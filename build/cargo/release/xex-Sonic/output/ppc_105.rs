pub fn sub_828C2798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C2798 size=72
    let mut pc: u32 = 0x828C2798;
    'dispatch: loop {
        match pc {
            0x828C2798 => {
    //   block [0x828C2798..0x828C27E0)
	// 828C2798: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C279C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C27A0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C27A4: 4BF2B075  bl 0x827ed818
	ctx.lr = 0x828C27A8;
	sub_827ED818(ctx, base);
	// 828C27A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C27AC: 3963FFF0  addi r11, r3, -0x10
	ctx.r[11].s64 = ctx.r[3].s64 + -16;
	// 828C27B0: 40820008  bne 0x828c27b8
	if !ctx.cr[0].eq {
	pc = 0x828C27B8; continue 'dispatch;
	}
	// 828C27B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C27B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C27BC: 419A0010  beq cr6, 0x828c27cc
	if ctx.cr[6].eq {
	pc = 0x828C27CC; continue 'dispatch;
	}
	// 828C27C0: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 828C27C4: 48046DBD  bl 0x82909580
	ctx.lr = 0x828C27C8;
	sub_82909580(ctx, base);
	// 828C27C8: 48000008  b 0x828c27d0
	pc = 0x828C27D0; continue 'dispatch;
	// 828C27CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C27D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C27D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C27D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C27DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C27E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C27E0 size=88
    let mut pc: u32 = 0x828C27E0;
    'dispatch: loop {
        match pc {
            0x828C27E0 => {
    //   block [0x828C27E0..0x828C2838)
	// 828C27E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C27E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C27E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C27EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C27F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C27F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C27F8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C27FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C2800: 396BD15C  addi r11, r11, -0x2ea4
	ctx.r[11].s64 = ctx.r[11].s64 + -11940;
	// 828C2804: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C2808: 48054361  bl 0x82916b68
	ctx.lr = 0x828C280C;
	sub_82916B68(ctx, base);
	// 828C280C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C2810: 4182000C  beq 0x828c281c
	if ctx.cr[0].eq {
	pc = 0x828C281C; continue 'dispatch;
	}
	// 828C2814: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C2818: 4B9FDA51  bl 0x822c0268
	ctx.lr = 0x828C281C;
	sub_822C0268(ctx, base);
	// 828C281C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C2820: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C2824: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C2828: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C282C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C2830: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C2834: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828C2838 size=36
    let mut pc: u32 = 0x828C2838;
    'dispatch: loop {
        match pc {
            0x828C2838 => {
    //   block [0x828C2838..0x828C285C)
	// 828C2838: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C283C: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828C2840: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C2844: C1AA89AC  lfs f13, -0x7654(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C2848: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828C284C: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828C2850: D1A30008  stfs f13, 8(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 828C2854: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828C2858: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C2860 size=108
    let mut pc: u32 = 0x828C2860;
    'dispatch: loop {
        match pc {
            0x828C2860 => {
    //   block [0x828C2860..0x828C28CC)
	// 828C2860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2868: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C286C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2870: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C2874: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828C2878: 4BF2AFA1  bl 0x827ed818
	ctx.lr = 0x828C287C;
	sub_827ED818(ctx, base);
	// 828C287C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C2880: 3963FFF0  addi r11, r3, -0x10
	ctx.r[11].s64 = ctx.r[3].s64 + -16;
	// 828C2884: 40820008  bne 0x828c288c
	if !ctx.cr[0].eq {
	pc = 0x828C288C; continue 'dispatch;
	}
	// 828C2888: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C288C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2890: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C2894: 419A0014  beq cr6, 0x828c28a8
	if ctx.cr[6].eq {
	pc = 0x828C28A8; continue 'dispatch;
	}
	// 828C2898: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 828C289C: 48046DBD  bl 0x82909658
	ctx.lr = 0x828C28A0;
	sub_82909658(ctx, base);
	// 828C28A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C28A4: 48000014  b 0x828c28b8
	pc = 0x828C28B8; continue 'dispatch;
	// 828C28A8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828C28AC: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 828C28B0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C28D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C28D0 size=160
    let mut pc: u32 = 0x828C28D0;
    'dispatch: loop {
        match pc {
            0x828C28D0 => {
    //   block [0x828C28D0..0x828C2970)
	// 828C28D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C28D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C28D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C28DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C28E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C28E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C28E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C28EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C28F0: 4BFFFF71  bl 0x828c2860
	ctx.lr = 0x828C28F4;
	sub_828C2860(ctx, base);
	// 828C28F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C28F8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C28FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C2900: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2904: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C2908: 4E800421  bctrl
	ctx.lr = 0x828C290C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C290C: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828C2910: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C2970 size=124
    let mut pc: u32 = 0x828C2970;
    'dispatch: loop {
        match pc {
            0x828C2970 => {
    //   block [0x828C2970..0x828C29EC)
	// 828C2970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2974: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2978: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C297C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C2980: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2984: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C2988: 4BF2AE91  bl 0x827ed818
	ctx.lr = 0x828C298C;
	sub_827ED818(ctx, base);
	// 828C298C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C2990: 3963FFF0  addi r11, r3, -0x10
	ctx.r[11].s64 = ctx.r[3].s64 + -16;
	// 828C2994: 40820008  bne 0x828c299c
	if !ctx.cr[0].eq {
	pc = 0x828C299C; continue 'dispatch;
	}
	// 828C2998: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C299C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C29A0: 419A0034  beq cr6, 0x828c29d4
	if ctx.cr[6].eq {
	pc = 0x828C29D4; continue 'dispatch;
	}
	// 828C29A4: 3BEB0010  addi r31, r11, 0x10
	ctx.r[31].s64 = ctx.r[11].s64 + 16;
	// 828C29A8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C29AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C29B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C29B4: 4BF2ACED  bl 0x827ed6a0
	ctx.lr = 0x828C29B8;
	sub_827ED6A0(ctx, base);
	// 828C29B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C29BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C29C0: 4809CA19  bl 0x8295f3d8
	ctx.lr = 0x828C29C4;
	sub_8295F3D8(ctx, base);
	// 828C29C4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C29C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C29CC: 419A0008  beq cr6, 0x828c29d4
	if ctx.cr[6].eq {
	pc = 0x828C29D4; continue 'dispatch;
	}
	// 828C29D0: 4B9FDEC1  bl 0x822c0890
	ctx.lr = 0x828C29D4;
	sub_822C0890(ctx, base);
	// 828C29D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C29D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C29DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C29E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C29E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C29E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C29F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828C29F0 size=40
    let mut pc: u32 = 0x828C29F0;
    'dispatch: loop {
        match pc {
            0x828C29F0 => {
    //   block [0x828C29F0..0x828C2A18)
	// 828C29F0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828C29F4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 828C29F8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828C29FC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C2A00: C00B9524  lfs f0, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C2A04: C1AAD7BC  lfs f13, -0x2844(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C2A08: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828C2A0C: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 828C2A10: D1A3000C  stfs f13, 0xc(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828C2A14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C2A18 size=192
    let mut pc: u32 = 0x828C2A18;
    'dispatch: loop {
        match pc {
            0x828C2A18 => {
    //   block [0x828C2A18..0x828C2AD8)
	// 828C2A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2A1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2A20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C2A24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2A28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C2A2C: 480974E5  bl 0x82959f10
	ctx.lr = 0x828C2A30;
	sub_82959F10(ctx, base);
	// 828C2A30: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828C2A34: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 828C2A38: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828C2A3C: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 828C2A40: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 828C2A44: C18B9524  lfs f12, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828C2A48: 3CC08208  lis r6, -0x7df8
	ctx.r[6].s64 = -2113404928;
	// 828C2A4C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828C2A50: C16AD7BC  lfs f11, -0x2844(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828C2A54: C1499C28  lfs f10, -0x63d8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-25560 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828C2A58: 387F00BC  addi r3, r31, 0xbc
	ctx.r[3].s64 = ctx.r[31].s64 + 188;
	// 828C2A5C: C1286150  lfs f9, 0x6150(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24912 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 828C2A60: C007A1C4  lfs f0, -0x5e3c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C2A64: C10689AC  lfs f8, -0x7654(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 828C2A68: C1AB6154  lfs f13, 0x6154(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24916 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C2A6C: D19F0078  stfs f12, 0x78(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828C2A70: D17F007C  stfs f11, 0x7c(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 828C2A74: D15F0080  stfs f10, 0x80(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 828C2A78: D13F0084  stfs f9, 0x84(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828C2A7C: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828C2A80: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 828C2A84: D11F0090  stfs f8, 0x90(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828C2A88: D1BF0094  stfs f13, 0x94(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828C2A8C: D1BF0098  stfs f13, 0x98(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 828C2A90: 4807C4D9  bl 0x8293ef68
	ctx.lr = 0x828C2A94;
	sub_8293EF68(ctx, base);
	// 828C2A94: 387F00D4  addi r3, r31, 0xd4
	ctx.r[3].s64 = ctx.r[31].s64 + 212;
	// 828C2A98: 4807E541  bl 0x82940fd8
	ctx.lr = 0x828C2A9C;
	sub_82940FD8(ctx, base);
	// 828C2A9C: 387F00E0  addi r3, r31, 0xe0
	ctx.r[3].s64 = ctx.r[31].s64 + 224;
	// 828C2AA0: 480804B1  bl 0x82942f50
	ctx.lr = 0x828C2AA4;
	sub_82942F50(ctx, base);
	// 828C2AA4: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 828C2AA8: 480808B1  bl 0x82943358
	ctx.lr = 0x828C2AAC;
	sub_82943358(ctx, base);
	// 828C2AAC: 387F00F8  addi r3, r31, 0xf8
	ctx.r[3].s64 = ctx.r[31].s64 + 248;
	// 828C2AB0: 4807FE41  bl 0x829428f0
	ctx.lr = 0x828C2AB4;
	sub_829428F0(ctx, base);
	// 828C2AB4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828C2AB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C2ABC: C00BE0B4  lfs f0, -0x1f4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8012 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C2AC0: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828C2AC4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C2AC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C2ACC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C2AD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C2AD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C2AD8 size=92
    let mut pc: u32 = 0x828C2AD8;
    'dispatch: loop {
        match pc {
            0x828C2AD8 => {
    //   block [0x828C2AD8..0x828C2B34)
	// 828C2AD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2ADC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2AE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C2AE4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2AE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C2AEC: 4BFFFF2D  bl 0x828c2a18
	ctx.lr = 0x828C2AF0;
	sub_828C2A18(ctx, base);
	// 828C2AF0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828C2AF4: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828C2AF8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828C2AFC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 828C2B00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C2B04: C00BDD6C  lfs f0, -0x2294(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C2B08: 911F0108  stw r8, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[8].u32 ) };
	// 828C2B0C: C1AA89AC  lfs f13, -0x7654(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C2B10: C1899524  lfs f12, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828C2B14: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 828C2B18: D1BF0110  stfs f13, 0x110(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 828C2B1C: D19F0114  stfs f12, 0x114(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 828C2B20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C2B24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C2B28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C2B2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C2B30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C2B38 size=60
    let mut pc: u32 = 0x828C2B38;
    'dispatch: loop {
        match pc {
            0x828C2B38 => {
    //   block [0x828C2B38..0x828C2B74)
	// 828C2B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2B3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2B40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C2B44: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2B48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C2B4C: 4BFFFF8D  bl 0x828c2ad8
	ctx.lr = 0x828C2B50;
	sub_828C2AD8(ctx, base);
	// 828C2B50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C2B54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C2B58: 997F0068  stb r11, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u8 ) };
	// 828C2B5C: 997F0058  stb r11, 0x58(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 828C2B60: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C2B64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C2B68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C2B6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C2B70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2B78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C2B78 size=56
    let mut pc: u32 = 0x828C2B78;
    'dispatch: loop {
        match pc {
            0x828C2B78 => {
    //   block [0x828C2B78..0x828C2BB0)
	// 828C2B78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2B7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2B80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C2B84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2B88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C2B8C: 4BFFFF4D  bl 0x828c2ad8
	ctx.lr = 0x828C2B90;
	sub_828C2AD8(ctx, base);
	// 828C2B90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C2B94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C2B98: 997F0068  stb r11, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u8 ) };
	// 828C2B9C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C2BA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C2BA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C2BA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C2BAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2BB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C2BB0 size=116
    let mut pc: u32 = 0x828C2BB0;
    'dispatch: loop {
        match pc {
            0x828C2BB0 => {
    //   block [0x828C2BB0..0x828C2C24)
	// 828C2BB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2BB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C2BB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C2BBC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2BC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C2BC4: 4BFFFE55  bl 0x828c2a18
	ctx.lr = 0x828C2BC8;
	sub_828C2A18(ctx, base);
	// 828C2BC8: 387F0108  addi r3, r31, 0x108
	ctx.r[3].s64 = ctx.r[31].s64 + 264;
	// 828C2BCC: 4809502D  bl 0x82957bf8
	ctx.lr = 0x828C2BD0;
	sub_82957BF8(ctx, base);
	// 828C2BD0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C2BD4: 3D208203  lis r9, -0x7dfd
	ctx.r[9].s64 = -2113732608;
	// 828C2BD8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C2BDC: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 828C2BE0: 38E0000A  li r7, 0xa
	ctx.r[7].s64 = 10;
	// 828C2BE4: 997F0068  stb r11, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u8 ) };
	// 828C2BE8: 38C00014  li r6, 0x14
	ctx.r[6].s64 = 20;
	// 828C2BEC: C00A093C  lfs f0, 0x93c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C2BF0: C1A97BC8  lfs f13, 0x7bc8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(31688 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C2BF4: 997F0058  stb r11, 0x58(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 828C2BF8: D01F0118  stfs f0, 0x118(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 828C2BFC: 911F0108  stw r8, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[8].u32 ) };
	// 828C2C00: D1BF011C  stfs f13, 0x11c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 828C2C04: 90FF010C  stw r7, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[7].u32 ) };
	// 828C2C08: 90DF0110  stw r6, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[6].u32 ) };
	// 828C2C0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C2C10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C2C14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C2C18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C2C1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C2C20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C2C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C2C28 size=1256
    let mut pc: u32 = 0x828C2C28;
    'dispatch: loop {
        match pc {
            0x828C2C28 => {
    //   block [0x828C2C28..0x828C3110)
	// 828C2C28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C2C2C: 488E5541  bl 0x831a816c
	ctx.lr = 0x828C2C30;
	sub_831A8130(ctx, base);
	// 828C2C30: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 828C2C34: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 828C2C38: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828C2C3C: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C2C40: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C2C44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C2C48: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2C4C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2C50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2C54: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C2C58: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C2C5C: 419A0024  beq cr6, 0x828c2c80
	if ctx.cr[6].eq {
	pc = 0x828C2C80; continue 'dispatch;
	}
	// 828C2C60: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828C2C64: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C2C68: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C2C6C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C2C70: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C2C74: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C2C78: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C2C7C: 4082FFE8  bne 0x828c2c64
	if !ctx.cr[0].eq {
	pc = 0x828C2C64; continue 'dispatch;
	}
	// 828C2C80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C2C84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C2C88: 48097E91  bl 0x8295ab18
	ctx.lr = 0x828C2C8C;
	sub_8295AB18(ctx, base);
	// 828C2C8C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828C2C90: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C2C94: 388B3D90  addi r4, r11, 0x3d90
	ctx.r[4].s64 = ctx.r[11].s64 + 15760;
	// 828C2C98: 48530D71  bl 0x82df3a08
	ctx.lr = 0x828C2C9C;
	sub_82DF3A08(ctx, base);
	// 828C2C9C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828C2CA0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828C2CA4: 388B3D88  addi r4, r11, 0x3d88
	ctx.r[4].s64 = ctx.r[11].s64 + 15752;
	// 828C2CA8: 48530D61  bl 0x82df3a08
	ctx.lr = 0x828C2CAC;
	sub_82DF3A08(ctx, base);
	// 828C2CAC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828C2CB0: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 828C2CB4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2CB8: 4BD07849  bl 0x825ca500
	ctx.lr = 0x828C2CBC;
	sub_825CA500(ctx, base);
	// 828C2CBC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C2CC0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828C2CC4: 48530765  bl 0x82df3428
	ctx.lr = 0x828C2CC8;
	sub_82DF3428(ctx, base);
	// 828C2CC8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C2CCC: 4853075D  bl 0x82df3428
	ctx.lr = 0x828C2CD0;
	sub_82DF3428(ctx, base);
	// 828C2CD0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C2CD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C2CD8: 388BD358  addi r4, r11, -0x2ca8
	ctx.r[4].s64 = ctx.r[11].s64 + -11432;
	// 828C2CDC: 48530D2D  bl 0x82df3a08
	ctx.lr = 0x828C2CE0;
	sub_82DF3A08(ctx, base);
	// 828C2CE0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C2CE4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C2CE8: 388BD344  addi r4, r11, -0x2cbc
	ctx.r[4].s64 = ctx.r[11].s64 + -11452;
	// 828C2CEC: 48530D1D  bl 0x82df3a08
	ctx.lr = 0x828C2CF0;
	sub_82DF3A08(ctx, base);
	// 828C2CF0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828C2CF4: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 828C2CF8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828C2CFC: 38BE0078  addi r5, r30, 0x78
	ctx.r[5].s64 = ctx.r[30].s64 + 120;
	// 828C2D00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C2D04: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828C2D08: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828C2D0C: C3CA6218  lfs f30, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828C2D10: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828C2D14: C3A908A4  lfs f29, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828C2D18: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828C2D1C: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828C2D20: 4BCE0589  bl 0x825a32a8
	ctx.lr = 0x828C2D24;
	sub_825A32A8(ctx, base);
	// 828C2D24: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828C2D28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C2D2C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828C2D30: 4BCDEA41  bl 0x825a1770
	ctx.lr = 0x828C2D34;
	sub_825A1770(ctx, base);
	// 828C2D34: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 828C2D38: 485306F1  bl 0x82df3428
	ctx.lr = 0x828C2D3C;
	sub_82DF3428(ctx, base);
	// 828C2D3C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828C2D40: 4BA05F79  bl 0x822c8cb8
	ctx.lr = 0x828C2D44;
	sub_822C8CB8(ctx, base);
	// 828C2D44: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C2D48: 485306E1  bl 0x82df3428
	ctx.lr = 0x828C2D4C;
	sub_82DF3428(ctx, base);
	// 828C2D4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C2D50: 485306D9  bl 0x82df3428
	ctx.lr = 0x828C2D54;
	sub_82DF3428(ctx, base);
	// 828C2D54: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C2D58: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C2D5C: 388BD32C  addi r4, r11, -0x2cd4
	ctx.r[4].s64 = ctx.r[11].s64 + -11476;
	// 828C2D60: 48530CA9  bl 0x82df3a08
	ctx.lr = 0x828C2D64;
	sub_82DF3A08(ctx, base);
	// 828C2D64: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C2D68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C2D6C: 388BD318  addi r4, r11, -0x2ce8
	ctx.r[4].s64 = ctx.r[11].s64 + -11496;
	// 828C2D70: 48530C99  bl 0x82df3a08
	ctx.lr = 0x828C2D74;
	sub_82DF3A08(ctx, base);
	// 828C2D74: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828C2D78: 38BE007C  addi r5, r30, 0x7c
	ctx.r[5].s64 = ctx.r[30].s64 + 124;
	// 828C2D7C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828C2D80: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828C2D84: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828C2D88: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 828C2D8C: C02B9528  lfs f1, -0x6ad8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C2D90: 4BCE0519  bl 0x825a32a8
	ctx.lr = 0x828C2D94;
	sub_825A32A8(ctx, base);
	// 828C2D94: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828C2D98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C2D9C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C2DA0: 4BCDE9D1  bl 0x825a1770
	ctx.lr = 0x828C2DA4;
	sub_825A1770(ctx, base);
	// 828C2DA4: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 828C2DA8: 48530681  bl 0x82df3428
	ctx.lr = 0x828C2DAC;
	sub_82DF3428(ctx, base);
	// 828C2DAC: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 828C2DB0: 4BA05F09  bl 0x822c8cb8
	ctx.lr = 0x828C2DB4;
	sub_822C8CB8(ctx, base);
	// 828C2DB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C2DB8: 48530671  bl 0x82df3428
	ctx.lr = 0x828C2DBC;
	sub_82DF3428(ctx, base);
	// 828C2DBC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C2DC0: 48530669  bl 0x82df3428
	ctx.lr = 0x828C2DC4;
	sub_82DF3428(ctx, base);
	// 828C2DC4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2DC8: 4BD06F09  bl 0x825c9cd0
	ctx.lr = 0x828C2DCC;
	sub_825C9CD0(ctx, base);
	// 828C2DCC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828C2DD0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C2DD4: 388B3DC4  addi r4, r11, 0x3dc4
	ctx.r[4].s64 = ctx.r[11].s64 + 15812;
	// 828C2DD8: 48530C31  bl 0x82df3a08
	ctx.lr = 0x828C2DDC;
	sub_82DF3A08(ctx, base);
	// 828C2DDC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C2DE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C2DE4: 388BD310  addi r4, r11, -0x2cf0
	ctx.r[4].s64 = ctx.r[11].s64 + -11504;
	// 828C2DE8: 48530C21  bl 0x82df3a08
	ctx.lr = 0x828C2DEC;
	sub_82DF3A08(ctx, base);
	// 828C2DEC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828C2DF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C2DF4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2DF8: 4BD07709  bl 0x825ca500
	ctx.lr = 0x828C2DFC;
	sub_825CA500(ctx, base);
	// 828C2DFC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C2E00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C2E04: 48530625  bl 0x82df3428
	ctx.lr = 0x828C2E08;
	sub_82DF3428(ctx, base);
	// 828C2E08: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C2E0C: 4853061D  bl 0x82df3428
	ctx.lr = 0x828C2E10;
	sub_82DF3428(ctx, base);
	// 828C2E10: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C2E14: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828C2E18: 388BD2F8  addi r4, r11, -0x2d08
	ctx.r[4].s64 = ctx.r[11].s64 + -11528;
	// 828C2E1C: 48530BED  bl 0x82df3a08
	ctx.lr = 0x828C2E20;
	sub_82DF3A08(ctx, base);
	// 828C2E20: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C2E24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C2E28: 388BD2E8  addi r4, r11, -0x2d18
	ctx.r[4].s64 = ctx.r[11].s64 + -11544;
	// 828C2E2C: 48530BDD  bl 0x82df3a08
	ctx.lr = 0x828C2E30;
	sub_82DF3A08(ctx, base);
	// 828C2E30: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828C2E34: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C2E38: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828C2E3C: 38BE0084  addi r5, r30, 0x84
	ctx.r[5].s64 = ctx.r[30].s64 + 132;
	// 828C2E40: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 828C2E44: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828C2E48: C06B9F7C  lfs f3, -0x6084(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24708 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828C2E4C: C04A08A8  lfs f2, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828C2E50: 4BCE0459  bl 0x825a32a8
	ctx.lr = 0x828C2E54;
	sub_825A32A8(ctx, base);
	// 828C2E54: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828C2E58: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C2E5C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C2E60: 4BCDE911  bl 0x825a1770
	ctx.lr = 0x828C2E64;
	sub_825A1770(ctx, base);
	// 828C2E64: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 828C2E68: 485305C1  bl 0x82df3428
	ctx.lr = 0x828C2E6C;
	sub_82DF3428(ctx, base);
	// 828C2E6C: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828C2E70: 4BA05E49  bl 0x822c8cb8
	ctx.lr = 0x828C2E74;
	sub_822C8CB8(ctx, base);
	// 828C2E74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C2E78: 485305B1  bl 0x82df3428
	ctx.lr = 0x828C2E7C;
	sub_82DF3428(ctx, base);
	// 828C2E7C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828C2E80: 485305A9  bl 0x82df3428
	ctx.lr = 0x828C2E84;
	sub_82DF3428(ctx, base);
	// 828C2E84: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C2E88: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828C2E8C: 388BD2C4  addi r4, r11, -0x2d3c
	ctx.r[4].s64 = ctx.r[11].s64 + -11580;
	// 828C2E90: 48530B79  bl 0x82df3a08
	ctx.lr = 0x828C2E94;
	sub_82DF3A08(ctx, base);
	// 828C2E94: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C2E98: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C2E9C: 388BD2B4  addi r4, r11, -0x2d4c
	ctx.r[4].s64 = ctx.r[11].s64 + -11596;
	// 828C2EA0: 48530B69  bl 0x82df3a08
	ctx.lr = 0x828C2EA4;
	sub_82DF3A08(ctx, base);
	// 828C2EA4: 38BE0088  addi r5, r30, 0x88
	ctx.r[5].s64 = ctx.r[30].s64 + 136;
	// 828C2EA8: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 828C2EAC: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828C2EB0: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828C2EB4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828C2EB8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828C2EBC: 4BCE03ED  bl 0x825a32a8
	ctx.lr = 0x828C2EC0;
	sub_825A32A8(ctx, base);
	// 828C2EC0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828C2EC4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C2EC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C2ECC: 4BCDE8A5  bl 0x825a1770
	ctx.lr = 0x828C2ED0;
	sub_825A1770(ctx, base);
	// 828C2ED0: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 828C2ED4: 48530555  bl 0x82df3428
	ctx.lr = 0x828C2ED8;
	sub_82DF3428(ctx, base);
	// 828C2ED8: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 828C2EDC: 4BA05DDD  bl 0x822c8cb8
	ctx.lr = 0x828C2EE0;
	sub_822C8CB8(ctx, base);
	// 828C2EE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C2EE4: 48530545  bl 0x82df3428
	ctx.lr = 0x828C2EE8;
	sub_82DF3428(ctx, base);
	// 828C2EE8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828C2EEC: 4853053D  bl 0x82df3428
	ctx.lr = 0x828C2EF0;
	sub_82DF3428(ctx, base);
	// 828C2EF0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C2EF4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828C2EF8: 388BD2A8  addi r4, r11, -0x2d58
	ctx.r[4].s64 = ctx.r[11].s64 + -11608;
	// 828C2EFC: 48530B0D  bl 0x82df3a08
	ctx.lr = 0x828C2F00;
	sub_82DF3A08(ctx, base);
	// 828C2F00: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C2F04: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C2F08: 388BD29C  addi r4, r11, -0x2d64
	ctx.r[4].s64 = ctx.r[11].s64 + -11620;
	// 828C2F0C: 48530AFD  bl 0x82df3a08
	ctx.lr = 0x828C2F10;
	sub_82DF3A08(ctx, base);
	// 828C2F10: 38BE008C  addi r5, r30, 0x8c
	ctx.r[5].s64 = ctx.r[30].s64 + 140;
	// 828C2F14: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 828C2F18: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828C2F1C: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 828C2F20: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828C2F24: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828C2F28: 4BCE0381  bl 0x825a32a8
	ctx.lr = 0x828C2F2C;
	sub_825A32A8(ctx, base);
	// 828C2F2C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828C2F30: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C2F34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C2F38: 4BCDE839  bl 0x825a1770
	ctx.lr = 0x828C2F3C;
	sub_825A1770(ctx, base);
	// 828C2F3C: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 828C2F40: 485304E9  bl 0x82df3428
	ctx.lr = 0x828C2F44;
	sub_82DF3428(ctx, base);
	// 828C2F44: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 828C2F48: 4BA05D71  bl 0x822c8cb8
	ctx.lr = 0x828C2F4C;
	sub_822C8CB8(ctx, base);
	// 828C2F4C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C2F50: 485304D9  bl 0x82df3428
	ctx.lr = 0x828C2F54;
	sub_82DF3428(ctx, base);
	// 828C2F54: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828C2F58: 485304D1  bl 0x82df3428
	ctx.lr = 0x828C2F5C;
	sub_82DF3428(ctx, base);
	// 828C2F5C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2F60: 4BD06D71  bl 0x825c9cd0
	ctx.lr = 0x828C2F64;
	sub_825C9CD0(ctx, base);
	// 828C2F64: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2F68: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2F6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2F70: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C2F74: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C2F78: 419A0024  beq cr6, 0x828c2f9c
	if ctx.cr[6].eq {
	pc = 0x828C2F9C; continue 'dispatch;
	}
	// 828C2F7C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828C2F80: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C2F84: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C2F88: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C2F8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C2F90: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C2F94: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C2F98: 4082FFE8  bne 0x828c2f80
	if !ctx.cr[0].eq {
	pc = 0x828C2F80; continue 'dispatch;
	}
	// 828C2F9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C2FA0: 387E009C  addi r3, r30, 0x9c
	ctx.r[3].s64 = ctx.r[30].s64 + 156;
	// 828C2FA4: 4805211D  bl 0x829150c0
	ctx.lr = 0x828C2FA8;
	sub_829150C0(ctx, base);
	// 828C2FA8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2FAC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2FB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2FB4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C2FB8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C2FBC: 419A0024  beq cr6, 0x828c2fe0
	if ctx.cr[6].eq {
	pc = 0x828C2FE0; continue 'dispatch;
	}
	// 828C2FC0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828C2FC4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C2FC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C2FCC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C2FD0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C2FD4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C2FD8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C2FDC: 4082FFE8  bne 0x828c2fc4
	if !ctx.cr[0].eq {
	pc = 0x828C2FC4; continue 'dispatch;
	}
	// 828C2FE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C2FE4: 387E00BC  addi r3, r30, 0xbc
	ctx.r[3].s64 = ctx.r[30].s64 + 188;
	// 828C2FE8: 4807CBC1  bl 0x8293fba8
	ctx.lr = 0x828C2FEC;
	sub_8293FBA8(ctx, base);
	// 828C2FEC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C2FF0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C2FF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C2FF8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C2FFC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C3000: 419A0024  beq cr6, 0x828c3024
	if ctx.cr[6].eq {
	pc = 0x828C3024; continue 'dispatch;
	}
	// 828C3004: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828C3008: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C300C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C3010: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C3014: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C3018: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C301C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C3020: 4082FFE8  bne 0x828c3008
	if !ctx.cr[0].eq {
	pc = 0x828C3008; continue 'dispatch;
	}
	// 828C3024: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C3028: 387E00D4  addi r3, r30, 0xd4
	ctx.r[3].s64 = ctx.r[30].s64 + 212;
	// 828C302C: 4807E37D  bl 0x829413a8
	ctx.lr = 0x828C3030;
	sub_829413A8(ctx, base);
	// 828C3030: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C3034: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3038: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C303C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C3040: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C3044: 419A0024  beq cr6, 0x828c3068
	if ctx.cr[6].eq {
	pc = 0x828C3068; continue 'dispatch;
	}
	// 828C3048: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828C304C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C3050: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C3054: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C3058: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C305C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C3060: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C3064: 4082FFE8  bne 0x828c304c
	if !ctx.cr[0].eq {
	pc = 0x828C304C; continue 'dispatch;
	}
	// 828C3068: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C306C: 387E00E0  addi r3, r30, 0xe0
	ctx.r[3].s64 = ctx.r[30].s64 + 224;
	// 828C3070: 48080261  bl 0x829432d0
	ctx.lr = 0x828C3074;
	sub_829432D0(ctx, base);
	// 828C3074: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C3078: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C307C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3080: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C3084: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C3088: 419A0024  beq cr6, 0x828c30ac
	if ctx.cr[6].eq {
	pc = 0x828C30AC; continue 'dispatch;
	}
	// 828C308C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828C3090: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C3094: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C3098: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C309C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C30A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C30A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C30A8: 4082FFE8  bne 0x828c3090
	if !ctx.cr[0].eq {
	pc = 0x828C3090; continue 'dispatch;
	}
	// 828C30AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C30B0: 387E00E8  addi r3, r30, 0xe8
	ctx.r[3].s64 = ctx.r[30].s64 + 232;
	// 828C30B4: 480809DD  bl 0x82943a90
	ctx.lr = 0x828C30B8;
	sub_82943A90(ctx, base);
	// 828C30B8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C30BC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C30C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C30C4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C30C8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C30CC: 419A0024  beq cr6, 0x828c30f0
	if ctx.cr[6].eq {
	pc = 0x828C30F0; continue 'dispatch;
	}
	// 828C30D0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828C30D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C30D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C30DC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C30E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C30E4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C30E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C30EC: 4082FFE8  bne 0x828c30d4
	if !ctx.cr[0].eq {
	pc = 0x828C30D4; continue 'dispatch;
	}
	// 828C30F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C30F4: 387E00F8  addi r3, r30, 0xf8
	ctx.r[3].s64 = ctx.r[30].s64 + 248;
	// 828C30F8: 4807FB29  bl 0x82942c20
	ctx.lr = 0x828C30FC;
	sub_82942C20(ctx, base);
	// 828C30FC: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 828C3100: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828C3104: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828C3108: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828C310C: 488E50B0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C3110 size=480
    let mut pc: u32 = 0x828C3110;
    'dispatch: loop {
        match pc {
            0x828C3110 => {
    //   block [0x828C3110..0x828C32F0)
	// 828C3110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C3114: 488E5059  bl 0x831a816c
	ctx.lr = 0x828C3118;
	sub_831A8130(ctx, base);
	// 828C3118: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 828C311C: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 828C3120: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828C3124: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C3128: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C312C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C3130: 4BFFFAF9  bl 0x828c2c28
	ctx.lr = 0x828C3134;
	sub_828C2C28(ctx, base);
	// 828C3134: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 828C3138: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828C313C: 388B7A1C  addi r4, r11, 0x7a1c
	ctx.r[4].s64 = ctx.r[11].s64 + 31260;
	// 828C3140: 485308C9  bl 0x82df3a08
	ctx.lr = 0x828C3144;
	sub_82DF3A08(ctx, base);
	// 828C3144: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828C3148: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C314C: 388BCB24  addi r4, r11, -0x34dc
	ctx.r[4].s64 = ctx.r[11].s64 + -13532;
	// 828C3150: 485308B9  bl 0x82df3a08
	ctx.lr = 0x828C3154;
	sub_82DF3A08(ctx, base);
	// 828C3154: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 828C3158: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828C315C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3160: 4BD073A1  bl 0x825ca500
	ctx.lr = 0x828C3164;
	sub_825CA500(ctx, base);
	// 828C3164: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C3168: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C316C: 485302BD  bl 0x82df3428
	ctx.lr = 0x828C3170;
	sub_82DF3428(ctx, base);
	// 828C3170: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828C3174: 485302B5  bl 0x82df3428
	ctx.lr = 0x828C3178;
	sub_82DF3428(ctx, base);
	// 828C3178: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C317C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C3180: 388BD3E4  addi r4, r11, -0x2c1c
	ctx.r[4].s64 = ctx.r[11].s64 + -11292;
	// 828C3184: 48530885  bl 0x82df3a08
	ctx.lr = 0x828C3188;
	sub_82DF3A08(ctx, base);
	// 828C3188: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C318C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C3190: 388BD3D0  addi r4, r11, -0x2c30
	ctx.r[4].s64 = ctx.r[11].s64 + -11312;
	// 828C3194: 48530875  bl 0x82df3a08
	ctx.lr = 0x828C3198;
	sub_82DF3A08(ctx, base);
	// 828C3198: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C319C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 828C31A0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828C31A4: 38BF010C  addi r5, r31, 0x10c
	ctx.r[5].s64 = ctx.r[31].s64 + 268;
	// 828C31A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C31AC: C3EB08A8  lfs f31, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828C31B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C31B4: C3CADD6C  lfs f30, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828C31B8: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828C31BC: C3A908A4  lfs f29, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828C31C0: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828C31C4: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828C31C8: 4BCE00E1  bl 0x825a32a8
	ctx.lr = 0x828C31CC;
	sub_825A32A8(ctx, base);
	// 828C31CC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828C31D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C31D4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C31D8: 4BCDE599  bl 0x825a1770
	ctx.lr = 0x828C31DC;
	sub_825A1770(ctx, base);
	// 828C31DC: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 828C31E0: 48530249  bl 0x82df3428
	ctx.lr = 0x828C31E4;
	sub_82DF3428(ctx, base);
	// 828C31E4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828C31E8: 4BA05AD1  bl 0x822c8cb8
	ctx.lr = 0x828C31EC;
	sub_822C8CB8(ctx, base);
	// 828C31EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C31F0: 48530239  bl 0x82df3428
	ctx.lr = 0x828C31F4;
	sub_82DF3428(ctx, base);
	// 828C31F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C31F8: 48530231  bl 0x82df3428
	ctx.lr = 0x828C31FC;
	sub_82DF3428(ctx, base);
	// 828C31FC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C3200: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C3204: 388BD3BC  addi r4, r11, -0x2c44
	ctx.r[4].s64 = ctx.r[11].s64 + -11332;
	// 828C3208: 48530801  bl 0x82df3a08
	ctx.lr = 0x828C320C;
	sub_82DF3A08(ctx, base);
	// 828C320C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C3210: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C3214: 388BD3A4  addi r4, r11, -0x2c5c
	ctx.r[4].s64 = ctx.r[11].s64 + -11356;
	// 828C3218: 485307F1  bl 0x82df3a08
	ctx.lr = 0x828C321C;
	sub_82DF3A08(ctx, base);
	// 828C321C: 38BF0110  addi r5, r31, 0x110
	ctx.r[5].s64 = ctx.r[31].s64 + 272;
	// 828C3220: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C3224: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828C3228: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828C322C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828C3230: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828C3234: 4BCE0075  bl 0x825a32a8
	ctx.lr = 0x828C3238;
	sub_825A32A8(ctx, base);
	// 828C3238: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828C323C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C3240: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C3244: 4BCDE52D  bl 0x825a1770
	ctx.lr = 0x828C3248;
	sub_825A1770(ctx, base);
	// 828C3248: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 828C324C: 485301DD  bl 0x82df3428
	ctx.lr = 0x828C3250;
	sub_82DF3428(ctx, base);
	// 828C3250: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 828C3254: 4BA05A65  bl 0x822c8cb8
	ctx.lr = 0x828C3258;
	sub_822C8CB8(ctx, base);
	// 828C3258: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C325C: 485301CD  bl 0x82df3428
	ctx.lr = 0x828C3260;
	sub_82DF3428(ctx, base);
	// 828C3260: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C3264: 485301C5  bl 0x82df3428
	ctx.lr = 0x828C3268;
	sub_82DF3428(ctx, base);
	// 828C3268: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C326C: 388BD384  addi r4, r11, -0x2c7c
	ctx.r[4].s64 = ctx.r[11].s64 + -11388;
	// 828C3270: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C3274: 48530795  bl 0x82df3a08
	ctx.lr = 0x828C3278;
	sub_82DF3A08(ctx, base);
	// 828C3278: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C327C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C3280: 388BD36C  addi r4, r11, -0x2c94
	ctx.r[4].s64 = ctx.r[11].s64 + -11412;
	// 828C3284: 48530785  bl 0x82df3a08
	ctx.lr = 0x828C3288;
	sub_82DF3A08(ctx, base);
	// 828C3288: 38BF0114  addi r5, r31, 0x114
	ctx.r[5].s64 = ctx.r[31].s64 + 276;
	// 828C328C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C3290: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828C3294: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 828C3298: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828C329C: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828C32A0: 4BCE0009  bl 0x825a32a8
	ctx.lr = 0x828C32A4;
	sub_825A32A8(ctx, base);
	// 828C32A4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828C32A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C32AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C32B0: 4BCDE4C1  bl 0x825a1770
	ctx.lr = 0x828C32B4;
	sub_825A1770(ctx, base);
	// 828C32B4: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 828C32B8: 48530171  bl 0x82df3428
	ctx.lr = 0x828C32BC;
	sub_82DF3428(ctx, base);
	// 828C32BC: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 828C32C0: 4BA059F9  bl 0x822c8cb8
	ctx.lr = 0x828C32C4;
	sub_822C8CB8(ctx, base);
	// 828C32C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C32C8: 48530161  bl 0x82df3428
	ctx.lr = 0x828C32CC;
	sub_82DF3428(ctx, base);
	// 828C32CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C32D0: 48530159  bl 0x82df3428
	ctx.lr = 0x828C32D4;
	sub_82DF3428(ctx, base);
	// 828C32D4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C32D8: 4BD069F9  bl 0x825c9cd0
	ctx.lr = 0x828C32DC;
	sub_825C9CD0(ctx, base);
	// 828C32DC: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 828C32E0: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828C32E4: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828C32E8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828C32EC: 488E4ED0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C32F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C32F0 size=4
    let mut pc: u32 = 0x828C32F0;
    'dispatch: loop {
        match pc {
            0x828C32F0 => {
    //   block [0x828C32F0..0x828C32F4)
	// 828C32F0: 4BFFFE20  b 0x828c3110
	sub_828C3110(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C32F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C32F8 size=496
    let mut pc: u32 = 0x828C32F8;
    'dispatch: loop {
        match pc {
            0x828C32F8 => {
    //   block [0x828C32F8..0x828C34E8)
	// 828C32F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C32FC: 488E4E71  bl 0x831a816c
	ctx.lr = 0x828C3300;
	sub_831A8130(ctx, base);
	// 828C3300: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 828C3304: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 828C3308: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828C330C: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C3310: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C3314: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C3318: 4BFFF911  bl 0x828c2c28
	ctx.lr = 0x828C331C;
	sub_828C2C28(ctx, base);
	// 828C331C: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 828C3320: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C3324: 388B7A1C  addi r4, r11, 0x7a1c
	ctx.r[4].s64 = ctx.r[11].s64 + 31260;
	// 828C3328: 485306E1  bl 0x82df3a08
	ctx.lr = 0x828C332C;
	sub_82DF3A08(ctx, base);
	// 828C332C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828C3330: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C3334: 388B1A04  addi r4, r11, 0x1a04
	ctx.r[4].s64 = ctx.r[11].s64 + 6660;
	// 828C3338: 485306D1  bl 0x82df3a08
	ctx.lr = 0x828C333C;
	sub_82DF3A08(ctx, base);
	// 828C333C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C3340: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3344: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C3348: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828C334C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828C3350: 419A0024  beq cr6, 0x828c3374
	if ctx.cr[6].eq {
	pc = 0x828C3374; continue 'dispatch;
	}
	// 828C3354: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828C3358: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C335C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C3360: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C3364: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C3368: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C336C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C3370: 4082FFE8  bne 0x828c3358
	if !ctx.cr[0].eq {
	pc = 0x828C3358; continue 'dispatch;
	}
	// 828C3374: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 828C3378: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828C337C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828C3380: 387E0108  addi r3, r30, 0x108
	ctx.r[3].s64 = ctx.r[30].s64 + 264;
	// 828C3384: 4809488D  bl 0x82957c10
	ctx.lr = 0x828C3388;
	sub_82957C10(ctx, base);
	// 828C3388: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C338C: 4853009D  bl 0x82df3428
	ctx.lr = 0x828C3390;
	sub_82DF3428(ctx, base);
	// 828C3390: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C3394: 48530095  bl 0x82df3428
	ctx.lr = 0x828C3398;
	sub_82DF3428(ctx, base);
	// 828C3398: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828C339C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C33A0: 388B3D90  addi r4, r11, 0x3d90
	ctx.r[4].s64 = ctx.r[11].s64 + 15760;
	// 828C33A4: 48530665  bl 0x82df3a08
	ctx.lr = 0x828C33A8;
	sub_82DF3A08(ctx, base);
	// 828C33A8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828C33AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C33B0: 388B3D88  addi r4, r11, 0x3d88
	ctx.r[4].s64 = ctx.r[11].s64 + 15752;
	// 828C33B4: 48530655  bl 0x82df3a08
	ctx.lr = 0x828C33B8;
	sub_82DF3A08(ctx, base);
	// 828C33B8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828C33BC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C33C0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C33C4: 4BD0713D  bl 0x825ca500
	ctx.lr = 0x828C33C8;
	sub_825CA500(ctx, base);
	// 828C33C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C33CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C33D0: 48530059  bl 0x82df3428
	ctx.lr = 0x828C33D4;
	sub_82DF3428(ctx, base);
	// 828C33D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C33D8: 48530051  bl 0x82df3428
	ctx.lr = 0x828C33DC;
	sub_82DF3428(ctx, base);
	// 828C33DC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C33E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C33E4: 388BD42C  addi r4, r11, -0x2bd4
	ctx.r[4].s64 = ctx.r[11].s64 + -11220;
	// 828C33E8: 48530621  bl 0x82df3a08
	ctx.lr = 0x828C33EC;
	sub_82DF3A08(ctx, base);
	// 828C33EC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C33F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C33F4: 388BD41C  addi r4, r11, -0x2be4
	ctx.r[4].s64 = ctx.r[11].s64 + -11236;
	// 828C33F8: 48530611  bl 0x82df3a08
	ctx.lr = 0x828C33FC;
	sub_82DF3A08(ctx, base);
	// 828C33FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828C3400: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 828C3404: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828C3408: 38BE0118  addi r5, r30, 0x118
	ctx.r[5].s64 = ctx.r[30].s64 + 280;
	// 828C340C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828C3410: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828C3414: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828C3418: C3CA6218  lfs f30, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828C341C: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828C3420: C3A908A4  lfs f29, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828C3424: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828C3428: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828C342C: 4BCDFE7D  bl 0x825a32a8
	ctx.lr = 0x828C3430;
	sub_825A32A8(ctx, base);
	// 828C3430: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828C3434: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C3438: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C343C: 4BCDE335  bl 0x825a1770
	ctx.lr = 0x828C3440;
	sub_825A1770(ctx, base);
	// 828C3440: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 828C3444: 4852FFE5  bl 0x82df3428
	ctx.lr = 0x828C3448;
	sub_82DF3428(ctx, base);
	// 828C3448: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828C344C: 4BA0586D  bl 0x822c8cb8
	ctx.lr = 0x828C3450;
	sub_822C8CB8(ctx, base);
	// 828C3450: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C3454: 4852FFD5  bl 0x82df3428
	ctx.lr = 0x828C3458;
	sub_82DF3428(ctx, base);
	// 828C3458: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C345C: 4852FFCD  bl 0x82df3428
	ctx.lr = 0x828C3460;
	sub_82DF3428(ctx, base);
	// 828C3460: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C3464: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C3468: 388BD408  addi r4, r11, -0x2bf8
	ctx.r[4].s64 = ctx.r[11].s64 + -11256;
	// 828C346C: 4853059D  bl 0x82df3a08
	ctx.lr = 0x828C3470;
	sub_82DF3A08(ctx, base);
	// 828C3470: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C3474: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C3478: 388BD3F8  addi r4, r11, -0x2c08
	ctx.r[4].s64 = ctx.r[11].s64 + -11272;
	// 828C347C: 4853058D  bl 0x82df3a08
	ctx.lr = 0x828C3480;
	sub_82DF3A08(ctx, base);
	// 828C3480: 38BE011C  addi r5, r30, 0x11c
	ctx.r[5].s64 = ctx.r[30].s64 + 284;
	// 828C3484: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C3488: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828C348C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828C3490: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828C3494: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828C3498: 4BCDFE11  bl 0x825a32a8
	ctx.lr = 0x828C349C;
	sub_825A32A8(ctx, base);
	// 828C349C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828C34A0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828C34A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C34A8: 4BCDE2C9  bl 0x825a1770
	ctx.lr = 0x828C34AC;
	sub_825A1770(ctx, base);
	// 828C34AC: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 828C34B0: 4852FF79  bl 0x82df3428
	ctx.lr = 0x828C34B4;
	sub_82DF3428(ctx, base);
	// 828C34B4: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828C34B8: 4BA05801  bl 0x822c8cb8
	ctx.lr = 0x828C34BC;
	sub_822C8CB8(ctx, base);
	// 828C34BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C34C0: 4852FF69  bl 0x82df3428
	ctx.lr = 0x828C34C4;
	sub_82DF3428(ctx, base);
	// 828C34C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C34C8: 4852FF61  bl 0x82df3428
	ctx.lr = 0x828C34CC;
	sub_82DF3428(ctx, base);
	// 828C34CC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C34D0: 4BD06801  bl 0x825c9cd0
	ctx.lr = 0x828C34D4;
	sub_825C9CD0(ctx, base);
	// 828C34D4: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 828C34D8: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828C34DC: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828C34E0: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828C34E4: 488E4CD8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C34E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C34E8 size=60
    let mut pc: u32 = 0x828C34E8;
    'dispatch: loop {
        match pc {
            0x828C34E8 => {
    //   block [0x828C34E8..0x828C3524)
	// 828C34E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C34EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C34F0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C34F4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828C34F8: 48053271  bl 0x82916768
	ctx.lr = 0x828C34FC;
	sub_82916768(ctx, base);
	// 828C34FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C3500: 41820014  beq 0x828c3514
	if ctx.cr[0].eq {
	pc = 0x828C3514; continue 'dispatch;
	}
	// 828C3504: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C3508: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 828C350C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C3510: 4804B869  bl 0x8290ed78
	ctx.lr = 0x828C3514;
	sub_8290ED78(ctx, base);
	// 828C3514: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C3518: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C351C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C3520: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C3528 size=64
    let mut pc: u32 = 0x828C3528;
    'dispatch: loop {
        match pc {
            0x828C3528 => {
    //   block [0x828C3528..0x828C3568)
	// 828C3528: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C352C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C3530: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C3534: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C3538: 892A0051  lbz r9, 0x51(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(81 as u32) ) } as u64;
	// 828C353C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C3540: 409A0008  bne cr6, 0x828c3548
	if !ctx.cr[6].eq {
	pc = 0x828C3548; continue 'dispatch;
	}
	// 828C3544: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 828C3548: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C354C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C3550: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C3554: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C3558: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C355C: 409A000C  bne cr6, 0x828c3568
	if !ctx.cr[6].eq {
		sub_828C3568(ctx, base);
		return;
	}
	// 828C3560: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828C3564: 48000020  b 0x828c3584
	sub_828C3580(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C3568 size=24
    let mut pc: u32 = 0x828C3568;
    'dispatch: loop {
        match pc {
            0x828C3568 => {
    //   block [0x828C3568..0x828C3580)
	// 828C3568: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C356C: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C3570: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C3574: 409A000C  bne cr6, 0x828c3580
	if !ctx.cr[6].eq {
		sub_828C3580(ctx, base);
		return;
	}
	// 828C3578: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828C357C: 48000008  b 0x828c3584
	sub_828C3580(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C3580 size=16
    let mut pc: u32 = 0x828C3580;
    'dispatch: loop {
        match pc {
            0x828C3580 => {
    //   block [0x828C3580..0x828C3590)
	// 828C3580: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C3584: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 828C3588: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828C358C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C3590 size=64
    let mut pc: u32 = 0x828C3590;
    'dispatch: loop {
        match pc {
            0x828C3590 => {
    //   block [0x828C3590..0x828C35D0)
	// 828C3590: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C3594: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3598: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C359C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C35A0: 892A0051  lbz r9, 0x51(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(81 as u32) ) } as u64;
	// 828C35A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C35A8: 409A0008  bne cr6, 0x828c35b0
	if !ctx.cr[6].eq {
	pc = 0x828C35B0; continue 'dispatch;
	}
	// 828C35AC: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 828C35B0: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C35B4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C35B8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C35BC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C35C0: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C35C4: 409A000C  bne cr6, 0x828c35d0
	if !ctx.cr[6].eq {
		sub_828C35D0(ctx, base);
		return;
	}
	// 828C35C8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828C35CC: 48000020  b 0x828c35ec
	sub_828C35E8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C35D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C35D0 size=24
    let mut pc: u32 = 0x828C35D0;
    'dispatch: loop {
        match pc {
            0x828C35D0 => {
    //   block [0x828C35D0..0x828C35E8)
	// 828C35D0: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C35D4: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C35D8: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C35DC: 409A000C  bne cr6, 0x828c35e8
	if !ctx.cr[6].eq {
		sub_828C35E8(ctx, base);
		return;
	}
	// 828C35E0: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C35E4: 48000008  b 0x828c35ec
	sub_828C35E8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C35E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C35E8 size=16
    let mut pc: u32 = 0x828C35E8;
    'dispatch: loop {
        match pc {
            0x828C35E8 => {
    //   block [0x828C35E8..0x828C35F8)
	// 828C35E8: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828C35EC: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 828C35F0: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828C35F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C35F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C35F8 size=196
    let mut pc: u32 = 0x828C35F8;
    'dispatch: loop {
        match pc {
            0x828C35F8 => {
    //   block [0x828C35F8..0x828C36BC)
	// 828C35F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C35FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C3600: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C3604: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C3608: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C360C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C3610: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C3614: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C3618: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C361C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C3620: 4B9FD319  bl 0x822c0938
	ctx.lr = 0x828C3624;
	sub_822C0938(ctx, base);
	// 828C3624: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C3628: 41820028  beq 0x828c3650
	if ctx.cr[0].eq {
	pc = 0x828C3650; continue 'dispatch;
	}
	// 828C362C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C3630: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828C3634: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C3638: 392BD448  addi r9, r11, -0x2bb8
	ctx.r[9].s64 = ctx.r[11].s64 + -11192;
	// 828C363C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C3640: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C3644: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C3648: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C364C: 48000008  b 0x828c3654
	pc = 0x828C3654; continue 'dispatch;
	// 828C3650: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C3654: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C3658: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C365C: 409A0044  bne cr6, 0x828c36a0
	if !ctx.cr[6].eq {
	pc = 0x828C36A0; continue 'dispatch;
	}
	// 828C3660: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C3664: 419A001C  beq cr6, 0x828c3680
	if ctx.cr[6].eq {
	pc = 0x828C3680; continue 'dispatch;
	}
	// 828C3668: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C366C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C3670: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C3674: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C3678: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C367C: 4E800421  bctrl
	ctx.lr = 0x828C3680;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C3680: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C3684: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C3688: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C368C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828C3690: 816B388C  lwz r11, 0x388c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14476 as u32) ) } as u64;
	// 828C3694: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C3698: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C369C: 4B9FC965  bl 0x822c0000
	ctx.lr = 0x828C36A0;
	sub_822C0000(ctx, base);
	// 828C36A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C36A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C36A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C36AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C36B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C36B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C36B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C36C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C36C0 size=564
    let mut pc: u32 = 0x828C36C0;
    'dispatch: loop {
        match pc {
            0x828C36C0 => {
    //   block [0x828C36C0..0x828C38F4)
	// 828C36C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C36C4: 488E4AA1  bl 0x831a8164
	ctx.lr = 0x828C36C8;
	sub_831A8130(ctx, base);
	// 828C36C8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C36CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C36D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C36D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C36D8: 48053091  bl 0x82916768
	ctx.lr = 0x828C36DC;
	sub_82916768(ctx, base);
	// 828C36DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C36E0: 41820014  beq 0x828c36f4
	if ctx.cr[0].eq {
	pc = 0x828C36F4; continue 'dispatch;
	}
	// 828C36E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C36E8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828C36EC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C36F0: 4804B689  bl 0x8290ed78
	ctx.lr = 0x828C36F4;
	sub_8290ED78(ctx, base);
	// 828C36F4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828C36F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C36FC: 808BF3F8  lwz r4, -0xc08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3080 as u32) ) } as u64;
	// 828C3700: 48530309  bl 0x82df3a08
	ctx.lr = 0x828C3704;
	sub_82DF3A08(ctx, base);
	// 828C3704: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3708: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C370C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C3710: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C3714: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C3718: 4E800421  bctrl
	ctx.lr = 0x828C371C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C371C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C3720: 4852FD09  bl 0x82df3428
	ctx.lr = 0x828C3724;
	sub_82DF3428(ctx, base);
	// 828C3724: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828C3728: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C372C: 937F006C  stw r27, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[27].u32 ) };
	// 828C3730: 937F0070  stw r27, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 828C3734: 48053035  bl 0x82916768
	ctx.lr = 0x828C3738;
	sub_82916768(ctx, base);
	// 828C3738: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C373C: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C3740: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C3744: 4E800421  bctrl
	ctx.lr = 0x828C3748;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C3748: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828C374C: 418201A0  beq 0x828c38ec
	if ctx.cr[0].eq {
	pc = 0x828C38EC; continue 'dispatch;
	}
	// 828C3750: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C3754: 4BFFEF1D  bl 0x828c2670
	ctx.lr = 0x828C3758;
	sub_828C2670(ctx, base);
	// 828C3758: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C375C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C3760: 4807C631  bl 0x8293fd90
	ctx.lr = 0x828C3764;
	sub_8293FD90(ctx, base);
	// 828C3764: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C3768: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C376C: 3BABD458  addi r29, r11, -0x2ba8
	ctx.r[29].s64 = ctx.r[11].s64 + -11176;
	// 828C3770: 38A00075  li r5, 0x75
	ctx.r[5].s64 = 117;
	// 828C3774: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C3778: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 828C377C: 4B9FCC5D  bl 0x822c03d8
	ctx.lr = 0x828C3780;
	sub_822C03D8(ctx, base);
	// 828C3780: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C3784: 41820018  beq 0x828c379c
	if ctx.cr[0].eq {
	pc = 0x828C379C; continue 'dispatch;
	}
	// 828C3788: 38BC00D4  addi r5, r28, 0xd4
	ctx.r[5].s64 = ctx.r[28].s64 + 212;
	// 828C378C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C3790: 4807D871  bl 0x82941000
	ctx.lr = 0x828C3794;
	sub_82941000(ctx, base);
	// 828C3794: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C3798: 48000008  b 0x828c37a0
	pc = 0x828C37A0; continue 'dispatch;
	// 828C379C: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 828C37A0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828C37A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C37A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C37AC: 4BFAE57D  bl 0x82871d28
	ctx.lr = 0x828C37B0;
	sub_82871D28(ctx, base);
	// 828C37B0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C37B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C37B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C37BC: 4B9FC845  bl 0x822c0000
	ctx.lr = 0x828C37C0;
	sub_822C0000(ctx, base);
	// 828C37C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C37C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C37C8: 4807C6D9  bl 0x8293fea0
	ctx.lr = 0x828C37CC;
	sub_8293FEA0(ctx, base);
	// 828C37CC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C37D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C37D4: 38A00077  li r5, 0x77
	ctx.r[5].s64 = 119;
	// 828C37D8: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C37DC: 4B9FCBFD  bl 0x822c03d8
	ctx.lr = 0x828C37E0;
	sub_822C03D8(ctx, base);
	// 828C37E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C37E4: 41820018  beq 0x828c37fc
	if ctx.cr[0].eq {
	pc = 0x828C37FC; continue 'dispatch;
	}
	// 828C37E8: 38BC00E0  addi r5, r28, 0xe0
	ctx.r[5].s64 = ctx.r[28].s64 + 224;
	// 828C37EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C37F0: 4807F781  bl 0x82942f70
	ctx.lr = 0x828C37F4;
	sub_82942F70(ctx, base);
	// 828C37F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C37F8: 48000008  b 0x828c3800
	pc = 0x828C3800; continue 'dispatch;
	// 828C37FC: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 828C3800: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828C3804: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C3808: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C380C: 4BFAE5E5  bl 0x82871df0
	ctx.lr = 0x828C3810;
	sub_82871DF0(ctx, base);
	// 828C3810: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C3814: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C3818: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C381C: 4B9FC7E5  bl 0x822c0000
	ctx.lr = 0x828C3820;
	sub_822C0000(ctx, base);
	// 828C3820: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C3824: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C3828: 4807C679  bl 0x8293fea0
	ctx.lr = 0x828C382C;
	sub_8293FEA0(ctx, base);
	// 828C382C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C3830: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C3834: 38A00079  li r5, 0x79
	ctx.r[5].s64 = 121;
	// 828C3838: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828C383C: 4B9FCB9D  bl 0x822c03d8
	ctx.lr = 0x828C3840;
	sub_822C03D8(ctx, base);
	// 828C3840: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C3844: 41820018  beq 0x828c385c
	if ctx.cr[0].eq {
	pc = 0x828C385C; continue 'dispatch;
	}
	// 828C3848: 38BC00E8  addi r5, r28, 0xe8
	ctx.r[5].s64 = ctx.r[28].s64 + 232;
	// 828C384C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C3850: 4807FB39  bl 0x82943388
	ctx.lr = 0x828C3854;
	sub_82943388(ctx, base);
	// 828C3854: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C3858: 48000008  b 0x828c3860
	pc = 0x828C3860; continue 'dispatch;
	// 828C385C: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 828C3860: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828C3864: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C3868: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C386C: 4BFAE64D  bl 0x82871eb8
	ctx.lr = 0x828C3870;
	sub_82871EB8(ctx, base);
	// 828C3870: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C3874: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C3878: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C387C: 4B9FC785  bl 0x822c0000
	ctx.lr = 0x828C3880;
	sub_822C0000(ctx, base);
	// 828C3880: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C3884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C3888: 4807C619  bl 0x8293fea0
	ctx.lr = 0x828C388C;
	sub_8293FEA0(ctx, base);
	// 828C388C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C3890: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C3894: 38A0007B  li r5, 0x7b
	ctx.r[5].s64 = 123;
	// 828C3898: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 828C389C: 4B9FCB3D  bl 0x822c03d8
	ctx.lr = 0x828C38A0;
	sub_822C03D8(ctx, base);
	// 828C38A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C38A4: 41820018  beq 0x828c38bc
	if ctx.cr[0].eq {
	pc = 0x828C38BC; continue 'dispatch;
	}
	// 828C38A8: 38BC00F8  addi r5, r28, 0xf8
	ctx.r[5].s64 = ctx.r[28].s64 + 248;
	// 828C38AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C38B0: 4807F071  bl 0x82942920
	ctx.lr = 0x828C38B4;
	sub_82942920(ctx, base);
	// 828C38B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C38B8: 48000008  b 0x828c38c0
	pc = 0x828C38C0; continue 'dispatch;
	// 828C38BC: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 828C38C0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828C38C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C38C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C38CC: 4BFAE6B5  bl 0x82871f80
	ctx.lr = 0x828C38D0;
	sub_82871F80(ctx, base);
	// 828C38D0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C38D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C38D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C38DC: 4B9FC725  bl 0x822c0000
	ctx.lr = 0x828C38E0;
	sub_822C0000(ctx, base);
	// 828C38E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C38E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C38E8: 4807C5B9  bl 0x8293fea0
	ctx.lr = 0x828C38EC;
	sub_8293FEA0(ctx, base);
	// 828C38EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C38F0: 488E48C4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C38F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C38F8 size=320
    let mut pc: u32 = 0x828C38F8;
    'dispatch: loop {
        match pc {
            0x828C38F8 => {
    //   block [0x828C38F8..0x828C3A38)
	// 828C38F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C38FC: 488E4871  bl 0x831a816c
	ctx.lr = 0x828C3900;
	sub_831A8130(ctx, base);
	// 828C3900: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C3904: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C3908: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C390C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C3910: 48052E59  bl 0x82916768
	ctx.lr = 0x828C3914;
	sub_82916768(ctx, base);
	// 828C3914: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3918: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C391C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C3920: 4E800421  bctrl
	ctx.lr = 0x828C3924;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C3924: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828C3928: 41820018  beq 0x828c3940
	if ctx.cr[0].eq {
	pc = 0x828C3940; continue 'dispatch;
	}
	// 828C392C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C3930: 48595E49  bl 0x82e59778
	ctx.lr = 0x828C3934;
	sub_82E59778(ctx, base);
	// 828C3934: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C3938: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C393C: 4807C2F5  bl 0x8293fc30
	ctx.lr = 0x828C3940;
	sub_8293FC30(ctx, base);
	// 828C3940: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C3944: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C3948: 4BFFEF19  bl 0x828c2860
	ctx.lr = 0x828C394C;
	sub_828C2860(ctx, base);
	// 828C394C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3950: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C3954: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C3958: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C395C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C3960: 4E800421  bctrl
	ctx.lr = 0x828C3964;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C3964: 138018C7  vcmpequd (lvx128) v28, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828C3968: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828C396C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C3A38 size=492
    let mut pc: u32 = 0x828C3A38;
    'dispatch: loop {
        match pc {
            0x828C3A38 => {
    //   block [0x828C3A38..0x828C3C24)
	// 828C3A38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C3A3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C3A40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C3A44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C3A48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C3A4C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C3A50: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C3A54: 3BEB0070  addi r31, r11, 0x70
	ctx.r[31].s64 = ctx.r[11].s64 + 112;
	// 828C3A58: 814B0070  lwz r10, 0x70(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 828C3A5C: 554A07FF  clrlwi. r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828C3A60: 41820010  beq 0x828c3a70
	if ctx.cr[0].eq {
	pc = 0x828C3A70; continue 'dispatch;
	}
	// 828C3A64: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C3A68: 914B006C  stw r10, 0x6c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828C3A6C: 48000138  b 0x828c3ba4
	pc = 0x828C3BA4; continue 'dispatch;
	// 828C3A70: 814B006C  lwz r10, 0x6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C3A74: 5549D7FF  rlwinm. r9, r10, 0x1a, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C3A78: 4182001C  beq 0x828c3a94
	if ctx.cr[0].eq {
	pc = 0x828C3A94; continue 'dispatch;
	}
	// 828C3A7C: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828C3A80: 3D20832C  lis r9, -0x7cd4
	ctx.r[9].s64 = -2094268416;
	// 828C3A84: 554A06B0  rlwinm r10, r10, 0, 0x1a, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828C3A88: 914B006C  stw r10, 0x6c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828C3A8C: 80893848  lwz r4, 0x3848(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(14408 as u32) ) } as u64;
	// 828C3A90: 480000E0  b 0x828c3b70
	pc = 0x828C3B70; continue 'dispatch;
	// 828C3A94: 5549DFFF  rlwinm. r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C3A98: 4182001C  beq 0x828c3ab4
	if ctx.cr[0].eq {
	pc = 0x828C3AB4; continue 'dispatch;
	}
	// 828C3A9C: 814B006C  lwz r10, 0x6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C3AA0: 3D20832C  lis r9, -0x7cd4
	ctx.r[9].s64 = -2094268416;
	// 828C3AA4: 554A06F2  rlwinm r10, r10, 0, 0x1b, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828C3AA8: 914B006C  stw r10, 0x6c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828C3AAC: 80893844  lwz r4, 0x3844(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(14404 as u32) ) } as u64;
	// 828C3AB0: 480000C0  b 0x828c3b70
	pc = 0x828C3B70; continue 'dispatch;
	// 828C3AB4: 5549F7FF  rlwinm. r9, r10, 0x1e, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C3AB8: 4182001C  beq 0x828c3ad4
	if ctx.cr[0].eq {
	pc = 0x828C3AD4; continue 'dispatch;
	}
	// 828C3ABC: 814B006C  lwz r10, 0x6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C3AC0: 3D20832C  lis r9, -0x7cd4
	ctx.r[9].s64 = -2094268416;
	// 828C3AC4: 554A07B8  rlwinm r10, r10, 0, 0x1e, 0x1c
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828C3AC8: 914B006C  stw r10, 0x6c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828C3ACC: 80893838  lwz r4, 0x3838(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(14392 as u32) ) } as u64;
	// 828C3AD0: 480000A0  b 0x828c3b70
	pc = 0x828C3B70; continue 'dispatch;
	// 828C3AD4: 5549FFFF  rlwinm. r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C3AD8: 4182001C  beq 0x828c3af4
	if ctx.cr[0].eq {
	pc = 0x828C3AF4; continue 'dispatch;
	}
	// 828C3ADC: 814B006C  lwz r10, 0x6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C3AE0: 3D20832C  lis r9, -0x7cd4
	ctx.r[9].s64 = -2094268416;
	// 828C3AE4: 554A07FA  rlwinm r10, r10, 0, 0x1f, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828C3AE8: 914B006C  stw r10, 0x6c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828C3AEC: 80893834  lwz r4, 0x3834(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(14388 as u32) ) } as u64;
	// 828C3AF0: 48000080  b 0x828c3b70
	pc = 0x828C3B70; continue 'dispatch;
	// 828C3AF4: 5549C7FF  rlwinm. r9, r10, 0x18, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C3AF8: 4182001C  beq 0x828c3b14
	if ctx.cr[0].eq {
	pc = 0x828C3B14; continue 'dispatch;
	}
	// 828C3AFC: 814B006C  lwz r10, 0x6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C3B00: 3D20832C  lis r9, -0x7cd4
	ctx.r[9].s64 = -2094268416;
	// 828C3B04: 554A062C  rlwinm r10, r10, 0, 0x18, 0x16
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828C3B08: 914B006C  stw r10, 0x6c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828C3B0C: 8089384C  lwz r4, 0x384c(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(14412 as u32) ) } as u64;
	// 828C3B10: 48000060  b 0x828c3b70
	pc = 0x828C3B70; continue 'dispatch;
	// 828C3B14: 5549E7FF  rlwinm. r9, r10, 0x1c, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C3B18: 4182001C  beq 0x828c3b34
	if ctx.cr[0].eq {
	pc = 0x828C3B34; continue 'dispatch;
	}
	// 828C3B1C: 814B006C  lwz r10, 0x6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C3B20: 3D20832C  lis r9, -0x7cd4
	ctx.r[9].s64 = -2094268416;
	// 828C3B24: 554A0734  rlwinm r10, r10, 0, 0x1c, 0x1a
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828C3B28: 914B006C  stw r10, 0x6c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828C3B2C: 8089383C  lwz r4, 0x383c(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(14396 as u32) ) } as u64;
	// 828C3B30: 48000040  b 0x828c3b70
	pc = 0x828C3B70; continue 'dispatch;
	// 828C3B34: 5549CFFF  rlwinm. r9, r10, 0x19, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C3B38: 4182001C  beq 0x828c3b54
	if ctx.cr[0].eq {
	pc = 0x828C3B54; continue 'dispatch;
	}
	// 828C3B3C: 814B006C  lwz r10, 0x6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C3B40: 3D20832C  lis r9, -0x7cd4
	ctx.r[9].s64 = -2094268416;
	// 828C3B44: 554A066E  rlwinm r10, r10, 0, 0x19, 0x17
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828C3B48: 914B006C  stw r10, 0x6c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828C3B4C: 80893850  lwz r4, 0x3850(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(14416 as u32) ) } as u64;
	// 828C3B50: 48000020  b 0x828c3b70
	pc = 0x828C3B70; continue 'dispatch;
	// 828C3B54: 554AEFFF  rlwinm. r10, r10, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828C3B58: 4182004C  beq 0x828c3ba4
	if ctx.cr[0].eq {
	pc = 0x828C3BA4; continue 'dispatch;
	}
	// 828C3B5C: 814B006C  lwz r10, 0x6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C3B60: 3D20832C  lis r9, -0x7cd4
	ctx.r[9].s64 = -2094268416;
	// 828C3B64: 554A0776  rlwinm r10, r10, 0, 0x1d, 0x1b
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 828C3B68: 914B006C  stw r10, 0x6c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828C3B6C: 80893840  lwz r4, 0x3840(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(14400 as u32) ) } as u64;
	// 828C3B70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C3B74: 4852FE95  bl 0x82df3a08
	ctx.lr = 0x828C3B78;
	sub_82DF3A08(ctx, base);
	// 828C3B78: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3B7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C3B80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C3B84: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C3B88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C3B8C: 4E800421  bctrl
	ctx.lr = 0x828C3B90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C3B90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C3B94: 4852F895  bl 0x82df3428
	ctx.lr = 0x828C3B98;
	sub_82DF3428(ctx, base);
	// 828C3B98: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3B9C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828C3BA0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C3BA4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3BA8: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C3BAC: 41820060  beq 0x828c3c0c
	if ctx.cr[0].eq {
	pc = 0x828C3C0C; continue 'dispatch;
	}
	// 828C3BB0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3BB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C3BB8: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828C3BBC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C3BC0: 4E800421  bctrl
	ctx.lr = 0x828C3BC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C3BC4: 4BF2674D  bl 0x827ea310
	ctx.lr = 0x828C3BC8;
	sub_827EA310(ctx, base);
	// 828C3BC8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C3BCC: 41820040  beq 0x828c3c0c
	if ctx.cr[0].eq {
	pc = 0x828C3C0C; continue 'dispatch;
	}
	// 828C3BD0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828C3BD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C3BD8: 808BF3F8  lwz r4, -0xc08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3080 as u32) ) } as u64;
	// 828C3BDC: 4852FE2D  bl 0x82df3a08
	ctx.lr = 0x828C3BE0;
	sub_82DF3A08(ctx, base);
	// 828C3BE0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3BE4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C3BE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C3BEC: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C3BF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C3BF4: 4E800421  bctrl
	ctx.lr = 0x828C3BF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C3BF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C3BFC: 4852F82D  bl 0x82df3428
	ctx.lr = 0x828C3C00;
	sub_82DF3428(ctx, base);
	// 828C3C00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3C04: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828C3C08: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C3C0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C3C10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C3C14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C3C18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C3C1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C3C20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C3C28 size=228
    let mut pc: u32 = 0x828C3C28;
    'dispatch: loop {
        match pc {
            0x828C3C28 => {
    //   block [0x828C3C28..0x828C3D0C)
	// 828C3C28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C3C2C: 488E4541  bl 0x831a816c
	ctx.lr = 0x828C3C30;
	sub_831A8130(ctx, base);
	// 828C3C30: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C3C34: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C3C38: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C3C3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C3C40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3C44: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C3C48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C3C4C: 4E800421  bctrl
	ctx.lr = 0x828C3C50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C3C50: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C3C54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C3C58: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828C3C5C: 4BFFEC05  bl 0x828c2860
	ctx.lr = 0x828C3C60;
	sub_828C2860(ctx, base);
	// 828C3C60: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C3C64: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828C3C68: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 828C3C6C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828C3C70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C3C74: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C3D10 size=88
    let mut pc: u32 = 0x828C3D10;
    'dispatch: loop {
        match pc {
            0x828C3D10 => {
    //   block [0x828C3D10..0x828C3D68)
	// 828C3D10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C3D14: 488E4459  bl 0x831a816c
	ctx.lr = 0x828C3D18;
	sub_831A8130(ctx, base);
	// 828C3D18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C3D1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C3D20: 488908E1  bl 0x83154600
	ctx.lr = 0x828C3D24;
	sub_83154600(ctx, base);
	// 828C3D24: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828C3D28: 41820038  beq 0x828c3d60
	if ctx.cr[0].eq {
	pc = 0x828C3D60; continue 'dispatch;
	}
	// 828C3D2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C3D30: 48595A49  bl 0x82e59778
	ctx.lr = 0x828C3D34;
	sub_82E59778(ctx, base);
	// 828C3D34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C3D38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C3D3C: 4803ED1D  bl 0x82902a58
	ctx.lr = 0x828C3D40;
	sub_82902A58(ctx, base);
	// 828C3D40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C3D44: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C3D48: 48595A31  bl 0x82e59778
	ctx.lr = 0x828C3D4C;
	sub_82E59778(ctx, base);
	// 828C3D4C: 817D0028  lwz r11, 0x28(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 828C3D50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C3D54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C3D58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C3D5C: 4E800421  bctrl
	ctx.lr = 0x828C3D60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C3D60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C3D64: 488E4458  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C3D68 size=80
    let mut pc: u32 = 0x828C3D68;
    'dispatch: loop {
        match pc {
            0x828C3D68 => {
    //   block [0x828C3D68..0x828C3DB8)
	// 828C3D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C3D6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C3D70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C3D74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C3D78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C3D7C: 48598BAD  bl 0x82e5c928
	ctx.lr = 0x828C3D80;
	sub_82E5C928(ctx, base);
	// 828C3D80: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C3D84: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 828C3D88: 396BD4D8  addi r11, r11, -0x2b28
	ctx.r[11].s64 = ctx.r[11].s64 + -11048;
	// 828C3D8C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C3D90: 48007D91  bl 0x828cbb20
	ctx.lr = 0x828C3D94;
	sub_828CBB20(ctx, base);
	// 828C3D94: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C3D98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C3D9C: 396BD510  addi r11, r11, -0x2af0
	ctx.r[11].s64 = ctx.r[11].s64 + -10992;
	// 828C3DA0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C3DA4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C3DA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C3DAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C3DB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C3DB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C3DB8 size=108
    let mut pc: u32 = 0x828C3DB8;
    'dispatch: loop {
        match pc {
            0x828C3DB8 => {
    //   block [0x828C3DB8..0x828C3E24)
	// 828C3DB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C3DBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C3DC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C3DC4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C3DC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C3DCC: 4BFFFF9D  bl 0x828c3d68
	ctx.lr = 0x828C3DD0;
	sub_828C3D68(ctx, base);
	// 828C3DD0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828C3DD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C3DD8: 394AD548  addi r10, r10, -0x2ab8
	ctx.r[10].s64 = ctx.r[10].s64 + -10936;
	// 828C3DDC: 3D20832D  lis r9, -0x7cd3
	ctx.r[9].s64 = -2094202880;
	// 828C3DE0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C3DE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C3DE8: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 828C3DEC: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 828C3DF0: 80890B24  lwz r4, 0xb24(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828C3DF4: 4852FC15  bl 0x82df3a08
	ctx.lr = 0x828C3DF8;
	sub_82DF3A08(ctx, base);
	// 828C3DF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C3DFC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C3E00: 485958E9  bl 0x82e596e8
	ctx.lr = 0x828C3E04;
	sub_82E596E8(ctx, base);
	// 828C3E04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C3E08: 4852F621  bl 0x82df3428
	ctx.lr = 0x828C3E0C;
	sub_82DF3428(ctx, base);
	// 828C3E0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C3E10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C3E14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C3E18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C3E1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C3E20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C3E28 size=112
    let mut pc: u32 = 0x828C3E28;
    'dispatch: loop {
        match pc {
            0x828C3E28 => {
    //   block [0x828C3E28..0x828C3E98)
	// 828C3E28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C3E2C: 488E4341  bl 0x831a816c
	ctx.lr = 0x828C3E30;
	sub_831A8130(ctx, base);
	// 828C3E30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C3E34: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C3E38: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C3E3C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C3E40: 388BD458  addi r4, r11, -0x2ba8
	ctx.r[4].s64 = ctx.r[11].s64 + -11176;
	// 828C3E44: 38A00050  li r5, 0x50
	ctx.r[5].s64 = 80;
	// 828C3E48: 38600074  li r3, 0x74
	ctx.r[3].s64 = 116;
	// 828C3E4C: 4852E59D  bl 0x82df23e8
	ctx.lr = 0x828C3E50;
	sub_82DF23E8(ctx, base);
	// 828C3E50: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C3E54: 41820010  beq 0x828c3e64
	if ctx.cr[0].eq {
	pc = 0x828C3E64; continue 'dispatch;
	}
	// 828C3E58: 4BFFFF61  bl 0x828c3db8
	ctx.lr = 0x828C3E5C;
	sub_828C3DB8(ctx, base);
	// 828C3E5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C3E60: 48000008  b 0x828c3e68
	pc = 0x828C3E68; continue 'dispatch;
	// 828C3E64: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C3E68: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C3E6C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828C3E70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C3E74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C3E78: 4BFFF781  bl 0x828c35f8
	ctx.lr = 0x828C3E7C;
	sub_828C35F8(ctx, base);
	// 828C3E7C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C3E80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C3E84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C3E88: 4B9FC179  bl 0x822c0000
	ctx.lr = 0x828C3E8C;
	sub_822C0000(ctx, base);
	// 828C3E8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C3E90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C3E94: 488E4328  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C3E98 size=108
    let mut pc: u32 = 0x828C3E98;
    'dispatch: loop {
        match pc {
            0x828C3E98 => {
    //   block [0x828C3E98..0x828C3F04)
	// 828C3E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C3E9C: 488E42D1  bl 0x831a816c
	ctx.lr = 0x828C3EA0;
	sub_831A8130(ctx, base);
	// 828C3EA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C3EA4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828C3EA8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C3EAC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C3EB0: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C3EB4: 41820038  beq 0x828c3eec
	if ctx.cr[0].eq {
	pc = 0x828C3EEC; continue 'dispatch;
	}
	// 828C3EB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C3EBC: 488E5ACD  bl 0x831a9988
	ctx.lr = 0x828C3EC0;
	sub_831A9988(ctx, base);
	// 828C3EC0: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828C3EC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C3EC8: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 828C3ECC: 488E422D  bl 0x831a80f8
	ctx.lr = 0x828C3ED0;
	sub_831A80F8(ctx, base);
	// 828C3ED0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C3ED4: 41820018  beq 0x828c3eec
	if ctx.cr[0].eq {
	pc = 0x828C3EEC; continue 'dispatch;
	}
	// 828C3ED8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C3EDC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C3EE0: 480082D9  bl 0x828cc1b8
	ctx.lr = 0x828C3EE4;
	sub_828CC1B8(ctx, base);
	// 828C3EE4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828C3EE8: 48000014  b 0x828c3efc
	pc = 0x828C3EFC; continue 'dispatch;
	// 828C3EEC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C3EF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C3EF4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C3EF8: 488BA591  bl 0x8317e488
	ctx.lr = 0x828C3EFC;
	sub_8317E488(ctx, base);
	// 828C3EFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C3F00: 488E42BC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C3F08 size=96
    let mut pc: u32 = 0x828C3F08;
    'dispatch: loop {
        match pc {
            0x828C3F08 => {
    //   block [0x828C3F08..0x828C3F68)
	// 828C3F08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C3F0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C3F10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C3F14: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C3F18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C3F1C: 4BFFFE4D  bl 0x828c3d68
	ctx.lr = 0x828C3F20;
	sub_828C3D68(ctx, base);
	// 828C3F20: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C3F24: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828C3F28: 396BD5AC  addi r11, r11, -0x2a54
	ctx.r[11].s64 = ctx.r[11].s64 + -10836;
	// 828C3F2C: 388A40A4  addi r4, r10, 0x40a4
	ctx.r[4].s64 = ctx.r[10].s64 + 16548;
	// 828C3F30: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C3F34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C3F38: 4852FAD1  bl 0x82df3a08
	ctx.lr = 0x828C3F3C;
	sub_82DF3A08(ctx, base);
	// 828C3F3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C3F40: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C3F44: 485957A5  bl 0x82e596e8
	ctx.lr = 0x828C3F48;
	sub_82E596E8(ctx, base);
	// 828C3F48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C3F4C: 4852F4DD  bl 0x82df3428
	ctx.lr = 0x828C3F50;
	sub_82DF3428(ctx, base);
	// 828C3F50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C3F54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C3F58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C3F5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C3F60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C3F64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C3F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C3F68 size=224
    let mut pc: u32 = 0x828C3F68;
    'dispatch: loop {
        match pc {
            0x828C3F68 => {
    //   block [0x828C3F68..0x828C4048)
	// 828C3F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C3F6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C3F70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C3F74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C3F78: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4048 size=196
    let mut pc: u32 = 0x828C4048;
    'dispatch: loop {
        match pc {
            0x828C4048 => {
    //   block [0x828C4048..0x828C410C)
	// 828C4048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C404C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C4050: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C4054: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C4058: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C405C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C4060: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C4064: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C4068: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C406C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C4070: 4B9FC8C9  bl 0x822c0938
	ctx.lr = 0x828C4074;
	sub_822C0938(ctx, base);
	// 828C4074: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C4078: 41820028  beq 0x828c40a0
	if ctx.cr[0].eq {
	pc = 0x828C40A0; continue 'dispatch;
	}
	// 828C407C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C4080: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828C4084: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C4088: 392BD5E8  addi r9, r11, -0x2a18
	ctx.r[9].s64 = ctx.r[11].s64 + -10776;
	// 828C408C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C4090: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C4094: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C4098: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C409C: 48000008  b 0x828c40a4
	pc = 0x828C40A4; continue 'dispatch;
	// 828C40A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C40A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C40A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C40AC: 409A0044  bne cr6, 0x828c40f0
	if !ctx.cr[6].eq {
	pc = 0x828C40F0; continue 'dispatch;
	}
	// 828C40B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C40B4: 419A001C  beq cr6, 0x828c40d0
	if ctx.cr[6].eq {
	pc = 0x828C40D0; continue 'dispatch;
	}
	// 828C40B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C40BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C40C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C40C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C40C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C40CC: 4E800421  bctrl
	ctx.lr = 0x828C40D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C40D0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C40D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C40D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C40DC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828C40E0: 816B3A34  lwz r11, 0x3a34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14900 as u32) ) } as u64;
	// 828C40E4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C40E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C40EC: 4B9FBF15  bl 0x822c0000
	ctx.lr = 0x828C40F0;
	sub_822C0000(ctx, base);
	// 828C40F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C40F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C40F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C40FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C4100: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C4104: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C4108: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C4110 size=216
    let mut pc: u32 = 0x828C4110;
    'dispatch: loop {
        match pc {
            0x828C4110 => {
    //   block [0x828C4110..0x828C41E8)
	// 828C4110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C4114: 488E4055  bl 0x831a8168
	ctx.lr = 0x828C4118;
	sub_831A8130(ctx, base);
	// 828C4118: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C411C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C4120: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C4124: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C4128: 488904D9  bl 0x83154600
	ctx.lr = 0x828C412C;
	sub_83154600(ctx, base);
	// 828C412C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828C4130: 418200B0  beq 0x828c41e0
	if ctx.cr[0].eq {
	pc = 0x828C41E0; continue 'dispatch;
	}
	// 828C4134: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C4138: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C413C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C4140: 4BF2B711  bl 0x827ef850
	ctx.lr = 0x828C4144;
	sub_827EF850(ctx, base);
	// 828C4144: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828C4148: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C414C: 815E0034  lwz r10, 0x34(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 828C4150: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C4154: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C4158: C02B029C  lfs f1, 0x29c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(668 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C415C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C4160: 4E800421  bctrl
	ctx.lr = 0x828C4164;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C4164: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C4168: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C416C: 388BD5F8  addi r4, r11, -0x2a08
	ctx.r[4].s64 = ctx.r[11].s64 + -10760;
	// 828C4170: 38A00041  li r5, 0x41
	ctx.r[5].s64 = 65;
	// 828C4174: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 828C4178: 4B9FC261  bl 0x822c03d8
	ctx.lr = 0x828C417C;
	sub_822C03D8(ctx, base);
	// 828C417C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828C4180: 4182002C  beq 0x828c41ac
	if ctx.cr[0].eq {
	pc = 0x828C41AC; continue 'dispatch;
	}
	// 828C4184: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C4188: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 828C418C: 480525DD  bl 0x82916768
	ctx.lr = 0x828C4190;
	sub_82916768(ctx, base);
	// 828C4190: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C4194: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4198: 4BC4B381  bl 0x8250f518
	ctx.lr = 0x828C419C;
	sub_8250F518(ctx, base);
	// 828C419C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C41A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C41A4: 4BBCCF4D  bl 0x824910f0
	ctx.lr = 0x828C41A8;
	sub_824910F0(ctx, base);
	// 828C41A8: 48000008  b 0x828c41b0
	pc = 0x828C41B0; continue 'dispatch;
	// 828C41AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C41B0: 83FD006C  lwz r31, 0x6c(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C41B4: 907D006C  stw r3, 0x6c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(108 as u32), ctx.r[3].u32 ) };
	// 828C41B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C41BC: 419A0014  beq cr6, 0x828c41d0
	if ctx.cr[6].eq {
	pc = 0x828C41D0; continue 'dispatch;
	}
	// 828C41C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C41C4: 4BBCD005  bl 0x824911c8
	ctx.lr = 0x828C41C8;
	sub_824911C8(ctx, base);
	// 828C41C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C41CC: 4B9FC09D  bl 0x822c0268
	ctx.lr = 0x828C41D0;
	sub_822C0268(ctx, base);
	// 828C41D0: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C41D4: 4182000C  beq 0x828c41e0
	if ctx.cr[0].eq {
	pc = 0x828C41E0; continue 'dispatch;
	}
	// 828C41D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C41DC: 4852DAB5  bl 0x82df1c90
	ctx.lr = 0x828C41E0;
	sub_82DF1C90(ctx, base);
	// 828C41E0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828C41E4: 488E3FD4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C41E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C41E8 size=104
    let mut pc: u32 = 0x828C41E8;
    'dispatch: loop {
        match pc {
            0x828C41E8 => {
    //   block [0x828C41E8..0x828C4250)
	// 828C41E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C41EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C41F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C41F4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C41F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C41FC: 4BFFFB6D  bl 0x828c3d68
	ctx.lr = 0x828C4200;
	sub_828C3D68(ctx, base);
	// 828C4200: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C4204: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C4208: 396BD678  addi r11, r11, -0x2988
	ctx.r[11].s64 = ctx.r[11].s64 + -10632;
	// 828C420C: 3D20832D  lis r9, -0x7cd3
	ctx.r[9].s64 = -2094202880;
	// 828C4210: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C4214: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4218: 915F006C  stw r10, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 828C421C: 80890AF0  lwz r4, 0xaf0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2800 as u32) ) } as u64;
	// 828C4220: 4852F7E9  bl 0x82df3a08
	ctx.lr = 0x828C4224;
	sub_82DF3A08(ctx, base);
	// 828C4224: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C4228: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C422C: 485954BD  bl 0x82e596e8
	ctx.lr = 0x828C4230;
	sub_82E596E8(ctx, base);
	// 828C4230: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4234: 4852F1F5  bl 0x82df3428
	ctx.lr = 0x828C4238;
	sub_82DF3428(ctx, base);
	// 828C4238: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C423C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C4240: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C4244: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C4248: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C424C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4250 size=92
    let mut pc: u32 = 0x828C4250;
    'dispatch: loop {
        match pc {
            0x828C4250 => {
    //   block [0x828C4250..0x828C42AC)
	// 828C4250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C4254: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C4258: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C425C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C4260: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4264: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C4268: 83FE006C  lwz r31, 0x6c(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C426C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C4270: 419A0014  beq cr6, 0x828c4284
	if ctx.cr[6].eq {
	pc = 0x828C4284; continue 'dispatch;
	}
	// 828C4274: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C4278: 4BBCCF51  bl 0x824911c8
	ctx.lr = 0x828C427C;
	sub_824911C8(ctx, base);
	// 828C427C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C4280: 4B9FBFE9  bl 0x822c0268
	ctx.lr = 0x828C4284;
	sub_822C0268(ctx, base);
	// 828C4284: 387E0060  addi r3, r30, 0x60
	ctx.r[3].s64 = ctx.r[30].s64 + 96;
	// 828C4288: 4803FB49  bl 0x82903dd0
	ctx.lr = 0x828C428C;
	sub_82903DD0(ctx, base);
	// 828C428C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4290: 485982F9  bl 0x82e5c588
	ctx.lr = 0x828C4294;
	sub_82E5C588(ctx, base);
	// 828C4294: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C4298: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C429C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C42A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C42A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C42A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C42B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C42B0 size=76
    let mut pc: u32 = 0x828C42B0;
    'dispatch: loop {
        match pc {
            0x828C42B0 => {
    //   block [0x828C42B0..0x828C42FC)
	// 828C42B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C42B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C42B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C42BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C42C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C42C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C42C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C42CC: 4BFFFF85  bl 0x828c4250
	ctx.lr = 0x828C42D0;
	sub_828C4250(ctx, base);
	// 828C42D0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C42D4: 4182000C  beq 0x828c42e0
	if ctx.cr[0].eq {
	pc = 0x828C42E0; continue 'dispatch;
	}
	// 828C42D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C42DC: 4852E0FD  bl 0x82df23d8
	ctx.lr = 0x828C42E0;
	sub_82DF23D8(ctx, base);
	// 828C42E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C42E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C42E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C42EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C42F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C42F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C42F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4300 size=112
    let mut pc: u32 = 0x828C4300;
    'dispatch: loop {
        match pc {
            0x828C4300 => {
    //   block [0x828C4300..0x828C4370)
	// 828C4300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C4304: 488E3E69  bl 0x831a816c
	ctx.lr = 0x828C4308;
	sub_831A8130(ctx, base);
	// 828C4308: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C430C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C4310: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C4314: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C4318: 388BD5F8  addi r4, r11, -0x2a08
	ctx.r[4].s64 = ctx.r[11].s64 + -10760;
	// 828C431C: 38A0002E  li r5, 0x2e
	ctx.r[5].s64 = 46;
	// 828C4320: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 828C4324: 4852E0C5  bl 0x82df23e8
	ctx.lr = 0x828C4328;
	sub_82DF23E8(ctx, base);
	// 828C4328: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C432C: 41820010  beq 0x828c433c
	if ctx.cr[0].eq {
	pc = 0x828C433C; continue 'dispatch;
	}
	// 828C4330: 4BFFFEB9  bl 0x828c41e8
	ctx.lr = 0x828C4334;
	sub_828C41E8(ctx, base);
	// 828C4334: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C4338: 48000008  b 0x828c4340
	pc = 0x828C4340; continue 'dispatch;
	// 828C433C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C4340: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C4344: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828C4348: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C434C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4350: 4BFFFCF9  bl 0x828c4048
	ctx.lr = 0x828C4354;
	sub_828C4048(ctx, base);
	// 828C4354: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C4358: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C435C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4360: 4B9FBCA1  bl 0x822c0000
	ctx.lr = 0x828C4364;
	sub_822C0000(ctx, base);
	// 828C4364: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C4368: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C436C: 488E3E50  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C4370 size=52
    let mut pc: u32 = 0x828C4370;
    'dispatch: loop {
        match pc {
            0x828C4370 => {
    //   block [0x828C4370..0x828C43A4)
	// 828C4370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C4374: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C4378: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C437C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828C4380: 480523E9  bl 0x82916768
	ctx.lr = 0x828C4384;
	sub_82916768(ctx, base);
	// 828C4384: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C4388: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828C438C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C4390: 4804A9E9  bl 0x8290ed78
	ctx.lr = 0x828C4394;
	sub_8290ED78(ctx, base);
	// 828C4394: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C4398: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C439C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C43A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C43A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C43A8 size=76
    let mut pc: u32 = 0x828C43A8;
    'dispatch: loop {
        match pc {
            0x828C43A8 => {
    //   block [0x828C43A8..0x828C43F4)
	// 828C43A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C43AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C43B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C43B4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C43B8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828C43BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C43C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C43C4: 808B0B30  lwz r4, 0xb30(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2864 as u32) ) } as u64;
	// 828C43C8: 4852F641  bl 0x82df3a08
	ctx.lr = 0x828C43CC;
	sub_82DF3A08(ctx, base);
	// 828C43CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C43D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C43D4: 4BF2B36D  bl 0x827ef740
	ctx.lr = 0x828C43D8;
	sub_827EF740(ctx, base);
	// 828C43D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C43DC: 4852F04D  bl 0x82df3428
	ctx.lr = 0x828C43E0;
	sub_82DF3428(ctx, base);
	// 828C43E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C43E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C43E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C43EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C43F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C43F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C43F8 size=112
    let mut pc: u32 = 0x828C43F8;
    'dispatch: loop {
        match pc {
            0x828C43F8 => {
    //   block [0x828C43F8..0x828C4468)
	// 828C43F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C43FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C4400: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C4404: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C4408: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C440C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C4410: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4414: 48052355  bl 0x82916768
	ctx.lr = 0x828C4418;
	sub_82916768(ctx, base);
	// 828C4418: 48045171  bl 0x82909588
	ctx.lr = 0x828C441C;
	sub_82909588(ctx, base);
	// 828C441C: 4807C08D  bl 0x829404a8
	ctx.lr = 0x828C4420;
	sub_829404A8(ctx, base);
	// 828C4420: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C4424: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4428: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C442C: 4BF2B425  bl 0x827ef850
	ctx.lr = 0x828C4430;
	sub_827EF850(ctx, base);
	// 828C4430: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828C4434: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 828C4438: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C443C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4440: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C4444: C02B029C  lfs f1, 0x29c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(668 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C4448: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828C444C: 4E800421  bctrl
	ctx.lr = 0x828C4450;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C4450: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C4454: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C4458: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C445C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C4460: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C4464: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C4468 size=120
    let mut pc: u32 = 0x828C4468;
    'dispatch: loop {
        match pc {
            0x828C4468 => {
    //   block [0x828C4468..0x828C44E0)
	// 828C4468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C446C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C4470: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C4474: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C4478: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C447C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C4480: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C4484: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4488: 4BFFE1A1  bl 0x828c2628
	ctx.lr = 0x828C448C;
	sub_828C2628(ctx, base);
	// 828C448C: C0030008  lfs f0, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C4490: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828C4494: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C4498: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C449C: 808B386C  lwz r4, 0x386c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14444 as u32) ) } as u64;
	// 828C44A0: 4852F569  bl 0x82df3a08
	ctx.lr = 0x828C44A4;
	sub_82DF3A08(ctx, base);
	// 828C44A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C44A8: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 828C44AC: 4BF2B2D5  bl 0x827ef780
	ctx.lr = 0x828C44B0;
	sub_827EF780(ctx, base);
	// 828C44B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C44B4: 4BF2602D  bl 0x827ea4e0
	ctx.lr = 0x828C44B8;
	sub_827EA4E0(ctx, base);
	// 828C44B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C44BC: 4852EF6D  bl 0x82df3428
	ctx.lr = 0x828C44C0;
	sub_82DF3428(ctx, base);
	// 828C44C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C44C4: 4BFFE205  bl 0x828c26c8
	ctx.lr = 0x828C44C8;
	sub_828C26C8(ctx, base);
	// 828C44C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C44CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C44D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C44D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C44D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C44DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C44E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C44E0 size=84
    let mut pc: u32 = 0x828C44E0;
    'dispatch: loop {
        match pc {
            0x828C44E0 => {
    //   block [0x828C44E0..0x828C4534)
	// 828C44E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C44E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C44E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C44EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C44F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C44F4: 48595285  bl 0x82e59778
	ctx.lr = 0x828C44F8;
	sub_82E59778(ctx, base);
	// 828C44F8: C01F006C  lfs f0, 0x6c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C44FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C4500: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 828C4504: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828C4508: C02B08A4  lfs f1, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C450C: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 828C4510: 40980010  bge cr6, 0x828c4520
	if !ctx.cr[6].lt {
	pc = 0x828C4520; continue 'dispatch;
	}
	// 828C4514: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828C4518: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C451C: 4859851D  bl 0x82e5ca38
	ctx.lr = 0x828C4520;
	sub_82E5CA38(ctx, base);
	// 828C4520: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C4524: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C4528: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C452C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C4530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C4538 size=8
    let mut pc: u32 = 0x828C4538;
    'dispatch: loop {
        match pc {
            0x828C4538 => {
    //   block [0x828C4538..0x828C4540)
	// 828C4538: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828C453C: 4BFFE1D4  b 0x828c2710
	sub_828C2710(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4540 size=108
    let mut pc: u32 = 0x828C4540;
    'dispatch: loop {
        match pc {
            0x828C4540 => {
    //   block [0x828C4540..0x828C45AC)
	// 828C4540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C4544: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C4548: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C454C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4550: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C4554: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C4558: 4BFFE0D1  bl 0x828c2628
	ctx.lr = 0x828C455C;
	sub_828C2628(ctx, base);
	// 828C455C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4560: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4564: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 828C4568: 409A0010  bne cr6, 0x828c4578
	if !ctx.cr[6].eq {
	pc = 0x828C4578; continue 'dispatch;
	}
	// 828C456C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828C4570: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828C4574: 4800000C  b 0x828c4580
	pc = 0x828C4580; continue 'dispatch;
	// 828C4578: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C457C: 808B39E8  lwz r4, 0x39e8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14824 as u32) ) } as u64;
	// 828C4580: 4852F489  bl 0x82df3a08
	ctx.lr = 0x828C4584;
	sub_82DF3A08(ctx, base);
	// 828C4584: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C4588: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C458C: 4BF2B1B5  bl 0x827ef740
	ctx.lr = 0x828C4590;
	sub_827EF740(ctx, base);
	// 828C4590: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4594: 4852EE95  bl 0x82df3428
	ctx.lr = 0x828C4598;
	sub_82DF3428(ctx, base);
	// 828C4598: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C459C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C45A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C45A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C45A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C45B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C45B0 size=88
    let mut pc: u32 = 0x828C45B0;
    'dispatch: loop {
        match pc {
            0x828C45B0 => {
    //   block [0x828C45B0..0x828C4608)
	// 828C45B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C45B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C45B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C45BC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C45C0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C45C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C45C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C45CC: 808B385C  lwz r4, 0x385c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14428 as u32) ) } as u64;
	// 828C45D0: 4852F439  bl 0x82df3a08
	ctx.lr = 0x828C45D4;
	sub_82DF3A08(ctx, base);
	// 828C45D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C45D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C45DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C45E0: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C45E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C45E8: 4E800421  bctrl
	ctx.lr = 0x828C45EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C45EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C45F0: 4852EE39  bl 0x82df3428
	ctx.lr = 0x828C45F4;
	sub_82DF3428(ctx, base);
	// 828C45F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C45F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C45FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C4600: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C4604: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C4608 size=156
    let mut pc: u32 = 0x828C4608;
    'dispatch: loop {
        match pc {
            0x828C4608 => {
    //   block [0x828C4608..0x828C46A4)
	// 828C4608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C460C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C4610: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C4614: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4618: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C461C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C4620: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4624: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828C4628: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C462C: 4E800421  bctrl
	ctx.lr = 0x828C4630;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C4630: 4BF25CE1  bl 0x827ea310
	ctx.lr = 0x828C4634;
	sub_827EA310(ctx, base);
	// 828C4634: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C4638: 41820058  beq 0x828c4690
	if ctx.cr[0].eq {
	pc = 0x828C4690; continue 'dispatch;
	}
	// 828C463C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4640: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C4644: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828C4648: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C464C: 4E800421  bctrl
	ctx.lr = 0x828C4650;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C4650: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C4654: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4658: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C465C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828C4660: 41990010  bgt cr6, 0x828c4670
	if ctx.cr[6].gt {
	pc = 0x828C4670; continue 'dispatch;
	}
	// 828C4664: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828C4668: 808B0B28  lwz r4, 0xb28(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2856 as u32) ) } as u64;
	// 828C466C: 4800000C  b 0x828c4678
	pc = 0x828C4678; continue 'dispatch;
	// 828C4670: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C4674: 808B39F4  lwz r4, 0x39f4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14836 as u32) ) } as u64;
	// 828C4678: 4852F391  bl 0x82df3a08
	ctx.lr = 0x828C467C;
	sub_82DF3A08(ctx, base);
	// 828C467C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C4680: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C4684: 4BF2B0BD  bl 0x827ef740
	ctx.lr = 0x828C4688;
	sub_827EF740(ctx, base);
	// 828C4688: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C468C: 4852ED9D  bl 0x82df3428
	ctx.lr = 0x828C4690;
	sub_82DF3428(ctx, base);
	// 828C4690: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C4694: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C4698: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C469C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C46A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C46A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C46A8 size=156
    let mut pc: u32 = 0x828C46A8;
    'dispatch: loop {
        match pc {
            0x828C46A8 => {
    //   block [0x828C46A8..0x828C4744)
	// 828C46A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C46AC: 488E3AC1  bl 0x831a816c
	ctx.lr = 0x828C46B0;
	sub_831A8130(ctx, base);
	// 828C46B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C46B4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C46B8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C46BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C46C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C46C4: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828C46C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C46CC: 4E800421  bctrl
	ctx.lr = 0x828C46D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C46D0: 4BF25C39  bl 0x827ea308
	ctx.lr = 0x828C46D4;
	sub_827EA308(ctx, base);
	// 828C46D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828C46D8: C00B1678  lfs f0, 0x1678(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5752 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C46DC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828C46E0: 4099000C  ble cr6, 0x828c46ec
	if !ctx.cr[6].gt {
	pc = 0x828C46EC; continue 'dispatch;
	}
	// 828C46E4: 387E006C  addi r3, r30, 0x6c
	ctx.r[3].s64 = ctx.r[30].s64 + 108;
	// 828C46E8: 48541E39  bl 0x82e06520
	ctx.lr = 0x828C46EC;
	sub_82E06520(ctx, base);
	// 828C46EC: 817E00A0  lwz r11, 0xa0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(160 as u32) ) } as u64;
	// 828C46F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C46F4: 419A0048  beq cr6, 0x828c473c
	if ctx.cr[6].eq {
	pc = 0x828C473C; continue 'dispatch;
	}
	// 828C46F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C46FC: 3BBE0090  addi r29, r30, 0x90
	ctx.r[29].s64 = ctx.r[30].s64 + 144;
	// 828C4700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C4704: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C4708: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C470C: 4E800421  bctrl
	ctx.lr = 0x828C4710;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C4710: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828C4714: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C4718: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C471C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828C4720: C02B6150  lfs f1, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C4724: 485B8BA5  bl 0x82e7d2c8
	ctx.lr = 0x828C4728;
	sub_82E7D2C8(ctx, base);
	// 828C4728: 817E00A0  lwz r11, 0xa0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(160 as u32) ) } as u64;
	// 828C472C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C4730: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C4734: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C4738: 4E800421  bctrl
	ctx.lr = 0x828C473C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C473C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C4740: 488E3A7C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4748 size=156
    let mut pc: u32 = 0x828C4748;
    'dispatch: loop {
        match pc {
            0x828C4748 => {
    //   block [0x828C4748..0x828C47E4)
	// 828C4748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C474C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C4750: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C4754: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4758: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C475C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C4760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C4764: 388B0090  addi r4, r11, 0x90
	ctx.r[4].s64 = ctx.r[11].s64 + 144;
	// 828C4768: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C476C: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C4770: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C4774: 4E800421  bctrl
	ctx.lr = 0x828C4778;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C4778: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C477C: 48051FED  bl 0x82916768
	ctx.lr = 0x828C4780;
	sub_82916768(ctx, base);
	// 828C4780: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C4784: 41820018  beq 0x828c479c
	if ctx.cr[0].eq {
	pc = 0x828C479C; continue 'dispatch;
	}
	// 828C4788: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C478C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828C4790: 816B00BC  lwz r11, 0xbc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 828C4794: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C4798: 4E800421  bctrl
	ctx.lr = 0x828C479C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C479C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828C47A0: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828C47A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C47A8: 48052879  bl 0x82917020
	ctx.lr = 0x828C47AC;
	sub_82917020(ctx, base);
	// 828C47AC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828C47B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C47B4: 808B0BD8  lwz r4, 0xbd8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3032 as u32) ) } as u64;
	// 828C47B8: 4852F251  bl 0x82df3a08
	ctx.lr = 0x828C47BC;
	sub_82DF3A08(ctx, base);
	// 828C47BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C47C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C47C4: 4BF2AFAD  bl 0x827ef770
	ctx.lr = 0x828C47C8;
	sub_827EF770(ctx, base);
	// 828C47C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C47CC: 4852EC5D  bl 0x82df3428
	ctx.lr = 0x828C47D0;
	sub_82DF3428(ctx, base);
	// 828C47D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C47D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C47D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C47DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C47E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C47E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C47E8 size=72
    let mut pc: u32 = 0x828C47E8;
    'dispatch: loop {
        match pc {
            0x828C47E8 => {
    //   block [0x828C47E8..0x828C4830)
	// 828C47E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C47EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C47F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C47F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C47F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C47FC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828C4800: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C4804: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828C4808: 48052819  bl 0x82917020
	ctx.lr = 0x828C480C;
	sub_82917020(ctx, base);
	// 828C480C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828C4810: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 828C4814: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C4818: 48052809  bl 0x82917020
	ctx.lr = 0x828C481C;
	sub_82917020(ctx, base);
	// 828C481C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C4820: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C4824: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C4828: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C482C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4830 size=136
    let mut pc: u32 = 0x828C4830;
    'dispatch: loop {
        match pc {
            0x828C4830 => {
    //   block [0x828C4830..0x828C48B8)
	// 828C4830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C4834: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C4838: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C483C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C4840: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4844: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C4848: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C484C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828C4850: 409A0020  bne cr6, 0x828c4870
	if !ctx.cr[6].eq {
	pc = 0x828C4870; continue 'dispatch;
	}
	// 828C4854: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C4858: 419A0048  beq cr6, 0x828c48a0
	if ctx.cr[6].eq {
	pc = 0x828C48A0; continue 'dispatch;
	}
	// 828C485C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828C4860: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828C4864: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828C4868: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828C486C: 48000034  b 0x828c48a0
	pc = 0x828C48A0; continue 'dispatch;
	// 828C4870: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828C4874: 419A002C  beq cr6, 0x828c48a0
	if ctx.cr[6].eq {
	pc = 0x828C48A0; continue 'dispatch;
	}
	// 828C4878: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C487C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4880: 388B3FA0  addi r4, r11, 0x3fa0
	ctx.r[4].s64 = ctx.r[11].s64 + 16288;
	// 828C4884: 488E3875  bl 0x831a80f8
	ctx.lr = 0x828C4888;
	sub_831A80F8(ctx, base);
	// 828C4888: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C488C: 4182000C  beq 0x828c4898
	if ctx.cr[0].eq {
	pc = 0x828C4898; continue 'dispatch;
	}
	// 828C4890: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828C4894: 4800000C  b 0x828c48a0
	pc = 0x828C48A0; continue 'dispatch;
	// 828C4898: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C489C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C48A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C48A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C48A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C48AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C48B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C48B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C48B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C48B8 size=196
    let mut pc: u32 = 0x828C48B8;
    'dispatch: loop {
        match pc {
            0x828C48B8 => {
    //   block [0x828C48B8..0x828C497C)
	// 828C48B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C48BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C48C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C48C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C48C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C48CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C48D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C48D4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C48D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C48DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C48E0: 4B9FC059  bl 0x822c0938
	ctx.lr = 0x828C48E4;
	sub_822C0938(ctx, base);
	// 828C48E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C48E8: 41820028  beq 0x828c4910
	if ctx.cr[0].eq {
	pc = 0x828C4910; continue 'dispatch;
	}
	// 828C48EC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C48F0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828C48F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C48F8: 392BD6B4  addi r9, r11, -0x294c
	ctx.r[9].s64 = ctx.r[11].s64 + -10572;
	// 828C48FC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C4900: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C4904: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C4908: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C490C: 48000008  b 0x828c4914
	pc = 0x828C4914; continue 'dispatch;
	// 828C4910: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C4914: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C4918: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C491C: 409A0044  bne cr6, 0x828c4960
	if !ctx.cr[6].eq {
	pc = 0x828C4960; continue 'dispatch;
	}
	// 828C4920: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C4924: 419A001C  beq cr6, 0x828c4940
	if ctx.cr[6].eq {
	pc = 0x828C4940; continue 'dispatch;
	}
	// 828C4928: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C492C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C4930: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C4934: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4938: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C493C: 4E800421  bctrl
	ctx.lr = 0x828C4940;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C4940: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C4944: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C4948: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C494C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828C4950: 816B3AC0  lwz r11, 0x3ac0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15040 as u32) ) } as u64;
	// 828C4954: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C4958: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C495C: 4B9FB6A5  bl 0x822c0000
	ctx.lr = 0x828C4960;
	sub_822C0000(ctx, base);
	// 828C4960: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4964: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C4968: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C496C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C4970: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C4974: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C4978: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4980 size=196
    let mut pc: u32 = 0x828C4980;
    'dispatch: loop {
        match pc {
            0x828C4980 => {
    //   block [0x828C4980..0x828C4A44)
	// 828C4980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C4984: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C4988: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C498C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C4990: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4994: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C4998: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C499C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C49A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C49A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C49A8: 4B9FBF91  bl 0x822c0938
	ctx.lr = 0x828C49AC;
	sub_822C0938(ctx, base);
	// 828C49AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C49B0: 41820028  beq 0x828c49d8
	if ctx.cr[0].eq {
	pc = 0x828C49D8; continue 'dispatch;
	}
	// 828C49B4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C49B8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828C49BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C49C0: 392BD6C8  addi r9, r11, -0x2938
	ctx.r[9].s64 = ctx.r[11].s64 + -10552;
	// 828C49C4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C49C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C49CC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C49D0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C49D4: 48000008  b 0x828c49dc
	pc = 0x828C49DC; continue 'dispatch;
	// 828C49D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C49DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C49E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C49E4: 409A0044  bne cr6, 0x828c4a28
	if !ctx.cr[6].eq {
	pc = 0x828C4A28; continue 'dispatch;
	}
	// 828C49E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C49EC: 419A001C  beq cr6, 0x828c4a08
	if ctx.cr[6].eq {
	pc = 0x828C4A08; continue 'dispatch;
	}
	// 828C49F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C49F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C49F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C49FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4A00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C4A04: 4E800421  bctrl
	ctx.lr = 0x828C4A08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C4A08: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C4A0C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C4A10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4A14: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828C4A18: 816B3AC0  lwz r11, 0x3ac0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15040 as u32) ) } as u64;
	// 828C4A1C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C4A20: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C4A24: 4B9FB5DD  bl 0x822c0000
	ctx.lr = 0x828C4A28;
	sub_822C0000(ctx, base);
	// 828C4A28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4A2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C4A30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C4A34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C4A38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C4A3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C4A40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4A48 size=196
    let mut pc: u32 = 0x828C4A48;
    'dispatch: loop {
        match pc {
            0x828C4A48 => {
    //   block [0x828C4A48..0x828C4B0C)
	// 828C4A48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C4A4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C4A50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C4A54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C4A58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4A5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C4A60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C4A64: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C4A68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C4A6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C4A70: 4B9FBEC9  bl 0x822c0938
	ctx.lr = 0x828C4A74;
	sub_822C0938(ctx, base);
	// 828C4A74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C4A78: 41820028  beq 0x828c4aa0
	if ctx.cr[0].eq {
	pc = 0x828C4AA0; continue 'dispatch;
	}
	// 828C4A7C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C4A80: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828C4A84: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C4A88: 392BD6DC  addi r9, r11, -0x2924
	ctx.r[9].s64 = ctx.r[11].s64 + -10532;
	// 828C4A8C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C4A90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C4A94: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C4A98: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C4A9C: 48000008  b 0x828c4aa4
	pc = 0x828C4AA4; continue 'dispatch;
	// 828C4AA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C4AA4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C4AA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4AAC: 409A0044  bne cr6, 0x828c4af0
	if !ctx.cr[6].eq {
	pc = 0x828C4AF0; continue 'dispatch;
	}
	// 828C4AB0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C4AB4: 419A001C  beq cr6, 0x828c4ad0
	if ctx.cr[6].eq {
	pc = 0x828C4AD0; continue 'dispatch;
	}
	// 828C4AB8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4ABC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C4AC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C4AC4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4AC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C4ACC: 4E800421  bctrl
	ctx.lr = 0x828C4AD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C4AD0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C4AD4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C4AD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4ADC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828C4AE0: 816B3AC0  lwz r11, 0x3ac0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15040 as u32) ) } as u64;
	// 828C4AE4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C4AE8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C4AEC: 4B9FB515  bl 0x822c0000
	ctx.lr = 0x828C4AF0;
	sub_822C0000(ctx, base);
	// 828C4AF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4AF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C4AF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C4AFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C4B00: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C4B04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C4B08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4B10 size=196
    let mut pc: u32 = 0x828C4B10;
    'dispatch: loop {
        match pc {
            0x828C4B10 => {
    //   block [0x828C4B10..0x828C4BD4)
	// 828C4B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C4B14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C4B18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C4B1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C4B20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4B24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C4B28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C4B2C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C4B30: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C4B34: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C4B38: 4B9FBE01  bl 0x822c0938
	ctx.lr = 0x828C4B3C;
	sub_822C0938(ctx, base);
	// 828C4B3C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C4B40: 41820028  beq 0x828c4b68
	if ctx.cr[0].eq {
	pc = 0x828C4B68; continue 'dispatch;
	}
	// 828C4B44: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C4B48: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828C4B4C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C4B50: 392BD6F0  addi r9, r11, -0x2910
	ctx.r[9].s64 = ctx.r[11].s64 + -10512;
	// 828C4B54: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C4B58: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C4B5C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C4B60: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C4B64: 48000008  b 0x828c4b6c
	pc = 0x828C4B6C; continue 'dispatch;
	// 828C4B68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C4B6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C4B70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4B74: 409A0044  bne cr6, 0x828c4bb8
	if !ctx.cr[6].eq {
	pc = 0x828C4BB8; continue 'dispatch;
	}
	// 828C4B78: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C4B7C: 419A001C  beq cr6, 0x828c4b98
	if ctx.cr[6].eq {
	pc = 0x828C4B98; continue 'dispatch;
	}
	// 828C4B80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4B84: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C4B88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C4B8C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4B90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C4B94: 4E800421  bctrl
	ctx.lr = 0x828C4B98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C4B98: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C4B9C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C4BA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4BA4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828C4BA8: 816B3AC0  lwz r11, 0x3ac0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15040 as u32) ) } as u64;
	// 828C4BAC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C4BB0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C4BB4: 4B9FB44D  bl 0x822c0000
	ctx.lr = 0x828C4BB8;
	sub_822C0000(ctx, base);
	// 828C4BB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4BBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C4BC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C4BC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C4BC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C4BCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C4BD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4BD8 size=196
    let mut pc: u32 = 0x828C4BD8;
    'dispatch: loop {
        match pc {
            0x828C4BD8 => {
    //   block [0x828C4BD8..0x828C4C9C)
	// 828C4BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C4BDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C4BE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C4BE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C4BE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4BEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C4BF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C4BF4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C4BF8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C4BFC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C4C00: 4B9FBD39  bl 0x822c0938
	ctx.lr = 0x828C4C04;
	sub_822C0938(ctx, base);
	// 828C4C04: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C4C08: 41820028  beq 0x828c4c30
	if ctx.cr[0].eq {
	pc = 0x828C4C30; continue 'dispatch;
	}
	// 828C4C0C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C4C10: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828C4C14: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C4C18: 392BD704  addi r9, r11, -0x28fc
	ctx.r[9].s64 = ctx.r[11].s64 + -10492;
	// 828C4C1C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C4C20: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C4C24: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C4C28: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C4C2C: 48000008  b 0x828c4c34
	pc = 0x828C4C34; continue 'dispatch;
	// 828C4C30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C4C34: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C4C38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4C3C: 409A0044  bne cr6, 0x828c4c80
	if !ctx.cr[6].eq {
	pc = 0x828C4C80; continue 'dispatch;
	}
	// 828C4C40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C4C44: 419A001C  beq cr6, 0x828c4c60
	if ctx.cr[6].eq {
	pc = 0x828C4C60; continue 'dispatch;
	}
	// 828C4C48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4C4C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C4C50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C4C54: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4C58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C4C5C: 4E800421  bctrl
	ctx.lr = 0x828C4C60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C4C60: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C4C64: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C4C68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4C6C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828C4C70: 816B3AC0  lwz r11, 0x3ac0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15040 as u32) ) } as u64;
	// 828C4C74: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C4C78: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C4C7C: 4B9FB385  bl 0x822c0000
	ctx.lr = 0x828C4C80;
	sub_822C0000(ctx, base);
	// 828C4C80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4C84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C4C88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C4C8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C4C90: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C4C94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C4C98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4CA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4CA0 size=196
    let mut pc: u32 = 0x828C4CA0;
    'dispatch: loop {
        match pc {
            0x828C4CA0 => {
    //   block [0x828C4CA0..0x828C4D64)
	// 828C4CA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C4CA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C4CA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C4CAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C4CB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4CB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C4CB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C4CBC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C4CC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C4CC4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C4CC8: 4B9FBC71  bl 0x822c0938
	ctx.lr = 0x828C4CCC;
	sub_822C0938(ctx, base);
	// 828C4CCC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C4CD0: 41820028  beq 0x828c4cf8
	if ctx.cr[0].eq {
	pc = 0x828C4CF8; continue 'dispatch;
	}
	// 828C4CD4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C4CD8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828C4CDC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C4CE0: 392BD718  addi r9, r11, -0x28e8
	ctx.r[9].s64 = ctx.r[11].s64 + -10472;
	// 828C4CE4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C4CE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C4CEC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C4CF0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C4CF4: 48000008  b 0x828c4cfc
	pc = 0x828C4CFC; continue 'dispatch;
	// 828C4CF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C4CFC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C4D00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4D04: 409A0044  bne cr6, 0x828c4d48
	if !ctx.cr[6].eq {
	pc = 0x828C4D48; continue 'dispatch;
	}
	// 828C4D08: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C4D0C: 419A001C  beq cr6, 0x828c4d28
	if ctx.cr[6].eq {
	pc = 0x828C4D28; continue 'dispatch;
	}
	// 828C4D10: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4D14: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C4D18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C4D1C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4D20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C4D24: 4E800421  bctrl
	ctx.lr = 0x828C4D28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C4D28: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C4D2C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C4D30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4D34: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828C4D38: 816B3AC0  lwz r11, 0x3ac0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15040 as u32) ) } as u64;
	// 828C4D3C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C4D40: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C4D44: 4B9FB2BD  bl 0x822c0000
	ctx.lr = 0x828C4D48;
	sub_822C0000(ctx, base);
	// 828C4D48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4D4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C4D50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C4D54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C4D58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C4D5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C4D60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4D68 size=196
    let mut pc: u32 = 0x828C4D68;
    'dispatch: loop {
        match pc {
            0x828C4D68 => {
    //   block [0x828C4D68..0x828C4E2C)
	// 828C4D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C4D6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C4D70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C4D74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C4D78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4D7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C4D80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C4D84: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C4D88: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C4D8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C4D90: 4B9FBBA9  bl 0x822c0938
	ctx.lr = 0x828C4D94;
	sub_822C0938(ctx, base);
	// 828C4D94: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C4D98: 41820028  beq 0x828c4dc0
	if ctx.cr[0].eq {
	pc = 0x828C4DC0; continue 'dispatch;
	}
	// 828C4D9C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C4DA0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828C4DA4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C4DA8: 392BD72C  addi r9, r11, -0x28d4
	ctx.r[9].s64 = ctx.r[11].s64 + -10452;
	// 828C4DAC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C4DB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C4DB4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C4DB8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C4DBC: 48000008  b 0x828c4dc4
	pc = 0x828C4DC4; continue 'dispatch;
	// 828C4DC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C4DC4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C4DC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4DCC: 409A0044  bne cr6, 0x828c4e10
	if !ctx.cr[6].eq {
	pc = 0x828C4E10; continue 'dispatch;
	}
	// 828C4DD0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C4DD4: 419A001C  beq cr6, 0x828c4df0
	if ctx.cr[6].eq {
	pc = 0x828C4DF0; continue 'dispatch;
	}
	// 828C4DD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4DDC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C4DE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C4DE4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4DE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C4DEC: 4E800421  bctrl
	ctx.lr = 0x828C4DF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C4DF0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C4DF4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C4DF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4DFC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828C4E00: 816B3AC0  lwz r11, 0x3ac0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15040 as u32) ) } as u64;
	// 828C4E04: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C4E08: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C4E0C: 4B9FB1F5  bl 0x822c0000
	ctx.lr = 0x828C4E10;
	sub_822C0000(ctx, base);
	// 828C4E10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4E14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C4E18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C4E1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C4E20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C4E24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C4E28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4E30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4E30 size=196
    let mut pc: u32 = 0x828C4E30;
    'dispatch: loop {
        match pc {
            0x828C4E30 => {
    //   block [0x828C4E30..0x828C4EF4)
	// 828C4E30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C4E34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C4E38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C4E3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C4E40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4E44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C4E48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C4E4C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C4E50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C4E54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C4E58: 4B9FBAE1  bl 0x822c0938
	ctx.lr = 0x828C4E5C;
	sub_822C0938(ctx, base);
	// 828C4E5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C4E60: 41820028  beq 0x828c4e88
	if ctx.cr[0].eq {
	pc = 0x828C4E88; continue 'dispatch;
	}
	// 828C4E64: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C4E68: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828C4E6C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C4E70: 392BD740  addi r9, r11, -0x28c0
	ctx.r[9].s64 = ctx.r[11].s64 + -10432;
	// 828C4E74: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C4E78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C4E7C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C4E80: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C4E84: 48000008  b 0x828c4e8c
	pc = 0x828C4E8C; continue 'dispatch;
	// 828C4E88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C4E8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C4E90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4E94: 409A0044  bne cr6, 0x828c4ed8
	if !ctx.cr[6].eq {
	pc = 0x828C4ED8; continue 'dispatch;
	}
	// 828C4E98: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C4E9C: 419A001C  beq cr6, 0x828c4eb8
	if ctx.cr[6].eq {
	pc = 0x828C4EB8; continue 'dispatch;
	}
	// 828C4EA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4EA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C4EA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C4EAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C4EB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C4EB4: 4E800421  bctrl
	ctx.lr = 0x828C4EB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C4EB8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C4EBC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C4EC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4EC4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828C4EC8: 816B3AC0  lwz r11, 0x3ac0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15040 as u32) ) } as u64;
	// 828C4ECC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C4ED0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C4ED4: 4B9FB12D  bl 0x822c0000
	ctx.lr = 0x828C4ED8;
	sub_822C0000(ctx, base);
	// 828C4ED8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4EDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C4EE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C4EE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C4EE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C4EEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C4EF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4EF8 size=196
    let mut pc: u32 = 0x828C4EF8;
    'dispatch: loop {
        match pc {
            0x828C4EF8 => {
    //   block [0x828C4EF8..0x828C4FBC)
	// 828C4EF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C4EFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C4F00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C4F04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C4F08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4F0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C4F10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C4F14: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C4F18: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C4F1C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C4F20: 4B9FBA19  bl 0x822c0938
	ctx.lr = 0x828C4F24;
	sub_822C0938(ctx, base);
	// 828C4F24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C4F28: 41820028  beq 0x828c4f50
	if ctx.cr[0].eq {
	pc = 0x828C4F50; continue 'dispatch;
	}
	// 828C4F2C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C4F30: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828C4F34: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C4F38: 392BD754  addi r9, r11, -0x28ac
	ctx.r[9].s64 = ctx.r[11].s64 + -10412;
	// 828C4F3C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C4F40: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C4F44: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C4F48: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C4F4C: 48000008  b 0x828c4f54
	pc = 0x828C4F54; continue 'dispatch;
	// 828C4F50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C4F54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C4F58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C4F5C: 409A0044  bne cr6, 0x828c4fa0
	if !ctx.cr[6].eq {
	pc = 0x828C4FA0; continue 'dispatch;
	}
	// 828C4F60: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C4F64: 419A001C  beq cr6, 0x828c4f80
	if ctx.cr[6].eq {
	pc = 0x828C4F80; continue 'dispatch;
	}
	// 828C4F68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4F6C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C4F70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C4F74: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C4F78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C4F7C: 4E800421  bctrl
	ctx.lr = 0x828C4F80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C4F80: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C4F84: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C4F88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C4F8C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828C4F90: 816B3AC0  lwz r11, 0x3ac0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15040 as u32) ) } as u64;
	// 828C4F94: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C4F98: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C4F9C: 4B9FB065  bl 0x822c0000
	ctx.lr = 0x828C4FA0;
	sub_822C0000(ctx, base);
	// 828C4FA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C4FA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C4FA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C4FAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C4FB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C4FB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C4FB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C4FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C4FC0 size=196
    let mut pc: u32 = 0x828C4FC0;
    'dispatch: loop {
        match pc {
            0x828C4FC0 => {
    //   block [0x828C4FC0..0x828C5084)
	// 828C4FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C4FC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C4FC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C4FCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C4FD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C4FD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C4FD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C4FDC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C4FE0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C4FE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C4FE8: 4B9FB951  bl 0x822c0938
	ctx.lr = 0x828C4FEC;
	sub_822C0938(ctx, base);
	// 828C4FEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C4FF0: 41820028  beq 0x828c5018
	if ctx.cr[0].eq {
	pc = 0x828C5018; continue 'dispatch;
	}
	// 828C4FF4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C4FF8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828C4FFC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C5000: 392BD768  addi r9, r11, -0x2898
	ctx.r[9].s64 = ctx.r[11].s64 + -10392;
	// 828C5004: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C5008: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C500C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C5010: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C5014: 48000008  b 0x828c501c
	pc = 0x828C501C; continue 'dispatch;
	// 828C5018: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C501C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C5020: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C5024: 409A0044  bne cr6, 0x828c5068
	if !ctx.cr[6].eq {
	pc = 0x828C5068; continue 'dispatch;
	}
	// 828C5028: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C502C: 419A001C  beq cr6, 0x828c5048
	if ctx.cr[6].eq {
	pc = 0x828C5048; continue 'dispatch;
	}
	// 828C5030: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5034: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C5038: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C503C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5040: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C5044: 4E800421  bctrl
	ctx.lr = 0x828C5048;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C5048: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C504C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C5050: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C5054: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828C5058: 816B3AC0  lwz r11, 0x3ac0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15040 as u32) ) } as u64;
	// 828C505C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C5060: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C5064: 4B9FAF9D  bl 0x822c0000
	ctx.lr = 0x828C5068;
	sub_822C0000(ctx, base);
	// 828C5068: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C506C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C5070: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C5074: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C5078: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C507C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C5080: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C5088 size=196
    let mut pc: u32 = 0x828C5088;
    'dispatch: loop {
        match pc {
            0x828C5088 => {
    //   block [0x828C5088..0x828C514C)
	// 828C5088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C508C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C5090: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C5094: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C5098: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C509C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C50A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C50A4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C50A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C50AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C50B0: 4B9FB889  bl 0x822c0938
	ctx.lr = 0x828C50B4;
	sub_822C0938(ctx, base);
	// 828C50B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C50B8: 41820028  beq 0x828c50e0
	if ctx.cr[0].eq {
	pc = 0x828C50E0; continue 'dispatch;
	}
	// 828C50BC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C50C0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828C50C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C50C8: 392BD77C  addi r9, r11, -0x2884
	ctx.r[9].s64 = ctx.r[11].s64 + -10372;
	// 828C50CC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C50D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C50D4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C50D8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C50DC: 48000008  b 0x828c50e4
	pc = 0x828C50E4; continue 'dispatch;
	// 828C50E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C50E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C50E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C50EC: 409A0044  bne cr6, 0x828c5130
	if !ctx.cr[6].eq {
	pc = 0x828C5130; continue 'dispatch;
	}
	// 828C50F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C50F4: 419A001C  beq cr6, 0x828c5110
	if ctx.cr[6].eq {
	pc = 0x828C5110; continue 'dispatch;
	}
	// 828C50F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C50FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C5100: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C5104: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5108: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C510C: 4E800421  bctrl
	ctx.lr = 0x828C5110;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C5110: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C5114: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C5118: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C511C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828C5120: 816B3AC0  lwz r11, 0x3ac0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15040 as u32) ) } as u64;
	// 828C5124: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C5128: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C512C: 4B9FAED5  bl 0x822c0000
	ctx.lr = 0x828C5130;
	sub_822C0000(ctx, base);
	// 828C5130: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C5134: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C5138: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C513C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C5140: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C5144: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C5148: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C5150 size=164
    let mut pc: u32 = 0x828C5150;
    'dispatch: loop {
        match pc {
            0x828C5150 => {
    //   block [0x828C5150..0x828C51F4)
	// 828C5150: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C5154: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C5158: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C515C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C5160: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C5164: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C5168: 4BF2A649  bl 0x827ef7b0
	ctx.lr = 0x828C516C;
	sub_827EF7B0(ctx, base);
	// 828C516C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C5170: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828C5174: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 828C5178: 396B3AD0  addi r11, r11, 0x3ad0
	ctx.r[11].s64 = ctx.r[11].s64 + 15056;
	// 828C517C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828C5180: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C51F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C51F8 size=264
    let mut pc: u32 = 0x828C51F8;
    'dispatch: loop {
        match pc {
            0x828C51F8 => {
    //   block [0x828C51F8..0x828C5300)
	// 828C51F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C51FC: 488E2F71  bl 0x831a816c
	ctx.lr = 0x828C5200;
	sub_831A8130(ctx, base);
	// 828C5200: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C5204: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C5208: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828C520C: 4805155D  bl 0x82916768
	ctx.lr = 0x828C5210;
	sub_82916768(ctx, base);
	// 828C5210: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828C5214: 418200E4  beq 0x828c52f8
	if ctx.cr[0].eq {
	pc = 0x828C52F8; continue 'dispatch;
	}
	// 828C5218: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C521C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C5220: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C5224: 816B00A0  lwz r11, 0xa0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) } as u64;
	// 828C5228: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C522C: 4E800421  bctrl
	ctx.lr = 0x828C5230;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C5230: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5234: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C5238: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C523C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C5240: 4E800421  bctrl
	ctx.lr = 0x828C5244;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C5244: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C5248: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 828C524C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C5250: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C5300 size=192
    let mut pc: u32 = 0x828C5300;
    'dispatch: loop {
        match pc {
            0x828C5300 => {
    //   block [0x828C5300..0x828C53C0)
	// 828C5300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C5304: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C5308: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C530C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C5310: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C5314: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C5318: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C531C: 4888F2E5  bl 0x83154600
	ctx.lr = 0x828C5320;
	sub_83154600(ctx, base);
	// 828C5320: 48051449  bl 0x82916768
	ctx.lr = 0x828C5324;
	sub_82916768(ctx, base);
	// 828C5324: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C5328: 4182003C  beq 0x828c5364
	if ctx.cr[0].eq {
	pc = 0x828C5364; continue 'dispatch;
	}
	// 828C532C: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 828C5330: 39400220  li r10, 0x220
	ctx.r[10].s64 = 544;
	// 828C5334: 39200040  li r9, 0x40
	ctx.r[9].s64 = 64;
	// 828C5338: 39000230  li r8, 0x230
	ctx.r[8].s64 = 560;
	// 828C533C: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 828C5340: 38C00210  li r6, 0x210
	ctx.r[6].s64 = 528;
	// 828C5344: 13FF58C7  vcmpequd (lvx128) v31, v31, v11
	tmp.u32 = ctx.r[31].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C53C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C53C0 size=96
    let mut pc: u32 = 0x828C53C0;
    'dispatch: loop {
        match pc {
            0x828C53C0 => {
    //   block [0x828C53C0..0x828C5420)
	// 828C53C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C53C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C53C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C53CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C53D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C53D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C53D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C53DC: 807F0044  lwz r3, 0x44(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 828C53E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C53E4: 419A0008  beq cr6, 0x828c53ec
	if ctx.cr[6].eq {
	pc = 0x828C53EC; continue 'dispatch;
	}
	// 828C53E8: 4B9FB4A9  bl 0x822c0890
	ctx.lr = 0x828C53EC;
	sub_822C0890(ctx, base);
	// 828C53EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C53F0: 485941E9  bl 0x82e595d8
	ctx.lr = 0x828C53F4;
	sub_82E595D8(ctx, base);
	// 828C53F4: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C53F8: 4182000C  beq 0x828c5404
	if ctx.cr[0].eq {
	pc = 0x828C5404; continue 'dispatch;
	}
	// 828C53FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C5400: 4852CFD9  bl 0x82df23d8
	ctx.lr = 0x828C5404;
	sub_82DF23D8(ctx, base);
	// 828C5404: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C5408: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C540C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C5410: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C5414: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C5418: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C541C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C5420 size=72
    let mut pc: u32 = 0x828C5420;
    'dispatch: loop {
        match pc {
            0x828C5420 => {
    //   block [0x828C5420..0x828C5468)
	// 828C5420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C5424: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C5428: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C542C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828C5430: 419A001C  beq cr6, 0x828c544c
	if ctx.cr[6].eq {
	pc = 0x828C544C; continue 'dispatch;
	}
	// 828C5434: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828C5438: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C543C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828C5440: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C5444: 4BFFF3ED  bl 0x828c4830
	ctx.lr = 0x828C5448;
	sub_828C4830(ctx, base);
	// 828C5448: 48000010  b 0x828c5458
	pc = 0x828C5458; continue 'dispatch;
	// 828C544C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C5450: 396B3FA0  addi r11, r11, 0x3fa0
	ctx.r[11].s64 = ctx.r[11].s64 + 16288;
	// 828C5454: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C5458: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C545C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C5460: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C5464: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C5468 size=312
    let mut pc: u32 = 0x828C5468;
    'dispatch: loop {
        match pc {
            0x828C5468 => {
    //   block [0x828C5468..0x828C55A0)
	// 828C5468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C546C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C5470: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C5474: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C5478: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C547C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C5480: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C5484: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C5488: 808B3854  lwz r4, 0x3854(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14420 as u32) ) } as u64;
	// 828C548C: 4852E57D  bl 0x82df3a08
	ctx.lr = 0x828C5490;
	sub_82DF3A08(ctx, base);
	// 828C5490: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5494: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C5498: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C549C: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C54A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C54A4: 4E800421  bctrl
	ctx.lr = 0x828C54A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C54A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C54AC: 4852DF7D  bl 0x82df3428
	ctx.lr = 0x828C54B0;
	sub_82DF3428(ctx, base);
	// 828C54B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C54B4: 480512B5  bl 0x82916768
	ctx.lr = 0x828C54B8;
	sub_82916768(ctx, base);
	// 828C54B8: 480440D1  bl 0x82909588
	ctx.lr = 0x828C54BC;
	sub_82909588(ctx, base);
	// 828C54BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C54C0: 4807AFE9  bl 0x829404a8
	ctx.lr = 0x828C54C4;
	sub_829404A8(ctx, base);
	// 828C54C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C54C8: 4807CB21  bl 0x82941fe8
	ctx.lr = 0x828C54CC;
	sub_82941FE8(ctx, base);
	// 828C54CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C54D0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828C54D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C54D8: 388AD7B0  addi r4, r10, -0x2850
	ctx.r[4].s64 = ctx.r[10].s64 + -10320;
	// 828C54DC: 38A000A1  li r5, 0xa1
	ctx.r[5].s64 = 161;
	// 828C54E0: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C54E4: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828C54E8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828C54EC: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828C54F0: 4B9FAEE9  bl 0x822c03d8
	ctx.lr = 0x828C54F4;
	sub_822C03D8(ctx, base);
	// 828C54F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C54F8: 41820018  beq 0x828c5510
	if ctx.cr[0].eq {
	pc = 0x828C5510; continue 'dispatch;
	}
	// 828C54FC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828C5500: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C5504: 4807CB05  bl 0x82942008
	ctx.lr = 0x828C5508;
	sub_82942008(ctx, base);
	// 828C5508: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C550C: 48000008  b 0x828c5514
	pc = 0x828C5514; continue 'dispatch;
	// 828C5510: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C5514: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828C5518: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C551C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C5520: 4BFA8911  bl 0x8286de30
	ctx.lr = 0x828C5524;
	sub_8286DE30(ctx, base);
	// 828C5524: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C5528: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C552C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C5530: 4B9FAAD1  bl 0x822c0000
	ctx.lr = 0x828C5534;
	sub_822C0000(ctx, base);
	// 828C5534: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C5538: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C553C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C5540: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828C5544: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828C5548: 419A0024  beq cr6, 0x828c556c
	if ctx.cr[6].eq {
	pc = 0x828C556C; continue 'dispatch;
	}
	// 828C554C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828C5550: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C5554: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C5558: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C555C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C5560: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C5564: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C5568: 4082FFE8  bne 0x828c5550
	if !ctx.cr[0].eq {
	pc = 0x828C5550; continue 'dispatch;
	}
	// 828C556C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C5570: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C5574: 4807AF3D  bl 0x829404b0
	ctx.lr = 0x828C5578;
	sub_829404B0(ctx, base);
	// 828C5578: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C557C: 419A000C  beq cr6, 0x828c5588
	if ctx.cr[6].eq {
	pc = 0x828C5588; continue 'dispatch;
	}
	// 828C5580: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C5584: 4B9FB30D  bl 0x822c0890
	ctx.lr = 0x828C5588;
	sub_822C0890(ctx, base);
	// 828C5588: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C558C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C5590: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C5594: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C5598: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C559C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C55A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C55A0 size=460
    let mut pc: u32 = 0x828C55A0;
    'dispatch: loop {
        match pc {
            0x828C55A0 => {
    //   block [0x828C55A0..0x828C576C)
	// 828C55A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C55A4: 488E2BC9  bl 0x831a816c
	ctx.lr = 0x828C55A8;
	sub_831A8130(ctx, base);
	// 828C55A8: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 828C55AC: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828C55B0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C55B4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C55B8: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 828C55BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C55C0: 480511A9  bl 0x82916768
	ctx.lr = 0x828C55C4;
	sub_82916768(ctx, base);
	// 828C55C4: 48043FC5  bl 0x82909588
	ctx.lr = 0x828C55C8;
	sub_82909588(ctx, base);
	// 828C55C8: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 828C55CC: 4807AE85  bl 0x82940450
	ctx.lr = 0x828C55D0;
	sub_82940450(ctx, base);
	// 828C55D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C55D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C55D8: 4807D0F9  bl 0x829426d0
	ctx.lr = 0x828C55DC;
	sub_829426D0(ctx, base);
	// 828C55DC: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C55E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C55E4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828C55E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C55EC: 4E800421  bctrl
	ctx.lr = 0x828C55F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C55F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C55F4: 4182003C  beq 0x828c5630
	if ctx.cr[0].eq {
	pc = 0x828C5630; continue 'dispatch;
	}
	// 828C55F8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828C55FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C5600: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828C5604: 4852E405  bl 0x82df3a08
	ctx.lr = 0x828C5608;
	sub_82DF3A08(ctx, base);
	// 828C5608: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C560C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C5610: 4BF2A131  bl 0x827ef740
	ctx.lr = 0x828C5614;
	sub_827EF740(ctx, base);
	// 828C5614: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C5618: 4852DE11  bl 0x82df3428
	ctx.lr = 0x828C561C;
	sub_82DF3428(ctx, base);
	// 828C561C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C5620: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C5624: 419A0138  beq cr6, 0x828c575c
	if ctx.cr[6].eq {
	pc = 0x828C575C; continue 'dispatch;
	}
	// 828C5628: 4B9FB269  bl 0x822c0890
	ctx.lr = 0x828C562C;
	sub_822C0890(ctx, base);
	// 828C562C: 48000130  b 0x828c575c
	pc = 0x828C575C; continue 'dispatch;
	// 828C5630: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C5634: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5638: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828C563C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C5640: 4E800421  bctrl
	ctx.lr = 0x828C5644;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C5644: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C5648: 3FA0832D  lis r29, -0x7cd3
	ctx.r[29].s64 = -2094202880;
	// 828C564C: 4082003C  bne 0x828c5688
	if !ctx.cr[0].eq {
	pc = 0x828C5688; continue 'dispatch;
	}
	// 828C5650: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C5654: 48051115  bl 0x82916768
	ctx.lr = 0x828C5658;
	sub_82916768(ctx, base);
	// 828C5658: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C565C: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828C5660: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C5664: 48049715  bl 0x8290ed78
	ctx.lr = 0x828C5668;
	sub_8290ED78(ctx, base);
	// 828C5668: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C566C: 809D0B10  lwz r4, 0xb10(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(2832 as u32) ) } as u64;
	// 828C5670: 4852E399  bl 0x82df3a08
	ctx.lr = 0x828C5674;
	sub_82DF3A08(ctx, base);
	// 828C5674: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C5678: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C567C: 4BF2A0C5  bl 0x827ef740
	ctx.lr = 0x828C5680;
	sub_827EF740(ctx, base);
	// 828C5680: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C5684: 4852DDA5  bl 0x82df3428
	ctx.lr = 0x828C5688;
	sub_82DF3428(ctx, base);
	// 828C5688: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C568C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C5690: 419A0008  beq cr6, 0x828c5698
	if ctx.cr[6].eq {
	pc = 0x828C5698; continue 'dispatch;
	}
	// 828C5694: 4B9FB1FD  bl 0x822c0890
	ctx.lr = 0x828C5698;
	sub_822C0890(ctx, base);
	// 828C5698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C569C: 4BFFD235  bl 0x828c28d0
	ctx.lr = 0x828C56A0;
	sub_828C28D0(ctx, base);
	// 828C56A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C56A4: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828C56A8: 4BFFCFC9  bl 0x828c2670
	ctx.lr = 0x828C56AC;
	sub_828C2670(ctx, base);
	// 828C56AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C56B0: C01E007C  lfs f0, 0x7c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C56B4: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828C56B8: 40980028  bge cr6, 0x828c56e0
	if !ctx.cr[6].lt {
	pc = 0x828C56E0; continue 'dispatch;
	}
	// 828C56BC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828C56C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C56C4: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828C56C8: 4852E341  bl 0x82df3a08
	ctx.lr = 0x828C56CC;
	sub_82DF3A08(ctx, base);
	// 828C56CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C56D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C56D4: 4BF2A06D  bl 0x827ef740
	ctx.lr = 0x828C56D8;
	sub_827EF740(ctx, base);
	// 828C56D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C56DC: 4852DD4D  bl 0x82df3428
	ctx.lr = 0x828C56E0;
	sub_82DF3428(ctx, base);
	// 828C56E0: C01E0080  lfs f0, 0x80(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C56E4: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828C56E8: 40990024  ble cr6, 0x828c570c
	if !ctx.cr[6].gt {
	pc = 0x828C570C; continue 'dispatch;
	}
	// 828C56EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C56F0: 809D0B10  lwz r4, 0xb10(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(2832 as u32) ) } as u64;
	// 828C56F4: 4852E315  bl 0x82df3a08
	ctx.lr = 0x828C56F8;
	sub_82DF3A08(ctx, base);
	// 828C56F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C56FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C5700: 4BF2A041  bl 0x827ef740
	ctx.lr = 0x828C5704;
	sub_827EF740(ctx, base);
	// 828C5704: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C5708: 4852DD21  bl 0x82df3428
	ctx.lr = 0x828C570C;
	sub_82DF3428(ctx, base);
	// 828C570C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C5710: 48051059  bl 0x82916768
	ctx.lr = 0x828C5714;
	sub_82916768(ctx, base);
	// 828C5714: 48043E75  bl 0x82909588
	ctx.lr = 0x828C5718;
	sub_82909588(ctx, base);
	// 828C5718: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828C571C: 41820040  beq 0x828c575c
	if ctx.cr[0].eq {
	pc = 0x828C575C; continue 'dispatch;
	}
	// 828C5720: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C5724: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828C5728: 4807ABF1  bl 0x82940318
	ctx.lr = 0x828C572C;
	sub_82940318(ctx, base);
	// 828C572C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C5730: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C5734: 4807AAD5  bl 0x82940208
	ctx.lr = 0x828C5738;
	sub_82940208(ctx, base);
	// 828C5738: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828C573C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828C5740: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828C5744: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C5748: C02B4494  lfs f1, 0x4494(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17556 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C574C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5750: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828C5754: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C5758: 4E800421  bctrl
	ctx.lr = 0x828C575C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C575C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828C5760: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828C5764: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828C5768: 488E2A54  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C5770 size=212
    let mut pc: u32 = 0x828C5770;
    'dispatch: loop {
        match pc {
            0x828C5770 => {
    //   block [0x828C5770..0x828C5844)
	// 828C5770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C5774: 488E29F9  bl 0x831a816c
	ctx.lr = 0x828C5778;
	sub_831A8130(ctx, base);
	// 828C5778: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C577C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C5780: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C5784: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C5788: 48050FE1  bl 0x82916768
	ctx.lr = 0x828C578C;
	sub_82916768(ctx, base);
	// 828C578C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828C5790: 41820064  beq 0x828c57f4
	if ctx.cr[0].eq {
	pc = 0x828C57F4; continue 'dispatch;
	}
	// 828C5794: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5798: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C579C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C57A0: 816B00BC  lwz r11, 0xbc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 828C57A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C57A8: 4E800421  bctrl
	ctx.lr = 0x828C57AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C57AC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828C57B0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 828C57B4: 3D20832C  lis r9, -0x7cd4
	ctx.r[9].s64 = -2094268416;
	// 828C57B8: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 828C57BC: 39293AD0  addi r9, r9, 0x3ad0
	ctx.r[9].s64 = ctx.r[9].s64 + 15056;
	// 828C57C0: C00B89AC  lfs f0, -0x7654(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C57C4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828C57C8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828C57CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C57D0: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C5848 size=124
    let mut pc: u32 = 0x828C5848;
    'dispatch: loop {
        match pc {
            0x828C5848 => {
    //   block [0x828C5848..0x828C58C4)
	// 828C5848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C584C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C5850: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C5854: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C5858: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C585C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C5860: 48051539  bl 0x82916d98
	ctx.lr = 0x828C5864;
	sub_82916D98(ctx, base);
	// 828C5864: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C5868: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C586C: 419A0018  beq cr6, 0x828c5884
	if ctx.cr[6].eq {
	pc = 0x828C5884; continue 'dispatch;
	}
	// 828C5870: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 828C5874: 392000D0  li r9, 0xd0
	ctx.r[9].s64 = 208;
	// 828C5878: 394AAA50  addi r10, r10, -0x55b0
	ctx.r[10].s64 = ctx.r[10].s64 + -21936;
	// 828C587C: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C58C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C58C8 size=136
    let mut pc: u32 = 0x828C58C8;
    'dispatch: loop {
        match pc {
            0x828C58C8 => {
    //   block [0x828C58C8..0x828C5950)
	// 828C58C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C58CC: 488E28A1  bl 0x831a816c
	ctx.lr = 0x828C58D0;
	sub_831A8130(ctx, base);
	// 828C58D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C58D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828C58D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C58DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C58E0: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 828C58E4: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 828C58E8: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 828C58EC: 4852CAFD  bl 0x82df23e8
	ctx.lr = 0x828C58F0;
	sub_82DF23E8(ctx, base);
	// 828C58F0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828C58F4: 41820028  beq 0x828c591c
	if ctx.cr[0].eq {
	pc = 0x828C591C; continue 'dispatch;
	}
	// 828C58F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C58FC: 48593DA5  bl 0x82e596a0
	ctx.lr = 0x828C5900;
	sub_82E596A0(ctx, base);
	// 828C5900: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828C5904: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C5908: 394AD7A8  addi r10, r10, -0x2858
	ctx.r[10].s64 = ctx.r[10].s64 + -10328;
	// 828C590C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C5910: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 828C5914: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 828C5918: 48000008  b 0x828c5920
	pc = 0x828C5920; continue 'dispatch;
	// 828C591C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C5920: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C5924: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828C5928: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C592C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C5930: 4BFFF691  bl 0x828c4fc0
	ctx.lr = 0x828C5934;
	sub_828C4FC0(ctx, base);
	// 828C5934: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C5938: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C593C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C5940: 4B9FA6C1  bl 0x822c0000
	ctx.lr = 0x828C5944;
	sub_822C0000(ctx, base);
	// 828C5944: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C5948: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C594C: 488E2870  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C5950 size=112
    let mut pc: u32 = 0x828C5950;
    'dispatch: loop {
        match pc {
            0x828C5950 => {
    //   block [0x828C5950..0x828C59C0)
	// 828C5950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C5954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C5958: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C595C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C5960: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C5964: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C5968: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C596C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828C5970: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C5974: 4BFFF715  bl 0x828c5088
	ctx.lr = 0x828C5978;
	sub_828C5088(ctx, base);
	// 828C5978: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C597C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C5980: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C5984: 4B9FA67D  bl 0x822c0000
	ctx.lr = 0x828C5988;
	sub_822C0000(ctx, base);
	// 828C5988: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C598C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C5990: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C5994: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5998: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C599C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C59A0: 419A0008  beq cr6, 0x828c59a8
	if ctx.cr[6].eq {
	pc = 0x828C59A8; continue 'dispatch;
	}
	// 828C59A4: 4B9FAEED  bl 0x822c0890
	ctx.lr = 0x828C59A8;
	sub_822C0890(ctx, base);
	// 828C59A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C59AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C59B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C59B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C59B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C59BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C59C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C59C0 size=492
    let mut pc: u32 = 0x828C59C0;
    'dispatch: loop {
        match pc {
            0x828C59C0 => {
    //   block [0x828C59C0..0x828C5BAC)
	// 828C59C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C59C4: 488E2799  bl 0x831a815c
	ctx.lr = 0x828C59C8;
	sub_831A8130(ctx, base);
	// 828C59C8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C59CC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828C59D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C59D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C59D8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828C59DC: 808BF42C  lwz r4, -0xbd4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3028 as u32) ) } as u64;
	// 828C59E0: 4852E029  bl 0x82df3a08
	ctx.lr = 0x828C59E4;
	sub_82DF3A08(ctx, base);
	// 828C59E4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C59E8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C59EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C59F0: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C59F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C59F8: 4E800421  bctrl
	ctx.lr = 0x828C59FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C59FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C5A00: 4852DA29  bl 0x82df3428
	ctx.lr = 0x828C5A04;
	sub_82DF3428(ctx, base);
	// 828C5A04: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C5A08: 48050D61  bl 0x82916768
	ctx.lr = 0x828C5A0C;
	sub_82916768(ctx, base);
	// 828C5A0C: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828C5A10: 41820138  beq 0x828c5b48
	if ctx.cr[0].eq {
	pc = 0x828C5B48; continue 'dispatch;
	}
	// 828C5A14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C5A18: 4BFFFEB1  bl 0x828c58c8
	ctx.lr = 0x828C5A1C;
	sub_828C58C8(ctx, base);
	// 828C5A1C: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C5A20: 83410050  lwz r26, 0x50(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C5A24: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828C5A28: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 828C5A2C: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 828C5A30: 419A0024  beq cr6, 0x828c5a54
	if ctx.cr[6].eq {
	pc = 0x828C5A54; continue 'dispatch;
	}
	// 828C5A34: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 828C5A38: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C5A3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C5A40: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C5A44: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C5A48: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C5A4C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C5A50: 4082FFE8  bne 0x828c5a38
	if !ctx.cr[0].eq {
	pc = 0x828C5A38; continue 'dispatch;
	}
	// 828C5A54: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C5A58: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C5A5C: 4BC49A6D  bl 0x8250f4c8
	ctx.lr = 0x828C5A60;
	sub_8250F4C8(ctx, base);
	// 828C5A60: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5A64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C5A68: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 828C5A6C: 409A0008  bne cr6, 0x828c5a74
	if !ctx.cr[6].eq {
	pc = 0x828C5A74; continue 'dispatch;
	}
	// 828C5A70: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C5A74: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828C5A78: 3B210058  addi r25, r1, 0x58
	ctx.r[25].s64 = ctx.r[1].s64 + 88;
	// 828C5A7C: 4BC42F9D  bl 0x82508a18
	ctx.lr = 0x828C5A80;
	sub_82508A18(ctx, base);
	// 828C5A80: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C5A84: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828C5A88: 3BEBD7B0  addi r31, r11, -0x2850
	ctx.r[31].s64 = ctx.r[11].s64 + -10320;
	// 828C5A8C: 38A0024C  li r5, 0x24c
	ctx.r[5].s64 = 588;
	// 828C5A90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C5A94: 387D0028  addi r3, r29, 0x28
	ctx.r[3].s64 = ctx.r[29].s64 + 40;
	// 828C5A98: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 828C5A9C: 4859154D  bl 0x82e56fe8
	ctx.lr = 0x828C5AA0;
	sub_82E56FE8(ctx, base);
	// 828C5AA0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C5AA4: 4852C1ED  bl 0x82df1c90
	ctx.lr = 0x828C5AA8;
	sub_82DF1C90(ctx, base);
	// 828C5AA8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C5AAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C5AB0: 419A0008  beq cr6, 0x828c5ab8
	if ctx.cr[6].eq {
	pc = 0x828C5AB8; continue 'dispatch;
	}
	// 828C5AB4: 4B9FADDD  bl 0x822c0890
	ctx.lr = 0x828C5AB8;
	sub_822C0890(ctx, base);
	// 828C5AB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C5ABC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C5AC0: 38A0024E  li r5, 0x24e
	ctx.r[5].s64 = 590;
	// 828C5AC4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C5AC8: 4852C921  bl 0x82df23e8
	ctx.lr = 0x828C5ACC;
	sub_82DF23E8(ctx, base);
	// 828C5ACC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C5AD0: 41820024  beq 0x828c5af4
	if ctx.cr[0].eq {
	pc = 0x828C5AF4; continue 'dispatch;
	}
	// 828C5AD4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C5AD8: 93830008  stw r28, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 828C5ADC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C5AE0: 396BD790  addi r11, r11, -0x2870
	ctx.r[11].s64 = ctx.r[11].s64 + -10352;
	// 828C5AE4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C5AE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C5AEC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C5AF0: 48000008  b 0x828c5af8
	pc = 0x828C5AF8; continue 'dispatch;
	// 828C5AF4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828C5AF8: 387E006C  addi r3, r30, 0x6c
	ctx.r[3].s64 = ctx.r[30].s64 + 108;
	// 828C5AFC: 4BFFFE55  bl 0x828c5950
	ctx.lr = 0x828C5B00;
	sub_828C5950(ctx, base);
	// 828C5B00: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828C5B04: 807E0074  lwz r3, 0x74(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) } as u64;
	// 828C5B08: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 828C5B0C: 4BCC535D  bl 0x8258ae68
	ctx.lr = 0x828C5B10;
	sub_8258AE68(ctx, base);
	// 828C5B10: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828C5B14: 807E0074  lwz r3, 0x74(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) } as u64;
	// 828C5B18: 388BBA80  addi r4, r11, -0x4580
	ctx.r[4].s64 = ctx.r[11].s64 + -17792;
	// 828C5B1C: 4BCC5395  bl 0x8258aeb0
	ctx.lr = 0x828C5B20;
	sub_8258AEB0(ctx, base);
	// 828C5B20: 809E006C  lwz r4, 0x6c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C5B24: 807E0074  lwz r3, 0x74(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) } as u64;
	// 828C5B28: 4854CF99  bl 0x82e12ac0
	ctx.lr = 0x828C5B2C;
	sub_82E12AC0(ctx, base);
	// 828C5B2C: 809E0074  lwz r4, 0x74(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) } as u64;
	// 828C5B30: 807A0040  lwz r3, 0x40(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(64 as u32) ) } as u64;
	// 828C5B34: 4854D2FD  bl 0x82e12e30
	ctx.lr = 0x828C5B38;
	sub_82E12E30(ctx, base);
	// 828C5B38: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828C5B3C: 419A000C  beq cr6, 0x828c5b48
	if ctx.cr[6].eq {
	pc = 0x828C5B48; continue 'dispatch;
	}
	// 828C5B40: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C5B44: 4B9FAD4D  bl 0x822c0890
	ctx.lr = 0x828C5B48;
	sub_822C0890(ctx, base);
	// 828C5B48: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828C5B4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C5B50: 808B0BE8  lwz r4, 0xbe8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3048 as u32) ) } as u64;
	// 828C5B54: 4852DEB5  bl 0x82df3a08
	ctx.lr = 0x828C5B58;
	sub_82DF3A08(ctx, base);
	// 828C5B58: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C5B5C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C5B60: 4BF29C11  bl 0x827ef770
	ctx.lr = 0x828C5B64;
	sub_827EF770(ctx, base);
	// 828C5B64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C5B68: 4852D8C1  bl 0x82df3428
	ctx.lr = 0x828C5B6C;
	sub_82DF3428(ctx, base);
	// 828C5B6C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C5B70: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828C5B74: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C5B78: 480514A9  bl 0x82917020
	ctx.lr = 0x828C5B7C;
	sub_82917020(ctx, base);
	// 828C5B7C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C5B80: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 828C5B84: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C5B88: 48051499  bl 0x82917020
	ctx.lr = 0x828C5B8C;
	sub_82917020(ctx, base);
	// 828C5B8C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828C5B90: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C5B94: 83EB666C  lwz r31, 0x666c(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26220 as u32) ) } as u64;
	// 828C5B98: 4BF29BE1  bl 0x827ef778
	ctx.lr = 0x828C5B9C;
	sub_827EF778(ctx, base);
	// 828C5B9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C5BA0: 4BBC9801  bl 0x8248f3a0
	ctx.lr = 0x828C5BA4;
	sub_8248F3A0(ctx, base);
	// 828C5BA4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C5BA8: 488E2604  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5BB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C5BB0 size=352
    let mut pc: u32 = 0x828C5BB0;
    'dispatch: loop {
        match pc {
            0x828C5BB0 => {
    //   block [0x828C5BB0..0x828C5D10)
	// 828C5BB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C5BB4: 488E25B5  bl 0x831a8168
	ctx.lr = 0x828C5BB8;
	sub_831A8130(ctx, base);
	// 828C5BB8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828C5BBC: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C5BC0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C5BC4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828C5BC8: 4888EA39  bl 0x83154600
	ctx.lr = 0x828C5BCC;
	sub_83154600(ctx, base);
	// 828C5BCC: 48050B9D  bl 0x82916768
	ctx.lr = 0x828C5BD0;
	sub_82916768(ctx, base);
	// 828C5BD0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828C5BD4: 4182012C  beq 0x828c5d00
	if ctx.cr[0].eq {
	pc = 0x828C5D00; continue 'dispatch;
	}
	// 828C5BD8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C5BDC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C5BE0: 4BC498E9  bl 0x8250f4c8
	ctx.lr = 0x828C5BE4;
	sub_8250F4C8(ctx, base);
	// 828C5BE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5BE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C5BEC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 828C5BF0: 409A0008  bne cr6, 0x828c5bf8
	if !ctx.cr[6].eq {
	pc = 0x828C5BF8; continue 'dispatch;
	}
	// 828C5BF4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C5BF8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828C5BFC: 4BC42E1D  bl 0x82508a18
	ctx.lr = 0x828C5C00;
	sub_82508A18(ctx, base);
	// 828C5C00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C5C04: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C5C08: 4852C089  bl 0x82df1c90
	ctx.lr = 0x828C5C0C;
	sub_82DF1C90(ctx, base);
	// 828C5C0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C5C10: 48742519  bl 0x83008128
	ctx.lr = 0x828C5C14;
	sub_83008128(ctx, base);
	// 828C5C14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C5C18: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828C5C1C: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828C5C20: 419A0084  beq cr6, 0x828c5ca4
	if ctx.cr[6].eq {
	pc = 0x828C5CA4; continue 'dispatch;
	}
	// 828C5C24: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828C5C28: 4BAF9401  bl 0x823bf028
	ctx.lr = 0x828C5C2C;
	sub_823BF028(ctx, base);
	// 828C5C2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5C30: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828C5C34: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5C38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C5C3C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828C5C40: 419A0024  beq cr6, 0x828c5c64
	if ctx.cr[6].eq {
	pc = 0x828C5C64; continue 'dispatch;
	}
	// 828C5C44: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828C5C48: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C5C4C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C5C50: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C5C54: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C5C58: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C5C5C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C5C60: 4082FFE8  bne 0x828c5c48
	if !ctx.cr[0].eq {
	pc = 0x828C5C48; continue 'dispatch;
	}
	// 828C5C64: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C5C68: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828C5C6C: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 828C5C70: 388BD7B0  addi r4, r11, -0x2850
	ctx.r[4].s64 = ctx.r[11].s64 + -10320;
	// 828C5C74: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828C5C78: 38A00282  li r5, 0x282
	ctx.r[5].s64 = 642;
	// 828C5C7C: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 828C5C80: 48592DC1  bl 0x82e58a40
	ctx.lr = 0x828C5C84;
	sub_82E58A40(ctx, base);
	// 828C5C84: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C5C88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C5C8C: 419A0008  beq cr6, 0x828c5c94
	if ctx.cr[6].eq {
	pc = 0x828C5C94; continue 'dispatch;
	}
	// 828C5C90: 4B9FAC01  bl 0x822c0890
	ctx.lr = 0x828C5C94;
	sub_822C0890(ctx, base);
	// 828C5C94: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C5C98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C5C9C: 419A0008  beq cr6, 0x828c5ca4
	if ctx.cr[6].eq {
	pc = 0x828C5CA4; continue 'dispatch;
	}
	// 828C5CA0: 4B9FABF1  bl 0x822c0890
	ctx.lr = 0x828C5CA4;
	sub_822C0890(ctx, base);
	// 828C5CA4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C5CA8: 4888E959  bl 0x83154600
	ctx.lr = 0x828C5CAC;
	sub_83154600(ctx, base);
	// 828C5CAC: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 828C5CB0: 4182000C  beq 0x828c5cbc
	if ctx.cr[0].eq {
	pc = 0x828C5CBC; continue 'dispatch;
	}
	// 828C5CB4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C5CB8: 4BFFFB91  bl 0x828c5848
	ctx.lr = 0x828C5CBC;
	sub_828C5848(ctx, base);
	// 828C5CBC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828C5CC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C5CC4: 808B0B70  lwz r4, 0xb70(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2928 as u32) ) } as u64;
	// 828C5CC8: 4852DD41  bl 0x82df3a08
	ctx.lr = 0x828C5CCC;
	sub_82DF3A08(ctx, base);
	// 828C5CCC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828C5CD0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828C5CD4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828C5CD8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828C5CDC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C5CE0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828C5CE4: 48598DAD  bl 0x82e5ea90
	ctx.lr = 0x828C5CE8;
	sub_82E5EA90(ctx, base);
	// 828C5CE8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828C5CEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C5CF0: 419A0008  beq cr6, 0x828c5cf8
	if ctx.cr[6].eq {
	pc = 0x828C5CF8; continue 'dispatch;
	}
	// 828C5CF4: 4B9FAB9D  bl 0x822c0890
	ctx.lr = 0x828C5CF8;
	sub_822C0890(ctx, base);
	// 828C5CF8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828C5CFC: 48000008  b 0x828c5d04
	pc = 0x828C5D04; continue 'dispatch;
	// 828C5D00: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C5D04: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C5D08: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828C5D0C: 488E24AC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C5D10 size=32
    let mut pc: u32 = 0x828C5D10;
    'dispatch: loop {
        match pc {
            0x828C5D10 => {
    //   block [0x828C5D10..0x828C5D30)
	// 828C5D10: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	// 828C5D14: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C5D18: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828C5D1C: 80830014  lwz r4, 0x14(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 828C5D20: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C5D24: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828C5D28: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828C5D2C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C5D30 size=160
    let mut pc: u32 = 0x828C5D30;
    'dispatch: loop {
        match pc {
            0x828C5D30 => {
    //   block [0x828C5D30..0x828C5DD0)
	// 828C5D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C5D34: 488E2435  bl 0x831a8168
	ctx.lr = 0x828C5D38;
	sub_831A8130(ctx, base);
	// 828C5D38: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C5D3C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828C5D40: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C5D44: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C5D48: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 828C5D4C: 41820034  beq 0x828c5d80
	if ctx.cr[0].eq {
	pc = 0x828C5D80; continue 'dispatch;
	}
	// 828C5D50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C5D54: 488E3C35  bl 0x831a9988
	ctx.lr = 0x828C5D58;
	sub_831A9988(ctx, base);
	// 828C5D58: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 828C5D5C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C5D60: 386BFD00  addi r3, r11, -0x300
	ctx.r[3].s64 = ctx.r[11].s64 + -768;
	// 828C5D64: 488E2395  bl 0x831a80f8
	ctx.lr = 0x828C5D68;
	sub_831A80F8(ctx, base);
	// 828C5D68: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C5D6C: 41820014  beq 0x828c5d80
	if ctx.cr[0].eq {
	pc = 0x828C5D80; continue 'dispatch;
	}
	// 828C5D70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C5D74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C5D78: 4BFFF589  bl 0x828c5300
	ctx.lr = 0x828C5D7C;
	sub_828C5300(ctx, base);
	// 828C5D7C: 4800004C  b 0x828c5dc8
	pc = 0x828C5DC8; continue 'dispatch;
	// 828C5D80: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C5D84: 419A0034  beq cr6, 0x828c5db8
	if ctx.cr[6].eq {
	pc = 0x828C5DB8; continue 'dispatch;
	}
	// 828C5D88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C5D8C: 488E3BFD  bl 0x831a9988
	ctx.lr = 0x828C5D90;
	sub_831A9988(ctx, base);
	// 828C5D90: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 828C5D94: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C5D98: 386B39EC  addi r3, r11, 0x39ec
	ctx.r[3].s64 = ctx.r[11].s64 + 14828;
	// 828C5D9C: 488E235D  bl 0x831a80f8
	ctx.lr = 0x828C5DA0;
	sub_831A80F8(ctx, base);
	// 828C5DA0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C5DA4: 41820014  beq 0x828c5db8
	if ctx.cr[0].eq {
	pc = 0x828C5DB8; continue 'dispatch;
	}
	// 828C5DA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C5DAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C5DB0: 4BFFFE01  bl 0x828c5bb0
	ctx.lr = 0x828C5DB4;
	sub_828C5BB0(ctx, base);
	// 828C5DB4: 48000014  b 0x828c5dc8
	pc = 0x828C5DC8; continue 'dispatch;
	// 828C5DB8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828C5DBC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C5DC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C5DC4: 488B86C5  bl 0x8317e488
	ctx.lr = 0x828C5DC8;
	sub_8317E488(ctx, base);
	// 828C5DC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C5DCC: 488E23EC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5DD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C5DD0 size=132
    let mut pc: u32 = 0x828C5DD0;
    'dispatch: loop {
        match pc {
            0x828C5DD0 => {
    //   block [0x828C5DD0..0x828C5E54)
	// 828C5DD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C5DD4: 488E238D  bl 0x831a8160
	ctx.lr = 0x828C5DD8;
	sub_831A8130(ctx, base);
	// 828C5DD8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C5DDC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828C5DE0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C5DE4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C5DE8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828C5DEC: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 828C5DF0: 38C00058  li r6, 0x58
	ctx.r[6].s64 = 88;
	// 828C5DF4: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 828C5DF8: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 828C5DFC: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 828C5E00: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 828C5E04: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 828C5E08: 4852C2C1  bl 0x82df20c8
	ctx.lr = 0x828C5E0C;
	sub_82DF20C8(ctx, base);
	// 828C5E0C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828C5E10: 41820038  beq 0x828c5e48
	if ctx.cr[0].eq {
	pc = 0x828C5E48; continue 'dispatch;
	}
	// 828C5E14: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828C5E18: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828C5E1C: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 828C5E20: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C5E24: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 828C5E28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C5E2C: 4852DDD5  bl 0x82df3c00
	ctx.lr = 0x828C5E30;
	sub_82DF3C00(ctx, base);
	// 828C5E30: 389D0008  addi r4, r29, 8
	ctx.r[4].s64 = ctx.r[29].s64 + 8;
	// 828C5E34: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 828C5E38: 4803BC29  bl 0x82901a60
	ctx.lr = 0x828C5E3C;
	sub_82901A60(ctx, base);
	// 828C5E3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C5E40: 9B5F0050  stb r26, 0x50(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[26].u8 ) };
	// 828C5E44: 997F0051  stb r11, 0x51(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 828C5E48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C5E4C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C5E50: 488E2360  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C5E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C5E58 size=548
    let mut pc: u32 = 0x828C5E58;
    'dispatch: loop {
        match pc {
            0x828C5E58 => {
    //   block [0x828C5E58..0x828C607C)
	// 828C5E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C5E5C: 488E2305  bl 0x831a8160
	ctx.lr = 0x828C5E60;
	sub_831A8130(ctx, base);
	// 828C5E60: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C5E64: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C5E68: 3D6003FF  lis r11, 0x3ff
	ctx.r[11].s64 = 67043328;
	// 828C5E6C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828C5E70: 616BFFFE  ori r11, r11, 0xfffe
	ctx.r[11].u64 = ctx.r[11].u64 | 65534;
	// 828C5E74: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 828C5E78: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C5E7C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 828C5E80: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 828C5E84: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C5E88: 41980048  blt cr6, 0x828c5ed0
	if ctx.cr[6].lt {
	pc = 0x828C5ED0; continue 'dispatch;
	}
	// 828C5E8C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828C5E90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C5E94: 388B9BCC  addi r4, r11, -0x6434
	ctx.r[4].s64 = ctx.r[11].s64 + -25652;
	// 828C5E98: 4B9FFA31  bl 0x822c58c8
	ctx.lr = 0x828C5E9C;
	sub_822C58C8(ctx, base);
	// 828C5E9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C5EA0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828C5EA4: 4B9FF975  bl 0x822c5818
	ctx.lr = 0x828C5EA8;
	sub_822C5818(ctx, base);
	// 828C5EA8: 4B9FE409  bl 0x822c42b0
	ctx.lr = 0x828C5EAC;
	sub_822C42B0(ctx, base);
	// 828C5EAC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828C5EB0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828C5EB4: 396B94A0  addi r11, r11, -0x6b60
	ctx.r[11].s64 = ctx.r[11].s64 + -27488;
	// 828C5EB8: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 828C5EBC: 4B9FF5B5  bl 0x822c5470
	ctx.lr = 0x828C5EC0;
	sub_822C5470(ctx, base);
	// 828C5EC0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828C5EC4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C5EC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C5ECC: 4B9FEE15  bl 0x822c4ce0
	ctx.lr = 0x828C5ED0;
	sub_822C4CE0(ctx, base);
	// 828C5ED0: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5ED4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828C5ED8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828C5EDC: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 828C5EE0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C5EE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C5EE8: 4BFFFEE9  bl 0x828c5dd0
	ctx.lr = 0x828C5EEC;
	sub_828C5DD0(ctx, base);
	// 828C5EEC: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C5EF0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5EF4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C5EF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C5EFC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C5F00: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C5F04: 409A0018  bne cr6, 0x828c5f1c
	if !ctx.cr[6].eq {
	pc = 0x828C5F1C; continue 'dispatch;
	}
	// 828C5F08: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 828C5F0C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5F10: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828C5F14: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5F18: 4800003C  b 0x828c5f54
	pc = 0x828C5F54; continue 'dispatch;
	// 828C5F1C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C5F20: 41820020  beq 0x828c5f40
	if ctx.cr[0].eq {
	pc = 0x828C5F40; continue 'dispatch;
	}
	// 828C5F24: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828C5F28: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5F2C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5F30: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C5F34: 409A0024  bne cr6, 0x828c5f58
	if !ctx.cr[6].eq {
	pc = 0x828C5F58; continue 'dispatch;
	}
	// 828C5F38: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828C5F3C: 4800001C  b 0x828c5f58
	pc = 0x828C5F58; continue 'dispatch;
	// 828C5F40: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 828C5F44: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5F48: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C5F4C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828C5F50: 409A0008  bne cr6, 0x828c5f58
	if !ctx.cr[6].eq {
	pc = 0x828C5F58; continue 'dispatch;
	}
	// 828C5F54: 938B0008  stw r28, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 828C5F58: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5F5C: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828C5F60: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828C5F64: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 828C5F68: 894A0050  lbz r10, 0x50(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C5F6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C5F70: 409A00F0  bne cr6, 0x828c6060
	if !ctx.cr[6].eq {
	pc = 0x828C6060; continue 'dispatch;
	}
	// 828C5F74: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828C5F78: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5F7C: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5F80: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5F84: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828C5F88: 409A0054  bne cr6, 0x828c5fdc
	if !ctx.cr[6].eq {
	pc = 0x828C5FDC; continue 'dispatch;
	}
	// 828C5F8C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C5F90: 892A0050  lbz r9, 0x50(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C5F94: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C5F98: 419A0054  beq cr6, 0x828c5fec
	if ctx.cr[6].eq {
	pc = 0x828C5FEC; continue 'dispatch;
	}
	// 828C5F9C: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C5FA0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C5FA4: 409A0010  bne cr6, 0x828c5fb4
	if !ctx.cr[6].eq {
	pc = 0x828C5FB4; continue 'dispatch;
	}
	// 828C5FA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C5FAC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C5FB0: 4BFFD5E1  bl 0x828c3590
	ctx.lr = 0x828C5FB4;
	sub_828C3590(ctx, base);
	// 828C5FB4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5FB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C5FBC: 9BAB0050  stb r29, 0x50(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 828C5FC0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5FC4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5FC8: 9B6B0050  stb r27, 0x50(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 828C5FCC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5FD0: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C5FD4: 4BFFD555  bl 0x828c3528
	ctx.lr = 0x828C5FD8;
	sub_828C3528(ctx, base);
	// 828C5FD8: 48000074  b 0x828c604c
	pc = 0x828C604C; continue 'dispatch;
	// 828C5FDC: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5FE0: 892A0050  lbz r9, 0x50(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C5FE4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828C5FE8: 409A0028  bne cr6, 0x828c6010
	if !ctx.cr[6].eq {
	pc = 0x828C6010; continue 'dispatch;
	}
	// 828C5FEC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5FF0: 9BA90050  stb r29, 0x50(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 828C5FF4: 9BAA0050  stb r29, 0x50(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 828C5FF8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C5FFC: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C6000: 9B6A0050  stb r27, 0x50(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 828C6004: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6008: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C600C: 48000040  b 0x828c604c
	pc = 0x828C604C; continue 'dispatch;
	// 828C6010: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6014: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C6018: 409A0010  bne cr6, 0x828c6028
	if !ctx.cr[6].eq {
	pc = 0x828C6028; continue 'dispatch;
	}
	// 828C601C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C6020: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C6024: 4BFFD505  bl 0x828c3528
	ctx.lr = 0x828C6028;
	sub_828C3528(ctx, base);
	// 828C6028: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C602C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C6030: 9BAB0050  stb r29, 0x50(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 828C6034: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C6038: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C603C: 9B6B0050  stb r27, 0x50(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 828C6040: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C6044: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C6048: 4BFFD549  bl 0x828c3590
	ctx.lr = 0x828C604C;
	sub_828C3590(ctx, base);
	// 828C604C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C6050: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828C6054: 894A0050  lbz r10, 0x50(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C6058: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828C605C: 419AFF1C  beq cr6, 0x828c5f78
	if ctx.cr[6].eq {
	pc = 0x828C5F78; continue 'dispatch;
	}
	// 828C6060: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C6064: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C6068: 939A0000  stw r28, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828C606C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C6070: 9BAB0050  stb r29, 0x50(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 828C6074: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828C6078: 488E2138  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6080 size=236
    let mut pc: u32 = 0x828C6080;
    'dispatch: loop {
        match pc {
            0x828C6080 => {
    //   block [0x828C6080..0x828C616C)
	// 828C6080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6084: 488E20D9  bl 0x831a815c
	ctx.lr = 0x828C6088;
	sub_831A8130(ctx, base);
	// 828C6088: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C608C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828C6090: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 828C6094: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C6098: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 828C609C: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 828C60A0: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C60A4: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C60A8: 4800002C  b 0x828c60d4
	pc = 0x828C60D4; continue 'dispatch;
	// 828C60AC: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 828C60B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C60B4: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 828C60B8: 4852D181  bl 0x82df3238
	ctx.lr = 0x828C60BC;
	sub_82DF3238(ctx, base);
	// 828C60BC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C60C0: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C60C4: 4182000C  beq 0x828c60d0
	if ctx.cr[0].eq {
	pc = 0x828C60D0; continue 'dispatch;
	}
	// 828C60C8: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C60CC: 48000008  b 0x828c60d4
	pc = 0x828C60D4; continue 'dispatch;
	// 828C60D0: 83BD0008  lwz r29, 8(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C60D4: 897D0051  lbz r11, 0x51(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(81 as u32) ) } as u64;
	// 828C60D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C60DC: 419AFFD0  beq cr6, 0x828c60ac
	if ctx.cr[6].eq {
	pc = 0x828C60AC; continue 'dispatch;
	}
	// 828C60E0: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 828C60E4: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C60E8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828C60EC: 41820048  beq 0x828c6134
	if ctx.cr[0].eq {
	pc = 0x828C6134; continue 'dispatch;
	}
	// 828C60F0: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C60F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C60F8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C60FC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828C6100: 409A002C  bne cr6, 0x828c612c
	if !ctx.cr[6].eq {
	pc = 0x828C612C; continue 'dispatch;
	}
	// 828C6104: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C6108: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828C610C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 828C6110: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828C6114: 4BFFFD45  bl 0x828c5e58
	ctx.lr = 0x828C6118;
	sub_828C5E58(ctx, base);
	// 828C6118: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C611C: 9B3F0004  stb r25, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[25].u8 ) };
	// 828C6120: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6124: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C6128: 48000038  b 0x828c6160
	pc = 0x828C6160; continue 'dispatch;
	// 828C612C: 482A8AD5  bl 0x82b6ec00
	ctx.lr = 0x828C6130;
	sub_82B6EC00(ctx, base);
	// 828C6130: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C6134: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C6138: 387D0010  addi r3, r29, 0x10
	ctx.r[3].s64 = ctx.r[29].s64 + 16;
	// 828C613C: 4852D0FD  bl 0x82df3238
	ctx.lr = 0x828C6140;
	sub_82DF3238(ctx, base);
	// 828C6140: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C6144: 41820010  beq 0x828c6154
	if ctx.cr[0].eq {
	pc = 0x828C6154; continue 'dispatch;
	}
	// 828C6148: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828C614C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6150: 4BFFFFB8  b 0x828c6108
	pc = 0x828C6108; continue 'dispatch;
	// 828C6154: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C6158: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C615C: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 828C6160: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C6164: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828C6168: 488E2044  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6170 size=128
    let mut pc: u32 = 0x828C6170;
    'dispatch: loop {
        match pc {
            0x828C6170 => {
    //   block [0x828C6170..0x828C61F0)
	// 828C6170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6174: 488E1FF9  bl 0x831a816c
	ctx.lr = 0x828C6178;
	sub_831A8130(ctx, base);
	// 828C6178: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C617C: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828C6180: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828C6184: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C6188: 3BEB0CB8  addi r31, r11, 0xcb8
	ctx.r[31].s64 = ctx.r[11].s64 + 3256;
	// 828C618C: 816A0CC0  lwz r11, 0xcc0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3264 as u32) ) } as u64;
	// 828C6190: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C6194: 40820024  bne 0x828c61b8
	if !ctx.cr[0].eq {
	pc = 0x828C61B8; continue 'dispatch;
	}
	// 828C6198: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 828C619C: 3D00828C  lis r8, -0x7d74
	ctx.r[8].s64 = -2104754176;
	// 828C61A0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828C61A4: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 828C61A8: 39085420  addi r8, r8, 0x5420
	ctx.r[8].s64 = ctx.r[8].s64 + 21536;
	// 828C61AC: 916A0CC0  stw r11, 0xcc0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(3264 as u32), ctx.r[11].u32 ) };
	// 828C61B0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C61B4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828C61B8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828C61BC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C61C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C61C4: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828C61C8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828C61CC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C61D0: 4BD8E3F1  bl 0x826545c0
	ctx.lr = 0x828C61D4;
	sub_826545C0(ctx, base);
	// 828C61D4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C61D8: 4182000C  beq 0x828c61e4
	if ctx.cr[0].eq {
	pc = 0x828C61E4; continue 'dispatch;
	}
	// 828C61DC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C61E0: 48000008  b 0x828c61e8
	pc = 0x828C61E8; continue 'dispatch;
	// 828C61E4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C61E8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C61EC: 488E1FD0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C61F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C61F0 size=160
    let mut pc: u32 = 0x828C61F0;
    'dispatch: loop {
        match pc {
            0x828C61F0 => {
    //   block [0x828C61F0..0x828C6290)
	// 828C61F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C61F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C61F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C61FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C6200: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6204: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C6208: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C620C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828C6210: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 828C6214: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 828C6218: 48065A19  bl 0x8292bc30
	ctx.lr = 0x828C621C;
	sub_8292BC30(ctx, base);
	// 828C621C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828C6220: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C6224: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828C6228: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C622C: 4803B835  bl 0x82901a60
	ctx.lr = 0x828C6230;
	sub_82901A60(ctx, base);
	// 828C6230: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828C6234: 4BA02A85  bl 0x822c8cb8
	ctx.lr = 0x828C6238;
	sub_822C8CB8(ctx, base);
	// 828C6238: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828C623C: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828C6240: 4852D7C9  bl 0x82df3a08
	ctx.lr = 0x828C6244;
	sub_82DF3A08(ctx, base);
	// 828C6244: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828C6248: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 828C624C: 4803B815  bl 0x82901a60
	ctx.lr = 0x828C6250;
	sub_82901A60(ctx, base);
	// 828C6250: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 828C6254: 389E0060  addi r4, r30, 0x60
	ctx.r[4].s64 = ctx.r[30].s64 + 96;
	// 828C6258: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C625C: 4BFFFE25  bl 0x828c6080
	ctx.lr = 0x828C6260;
	sub_828C6080(ctx, base);
	// 828C6260: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 828C6264: 4BA02A55  bl 0x822c8cb8
	ctx.lr = 0x828C6268;
	sub_822C8CB8(ctx, base);
	// 828C6268: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828C626C: 4852D1BD  bl 0x82df3428
	ctx.lr = 0x828C6270;
	sub_82DF3428(ctx, base);
	// 828C6270: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828C6274: 4BA02A45  bl 0x822c8cb8
	ctx.lr = 0x828C6278;
	sub_822C8CB8(ctx, base);
	// 828C6278: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 828C627C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C6280: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C6284: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C6288: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C628C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6290 size=212
    let mut pc: u32 = 0x828C6290;
    'dispatch: loop {
        match pc {
            0x828C6290 => {
    //   block [0x828C6290..0x828C6364)
	// 828C6290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6294: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C6298: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C629C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C62A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C62A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828C62A8: F8810090  std r4, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[4].u64 ) };
	// 828C62AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C62B0: F8A10098  std r5, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[5].u64 ) };
	// 828C62B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C62B8: 388B5D9C  addi r4, r11, 0x5d9c
	ctx.r[4].s64 = ctx.r[11].s64 + 23964;
	// 828C62BC: 38A0002B  li r5, 0x2b
	ctx.r[5].s64 = 43;
	// 828C62C0: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 828C62C4: 4B9FA115  bl 0x822c03d8
	ctx.lr = 0x828C62C8;
	sub_822C03D8(ctx, base);
	// 828C62C8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C62CC: 41820040  beq 0x828c630c
	if ctx.cr[0].eq {
	pc = 0x828C630C; continue 'dispatch;
	}
	// 828C62D0: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 828C62D4: 39230008  addi r9, r3, 8
	ctx.r[9].s64 = ctx.r[3].s64 + 8;
	// 828C62D8: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828C62DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C62E0: 394AD79C  addi r10, r10, -0x2864
	ctx.r[10].s64 = ctx.r[10].s64 + -10340;
	// 828C62E4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C62E8: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C62EC: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C62F0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C62F4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C62F8: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828C62FC: 9103000C  stw r8, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 828C6300: 90E30010  stw r7, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 828C6304: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 828C6308: 48000008  b 0x828c6310
	pc = 0x828C6310; continue 'dispatch;
	// 828C630C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C6310: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828C6314: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C6318: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C631C: 4BFFEBDD  bl 0x828c4ef8
	ctx.lr = 0x828C6320;
	sub_828C4EF8(ctx, base);
	// 828C6320: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C6324: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C6328: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C632C: 4B9F9CD5  bl 0x822c0000
	ctx.lr = 0x828C6330;
	sub_822C0000(ctx, base);
	// 828C6330: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C6334: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C6338: 482ECDD1  bl 0x82bb3108
	ctx.lr = 0x828C633C;
	sub_82BB3108(ctx, base);
	// 828C633C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C6340: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C6344: 419A0008  beq cr6, 0x828c634c
	if ctx.cr[6].eq {
	pc = 0x828C634C; continue 'dispatch;
	}
	// 828C6348: 4B9FA549  bl 0x822c0890
	ctx.lr = 0x828C634C;
	sub_822C0890(ctx, base);
	// 828C634C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C6350: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C6354: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C6358: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C635C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C6360: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C6368 size=400
    let mut pc: u32 = 0x828C6368;
    'dispatch: loop {
        match pc {
            0x828C6368 => {
    //   block [0x828C6368..0x828C64F8)
	// 828C6368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C636C: 488E1DFD  bl 0x831a8168
	ctx.lr = 0x828C6370;
	sub_831A8130(ctx, base);
	// 828C6370: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6374: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C6378: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C637C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C6380: 3D20832C  lis r9, -0x7cd4
	ctx.r[9].s64 = -2094268416;
	// 828C6384: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C6388: C1AB08A8  lfs f13, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C638C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C6390: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C6394: 3BA93AD0  addi r29, r9, 0x3ad0
	ctx.r[29].s64 = ctx.r[9].s64 + 15056;
	// 828C6398: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828C639C: 3B810070  addi r28, r1, 0x70
	ctx.r[28].s64 = ctx.r[1].s64 + 112;
	// 828C63A0: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828C63A4: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828C63A8: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 828C63AC: 4BF29405  bl 0x827ef7b0
	ctx.lr = 0x828C63B0;
	sub_827EF7B0(ctx, base);
	// 828C63B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C63B4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828C63B8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828C63BC: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828C63C0: 485B6CA1  bl 0x82e7d060
	ctx.lr = 0x828C63C4;
	sub_82E7D060(ctx, base);
	// 828C63C4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C63C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C63CC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C63D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C63D4: 4E800421  bctrl
	ctx.lr = 0x828C63D8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C64F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C64F8 size=96
    let mut pc: u32 = 0x828C64F8;
    'dispatch: loop {
        match pc {
            0x828C64F8 => {
    //   block [0x828C64F8..0x828C6558)
	// 828C64F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C64FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C6500: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C6504: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6508: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C650C: 4BFFD85D  bl 0x828c3d68
	ctx.lr = 0x828C6510;
	sub_828C3D68(ctx, base);
	// 828C6510: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C6514: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828C6518: 396BD830  addi r11, r11, -0x27d0
	ctx.r[11].s64 = ctx.r[11].s64 + -10192;
	// 828C651C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6520: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C6524: 808A0B30  lwz r4, 0xb30(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2864 as u32) ) } as u64;
	// 828C6528: 4852D4E1  bl 0x82df3a08
	ctx.lr = 0x828C652C;
	sub_82DF3A08(ctx, base);
	// 828C652C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C6530: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C6534: 485931B5  bl 0x82e596e8
	ctx.lr = 0x828C6538;
	sub_82E596E8(ctx, base);
	// 828C6538: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C653C: 4852CEED  bl 0x82df3428
	ctx.lr = 0x828C6540;
	sub_82DF3428(ctx, base);
	// 828C6540: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C6544: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C6548: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C654C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C6550: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C6554: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C6558 size=108
    let mut pc: u32 = 0x828C6558;
    'dispatch: loop {
        match pc {
            0x828C6558 => {
    //   block [0x828C6558..0x828C65C4)
	// 828C6558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C655C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C6560: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C6564: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6568: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C656C: 4BFFD7FD  bl 0x828c3d68
	ctx.lr = 0x828C6570;
	sub_828C3D68(ctx, base);
	// 828C6570: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C6574: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828C6578: 3D20832C  lis r9, -0x7cd4
	ctx.r[9].s64 = -2094268416;
	// 828C657C: 394AD86C  addi r10, r10, -0x2794
	ctx.r[10].s64 = ctx.r[10].s64 + -10132;
	// 828C6580: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6584: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C6588: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C658C: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828C6590: 808939EC  lwz r4, 0x39ec(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(14828 as u32) ) } as u64;
	// 828C6594: 4852D475  bl 0x82df3a08
	ctx.lr = 0x828C6598;
	sub_82DF3A08(ctx, base);
	// 828C6598: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C659C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C65A0: 48593149  bl 0x82e596e8
	ctx.lr = 0x828C65A4;
	sub_82E596E8(ctx, base);
	// 828C65A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C65A8: 4852CE81  bl 0x82df3428
	ctx.lr = 0x828C65AC;
	sub_82DF3428(ctx, base);
	// 828C65AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C65B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C65B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C65B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C65BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C65C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C65C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C65C8 size=96
    let mut pc: u32 = 0x828C65C8;
    'dispatch: loop {
        match pc {
            0x828C65C8 => {
    //   block [0x828C65C8..0x828C6628)
	// 828C65C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C65CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C65D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C65D4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C65D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C65DC: 4BFFD78D  bl 0x828c3d68
	ctx.lr = 0x828C65E0;
	sub_828C3D68(ctx, base);
	// 828C65E0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C65E4: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828C65E8: 396BD8A4  addi r11, r11, -0x275c
	ctx.r[11].s64 = ctx.r[11].s64 + -10076;
	// 828C65EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C65F0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C65F4: 808A39F0  lwz r4, 0x39f0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14832 as u32) ) } as u64;
	// 828C65F8: 4852D411  bl 0x82df3a08
	ctx.lr = 0x828C65FC;
	sub_82DF3A08(ctx, base);
	// 828C65FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C6600: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C6604: 485930E5  bl 0x82e596e8
	ctx.lr = 0x828C6608;
	sub_82E596E8(ctx, base);
	// 828C6608: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C660C: 4852CE1D  bl 0x82df3428
	ctx.lr = 0x828C6610;
	sub_82DF3428(ctx, base);
	// 828C6610: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C6614: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C6618: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C661C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C6620: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C6624: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6628 size=96
    let mut pc: u32 = 0x828C6628;
    'dispatch: loop {
        match pc {
            0x828C6628 => {
    //   block [0x828C6628..0x828C6688)
	// 828C6628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C662C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C6630: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C6634: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6638: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C663C: 4BFFD72D  bl 0x828c3d68
	ctx.lr = 0x828C6640;
	sub_828C3D68(ctx, base);
	// 828C6640: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C6644: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828C6648: 396BD8DC  addi r11, r11, -0x2724
	ctx.r[11].s64 = ctx.r[11].s64 + -10020;
	// 828C664C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6650: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C6654: 808A0B34  lwz r4, 0xb34(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2868 as u32) ) } as u64;
	// 828C6658: 4852D3B1  bl 0x82df3a08
	ctx.lr = 0x828C665C;
	sub_82DF3A08(ctx, base);
	// 828C665C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C6660: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C6664: 48593085  bl 0x82e596e8
	ctx.lr = 0x828C6668;
	sub_82E596E8(ctx, base);
	// 828C6668: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C666C: 4852CDBD  bl 0x82df3428
	ctx.lr = 0x828C6670;
	sub_82DF3428(ctx, base);
	// 828C6670: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C6674: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C6678: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C667C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C6680: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C6684: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6688 size=96
    let mut pc: u32 = 0x828C6688;
    'dispatch: loop {
        match pc {
            0x828C6688 => {
    //   block [0x828C6688..0x828C66E8)
	// 828C6688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C668C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C6690: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C6694: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6698: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C669C: 4BFFD6CD  bl 0x828c3d68
	ctx.lr = 0x828C66A0;
	sub_828C3D68(ctx, base);
	// 828C66A0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C66A4: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828C66A8: 396BD914  addi r11, r11, -0x26ec
	ctx.r[11].s64 = ctx.r[11].s64 + -9964;
	// 828C66AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C66B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C66B4: 808A39F4  lwz r4, 0x39f4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14836 as u32) ) } as u64;
	// 828C66B8: 4852D351  bl 0x82df3a08
	ctx.lr = 0x828C66BC;
	sub_82DF3A08(ctx, base);
	// 828C66BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C66C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C66C4: 48593025  bl 0x82e596e8
	ctx.lr = 0x828C66C8;
	sub_82E596E8(ctx, base);
	// 828C66C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C66CC: 4852CD5D  bl 0x82df3428
	ctx.lr = 0x828C66D0;
	sub_82DF3428(ctx, base);
	// 828C66D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C66D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C66D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C66DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C66E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C66E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C66E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C66E8 size=268
    let mut pc: u32 = 0x828C66E8;
    'dispatch: loop {
        match pc {
            0x828C66E8 => {
    //   block [0x828C66E8..0x828C67F4)
	// 828C66E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C66EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C66F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C66F4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C66F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C66FC: 4BFFD66D  bl 0x828c3d68
	ctx.lr = 0x828C6700;
	sub_828C3D68(ctx, base);
	// 828C6700: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C6704: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828C6708: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 828C670C: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828C6710: 394BD954  addi r10, r11, -0x26ac
	ctx.r[10].s64 = ctx.r[11].s64 + -9900;
	// 828C6714: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C6718: 3909BA80  addi r8, r9, -0x4580
	ctx.r[8].s64 = ctx.r[9].s64 + -17792;
	// 828C671C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828C6720: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 828C6724: 3D40828C  lis r10, -0x7d74
	ctx.r[10].s64 = -2104754176;
	// 828C6728: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 828C672C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C6730: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 828C6734: 38EA5150  addi r7, r10, 0x5150
	ctx.r[7].s64 = ctx.r[10].s64 + 20816;
	// 828C6738: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828C673C: 395F006C  addi r10, r31, 0x6c
	ctx.r[10].s64 = ctx.r[31].s64 + 108;
	// 828C6740: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 828C6744: 917F0088  stw r11, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 828C6748: C009BA80  lfs f0, -0x4580(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17792 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C674C: D01F0090  stfs f0, 0x90(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828C6750: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C6754: C0080004  lfs f0, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C6758: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 828C675C: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828C6760: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C6764: C0080008  lfs f0, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C6768: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828C676C: D01F0098  stfs f0, 0x98(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 828C6770: C008000C  lfs f0, 0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C6774: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 828C6778: 917F00A0  stw r11, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 828C677C: 4BFFF9F5  bl 0x828c6170
	ctx.lr = 0x828C6780;
	sub_828C6170(ctx, base);
	// 828C6780: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828C6784: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C6788: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C678C: C04B7BC8  lfs f2, 0x7bc8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31688 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828C6790: C02A08A8  lfs f1, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C6794: 4BF2F78D  bl 0x827f5f20
	ctx.lr = 0x828C6798;
	sub_827F5F20(ctx, base);
	// 828C6798: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C679C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828C67A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C67A4: 388BD948  addi r4, r11, -0x26b8
	ctx.r[4].s64 = ctx.r[11].s64 + -9912;
	// 828C67A8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828C67AC: 4BFFFA45  bl 0x828c61f0
	ctx.lr = 0x828C67B0;
	sub_828C61F0(ctx, base);
	// 828C67B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C67B4: 4BA02505  bl 0x822c8cb8
	ctx.lr = 0x828C67B8;
	sub_822C8CB8(ctx, base);
	// 828C67B8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828C67BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C67C0: 808B0B50  lwz r4, 0xb50(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2896 as u32) ) } as u64;
	// 828C67C4: 4852D245  bl 0x82df3a08
	ctx.lr = 0x828C67C8;
	sub_82DF3A08(ctx, base);
	// 828C67C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C67CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C67D0: 48592F19  bl 0x82e596e8
	ctx.lr = 0x828C67D4;
	sub_82E596E8(ctx, base);
	// 828C67D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C67D8: 4852CC51  bl 0x82df3428
	ctx.lr = 0x828C67DC;
	sub_82DF3428(ctx, base);
	// 828C67DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C67E0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C67E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C67E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C67EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C67F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C67F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C67F8 size=84
    let mut pc: u32 = 0x828C67F8;
    'dispatch: loop {
        match pc {
            0x828C67F8 => {
    //   block [0x828C67F8..0x828C684C)
	// 828C67F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C67FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C6800: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C6804: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C6808: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C680C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C6810: 3BDF006C  addi r30, r31, 0x6c
	ctx.r[30].s64 = ctx.r[31].s64 + 108;
	// 828C6814: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 828C6818: 4BBEAA89  bl 0x824b12a0
	ctx.lr = 0x828C681C;
	sub_824B12A0(ctx, base);
	// 828C681C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C6820: 4BBEAA81  bl 0x824b12a0
	ctx.lr = 0x828C6824;
	sub_824B12A0(ctx, base);
	// 828C6824: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 828C6828: 4803D5A9  bl 0x82903dd0
	ctx.lr = 0x828C682C;
	sub_82903DD0(ctx, base);
	// 828C682C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C6830: 48595D59  bl 0x82e5c588
	ctx.lr = 0x828C6834;
	sub_82E5C588(ctx, base);
	// 828C6834: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C6838: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C683C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C6840: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C6844: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C6848: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6850 size=140
    let mut pc: u32 = 0x828C6850;
    'dispatch: loop {
        match pc {
            0x828C6850 => {
    //   block [0x828C6850..0x828C68DC)
	// 828C6850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6854: 488E1919  bl 0x831a816c
	ctx.lr = 0x828C6858;
	sub_831A8130(ctx, base);
	// 828C6858: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C685C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C6860: 4BFFD509  bl 0x828c3d68
	ctx.lr = 0x828C6864;
	sub_828C3D68(ctx, base);
	// 828C6864: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C6868: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828C686C: 396BD98C  addi r11, r11, -0x2674
	ctx.r[11].s64 = ctx.r[11].s64 + -9844;
	// 828C6870: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828C6874: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C6878: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C687C: 93DF006C  stw r30, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 828C6880: 388AD7B0  addi r4, r10, -0x2850
	ctx.r[4].s64 = ctx.r[10].s64 + -10320;
	// 828C6884: 93DF0070  stw r30, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828C6888: 38A0023F  li r5, 0x23f
	ctx.r[5].s64 = 575;
	// 828C688C: 93DF0074  stw r30, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 828C6890: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 828C6894: 93DF0078  stw r30, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 828C6898: 3BBF0074  addi r29, r31, 0x74
	ctx.r[29].s64 = ctx.r[31].s64 + 116;
	// 828C689C: 4852BB4D  bl 0x82df23e8
	ctx.lr = 0x828C68A0;
	sub_82DF23E8(ctx, base);
	// 828C68A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C68A4: 41820020  beq 0x828c68c4
	if ctx.cr[0].eq {
	pc = 0x828C68C4; continue 'dispatch;
	}
	// 828C68A8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828C68AC: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 828C68B0: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 828C68B4: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 828C68B8: 4BCC4469  bl 0x8258ad20
	ctx.lr = 0x828C68BC;
	sub_8258AD20(ctx, base);
	// 828C68BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C68C0: 48000008  b 0x828c68c8
	pc = 0x828C68C8; continue 'dispatch;
	// 828C68C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C68C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C68CC: 4BB0CF5D  bl 0x823d3828
	ctx.lr = 0x828C68D0;
	sub_823D3828(ctx, base);
	// 828C68D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C68D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C68D8: 488E18E4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C68E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C68E0 size=88
    let mut pc: u32 = 0x828C68E0;
    'dispatch: loop {
        match pc {
            0x828C68E0 => {
    //   block [0x828C68E0..0x828C6938)
	// 828C68E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C68E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C68E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C68EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C68F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C68F4: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 828C68F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C68FC: 419A0008  beq cr6, 0x828c6904
	if ctx.cr[6].eq {
	pc = 0x828C6904; continue 'dispatch;
	}
	// 828C6900: 4B9F9F91  bl 0x822c0890
	ctx.lr = 0x828C6904;
	sub_822C0890(ctx, base);
	// 828C6904: 807F0070  lwz r3, 0x70(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 828C6908: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C690C: 419A0008  beq cr6, 0x828c6914
	if ctx.cr[6].eq {
	pc = 0x828C6914; continue 'dispatch;
	}
	// 828C6910: 4B9F9F81  bl 0x822c0890
	ctx.lr = 0x828C6914;
	sub_822C0890(ctx, base);
	// 828C6914: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 828C6918: 4803D4B9  bl 0x82903dd0
	ctx.lr = 0x828C691C;
	sub_82903DD0(ctx, base);
	// 828C691C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C6920: 48595C69  bl 0x82e5c588
	ctx.lr = 0x828C6924;
	sub_82E5C588(ctx, base);
	// 828C6924: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C6928: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C692C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C6930: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C6934: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6938 size=96
    let mut pc: u32 = 0x828C6938;
    'dispatch: loop {
        match pc {
            0x828C6938 => {
    //   block [0x828C6938..0x828C6998)
	// 828C6938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C693C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C6940: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C6944: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6948: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C694C: 4BFFD41D  bl 0x828c3d68
	ctx.lr = 0x828C6950;
	sub_828C3D68(ctx, base);
	// 828C6950: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C6954: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828C6958: 396BD9C4  addi r11, r11, -0x263c
	ctx.r[11].s64 = ctx.r[11].s64 + -9788;
	// 828C695C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6960: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C6964: 808A0B08  lwz r4, 0xb08(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2824 as u32) ) } as u64;
	// 828C6968: 4852D0A1  bl 0x82df3a08
	ctx.lr = 0x828C696C;
	sub_82DF3A08(ctx, base);
	// 828C696C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C6970: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C6974: 48592D75  bl 0x82e596e8
	ctx.lr = 0x828C6978;
	sub_82E596E8(ctx, base);
	// 828C6978: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C697C: 4852CAAD  bl 0x82df3428
	ctx.lr = 0x828C6980;
	sub_82DF3428(ctx, base);
	// 828C6980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C6984: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C6988: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C698C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C6990: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C6994: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6998 size=112
    let mut pc: u32 = 0x828C6998;
    'dispatch: loop {
        match pc {
            0x828C6998 => {
    //   block [0x828C6998..0x828C6A08)
	// 828C6998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C699C: 488E17D1  bl 0x831a816c
	ctx.lr = 0x828C69A0;
	sub_831A8130(ctx, base);
	// 828C69A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C69A4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C69A8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C69AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C69B0: 388BD7B0  addi r4, r11, -0x2850
	ctx.r[4].s64 = ctx.r[11].s64 + -10320;
	// 828C69B4: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 828C69B8: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 828C69BC: 4852BA2D  bl 0x82df23e8
	ctx.lr = 0x828C69C0;
	sub_82DF23E8(ctx, base);
	// 828C69C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C69C4: 41820010  beq 0x828c69d4
	if ctx.cr[0].eq {
	pc = 0x828C69D4; continue 'dispatch;
	}
	// 828C69C8: 4BFFFB31  bl 0x828c64f8
	ctx.lr = 0x828C69CC;
	sub_828C64F8(ctx, base);
	// 828C69CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C69D0: 48000008  b 0x828c69d8
	pc = 0x828C69D8; continue 'dispatch;
	// 828C69D4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C69D8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C69DC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828C69E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C69E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C69E8: 4BFFDF99  bl 0x828c4980
	ctx.lr = 0x828C69EC;
	sub_828C4980(ctx, base);
	// 828C69EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C69F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C69F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C69F8: 4B9F9609  bl 0x822c0000
	ctx.lr = 0x828C69FC;
	sub_822C0000(ctx, base);
	// 828C69FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C6A00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C6A04: 488E17B8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6A08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6A08 size=112
    let mut pc: u32 = 0x828C6A08;
    'dispatch: loop {
        match pc {
            0x828C6A08 => {
    //   block [0x828C6A08..0x828C6A78)
	// 828C6A08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6A0C: 488E1761  bl 0x831a816c
	ctx.lr = 0x828C6A10;
	sub_831A8130(ctx, base);
	// 828C6A10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6A14: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C6A18: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C6A1C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C6A20: 388BD7B0  addi r4, r11, -0x2850
	ctx.r[4].s64 = ctx.r[11].s64 + -10320;
	// 828C6A24: 38A000F7  li r5, 0xf7
	ctx.r[5].s64 = 247;
	// 828C6A28: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 828C6A2C: 4852B9BD  bl 0x82df23e8
	ctx.lr = 0x828C6A30;
	sub_82DF23E8(ctx, base);
	// 828C6A30: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C6A34: 41820010  beq 0x828c6a44
	if ctx.cr[0].eq {
	pc = 0x828C6A44; continue 'dispatch;
	}
	// 828C6A38: 4BFFFB21  bl 0x828c6558
	ctx.lr = 0x828C6A3C;
	sub_828C6558(ctx, base);
	// 828C6A3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C6A40: 48000008  b 0x828c6a48
	pc = 0x828C6A48; continue 'dispatch;
	// 828C6A44: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C6A48: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C6A4C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828C6A50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C6A54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C6A58: 4BFFDFF1  bl 0x828c4a48
	ctx.lr = 0x828C6A5C;
	sub_828C4A48(ctx, base);
	// 828C6A5C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C6A60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C6A64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C6A68: 4B9F9599  bl 0x822c0000
	ctx.lr = 0x828C6A6C;
	sub_822C0000(ctx, base);
	// 828C6A6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C6A70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C6A74: 488E1748  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6A78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6A78 size=112
    let mut pc: u32 = 0x828C6A78;
    'dispatch: loop {
        match pc {
            0x828C6A78 => {
    //   block [0x828C6A78..0x828C6AE8)
	// 828C6A78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6A7C: 488E16F1  bl 0x831a816c
	ctx.lr = 0x828C6A80;
	sub_831A8130(ctx, base);
	// 828C6A80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6A84: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C6A88: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C6A8C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C6A90: 388BD7B0  addi r4, r11, -0x2850
	ctx.r[4].s64 = ctx.r[11].s64 + -10320;
	// 828C6A94: 38A0011E  li r5, 0x11e
	ctx.r[5].s64 = 286;
	// 828C6A98: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 828C6A9C: 4852B94D  bl 0x82df23e8
	ctx.lr = 0x828C6AA0;
	sub_82DF23E8(ctx, base);
	// 828C6AA0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C6AA4: 41820010  beq 0x828c6ab4
	if ctx.cr[0].eq {
	pc = 0x828C6AB4; continue 'dispatch;
	}
	// 828C6AA8: 4BFFFB21  bl 0x828c65c8
	ctx.lr = 0x828C6AAC;
	sub_828C65C8(ctx, base);
	// 828C6AAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C6AB0: 48000008  b 0x828c6ab8
	pc = 0x828C6AB8; continue 'dispatch;
	// 828C6AB4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C6AB8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C6ABC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828C6AC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C6AC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C6AC8: 4BFFE049  bl 0x828c4b10
	ctx.lr = 0x828C6ACC;
	sub_828C4B10(ctx, base);
	// 828C6ACC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C6AD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C6AD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C6AD8: 4B9F9529  bl 0x822c0000
	ctx.lr = 0x828C6ADC;
	sub_822C0000(ctx, base);
	// 828C6ADC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C6AE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C6AE4: 488E16D8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6AE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6AE8 size=112
    let mut pc: u32 = 0x828C6AE8;
    'dispatch: loop {
        match pc {
            0x828C6AE8 => {
    //   block [0x828C6AE8..0x828C6B58)
	// 828C6AE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6AEC: 488E1681  bl 0x831a816c
	ctx.lr = 0x828C6AF0;
	sub_831A8130(ctx, base);
	// 828C6AF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6AF4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C6AF8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C6AFC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C6B00: 388BD7B0  addi r4, r11, -0x2850
	ctx.r[4].s64 = ctx.r[11].s64 + -10320;
	// 828C6B04: 38A0013C  li r5, 0x13c
	ctx.r[5].s64 = 316;
	// 828C6B08: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 828C6B0C: 4852B8DD  bl 0x82df23e8
	ctx.lr = 0x828C6B10;
	sub_82DF23E8(ctx, base);
	// 828C6B10: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C6B14: 41820010  beq 0x828c6b24
	if ctx.cr[0].eq {
	pc = 0x828C6B24; continue 'dispatch;
	}
	// 828C6B18: 4BFFFB11  bl 0x828c6628
	ctx.lr = 0x828C6B1C;
	sub_828C6628(ctx, base);
	// 828C6B1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C6B20: 48000008  b 0x828c6b28
	pc = 0x828C6B28; continue 'dispatch;
	// 828C6B24: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C6B28: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C6B2C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828C6B30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C6B34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C6B38: 4BFFE0A1  bl 0x828c4bd8
	ctx.lr = 0x828C6B3C;
	sub_828C4BD8(ctx, base);
	// 828C6B3C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C6B40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C6B44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C6B48: 4B9F94B9  bl 0x822c0000
	ctx.lr = 0x828C6B4C;
	sub_822C0000(ctx, base);
	// 828C6B4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C6B50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C6B54: 488E1668  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6B58 size=112
    let mut pc: u32 = 0x828C6B58;
    'dispatch: loop {
        match pc {
            0x828C6B58 => {
    //   block [0x828C6B58..0x828C6BC8)
	// 828C6B58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6B5C: 488E1611  bl 0x831a816c
	ctx.lr = 0x828C6B60;
	sub_831A8130(ctx, base);
	// 828C6B60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6B64: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C6B68: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C6B6C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C6B70: 388BD7B0  addi r4, r11, -0x2850
	ctx.r[4].s64 = ctx.r[11].s64 + -10320;
	// 828C6B74: 38A00170  li r5, 0x170
	ctx.r[5].s64 = 368;
	// 828C6B78: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 828C6B7C: 4852B86D  bl 0x82df23e8
	ctx.lr = 0x828C6B80;
	sub_82DF23E8(ctx, base);
	// 828C6B80: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C6B84: 41820010  beq 0x828c6b94
	if ctx.cr[0].eq {
	pc = 0x828C6B94; continue 'dispatch;
	}
	// 828C6B88: 4BFFFB01  bl 0x828c6688
	ctx.lr = 0x828C6B8C;
	sub_828C6688(ctx, base);
	// 828C6B8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C6B90: 48000008  b 0x828c6b98
	pc = 0x828C6B98; continue 'dispatch;
	// 828C6B94: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C6B98: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C6B9C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828C6BA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C6BA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C6BA8: 4BFFE0F9  bl 0x828c4ca0
	ctx.lr = 0x828C6BAC;
	sub_828C4CA0(ctx, base);
	// 828C6BAC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C6BB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C6BB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C6BB8: 4B9F9449  bl 0x822c0000
	ctx.lr = 0x828C6BBC;
	sub_822C0000(ctx, base);
	// 828C6BBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C6BC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C6BC4: 488E15F8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6BC8 size=112
    let mut pc: u32 = 0x828C6BC8;
    'dispatch: loop {
        match pc {
            0x828C6BC8 => {
    //   block [0x828C6BC8..0x828C6C38)
	// 828C6BC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6BCC: 488E15A1  bl 0x831a816c
	ctx.lr = 0x828C6BD0;
	sub_831A8130(ctx, base);
	// 828C6BD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6BD4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C6BD8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C6BDC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C6BE0: 388BD7B0  addi r4, r11, -0x2850
	ctx.r[4].s64 = ctx.r[11].s64 + -10320;
	// 828C6BE4: 38A00199  li r5, 0x199
	ctx.r[5].s64 = 409;
	// 828C6BE8: 386000B0  li r3, 0xb0
	ctx.r[3].s64 = 176;
	// 828C6BEC: 4852B7FD  bl 0x82df23e8
	ctx.lr = 0x828C6BF0;
	sub_82DF23E8(ctx, base);
	// 828C6BF0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C6BF4: 41820010  beq 0x828c6c04
	if ctx.cr[0].eq {
	pc = 0x828C6C04; continue 'dispatch;
	}
	// 828C6BF8: 4BFFFAF1  bl 0x828c66e8
	ctx.lr = 0x828C6BFC;
	sub_828C66E8(ctx, base);
	// 828C6BFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C6C00: 48000008  b 0x828c6c08
	pc = 0x828C6C08; continue 'dispatch;
	// 828C6C04: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C6C08: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C6C0C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828C6C10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C6C14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C6C18: 4BFFE151  bl 0x828c4d68
	ctx.lr = 0x828C6C1C;
	sub_828C4D68(ctx, base);
	// 828C6C1C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C6C20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C6C24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C6C28: 4B9F93D9  bl 0x822c0000
	ctx.lr = 0x828C6C2C;
	sub_822C0000(ctx, base);
	// 828C6C2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C6C30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C6C34: 488E1588  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6C38 size=76
    let mut pc: u32 = 0x828C6C38;
    'dispatch: loop {
        match pc {
            0x828C6C38 => {
    //   block [0x828C6C38..0x828C6C84)
	// 828C6C38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6C3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C6C40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C6C44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C6C48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6C4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C6C50: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C6C54: 4BFFFBA5  bl 0x828c67f8
	ctx.lr = 0x828C6C58;
	sub_828C67F8(ctx, base);
	// 828C6C58: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C6C5C: 4182000C  beq 0x828c6c68
	if ctx.cr[0].eq {
	pc = 0x828C6C68; continue 'dispatch;
	}
	// 828C6C60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C6C64: 4852B775  bl 0x82df23d8
	ctx.lr = 0x828C6C68;
	sub_82DF23D8(ctx, base);
	// 828C6C68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C6C6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C6C70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C6C74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C6C78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C6C7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C6C80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6C88 size=112
    let mut pc: u32 = 0x828C6C88;
    'dispatch: loop {
        match pc {
            0x828C6C88 => {
    //   block [0x828C6C88..0x828C6CF8)
	// 828C6C88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6C8C: 488E14E1  bl 0x831a816c
	ctx.lr = 0x828C6C90;
	sub_831A8130(ctx, base);
	// 828C6C90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6C94: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C6C98: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C6C9C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C6CA0: 388BD7B0  addi r4, r11, -0x2850
	ctx.r[4].s64 = ctx.r[11].s64 + -10320;
	// 828C6CA4: 38A00237  li r5, 0x237
	ctx.r[5].s64 = 567;
	// 828C6CA8: 3860007C  li r3, 0x7c
	ctx.r[3].s64 = 124;
	// 828C6CAC: 4852B73D  bl 0x82df23e8
	ctx.lr = 0x828C6CB0;
	sub_82DF23E8(ctx, base);
	// 828C6CB0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C6CB4: 41820010  beq 0x828c6cc4
	if ctx.cr[0].eq {
	pc = 0x828C6CC4; continue 'dispatch;
	}
	// 828C6CB8: 4BFFFB99  bl 0x828c6850
	ctx.lr = 0x828C6CBC;
	sub_828C6850(ctx, base);
	// 828C6CBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C6CC0: 48000008  b 0x828c6cc8
	pc = 0x828C6CC8; continue 'dispatch;
	// 828C6CC4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C6CC8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C6CCC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828C6CD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C6CD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C6CD8: 4BFFE159  bl 0x828c4e30
	ctx.lr = 0x828C6CDC;
	sub_828C4E30(ctx, base);
	// 828C6CDC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C6CE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C6CE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C6CE8: 4B9F9319  bl 0x822c0000
	ctx.lr = 0x828C6CEC;
	sub_822C0000(ctx, base);
	// 828C6CEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C6CF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C6CF4: 488E14C8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6CF8 size=76
    let mut pc: u32 = 0x828C6CF8;
    'dispatch: loop {
        match pc {
            0x828C6CF8 => {
    //   block [0x828C6CF8..0x828C6D44)
	// 828C6CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6CFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C6D00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C6D04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C6D08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6D0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C6D10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C6D14: 4BFFFBCD  bl 0x828c68e0
	ctx.lr = 0x828C6D18;
	sub_828C68E0(ctx, base);
	// 828C6D18: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C6D1C: 4182000C  beq 0x828c6d28
	if ctx.cr[0].eq {
	pc = 0x828C6D28; continue 'dispatch;
	}
	// 828C6D20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C6D24: 4852B6B5  bl 0x82df23d8
	ctx.lr = 0x828C6D28;
	sub_82DF23D8(ctx, base);
	// 828C6D28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C6D2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C6D30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C6D34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C6D38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C6D3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C6D40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6D48 size=112
    let mut pc: u32 = 0x828C6D48;
    'dispatch: loop {
        match pc {
            0x828C6D48 => {
    //   block [0x828C6D48..0x828C6DB8)
	// 828C6D48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6D4C: 488E1421  bl 0x831a816c
	ctx.lr = 0x828C6D50;
	sub_831A8130(ctx, base);
	// 828C6D50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6D54: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C6D58: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C6D5C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C6D60: 388BD7B0  addi r4, r11, -0x2850
	ctx.r[4].s64 = ctx.r[11].s64 + -10320;
	// 828C6D64: 38A00051  li r5, 0x51
	ctx.r[5].s64 = 81;
	// 828C6D68: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 828C6D6C: 4852B67D  bl 0x82df23e8
	ctx.lr = 0x828C6D70;
	sub_82DF23E8(ctx, base);
	// 828C6D70: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C6D74: 41820010  beq 0x828c6d84
	if ctx.cr[0].eq {
	pc = 0x828C6D84; continue 'dispatch;
	}
	// 828C6D78: 4BFFFBC1  bl 0x828c6938
	ctx.lr = 0x828C6D7C;
	sub_828C6938(ctx, base);
	// 828C6D7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C6D80: 48000008  b 0x828c6d88
	pc = 0x828C6D88; continue 'dispatch;
	// 828C6D84: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C6D88: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C6D8C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828C6D90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C6D94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C6D98: 4BFFDB21  bl 0x828c48b8
	ctx.lr = 0x828C6D9C;
	sub_828C48B8(ctx, base);
	// 828C6D9C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C6DA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C6DA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C6DA8: 4B9F9259  bl 0x822c0000
	ctx.lr = 0x828C6DAC;
	sub_822C0000(ctx, base);
	// 828C6DAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C6DB0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C6DB4: 488E1408  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6DB8 size=84
    let mut pc: u32 = 0x828C6DB8;
    'dispatch: loop {
        match pc {
            0x828C6DB8 => {
    //   block [0x828C6DB8..0x828C6E0C)
	// 828C6DB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6DBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C6DC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C6DC4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6DC8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C6DCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C6DD0: 4BFFB989  bl 0x828c2758
	ctx.lr = 0x828C6DD4;
	sub_828C2758(ctx, base);
	// 828C6DD4: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C6DD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6DDC: 808B39E8  lwz r4, 0x39e8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14824 as u32) ) } as u64;
	// 828C6DE0: 4852CC29  bl 0x82df3a08
	ctx.lr = 0x828C6DE4;
	sub_82DF3A08(ctx, base);
	// 828C6DE4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C6DE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C6DEC: 4BFFBB85  bl 0x828c2970
	ctx.lr = 0x828C6DF0;
	sub_828C2970(ctx, base);
	// 828C6DF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6DF4: 4852C635  bl 0x82df3428
	ctx.lr = 0x828C6DF8;
	sub_82DF3428(ctx, base);
	// 828C6DF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C6DFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C6E00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C6E04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C6E08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6E10 size=136
    let mut pc: u32 = 0x828C6E10;
    'dispatch: loop {
        match pc {
            0x828C6E10 => {
    //   block [0x828C6E10..0x828C6E98)
	// 828C6E10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6E14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C6E18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C6E1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C6E20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6E24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C6E28: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C6E2C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828C6E30: 409A0020  bne cr6, 0x828c6e50
	if !ctx.cr[6].eq {
	pc = 0x828C6E50; continue 'dispatch;
	}
	// 828C6E34: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C6E38: 419A0048  beq cr6, 0x828c6e80
	if ctx.cr[6].eq {
	pc = 0x828C6E80; continue 'dispatch;
	}
	// 828C6E3C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828C6E40: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828C6E44: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828C6E48: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828C6E4C: 48000034  b 0x828c6e80
	pc = 0x828C6E80; continue 'dispatch;
	// 828C6E50: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828C6E54: 419A002C  beq cr6, 0x828c6e80
	if ctx.cr[6].eq {
	pc = 0x828C6E80; continue 'dispatch;
	}
	// 828C6E58: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C6E5C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6E60: 388B43B8  addi r4, r11, 0x43b8
	ctx.r[4].s64 = ctx.r[11].s64 + 17336;
	// 828C6E64: 488E1295  bl 0x831a80f8
	ctx.lr = 0x828C6E68;
	sub_831A80F8(ctx, base);
	// 828C6E68: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C6E6C: 4182000C  beq 0x828c6e78
	if ctx.cr[0].eq {
	pc = 0x828C6E78; continue 'dispatch;
	}
	// 828C6E70: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828C6E74: 4800000C  b 0x828c6e80
	pc = 0x828C6E80; continue 'dispatch;
	// 828C6E78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C6E7C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C6E80: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C6E84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C6E88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C6E8C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C6E90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C6E94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6E98 size=196
    let mut pc: u32 = 0x828C6E98;
    'dispatch: loop {
        match pc {
            0x828C6E98 => {
    //   block [0x828C6E98..0x828C6F5C)
	// 828C6E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6E9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C6EA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C6EA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C6EA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6EAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C6EB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C6EB4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C6EB8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C6EBC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C6EC0: 4B9F9A79  bl 0x822c0938
	ctx.lr = 0x828C6EC4;
	sub_822C0938(ctx, base);
	// 828C6EC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C6EC8: 41820028  beq 0x828c6ef0
	if ctx.cr[0].eq {
	pc = 0x828C6EF0; continue 'dispatch;
	}
	// 828C6ECC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C6ED0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828C6ED4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C6ED8: 392BD9FC  addi r9, r11, -0x2604
	ctx.r[9].s64 = ctx.r[11].s64 + -9732;
	// 828C6EDC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C6EE0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C6EE4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C6EE8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C6EEC: 48000008  b 0x828c6ef4
	pc = 0x828C6EF4; continue 'dispatch;
	// 828C6EF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C6EF4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C6EF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C6EFC: 409A0044  bne cr6, 0x828c6f40
	if !ctx.cr[6].eq {
	pc = 0x828C6F40; continue 'dispatch;
	}
	// 828C6F00: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C6F04: 419A001C  beq cr6, 0x828c6f20
	if ctx.cr[6].eq {
	pc = 0x828C6F20; continue 'dispatch;
	}
	// 828C6F08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C6F0C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C6F10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C6F14: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C6F18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C6F1C: 4E800421  bctrl
	ctx.lr = 0x828C6F20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C6F20: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C6F24: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C6F28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C6F2C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828C6F30: 816B435C  lwz r11, 0x435c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17244 as u32) ) } as u64;
	// 828C6F34: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C6F38: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C6F3C: 4B9F90C5  bl 0x822c0000
	ctx.lr = 0x828C6F40;
	sub_822C0000(ctx, base);
	// 828C6F40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C6F44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C6F48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C6F4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C6F50: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C6F54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C6F58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6F60 size=72
    let mut pc: u32 = 0x828C6F60;
    'dispatch: loop {
        match pc {
            0x828C6F60 => {
    //   block [0x828C6F60..0x828C6FA8)
	// 828C6F60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6F64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C6F68: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6F6C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828C6F70: 419A001C  beq cr6, 0x828c6f8c
	if ctx.cr[6].eq {
	pc = 0x828C6F8C; continue 'dispatch;
	}
	// 828C6F74: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828C6F78: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C6F7C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828C6F80: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C6F84: 4BFFFE8D  bl 0x828c6e10
	ctx.lr = 0x828C6F88;
	sub_828C6E10(ctx, base);
	// 828C6F88: 48000010  b 0x828c6f98
	pc = 0x828C6F98; continue 'dispatch;
	// 828C6F8C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C6F90: 396B43B8  addi r11, r11, 0x43b8
	ctx.r[11].s64 = ctx.r[11].s64 + 17336;
	// 828C6F94: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C6F98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C6F9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C6FA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C6FA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C6FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C6FA8 size=128
    let mut pc: u32 = 0x828C6FA8;
    'dispatch: loop {
        match pc {
            0x828C6FA8 => {
    //   block [0x828C6FA8..0x828C7028)
	// 828C6FA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C6FAC: 488E11C1  bl 0x831a816c
	ctx.lr = 0x828C6FB0;
	sub_831A8130(ctx, base);
	// 828C6FB0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C6FB4: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828C6FB8: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828C6FBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C6FC0: 3BEB0CC4  addi r31, r11, 0xcc4
	ctx.r[31].s64 = ctx.r[11].s64 + 3268;
	// 828C6FC4: 816A0CCC  lwz r11, 0xccc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3276 as u32) ) } as u64;
	// 828C6FC8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C6FCC: 40820024  bne 0x828c6ff0
	if !ctx.cr[0].eq {
	pc = 0x828C6FF0; continue 'dispatch;
	}
	// 828C6FD0: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 828C6FD4: 3D00828C  lis r8, -0x7d74
	ctx.r[8].s64 = -2104754176;
	// 828C6FD8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828C6FDC: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 828C6FE0: 39086F60  addi r8, r8, 0x6f60
	ctx.r[8].s64 = ctx.r[8].s64 + 28512;
	// 828C6FE4: 916A0CCC  stw r11, 0xccc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(3276 as u32), ctx.r[11].u32 ) };
	// 828C6FE8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C6FEC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828C6FF0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828C6FF4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C6FF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C6FFC: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828C7000: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828C7004: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C7008: 4BD8D5B9  bl 0x826545c0
	ctx.lr = 0x828C700C;
	sub_826545C0(ctx, base);
	// 828C700C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C7010: 4182000C  beq 0x828c701c
	if ctx.cr[0].eq {
	pc = 0x828C701C; continue 'dispatch;
	}
	// 828C7014: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C7018: 48000008  b 0x828c7020
	pc = 0x828C7020; continue 'dispatch;
	// 828C701C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C7020: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C7024: 488E1198  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C7028 size=204
    let mut pc: u32 = 0x828C7028;
    'dispatch: loop {
        match pc {
            0x828C7028 => {
    //   block [0x828C7028..0x828C70F4)
	// 828C7028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C702C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7030: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C7034: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C7038: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C703C: 3D40828C  lis r10, -0x7d74
	ctx.r[10].s64 = -2104754176;
	// 828C7040: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C7044: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C7048: 394A6DB8  addi r10, r10, 0x6db8
	ctx.r[10].s64 = ctx.r[10].s64 + 28088;
	// 828C704C: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 828C7050: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828C7054: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C7058: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C705C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C7060: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828C7064: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C7068: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 828C706C: 4BFFFF3D  bl 0x828c6fa8
	ctx.lr = 0x828C7070;
	sub_828C6FA8(ctx, base);
	// 828C7070: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C7074: 4BFFB5B5  bl 0x828c2628
	ctx.lr = 0x828C7078;
	sub_828C2628(ctx, base);
	// 828C7078: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828C707C: C023000C  lfs f1, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C7080: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C7084: C04B7BC8  lfs f2, 0x7bc8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31688 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828C7088: 4BF2EE99  bl 0x827f5f20
	ctx.lr = 0x828C708C;
	sub_827F5F20(ctx, base);
	// 828C708C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C7090: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828C7094: 388BDA88  addi r4, r11, -0x2578
	ctx.r[4].s64 = ctx.r[11].s64 + -9592;
	// 828C7098: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 828C709C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C70A0: 4BFFF151  bl 0x828c61f0
	ctx.lr = 0x828C70A4;
	sub_828C61F0(ctx, base);
	// 828C70A4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828C70A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C70AC: 808BF3F8  lwz r4, -0xc08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3080 as u32) ) } as u64;
	// 828C70B0: 4852C959  bl 0x82df3a08
	ctx.lr = 0x828C70B4;
	sub_82DF3A08(ctx, base);
	// 828C70B4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C70B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C70BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C70C0: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C70C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C70C8: 4E800421  bctrl
	ctx.lr = 0x828C70CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C70CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C70D0: 4852C359  bl 0x82df3428
	ctx.lr = 0x828C70D4;
	sub_82DF3428(ctx, base);
	// 828C70D4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828C70D8: 4BA01BE1  bl 0x822c8cb8
	ctx.lr = 0x828C70DC;
	sub_822C8CB8(ctx, base);
	// 828C70DC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C70E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C70E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C70E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C70EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C70F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C70F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C70F8 size=96
    let mut pc: u32 = 0x828C70F8;
    'dispatch: loop {
        match pc {
            0x828C70F8 => {
    //   block [0x828C70F8..0x828C7158)
	// 828C70F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C70FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7100: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C7104: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7108: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C710C: 4BFFCC5D  bl 0x828c3d68
	ctx.lr = 0x828C7110;
	sub_828C3D68(ctx, base);
	// 828C7110: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C7114: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828C7118: 396BDA98  addi r11, r11, -0x2568
	ctx.r[11].s64 = ctx.r[11].s64 + -9576;
	// 828C711C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7120: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C7124: 808A39E8  lwz r4, 0x39e8(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(14824 as u32) ) } as u64;
	// 828C7128: 4852C8E1  bl 0x82df3a08
	ctx.lr = 0x828C712C;
	sub_82DF3A08(ctx, base);
	// 828C712C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C7130: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C7134: 485925B5  bl 0x82e596e8
	ctx.lr = 0x828C7138;
	sub_82E596E8(ctx, base);
	// 828C7138: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C713C: 4852C2ED  bl 0x82df3428
	ctx.lr = 0x828C7140;
	sub_82DF3428(ctx, base);
	// 828C7140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C7144: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C7148: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C714C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C7150: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C7154: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7158 size=112
    let mut pc: u32 = 0x828C7158;
    'dispatch: loop {
        match pc {
            0x828C7158 => {
    //   block [0x828C7158..0x828C71C8)
	// 828C7158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C715C: 488E1011  bl 0x831a816c
	ctx.lr = 0x828C7160;
	sub_831A8130(ctx, base);
	// 828C7160: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7164: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C7168: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C716C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C7170: 388BDA10  addi r4, r11, -0x25f0
	ctx.r[4].s64 = ctx.r[11].s64 + -9712;
	// 828C7174: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 828C7178: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 828C717C: 4852B26D  bl 0x82df23e8
	ctx.lr = 0x828C7180;
	sub_82DF23E8(ctx, base);
	// 828C7180: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C7184: 41820010  beq 0x828c7194
	if ctx.cr[0].eq {
	pc = 0x828C7194; continue 'dispatch;
	}
	// 828C7188: 4BFFFF71  bl 0x828c70f8
	ctx.lr = 0x828C718C;
	sub_828C70F8(ctx, base);
	// 828C718C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C7190: 48000008  b 0x828c7198
	pc = 0x828C7198; continue 'dispatch;
	// 828C7194: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C7198: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C719C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828C71A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C71A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C71A8: 4BFFFCF1  bl 0x828c6e98
	ctx.lr = 0x828C71AC;
	sub_828C6E98(ctx, base);
	// 828C71AC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C71B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C71B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C71B8: 4B9F8E49  bl 0x822c0000
	ctx.lr = 0x828C71BC;
	sub_822C0000(ctx, base);
	// 828C71BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C71C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C71C4: 488E0FF8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C71C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C71C8 size=108
    let mut pc: u32 = 0x828C71C8;
    'dispatch: loop {
        match pc {
            0x828C71C8 => {
    //   block [0x828C71C8..0x828C7234)
	// 828C71C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C71CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C71D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C71D4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C71D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C71DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C71E0: 4BFFB449  bl 0x828c2628
	ctx.lr = 0x828C71E4;
	sub_828C2628(ctx, base);
	// 828C71E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C71E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C71EC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 828C71F0: 409A0010  bne cr6, 0x828c7200
	if !ctx.cr[6].eq {
	pc = 0x828C7200; continue 'dispatch;
	}
	// 828C71F4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828C71F8: 808B0AF8  lwz r4, 0xaf8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2808 as u32) ) } as u64;
	// 828C71FC: 4800000C  b 0x828c7208
	pc = 0x828C7208; continue 'dispatch;
	// 828C7200: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C7204: 808B39E8  lwz r4, 0x39e8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14824 as u32) ) } as u64;
	// 828C7208: 4852C801  bl 0x82df3a08
	ctx.lr = 0x828C720C;
	sub_82DF3A08(ctx, base);
	// 828C720C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C7210: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C7214: 4BF2852D  bl 0x827ef740
	ctx.lr = 0x828C7218;
	sub_827EF740(ctx, base);
	// 828C7218: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C721C: 4852C20D  bl 0x82df3428
	ctx.lr = 0x828C7220;
	sub_82DF3428(ctx, base);
	// 828C7220: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C7224: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C7228: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C722C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C7230: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7238 size=96
    let mut pc: u32 = 0x828C7238;
    'dispatch: loop {
        match pc {
            0x828C7238 => {
    //   block [0x828C7238..0x828C7298)
	// 828C7238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C723C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7240: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C7244: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7248: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C724C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C7250: 4BFFB549  bl 0x828c2798
	ctx.lr = 0x828C7254;
	sub_828C2798(ctx, base);
	// 828C7254: 48054BC5  bl 0x8291be18
	ctx.lr = 0x828C7258;
	sub_8291BE18(ctx, base);
	// 828C7258: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C725C: 41820028  beq 0x828c7284
	if ctx.cr[0].eq {
	pc = 0x828C7284; continue 'dispatch;
	}
	// 828C7260: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828C7264: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7268: 808B0B08  lwz r4, 0xb08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2824 as u32) ) } as u64;
	// 828C726C: 4852C79D  bl 0x82df3a08
	ctx.lr = 0x828C7270;
	sub_82DF3A08(ctx, base);
	// 828C7270: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C7274: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C7278: 4BF284C9  bl 0x827ef740
	ctx.lr = 0x828C727C;
	sub_827EF740(ctx, base);
	// 828C727C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7280: 4852C1A9  bl 0x82df3428
	ctx.lr = 0x828C7284;
	sub_82DF3428(ctx, base);
	// 828C7284: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C7288: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C728C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C7290: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C7294: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7298 size=136
    let mut pc: u32 = 0x828C7298;
    'dispatch: loop {
        match pc {
            0x828C7298 => {
    //   block [0x828C7298..0x828C7320)
	// 828C7298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C729C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C72A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C72A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C72A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C72AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C72B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C72B4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828C72B8: 409A0020  bne cr6, 0x828c72d8
	if !ctx.cr[6].eq {
	pc = 0x828C72D8; continue 'dispatch;
	}
	// 828C72BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C72C0: 419A0048  beq cr6, 0x828c7308
	if ctx.cr[6].eq {
	pc = 0x828C7308; continue 'dispatch;
	}
	// 828C72C4: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828C72C8: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828C72CC: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828C72D0: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828C72D4: 48000034  b 0x828c7308
	pc = 0x828C7308; continue 'dispatch;
	// 828C72D8: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828C72DC: 419A002C  beq cr6, 0x828c7308
	if ctx.cr[6].eq {
	pc = 0x828C7308; continue 'dispatch;
	}
	// 828C72E0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C72E4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C72E8: 388B4570  addi r4, r11, 0x4570
	ctx.r[4].s64 = ctx.r[11].s64 + 17776;
	// 828C72EC: 488E0E0D  bl 0x831a80f8
	ctx.lr = 0x828C72F0;
	sub_831A80F8(ctx, base);
	// 828C72F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C72F4: 4182000C  beq 0x828c7300
	if ctx.cr[0].eq {
	pc = 0x828C7300; continue 'dispatch;
	}
	// 828C72F8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828C72FC: 4800000C  b 0x828c7308
	pc = 0x828C7308; continue 'dispatch;
	// 828C7300: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C7304: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C7308: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C730C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C7310: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C7314: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C7318: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C731C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7320 size=196
    let mut pc: u32 = 0x828C7320;
    'dispatch: loop {
        match pc {
            0x828C7320 => {
    //   block [0x828C7320..0x828C73E4)
	// 828C7320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C7324: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7328: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C732C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C7330: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7334: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C7338: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C733C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C7340: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C7344: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C7348: 4B9F95F1  bl 0x822c0938
	ctx.lr = 0x828C734C;
	sub_822C0938(ctx, base);
	// 828C734C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C7350: 41820028  beq 0x828c7378
	if ctx.cr[0].eq {
	pc = 0x828C7378; continue 'dispatch;
	}
	// 828C7354: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C7358: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828C735C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C7360: 392BDAD0  addi r9, r11, -0x2530
	ctx.r[9].s64 = ctx.r[11].s64 + -9520;
	// 828C7364: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C7368: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C736C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C7370: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C7374: 48000008  b 0x828c737c
	pc = 0x828C737C; continue 'dispatch;
	// 828C7378: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C737C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C7380: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7384: 409A0044  bne cr6, 0x828c73c8
	if !ctx.cr[6].eq {
	pc = 0x828C73C8; continue 'dispatch;
	}
	// 828C7388: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C738C: 419A001C  beq cr6, 0x828c73a8
	if ctx.cr[6].eq {
	pc = 0x828C73A8; continue 'dispatch;
	}
	// 828C7390: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7394: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C7398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C739C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C73A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C73A4: 4E800421  bctrl
	ctx.lr = 0x828C73A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C73A8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C73AC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C73B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C73B4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828C73B8: 816B44BC  lwz r11, 0x44bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17596 as u32) ) } as u64;
	// 828C73BC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C73C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C73C4: 4B9F8C3D  bl 0x822c0000
	ctx.lr = 0x828C73C8;
	sub_822C0000(ctx, base);
	// 828C73C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C73CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C73D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C73D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C73D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C73DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C73E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C73E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C73E8 size=196
    let mut pc: u32 = 0x828C73E8;
    'dispatch: loop {
        match pc {
            0x828C73E8 => {
    //   block [0x828C73E8..0x828C74AC)
	// 828C73E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C73EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C73F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C73F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C73F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C73FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C7400: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C7404: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C7408: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C740C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C7410: 4B9F9529  bl 0x822c0938
	ctx.lr = 0x828C7414;
	sub_822C0938(ctx, base);
	// 828C7414: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C7418: 41820028  beq 0x828c7440
	if ctx.cr[0].eq {
	pc = 0x828C7440; continue 'dispatch;
	}
	// 828C741C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C7420: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828C7424: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C7428: 392BDAE4  addi r9, r11, -0x251c
	ctx.r[9].s64 = ctx.r[11].s64 + -9500;
	// 828C742C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C7430: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C7434: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C7438: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C743C: 48000008  b 0x828c7444
	pc = 0x828C7444; continue 'dispatch;
	// 828C7440: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C7444: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C7448: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C744C: 409A0044  bne cr6, 0x828c7490
	if !ctx.cr[6].eq {
	pc = 0x828C7490; continue 'dispatch;
	}
	// 828C7450: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C7454: 419A001C  beq cr6, 0x828c7470
	if ctx.cr[6].eq {
	pc = 0x828C7470; continue 'dispatch;
	}
	// 828C7458: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C745C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C7460: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C7464: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7468: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C746C: 4E800421  bctrl
	ctx.lr = 0x828C7470;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C7470: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C7474: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C7478: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C747C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828C7480: 816B44BC  lwz r11, 0x44bc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17596 as u32) ) } as u64;
	// 828C7484: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C7488: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C748C: 4B9F8B75  bl 0x822c0000
	ctx.lr = 0x828C7490;
	sub_822C0000(ctx, base);
	// 828C7490: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C7494: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C7498: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C749C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C74A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C74A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C74A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C74B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C74B0 size=72
    let mut pc: u32 = 0x828C74B0;
    'dispatch: loop {
        match pc {
            0x828C74B0 => {
    //   block [0x828C74B0..0x828C74F8)
	// 828C74B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C74B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C74B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C74BC: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828C74C0: 419A001C  beq cr6, 0x828c74dc
	if ctx.cr[6].eq {
	pc = 0x828C74DC; continue 'dispatch;
	}
	// 828C74C4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828C74C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C74CC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828C74D0: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C74D4: 4BFFFDC5  bl 0x828c7298
	ctx.lr = 0x828C74D8;
	sub_828C7298(ctx, base);
	// 828C74D8: 48000010  b 0x828c74e8
	pc = 0x828C74E8; continue 'dispatch;
	// 828C74DC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C74E0: 396B4570  addi r11, r11, 0x4570
	ctx.r[11].s64 = ctx.r[11].s64 + 17776;
	// 828C74E4: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C74E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C74EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C74F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C74F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C74F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C74F8 size=128
    let mut pc: u32 = 0x828C74F8;
    'dispatch: loop {
        match pc {
            0x828C74F8 => {
    //   block [0x828C74F8..0x828C7578)
	// 828C74F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C74FC: 488E0C71  bl 0x831a816c
	ctx.lr = 0x828C7500;
	sub_831A8130(ctx, base);
	// 828C7500: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7504: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828C7508: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828C750C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C7510: 3BEB0CD0  addi r31, r11, 0xcd0
	ctx.r[31].s64 = ctx.r[11].s64 + 3280;
	// 828C7514: 816A0CD8  lwz r11, 0xcd8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3288 as u32) ) } as u64;
	// 828C7518: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C751C: 40820024  bne 0x828c7540
	if !ctx.cr[0].eq {
	pc = 0x828C7540; continue 'dispatch;
	}
	// 828C7520: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 828C7524: 3D00828C  lis r8, -0x7d74
	ctx.r[8].s64 = -2104754176;
	// 828C7528: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828C752C: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 828C7530: 390874B0  addi r8, r8, 0x74b0
	ctx.r[8].s64 = ctx.r[8].s64 + 29872;
	// 828C7534: 916A0CD8  stw r11, 0xcd8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(3288 as u32), ctx.r[11].u32 ) };
	// 828C7538: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C753C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828C7540: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828C7544: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C7548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C754C: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828C7550: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828C7554: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C7558: 4BD8D069  bl 0x826545c0
	ctx.lr = 0x828C755C;
	sub_826545C0(ctx, base);
	// 828C755C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C7560: 4182000C  beq 0x828c756c
	if ctx.cr[0].eq {
	pc = 0x828C756C; continue 'dispatch;
	}
	// 828C7564: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C7568: 48000008  b 0x828c7570
	pc = 0x828C7570; continue 'dispatch;
	// 828C756C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C7570: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C7574: 488E0C48  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C7578 size=204
    let mut pc: u32 = 0x828C7578;
    'dispatch: loop {
        match pc {
            0x828C7578 => {
    //   block [0x828C7578..0x828C7644)
	// 828C7578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C757C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7580: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C7584: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C7588: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C758C: 3D40828D  lis r10, -0x7d73
	ctx.r[10].s64 = -2104688640;
	// 828C7590: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C7594: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C7598: 394ADEE0  addi r10, r10, -0x2120
	ctx.r[10].s64 = ctx.r[10].s64 + -8480;
	// 828C759C: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 828C75A0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828C75A4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C75A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C75AC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C75B0: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828C75B4: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828C75B8: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 828C75BC: 4BFFFF3D  bl 0x828c74f8
	ctx.lr = 0x828C75C0;
	sub_828C74F8(ctx, base);
	// 828C75C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C75C4: 4BFFB0AD  bl 0x828c2670
	ctx.lr = 0x828C75C8;
	sub_828C2670(ctx, base);
	// 828C75C8: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828C75CC: C0230088  lfs f1, 0x88(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C75D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C75D4: C04B7BC8  lfs f2, 0x7bc8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31688 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828C75D8: 4BF2E949  bl 0x827f5f20
	ctx.lr = 0x828C75DC;
	sub_827F5F20(ctx, base);
	// 828C75DC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C75E0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828C75E4: 388BDA88  addi r4, r11, -0x2578
	ctx.r[4].s64 = ctx.r[11].s64 + -9592;
	// 828C75E8: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 828C75EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C75F0: 4BFFEC01  bl 0x828c61f0
	ctx.lr = 0x828C75F4;
	sub_828C61F0(ctx, base);
	// 828C75F4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828C75F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C75FC: 808BF3F8  lwz r4, -0xc08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3080 as u32) ) } as u64;
	// 828C7600: 4852C409  bl 0x82df3a08
	ctx.lr = 0x828C7604;
	sub_82DF3A08(ctx, base);
	// 828C7604: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7608: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C760C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C7610: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828C7614: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C7618: 4E800421  bctrl
	ctx.lr = 0x828C761C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C761C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7620: 4852BE09  bl 0x82df3428
	ctx.lr = 0x828C7624;
	sub_82DF3428(ctx, base);
	// 828C7624: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828C7628: 4BA01691  bl 0x822c8cb8
	ctx.lr = 0x828C762C;
	sub_822C8CB8(ctx, base);
	// 828C762C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828C7630: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C7634: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C7638: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C763C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C7640: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7648 size=96
    let mut pc: u32 = 0x828C7648;
    'dispatch: loop {
        match pc {
            0x828C7648 => {
    //   block [0x828C7648..0x828C76A8)
	// 828C7648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C764C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7650: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C7654: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7658: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C765C: 4BFFC8AD  bl 0x828c3f08
	ctx.lr = 0x828C7660;
	sub_828C3F08(ctx, base);
	// 828C7660: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C7664: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828C7668: 396BDAF8  addi r11, r11, -0x2508
	ctx.r[11].s64 = ctx.r[11].s64 + -9480;
	// 828C766C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7670: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C7674: 808A0AF8  lwz r4, 0xaf8(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2808 as u32) ) } as u64;
	// 828C7678: 4852C391  bl 0x82df3a08
	ctx.lr = 0x828C767C;
	sub_82DF3A08(ctx, base);
	// 828C767C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C7680: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C7684: 48592065  bl 0x82e596e8
	ctx.lr = 0x828C7688;
	sub_82E596E8(ctx, base);
	// 828C7688: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C768C: 4852BD9D  bl 0x82df3428
	ctx.lr = 0x828C7690;
	sub_82DF3428(ctx, base);
	// 828C7690: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C7694: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C7698: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C769C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C76A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C76A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C76A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C76A8 size=96
    let mut pc: u32 = 0x828C76A8;
    'dispatch: loop {
        match pc {
            0x828C76A8 => {
    //   block [0x828C76A8..0x828C7708)
	// 828C76A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C76AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C76B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C76B4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C76B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C76BC: 4BFFC84D  bl 0x828c3f08
	ctx.lr = 0x828C76C0;
	sub_828C3F08(ctx, base);
	// 828C76C0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C76C4: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828C76C8: 396BDB34  addi r11, r11, -0x24cc
	ctx.r[11].s64 = ctx.r[11].s64 + -9420;
	// 828C76CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C76D0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C76D4: 808A0AF4  lwz r4, 0xaf4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2804 as u32) ) } as u64;
	// 828C76D8: 4852C331  bl 0x82df3a08
	ctx.lr = 0x828C76DC;
	sub_82DF3A08(ctx, base);
	// 828C76DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C76E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C76E4: 48592005  bl 0x82e596e8
	ctx.lr = 0x828C76E8;
	sub_82E596E8(ctx, base);
	// 828C76E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C76EC: 4852BD3D  bl 0x82df3428
	ctx.lr = 0x828C76F0;
	sub_82DF3428(ctx, base);
	// 828C76F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C76F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C76F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C76FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C7700: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C7704: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7708 size=112
    let mut pc: u32 = 0x828C7708;
    'dispatch: loop {
        match pc {
            0x828C7708 => {
    //   block [0x828C7708..0x828C7778)
	// 828C7708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C770C: 488E0A61  bl 0x831a816c
	ctx.lr = 0x828C7710;
	sub_831A8130(ctx, base);
	// 828C7710: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7714: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C7718: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C771C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C7720: 388BDB70  addi r4, r11, -0x2490
	ctx.r[4].s64 = ctx.r[11].s64 + -9360;
	// 828C7724: 38A00060  li r5, 0x60
	ctx.r[5].s64 = 96;
	// 828C7728: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 828C772C: 4852ACBD  bl 0x82df23e8
	ctx.lr = 0x828C7730;
	sub_82DF23E8(ctx, base);
	// 828C7730: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C7734: 41820010  beq 0x828c7744
	if ctx.cr[0].eq {
	pc = 0x828C7744; continue 'dispatch;
	}
	// 828C7738: 4BFFFF11  bl 0x828c7648
	ctx.lr = 0x828C773C;
	sub_828C7648(ctx, base);
	// 828C773C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C7740: 48000008  b 0x828c7748
	pc = 0x828C7748; continue 'dispatch;
	// 828C7744: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C7748: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C774C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828C7750: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C7754: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C7758: 4BFFFC91  bl 0x828c73e8
	ctx.lr = 0x828C775C;
	sub_828C73E8(ctx, base);
	// 828C775C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C7760: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C7764: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C7768: 4B9F8899  bl 0x822c0000
	ctx.lr = 0x828C776C;
	sub_822C0000(ctx, base);
	// 828C776C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C7770: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C7774: 488E0A48  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7778 size=112
    let mut pc: u32 = 0x828C7778;
    'dispatch: loop {
        match pc {
            0x828C7778 => {
    //   block [0x828C7778..0x828C77E8)
	// 828C7778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C777C: 488E09F1  bl 0x831a816c
	ctx.lr = 0x828C7780;
	sub_831A8130(ctx, base);
	// 828C7780: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7784: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C7788: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C778C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C7790: 388BDB70  addi r4, r11, -0x2490
	ctx.r[4].s64 = ctx.r[11].s64 + -9360;
	// 828C7794: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 828C7798: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 828C779C: 4852AC4D  bl 0x82df23e8
	ctx.lr = 0x828C77A0;
	sub_82DF23E8(ctx, base);
	// 828C77A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C77A4: 41820010  beq 0x828c77b4
	if ctx.cr[0].eq {
	pc = 0x828C77B4; continue 'dispatch;
	}
	// 828C77A8: 4BFFFF01  bl 0x828c76a8
	ctx.lr = 0x828C77AC;
	sub_828C76A8(ctx, base);
	// 828C77AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C77B0: 48000008  b 0x828c77b8
	pc = 0x828C77B8; continue 'dispatch;
	// 828C77B4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C77B8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C77BC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828C77C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C77C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C77C8: 4BFFFB59  bl 0x828c7320
	ctx.lr = 0x828C77CC;
	sub_828C7320(ctx, base);
	// 828C77CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C77D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C77D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C77D8: 4B9F8829  bl 0x822c0000
	ctx.lr = 0x828C77DC;
	sub_822C0000(ctx, base);
	// 828C77DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C77E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C77E4: 488E09D8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C77E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C77E8 size=16
    let mut pc: u32 = 0x828C77E8;
    'dispatch: loop {
        match pc {
            0x828C77E8 => {
    //   block [0x828C77E8..0x828C77F8)
	// 828C77E8: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828C77EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C77F0: 386B0D78  addi r3, r11, 0xd78
	ctx.r[3].s64 = ctx.r[11].s64 + 3448;
	// 828C77F4: 48003B9C  b 0x828cb390
	sub_828CB390(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C77F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C77F8 size=92
    let mut pc: u32 = 0x828C77F8;
    'dispatch: loop {
        match pc {
            0x828C77F8 => {
    //   block [0x828C77F8..0x828C7854)
	// 828C77F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C77FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7800: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C7804: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C7808: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C780C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C7810: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C7814: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C7818: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C781C: 388BDC54  addi r4, r11, -0x23ac
	ctx.r[4].s64 = ctx.r[11].s64 + -9132;
	// 828C7820: 4852C1E9  bl 0x82df3a08
	ctx.lr = 0x828C7824;
	sub_82DF3A08(ctx, base);
	// 828C7824: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C7828: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C782C: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828C7830: 48046621  bl 0x8290de50
	ctx.lr = 0x828C7834;
	sub_8290DE50(ctx, base);
	// 828C7834: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7838: 4852BBF1  bl 0x82df3428
	ctx.lr = 0x828C783C;
	sub_82DF3428(ctx, base);
	// 828C783C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C7840: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C7844: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C7848: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C784C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C7850: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7858 size=96
    let mut pc: u32 = 0x828C7858;
    'dispatch: loop {
        match pc {
            0x828C7858 => {
    //   block [0x828C7858..0x828C78B8)
	// 828C7858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C785C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7860: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C7864: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7868: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828C786C: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828C7870: 3BEB0CDC  addi r31, r11, 0xcdc
	ctx.r[31].s64 = ctx.r[11].s64 + 3292;
	// 828C7874: 816A0CE8  lwz r11, 0xce8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3304 as u32) ) } as u64;
	// 828C7878: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C787C: 40820024  bne 0x828c78a0
	if !ctx.cr[0].eq {
	pc = 0x828C78A0; continue 'dispatch;
	}
	// 828C7880: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828C7884: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 828C7888: 916A0CE8  stw r11, 0xce8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(3304 as u32), ctx.r[11].u32 ) };
	// 828C788C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C7890: 3889BF6C  addi r4, r9, -0x4094
	ctx.r[4].s64 = ctx.r[9].s64 + -16532;
	// 828C7894: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 828C7898: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 828C789C: 48093B85  bl 0x8295b420
	ctx.lr = 0x828C78A0;
	sub_8295B420(ctx, base);
	// 828C78A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C78A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C78A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C78AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C78B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C78B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C78B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C78B8 size=8
    let mut pc: u32 = 0x828C78B8;
    'dispatch: loop {
        match pc {
            0x828C78B8 => {
    //   block [0x828C78B8..0x828C78C0)
	// 828C78B8: 386303C0  addi r3, r3, 0x3c0
	ctx.r[3].s64 = ctx.r[3].s64 + 960;
	// 828C78BC: 48594DDC  b 0x82e5c698
	sub_82E5C698(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C78C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C78C0 size=12
    let mut pc: u32 = 0x828C78C0;
    'dispatch: loop {
        match pc {
            0x828C78C0 => {
    //   block [0x828C78C0..0x828C78CC)
	// 828C78C0: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828C78C4: 386B0D78  addi r3, r11, 0xd78
	ctx.r[3].s64 = ctx.r[11].s64 + 3448;
	// 828C78C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C78D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C78D0 size=8
    let mut pc: u32 = 0x828C78D0;
    'dispatch: loop {
        match pc {
            0x828C78D0 => {
    //   block [0x828C78D0..0x828C78D8)
	// 828C78D0: 386303A8  addi r3, r3, 0x3a8
	ctx.r[3].s64 = ctx.r[3].s64 + 936;
	// 828C78D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C78D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C78D8 size=108
    let mut pc: u32 = 0x828C78D8;
    'dispatch: loop {
        match pc {
            0x828C78D8 => {
    //   block [0x828C78D8..0x828C7944)
	// 828C78D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C78DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C78E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C78E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C78E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C78EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C78F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C78F4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 828C78F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C78FC: 419A0018  beq cr6, 0x828c7914
	if ctx.cr[6].eq {
	pc = 0x828C7914; continue 'dispatch;
	}
	// 828C7900: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828C7904: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C7908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C790C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C7910: 4E800421  bctrl
	ctx.lr = 0x828C7914;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C7914: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C7918: 419A0010  beq cr6, 0x828c7928
	if ctx.cr[6].eq {
	pc = 0x828C7928; continue 'dispatch;
	}
	// 828C791C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828C7920: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828C7924: 48000008  b 0x828c792c
	pc = 0x828C792C; continue 'dispatch;
	// 828C7928: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C792C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C7930: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C7934: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C7938: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C793C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C7940: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7948 size=116
    let mut pc: u32 = 0x828C7948;
    'dispatch: loop {
        match pc {
            0x828C7948 => {
    //   block [0x828C7948..0x828C79BC)
	// 828C7948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C794C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7950: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C7954: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C7958: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C795C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C7960: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C7964: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828C7968: 409A000C  bne cr6, 0x828c7974
	if !ctx.cr[6].eq {
	pc = 0x828C7974; continue 'dispatch;
	}
	// 828C796C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7970: 48000030  b 0x828c79a0
	pc = 0x828C79A0; continue 'dispatch;
	// 828C7974: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828C7978: 419A0024  beq cr6, 0x828c799c
	if ctx.cr[6].eq {
	pc = 0x828C799C; continue 'dispatch;
	}
	// 828C797C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C7980: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7984: 388B47A8  addi r4, r11, 0x47a8
	ctx.r[4].s64 = ctx.r[11].s64 + 18344;
	// 828C7988: 488E0771  bl 0x831a80f8
	ctx.lr = 0x828C798C;
	sub_831A80F8(ctx, base);
	// 828C798C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C7990: 4182000C  beq 0x828c799c
	if ctx.cr[0].eq {
	pc = 0x828C799C; continue 'dispatch;
	}
	// 828C7994: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828C7998: 4800000C  b 0x828c79a4
	pc = 0x828C79A4; continue 'dispatch;
	// 828C799C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C79A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C79A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C79A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C79AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C79B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C79B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C79B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C79C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C79C0 size=116
    let mut pc: u32 = 0x828C79C0;
    'dispatch: loop {
        match pc {
            0x828C79C0 => {
    //   block [0x828C79C0..0x828C7A34)
	// 828C79C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C79C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C79C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C79CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C79D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C79D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C79D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C79DC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828C79E0: 409A000C  bne cr6, 0x828c79ec
	if !ctx.cr[6].eq {
	pc = 0x828C79EC; continue 'dispatch;
	}
	// 828C79E4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C79E8: 48000030  b 0x828c7a18
	pc = 0x828C7A18; continue 'dispatch;
	// 828C79EC: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828C79F0: 419A0024  beq cr6, 0x828c7a14
	if ctx.cr[6].eq {
	pc = 0x828C7A14; continue 'dispatch;
	}
	// 828C79F4: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C79F8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C79FC: 388B47F8  addi r4, r11, 0x47f8
	ctx.r[4].s64 = ctx.r[11].s64 + 18424;
	// 828C7A00: 488E06F9  bl 0x831a80f8
	ctx.lr = 0x828C7A04;
	sub_831A80F8(ctx, base);
	// 828C7A04: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C7A08: 4182000C  beq 0x828c7a14
	if ctx.cr[0].eq {
	pc = 0x828C7A14; continue 'dispatch;
	}
	// 828C7A0C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828C7A10: 4800000C  b 0x828c7a1c
	pc = 0x828C7A1C; continue 'dispatch;
	// 828C7A14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C7A18: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C7A1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C7A20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C7A24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C7A28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C7A2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C7A30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7A38 size=116
    let mut pc: u32 = 0x828C7A38;
    'dispatch: loop {
        match pc {
            0x828C7A38 => {
    //   block [0x828C7A38..0x828C7AAC)
	// 828C7A38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C7A3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7A40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C7A44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C7A48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7A4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C7A50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C7A54: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828C7A58: 409A000C  bne cr6, 0x828c7a64
	if !ctx.cr[6].eq {
	pc = 0x828C7A64; continue 'dispatch;
	}
	// 828C7A5C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7A60: 48000030  b 0x828c7a90
	pc = 0x828C7A90; continue 'dispatch;
	// 828C7A64: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828C7A68: 419A0024  beq cr6, 0x828c7a8c
	if ctx.cr[6].eq {
	pc = 0x828C7A8C; continue 'dispatch;
	}
	// 828C7A6C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C7A70: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7A74: 388B4848  addi r4, r11, 0x4848
	ctx.r[4].s64 = ctx.r[11].s64 + 18504;
	// 828C7A78: 488E0681  bl 0x831a80f8
	ctx.lr = 0x828C7A7C;
	sub_831A80F8(ctx, base);
	// 828C7A7C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C7A80: 4182000C  beq 0x828c7a8c
	if ctx.cr[0].eq {
	pc = 0x828C7A8C; continue 'dispatch;
	}
	// 828C7A84: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828C7A88: 4800000C  b 0x828c7a94
	pc = 0x828C7A94; continue 'dispatch;
	// 828C7A8C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C7A90: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C7A94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C7A98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C7A9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C7AA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C7AA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C7AA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7AB0 size=136
    let mut pc: u32 = 0x828C7AB0;
    'dispatch: loop {
        match pc {
            0x828C7AB0 => {
    //   block [0x828C7AB0..0x828C7B38)
	// 828C7AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C7AB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7AB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C7ABC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C7AC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7AC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C7AC8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C7ACC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828C7AD0: 409A0020  bne cr6, 0x828c7af0
	if !ctx.cr[6].eq {
	pc = 0x828C7AF0; continue 'dispatch;
	}
	// 828C7AD4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C7AD8: 419A0048  beq cr6, 0x828c7b20
	if ctx.cr[6].eq {
	pc = 0x828C7B20; continue 'dispatch;
	}
	// 828C7ADC: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828C7AE0: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828C7AE4: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828C7AE8: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828C7AEC: 48000034  b 0x828c7b20
	pc = 0x828C7B20; continue 'dispatch;
	// 828C7AF0: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828C7AF4: 419A002C  beq cr6, 0x828c7b20
	if ctx.cr[6].eq {
	pc = 0x828C7B20; continue 'dispatch;
	}
	// 828C7AF8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C7AFC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7B00: 388B4898  addi r4, r11, 0x4898
	ctx.r[4].s64 = ctx.r[11].s64 + 18584;
	// 828C7B04: 488E05F5  bl 0x831a80f8
	ctx.lr = 0x828C7B08;
	sub_831A80F8(ctx, base);
	// 828C7B08: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C7B0C: 4182000C  beq 0x828c7b18
	if ctx.cr[0].eq {
	pc = 0x828C7B18; continue 'dispatch;
	}
	// 828C7B10: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828C7B14: 4800000C  b 0x828c7b20
	pc = 0x828C7B20; continue 'dispatch;
	// 828C7B18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C7B1C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C7B20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C7B24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C7B28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C7B2C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C7B30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C7B34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7B38 size=136
    let mut pc: u32 = 0x828C7B38;
    'dispatch: loop {
        match pc {
            0x828C7B38 => {
    //   block [0x828C7B38..0x828C7BC0)
	// 828C7B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C7B3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7B40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C7B44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C7B48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7B4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C7B50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C7B54: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828C7B58: 409A0020  bne cr6, 0x828c7b78
	if !ctx.cr[6].eq {
	pc = 0x828C7B78; continue 'dispatch;
	}
	// 828C7B5C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C7B60: 419A0048  beq cr6, 0x828c7ba8
	if ctx.cr[6].eq {
	pc = 0x828C7BA8; continue 'dispatch;
	}
	// 828C7B64: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828C7B68: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828C7B6C: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828C7B70: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828C7B74: 48000034  b 0x828c7ba8
	pc = 0x828C7BA8; continue 'dispatch;
	// 828C7B78: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828C7B7C: 419A002C  beq cr6, 0x828c7ba8
	if ctx.cr[6].eq {
	pc = 0x828C7BA8; continue 'dispatch;
	}
	// 828C7B80: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C7B84: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7B88: 388B4960  addi r4, r11, 0x4960
	ctx.r[4].s64 = ctx.r[11].s64 + 18784;
	// 828C7B8C: 488E056D  bl 0x831a80f8
	ctx.lr = 0x828C7B90;
	sub_831A80F8(ctx, base);
	// 828C7B90: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C7B94: 4182000C  beq 0x828c7ba0
	if ctx.cr[0].eq {
	pc = 0x828C7BA0; continue 'dispatch;
	}
	// 828C7B98: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828C7B9C: 4800000C  b 0x828c7ba8
	pc = 0x828C7BA8; continue 'dispatch;
	// 828C7BA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C7BA4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C7BA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C7BAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C7BB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C7BB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C7BB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C7BBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7BC0 size=100
    let mut pc: u32 = 0x828C7BC0;
    'dispatch: loop {
        match pc {
            0x828C7BC0 => {
    //   block [0x828C7BC0..0x828C7C24)
	// 828C7BC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C7BC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7BC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C7BCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C7BD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7BD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C7BD8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C7BDC: 807F03A8  lwz r3, 0x3a8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(936 as u32) ) } as u64;
	// 828C7BE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C7BE4: 419A0014  beq cr6, 0x828c7bf8
	if ctx.cr[6].eq {
	pc = 0x828C7BF8; continue 'dispatch;
	}
	// 828C7BE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7BEC: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828C7BF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C7BF4: 4E800421  bctrl
	ctx.lr = 0x828C7BF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C7BF8: 387F03B0  addi r3, r31, 0x3b0
	ctx.r[3].s64 = ctx.r[31].s64 + 944;
	// 828C7BFC: 48594A9D  bl 0x82e5c698
	ctx.lr = 0x828C7C00;
	sub_82E5C698(ctx, base);
	// 828C7C00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C7C04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C7C08: 48097631  bl 0x8295f238
	ctx.lr = 0x828C7C0C;
	sub_8295F238(ctx, base);
	// 828C7C0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C7C10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C7C14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C7C18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C7C1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C7C20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7C28 size=76
    let mut pc: u32 = 0x828C7C28;
    'dispatch: loop {
        match pc {
            0x828C7C28 => {
    //   block [0x828C7C28..0x828C7C74)
	// 828C7C28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C7C2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7C30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C7C34: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7C38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C7C3C: 807F03B8  lwz r3, 0x3b8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(952 as u32) ) } as u64;
	// 828C7C40: 4BF02B59  bl 0x827ca798
	ctx.lr = 0x828C7C44;
	sub_827CA798(ctx, base);
	// 828C7C44: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828C7C48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C7C4C: 4BF24635  bl 0x827ec280
	ctx.lr = 0x828C7C50;
	sub_827EC280(ctx, base);
	// 828C7C50: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828C7C54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C7C58: 388B2AD4  addi r4, r11, 0x2ad4
	ctx.r[4].s64 = ctx.r[11].s64 + 10964;
	// 828C7C5C: 4809745D  bl 0x8295f0b8
	ctx.lr = 0x828C7C60;
	sub_8295F0B8(ctx, base);
	// 828C7C60: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C7C64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C7C68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C7C6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C7C70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7C78 size=72
    let mut pc: u32 = 0x828C7C78;
    'dispatch: loop {
        match pc {
            0x828C7C78 => {
    //   block [0x828C7C78..0x828C7CC0)
	// 828C7C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C7C7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7C80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C7C84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7C88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C7C8C: 807F03B8  lwz r3, 0x3b8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(952 as u32) ) } as u64;
	// 828C7C90: 4BF02BA9  bl 0x827ca838
	ctx.lr = 0x828C7C94;
	sub_827CA838(ctx, base);
	// 828C7C94: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828C7C98: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C7C9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C7CA0: 4BF245D1  bl 0x827ec270
	ctx.lr = 0x828C7CA4;
	sub_827EC270(ctx, base);
	// 828C7CA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C7CA8: 48097359  bl 0x8295f000
	ctx.lr = 0x828C7CAC;
	sub_8295F000(ctx, base);
	// 828C7CAC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C7CB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C7CB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C7CB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C7CBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C7CC0 size=80
    let mut pc: u32 = 0x828C7CC0;
    'dispatch: loop {
        match pc {
            0x828C7CC0 => {
    //   block [0x828C7CC0..0x828C7D10)
	// 828C7CC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C7CC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7CC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C7CCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7CD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C7CD4: 4814B9AD  bl 0x82a13680
	ctx.lr = 0x828C7CD8;
	sub_82A13680(ctx, base);
	// 828C7CD8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828C7CDC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C7CE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C7CE4: C02B9450  lfs f1, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C7CE8: 48044FB1  bl 0x8290cc98
	ctx.lr = 0x828C7CEC;
	sub_8290CC98(ctx, base);
	// 828C7CEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C7CF0: 48041039  bl 0x82908d28
	ctx.lr = 0x828C7CF4;
	sub_82908D28(ctx, base);
	// 828C7CF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C7CF8: 4BC488D9  bl 0x825105d0
	ctx.lr = 0x828C7CFC;
	sub_825105D0(ctx, base);
	// 828C7CFC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C7D00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C7D04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C7D08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C7D0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C7D10 size=232
    let mut pc: u32 = 0x828C7D10;
    'dispatch: loop {
        match pc {
            0x828C7D10 => {
    //   block [0x828C7D10..0x828C7DF8)
	// 828C7D10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C7D14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7D18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C7D1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C7D20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7D24: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828C7D28: 806300F4  lwz r3, 0xf4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(244 as u32) ) } as u64;
	// 828C7D2C: 3D40832B  lis r10, -0x7cd5
	ctx.r[10].s64 = -2094333952;
	// 828C7D30: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C7D34: 38CB5DCC  addi r6, r11, 0x5dcc
	ctx.r[6].s64 = ctx.r[11].s64 + 24012;
	// 828C7D38: 38AAC8DC  addi r5, r10, -0x3724
	ctx.r[5].s64 = ctx.r[10].s64 + -14116;
	// 828C7D3C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828C7D40: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828C7D44: 488E2205  bl 0x831a9f48
	ctx.lr = 0x828C7D48;
	sub_831A9F48(ctx, base);
	// 828C7D48: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828C7D4C: 41820094  beq 0x828c7de0
	if ctx.cr[0].eq {
	pc = 0x828C7DE0; continue 'dispatch;
	}
	// 828C7D50: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828C7D54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C7D58: 4804F2D9  bl 0x82917030
	ctx.lr = 0x828C7D5C;
	sub_82917030(ctx, base);
	// 828C7D5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C7D60: 40820018  bne 0x828c7d78
	if !ctx.cr[0].eq {
	pc = 0x828C7D78; continue 'dispatch;
	}
	// 828C7D64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C7D68: 4804ED99  bl 0x82916b00
	ctx.lr = 0x828C7D6C;
	sub_82916B00(ctx, base);
	// 828C7D6C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C7D70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828C7D74: 41820008  beq 0x828c7d7c
	if ctx.cr[0].eq {
	pc = 0x828C7D7C; continue 'dispatch;
	}
	// 828C7D78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C7D7C: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 828C7D80: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828C7D84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C7D88: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 828C7D8C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7D90: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C7D94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C7D98: 4E800421  bctrl
	ctx.lr = 0x828C7D9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C7D9C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C7DA0: 39400040  li r10, 0x40
	ctx.r[10].s64 = 64;
	// 828C7DA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C7DA8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C7DF8 size=116
    let mut pc: u32 = 0x828C7DF8;
    'dispatch: loop {
        match pc {
            0x828C7DF8 => {
    //   block [0x828C7DF8..0x828C7E6C)
	// 828C7DF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C7DFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7E00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C7E04: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7E08: 80630398  lwz r3, 0x398(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(920 as u32) ) } as u64;
	// 828C7E0C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C7E10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C7E14: 419A0044  beq cr6, 0x828c7e58
	if ctx.cr[6].eq {
	pc = 0x828C7E58; continue 'dispatch;
	}
	// 828C7E18: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7E1C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828C7E20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C7E24: 4E800421  bctrl
	ctx.lr = 0x828C7E28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C7E28: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828C7E2C: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 828C7E30: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C7E34: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C7E38: C1830038  lfs f12, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828C7E3C: C163003C  lfs f11, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828C7E40: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828C7E44: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828C7E48: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828C7E4C: D161005C  stfs f11, 0x5c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828C7E50: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7E70 size=196
    let mut pc: u32 = 0x828C7E70;
    'dispatch: loop {
        match pc {
            0x828C7E70 => {
    //   block [0x828C7E70..0x828C7F34)
	// 828C7E70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C7E74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7E78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C7E7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C7E80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7E84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C7E88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C7E8C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C7E90: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C7E94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C7E98: 4B9F8AA1  bl 0x822c0938
	ctx.lr = 0x828C7E9C;
	sub_822C0938(ctx, base);
	// 828C7E9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C7EA0: 41820028  beq 0x828c7ec8
	if ctx.cr[0].eq {
	pc = 0x828C7EC8; continue 'dispatch;
	}
	// 828C7EA4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C7EA8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828C7EAC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C7EB0: 392BDCD0  addi r9, r11, -0x2330
	ctx.r[9].s64 = ctx.r[11].s64 + -9008;
	// 828C7EB4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C7EB8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C7EBC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C7EC0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C7EC4: 48000008  b 0x828c7ecc
	pc = 0x828C7ECC; continue 'dispatch;
	// 828C7EC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C7ECC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C7ED0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7ED4: 409A0044  bne cr6, 0x828c7f18
	if !ctx.cr[6].eq {
	pc = 0x828C7F18; continue 'dispatch;
	}
	// 828C7ED8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C7EDC: 419A001C  beq cr6, 0x828c7ef8
	if ctx.cr[6].eq {
	pc = 0x828C7EF8; continue 'dispatch;
	}
	// 828C7EE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7EE4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C7EE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C7EEC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C7EF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C7EF4: 4E800421  bctrl
	ctx.lr = 0x828C7EF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C7EF8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C7EFC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C7F00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7F04: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828C7F08: 816B46A4  lwz r11, 0x46a4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18084 as u32) ) } as u64;
	// 828C7F0C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C7F10: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C7F14: 4B9F80ED  bl 0x822c0000
	ctx.lr = 0x828C7F18;
	sub_822C0000(ctx, base);
	// 828C7F18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C7F1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C7F20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C7F24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C7F28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C7F2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C7F30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7F38 size=172
    let mut pc: u32 = 0x828C7F38;
    'dispatch: loop {
        match pc {
            0x828C7F38 => {
    //   block [0x828C7F38..0x828C7FE4)
	// 828C7F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C7F3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7F40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C7F44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C7F48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7F4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C7F50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C7F54: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C7F58: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C7F5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C7F60: 4B9F89D9  bl 0x822c0938
	ctx.lr = 0x828C7F64;
	sub_822C0938(ctx, base);
	// 828C7F64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C7F68: 41820028  beq 0x828c7f90
	if ctx.cr[0].eq {
	pc = 0x828C7F90; continue 'dispatch;
	}
	// 828C7F6C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C7F70: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828C7F74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C7F78: 392BDCE4  addi r9, r11, -0x231c
	ctx.r[9].s64 = ctx.r[11].s64 + -8988;
	// 828C7F7C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C7F80: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C7F84: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C7F88: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C7F8C: 48000008  b 0x828c7f94
	pc = 0x828C7F94; continue 'dispatch;
	// 828C7F90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C7F94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C7F98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C7F9C: 409A002C  bne cr6, 0x828c7fc8
	if !ctx.cr[6].eq {
	pc = 0x828C7FC8; continue 'dispatch;
	}
	// 828C7FA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C7FA4: 4B9F82C5  bl 0x822c0268
	ctx.lr = 0x828C7FA8;
	sub_822C0268(ctx, base);
	// 828C7FA8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C7FAC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C7FB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C7FB4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828C7FB8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C7FBC: 816B46A4  lwz r11, 0x46a4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18084 as u32) ) } as u64;
	// 828C7FC0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C7FC4: 4B9F803D  bl 0x822c0000
	ctx.lr = 0x828C7FC8;
	sub_822C0000(ctx, base);
	// 828C7FC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C7FCC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C7FD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C7FD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C7FD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C7FDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C7FE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C7FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C7FE8 size=196
    let mut pc: u32 = 0x828C7FE8;
    'dispatch: loop {
        match pc {
            0x828C7FE8 => {
    //   block [0x828C7FE8..0x828C80AC)
	// 828C7FE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C7FEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C7FF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C7FF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C7FF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C7FFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C8000: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C8004: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C8008: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C800C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C8010: 4B9F8929  bl 0x822c0938
	ctx.lr = 0x828C8014;
	sub_822C0938(ctx, base);
	// 828C8014: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C8018: 41820028  beq 0x828c8040
	if ctx.cr[0].eq {
	pc = 0x828C8040; continue 'dispatch;
	}
	// 828C801C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C8020: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828C8024: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828C8028: 392BDCF8  addi r9, r11, -0x2308
	ctx.r[9].s64 = ctx.r[11].s64 + -8968;
	// 828C802C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C8030: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828C8034: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828C8038: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828C803C: 48000008  b 0x828c8044
	pc = 0x828C8044; continue 'dispatch;
	// 828C8040: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C8044: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C8048: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C804C: 409A0044  bne cr6, 0x828c8090
	if !ctx.cr[6].eq {
	pc = 0x828C8090; continue 'dispatch;
	}
	// 828C8050: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C8054: 419A001C  beq cr6, 0x828c8070
	if ctx.cr[6].eq {
	pc = 0x828C8070; continue 'dispatch;
	}
	// 828C8058: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C805C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828C8060: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C8064: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8068: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C806C: 4E800421  bctrl
	ctx.lr = 0x828C8070;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C8070: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C8074: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C8078: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C807C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828C8080: 816B46A4  lwz r11, 0x46a4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18084 as u32) ) } as u64;
	// 828C8084: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C8088: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C808C: 4B9F7F75  bl 0x822c0000
	ctx.lr = 0x828C8090;
	sub_822C0000(ctx, base);
	// 828C8090: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C8094: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C8098: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C809C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C80A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C80A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C80A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C80B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C80B0 size=72
    let mut pc: u32 = 0x828C80B0;
    'dispatch: loop {
        match pc {
            0x828C80B0 => {
    //   block [0x828C80B0..0x828C80F8)
	// 828C80B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C80B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C80B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C80BC: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828C80C0: 419A001C  beq cr6, 0x828c80dc
	if ctx.cr[6].eq {
	pc = 0x828C80DC; continue 'dispatch;
	}
	// 828C80C4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828C80C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C80CC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828C80D0: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C80D4: 4BFFF875  bl 0x828c7948
	ctx.lr = 0x828C80D8;
	sub_828C7948(ctx, base);
	// 828C80D8: 48000010  b 0x828c80e8
	pc = 0x828C80E8; continue 'dispatch;
	// 828C80DC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C80E0: 396B47A8  addi r11, r11, 0x47a8
	ctx.r[11].s64 = ctx.r[11].s64 + 18344;
	// 828C80E4: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C80E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C80EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C80F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C80F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C80F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C80F8 size=72
    let mut pc: u32 = 0x828C80F8;
    'dispatch: loop {
        match pc {
            0x828C80F8 => {
    //   block [0x828C80F8..0x828C8140)
	// 828C80F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C80FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C8100: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8104: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828C8108: 419A001C  beq cr6, 0x828c8124
	if ctx.cr[6].eq {
	pc = 0x828C8124; continue 'dispatch;
	}
	// 828C810C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828C8110: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C8114: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828C8118: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C811C: 4BFFF8A5  bl 0x828c79c0
	ctx.lr = 0x828C8120;
	sub_828C79C0(ctx, base);
	// 828C8120: 48000010  b 0x828c8130
	pc = 0x828C8130; continue 'dispatch;
	// 828C8124: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C8128: 396B47F8  addi r11, r11, 0x47f8
	ctx.r[11].s64 = ctx.r[11].s64 + 18424;
	// 828C812C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C8130: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C8134: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C8138: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C813C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8140 size=72
    let mut pc: u32 = 0x828C8140;
    'dispatch: loop {
        match pc {
            0x828C8140 => {
    //   block [0x828C8140..0x828C8188)
	// 828C8140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C8148: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C814C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828C8150: 419A001C  beq cr6, 0x828c816c
	if ctx.cr[6].eq {
	pc = 0x828C816C; continue 'dispatch;
	}
	// 828C8154: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828C8158: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C815C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828C8160: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C8164: 4BFFF8D5  bl 0x828c7a38
	ctx.lr = 0x828C8168;
	sub_828C7A38(ctx, base);
	// 828C8168: 48000010  b 0x828c8178
	pc = 0x828C8178; continue 'dispatch;
	// 828C816C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C8170: 396B4848  addi r11, r11, 0x4848
	ctx.r[11].s64 = ctx.r[11].s64 + 18504;
	// 828C8174: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C8178: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C817C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C8180: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C8184: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C8188 size=228
    let mut pc: u32 = 0x828C8188;
    'dispatch: loop {
        match pc {
            0x828C8188 => {
    //   block [0x828C8188..0x828C826C)
	// 828C8188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C818C: 488DFFE1  bl 0x831a816c
	ctx.lr = 0x828C8190;
	sub_831A8130(ctx, base);
	// 828C8190: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8194: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C8198: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828C819C: 4BF23FC5  bl 0x827ec160
	ctx.lr = 0x828C81A0;
	sub_827EC160(ctx, base);
	// 828C81A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C81A4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C81A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C81AC: 4E800421  bctrl
	ctx.lr = 0x828C81B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C81B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C81B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C81B8: 481F9DD9  bl 0x82ac1f90
	ctx.lr = 0x828C81BC;
	sub_82AC1F90(ctx, base);
	// 828C81BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C81C0: 4BF23FA1  bl 0x827ec160
	ctx.lr = 0x828C81C4;
	sub_827EC160(ctx, base);
	// 828C81C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C81C8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828C81CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C81D0: 4E800421  bctrl
	ctx.lr = 0x828C81D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C81D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C81D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C81DC: 481E32FD  bl 0x82aab4d8
	ctx.lr = 0x828C81E0;
	sub_82AAB4D8(ctx, base);
	// 828C81E0: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828C81E4: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828C81E8: 3BCB0CF0  addi r30, r11, 0xcf0
	ctx.r[30].s64 = ctx.r[11].s64 + 3312;
	// 828C81EC: 816A0D30  lwz r11, 0xd30(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3376 as u32) ) } as u64;
	// 828C81F0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C81F4: 40820038  bne 0x828c822c
	if !ctx.cr[0].eq {
	pc = 0x828C822C; continue 'dispatch;
	}
	// 828C81F8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828C81FC: 3D008202  lis r8, -0x7dfe
	ctx.r[8].s64 = -2113798144;
	// 828C8200: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828C8204: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C8208: 916A0D30  stw r11, 0xd30(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(3376 as u32), ctx.r[11].u32 ) };
	// 828C820C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C8210: C00908A4  lfs f0, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C8214: C1A80590  lfs f13, 0x590(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(1424 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C8218: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828C821C: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828C8220: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828C8224: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828C8228: 485B3DB1  bl 0x82e7bfd8
	ctx.lr = 0x828C822C;
	sub_82E7BFD8(ctx, base);
	// 828C822C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C8230: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 828C8234: 4854B02D  bl 0x82e13260
	ctx.lr = 0x828C8238;
	sub_82E13260(ctx, base);
	// 828C8238: 807F03A0  lwz r3, 0x3a0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 828C823C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C8240: 419A000C  beq cr6, 0x828c824c
	if ctx.cr[6].eq {
	pc = 0x828C824C; continue 'dispatch;
	}
	// 828C8244: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C8248: 4805A731  bl 0x82922978
	ctx.lr = 0x828C824C;
	sub_82922978(ctx, base);
	// 828C824C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C8250: 387F03B0  addi r3, r31, 0x3b0
	ctx.r[3].s64 = ctx.r[31].s64 + 944;
	// 828C8254: 4BF24045  bl 0x827ec298
	ctx.lr = 0x828C8258;
	sub_827EC298(ctx, base);
	// 828C8258: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C825C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C8260: 48096EC1  bl 0x8295f120
	ctx.lr = 0x828C8264;
	sub_8295F120(ctx, base);
	// 828C8264: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C8268: 488DFF54  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C8270 size=120
    let mut pc: u32 = 0x828C8270;
    'dispatch: loop {
        match pc {
            0x828C8270 => {
    //   block [0x828C8270..0x828C82E8)
	// 828C8270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8274: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C8278: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C827C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8280: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828C8284: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 828C8288: 390B6880  addi r8, r11, 0x6880
	ctx.r[8].s64 = ctx.r[11].s64 + 26752;
	// 828C828C: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 828C8290: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 828C8294: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C8298: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828C829C: 13E94407  vcmpneb. (lvlx128) v31, v9, v8
	tmp.u32 = ctx.r[9].u32 + ctx.r[8].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828C82A0: 13CA4407  vcmpneb. (lvlx128) v30, v10, v8
	tmp.u32 = ctx.r[10].u32 + ctx.r[8].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828C82A4: 13AB4407  vcmpneb. (lvlx128) v29, v11, v8
	tmp.u32 = ctx.r[11].u32 + ctx.r[8].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828C82A8: 13804407  vcmpneb. (lvlx128) v28, v0, v8
	tmp.u32 = ctx.r[8].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C82E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C82E8 size=156
    let mut pc: u32 = 0x828C82E8;
    'dispatch: loop {
        match pc {
            0x828C82E8 => {
    //   block [0x828C82E8..0x828C8384)
	// 828C82E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C82EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C82F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C82F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C82F8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C82FC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828C8300: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 828C8304: 396B6880  addi r11, r11, 0x6880
	ctx.r[11].s64 = ctx.r[11].s64 + 26752;
	// 828C8308: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 828C830C: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 828C8310: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 828C8314: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828C8318: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 828C831C: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828C8320: 3BC10080  addi r30, r1, 0x80
	ctx.r[30].s64 = ctx.r[1].s64 + 128;
	// 828C8324: 13CA5C07  vcmpneb. (lvlx128) v30, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828C8328: 13A95C07  vcmpneb. (lvlx128) v29, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828C832C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C8330: 13885C07  vcmpneb. (lvlx128) v28, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828C8334: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C8388 size=124
    let mut pc: u32 = 0x828C8388;
    'dispatch: loop {
        match pc {
            0x828C8388 => {
    //   block [0x828C8388..0x828C8404)
	// 828C8388: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C838C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C8390: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C8394: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C8398: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C839C: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 828C83A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C83A4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828C83A8: 4BF23DB9  bl 0x827ec160
	ctx.lr = 0x828C83AC;
	sub_827EC160(ctx, base);
	// 828C83AC: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 828C83B0: 4182003C  beq 0x828c83ec
	if ctx.cr[0].eq {
	pc = 0x828C83EC; continue 'dispatch;
	}
	// 828C83B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C83B8: 4804E9E1  bl 0x82916d98
	ctx.lr = 0x828C83BC;
	sub_82916D98(ctx, base);
	// 828C83BC: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C83C0: 396000E0  li r11, 0xe0
	ctx.r[11].s64 = 224;
	// 828C83C4: 13E0F8C7  vcmpequd (lvx128) v31, v0, v31
	tmp.u32 = ctx.r[31].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828C83C8: 394000D0  li r10, 0xd0
	ctx.r[10].s64 = 208;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C8408 size=192
    let mut pc: u32 = 0x828C8408;
    'dispatch: loop {
        match pc {
            0x828C8408 => {
    //   block [0x828C8408..0x828C84C8)
	// 828C8408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C840C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C8410: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C8414: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8418: 81630398  lwz r11, 0x398(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(920 as u32) ) } as u64;
	// 828C841C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C8420: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C8424: 419A0090  beq cr6, 0x828c84b4
	if ctx.cr[6].eq {
	pc = 0x828C84B4; continue 'dispatch;
	}
	// 828C8428: 81630270  lwz r11, 0x270(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(624 as u32) ) } as u64;
	// 828C842C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 828C8430: 395F0020  addi r10, r31, 0x20
	ctx.r[10].s64 = ctx.r[31].s64 + 32;
	// 828C8434: 396B0060  addi r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 + 96;
	// 828C8438: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C843C: 911F0020  stw r8, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 828C8440: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8444: 911F0024  stw r8, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[8].u32 ) };
	// 828C8448: 13EB48C7  vcmpequd (lvx128) v31, v11, v9
	tmp.u32 = ctx.r[11].u32 + ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C84C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C84C8 size=84
    let mut pc: u32 = 0x828C84C8;
    'dispatch: loop {
        match pc {
            0x828C84C8 => {
    //   block [0x828C84C8..0x828C851C)
	// 828C84C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C84CC: 488DFCA1  bl 0x831a816c
	ctx.lr = 0x828C84D0;
	sub_831A8130(ctx, base);
	// 828C84D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C84D4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C84D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C84DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C84E0: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 828C84E4: 409A0008  bne cr6, 0x828c84ec
	if !ctx.cr[6].eq {
	pc = 0x828C84EC; continue 'dispatch;
	}
	// 828C84E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C84EC: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C84F0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828C84F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C84F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C84FC: 4BFFF975  bl 0x828c7e70
	ctx.lr = 0x828C8500;
	sub_828C7E70(ctx, base);
	// 828C8500: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C8504: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C8508: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C850C: 4B9F7AF5  bl 0x822c0000
	ctx.lr = 0x828C8510;
	sub_822C0000(ctx, base);
	// 828C8510: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C8514: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C8518: 488DFCA4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8520 size=72
    let mut pc: u32 = 0x828C8520;
    'dispatch: loop {
        match pc {
            0x828C8520 => {
    //   block [0x828C8520..0x828C8568)
	// 828C8520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C8528: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C852C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828C8530: 419A001C  beq cr6, 0x828c854c
	if ctx.cr[6].eq {
	pc = 0x828C854C; continue 'dispatch;
	}
	// 828C8534: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828C8538: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C853C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828C8540: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C8544: 4BFFF56D  bl 0x828c7ab0
	ctx.lr = 0x828C8548;
	sub_828C7AB0(ctx, base);
	// 828C8548: 48000010  b 0x828c8558
	pc = 0x828C8558; continue 'dispatch;
	// 828C854C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C8550: 396B4898  addi r11, r11, 0x4898
	ctx.r[11].s64 = ctx.r[11].s64 + 18584;
	// 828C8554: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C8558: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C855C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C8560: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C8564: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8568 size=72
    let mut pc: u32 = 0x828C8568;
    'dispatch: loop {
        match pc {
            0x828C8568 => {
    //   block [0x828C8568..0x828C85B0)
	// 828C8568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C856C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C8570: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8574: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828C8578: 419A001C  beq cr6, 0x828c8594
	if ctx.cr[6].eq {
	pc = 0x828C8594; continue 'dispatch;
	}
	// 828C857C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828C8580: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828C8584: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828C8588: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C858C: 4BFFF5AD  bl 0x828c7b38
	ctx.lr = 0x828C8590;
	sub_828C7B38(ctx, base);
	// 828C8590: 48000010  b 0x828c85a0
	pc = 0x828C85A0; continue 'dispatch;
	// 828C8594: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828C8598: 396B4960  addi r11, r11, 0x4960
	ctx.r[11].s64 = ctx.r[11].s64 + 18784;
	// 828C859C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C85A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828C85A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C85A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C85AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C85B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C85B0 size=216
    let mut pc: u32 = 0x828C85B0;
    'dispatch: loop {
        match pc {
            0x828C85B0 => {
    //   block [0x828C85B0..0x828C8688)
	// 828C85B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C85B4: 488DFBB9  bl 0x831a816c
	ctx.lr = 0x828C85B8;
	sub_831A8130(ctx, base);
	// 828C85B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C85BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C85C0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C85C4: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828C85C8: 396BDEE4  addi r11, r11, -0x211c
	ctx.r[11].s64 = ctx.r[11].s64 + -8476;
	// 828C85CC: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828C85D0: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828C85D4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C85D8: 394ADD3C  addi r10, r10, -0x22c4
	ctx.r[10].s64 = ctx.r[10].s64 + -8900;
	// 828C85DC: 3929DD28  addi r9, r9, -0x22d8
	ctx.r[9].s64 = ctx.r[9].s64 + -8920;
	// 828C85E0: 3968DD0C  addi r11, r8, -0x22f4
	ctx.r[11].s64 = ctx.r[8].s64 + -8948;
	// 828C85E4: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828C85E8: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828C85EC: 3BDF03C0  addi r30, r31, 0x3c0
	ctx.r[30].s64 = ctx.r[31].s64 + 960;
	// 828C85F0: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828C85F4: 3BBF0010  addi r29, r31, 0x10
	ctx.r[29].s64 = ctx.r[31].s64 + 16;
	// 828C85F8: 807F0424  lwz r3, 0x424(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1060 as u32) ) } as u64;
	// 828C85FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C8600: 419A0008  beq cr6, 0x828c8608
	if ctx.cr[6].eq {
	pc = 0x828C8608; continue 'dispatch;
	}
	// 828C8604: 4B9F828D  bl 0x822c0890
	ctx.lr = 0x828C8608;
	sub_822C0890(ctx, base);
	// 828C8608: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C860C: 4859523D  bl 0x82e5d848
	ctx.lr = 0x828C8610;
	sub_82E5D848(ctx, base);
	// 828C8610: 807F03BC  lwz r3, 0x3bc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(956 as u32) ) } as u64;
	// 828C8614: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C8618: 419A0008  beq cr6, 0x828c8620
	if ctx.cr[6].eq {
	pc = 0x828C8620; continue 'dispatch;
	}
	// 828C861C: 4B9F8275  bl 0x822c0890
	ctx.lr = 0x828C8620;
	sub_822C0890(ctx, base);
	// 828C8620: 807F03B4  lwz r3, 0x3b4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(948 as u32) ) } as u64;
	// 828C8624: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C8628: 419A0008  beq cr6, 0x828c8630
	if ctx.cr[6].eq {
	pc = 0x828C8630; continue 'dispatch;
	}
	// 828C862C: 4B9F8265  bl 0x822c0890
	ctx.lr = 0x828C8630;
	sub_822C0890(ctx, base);
	// 828C8630: 807F03AC  lwz r3, 0x3ac(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(940 as u32) ) } as u64;
	// 828C8634: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C8638: 419A0008  beq cr6, 0x828c8640
	if ctx.cr[6].eq {
	pc = 0x828C8640; continue 'dispatch;
	}
	// 828C863C: 4B9F8255  bl 0x822c0890
	ctx.lr = 0x828C8640;
	sub_822C0890(ctx, base);
	// 828C8640: 807F03A4  lwz r3, 0x3a4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(932 as u32) ) } as u64;
	// 828C8644: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C8648: 419A0008  beq cr6, 0x828c8650
	if ctx.cr[6].eq {
	pc = 0x828C8650; continue 'dispatch;
	}
	// 828C864C: 4B9F8245  bl 0x822c0890
	ctx.lr = 0x828C8650;
	sub_822C0890(ctx, base);
	// 828C8650: 807F039C  lwz r3, 0x39c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(924 as u32) ) } as u64;
	// 828C8654: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C8658: 419A0008  beq cr6, 0x828c8660
	if ctx.cr[6].eq {
	pc = 0x828C8660; continue 'dispatch;
	}
	// 828C865C: 4B9F8235  bl 0x822c0890
	ctx.lr = 0x828C8660;
	sub_822C0890(ctx, base);
	// 828C8660: 807F0394  lwz r3, 0x394(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) } as u64;
	// 828C8664: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C8668: 419A0008  beq cr6, 0x828c8670
	if ctx.cr[6].eq {
	pc = 0x828C8670; continue 'dispatch;
	}
	// 828C866C: 4B9F8225  bl 0x822c0890
	ctx.lr = 0x828C8670;
	sub_822C0890(ctx, base);
	// 828C8670: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C8674: 48096C25  bl 0x8295f298
	ctx.lr = 0x828C8678;
	sub_8295F298(ctx, base);
	// 828C8678: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C867C: 4BEDEFDD  bl 0x827a7658
	ctx.lr = 0x828C8680;
	sub_827A7658(ctx, base);
	// 828C8680: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C8684: 488DFB38  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C8688 size=8
    let mut pc: u32 = 0x828C8688;
    'dispatch: loop {
        match pc {
            0x828C8688 => {
    //   block [0x828C8688..0x828C8690)
	// 828C8688: 3863FFC8  addi r3, r3, -0x38
	ctx.r[3].s64 = ctx.r[3].s64 + -56;
	// 828C868C: 480007FC  b 0x828c8e88
	sub_828C8E88(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C8690 size=8
    let mut pc: u32 = 0x828C8690;
    'dispatch: loop {
        match pc {
            0x828C8690 => {
    //   block [0x828C8690..0x828C8698)
	// 828C8690: 3863FDE8  addi r3, r3, -0x218
	ctx.r[3].s64 = ctx.r[3].s64 + -536;
	// 828C8694: 480007F4  b 0x828c8e88
	sub_828C8E88(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828C8698 size=8
    let mut pc: u32 = 0x828C8698;
    'dispatch: loop {
        match pc {
            0x828C8698 => {
    //   block [0x828C8698..0x828C86A0)
	// 828C8698: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828C869C: 480007EC  b 0x828c8e88
	sub_828C8E88(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C86A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C86A0 size=184
    let mut pc: u32 = 0x828C86A0;
    'dispatch: loop {
        match pc {
            0x828C86A0 => {
    //   block [0x828C86A0..0x828C8758)
	// 828C86A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C86A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C86A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C86AC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C86B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C86B4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C86B8: 48005519  bl 0x828cdbd0
	ctx.lr = 0x828C86BC;
	sub_828CDBD0(ctx, base);
	// 828C86BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C86C0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828C86C4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C86C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C86CC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C86D0: 419A0024  beq cr6, 0x828c86f4
	if ctx.cr[6].eq {
	pc = 0x828C86F4; continue 'dispatch;
	}
	// 828C86D4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828C86D8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C86DC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C86E0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C86E4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C86E8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C86EC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C86F0: 4082FFE8  bne 0x828c86d8
	if !ctx.cr[0].eq {
	pc = 0x828C86D8; continue 'dispatch;
	}
	// 828C86F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C86F8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828C86FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C8700: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C8704: 389F03C0  addi r4, r31, 0x3c0
	ctx.r[4].s64 = ctx.r[31].s64 + 960;
	// 828C8708: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C870C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C8710: 48595F99  bl 0x82e5e6a8
	ctx.lr = 0x828C8714;
	sub_82E5E6A8(ctx, base);
	// 828C8714: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C8718: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C871C: 419A0008  beq cr6, 0x828c8724
	if ctx.cr[6].eq {
	pc = 0x828C8724; continue 'dispatch;
	}
	// 828C8720: 4B9F8171  bl 0x822c0890
	ctx.lr = 0x828C8724;
	sub_822C0890(ctx, base);
	// 828C8724: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C8728: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C872C: 419A0008  beq cr6, 0x828c8734
	if ctx.cr[6].eq {
	pc = 0x828C8734; continue 'dispatch;
	}
	// 828C8730: 4B9F8161  bl 0x822c0890
	ctx.lr = 0x828C8734;
	sub_822C0890(ctx, base);
	// 828C8734: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828C8738: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C873C: 419A0008  beq cr6, 0x828c8744
	if ctx.cr[6].eq {
	pc = 0x828C8744; continue 'dispatch;
	}
	// 828C8740: 4B9F8151  bl 0x822c0890
	ctx.lr = 0x828C8744;
	sub_822C0890(ctx, base);
	// 828C8744: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C8748: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C874C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C8750: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C8754: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C8758 size=140
    let mut pc: u32 = 0x828C8758;
    'dispatch: loop {
        match pc {
            0x828C8758 => {
    //   block [0x828C8758..0x828C87E4)
	// 828C8758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C875C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C8760: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C8764: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C8768: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828C876C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8770: 83C303AC  lwz r30, 0x3ac(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(940 as u32) ) } as u64;
	// 828C8774: 83E303A8  lwz r31, 0x3a8(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(936 as u32) ) } as u64;
	// 828C8778: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C877C: 419A0024  beq cr6, 0x828c87a0
	if ctx.cr[6].eq {
	pc = 0x828C87A0; continue 'dispatch;
	}
	// 828C8780: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 828C8784: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C8788: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C878C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C8790: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C8794: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C8798: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C879C: 4082FFE8  bne 0x828c8784
	if !ctx.cr[0].eq {
	pc = 0x828C8784; continue 'dispatch;
	}
	// 828C87A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C87A4: 419A0014  beq cr6, 0x828c87b8
	if ctx.cr[6].eq {
	pc = 0x828C87B8; continue 'dispatch;
	}
	// 828C87A8: C3FF0004  lfs f31, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828C87AC: D03F0004  stfs f1, 4(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828C87B0: 4BFFFEF1  bl 0x828c86a0
	ctx.lr = 0x828C87B4;
	sub_828C86A0(ctx, base);
	// 828C87B4: D3FF0004  stfs f31, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828C87B8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C87BC: 419A000C  beq cr6, 0x828c87c8
	if ctx.cr[6].eq {
	pc = 0x828C87C8; continue 'dispatch;
	}
	// 828C87C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C87C4: 4B9F80CD  bl 0x822c0890
	ctx.lr = 0x828C87C8;
	sub_822C0890(ctx, base);
	// 828C87C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C87CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C87D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C87D4: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828C87D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C87DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C87E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C87E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C87E8 size=548
    let mut pc: u32 = 0x828C87E8;
    'dispatch: loop {
        match pc {
            0x828C87E8 => {
    //   block [0x828C87E8..0x828C8A0C)
	// 828C87E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C87EC: 488DF979  bl 0x831a8164
	ctx.lr = 0x828C87F0;
	sub_831A8130(ctx, base);
	// 828C87F0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C87F4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C87F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C87FC: 3BABDF30  addi r29, r11, -0x20d0
	ctx.r[29].s64 = ctx.r[11].s64 + -8400;
	// 828C8800: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C8804: 38A002C1  li r5, 0x2c1
	ctx.r[5].s64 = 705;
	// 828C8808: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C880C: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828C8810: 4B9F7BC9  bl 0x822c03d8
	ctx.lr = 0x828C8814;
	sub_822C03D8(ctx, base);
	// 828C8814: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C8818: 4182001C  beq 0x828c8834
	if ctx.cr[0].eq {
	pc = 0x828C8834; continue 'dispatch;
	}
	// 828C881C: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828C8820: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C8824: 38AB0EB8  addi r5, r11, 0xeb8
	ctx.r[5].s64 = ctx.r[11].s64 + 3768;
	// 828C8828: 4807AB61  bl 0x82943388
	ctx.lr = 0x828C882C;
	sub_82943388(ctx, base);
	// 828C882C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C8830: 48000008  b 0x828c8838
	pc = 0x828C8838; continue 'dispatch;
	// 828C8834: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C8838: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828C883C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C8840: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C8844: 4BFA9675  bl 0x82871eb8
	ctx.lr = 0x828C8848;
	sub_82871EB8(ctx, base);
	// 828C8848: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C884C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C8850: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C8854: 4B9F77AD  bl 0x822c0000
	ctx.lr = 0x828C8858;
	sub_822C0000(ctx, base);
	// 828C8858: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C885C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C8860: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828C8864: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 828C8868: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828C886C: 419A0024  beq cr6, 0x828c8890
	if ctx.cr[6].eq {
	pc = 0x828C8890; continue 'dispatch;
	}
	// 828C8870: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 828C8874: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C8878: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C887C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C8880: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C8884: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C8888: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C888C: 4082FFE8  bne 0x828c8874
	if !ctx.cr[0].eq {
	pc = 0x828C8874; continue 'dispatch;
	}
	// 828C8890: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C8894: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C8898: 48077C19  bl 0x829404b0
	ctx.lr = 0x828C889C;
	sub_829404B0(ctx, base);
	// 828C889C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C88A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C88A4: 38A002C5  li r5, 0x2c5
	ctx.r[5].s64 = 709;
	// 828C88A8: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 828C88AC: 4B9F7B2D  bl 0x822c03d8
	ctx.lr = 0x828C88B0;
	sub_822C03D8(ctx, base);
	// 828C88B0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C88B4: 4182001C  beq 0x828c88d0
	if ctx.cr[0].eq {
	pc = 0x828C88D0; continue 'dispatch;
	}
	// 828C88B8: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828C88BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C88C0: 38AB0E9C  addi r5, r11, 0xe9c
	ctx.r[5].s64 = ctx.r[11].s64 + 3740;
	// 828C88C4: 48079645  bl 0x82941f08
	ctx.lr = 0x828C88C8;
	sub_82941F08(ctx, base);
	// 828C88C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C88CC: 48000008  b 0x828c88d4
	pc = 0x828C88D4; continue 'dispatch;
	// 828C88D0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C88D4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828C88D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C88DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C88E0: 4BFAA4C9  bl 0x82872da8
	ctx.lr = 0x828C88E4;
	sub_82872DA8(ctx, base);
	// 828C88E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C88E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C88EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C88F0: 4B9F7711  bl 0x822c0000
	ctx.lr = 0x828C88F4;
	sub_822C0000(ctx, base);
	// 828C88F4: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C88F8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C88FC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C8900: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828C8904: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828C8908: 419A0024  beq cr6, 0x828c892c
	if ctx.cr[6].eq {
	pc = 0x828C892C; continue 'dispatch;
	}
	// 828C890C: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828C8910: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C8914: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8918: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C891C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C8920: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C8924: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8928: 4082FFE8  bne 0x828c8910
	if !ctx.cr[0].eq {
	pc = 0x828C8910; continue 'dispatch;
	}
	// 828C892C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C8930: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C8934: 48077B7D  bl 0x829404b0
	ctx.lr = 0x828C8938;
	sub_829404B0(ctx, base);
	// 828C8938: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C893C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C8940: 38A002C9  li r5, 0x2c9
	ctx.r[5].s64 = 713;
	// 828C8944: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 828C8948: 4B9F7A91  bl 0x822c03d8
	ctx.lr = 0x828C894C;
	sub_822C03D8(ctx, base);
	// 828C894C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C8950: 4182001C  beq 0x828c896c
	if ctx.cr[0].eq {
	pc = 0x828C896C; continue 'dispatch;
	}
	// 828C8954: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828C8958: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C895C: 38AB0EC8  addi r5, r11, 0xec8
	ctx.r[5].s64 = ctx.r[11].s64 + 3784;
	// 828C8960: 48079FC1  bl 0x82942920
	ctx.lr = 0x828C8964;
	sub_82942920(ctx, base);
	// 828C8964: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C8968: 48000008  b 0x828c8970
	pc = 0x828C8970; continue 'dispatch;
	// 828C896C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C8970: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828C8974: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C8978: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C897C: 4BFA9605  bl 0x82871f80
	ctx.lr = 0x828C8980;
	sub_82871F80(ctx, base);
	// 828C8980: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C8984: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C8988: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C898C: 4B9F7675  bl 0x822c0000
	ctx.lr = 0x828C8990;
	sub_822C0000(ctx, base);
	// 828C8990: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C8994: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C8998: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C899C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828C89A0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828C89A4: 419A0024  beq cr6, 0x828c89c8
	if ctx.cr[6].eq {
	pc = 0x828C89C8; continue 'dispatch;
	}
	// 828C89A8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828C89AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C89B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C89B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C89B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C89BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C89C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C89C4: 4082FFE8  bne 0x828c89ac
	if !ctx.cr[0].eq {
	pc = 0x828C89AC; continue 'dispatch;
	}
	// 828C89C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C89CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C89D0: 48077AE1  bl 0x829404b0
	ctx.lr = 0x828C89D4;
	sub_829404B0(ctx, base);
	// 828C89D4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C89D8: 419A000C  beq cr6, 0x828c89e4
	if ctx.cr[6].eq {
	pc = 0x828C89E4; continue 'dispatch;
	}
	// 828C89DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C89E0: 4B9F7EB1  bl 0x822c0890
	ctx.lr = 0x828C89E4;
	sub_822C0890(ctx, base);
	// 828C89E4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C89E8: 419A000C  beq cr6, 0x828c89f4
	if ctx.cr[6].eq {
	pc = 0x828C89F4; continue 'dispatch;
	}
	// 828C89EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C89F0: 4B9F7EA1  bl 0x822c0890
	ctx.lr = 0x828C89F4;
	sub_822C0890(ctx, base);
	// 828C89F4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828C89F8: 419A000C  beq cr6, 0x828c8a04
	if ctx.cr[6].eq {
	pc = 0x828C8A04; continue 'dispatch;
	}
	// 828C89FC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C8A00: 4B9F7E91  bl 0x822c0890
	ctx.lr = 0x828C8A04;
	sub_822C0890(ctx, base);
	// 828C8A04: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828C8A08: 488DF7AC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C8A10 size=272
    let mut pc: u32 = 0x828C8A10;
    'dispatch: loop {
        match pc {
            0x828C8A10 => {
    //   block [0x828C8A10..0x828C8B20)
	// 828C8A10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8A14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C8A18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C8A1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C8A20: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8A24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C8A28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C8A2C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C8A30: 480798E1  bl 0x82942310
	ctx.lr = 0x828C8A34;
	sub_82942310(ctx, base);
	// 828C8A34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C8A38: 4BF23729  bl 0x827ec160
	ctx.lr = 0x828C8A3C;
	sub_827EC160(ctx, base);
	// 828C8A3C: 4BF26CFD  bl 0x827ef738
	ctx.lr = 0x828C8A40;
	sub_827EF738(ctx, base);
	// 828C8A40: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 828C8A44: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 828C8A48: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828C8A4C: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828C8A50: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C8A54: 13E358C7  vcmpequd (lvx128) v31, v3, v11
	tmp.u32 = ctx.r[3].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828C8A58: 3888DF30  addi r4, r8, -0x20d0
	ctx.r[4].s64 = ctx.r[8].s64 + -8400;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8B20 size=152
    let mut pc: u32 = 0x828C8B20;
    'dispatch: loop {
        match pc {
            0x828C8B20 => {
    //   block [0x828C8B20..0x828C8BB8)
	// 828C8B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8B24: 488DF649  bl 0x831a816c
	ctx.lr = 0x828C8B28;
	sub_831A8130(ctx, base);
	// 828C8B28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8B2C: 83E303B4  lwz r31, 0x3b4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(948 as u32) ) } as u64;
	// 828C8B30: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828C8B34: 83C303B0  lwz r30, 0x3b0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(944 as u32) ) } as u64;
	// 828C8B38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C8B3C: 419A0024  beq cr6, 0x828c8b60
	if ctx.cr[6].eq {
	pc = 0x828C8B60; continue 'dispatch;
	}
	// 828C8B40: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828C8B44: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C8B48: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8B4C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C8B50: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C8B54: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C8B58: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8B5C: 4082FFE8  bne 0x828c8b44
	if !ctx.cr[0].eq {
	pc = 0x828C8B44; continue 'dispatch;
	}
	// 828C8B60: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828C8B64: 419A0038  beq cr6, 0x828c8b9c
	if ctx.cr[6].eq {
	pc = 0x828C8B9C; continue 'dispatch;
	}
	// 828C8B68: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 828C8B6C: 4BF24295  bl 0x827ece00
	ctx.lr = 0x828C8B70;
	sub_827ECE00(ctx, base);
	// 828C8B70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C8B74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C8B78: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828C8B7C: 48059515  bl 0x82922090
	ctx.lr = 0x828C8B80;
	sub_82922090(ctx, base);
	// 828C8B80: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C8B84: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C8B88: 419A000C  beq cr6, 0x828c8b94
	if ctx.cr[6].eq {
	pc = 0x828C8B94; continue 'dispatch;
	}
	// 828C8B8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C8B90: 4B9F7D01  bl 0x822c0890
	ctx.lr = 0x828C8B94;
	sub_822C0890(ctx, base);
	// 828C8B94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C8B98: 48000018  b 0x828c8bb0
	pc = 0x828C8BB0; continue 'dispatch;
	// 828C8B9C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C8BA0: 419A000C  beq cr6, 0x828c8bac
	if ctx.cr[6].eq {
	pc = 0x828C8BAC; continue 'dispatch;
	}
	// 828C8BA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C8BA8: 4B9F7CE9  bl 0x822c0890
	ctx.lr = 0x828C8BAC;
	sub_822C0890(ctx, base);
	// 828C8BAC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C8BB0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C8BB4: 488DF608  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8BB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C8BB8 size=344
    let mut pc: u32 = 0x828C8BB8;
    'dispatch: loop {
        match pc {
            0x828C8BB8 => {
    //   block [0x828C8BB8..0x828C8D10)
	// 828C8BB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8BBC: 488DF5A9  bl 0x831a8164
	ctx.lr = 0x828C8BC0;
	sub_831A8130(ctx, base);
	// 828C8BC0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8BC4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C8BC8: 3BBB0010  addi r29, r27, 0x10
	ctx.r[29].s64 = ctx.r[27].s64 + 16;
	// 828C8BCC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C8BD0: 4BF23889  bl 0x827ec458
	ctx.lr = 0x828C8BD4;
	sub_827EC458(ctx, base);
	// 828C8BD4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828C8BD8: 41820130  beq 0x828c8d08
	if ctx.cr[0].eq {
	pc = 0x828C8D08; continue 'dispatch;
	}
	// 828C8BDC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828C8BE0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8BE4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C8BE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C8BEC: 83CB0B98  lwz r30, 0xb98(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2968 as u32) ) } as u64;
	// 828C8BF0: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 828C8BF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C8BF8: 4E800421  bctrl
	ctx.lr = 0x828C8BFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C8BFC: 4852A5B5  bl 0x82df31b0
	ctx.lr = 0x828C8C00;
	sub_82DF31B0(ctx, base);
	// 828C8C00: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8C04: 895E0000  lbz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8C08: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828C8C0C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828C8C10: 41820014  beq 0x828c8c24
	if ctx.cr[0].eq {
	pc = 0x828C8C24; continue 'dispatch;
	}
	// 828C8C14: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 828C8C18: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828C8C1C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C8C20: 419AFFE0  beq cr6, 0x828c8c00
	if ctx.cr[6].eq {
	pc = 0x828C8C00; continue 'dispatch;
	}
	// 828C8C24: 3FC0832D  lis r30, -0x7cd3
	ctx.r[30].s64 = -2094202880;
	// 828C8C28: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828C8C2C: 4182004C  beq 0x828c8c78
	if ctx.cr[0].eq {
	pc = 0x828C8C78; continue 'dispatch;
	}
	// 828C8C30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8C34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C8C38: 83FE0B70  lwz r31, 0xb70(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(2928 as u32) ) } as u64;
	// 828C8C3C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828C8C40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828C8C44: 4E800421  bctrl
	ctx.lr = 0x828C8C48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828C8C48: 4852A569  bl 0x82df31b0
	ctx.lr = 0x828C8C4C;
	sub_82DF31B0(ctx, base);
	// 828C8C4C: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8C50: 895F0000  lbz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8C54: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828C8C58: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828C8C5C: 41820014  beq 0x828c8c70
	if ctx.cr[0].eq {
	pc = 0x828C8C70; continue 'dispatch;
	}
	// 828C8C60: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 828C8C64: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828C8C68: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C8C6C: 419AFFE0  beq cr6, 0x828c8c4c
	if ctx.cr[6].eq {
	pc = 0x828C8C4C; continue 'dispatch;
	}
	// 828C8C70: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828C8C74: 40820008  bne 0x828c8c7c
	if !ctx.cr[0].eq {
	pc = 0x828C8C7C; continue 'dispatch;
	}
	// 828C8C78: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 828C8C7C: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C8C80: 41820088  beq 0x828c8d08
	if ctx.cr[0].eq {
	pc = 0x828C8D08; continue 'dispatch;
	}
	// 828C8C84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C8C88: 4BF234D9  bl 0x827ec160
	ctx.lr = 0x828C8C8C;
	sub_827EC160(ctx, base);
	// 828C8C8C: 4BF26AA5  bl 0x827ef730
	ctx.lr = 0x828C8C90;
	sub_827EF730(ctx, base);
	// 828C8C90: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828C8C94: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 828C8C98: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 828C8C9C: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 828C8CA0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C8CA4: C00B6150  lfs f0, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C8CA8: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 828C8CAC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828C8CB0: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8D10 size=112
    let mut pc: u32 = 0x828C8D10;
    'dispatch: loop {
        match pc {
            0x828C8D10 => {
    //   block [0x828C8D10..0x828C8D80)
	// 828C8D10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8D14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C8D18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C8D1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C8D20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8D24: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C8D28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C8D2C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828C8D30: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C8D34: 4BFFF2B5  bl 0x828c7fe8
	ctx.lr = 0x828C8D38;
	sub_828C7FE8(ctx, base);
	// 828C8D38: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C8D3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C8D40: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C8D44: 4B9F72BD  bl 0x822c0000
	ctx.lr = 0x828C8D48;
	sub_822C0000(ctx, base);
	// 828C8D48: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C8D4C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C8D50: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C8D54: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C8D58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C8D5C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828C8D60: 419A0008  beq cr6, 0x828c8d68
	if ctx.cr[6].eq {
	pc = 0x828C8D68; continue 'dispatch;
	}
	// 828C8D64: 4B9F7B2D  bl 0x822c0890
	ctx.lr = 0x828C8D68;
	sub_822C0890(ctx, base);
	// 828C8D68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C8D6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C8D70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C8D74: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C8D78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C8D7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8D80 size=260
    let mut pc: u32 = 0x828C8D80;
    'dispatch: loop {
        match pc {
            0x828C8D80 => {
    //   block [0x828C8D80..0x828C8E84)
	// 828C8D80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8D84: 488DF3E5  bl 0x831a8168
	ctx.lr = 0x828C8D88;
	sub_831A8130(ctx, base);
	// 828C8D88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8D8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C8D90: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828C8D94: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828C8D98: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 828C8D9C: 38C0001D  li r6, 0x1d
	ctx.r[6].s64 = 29;
	// 828C8DA0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C8DA4: 48096575  bl 0x8295f318
	ctx.lr = 0x828C8DA8;
	sub_8295F318(ctx, base);
	// 828C8DA8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C8DAC: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828C8DB0: 396BDEE4  addi r11, r11, -0x211c
	ctx.r[11].s64 = ctx.r[11].s64 + -8476;
	// 828C8DB4: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828C8DB8: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828C8DBC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828C8DC0: 3968DD0C  addi r11, r8, -0x22f4
	ctx.r[11].s64 = ctx.r[8].s64 + -8948;
	// 828C8DC4: 394ADD3C  addi r10, r10, -0x22c4
	ctx.r[10].s64 = ctx.r[10].s64 + -8900;
	// 828C8DC8: 3929DD28  addi r9, r9, -0x22d8
	ctx.r[9].s64 = ctx.r[9].s64 + -8920;
	// 828C8DCC: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828C8DD0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828C8DD4: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828C8DD8: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828C8DDC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C8DE0: 93DF0390  stw r30, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[30].u32 ) };
	// 828C8DE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C8DE8: 93DF0394  stw r30, 0x394(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), ctx.r[30].u32 ) };
	// 828C8DEC: 388BDF30  addi r4, r11, -0x20d0
	ctx.r[4].s64 = ctx.r[11].s64 + -8400;
	// 828C8DF0: 93DF0398  stw r30, 0x398(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), ctx.r[30].u32 ) };
	// 828C8DF4: 38A000C5  li r5, 0xc5
	ctx.r[5].s64 = 197;
	// 828C8DF8: 93DF039C  stw r30, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[30].u32 ) };
	// 828C8DFC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828C8E00: 93DF03A0  stw r30, 0x3a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(928 as u32), ctx.r[30].u32 ) };
	// 828C8E04: 93DF03A4  stw r30, 0x3a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(932 as u32), ctx.r[30].u32 ) };
	// 828C8E08: 4B9F75D1  bl 0x822c03d8
	ctx.lr = 0x828C8E0C;
	sub_822C03D8(ctx, base);
	// 828C8E0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C8E10: 41820010  beq 0x828c8e20
	if ctx.cr[0].eq {
	pc = 0x828C8E20; continue 'dispatch;
	}
	// 828C8E14: 4800245D  bl 0x828cb270
	ctx.lr = 0x828C8E18;
	sub_828CB270(ctx, base);
	// 828C8E18: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C8E1C: 48000008  b 0x828c8e24
	pc = 0x828C8E24; continue 'dispatch;
	// 828C8E20: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 828C8E24: 93BF03A8  stw r29, 0x3a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(936 as u32), ctx.r[29].u32 ) };
	// 828C8E28: 397F03A8  addi r11, r31, 0x3a8
	ctx.r[11].s64 = ctx.r[31].s64 + 936;
	// 828C8E2C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C8E30: 3B8B0004  addi r28, r11, 4
	ctx.r[28].s64 = ctx.r[11].s64 + 4;
	// 828C8E34: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C8E38: 4BFFF101  bl 0x828c7f38
	ctx.lr = 0x828C8E3C;
	sub_828C7F38(ctx, base);
	// 828C8E3C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828C8E40: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C8E44: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C8E48: 4B9F71B9  bl 0x822c0000
	ctx.lr = 0x828C8E4C;
	sub_822C0000(ctx, base);
	// 828C8E4C: 93DF03B0  stw r30, 0x3b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(944 as u32), ctx.r[30].u32 ) };
	// 828C8E50: 93DF03B4  stw r30, 0x3b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(948 as u32), ctx.r[30].u32 ) };
	// 828C8E54: 387F03C0  addi r3, r31, 0x3c0
	ctx.r[3].s64 = ctx.r[31].s64 + 960;
	// 828C8E58: 93DF03B8  stw r30, 0x3b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(952 as u32), ctx.r[30].u32 ) };
	// 828C8E5C: 93DF03BC  stw r30, 0x3bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(956 as u32), ctx.r[30].u32 ) };
	// 828C8E60: 48594A71  bl 0x82e5d8d0
	ctx.lr = 0x828C8E64;
	sub_82E5D8D0(ctx, base);
	// 828C8E64: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 828C8E68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C8E6C: 396B5DA0  addi r11, r11, 0x5da0
	ctx.r[11].s64 = ctx.r[11].s64 + 23968;
	// 828C8E70: 917F03C0  stw r11, 0x3c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(960 as u32), ctx.r[11].u32 ) };
	// 828C8E74: 93DF0420  stw r30, 0x420(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1056 as u32), ctx.r[30].u32 ) };
	// 828C8E78: 93DF0424  stw r30, 0x424(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1060 as u32), ctx.r[30].u32 ) };
	// 828C8E7C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C8E80: 488DF338  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C8E88 size=76
    let mut pc: u32 = 0x828C8E88;
    'dispatch: loop {
        match pc {
            0x828C8E88 => {
    //   block [0x828C8E88..0x828C8ED4)
	// 828C8E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8E8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C8E90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C8E94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C8E98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8E9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C8EA0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C8EA4: 4BFFF70D  bl 0x828c85b0
	ctx.lr = 0x828C8EA8;
	sub_828C85B0(ctx, base);
	// 828C8EA8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C8EAC: 4182000C  beq 0x828c8eb8
	if ctx.cr[0].eq {
	pc = 0x828C8EB8; continue 'dispatch;
	}
	// 828C8EB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C8EB4: 48529525  bl 0x82df23d8
	ctx.lr = 0x828C8EB8;
	sub_82DF23D8(ctx, base);
	// 828C8EB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C8EBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C8EC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C8EC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C8EC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C8ECC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C8ED0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C8ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C8ED8 size=636
    let mut pc: u32 = 0x828C8ED8;
    'dispatch: loop {
        match pc {
            0x828C8ED8 => {
    //   block [0x828C8ED8..0x828C9154)
	// 828C8ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C8EDC: 488DF281  bl 0x831a815c
	ctx.lr = 0x828C8EE0;
	sub_831A8130(ctx, base);
	// 828C8EE0: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 828C8EE4: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 828C8EE8: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C8EEC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828C8EF0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C8EF4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828C8EF8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C8EFC: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 828C8F00: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C8F04: 388BDF30  addi r4, r11, -0x20d0
	ctx.r[4].s64 = ctx.r[11].s64 + -8400;
	// 828C8F08: 38A001D8  li r5, 0x1d8
	ctx.r[5].s64 = 472;
	// 828C8F0C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C8F10: 4B9F74C9  bl 0x822c03d8
	ctx.lr = 0x828C8F14;
	sub_822C03D8(ctx, base);
	// 828C8F14: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828C8F18: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828C8F1C: 3B4B4A98  addi r26, r11, 0x4a98
	ctx.r[26].s64 = ctx.r[11].s64 + 19096;
	// 828C8F20: 41820030  beq 0x828c8f50
	if ctx.cr[0].eq {
	pc = 0x828C8F50; continue 'dispatch;
	}
	// 828C8F24: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828C8F28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C8F2C: 4852AADD  bl 0x82df3a08
	ctx.lr = 0x828C8F30;
	sub_82DF3A08(ctx, base);
	// 828C8F30: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C8F34: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C8F38: 80BC03A8  lwz r5, 0x3a8(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(936 as u32) ) } as u64;
	// 828C8F3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C8F40: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 828C8F44: 4BCE34CD  bl 0x825ac410
	ctx.lr = 0x828C8F48;
	sub_825AC410(ctx, base);
	// 828C8F48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C8F4C: 48000008  b 0x828c8f54
	pc = 0x828C8F54; continue 'dispatch;
	// 828C8F50: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C8F54: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828C8F58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C8F5C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828C8F60: 4BC2A459  bl 0x824f33b8
	ctx.lr = 0x828C8F64;
	sub_824F33B8(ctx, base);
	// 828C8F64: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C8F68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C8F6C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828C8F70: 4B9F7091  bl 0x822c0000
	ctx.lr = 0x828C8F74;
	sub_822C0000(ctx, base);
	// 828C8F74: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C8F78: 4182000C  beq 0x828c8f84
	if ctx.cr[0].eq {
	pc = 0x828C8F84; continue 'dispatch;
	}
	// 828C8F7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C8F80: 4852A4A9  bl 0x82df3428
	ctx.lr = 0x828C8F84;
	sub_82DF3428(ctx, base);
	// 828C8F84: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C8F88: 83610058  lwz r27, 0x58(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828C8F8C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828C8F90: 3BABDC98  addi r29, r11, -0x2368
	ctx.r[29].s64 = ctx.r[11].s64 + -9064;
	// 828C8F94: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 828C8F98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C8F9C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C8FA0: 4852AA69  bl 0x82df3a08
	ctx.lr = 0x828C8FA4;
	sub_82DF3A08(ctx, base);
	// 828C8FA4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C8FA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C8FAC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C8FB0: 4BCE2E11  bl 0x825abdc0
	ctx.lr = 0x828C8FB4;
	sub_825ABDC0(ctx, base);
	// 828C8FB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C8FB8: 4852A471  bl 0x82df3428
	ctx.lr = 0x828C8FBC;
	sub_82DF3428(ctx, base);
	// 828C8FBC: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 828C8FC0: 397D0008  addi r11, r29, 8
	ctx.r[11].s64 = ctx.r[29].s64 + 8;
	// 828C8FC4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828C8FC8: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828C8FCC: 4198FFCC  blt cr6, 0x828c8f98
	if ctx.cr[6].lt {
	pc = 0x828C8F98; continue 'dispatch;
	}
	// 828C8FD0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828C8FD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C8FD8: 4852AA31  bl 0x82df3a08
	ctx.lr = 0x828C8FDC;
	sub_82DF3A08(ctx, base);
	// 828C8FDC: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C8FE0: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 828C8FE4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C8FE8: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828C8FEC: 419A0024  beq cr6, 0x828c9010
	if ctx.cr[6].eq {
	pc = 0x828C9010; continue 'dispatch;
	}
	// 828C8FF0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828C8FF4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C8FF8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C8FFC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C9000: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C9004: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C9008: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C900C: 4082FFE8  bne 0x828c8ff4
	if !ctx.cr[0].eq {
	pc = 0x828C8FF4; continue 'dispatch;
	}
	// 828C9010: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828C9014: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C9018: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828C901C: 4BCD90F5  bl 0x825a2110
	ctx.lr = 0x828C9020;
	sub_825A2110(ctx, base);
	// 828C9020: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C9024: 4852A405  bl 0x82df3428
	ctx.lr = 0x828C9028;
	sub_82DF3428(ctx, base);
	// 828C9028: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828C902C: 419A000C  beq cr6, 0x828c9038
	if ctx.cr[6].eq {
	pc = 0x828C9038; continue 'dispatch;
	}
	// 828C9030: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C9034: 4B9F785D  bl 0x822c0890
	ctx.lr = 0x828C9038;
	sub_822C0890(ctx, base);
	// 828C9038: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 828C903C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C9040: 388BEDA0  addi r4, r11, -0x1260
	ctx.r[4].s64 = ctx.r[11].s64 + -4704;
	// 828C9044: 4852A9C5  bl 0x82df3a08
	ctx.lr = 0x828C9048;
	sub_82DF3A08(ctx, base);
	// 828C9048: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828C904C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828C9050: 817C03A8  lwz r11, 0x3a8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(936 as u32) ) } as u64;
	// 828C9054: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828C9058: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 828C905C: C3EA964C  lfs f31, -0x69b4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828C9060: C3C908AC  lfs f30, 0x8ac(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2220 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828C9064: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828C9068: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828C906C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828C9070: 4BCDA141  bl 0x825a31b0
	ctx.lr = 0x828C9074;
	sub_825A31B0(ctx, base);
	// 828C9074: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828C9078: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C907C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828C9080: 4BCD86F1  bl 0x825a1770
	ctx.lr = 0x828C9084;
	sub_825A1770(ctx, base);
	// 828C9084: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 828C9088: 4852A3A1  bl 0x82df3428
	ctx.lr = 0x828C908C;
	sub_82DF3428(ctx, base);
	// 828C908C: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828C9090: 4B9FFC29  bl 0x822c8cb8
	ctx.lr = 0x828C9094;
	sub_822C8CB8(ctx, base);
	// 828C9094: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C9098: 4852A391  bl 0x82df3428
	ctx.lr = 0x828C909C;
	sub_82DF3428(ctx, base);
	// 828C909C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 828C90A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C90A4: 388BED88  addi r4, r11, -0x1278
	ctx.r[4].s64 = ctx.r[11].s64 + -4728;
	// 828C90A8: 4852A961  bl 0x82df3a08
	ctx.lr = 0x828C90AC;
	sub_82DF3A08(ctx, base);
	// 828C90AC: 817C03A8  lwz r11, 0x3a8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(936 as u32) ) } as u64;
	// 828C90B0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828C90B4: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828C90B8: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 828C90BC: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828C90C0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828C90C4: 4BCDA0ED  bl 0x825a31b0
	ctx.lr = 0x828C90C8;
	sub_825A31B0(ctx, base);
	// 828C90C8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828C90CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C90D0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828C90D4: 4BCD869D  bl 0x825a1770
	ctx.lr = 0x828C90D8;
	sub_825A1770(ctx, base);
	// 828C90D8: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 828C90DC: 4852A34D  bl 0x82df3428
	ctx.lr = 0x828C90E0;
	sub_82DF3428(ctx, base);
	// 828C90E0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828C90E4: 4B9FFBD5  bl 0x822c8cb8
	ctx.lr = 0x828C90E8;
	sub_822C8CB8(ctx, base);
	// 828C90E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C90EC: 4852A33D  bl 0x82df3428
	ctx.lr = 0x828C90F0;
	sub_82DF3428(ctx, base);
	// 828C90F0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 828C90F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C90F8: 388BED64  addi r4, r11, -0x129c
	ctx.r[4].s64 = ctx.r[11].s64 + -4764;
	// 828C90FC: 4852A90D  bl 0x82df3a08
	ctx.lr = 0x828C9100;
	sub_82DF3A08(ctx, base);
	// 828C9100: 817C03A8  lwz r11, 0x3a8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(936 as u32) ) } as u64;
	// 828C9104: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828C9108: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828C910C: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 828C9110: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828C9114: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828C9118: 4BCDA099  bl 0x825a31b0
	ctx.lr = 0x828C911C;
	sub_825A31B0(ctx, base);
	// 828C911C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828C9120: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C9124: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828C9128: 4BCD8649  bl 0x825a1770
	ctx.lr = 0x828C912C;
	sub_825A1770(ctx, base);
	// 828C912C: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 828C9130: 4852A2F9  bl 0x82df3428
	ctx.lr = 0x828C9134;
	sub_82DF3428(ctx, base);
	// 828C9134: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 828C9138: 4B9FFB81  bl 0x822c8cb8
	ctx.lr = 0x828C913C;
	sub_822C8CB8(ctx, base);
	// 828C913C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C9140: 4852A2E9  bl 0x82df3428
	ctx.lr = 0x828C9144;
	sub_82DF3428(ctx, base);
	// 828C9144: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 828C9148: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 828C914C: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 828C9150: 488DF05C  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C9158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C9158 size=452
    let mut pc: u32 = 0x828C9158;
    'dispatch: loop {
        match pc {
            0x828C9158 => {
    //   block [0x828C9158..0x828C931C)
	// 828C9158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C915C: 488DF005  bl 0x831a8160
	ctx.lr = 0x828C9160;
	sub_831A8130(ctx, base);
	// 828C9160: DBA1FFB0  stfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[29].u64 ) };
	// 828C9164: DBC1FFB8  stfd f30, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 828C9168: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 828C916C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C9170: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C9174: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828C9178: 3BDF0398  addi r30, r31, 0x398
	ctx.r[30].s64 = ctx.r[31].s64 + 920;
	// 828C917C: 817F0398  lwz r11, 0x398(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(920 as u32) ) } as u64;
	// 828C9180: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C9184: 419A00D0  beq cr6, 0x828c9254
	if ctx.cr[6].eq {
	pc = 0x828C9254; continue 'dispatch;
	}
	// 828C9188: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C918C: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 828C9190: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828C9194: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 828C9198: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C919C: 485D7595  bl 0x82ea0730
	ctx.lr = 0x828C91A0;
	sub_82EA0730(ctx, base);
	// 828C91A0: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 828C91A4: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828C91A8: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 828C91AC: C02ADCB8  lfs f1, -0x2348(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-9032 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C91B0: 48651041  bl 0x82f1a1f0
	ctx.lr = 0x828C91B4;
	sub_82F1A1F0(ctx, base);
	// 828C91B4: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828C91B8: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828C91BC: 396B0D78  addi r11, r11, 0xd78
	ctx.r[11].s64 = ctx.r[11].s64 + 3448;
	// 828C91C0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C91C4: 388ADF30  addi r4, r10, -0x20d0
	ctx.r[4].s64 = ctx.r[10].s64 + -8400;
	// 828C91C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C91CC: 38A0020F  li r5, 0x20f
	ctx.r[5].s64 = 527;
	// 828C91D0: 3860011C  li r3, 0x11c
	ctx.r[3].s64 = 284;
	// 828C91D4: C3EB009C  lfs f31, 0x9c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828C91D8: C3CB00A0  lfs f30, 0xa0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828C91DC: C3AB00A4  lfs f29, 0xa4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(164 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828C91E0: 48529209  bl 0x82df23e8
	ctx.lr = 0x828C91E4;
	sub_82DF23E8(ctx, base);
	// 828C91E4: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828C91E8: 41820050  beq 0x828c9238
	if ctx.cr[0].eq {
	pc = 0x828C9238; continue 'dispatch;
	}
	// 828C91EC: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828C91F0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828C91F4: 419A000C  beq cr6, 0x828c9200
	if ctx.cr[6].eq {
	pc = 0x828C9200; continue 'dispatch;
	}
	// 828C91F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C91FC: 4BA1F04D  bl 0x822e8248
	ctx.lr = 0x828C9200;
	sub_822E8248(ctx, base);
	// 828C9200: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 828C9204: 3B410050  addi r26, r1, 0x50
	ctx.r[26].s64 = ctx.r[1].s64 + 80;
	// 828C9208: 4873FDB1  bl 0x83008fb8
	ctx.lr = 0x828C920C;
	sub_83008FB8(ctx, base);
	// 828C920C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C9210: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C9214: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828C9218: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828C921C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828C9220: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 828C9224: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 828C9228: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 828C922C: 4BF0182D  bl 0x827caa58
	ctx.lr = 0x828C9230;
	sub_827CAA58(ctx, base);
	// 828C9230: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C9234: 48000008  b 0x828c923c
	pc = 0x828C923C; continue 'dispatch;
	// 828C9238: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828C923C: 387F03B8  addi r3, r31, 0x3b8
	ctx.r[3].s64 = ctx.r[31].s64 + 952;
	// 828C9240: 4BF3F231  bl 0x82808470
	ctx.lr = 0x828C9244;
	sub_82808470(ctx, base);
	// 828C9244: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828C9248: 419A000C  beq cr6, 0x828c9254
	if ctx.cr[6].eq {
	pc = 0x828C9254; continue 'dispatch;
	}
	// 828C924C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C9250: 4BA1F019  bl 0x822e8268
	ctx.lr = 0x828C9254;
	sub_822E8268(ctx, base);
	// 828C9254: 817F03B8  lwz r11, 0x3b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(952 as u32) ) } as u64;
	// 828C9258: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C925C: 419A00AC  beq cr6, 0x828c9308
	if ctx.cr[6].eq {
	pc = 0x828C9308; continue 'dispatch;
	}
	// 828C9260: 817F03BC  lwz r11, 0x3bc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(956 as u32) ) } as u64;
	// 828C9264: 3BBF0010  addi r29, r31, 0x10
	ctx.r[29].s64 = ctx.r[31].s64 + 16;
	// 828C9268: 815F03B8  lwz r10, 0x3b8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(952 as u32) ) } as u64;
	// 828C926C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C9270: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828C9274: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828C9278: 419A0024  beq cr6, 0x828c929c
	if ctx.cr[6].eq {
	pc = 0x828C929C; continue 'dispatch;
	}
	// 828C927C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828C9280: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C9284: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C9288: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C928C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C9290: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C9294: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C9298: 4082FFE8  bne 0x828c9280
	if !ctx.cr[0].eq {
	pc = 0x828C9280; continue 'dispatch;
	}
	// 828C929C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C92A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C92A4: 4BC46225  bl 0x8250f4c8
	ctx.lr = 0x828C92A8;
	sub_8250F4C8(ctx, base);
	// 828C92A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C92AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C92B0: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 828C92B4: 409A0008  bne cr6, 0x828c92bc
	if !ctx.cr[6].eq {
	pc = 0x828C92BC; continue 'dispatch;
	}
	// 828C92B8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828C92BC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C92C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C92C4: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 828C92C8: 4BC46251  bl 0x8250f518
	ctx.lr = 0x828C92CC;
	sub_8250F518(ctx, base);
	// 828C92CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C92D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C92D4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828C92D8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828C92DC: 4BC4422D  bl 0x8250d508
	ctx.lr = 0x828C92E0;
	sub_8250D508(ctx, base);
	// 828C92E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C92E4: 485289AD  bl 0x82df1c90
	ctx.lr = 0x828C92E8;
	sub_82DF1C90(ctx, base);
	// 828C92E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C92EC: 485289A5  bl 0x82df1c90
	ctx.lr = 0x828C92F0;
	sub_82DF1C90(ctx, base);
	// 828C92F0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828C92F4: 807F03B8  lwz r3, 0x3b8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(952 as u32) ) } as u64;
	// 828C92F8: C02B89AC  lfs f1, -0x7654(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C92FC: 4BF00C7D  bl 0x827c9f78
	ctx.lr = 0x828C9300;
	sub_827C9F78(ctx, base);
	// 828C9300: 807F03B8  lwz r3, 0x3b8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(952 as u32) ) } as u64;
	// 828C9304: 4BF01535  bl 0x827ca838
	ctx.lr = 0x828C9308;
	sub_827CA838(ctx, base);
	// 828C9308: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828C930C: CBA1FFB0  lfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 828C9310: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 828C9314: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 828C9318: 488DEE98  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C9320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C9320 size=376
    let mut pc: u32 = 0x828C9320;
    'dispatch: loop {
        match pc {
            0x828C9320 => {
    //   block [0x828C9320..0x828C9498)
	// 828C9320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C9324: 488DEE29  bl 0x831a814c
	ctx.lr = 0x828C9328;
	sub_831A8130(ctx, base);
	// 828C9328: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C932C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828C9330: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C9334: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828C9338: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C933C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828C9340: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C9344: 409A014C  bne cr6, 0x828c9490
	if !ctx.cr[6].eq {
	pc = 0x828C9490; continue 'dispatch;
	}
	// 828C9348: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C934C: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 828C9350: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828C9354: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 828C9358: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828C935C: 485D73D5  bl 0x82ea0730
	ctx.lr = 0x828C9360;
	sub_82EA0730(ctx, base);
	// 828C9360: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 828C9364: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828C9368: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 828C936C: C02AC664  lfs f1, -0x399c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-14748 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C9370: 48650E81  bl 0x82f1a1f0
	ctx.lr = 0x828C9374;
	sub_82F1A1F0(ctx, base);
	// 828C9374: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828C9378: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828C937C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828C9380: 3D008335  lis r8, -0x7ccb
	ctx.r[8].s64 = -2093678592;
	// 828C9384: 3CE08209  lis r7, -0x7df7
	ctx.r[7].s64 = -2113339392;
	// 828C9388: C1ABF614  lfs f13, -0x9ec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2540 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C938C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828C9390: C18A9524  lfs f12, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828C9394: 3887DF30  addi r4, r7, -0x20d0
	ctx.r[4].s64 = ctx.r[7].s64 + -8400;
	// 828C9398: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C939C: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 828C93A0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828C93A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C93A8: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828C93AC: 38A002E9  li r5, 0x2e9
	ctx.r[5].s64 = 745;
	// 828C93B0: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828C93B4: 38600200  li r3, 0x200
	ctx.r[3].s64 = 512;
	// 828C93B8: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828C93BC: 83686810  lwz r27, 0x6810(r8)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(26640 as u32) ) } as u64;
	// 828C93C0: 48529029  bl 0x82df23e8
	ctx.lr = 0x828C93C4;
	sub_82DF23E8(ctx, base);
	// 828C93C4: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828C93C8: 4182007C  beq 0x828c9444
	if ctx.cr[0].eq {
	pc = 0x828C9444; continue 'dispatch;
	}
	// 828C93CC: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 828C93D0: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 828C93D4: 419A000C  beq cr6, 0x828c93e0
	if ctx.cr[6].eq {
	pc = 0x828C93E0; continue 'dispatch;
	}
	// 828C93D8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828C93DC: 4BA1EE6D  bl 0x822e8248
	ctx.lr = 0x828C93E0;
	sub_822E8248(ctx, base);
	// 828C93E0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828C93E4: 3BDC0038  addi r30, r28, 0x38
	ctx.r[30].s64 = ctx.r[28].s64 + 56;
	// 828C93E8: 409A0008  bne cr6, 0x828c93f0
	if !ctx.cr[6].eq {
	pc = 0x828C93F0; continue 'dispatch;
	}
	// 828C93EC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828C93F0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828C93F4: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 828C93F8: 389C0010  addi r4, r28, 0x10
	ctx.r[4].s64 = ctx.r[28].s64 + 16;
	// 828C93FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C9400: 3B0B6910  addi r24, r11, 0x6910
	ctx.r[24].s64 = ctx.r[11].s64 + 26896;
	// 828C9404: 3AEABA80  addi r23, r10, -0x4580
	ctx.r[23].s64 = ctx.r[10].s64 + -17792;
	// 828C9408: 3BE00003  li r31, 3
	ctx.r[31].s64 = 3;
	// 828C940C: 3AC10060  addi r22, r1, 0x60
	ctx.r[22].s64 = ctx.r[1].s64 + 96;
	// 828C9410: 3AA10050  addi r21, r1, 0x50
	ctx.r[21].s64 = ctx.r[1].s64 + 80;
	// 828C9414: 4BC46105  bl 0x8250f518
	ctx.lr = 0x828C9418;
	sub_8250F518(ctx, base);
	// 828C9418: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828C941C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C9420: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C9424: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 828C9428: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	// 828C942C: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 828C9430: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 828C9434: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 828C9438: 4821DEA9  bl 0x82ae72e0
	ctx.lr = 0x828C943C;
	sub_82AE72E0(ctx, base);
	// 828C943C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C9440: 48000008  b 0x828c9448
	pc = 0x828C9448; continue 'dispatch;
	// 828C9444: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828C9448: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828C944C: 4BAAAE0D  bl 0x82374258
	ctx.lr = 0x828C9450;
	sub_82374258(ctx, base);
	// 828C9450: 57EB07BD  rlwinm. r11, r31, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C9454: 41820010  beq 0x828c9464
	if ctx.cr[0].eq {
	pc = 0x828C9464; continue 'dispatch;
	}
	// 828C9458: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C945C: 57FF07FA  rlwinm r31, r31, 0, 0x1f, 0x1d
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 828C9460: 48528831  bl 0x82df1c90
	ctx.lr = 0x828C9464;
	sub_82DF1C90(ctx, base);
	// 828C9464: 57EB07FF  clrlwi. r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C9468: 41820014  beq 0x828c947c
	if ctx.cr[0].eq {
	pc = 0x828C947C; continue 'dispatch;
	}
	// 828C946C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C9470: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C9474: 419A0008  beq cr6, 0x828c947c
	if ctx.cr[6].eq {
	pc = 0x828C947C; continue 'dispatch;
	}
	// 828C9478: 4BA1EDF1  bl 0x822e8268
	ctx.lr = 0x828C947C;
	sub_822E8268(ctx, base);
	// 828C947C: 937C0258  stw r27, 0x258(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(600 as u32), ctx.r[27].u32 ) };
	// 828C9480: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 828C9484: 419A000C  beq cr6, 0x828c9490
	if ctx.cr[6].eq {
	pc = 0x828C9490; continue 'dispatch;
	}
	// 828C9488: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828C948C: 4BA1EDDD  bl 0x822e8268
	ctx.lr = 0x828C9490;
	sub_822E8268(ctx, base);
	// 828C9490: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828C9494: 488DED08  b 0x831a819c
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C9498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C9498 size=216
    let mut pc: u32 = 0x828C9498;
    'dispatch: loop {
        match pc {
            0x828C9498 => {
    //   block [0x828C9498..0x828C9570)
	// 828C9498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C949C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828C94A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828C94A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828C94A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C94AC: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828C94B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C94B4: 396B0D78  addi r11, r11, 0xd78
	ctx.r[11].s64 = ctx.r[11].s64 + 3448;
	// 828C94B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828C94BC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828C94C0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C94C4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C94C8: C00B00A0  lfs f0, 0xa0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C94CC: C1AB00A4  lfs f13, 0xa4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(164 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828C94D0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828C94D4: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828C94D8: 4BF01019  bl 0x827ca4f0
	ctx.lr = 0x828C94DC;
	sub_827CA4F0(ctx, base);
	// 828C94DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C94E0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828C94E4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C94E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C94EC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828C94F0: 419A0024  beq cr6, 0x828c9514
	if ctx.cr[6].eq {
	pc = 0x828C9514; continue 'dispatch;
	}
	// 828C94F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828C94F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C94FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C9500: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C9504: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C9508: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C950C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C9510: 4082FFE8  bne 0x828c94f8
	if !ctx.cr[0].eq {
	pc = 0x828C94F8; continue 'dispatch;
	}
	// 828C9514: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C9518: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828C951C: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 828C9520: 388ADF30  addi r4, r10, -0x20d0
	ctx.r[4].s64 = ctx.r[10].s64 + -8400;
	// 828C9524: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 828C9528: 38A00399  li r5, 0x399
	ctx.r[5].s64 = 921;
	// 828C952C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C9530: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 828C9534: 4858F50D  bl 0x82e58a40
	ctx.lr = 0x828C9538;
	sub_82E58A40(ctx, base);
	// 828C9538: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C953C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C9540: 419A0008  beq cr6, 0x828c9548
	if ctx.cr[6].eq {
	pc = 0x828C9548; continue 'dispatch;
	}
	// 828C9544: 4B9F734D  bl 0x822c0890
	ctx.lr = 0x828C9548;
	sub_822C0890(ctx, base);
	// 828C9548: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828C954C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C9550: 419A0008  beq cr6, 0x828c9558
	if ctx.cr[6].eq {
	pc = 0x828C9558; continue 'dispatch;
	}
	// 828C9554: 4B9F733D  bl 0x822c0890
	ctx.lr = 0x828C9558;
	sub_822C0890(ctx, base);
	// 828C9558: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C955C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828C9560: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828C9564: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828C9568: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828C956C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C9570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C9570 size=316
    let mut pc: u32 = 0x828C9570;
    'dispatch: loop {
        match pc {
            0x828C9570 => {
    //   block [0x828C9570..0x828C96AC)
	// 828C9570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C9574: 488DEBF5  bl 0x831a8168
	ctx.lr = 0x828C9578;
	sub_831A8130(ctx, base);
	// 828C9578: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C957C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828C9580: 3BC40018  addi r30, r4, 0x18
	ctx.r[30].s64 = ctx.r[4].s64 + 24;
	// 828C9584: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C9588: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C958C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 828C9590: 83EB0BA0  lwz r31, 0xba0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2976 as u32) ) } as u64;
	// 828C9594: 48529C1D  bl 0x82df31b0
	ctx.lr = 0x828C9598;
	sub_82DF31B0(ctx, base);
	// 828C9598: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C959C: 895F0000  lbz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C95A0: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828C95A4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828C95A8: 41820014  beq 0x828c95bc
	if ctx.cr[0].eq {
	pc = 0x828C95BC; continue 'dispatch;
	}
	// 828C95AC: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 828C95B0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828C95B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C95B8: 419AFFE0  beq cr6, 0x828c9598
	if ctx.cr[6].eq {
	pc = 0x828C9598; continue 'dispatch;
	}
	// 828C95BC: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828C95C0: 41820040  beq 0x828c9600
	if ctx.cr[0].eq {
	pc = 0x828C9600; continue 'dispatch;
	}
	// 828C95C4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828C95C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C95CC: 83EB0B80  lwz r31, 0xb80(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2944 as u32) ) } as u64;
	// 828C95D0: 48529BE1  bl 0x82df31b0
	ctx.lr = 0x828C95D4;
	sub_82DF31B0(ctx, base);
	// 828C95D4: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C95D8: 895F0000  lbz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C95DC: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828C95E0: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828C95E4: 41820014  beq 0x828c95f8
	if ctx.cr[0].eq {
	pc = 0x828C95F8; continue 'dispatch;
	}
	// 828C95E8: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 828C95EC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828C95F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C95F4: 419AFFE0  beq cr6, 0x828c95d4
	if ctx.cr[6].eq {
	pc = 0x828C95D4; continue 'dispatch;
	}
	// 828C95F8: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828C95FC: 4082000C  bne 0x828c9608
	if !ctx.cr[0].eq {
	pc = 0x828C9608; continue 'dispatch;
	}
	// 828C9600: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C9604: 4800008C  b 0x828c9690
	pc = 0x828C9690; continue 'dispatch;
	// 828C9608: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828C960C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C9610: 83EB0B78  lwz r31, 0xb78(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2936 as u32) ) } as u64;
	// 828C9614: 48529B9D  bl 0x82df31b0
	ctx.lr = 0x828C9618;
	sub_82DF31B0(ctx, base);
	// 828C9618: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C961C: 895F0000  lbz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C9620: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828C9624: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 828C9628: 41820014  beq 0x828c963c
	if ctx.cr[0].eq {
	pc = 0x828C963C; continue 'dispatch;
	}
	// 828C962C: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 828C9630: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828C9634: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C9638: 419AFFE0  beq cr6, 0x828c9618
	if ctx.cr[6].eq {
	pc = 0x828C9618; continue 'dispatch;
	}
	// 828C963C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828C9640: 40820050  bne 0x828c9690
	if !ctx.cr[0].eq {
	pc = 0x828C9690; continue 'dispatch;
	}
	// 828C9644: 807D03B8  lwz r3, 0x3b8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(952 as u32) ) } as u64;
	// 828C9648: 4BF00929  bl 0x827c9f70
	ctx.lr = 0x828C964C;
	sub_827C9F70(ctx, base);
	// 828C964C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C9650: 41820040  beq 0x828c9690
	if ctx.cr[0].eq {
	pc = 0x828C9690; continue 'dispatch;
	}
	// 828C9654: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 828C9658: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C965C: 4BC45E6D  bl 0x8250f4c8
	ctx.lr = 0x828C9660;
	sub_8250F4C8(ctx, base);
	// 828C9660: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C9664: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C9668: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 828C966C: 409A0008  bne cr6, 0x828c9674
	if !ctx.cr[6].eq {
	pc = 0x828C9674; continue 'dispatch;
	}
	// 828C9670: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C9674: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828C9678: 4BC3F3A1  bl 0x82508a18
	ctx.lr = 0x828C967C;
	sub_82508A18(ctx, base);
	// 828C967C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C9680: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C9684: 4BFFFE15  bl 0x828c9498
	ctx.lr = 0x828C9688;
	sub_828C9498(ctx, base);
	// 828C9688: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C968C: 48528605  bl 0x82df1c90
	ctx.lr = 0x828C9690;
	sub_82DF1C90(ctx, base);
	// 828C9690: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C9694: 41820010  beq 0x828c96a4
	if ctx.cr[0].eq {
	pc = 0x828C96A4; continue 'dispatch;
	}
	// 828C9698: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C969C: 387D0010  addi r3, r29, 0x10
	ctx.r[3].s64 = ctx.r[29].s64 + 16;
	// 828C96A0: 4BF23649  bl 0x827ecce8
	ctx.lr = 0x828C96A4;
	sub_827ECCE8(ctx, base);
	// 828C96A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C96A8: 488DEB10  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C96B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C96B0 size=684
    let mut pc: u32 = 0x828C96B0;
    'dispatch: loop {
        match pc {
            0x828C96B0 => {
    //   block [0x828C96B0..0x828C995C)
	// 828C96B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C96B4: 488DEAA5  bl 0x831a8158
	ctx.lr = 0x828C96B8;
	sub_831A8130(ctx, base);
	// 828C96B8: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 828C96BC: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C96C0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828C96C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C96C8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828C96CC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828C96D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C96D4: 388B9BC9  addi r4, r11, -0x6437
	ctx.r[4].s64 = ctx.r[11].s64 + -25655;
	// 828C96D8: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 828C96DC: 4852A32D  bl 0x82df3a08
	ctx.lr = 0x828C96E0;
	sub_82DF3A08(ctx, base);
	// 828C96E0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828C96E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C96E8: 4BFFF439  bl 0x828c8b20
	ctx.lr = 0x828C96EC;
	sub_828C8B20(ctx, base);
	// 828C96EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828C96F0: 3BBF0010  addi r29, r31, 0x10
	ctx.r[29].s64 = ctx.r[31].s64 + 16;
	// 828C96F4: 7C7B1B79  or. r27, r3, r3
	ctx.r[27].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 828C96F8: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828C96FC: 3F40832D  lis r26, -0x7cd3
	ctx.r[26].s64 = -2094202880;
	// 828C9700: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C9704: 418200E4  beq 0x828c97e8
	if ctx.cr[0].eq {
	pc = 0x828C97E8; continue 'dispatch;
	}
	// 828C9708: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 828C970C: 4BF236F5  bl 0x827ece00
	ctx.lr = 0x828C9710;
	sub_827ECE00(ctx, base);
	// 828C9710: 48529AA1  bl 0x82df31b0
	ctx.lr = 0x828C9714;
	sub_82DF31B0(ctx, base);
	// 828C9714: 817A0B70  lwz r11, 0xb70(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(2928 as u32) ) } as u64;
	// 828C9718: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C971C: 89230000  lbz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C9720: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828C9724: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 828C9728: 41820014  beq 0x828c973c
	if ctx.cr[0].eq {
	pc = 0x828C973C; continue 'dispatch;
	}
	// 828C972C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C9730: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 828C9734: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828C9738: 419AFFE0  beq cr6, 0x828c9718
	if ctx.cr[6].eq {
	pc = 0x828C9718; continue 'dispatch;
	}
	// 828C973C: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828C9740: 4082005C  bne 0x828c979c
	if !ctx.cr[0].eq {
	pc = 0x828C979C; continue 'dispatch;
	}
	// 828C9744: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828C9748: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C974C: 4BC45D7D  bl 0x8250f4c8
	ctx.lr = 0x828C9750;
	sub_8250F4C8(ctx, base);
	// 828C9750: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C9754: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C9758: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 828C975C: 409A0008  bne cr6, 0x828c9764
	if !ctx.cr[6].eq {
	pc = 0x828C9764; continue 'dispatch;
	}
	// 828C9760: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828C9764: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828C9768: 4BC3F2B1  bl 0x82508a18
	ctx.lr = 0x828C976C;
	sub_82508A18(ctx, base);
	// 828C976C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 828C9770: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C9774: 4873E9B5  bl 0x83008128
	ctx.lr = 0x828C9778;
	sub_83008128(ctx, base);
	// 828C9778: 7D781850  subf r11, r24, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[24].s64;
	// 828C977C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828C9780: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828C9784: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828C9788: 69780001  xori r24, r11, 1
	ctx.r[24].u64 = ctx.r[11].u64 ^ 1;
	// 828C978C: 48528505  bl 0x82df1c90
	ctx.lr = 0x828C9790;
	sub_82DF1C90(ctx, base);
	// 828C9790: 570B063F  clrlwi. r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C9794: 41820008  beq 0x828c979c
	if ctx.cr[0].eq {
	pc = 0x828C979C; continue 'dispatch;
	}
	// 828C9798: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828C979C: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828C97A0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828C97A4: 814A0BD4  lwz r10, 0xbd4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3028 as u32) ) } as u64;
	// 828C97A8: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C97AC: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C97B0: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828C97B4: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828C97B8: 41820014  beq 0x828c97cc
	if ctx.cr[0].eq {
	pc = 0x828C97CC; continue 'dispatch;
	}
	// 828C97BC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828C97C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C97C4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C97C8: 419AFFE0  beq cr6, 0x828c97a8
	if ctx.cr[6].eq {
	pc = 0x828C97A8; continue 'dispatch;
	}
	// 828C97CC: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828C97D0: 40820008  bne 0x828c97d8
	if !ctx.cr[0].eq {
	pc = 0x828C97D8; continue 'dispatch;
	}
	// 828C97D4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828C97D8: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C97DC: 41820028  beq 0x828c9804
	if ctx.cr[0].eq {
	pc = 0x828C9804; continue 'dispatch;
	}
	// 828C97E0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C97E4: 48000018  b 0x828c97fc
	pc = 0x828C97FC; continue 'dispatch;
	// 828C97E8: 4803F671  bl 0x82908e58
	ctx.lr = 0x828C97EC;
	sub_82908E58(ctx, base);
	// 828C97EC: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 828C97F0: 40990014  ble cr6, 0x828c9804
	if !ctx.cr[6].gt {
	pc = 0x828C9804; continue 'dispatch;
	}
	// 828C97F4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828C97F8: 808B0B34  lwz r4, 0xb34(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2868 as u32) ) } as u64;
	// 828C97FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C9800: 4852A079  bl 0x82df3878
	ctx.lr = 0x828C9804;
	sub_82DF3878(ctx, base);
	// 828C9804: 807F03B8  lwz r3, 0x3b8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(952 as u32) ) } as u64;
	// 828C9808: 4BF00769  bl 0x827c9f70
	ctx.lr = 0x828C980C;
	sub_827C9F70(ctx, base);
	// 828C980C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C9810: 40820138  bne 0x828c9948
	if !ctx.cr[0].eq {
	pc = 0x828C9948; continue 'dispatch;
	}
	// 828C9814: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C9818: 4852A391  bl 0x82df3ba8
	ctx.lr = 0x828C981C;
	sub_82DF3BA8(ctx, base);
	// 828C981C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C9820: 40820128  bne 0x828c9948
	if !ctx.cr[0].eq {
	pc = 0x828C9948; continue 'dispatch;
	}
	// 828C9824: 38BC0050  addi r5, r28, 0x50
	ctx.r[5].s64 = ctx.r[28].s64 + 80;
	// 828C9828: 389C0030  addi r4, r28, 0x30
	ctx.r[4].s64 = ctx.r[28].s64 + 48;
	// 828C982C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C9830: 4BFFEB59  bl 0x828c8388
	ctx.lr = 0x828C9834;
	sub_828C8388(ctx, base);
	// 828C9834: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C9838: 48149E49  bl 0x82a13680
	ctx.lr = 0x828C983C;
	sub_82A13680(ctx, base);
	// 828C983C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C9840: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828C9844: 4BD1DDED  bl 0x825e7630
	ctx.lr = 0x828C9848;
	sub_825E7630(ctx, base);
	// 828C9848: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828C984C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828C9850: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828C9854: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C9858: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828C985C: 419A0024  beq cr6, 0x828c9880
	if ctx.cr[6].eq {
	pc = 0x828C9880; continue 'dispatch;
	}
	// 828C9860: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828C9864: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C9868: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C986C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C9870: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C9874: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C9878: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C987C: 4082FFE8  bne 0x828c9864
	if !ctx.cr[0].eq {
	pc = 0x828C9864; continue 'dispatch;
	}
	// 828C9880: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828C9884: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 828C9888: 4873E8A1  bl 0x83008128
	ctx.lr = 0x828C988C;
	sub_83008128(ctx, base);
	// 828C988C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C9890: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828C9894: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828C9898: 388BDF30  addi r4, r11, -0x20d0
	ctx.r[4].s64 = ctx.r[11].s64 + -8400;
	// 828C989C: 38A00413  li r5, 0x413
	ctx.r[5].s64 = 1043;
	// 828C98A0: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 828C98A4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828C98A8: 4858F199  bl 0x82e58a40
	ctx.lr = 0x828C98AC;
	sub_82E58A40(ctx, base);
	// 828C98AC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828C98B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C98B4: 419A0008  beq cr6, 0x828c98bc
	if ctx.cr[6].eq {
	pc = 0x828C98BC; continue 'dispatch;
	}
	// 828C98B8: 4B9F6FD9  bl 0x822c0890
	ctx.lr = 0x828C98BC;
	sub_822C0890(ctx, base);
	// 828C98BC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828C98C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C98C4: 419A0008  beq cr6, 0x828c98cc
	if ctx.cr[6].eq {
	pc = 0x828C98CC; continue 'dispatch;
	}
	// 828C98C8: 4B9F6FC9  bl 0x822c0890
	ctx.lr = 0x828C98CC;
	sub_822C0890(ctx, base);
	// 828C98CC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828C98D0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828C98D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C98D8: 48046EA1  bl 0x82910778
	ctx.lr = 0x828C98DC;
	sub_82910778(ctx, base);
	// 828C98DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C98E0: 4803F579  bl 0x82908e58
	ctx.lr = 0x828C98E4;
	sub_82908E58(ctx, base);
	// 828C98E4: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 828C98E8: 4099000C  ble cr6, 0x828c98f4
	if !ctx.cr[6].gt {
	pc = 0x828C98F4; continue 'dispatch;
	}
	// 828C98EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828C98F0: 48000018  b 0x828c9908
	pc = 0x828C9908; continue 'dispatch;
	// 828C98F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C98F8: 809A0B70  lwz r4, 0xb70(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(2928 as u32) ) } as u64;
	// 828C98FC: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 828C9900: 4852A109  bl 0x82df3a08
	ctx.lr = 0x828C9904;
	sub_82DF3A08(ctx, base);
	// 828C9904: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C9908: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C990C: 4852A2C5  bl 0x82df3bd0
	ctx.lr = 0x828C9910;
	sub_82DF3BD0(ctx, base);
	// 828C9910: 572B07FF  clrlwi. r11, r25, 0x1f
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C9914: 4182000C  beq 0x828c9920
	if ctx.cr[0].eq {
	pc = 0x828C9920; continue 'dispatch;
	}
	// 828C9918: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C991C: 48529B0D  bl 0x82df3428
	ctx.lr = 0x828C9920;
	sub_82DF3428(ctx, base);
	// 828C9920: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C9924: 4852988D  bl 0x82df31b0
	ctx.lr = 0x828C9928;
	sub_82DF31B0(ctx, base);
	// 828C9928: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C992C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C9930: 4852A0D9  bl 0x82df3a08
	ctx.lr = 0x828C9934;
	sub_82DF3A08(ctx, base);
	// 828C9934: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828C9938: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C993C: 4BF233AD  bl 0x827ecce8
	ctx.lr = 0x828C9940;
	sub_827ECCE8(ctx, base);
	// 828C9940: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C9944: 48529AE5  bl 0x82df3428
	ctx.lr = 0x828C9948;
	sub_82DF3428(ctx, base);
	// 828C9948: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828C994C: 48529ADD  bl 0x82df3428
	ctx.lr = 0x828C9950;
	sub_82DF3428(ctx, base);
	// 828C9950: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828C9954: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 828C9958: 488DE850  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C9960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C9960 size=388
    let mut pc: u32 = 0x828C9960;
    'dispatch: loop {
        match pc {
            0x828C9960 => {
    //   block [0x828C9960..0x828C9AE4)
	// 828C9960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C9964: 488DE805  bl 0x831a8168
	ctx.lr = 0x828C9968;
	sub_831A8130(ctx, base);
	// 828C9968: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C996C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828C9970: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C9974: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C9978: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828C997C: 41820038  beq 0x828c99b4
	if ctx.cr[0].eq {
	pc = 0x828C99B4; continue 'dispatch;
	}
	// 828C9980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C9984: 488E0005  bl 0x831a9988
	ctx.lr = 0x828C9988;
	sub_831A9988(ctx, base);
	// 828C9988: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 828C998C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C9990: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 828C9994: 488DE765  bl 0x831a80f8
	ctx.lr = 0x828C9998;
	sub_831A80F8(ctx, base);
	// 828C9998: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C999C: 41820018  beq 0x828c99b4
	if ctx.cr[0].eq {
	pc = 0x828C99B4; continue 'dispatch;
	}
	// 828C99A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C99A4: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828C99A8: 4BFFFD09  bl 0x828c96b0
	ctx.lr = 0x828C99AC;
	sub_828C96B0(ctx, base);
	// 828C99AC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828C99B0: 4800012C  b 0x828c9adc
	pc = 0x828C9ADC; continue 'dispatch;
	// 828C99B4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C99B8: 419A0114  beq cr6, 0x828c9acc
	if ctx.cr[6].eq {
	pc = 0x828C9ACC; continue 'dispatch;
	}
	// 828C99BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C99C0: 488DFFC9  bl 0x831a9988
	ctx.lr = 0x828C99C4;
	sub_831A9988(ctx, base);
	// 828C99C4: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828C99C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C99CC: 386B5CC4  addi r3, r11, 0x5cc4
	ctx.r[3].s64 = ctx.r[11].s64 + 23748;
	// 828C99D0: 488DE729  bl 0x831a80f8
	ctx.lr = 0x828C99D4;
	sub_831A80F8(ctx, base);
	// 828C99D4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C99D8: 41820014  beq 0x828c99ec
	if ctx.cr[0].eq {
	pc = 0x828C99EC; continue 'dispatch;
	}
	// 828C99DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C99E0: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828C99E4: 4BFFFB8D  bl 0x828c9570
	ctx.lr = 0x828C99E8;
	sub_828C9570(ctx, base);
	// 828C99E8: 4BFFFFC4  b 0x828c99ac
	pc = 0x828C99AC; continue 'dispatch;
	// 828C99EC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C99F0: 419A00DC  beq cr6, 0x828c9acc
	if ctx.cr[6].eq {
	pc = 0x828C9ACC; continue 'dispatch;
	}
	// 828C99F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C99F8: 488DFF91  bl 0x831a9988
	ctx.lr = 0x828C99FC;
	sub_831A9988(ctx, base);
	// 828C99FC: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 828C9A00: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C9A04: 386B3A44  addi r3, r11, 0x3a44
	ctx.r[3].s64 = ctx.r[11].s64 + 14916;
	// 828C9A08: 488DE6F1  bl 0x831a80f8
	ctx.lr = 0x828C9A0C;
	sub_831A80F8(ctx, base);
	// 828C9A0C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C9A10: 41820014  beq 0x828c9a24
	if ctx.cr[0].eq {
	pc = 0x828C9A24; continue 'dispatch;
	}
	// 828C9A14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C9A18: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828C9A1C: 4BFFE2F5  bl 0x828c7d10
	ctx.lr = 0x828C9A20;
	sub_828C7D10(ctx, base);
	// 828C9A20: 4BFFFF8C  b 0x828c99ac
	pc = 0x828C99AC; continue 'dispatch;
	// 828C9A24: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C9A28: 419A00A4  beq cr6, 0x828c9acc
	if ctx.cr[6].eq {
	pc = 0x828C9ACC; continue 'dispatch;
	}
	// 828C9A2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C9A30: 488DFF59  bl 0x831a9988
	ctx.lr = 0x828C9A34;
	sub_831A9988(ctx, base);
	// 828C9A34: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 828C9A38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C9A3C: 386B1FA4  addi r3, r11, 0x1fa4
	ctx.r[3].s64 = ctx.r[11].s64 + 8100;
	// 828C9A40: 488DE6B9  bl 0x831a80f8
	ctx.lr = 0x828C9A44;
	sub_831A80F8(ctx, base);
	// 828C9A44: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C9A48: 41820014  beq 0x828c9a5c
	if ctx.cr[0].eq {
	pc = 0x828C9A5C; continue 'dispatch;
	}
	// 828C9A4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C9A50: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828C9A54: 4BFFE9B5  bl 0x828c8408
	ctx.lr = 0x828C9A58;
	sub_828C8408(ctx, base);
	// 828C9A58: 4BFFFF54  b 0x828c99ac
	pc = 0x828C99AC; continue 'dispatch;
	// 828C9A5C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C9A60: 419A006C  beq cr6, 0x828c9acc
	if ctx.cr[6].eq {
	pc = 0x828C9ACC; continue 'dispatch;
	}
	// 828C9A64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C9A68: 488DFF21  bl 0x831a9988
	ctx.lr = 0x828C9A6C;
	sub_831A9988(ctx, base);
	// 828C9A6C: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 828C9A70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C9A74: 386B2380  addi r3, r11, 0x2380
	ctx.r[3].s64 = ctx.r[11].s64 + 9088;
	// 828C9A78: 488DE681  bl 0x831a80f8
	ctx.lr = 0x828C9A7C;
	sub_831A80F8(ctx, base);
	// 828C9A7C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C9A80: 41820014  beq 0x828c9a94
	if ctx.cr[0].eq {
	pc = 0x828C9A94; continue 'dispatch;
	}
	// 828C9A84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C9A88: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828C9A8C: 4BFFE36D  bl 0x828c7df8
	ctx.lr = 0x828C9A90;
	sub_828C7DF8(ctx, base);
	// 828C9A90: 4BFFFF1C  b 0x828c99ac
	pc = 0x828C99AC; continue 'dispatch;
	// 828C9A94: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C9A98: 419A0034  beq cr6, 0x828c9acc
	if ctx.cr[6].eq {
	pc = 0x828C9ACC; continue 'dispatch;
	}
	// 828C9A9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C9AA0: 488DFEE9  bl 0x831a9988
	ctx.lr = 0x828C9AA4;
	sub_831A9988(ctx, base);
	// 828C9AA4: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 828C9AA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C9AAC: 386BDA28  addi r3, r11, -0x25d8
	ctx.r[3].s64 = ctx.r[11].s64 + -9688;
	// 828C9AB0: 488DE649  bl 0x831a80f8
	ctx.lr = 0x828C9AB4;
	sub_831A80F8(ctx, base);
	// 828C9AB4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C9AB8: 41820014  beq 0x828c9acc
	if ctx.cr[0].eq {
	pc = 0x828C9ACC; continue 'dispatch;
	}
	// 828C9ABC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C9AC0: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828C9AC4: 4BFFF0F5  bl 0x828c8bb8
	ctx.lr = 0x828C9AC8;
	sub_828C8BB8(ctx, base);
	// 828C9AC8: 4BFFFEE4  b 0x828c99ac
	pc = 0x828C99AC; continue 'dispatch;
	// 828C9ACC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828C9AD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C9AD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C9AD8: 48095481  bl 0x8295ef58
	ctx.lr = 0x828C9ADC;
	sub_8295EF58(ctx, base);
	// 828C9ADC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C9AE0: 488DE6D8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C9AE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C9AE8 size=100
    let mut pc: u32 = 0x828C9AE8;
    'dispatch: loop {
        match pc {
            0x828C9AE8 => {
    //   block [0x828C9AE8..0x828C9B4C)
	// 828C9AE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C9AEC: 488DE681  bl 0x831a816c
	ctx.lr = 0x828C9AF0;
	sub_831A8130(ctx, base);
	// 828C9AF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C9AF4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C9AF8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C9AFC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828C9B00: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828C9B04: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C9B08: 388BDF30  addi r4, r11, -0x20d0
	ctx.r[4].s64 = ctx.r[11].s64 + -8400;
	// 828C9B0C: 38A000BD  li r5, 0xbd
	ctx.r[5].s64 = 189;
	// 828C9B10: 38600430  li r3, 0x430
	ctx.r[3].s64 = 1072;
	// 828C9B14: 485288D5  bl 0x82df23e8
	ctx.lr = 0x828C9B18;
	sub_82DF23E8(ctx, base);
	// 828C9B18: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C9B1C: 41820018  beq 0x828c9b34
	if ctx.cr[0].eq {
	pc = 0x828C9B34; continue 'dispatch;
	}
	// 828C9B20: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828C9B24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C9B28: 4BFFF259  bl 0x828c8d80
	ctx.lr = 0x828C9B2C;
	sub_828C8D80(ctx, base);
	// 828C9B2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C9B30: 48000008  b 0x828c9b38
	pc = 0x828C9B38; continue 'dispatch;
	// 828C9B34: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828C9B38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C9B3C: 4BFFE98D  bl 0x828c84c8
	ctx.lr = 0x828C9B40;
	sub_828C84C8(ctx, base);
	// 828C9B40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C9B44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828C9B48: 488DE674  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C9B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C9B50 size=128
    let mut pc: u32 = 0x828C9B50;
    'dispatch: loop {
        match pc {
            0x828C9B50 => {
    //   block [0x828C9B50..0x828C9BD0)
	// 828C9B50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C9B54: 488DE619  bl 0x831a816c
	ctx.lr = 0x828C9B58;
	sub_831A8130(ctx, base);
	// 828C9B58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C9B5C: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828C9B60: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828C9B64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C9B68: 3BEB0D34  addi r31, r11, 0xd34
	ctx.r[31].s64 = ctx.r[11].s64 + 3380;
	// 828C9B6C: 816A0D3C  lwz r11, 0xd3c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3388 as u32) ) } as u64;
	// 828C9B70: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C9B74: 40820024  bne 0x828c9b98
	if !ctx.cr[0].eq {
	pc = 0x828C9B98; continue 'dispatch;
	}
	// 828C9B78: 3D208236  lis r9, -0x7dca
	ctx.r[9].s64 = -2110390272;
	// 828C9B7C: 3D00828D  lis r8, -0x7d73
	ctx.r[8].s64 = -2104688640;
	// 828C9B80: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828C9B84: 3929A778  addi r9, r9, -0x5888
	ctx.r[9].s64 = ctx.r[9].s64 + -22664;
	// 828C9B88: 390880B0  addi r8, r8, -0x7f50
	ctx.r[8].s64 = ctx.r[8].s64 + -32592;
	// 828C9B8C: 916A0D3C  stw r11, 0xd3c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(3388 as u32), ctx.r[11].u32 ) };
	// 828C9B90: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C9B94: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828C9B98: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828C9B9C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C9BA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C9BA4: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 828C9BA8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828C9BAC: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C9BB0: 4BFFDD29  bl 0x828c78d8
	ctx.lr = 0x828C9BB4;
	sub_828C78D8(ctx, base);
	// 828C9BB4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C9BB8: 4182000C  beq 0x828c9bc4
	if ctx.cr[0].eq {
	pc = 0x828C9BC4; continue 'dispatch;
	}
	// 828C9BBC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C9BC0: 48000008  b 0x828c9bc8
	pc = 0x828C9BC8; continue 'dispatch;
	// 828C9BC4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C9BC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C9BCC: 488DE5F0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C9BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C9BD0 size=128
    let mut pc: u32 = 0x828C9BD0;
    'dispatch: loop {
        match pc {
            0x828C9BD0 => {
    //   block [0x828C9BD0..0x828C9C50)
	// 828C9BD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C9BD4: 488DE599  bl 0x831a816c
	ctx.lr = 0x828C9BD8;
	sub_831A8130(ctx, base);
	// 828C9BD8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C9BDC: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828C9BE0: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828C9BE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C9BE8: 3BEB0D40  addi r31, r11, 0xd40
	ctx.r[31].s64 = ctx.r[11].s64 + 3392;
	// 828C9BEC: 816A0D48  lwz r11, 0xd48(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3400 as u32) ) } as u64;
	// 828C9BF0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C9BF4: 40820024  bne 0x828c9c18
	if !ctx.cr[0].eq {
	pc = 0x828C9C18; continue 'dispatch;
	}
	// 828C9BF8: 3D208236  lis r9, -0x7dca
	ctx.r[9].s64 = -2110390272;
	// 828C9BFC: 3D00828D  lis r8, -0x7d73
	ctx.r[8].s64 = -2104688640;
	// 828C9C00: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828C9C04: 3929A778  addi r9, r9, -0x5888
	ctx.r[9].s64 = ctx.r[9].s64 + -22664;
	// 828C9C08: 390880F8  addi r8, r8, -0x7f08
	ctx.r[8].s64 = ctx.r[8].s64 + -32520;
	// 828C9C0C: 916A0D48  stw r11, 0xd48(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(3400 as u32), ctx.r[11].u32 ) };
	// 828C9C10: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C9C14: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828C9C18: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828C9C1C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C9C20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C9C24: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 828C9C28: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828C9C2C: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C9C30: 4BFFDCA9  bl 0x828c78d8
	ctx.lr = 0x828C9C34;
	sub_828C78D8(ctx, base);
	// 828C9C34: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C9C38: 4182000C  beq 0x828c9c44
	if ctx.cr[0].eq {
	pc = 0x828C9C44; continue 'dispatch;
	}
	// 828C9C3C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C9C40: 48000008  b 0x828c9c48
	pc = 0x828C9C48; continue 'dispatch;
	// 828C9C44: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C9C48: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C9C4C: 488DE570  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C9C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C9C50 size=128
    let mut pc: u32 = 0x828C9C50;
    'dispatch: loop {
        match pc {
            0x828C9C50 => {
    //   block [0x828C9C50..0x828C9CD0)
	// 828C9C50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C9C54: 488DE519  bl 0x831a816c
	ctx.lr = 0x828C9C58;
	sub_831A8130(ctx, base);
	// 828C9C58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C9C5C: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828C9C60: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828C9C64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C9C68: 3BEB0D4C  addi r31, r11, 0xd4c
	ctx.r[31].s64 = ctx.r[11].s64 + 3404;
	// 828C9C6C: 816A0D54  lwz r11, 0xd54(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3412 as u32) ) } as u64;
	// 828C9C70: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C9C74: 40820024  bne 0x828c9c98
	if !ctx.cr[0].eq {
	pc = 0x828C9C98; continue 'dispatch;
	}
	// 828C9C78: 3D208236  lis r9, -0x7dca
	ctx.r[9].s64 = -2110390272;
	// 828C9C7C: 3D00828D  lis r8, -0x7d73
	ctx.r[8].s64 = -2104688640;
	// 828C9C80: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828C9C84: 3929A778  addi r9, r9, -0x5888
	ctx.r[9].s64 = ctx.r[9].s64 + -22664;
	// 828C9C88: 39088140  addi r8, r8, -0x7ec0
	ctx.r[8].s64 = ctx.r[8].s64 + -32448;
	// 828C9C8C: 916A0D54  stw r11, 0xd54(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(3412 as u32), ctx.r[11].u32 ) };
	// 828C9C90: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C9C94: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828C9C98: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828C9C9C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C9CA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C9CA4: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 828C9CA8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828C9CAC: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C9CB0: 4BFFDC29  bl 0x828c78d8
	ctx.lr = 0x828C9CB4;
	sub_828C78D8(ctx, base);
	// 828C9CB4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C9CB8: 4182000C  beq 0x828c9cc4
	if ctx.cr[0].eq {
	pc = 0x828C9CC4; continue 'dispatch;
	}
	// 828C9CBC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C9CC0: 48000008  b 0x828c9cc8
	pc = 0x828C9CC8; continue 'dispatch;
	// 828C9CC4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C9CC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C9CCC: 488DE4F0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C9CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C9CD0 size=492
    let mut pc: u32 = 0x828C9CD0;
    'dispatch: loop {
        match pc {
            0x828C9CD0 => {
    //   block [0x828C9CD0..0x828C9EBC)
	// 828C9CD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C9CD4: 488DE491  bl 0x831a8164
	ctx.lr = 0x828C9CD8;
	sub_831A8130(ctx, base);
	// 828C9CD8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828C9CDC: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C9CE0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828C9CE4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828C9CE8: 3BCBDF30  addi r30, r11, -0x20d0
	ctx.r[30].s64 = ctx.r[11].s64 + -8400;
	// 828C9CEC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828C9CF0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C9CF4: 38A000B4  li r5, 0xb4
	ctx.r[5].s64 = 180;
	// 828C9CF8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828C9CFC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C9D00: 38600430  li r3, 0x430
	ctx.r[3].s64 = 1072;
	// 828C9D04: 485286E5  bl 0x82df23e8
	ctx.lr = 0x828C9D08;
	sub_82DF23E8(ctx, base);
	// 828C9D08: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828C9D0C: 41820020  beq 0x828c9d2c
	if ctx.cr[0].eq {
	pc = 0x828C9D2C; continue 'dispatch;
	}
	// 828C9D10: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828C9D14: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 828C9D18: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 828C9D1C: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 828C9D20: 4BFFF061  bl 0x828c8d80
	ctx.lr = 0x828C9D24;
	sub_828C8D80(ctx, base);
	// 828C9D24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C9D28: 48000008  b 0x828c9d30
	pc = 0x828C9D30; continue 'dispatch;
	// 828C9D2C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C9D30: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828C9D34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C9D38: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C9D3C: 4BFFE135  bl 0x828c7e70
	ctx.lr = 0x828C9D40;
	sub_828C7E70(ctx, base);
	// 828C9D40: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C9D44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C9D48: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828C9D4C: 4B9F62B5  bl 0x822c0000
	ctx.lr = 0x828C9D50;
	sub_822C0000(ctx, base);
	// 828C9D50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828C9D54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828C9D58: 38A000B5  li r5, 0xb5
	ctx.r[5].s64 = 181;
	// 828C9D5C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828C9D60: 4B9F6679  bl 0x822c03d8
	ctx.lr = 0x828C9D64;
	sub_822C03D8(ctx, base);
	// 828C9D64: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828C9D68: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828C9D6C: 418200E0  beq 0x828c9e4c
	if ctx.cr[0].eq {
	pc = 0x828C9E4C; continue 'dispatch;
	}
	// 828C9D70: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828C9D74: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C9D78: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828C9D7C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 828C9D80: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 828C9D84: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C9D88: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828C9D8C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828C9D90: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828C9D94: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828C9D98: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828C9D9C: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828C9DA0: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 828C9DA4: 419A0024  beq cr6, 0x828c9dc8
	if ctx.cr[6].eq {
	pc = 0x828C9DC8; continue 'dispatch;
	}
	// 828C9DA8: 395D0004  addi r10, r29, 4
	ctx.r[10].s64 = ctx.r[29].s64 + 4;
	// 828C9DAC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 828C9DB0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C9DB4: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 828C9DB8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828C9DBC: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C9DC0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C9DC4: 4082FFE8  bne 0x828c9dac
	if !ctx.cr[0].eq {
	pc = 0x828C9DAC; continue 'dispatch;
	}
	// 828C9DC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828C9DCC: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 828C9DD0: 409A0008  bne cr6, 0x828c9dd8
	if !ctx.cr[6].eq {
	pc = 0x828C9DD8; continue 'dispatch;
	}
	// 828C9DD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828C9DD8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828C9DDC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C9DE0: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 828C9DE4: 419A0024  beq cr6, 0x828c9e08
	if ctx.cr[6].eq {
	pc = 0x828C9E08; continue 'dispatch;
	}
	// 828C9DE8: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 828C9DEC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828C9DF0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C9DF4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828C9DF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828C9DFC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828C9E00: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828C9E04: 4082FFE8  bne 0x828c9dec
	if !ctx.cr[0].eq {
	pc = 0x828C9DEC; continue 'dispatch;
	}
	// 828C9E08: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828C9E0C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828C9E10: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828C9E14: C02B7590  lfs f1, 0x7590(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828C9E18: 485B2E29  bl 0x82e7cc40
	ctx.lr = 0x828C9E1C;
	sub_82E7CC40(ctx, base);
	// 828C9E1C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828C9E20: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828C9E24: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828C9E28: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828C9E2C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828C9E30: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828C9E34: 4BECF0FD  bl 0x82798f30
	ctx.lr = 0x828C9E38;
	sub_82798F30(ctx, base);
	// 828C9E38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828C9E3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C9E40: 4BED1829  bl 0x8279b668
	ctx.lr = 0x828C9E44;
	sub_8279B668(ctx, base);
	// 828C9E44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828C9E48: 48000008  b 0x828c9e50
	pc = 0x828C9E50; continue 'dispatch;
	// 828C9E4C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828C9E50: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C9E54: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828C9E58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C9E5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C9E60: 4BCCDDF1  bl 0x82597c50
	ctx.lr = 0x828C9E64;
	sub_82597C50(ctx, base);
	// 828C9E64: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828C9E68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828C9E6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828C9E70: 4B9F6191  bl 0x822c0000
	ctx.lr = 0x828C9E74;
	sub_822C0000(ctx, base);
	// 828C9E74: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C9E78: 41820024  beq 0x828c9e9c
	if ctx.cr[0].eq {
	pc = 0x828C9E9C; continue 'dispatch;
	}
	// 828C9E7C: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 828C9E80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C9E84: 419A0008  beq cr6, 0x828c9e8c
	if ctx.cr[6].eq {
	pc = 0x828C9E8C; continue 'dispatch;
	}
	// 828C9E88: 4B9F6A09  bl 0x822c0890
	ctx.lr = 0x828C9E8C;
	sub_822C0890(ctx, base);
	// 828C9E8C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828C9E90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828C9E94: 419A0008  beq cr6, 0x828c9e9c
	if ctx.cr[6].eq {
	pc = 0x828C9E9C; continue 'dispatch;
	}
	// 828C9E98: 4B9F69F9  bl 0x822c0890
	ctx.lr = 0x828C9E9C;
	sub_822C0890(ctx, base);
	// 828C9E9C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828C9EA0: 419A000C  beq cr6, 0x828c9eac
	if ctx.cr[6].eq {
	pc = 0x828C9EAC; continue 'dispatch;
	}
	// 828C9EA4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828C9EA8: 4B9F69E9  bl 0x822c0890
	ctx.lr = 0x828C9EAC;
	sub_822C0890(ctx, base);
	// 828C9EAC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828C9EB0: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 828C9EB4: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828C9EB8: 488DE2FC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C9EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C9EC0 size=128
    let mut pc: u32 = 0x828C9EC0;
    'dispatch: loop {
        match pc {
            0x828C9EC0 => {
    //   block [0x828C9EC0..0x828C9F40)
	// 828C9EC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C9EC4: 488DE2A9  bl 0x831a816c
	ctx.lr = 0x828C9EC8;
	sub_831A8130(ctx, base);
	// 828C9EC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C9ECC: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828C9ED0: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828C9ED4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C9ED8: 3BEB0D58  addi r31, r11, 0xd58
	ctx.r[31].s64 = ctx.r[11].s64 + 3416;
	// 828C9EDC: 816A0D60  lwz r11, 0xd60(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3424 as u32) ) } as u64;
	// 828C9EE0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C9EE4: 40820024  bne 0x828c9f08
	if !ctx.cr[0].eq {
	pc = 0x828C9F08; continue 'dispatch;
	}
	// 828C9EE8: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 828C9EEC: 3D00828D  lis r8, -0x7d73
	ctx.r[8].s64 = -2104688640;
	// 828C9EF0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828C9EF4: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 828C9EF8: 39088520  addi r8, r8, -0x7ae0
	ctx.r[8].s64 = ctx.r[8].s64 + -31456;
	// 828C9EFC: 916A0D60  stw r11, 0xd60(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(3424 as u32), ctx.r[11].u32 ) };
	// 828C9F00: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C9F04: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828C9F08: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828C9F0C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C9F10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C9F14: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828C9F18: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828C9F1C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C9F20: 4BD8A6A1  bl 0x826545c0
	ctx.lr = 0x828C9F24;
	sub_826545C0(ctx, base);
	// 828C9F24: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C9F28: 4182000C  beq 0x828c9f34
	if ctx.cr[0].eq {
	pc = 0x828C9F34; continue 'dispatch;
	}
	// 828C9F2C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C9F30: 48000008  b 0x828c9f38
	pc = 0x828C9F38; continue 'dispatch;
	// 828C9F34: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C9F38: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C9F3C: 488DE280  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C9F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828C9F40 size=128
    let mut pc: u32 = 0x828C9F40;
    'dispatch: loop {
        match pc {
            0x828C9F40 => {
    //   block [0x828C9F40..0x828C9FC0)
	// 828C9F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C9F44: 488DE229  bl 0x831a816c
	ctx.lr = 0x828C9F48;
	sub_831A8130(ctx, base);
	// 828C9F48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C9F4C: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828C9F50: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828C9F54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828C9F58: 3BEB0D64  addi r31, r11, 0xd64
	ctx.r[31].s64 = ctx.r[11].s64 + 3428;
	// 828C9F5C: 816A0D6C  lwz r11, 0xd6c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3436 as u32) ) } as u64;
	// 828C9F60: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828C9F64: 40820024  bne 0x828c9f88
	if !ctx.cr[0].eq {
	pc = 0x828C9F88; continue 'dispatch;
	}
	// 828C9F68: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 828C9F6C: 3D00828D  lis r8, -0x7d73
	ctx.r[8].s64 = -2104688640;
	// 828C9F70: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828C9F74: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 828C9F78: 39088568  addi r8, r8, -0x7a98
	ctx.r[8].s64 = ctx.r[8].s64 + -31384;
	// 828C9F7C: 916A0D6C  stw r11, 0xd6c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(3436 as u32), ctx.r[11].u32 ) };
	// 828C9F80: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828C9F84: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828C9F88: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828C9F8C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828C9F90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828C9F94: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828C9F98: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828C9F9C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828C9FA0: 4BD8A621  bl 0x826545c0
	ctx.lr = 0x828C9FA4;
	sub_826545C0(ctx, base);
	// 828C9FA4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828C9FA8: 4182000C  beq 0x828c9fb4
	if ctx.cr[0].eq {
	pc = 0x828C9FB4; continue 'dispatch;
	}
	// 828C9FAC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828C9FB0: 48000008  b 0x828c9fb8
	pc = 0x828C9FB8; continue 'dispatch;
	// 828C9FB4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828C9FB8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828C9FBC: 488DE200  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828C9FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828C9FC0 size=4152
    let mut pc: u32 = 0x828C9FC0;
    'dispatch: loop {
        match pc {
            0x828C9FC0 => {
    //   block [0x828C9FC0..0x828CAFF8)
	// 828C9FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828C9FC4: 488DE16D  bl 0x831a8130
	ctx.lr = 0x828C9FC8;
	sub_831A8130(ctx, base);
	// 828C9FC8: DBA1FF50  stfd f29, -0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.f[29].u64 ) };
	// 828C9FCC: DBC1FF58  stfd f30, -0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 828C9FD0: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 828C9FD4: 9421FC40  stwu r1, -0x3c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-960 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828C9FD8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828C9FDC: 7C8F2378  mr r15, r4
	ctx.r[15].u64 = ctx.r[4].u64;
	// 828C9FE0: 7CB12B78  mr r17, r5
	ctx.r[17].u64 = ctx.r[5].u64;
	// 828C9FE4: 7CD23378  mr r18, r6
	ctx.r[18].u64 = ctx.r[6].u64;
	// 828C9FE8: 48094E69  bl 0x8295ee50
	ctx.lr = 0x828C9FEC;
	sub_8295EE50(ctx, base);
	// 828C9FEC: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 828C9FF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828C9FF4: 3B6B7564  addi r27, r11, 0x7564
	ctx.r[27].s64 = ctx.r[11].s64 + 30052;
	// 828C9FF8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828C9FFC: 48529A0D  bl 0x82df3a08
	ctx.lr = 0x828CA000;
	sub_82DF3A08(ctx, base);
	// 828CA000: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CA004: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CA008: 3B0BDCB8  addi r24, r11, -0x2348
	ctx.r[24].s64 = ctx.r[11].s64 + -9032;
	// 828CA00C: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 828CA010: 38F80004  addi r7, r24, 4
	ctx.r[7].s64 = ctx.r[24].s64 + 4;
	// 828CA014: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 828CA018: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 828CA01C: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 828CA020: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 828CA024: 48047DED  bl 0x82911e10
	ctx.lr = 0x828CA028;
	sub_82911E10(ctx, base);
	// 828CA028: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CA02C: 485293FD  bl 0x82df3428
	ctx.lr = 0x828CA030;
	sub_82DF3428(ctx, base);
	// 828CA030: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CA034: 4804688D  bl 0x829108c0
	ctx.lr = 0x828CA038;
	sub_829108C0(ctx, base);
	// 828CA038: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CA03C: 41820010  beq 0x828ca04c
	if ctx.cr[0].eq {
	pc = 0x828CA04C; continue 'dispatch;
	}
	// 828CA040: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CA044: 4BC4658D  bl 0x825105d0
	ctx.lr = 0x828CA048;
	sub_825105D0(ctx, base);
	// 828CA048: 48000F9C  b 0x828cafe4
	pc = 0x828CAFE4; continue 'dispatch;
	// 828CA04C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828CA050: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CA054: 3A0BBF6C  addi r16, r11, -0x4094
	ctx.r[16].s64 = ctx.r[11].s64 + -16532;
	// 828CA058: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 828CA05C: 485299AD  bl 0x82df3a08
	ctx.lr = 0x828CA060;
	sub_82DF3A08(ctx, base);
	// 828CA060: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828CA064: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828CA068: 4BF22561  bl 0x827ec5c8
	ctx.lr = 0x828CA06C;
	sub_827EC5C8(ctx, base);
	// 828CA06C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CA070: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828CA074: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 828CA078: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA07C: 4854AFB5  bl 0x82e15030
	ctx.lr = 0x828CA080;
	sub_82E15030(ctx, base);
	// 828CA080: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CA084: 3BFD0388  addi r31, r29, 0x388
	ctx.r[31].s64 = ctx.r[29].s64 + 904;
	// 828CA088: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 828CA08C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 828CA090: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA094: 917D0388  stw r11, 0x388(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(904 as u32), ctx.r[11].u32 ) };
	// 828CA098: 4B9FA3C9  bl 0x822c4460
	ctx.lr = 0x828CA09C;
	sub_822C4460(ctx, base);
	// 828CA09C: 817D0388  lwz r11, 0x388(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(904 as u32) ) } as u64;
	// 828CA0A0: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 828CA0A4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828CA0A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CA0AC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828CA0B0: 697E0001  xori r30, r11, 1
	ctx.r[30].u64 = ctx.r[11].u64 ^ 1;
	// 828CA0B4: 419A0008  beq cr6, 0x828ca0bc
	if ctx.cr[6].eq {
	pc = 0x828CA0BC; continue 'dispatch;
	}
	// 828CA0B8: 4B9F67D9  bl 0x822c0890
	ctx.lr = 0x828CA0BC;
	sub_822C0890(ctx, base);
	// 828CA0BC: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 828CA0C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CA0C4: 419A0008  beq cr6, 0x828ca0cc
	if ctx.cr[6].eq {
	pc = 0x828CA0CC; continue 'dispatch;
	}
	// 828CA0C8: 4B9F67C9  bl 0x822c0890
	ctx.lr = 0x828CA0CC;
	sub_822C0890(ctx, base);
	// 828CA0CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CA0D0: 48529359  bl 0x82df3428
	ctx.lr = 0x828CA0D4;
	sub_82DF3428(ctx, base);
	// 828CA0D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828CA0D8: 57CA063F  clrlwi. r10, r30, 0x18
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828CA0DC: C3ABC664  lfs f29, -0x399c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14748 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828CA0E0: 3B800020  li r28, 0x20
	ctx.r[28].s64 = 32;
	// 828CA0E4: 418200E0  beq 0x828ca1c4
	if ctx.cr[0].eq {
	pc = 0x828CA1C4; continue 'dispatch;
	}
	// 828CA0E8: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA0EC: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 828CA0F0: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828CA0F4: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 828CA0F8: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828CA0FC: 485D6635  bl 0x82ea0730
	ctx.lr = 0x828CA100;
	sub_82EA0730(ctx, base);
	// 828CA100: B3830004  sth r28, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[28].u16 ) };
	// 828CA104: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828CA108: 486500E9  bl 0x82f1a1f0
	ctx.lr = 0x828CA10C;
	sub_82F1A1F0(ctx, base);
	// 828CA10C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828CA110: 93C10088  stw r30, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	// 828CA114: 4182000C  beq 0x828ca120
	if ctx.cr[0].eq {
	pc = 0x828CA120; continue 'dispatch;
	}
	// 828CA118: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CA11C: 4BA1E12D  bl 0x822e8248
	ctx.lr = 0x828CA120;
	sub_822E8248(ctx, base);
	// 828CA120: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CA124: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CA128: 388BDFF8  addi r4, r11, -0x2008
	ctx.r[4].s64 = ctx.r[11].s64 + -8200;
	// 828CA12C: 4852F405  bl 0x82df9530
	ctx.lr = 0x828CA130;
	sub_82DF9530(ctx, base);
	// 828CA130: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CA134: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA138: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA13C: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 828CA140: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 828CA144: 419A0024  beq cr6, 0x828ca168
	if ctx.cr[6].eq {
	pc = 0x828CA168; continue 'dispatch;
	}
	// 828CA148: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828CA14C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828CA150: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CA154: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828CA158: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828CA15C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828CA160: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CA164: 4082FFE8  bne 0x828ca14c
	if !ctx.cr[0].eq {
	pc = 0x828CA14C; continue 'dispatch;
	}
	// 828CA168: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828CA16C: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 828CA170: 38A10088  addi r5, r1, 0x88
	ctx.r[5].s64 = ctx.r[1].s64 + 136;
	// 828CA174: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828CA178: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CA17C: 80CB6820  lwz r6, 0x6820(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26656 as u32) ) } as u64;
	// 828CA180: 4BC48F79  bl 0x825130f8
	ctx.lr = 0x828CA184;
	sub_825130F8(ctx, base);
	// 828CA184: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 828CA188: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CA18C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA190: 419A000C  beq cr6, 0x828ca19c
	if ctx.cr[6].eq {
	pc = 0x828CA19C; continue 'dispatch;
	}
	// 828CA194: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CA198: 4BA1E0D1  bl 0x822e8268
	ctx.lr = 0x828CA19C;
	sub_822E8268(ctx, base);
	// 828CA19C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CA1A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CA1A4: 4803ED0D  bl 0x82908eb0
	ctx.lr = 0x828CA1A8;
	sub_82908EB0(ctx, base);
	// 828CA1A8: 38802012  li r4, 0x2012
	ctx.r[4].s64 = 8210;
	// 828CA1AC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828CA1B0: 4BBC5001  bl 0x8248f1b0
	ctx.lr = 0x828CA1B4;
	sub_8248F1B0(ctx, base);
	// 828CA1B4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828CA1B8: 419A000C  beq cr6, 0x828ca1c4
	if ctx.cr[6].eq {
	pc = 0x828CA1C4; continue 'dispatch;
	}
	// 828CA1BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CA1C0: 4BA1E0A9  bl 0x822e8268
	ctx.lr = 0x828CA1C4;
	sub_822E8268(ctx, base);
	// 828CA1C4: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA1C8: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 828CA1CC: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828CA1D0: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 828CA1D4: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828CA1D8: 485D6559  bl 0x82ea0730
	ctx.lr = 0x828CA1DC;
	sub_82EA0730(ctx, base);
	// 828CA1DC: B3830004  sth r28, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[28].u16 ) };
	// 828CA1E0: C0380000  lfs f1, 0(r24)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CA1E4: 4865000D  bl 0x82f1a1f0
	ctx.lr = 0x828CA1E8;
	sub_82F1A1F0(ctx, base);
	// 828CA1E8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CA1EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CA1F0: 3A8BDF30  addi r20, r11, -0x20d0
	ctx.r[20].s64 = ctx.r[11].s64 + -8400;
	// 828CA1F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CA1F8: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828CA1FC: 38A000ED  li r5, 0xed
	ctx.r[5].s64 = 237;
	// 828CA200: 38600038  li r3, 0x38
	ctx.r[3].s64 = 56;
	// 828CA204: 485281E5  bl 0x82df23e8
	ctx.lr = 0x828CA208;
	sub_82DF23E8(ctx, base);
	// 828CA208: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CA20C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828CA210: 41820024  beq 0x828ca234
	if ctx.cr[0].eq {
	pc = 0x828CA234; continue 'dispatch;
	}
	// 828CA214: 357DFFF0  addic. r11, r29, -0x10
	ctx.xer.ca = (ctx.r[29].u32 > (!(-16 as u32)));
	ctx.r[11].s64 = ctx.r[29].s64 + -16;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CA218: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828CA21C: 40820008  bne 0x828ca224
	if !ctx.cr[0].eq {
	pc = 0x828CA224; continue 'dispatch;
	}
	// 828CA220: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CA224: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828CA228: 480953C1  bl 0x8295f5e8
	ctx.lr = 0x828CA22C;
	sub_8295F5E8(ctx, base);
	// 828CA22C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CA230: 48000008  b 0x828ca238
	pc = 0x828CA238; continue 'dispatch;
	// 828CA234: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CA238: 387D0390  addi r3, r29, 0x390
	ctx.r[3].s64 = ctx.r[29].s64 + 912;
	// 828CA23C: 4BE8E3BD  bl 0x827585f8
	ctx.lr = 0x828CA240;
	sub_827585F8(ctx, base);
	// 828CA240: 3A7DFFF0  addi r19, r29, -0x10
	ctx.r[19].s64 = ctx.r[29].s64 + -16;
	// 828CA244: 389D01D4  addi r4, r29, 0x1d4
	ctx.r[4].s64 = ctx.r[29].s64 + 468;
	// 828CA248: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 828CA24C: 4BFFF0D5  bl 0x828c9320
	ctx.lr = 0x828CA250;
	sub_828C9320(ctx, base);
	// 828CA250: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828CA254: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CA258: 485297B1  bl 0x82df3a08
	ctx.lr = 0x828CA25C;
	sub_82DF3A08(ctx, base);
	// 828CA25C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828CA260: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CA264: 80920000  lwz r4, 0(r18)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA268: 480476B9  bl 0x82911920
	ctx.lr = 0x828CA26C;
	sub_82911920(ctx, base);
	// 828CA26C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CA270: 485291B9  bl 0x82df3428
	ctx.lr = 0x828CA274;
	sub_82DF3428(ctx, base);
	// 828CA274: 3F808200  lis r28, -0x7e00
	ctx.r[28].s64 = -2113929216;
	// 828CA278: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CA27C: C03C08A8  lfs f1, 0x8a8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CA280: 4803F869  bl 0x82909ae8
	ctx.lr = 0x828CA284;
	sub_82909AE8(ctx, base);
	// 828CA284: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828CA288: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 828CA28C: 4BF2233D  bl 0x827ec5c8
	ctx.lr = 0x828CA290;
	sub_827EC5C8(ctx, base);
	// 828CA290: 816100AC  lwz r11, 0xac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 828CA294: 82A30000  lwz r21, 0(r3)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA298: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CA29C: 419A000C  beq cr6, 0x828ca2a8
	if ctx.cr[6].eq {
	pc = 0x828CA2A8; continue 'dispatch;
	}
	// 828CA2A0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CA2A4: 4B9F65ED  bl 0x822c0890
	ctx.lr = 0x828CA2A8;
	sub_822C0890(ctx, base);
	// 828CA2A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828CA2AC: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 828CA2B0: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 828CA2B4: C3CB08A4  lfs f30, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828CA2B8: 419A04D0  beq cr6, 0x828ca788
	if ctx.cr[6].eq {
	pc = 0x828CA788; continue 'dispatch;
	}
	// 828CA2BC: 3F60832D  lis r27, -0x7cd3
	ctx.r[27].s64 = -2094202880;
	// 828CA2C0: C01C08A8  lfs f0, 0x8a8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CA2C4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CA2C8: D00100D8  stfs f0, 0xd8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 828CA2CC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828CA2D0: D3C100E0  stfs f30, 0xe0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 828CA2D4: 3BCBDFEC  addi r30, r11, -0x2014
	ctx.r[30].s64 = ctx.r[11].s64 + -8212;
	// 828CA2D8: 93E100DC  stw r31, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[31].u32 ) };
	// 828CA2DC: 9BE100EC  stb r31, 0xec(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[31].u8 ) };
	// 828CA2E0: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828CA2E4: 817BF3F8  lwz r11, -0xc08(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-3080 as u32) ) } as u64;
	// 828CA2E8: 93C100D4  stw r30, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[30].u32 ) };
	// 828CA2EC: C3EA9534  lfs f31, -0x6acc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828CA2F0: D3E100E4  stfs f31, 0xe4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 828CA2F4: D3E100E8  stfs f31, 0xe8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 828CA2F8: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 828CA2FC: 485345CD  bl 0x82dfe8c8
	ctx.lr = 0x828CA300;
	sub_82DFE8C8(ctx, base);
	// 828CA300: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 828CA304: 485345C5  bl 0x82dfe8c8
	ctx.lr = 0x828CA308;
	sub_82DFE8C8(ctx, base);
	// 828CA308: 3F40832D  lis r26, -0x7cd3
	ctx.r[26].s64 = -2094202880;
	// 828CA30C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CA310: C01C08A8  lfs f0, 0x8a8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CA314: D0010108  stfs f0, 0x108(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 828CA318: 93E1010C  stw r31, 0x10c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), ctx.r[31].u32 ) };
	// 828CA31C: 3AEBDFE0  addi r23, r11, -0x2020
	ctx.r[23].s64 = ctx.r[11].s64 + -8224;
	// 828CA320: D3C10110  stfs f30, 0x110(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 828CA324: D3E10114  stfs f31, 0x114(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 828CA328: 9BE1011C  stb r31, 0x11c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), ctx.r[31].u8 ) };
	// 828CA32C: D3E10118  stfs f31, 0x118(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 828CA330: 92E10104  stw r23, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[23].u32 ) };
	// 828CA334: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 828CA338: 817AF3FC  lwz r11, -0xc04(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-3076 as u32) ) } as u64;
	// 828CA33C: 91610100  stw r11, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 828CA340: 48534589  bl 0x82dfe8c8
	ctx.lr = 0x828CA344;
	sub_82DFE8C8(ctx, base);
	// 828CA344: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 828CA348: 48534581  bl 0x82dfe8c8
	ctx.lr = 0x828CA34C;
	sub_82DFE8C8(ctx, base);
	// 828CA34C: 3F20832D  lis r25, -0x7cd3
	ctx.r[25].s64 = -2094202880;
	// 828CA350: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CA354: C01C08A8  lfs f0, 0x8a8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CA358: D0010138  stfs f0, 0x138(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 828CA35C: 93E1013C  stw r31, 0x13c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(316 as u32), ctx.r[31].u32 ) };
	// 828CA360: 39CBDFD4  addi r14, r11, -0x202c
	ctx.r[14].s64 = ctx.r[11].s64 + -8236;
	// 828CA364: D3C10140  stfs f30, 0x140(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 828CA368: D3E10144  stfs f31, 0x144(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 828CA36C: 9BE1014C  stb r31, 0x14c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(332 as u32), ctx.r[31].u8 ) };
	// 828CA370: D3E10148  stfs f31, 0x148(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 828CA374: 91C10134  stw r14, 0x134(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), ctx.r[14].u32 ) };
	// 828CA378: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 828CA37C: 8179F440  lwz r11, -0xbc0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-3008 as u32) ) } as u64;
	// 828CA380: 91610130  stw r11, 0x130(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 828CA384: 48534545  bl 0x82dfe8c8
	ctx.lr = 0x828CA388;
	sub_82DFE8C8(ctx, base);
	// 828CA388: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 828CA38C: 4853453D  bl 0x82dfe8c8
	ctx.lr = 0x828CA390;
	sub_82DFE8C8(ctx, base);
	// 828CA390: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CA394: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828CA398: C01C08A8  lfs f0, 0x8a8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CA39C: D0010168  stfs f0, 0x168(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 828CA3A0: 93E1016C  stw r31, 0x16c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(364 as u32), ctx.r[31].u32 ) };
	// 828CA3A4: 394ADFC8  addi r10, r10, -0x2038
	ctx.r[10].s64 = ctx.r[10].s64 + -8248;
	// 828CA3A8: D3C10170  stfs f30, 0x170(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 828CA3AC: D3E10174  stfs f31, 0x174(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 828CA3B0: 9BE1017C  stb r31, 0x17c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(380 as u32), ctx.r[31].u8 ) };
	// 828CA3B4: D3E10178  stfs f31, 0x178(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 828CA3B8: 91410164  stw r10, 0x164(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(356 as u32), ctx.r[10].u32 ) };
	// 828CA3BC: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 828CA3C0: 816BF42C  lwz r11, -0xbd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3028 as u32) ) } as u64;
	// 828CA3C4: 91610160  stw r11, 0x160(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 828CA3C8: 48534501  bl 0x82dfe8c8
	ctx.lr = 0x828CA3CC;
	sub_82DFE8C8(ctx, base);
	// 828CA3CC: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 828CA3D0: 485344F9  bl 0x82dfe8c8
	ctx.lr = 0x828CA3D4;
	sub_82DFE8C8(ctx, base);
	// 828CA3D4: 3F00832D  lis r24, -0x7cd3
	ctx.r[24].s64 = -2094202880;
	// 828CA3D8: C01C08A8  lfs f0, 0x8a8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CA3DC: 93E1019C  stw r31, 0x19c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(412 as u32), ctx.r[31].u32 ) };
	// 828CA3E0: D0010198  stfs f0, 0x198(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 828CA3E4: 91C10194  stw r14, 0x194(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(404 as u32), ctx.r[14].u32 ) };
	// 828CA3E8: D3C101A0  stfs f30, 0x1a0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 828CA3EC: 9BE101AC  stb r31, 0x1ac(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(428 as u32), ctx.r[31].u8 ) };
	// 828CA3F0: D3E101A4  stfs f31, 0x1a4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(420 as u32), tmp.u32 ) };
	// 828CA3F4: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 828CA3F8: 8178F450  lwz r11, -0xbb0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-2992 as u32) ) } as u64;
	// 828CA3FC: D3E101A8  stfs f31, 0x1a8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 828CA400: 91610190  stw r11, 0x190(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(400 as u32), ctx.r[11].u32 ) };
	// 828CA404: 485344C5  bl 0x82dfe8c8
	ctx.lr = 0x828CA408;
	sub_82DFE8C8(ctx, base);
	// 828CA408: 386101B8  addi r3, r1, 0x1b8
	ctx.r[3].s64 = ctx.r[1].s64 + 440;
	// 828CA40C: 485344BD  bl 0x82dfe8c8
	ctx.lr = 0x828CA410;
	sub_82DFE8C8(ctx, base);
	// 828CA410: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CA414: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828CA418: C01C08A8  lfs f0, 0x8a8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CA41C: D00101C8  stfs f0, 0x1c8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(456 as u32), tmp.u32 ) };
	// 828CA420: 92C101CC  stw r22, 0x1cc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(460 as u32), ctx.r[22].u32 ) };
	// 828CA424: 39CADFBC  addi r14, r10, -0x2044
	ctx.r[14].s64 = ctx.r[10].s64 + -8260;
	// 828CA428: D3C101D0  stfs f30, 0x1d0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(464 as u32), tmp.u32 ) };
	// 828CA42C: D3E101D4  stfs f31, 0x1d4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(468 as u32), tmp.u32 ) };
	// 828CA430: 9BE101DC  stb r31, 0x1dc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(476 as u32), ctx.r[31].u8 ) };
	// 828CA434: D3E101D8  stfs f31, 0x1d8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(472 as u32), tmp.u32 ) };
	// 828CA438: 91C101C4  stw r14, 0x1c4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(452 as u32), ctx.r[14].u32 ) };
	// 828CA43C: 386101E0  addi r3, r1, 0x1e0
	ctx.r[3].s64 = ctx.r[1].s64 + 480;
	// 828CA440: 816BF460  lwz r11, -0xba0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2976 as u32) ) } as u64;
	// 828CA444: 916101C0  stw r11, 0x1c0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), ctx.r[11].u32 ) };
	// 828CA448: 48534481  bl 0x82dfe8c8
	ctx.lr = 0x828CA44C;
	sub_82DFE8C8(ctx, base);
	// 828CA44C: 386101E8  addi r3, r1, 0x1e8
	ctx.r[3].s64 = ctx.r[1].s64 + 488;
	// 828CA450: 48534479  bl 0x82dfe8c8
	ctx.lr = 0x828CA454;
	sub_82DFE8C8(ctx, base);
	// 828CA454: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CA458: C01C08A8  lfs f0, 0x8a8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CA45C: 91C101F4  stw r14, 0x1f4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(500 as u32), ctx.r[14].u32 ) };
	// 828CA460: D00101F8  stfs f0, 0x1f8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(504 as u32), tmp.u32 ) };
	// 828CA464: 92C101FC  stw r22, 0x1fc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(508 as u32), ctx.r[22].u32 ) };
	// 828CA468: D3C10200  stfs f30, 0x200(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(512 as u32), tmp.u32 ) };
	// 828CA46C: 9BE1020C  stb r31, 0x20c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(524 as u32), ctx.r[31].u8 ) };
	// 828CA470: D3E10204  stfs f31, 0x204(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(516 as u32), tmp.u32 ) };
	// 828CA474: 38610210  addi r3, r1, 0x210
	ctx.r[3].s64 = ctx.r[1].s64 + 528;
	// 828CA478: D3E10208  stfs f31, 0x208(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(520 as u32), tmp.u32 ) };
	// 828CA47C: 816BF464  lwz r11, -0xb9c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2972 as u32) ) } as u64;
	// 828CA480: 916101F0  stw r11, 0x1f0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(496 as u32), ctx.r[11].u32 ) };
	// 828CA484: 48534445  bl 0x82dfe8c8
	ctx.lr = 0x828CA488;
	sub_82DFE8C8(ctx, base);
	// 828CA488: 38610218  addi r3, r1, 0x218
	ctx.r[3].s64 = ctx.r[1].s64 + 536;
	// 828CA48C: 4853443D  bl 0x82dfe8c8
	ctx.lr = 0x828CA490;
	sub_82DFE8C8(ctx, base);
	// 828CA490: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CA494: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828CA498: C01C08A8  lfs f0, 0x8a8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CA49C: D0010228  stfs f0, 0x228(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(552 as u32), tmp.u32 ) };
	// 828CA4A0: 93E1022C  stw r31, 0x22c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(556 as u32), ctx.r[31].u32 ) };
	// 828CA4A4: 394ADFB0  addi r10, r10, -0x2050
	ctx.r[10].s64 = ctx.r[10].s64 + -8272;
	// 828CA4A8: D3C10230  stfs f30, 0x230(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(560 as u32), tmp.u32 ) };
	// 828CA4AC: D3E10234  stfs f31, 0x234(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(564 as u32), tmp.u32 ) };
	// 828CA4B0: 9BE1023C  stb r31, 0x23c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(572 as u32), ctx.r[31].u8 ) };
	// 828CA4B4: D3E10238  stfs f31, 0x238(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(568 as u32), tmp.u32 ) };
	// 828CA4B8: 91410224  stw r10, 0x224(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(548 as u32), ctx.r[10].u32 ) };
	// 828CA4BC: 38610240  addi r3, r1, 0x240
	ctx.r[3].s64 = ctx.r[1].s64 + 576;
	// 828CA4C0: 816BF484  lwz r11, -0xb7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2940 as u32) ) } as u64;
	// 828CA4C4: 91610220  stw r11, 0x220(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(544 as u32), ctx.r[11].u32 ) };
	// 828CA4C8: 48534401  bl 0x82dfe8c8
	ctx.lr = 0x828CA4CC;
	sub_82DFE8C8(ctx, base);
	// 828CA4CC: 38610248  addi r3, r1, 0x248
	ctx.r[3].s64 = ctx.r[1].s64 + 584;
	// 828CA4D0: 485343F9  bl 0x82dfe8c8
	ctx.lr = 0x828CA4D4;
	sub_82DFE8C8(ctx, base);
	// 828CA4D4: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CA4D8: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828CA4DC: C01C08A8  lfs f0, 0x8a8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CA4E0: D0010258  stfs f0, 0x258(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(600 as u32), tmp.u32 ) };
	// 828CA4E4: 92C1025C  stw r22, 0x25c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(604 as u32), ctx.r[22].u32 ) };
	// 828CA4E8: 394ADFA4  addi r10, r10, -0x205c
	ctx.r[10].s64 = ctx.r[10].s64 + -8284;
	// 828CA4EC: D3C10260  stfs f30, 0x260(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(608 as u32), tmp.u32 ) };
	// 828CA4F0: D3E10264  stfs f31, 0x264(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(612 as u32), tmp.u32 ) };
	// 828CA4F4: 9BE1026C  stb r31, 0x26c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(620 as u32), ctx.r[31].u8 ) };
	// 828CA4F8: D3E10268  stfs f31, 0x268(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(616 as u32), tmp.u32 ) };
	// 828CA4FC: 91410254  stw r10, 0x254(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(596 as u32), ctx.r[10].u32 ) };
	// 828CA500: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 828CA504: 816B4A84  lwz r11, 0x4a84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19076 as u32) ) } as u64;
	// 828CA508: 91610250  stw r11, 0x250(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(592 as u32), ctx.r[11].u32 ) };
	// 828CA50C: 485343BD  bl 0x82dfe8c8
	ctx.lr = 0x828CA510;
	sub_82DFE8C8(ctx, base);
	// 828CA510: 38610278  addi r3, r1, 0x278
	ctx.r[3].s64 = ctx.r[1].s64 + 632;
	// 828CA514: 485343B5  bl 0x82dfe8c8
	ctx.lr = 0x828CA518;
	sub_82DFE8C8(ctx, base);
	// 828CA518: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CA51C: C01C08A8  lfs f0, 0x8a8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CA520: 92C1028C  stw r22, 0x28c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(652 as u32), ctx.r[22].u32 ) };
	// 828CA524: D0010288  stfs f0, 0x288(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(648 as u32), tmp.u32 ) };
	// 828CA528: 93C10284  stw r30, 0x284(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(644 as u32), ctx.r[30].u32 ) };
	// 828CA52C: D3C10290  stfs f30, 0x290(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(656 as u32), tmp.u32 ) };
	// 828CA530: 9BE1029C  stb r31, 0x29c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(668 as u32), ctx.r[31].u8 ) };
	// 828CA534: D3E10294  stfs f31, 0x294(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(660 as u32), tmp.u32 ) };
	// 828CA538: 386102A0  addi r3, r1, 0x2a0
	ctx.r[3].s64 = ctx.r[1].s64 + 672;
	// 828CA53C: D3E10298  stfs f31, 0x298(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(664 as u32), tmp.u32 ) };
	// 828CA540: 816BF480  lwz r11, -0xb80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2944 as u32) ) } as u64;
	// 828CA544: 91610280  stw r11, 0x280(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(640 as u32), ctx.r[11].u32 ) };
	// 828CA548: 48534381  bl 0x82dfe8c8
	ctx.lr = 0x828CA54C;
	sub_82DFE8C8(ctx, base);
	// 828CA54C: 386102A8  addi r3, r1, 0x2a8
	ctx.r[3].s64 = ctx.r[1].s64 + 680;
	// 828CA550: 48534379  bl 0x82dfe8c8
	ctx.lr = 0x828CA554;
	sub_82DFE8C8(ctx, base);
	// 828CA554: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CA558: C01C08A8  lfs f0, 0x8a8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CA55C: 92C102BC  stw r22, 0x2bc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(700 as u32), ctx.r[22].u32 ) };
	// 828CA560: D00102B8  stfs f0, 0x2b8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(696 as u32), tmp.u32 ) };
	// 828CA564: 92E102B4  stw r23, 0x2b4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(692 as u32), ctx.r[23].u32 ) };
	// 828CA568: D3C102C0  stfs f30, 0x2c0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(704 as u32), tmp.u32 ) };
	// 828CA56C: 9BE102CC  stb r31, 0x2cc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(716 as u32), ctx.r[31].u8 ) };
	// 828CA570: D3E102C4  stfs f31, 0x2c4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(708 as u32), tmp.u32 ) };
	// 828CA574: 386102D0  addi r3, r1, 0x2d0
	ctx.r[3].s64 = ctx.r[1].s64 + 720;
	// 828CA578: D3E102C8  stfs f31, 0x2c8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(712 as u32), tmp.u32 ) };
	// 828CA57C: 816BF47C  lwz r11, -0xb84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2948 as u32) ) } as u64;
	// 828CA580: 916102B0  stw r11, 0x2b0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(688 as u32), ctx.r[11].u32 ) };
	// 828CA584: 48534345  bl 0x82dfe8c8
	ctx.lr = 0x828CA588;
	sub_82DFE8C8(ctx, base);
	// 828CA588: 386102D8  addi r3, r1, 0x2d8
	ctx.r[3].s64 = ctx.r[1].s64 + 728;
	// 828CA58C: 4853433D  bl 0x82dfe8c8
	ctx.lr = 0x828CA590;
	sub_82DFE8C8(ctx, base);
	// 828CA590: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828CA594: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CA598: 38A00111  li r5, 0x111
	ctx.r[5].s64 = 273;
	// 828CA59C: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828CA5A0: 4B9F5E39  bl 0x822c03d8
	ctx.lr = 0x828CA5A4;
	sub_822C03D8(ctx, base);
	// 828CA5A4: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828CA5A8: 4182001C  beq 0x828ca5c4
	if ctx.cr[0].eq {
	pc = 0x828CA5C4; continue 'dispatch;
	}
	// 828CA5AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CA5B0: 4BF20701  bl 0x827eacb0
	ctx.lr = 0x828CA5B4;
	sub_827EACB0(ctx, base);
	// 828CA5B4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828CA5B8: 396B09D8  addi r11, r11, 0x9d8
	ctx.r[11].s64 = ctx.r[11].s64 + 2520;
	// 828CA5BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CA5C0: 48000008  b 0x828ca5c8
	pc = 0x828CA5C8; continue 'dispatch;
	// 828CA5C4: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 828CA5C8: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 828CA5CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CA5D0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828CA5D4: 4BF9C60D  bl 0x82866be0
	ctx.lr = 0x828CA5D8;
	sub_82866BE0(ctx, base);
	// 828CA5D8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828CA5DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CA5E0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828CA5E4: 4B9F5A1D  bl 0x822c0000
	ctx.lr = 0x828CA5E8;
	sub_822C0000(ctx, base);
	// 828CA5E8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828CA5EC: 3BDD01CC  addi r30, r29, 0x1cc
	ctx.r[30].s64 = ctx.r[29].s64 + 460;
	// 828CA5F0: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 828CA5F4: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 828CA5F8: 917D01CC  stw r11, 0x1cc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(460 as u32), ctx.r[11].u32 ) };
	// 828CA5FC: 4B9F9E65  bl 0x822c4460
	ctx.lr = 0x828CA600;
	sub_822C4460(ctx, base);
	// 828CA600: 817D01CC  lwz r11, 0x1cc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(460 as u32) ) } as u64;
	// 828CA604: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828CA608: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828CA60C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CA610: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828CA614: 69770001  xori r23, r11, 1
	ctx.r[23].u64 = ctx.r[11].u64 ^ 1;
	// 828CA618: 419A0008  beq cr6, 0x828ca620
	if ctx.cr[6].eq {
	pc = 0x828CA620; continue 'dispatch;
	}
	// 828CA61C: 4B9F6275  bl 0x822c0890
	ctx.lr = 0x828CA620;
	sub_822C0890(ctx, base);
	// 828CA620: 56EB063F  clrlwi. r11, r23, 0x18
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CA624: 41820068  beq 0x828ca68c
	if ctx.cr[0].eq {
	pc = 0x828CA68C; continue 'dispatch;
	}
	// 828CA628: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CA62C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CA630: 388BDC74  addi r4, r11, -0x238c
	ctx.r[4].s64 = ctx.r[11].s64 + -9100;
	// 828CA634: 485293D5  bl 0x82df3a08
	ctx.lr = 0x828CA638;
	sub_82DF3A08(ctx, base);
	// 828CA638: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828CA63C: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828CA640: 3AE10058  addi r23, r1, 0x58
	ctx.r[23].s64 = ctx.r[1].s64 + 88;
	// 828CA644: 81DE0000  lwz r14, 0(r30)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA648: 4BC44E81  bl 0x8250f4c8
	ctx.lr = 0x828CA64C;
	sub_8250F4C8(ctx, base);
	// 828CA64C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CA650: C03C08A8  lfs f1, 0x8a8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CA654: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 828CA658: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 828CA65C: 4BF2030D  bl 0x827ea968
	ctx.lr = 0x828CA660;
	sub_827EA968(ctx, base);
	// 828CA660: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828CA664: 4852762D  bl 0x82df1c90
	ctx.lr = 0x828CA668;
	sub_82DF1C90(ctx, base);
	// 828CA668: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CA66C: 48528DBD  bl 0x82df3428
	ctx.lr = 0x828CA670;
	sub_82DF3428(ctx, base);
	// 828CA670: 38A0000B  li r5, 0xb
	ctx.r[5].s64 = 11;
	// 828CA674: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 828CA678: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA67C: 4BF20045  bl 0x827ea6c0
	ctx.lr = 0x828CA680;
	sub_827EA6C0(ctx, base);
	// 828CA680: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828CA684: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA688: 4BF20041  bl 0x827ea6c8
	ctx.lr = 0x828CA68C;
	sub_827EA6C8(ctx, base);
	// 828CA68C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CA690: 4BF21B41  bl 0x827ec1d0
	ctx.lr = 0x828CA694;
	sub_827EC1D0(ctx, base);
	// 828CA694: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828CA698: 418200EC  beq 0x828ca784
	if ctx.cr[0].eq {
	pc = 0x828CA784; continue 'dispatch;
	}
	// 828CA69C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CA6A0: 809BF3F8  lwz r4, -0xc08(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-3080 as u32) ) } as u64;
	// 828CA6A4: 48529365  bl 0x82df3a08
	ctx.lr = 0x828CA6A8;
	sub_82DF3A08(ctx, base);
	// 828CA6A8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828CA6AC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828CA6B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CA6B4: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828CA6B8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828CA6BC: 4BF1FC7D  bl 0x827ea338
	ctx.lr = 0x828CA6C0;
	sub_827EA338(ctx, base);
	// 828CA6C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CA6C4: 48528D65  bl 0x82df3428
	ctx.lr = 0x828CA6C8;
	sub_82DF3428(ctx, base);
	// 828CA6C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CA6CC: 809AF3FC  lwz r4, -0xc04(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-3076 as u32) ) } as u64;
	// 828CA6D0: 48529339  bl 0x82df3a08
	ctx.lr = 0x828CA6D4;
	sub_82DF3A08(ctx, base);
	// 828CA6D4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828CA6D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CA6DC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828CA6E0: 4BF1FC59  bl 0x827ea338
	ctx.lr = 0x828CA6E4;
	sub_827EA338(ctx, base);
	// 828CA6E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CA6E8: 48528D41  bl 0x82df3428
	ctx.lr = 0x828CA6EC;
	sub_82DF3428(ctx, base);
	// 828CA6EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CA6F0: 8099F440  lwz r4, -0xbc0(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-3008 as u32) ) } as u64;
	// 828CA6F4: 48529315  bl 0x82df3a08
	ctx.lr = 0x828CA6F8;
	sub_82DF3A08(ctx, base);
	// 828CA6F8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828CA6FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CA700: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828CA704: 4BF1FC35  bl 0x827ea338
	ctx.lr = 0x828CA708;
	sub_827EA338(ctx, base);
	// 828CA708: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CA70C: 48528D1D  bl 0x82df3428
	ctx.lr = 0x828CA710;
	sub_82DF3428(ctx, base);
	// 828CA710: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CA714: 8098F450  lwz r4, -0xbb0(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-2992 as u32) ) } as u64;
	// 828CA718: 485292F1  bl 0x82df3a08
	ctx.lr = 0x828CA71C;
	sub_82DF3A08(ctx, base);
	// 828CA71C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828CA720: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CA724: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828CA728: 4BF1FC11  bl 0x827ea338
	ctx.lr = 0x828CA72C;
	sub_827EA338(ctx, base);
	// 828CA72C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CA730: 48528CF9  bl 0x82df3428
	ctx.lr = 0x828CA734;
	sub_82DF3428(ctx, base);
	// 828CA734: 3D60822C  lis r11, -0x7dd4
	ctx.r[11].s64 = -2111045632;
	// 828CA738: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828CA73C: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828CA740: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 828CA744: 388AC15C  addi r4, r10, -0x3ea4
	ctx.r[4].s64 = ctx.r[10].s64 + -16036;
	// 828CA748: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CA74C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828CA750: 485292B9  bl 0x82df3a08
	ctx.lr = 0x828CA754;
	sub_82DF3A08(ctx, base);
	// 828CA754: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CA758: 92610098  stw r19, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[19].u32 ) };
	// 828CA75C: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828CA760: E8A10098  ld r5, 0x98(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 828CA764: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828CA768: 4BFFF759  bl 0x828c9ec0
	ctx.lr = 0x828CA76C;
	sub_828C9EC0(ctx, base);
	// 828CA76C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828CA770: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828CA774: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CA778: 4BF20091  bl 0x827ea808
	ctx.lr = 0x828CA77C;
	sub_827EA808(ctx, base);
	// 828CA77C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CA780: 48528CA9  bl 0x82df3428
	ctx.lr = 0x828CA784;
	sub_82DF3428(ctx, base);
	// 828CA784: 83010050  lwz r24, 0x50(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CA788: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828CA78C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CA790: 38A00126  li r5, 0x126
	ctx.r[5].s64 = 294;
	// 828CA794: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 828CA798: 4B9F5C41  bl 0x822c03d8
	ctx.lr = 0x828CA79C;
	sub_822C03D8(ctx, base);
	// 828CA79C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CA7A0: 41820020  beq 0x828ca7c0
	if ctx.cr[0].eq {
	pc = 0x828CA7C0; continue 'dispatch;
	}
	// 828CA7A4: 357DFFF0  addic. r11, r29, -0x10
	ctx.xer.ca = (ctx.r[29].u32 > (!(-16 as u32)));
	ctx.r[11].s64 = ctx.r[29].s64 + -16;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CA7A8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828CA7AC: 40820008  bne 0x828ca7b4
	if !ctx.cr[0].eq {
	pc = 0x828CA7B4; continue 'dispatch;
	}
	// 828CA7B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CA7B4: 48000845  bl 0x828caff8
	ctx.lr = 0x828CA7B8;
	sub_828CAFF8(ctx, base);
	// 828CA7B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CA7BC: 48000008  b 0x828ca7c4
	pc = 0x828CA7C4; continue 'dispatch;
	// 828CA7C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CA7C4: 3B3D00E4  addi r25, r29, 0xe4
	ctx.r[25].s64 = ctx.r[29].s64 + 228;
	// 828CA7C8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828CA7CC: 4BFFE545  bl 0x828c8d10
	ctx.lr = 0x828CA7D0;
	sub_828C8D10(ctx, base);
	// 828CA7D0: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828CA7D4: 3B4B0D78  addi r26, r11, 0xd78
	ctx.r[26].s64 = ctx.r[11].s64 + 3448;
	// 828CA7D8: 83DD00E4  lwz r30, 0xe4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(228 as u32) ) } as u64;
	// 828CA7DC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828CA7E0: 419A00EC  beq cr6, 0x828ca8cc
	if ctx.cr[6].eq {
	pc = 0x828CA8CC; continue 'dispatch;
	}
	// 828CA7E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CA7E8: 837E0000  lwz r27, 0(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA7EC: 48148E95  bl 0x82a13680
	ctx.lr = 0x828CA7F0;
	sub_82A13680(ctx, base);
	// 828CA7F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CA7F4: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 828CA7F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CA7FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CA800: 4E800421  bctrl
	ctx.lr = 0x828CA804;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA804: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CA808: 837E0000  lwz r27, 0(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA80C: 48148E7D  bl 0x82a13688
	ctx.lr = 0x828CA810;
	sub_82A13688(ctx, base);
	// 828CA810: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CA814: 817B0014  lwz r11, 0x14(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 828CA818: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CA81C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CA820: 4E800421  bctrl
	ctx.lr = 0x828CA824;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA824: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CA828: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828CA82C: 4804C56D  bl 0x82916d98
	ctx.lr = 0x828CA830;
	sub_82916D98(ctx, base);
	// 828CA830: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA834: C01A008C  lfs f0, 0x8c(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CA838: D00B0078  stfs f0, 0x78(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828CA83C: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 828CA840: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CA844: 419A0008  beq cr6, 0x828ca84c
	if ctx.cr[6].eq {
	pc = 0x828CA84C; continue 'dispatch;
	}
	// 828CA848: 4B9F6049  bl 0x822c0890
	ctx.lr = 0x828CA84C;
	sub_822C0890(ctx, base);
	// 828CA84C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828CA850: C07C08A8  lfs f3, 0x8a8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(2216 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828CA854: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828CA858: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 828CA85C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828CA860: C02B9450  lfs f1, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CA864: 48056B4D  bl 0x829213b0
	ctx.lr = 0x828CA868;
	sub_829213B0(ctx, base);
	// 828CA868: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA86C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 828CA870: 9BE100A0  stb r31, 0xa0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[31].u8 ) };
	// 828CA874: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CA878: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828CA87C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CA880: 4E800421  bctrl
	ctx.lr = 0x828CA884;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA884: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA888: 888100A0  lbz r4, 0xa0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 828CA88C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CA890: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828CA894: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CA898: 4E800421  bctrl
	ctx.lr = 0x828CA89C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA89C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828CA8A0: 4BF25CF1  bl 0x827f0590
	ctx.lr = 0x828CA8A4;
	sub_827F0590(ctx, base);
	// 828CA8A4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828CA8A8: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 828CA8AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CA8B0: C00BD7BC  lfs f0, -0x2844(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CA8B4: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828CA8B8: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828CA8BC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA8C0: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 828CA8C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CA8C8: 4E800421  bctrl
	ctx.lr = 0x828CA8CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CA8CC: 80990000  lwz r4, 0(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CA8D0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828CA8D4: 419A04B4  beq cr6, 0x828cad88
	if ctx.cr[6].eq {
	pc = 0x828CAD88; continue 'dispatch;
	}
	// 828CA8D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CA8DC: 4BF217CD  bl 0x827ec0a8
	ctx.lr = 0x828CA8E0;
	sub_827EC0A8(ctx, base);
	// 828CA8E0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828CA8E4: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828CA8E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CA8EC: 388BCB18  addi r4, r11, -0x34e8
	ctx.r[4].s64 = ctx.r[11].s64 + -13544;
	// 828CA8F0: 4BFF5889  bl 0x828c0178
	ctx.lr = 0x828CA8F4;
	sub_828C0178(ctx, base);
	// 828CA8F4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CA8F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CA8FC: 3BDD00FC  addi r30, r29, 0xfc
	ctx.r[30].s64 = ctx.r[29].s64 + 252;
	// 828CA900: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 828CA904: 808B0B70  lwz r4, 0xb70(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2928 as u32) ) } as u64;
	// 828CA908: 48529101  bl 0x82df3a08
	ctx.lr = 0x828CA90C;
	sub_82DF3A08(ctx, base);
	// 828CA90C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CA910: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CA914: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828CA918: 48591841  bl 0x82e5c158
	ctx.lr = 0x828CA91C;
	sub_82E5C158(ctx, base);
	// 828CA91C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828CA920: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828CA924: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CA928: 388BBFA0  addi r4, r11, -0x4060
	ctx.r[4].s64 = ctx.r[11].s64 + -16480;
	// 828CA92C: 4BF9E77D  bl 0x828690a8
	ctx.lr = 0x828CA930;
	sub_828690A8(ctx, base);
	// 828CA930: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CA934: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CA938: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 828CA93C: 808B0B98  lwz r4, 0xb98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2968 as u32) ) } as u64;
	// 828CA940: 485290C9  bl 0x82df3a08
	ctx.lr = 0x828CA944;
	sub_82DF3A08(ctx, base);
	// 828CA944: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CA948: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CA94C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828CA950: 48591809  bl 0x82e5c158
	ctx.lr = 0x828CA954;
	sub_82E5C158(ctx, base);
	// 828CA954: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828CA958: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828CA95C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CA960: 388B8AD0  addi r4, r11, -0x7530
	ctx.r[4].s64 = ctx.r[11].s64 + -30000;
	// 828CA964: 4BF9E745  bl 0x828690a8
	ctx.lr = 0x828CA968;
	sub_828690A8(ctx, base);
	// 828CA968: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CA96C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CA970: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 828CA974: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828CA978: 48529091  bl 0x82df3a08
	ctx.lr = 0x828CA97C;
	sub_82DF3A08(ctx, base);
	// 828CA97C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CA980: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CA984: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828CA988: 485917D1  bl 0x82e5c158
	ctx.lr = 0x828CA98C;
	sub_82E5C158(ctx, base);
	// 828CA98C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828CA990: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828CA994: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CA998: 388B8D88  addi r4, r11, -0x7278
	ctx.r[4].s64 = ctx.r[11].s64 + -29304;
	// 828CA99C: 4BF9E70D  bl 0x828690a8
	ctx.lr = 0x828CA9A0;
	sub_828690A8(ctx, base);
	// 828CA9A0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CA9A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CA9A8: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 828CA9AC: 808B0B6C  lwz r4, 0xb6c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2924 as u32) ) } as u64;
	// 828CA9B0: 48529059  bl 0x82df3a08
	ctx.lr = 0x828CA9B4;
	sub_82DF3A08(ctx, base);
	// 828CA9B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CA9B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CA9BC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828CA9C0: 48591799  bl 0x82e5c158
	ctx.lr = 0x828CA9C4;
	sub_82E5C158(ctx, base);
	// 828CA9C4: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828CA9C8: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828CA9CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CA9D0: 388B9EF8  addi r4, r11, -0x6108
	ctx.r[4].s64 = ctx.r[11].s64 + -24840;
	// 828CA9D4: 4BF9E6D5  bl 0x828690a8
	ctx.lr = 0x828CA9D8;
	sub_828690A8(ctx, base);
	// 828CA9D8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CA9DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CA9E0: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 828CA9E4: 808B0B64  lwz r4, 0xb64(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2916 as u32) ) } as u64;
	// 828CA9E8: 48529021  bl 0x82df3a08
	ctx.lr = 0x828CA9EC;
	sub_82DF3A08(ctx, base);
	// 828CA9EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CA9F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CA9F4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828CA9F8: 48591761  bl 0x82e5c158
	ctx.lr = 0x828CA9FC;
	sub_82E5C158(ctx, base);
	// 828CA9FC: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828CAA00: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828CAA04: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CAA08: 388BDD20  addi r4, r11, -0x22e0
	ctx.r[4].s64 = ctx.r[11].s64 + -8928;
	// 828CAA0C: 4BFFF145  bl 0x828c9b50
	ctx.lr = 0x828CAA10;
	sub_828C9B50(ctx, base);
	// 828CAA10: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CAA14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CAA18: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 828CAA1C: 808B0B10  lwz r4, 0xb10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2832 as u32) ) } as u64;
	// 828CAA20: 48528FE9  bl 0x82df3a08
	ctx.lr = 0x828CAA24;
	sub_82DF3A08(ctx, base);
	// 828CAA24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CAA28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CAA2C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828CAA30: 48591729  bl 0x82e5c158
	ctx.lr = 0x828CAA34;
	sub_82E5C158(ctx, base);
	// 828CAA34: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828CAA38: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828CAA3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CAA40: 388BDCB0  addi r4, r11, -0x2350
	ctx.r[4].s64 = ctx.r[11].s64 + -9040;
	// 828CAA44: 4BFFF10D  bl 0x828c9b50
	ctx.lr = 0x828CAA48;
	sub_828C9B50(ctx, base);
	// 828CAA48: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CAA4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CAA50: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 828CAA54: 808B0B34  lwz r4, 0xb34(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2868 as u32) ) } as u64;
	// 828CAA58: 48528FB1  bl 0x82df3a08
	ctx.lr = 0x828CAA5C;
	sub_82DF3A08(ctx, base);
	// 828CAA5C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CAA60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CAA64: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828CAA68: 485916F1  bl 0x82e5c158
	ctx.lr = 0x828CAA6C;
	sub_82E5C158(ctx, base);
	// 828CAA6C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828CAA70: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828CAA74: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CAA78: 388BDD90  addi r4, r11, -0x2270
	ctx.r[4].s64 = ctx.r[11].s64 + -8816;
	// 828CAA7C: 4BFFF155  bl 0x828c9bd0
	ctx.lr = 0x828CAA80;
	sub_828C9BD0(ctx, base);
	// 828CAA80: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CAA84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CAA88: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 828CAA8C: 808B0B78  lwz r4, 0xb78(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2936 as u32) ) } as u64;
	// 828CAA90: 48528F79  bl 0x82df3a08
	ctx.lr = 0x828CAA94;
	sub_82DF3A08(ctx, base);
	// 828CAA94: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CAA98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CAA9C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828CAAA0: 485916B9  bl 0x82e5c158
	ctx.lr = 0x828CAAA4;
	sub_82E5C158(ctx, base);
	// 828CAAA4: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828CAAA8: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828CAAAC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CAAB0: 388BE678  addi r4, r11, -0x1988
	ctx.r[4].s64 = ctx.r[11].s64 + -6536;
	// 828CAAB4: 4BFFF09D  bl 0x828c9b50
	ctx.lr = 0x828CAAB8;
	sub_828C9B50(ctx, base);
	// 828CAAB8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CAABC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CAAC0: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 828CAAC4: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828CAAC8: 48528F41  bl 0x82df3a08
	ctx.lr = 0x828CAACC;
	sub_82DF3A08(ctx, base);
	// 828CAACC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CAAD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CAAD4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828CAAD8: 48591681  bl 0x82e5c158
	ctx.lr = 0x828CAADC;
	sub_82E5C158(ctx, base);
	// 828CAADC: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828CAAE0: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828CAAE4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CAAE8: 388BE6E8  addi r4, r11, -0x1918
	ctx.r[4].s64 = ctx.r[11].s64 + -6424;
	// 828CAAEC: 4BFFF065  bl 0x828c9b50
	ctx.lr = 0x828CAAF0;
	sub_828C9B50(ctx, base);
	// 828CAAF0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CAAF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CAAF8: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 828CAAFC: 808B0AF4  lwz r4, 0xaf4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2804 as u32) ) } as u64;
	// 828CAB00: 48528F09  bl 0x82df3a08
	ctx.lr = 0x828CAB04;
	sub_82DF3A08(ctx, base);
	// 828CAB04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CAB08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CAB0C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828CAB10: 48591649  bl 0x82e5c158
	ctx.lr = 0x828CAB14;
	sub_82E5C158(ctx, base);
	// 828CAB14: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828CAB18: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828CAB1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CAB20: 388BDB60  addi r4, r11, -0x24a0
	ctx.r[4].s64 = ctx.r[11].s64 + -9376;
	// 828CAB24: 4BFFF02D  bl 0x828c9b50
	ctx.lr = 0x828CAB28;
	sub_828C9B50(ctx, base);
	// 828CAB28: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CAB2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CAB30: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 828CAB34: 808B0B30  lwz r4, 0xb30(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2864 as u32) ) } as u64;
	// 828CAB38: 48528ED1  bl 0x82df3a08
	ctx.lr = 0x828CAB3C;
	sub_82DF3A08(ctx, base);
	// 828CAB3C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CAB40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CAB44: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828CAB48: 48591611  bl 0x82e5c158
	ctx.lr = 0x828CAB4C;
	sub_82E5C158(ctx, base);
	// 828CAB4C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828CAB50: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828CAB54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CAB58: 388BBE48  addi r4, r11, -0x41b8
	ctx.r[4].s64 = ctx.r[11].s64 + -16824;
	// 828CAB5C: 4BFFEFF5  bl 0x828c9b50
	ctx.lr = 0x828CAB60;
	sub_828C9B50(ctx, base);
	// 828CAB60: 3F60832D  lis r27, -0x7cd3
	ctx.r[27].s64 = -2094202880;
	// 828CAB64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CAB68: 3AE10060  addi r23, r1, 0x60
	ctx.r[23].s64 = ctx.r[1].s64 + 96;
	// 828CAB6C: 809B0AF0  lwz r4, 0xaf0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(2800 as u32) ) } as u64;
	// 828CAB70: 48528E99  bl 0x82df3a08
	ctx.lr = 0x828CAB74;
	sub_82DF3A08(ctx, base);
	// 828CAB74: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CAB78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CAB7C: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 828CAB80: 485915D9  bl 0x82e5c158
	ctx.lr = 0x828CAB84;
	sub_82E5C158(ctx, base);
	// 828CAB84: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828CAB88: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828CAB8C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CAB90: 388BDC40  addi r4, r11, -0x23c0
	ctx.r[4].s64 = ctx.r[11].s64 + -9152;
	// 828CAB94: 4BFFEFBD  bl 0x828c9b50
	ctx.lr = 0x828CAB98;
	sub_828C9B50(ctx, base);
	// 828CAB98: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CAB9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CABA0: 3AE10060  addi r23, r1, 0x60
	ctx.r[23].s64 = ctx.r[1].s64 + 96;
	// 828CABA4: 808B0B50  lwz r4, 0xb50(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2896 as u32) ) } as u64;
	// 828CABA8: 48528E61  bl 0x82df3a08
	ctx.lr = 0x828CABAC;
	sub_82DF3A08(ctx, base);
	// 828CABAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CABB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CABB4: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 828CABB8: 485915A1  bl 0x82e5c158
	ctx.lr = 0x828CABBC;
	sub_82E5C158(ctx, base);
	// 828CABBC: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828CABC0: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828CABC4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CABC8: 388BE678  addi r4, r11, -0x1988
	ctx.r[4].s64 = ctx.r[11].s64 + -6536;
	// 828CABCC: 4BFFEF85  bl 0x828c9b50
	ctx.lr = 0x828CABD0;
	sub_828C9B50(ctx, base);
	// 828CABD0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CABD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CABD8: 3AE10060  addi r23, r1, 0x60
	ctx.r[23].s64 = ctx.r[1].s64 + 96;
	// 828CABDC: 808B0AF8  lwz r4, 0xaf8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2808 as u32) ) } as u64;
	// 828CABE0: 48528E29  bl 0x82df3a08
	ctx.lr = 0x828CABE4;
	sub_82DF3A08(ctx, base);
	// 828CABE4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CABE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CABEC: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 828CABF0: 48591569  bl 0x82e5c158
	ctx.lr = 0x828CABF4;
	sub_82E5C158(ctx, base);
	// 828CABF4: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828CABF8: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828CABFC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CAC00: 388BE3B0  addi r4, r11, -0x1c50
	ctx.r[4].s64 = ctx.r[11].s64 + -7248;
	// 828CAC04: 4BFFF04D  bl 0x828c9c50
	ctx.lr = 0x828CAC08;
	sub_828C9C50(ctx, base);
	// 828CAC08: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CAC0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CAC10: 3AE10060  addi r23, r1, 0x60
	ctx.r[23].s64 = ctx.r[1].s64 + 96;
	// 828CAC14: 808B0AFC  lwz r4, 0xafc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2812 as u32) ) } as u64;
	// 828CAC18: 48528DF1  bl 0x82df3a08
	ctx.lr = 0x828CAC1C;
	sub_82DF3A08(ctx, base);
	// 828CAC1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CAC20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CAC24: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 828CAC28: 48591531  bl 0x82e5c158
	ctx.lr = 0x828CAC2C;
	sub_82E5C158(ctx, base);
	// 828CAC2C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828CAC30: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828CAC34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CAC38: 388BDE00  addi r4, r11, -0x2200
	ctx.r[4].s64 = ctx.r[11].s64 + -8704;
	// 828CAC3C: 4BFFEF15  bl 0x828c9b50
	ctx.lr = 0x828CAC40;
	sub_828C9B50(ctx, base);
	// 828CAC40: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CAC44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CAC48: 3AE10060  addi r23, r1, 0x60
	ctx.r[23].s64 = ctx.r[1].s64 + 96;
	// 828CAC4C: 808B0B08  lwz r4, 0xb08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2824 as u32) ) } as u64;
	// 828CAC50: 48528DB9  bl 0x82df3a08
	ctx.lr = 0x828CAC54;
	sub_82DF3A08(ctx, base);
	// 828CAC54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CAC58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CAC5C: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 828CAC60: 485914F9  bl 0x82e5c158
	ctx.lr = 0x828CAC64;
	sub_82E5C158(ctx, base);
	// 828CAC64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CAC68: 809B0AF0  lwz r4, 0xaf0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(2800 as u32) ) } as u64;
	// 828CAC6C: 48528D9D  bl 0x82df3a08
	ctx.lr = 0x828CAC70;
	sub_82DF3A08(ctx, base);
	// 828CAC70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CAC74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CAC78: 4BF22071  bl 0x827ecce8
	ctx.lr = 0x828CAC7C;
	sub_827ECCE8(ctx, base);
	// 828CAC7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CAC80: 485287A9  bl 0x82df3428
	ctx.lr = 0x828CAC84;
	sub_82DF3428(ctx, base);
	// 828CAC84: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828CAC88: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828CAC8C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CAC90: 388BE810  addi r4, r11, -0x17f0
	ctx.r[4].s64 = ctx.r[11].s64 + -6128;
	// 828CAC94: 4BF9E415  bl 0x828690a8
	ctx.lr = 0x828CAC98;
	sub_828690A8(ctx, base);
	// 828CAC98: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CAC9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CACA0: 3BDD0164  addi r30, r29, 0x164
	ctx.r[30].s64 = ctx.r[29].s64 + 356;
	// 828CACA4: 808B0BE8  lwz r4, 0xbe8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3048 as u32) ) } as u64;
	// 828CACA8: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 828CACAC: 48528D5D  bl 0x82df3a08
	ctx.lr = 0x828CACB0;
	sub_82DF3A08(ctx, base);
	// 828CACB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CACB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CACB8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828CACBC: 4859149D  bl 0x82e5c158
	ctx.lr = 0x828CACC0;
	sub_82E5C158(ctx, base);
	// 828CACC0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828CACC4: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828CACC8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CACCC: 388BDE20  addi r4, r11, -0x21e0
	ctx.r[4].s64 = ctx.r[11].s64 + -8672;
	// 828CACD0: 4BF9E3D9  bl 0x828690a8
	ctx.lr = 0x828CACD4;
	sub_828690A8(ctx, base);
	// 828CACD4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CACD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CACDC: 3B610060  addi r27, r1, 0x60
	ctx.r[27].s64 = ctx.r[1].s64 + 96;
	// 828CACE0: 808B0BE0  lwz r4, 0xbe0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3040 as u32) ) } as u64;
	// 828CACE4: 48528D25  bl 0x82df3a08
	ctx.lr = 0x828CACE8;
	sub_82DF3A08(ctx, base);
	// 828CACE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CACEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CACF0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828CACF4: 48591465  bl 0x82e5c158
	ctx.lr = 0x828CACF8;
	sub_82E5C158(ctx, base);
	// 828CACF8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828CACFC: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828CAD00: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CAD04: 388BD8C8  addi r4, r11, -0x2738
	ctx.r[4].s64 = ctx.r[11].s64 + -10040;
	// 828CAD08: 4BF9E3A1  bl 0x828690a8
	ctx.lr = 0x828CAD0C;
	sub_828690A8(ctx, base);
	// 828CAD0C: 3F60832D  lis r27, -0x7cd3
	ctx.r[27].s64 = -2094202880;
	// 828CAD10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CAD14: 3AE10060  addi r23, r1, 0x60
	ctx.r[23].s64 = ctx.r[1].s64 + 96;
	// 828CAD18: 809B0BD8  lwz r4, 0xbd8(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(3032 as u32) ) } as u64;
	// 828CAD1C: 48528CED  bl 0x82df3a08
	ctx.lr = 0x828CAD20;
	sub_82DF3A08(ctx, base);
	// 828CAD20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CAD24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CAD28: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 828CAD2C: 4859142D  bl 0x82e5c158
	ctx.lr = 0x828CAD30;
	sub_82E5C158(ctx, base);
	// 828CAD30: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828CAD34: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828CAD38: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CAD3C: 388BE608  addi r4, r11, -0x19f8
	ctx.r[4].s64 = ctx.r[11].s64 + -6648;
	// 828CAD40: 4BF9E369  bl 0x828690a8
	ctx.lr = 0x828CAD44;
	sub_828690A8(ctx, base);
	// 828CAD44: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CAD48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CAD4C: 3AE10060  addi r23, r1, 0x60
	ctx.r[23].s64 = ctx.r[1].s64 + 96;
	// 828CAD50: 808B0BF0  lwz r4, 0xbf0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3056 as u32) ) } as u64;
	// 828CAD54: 48528CB5  bl 0x82df3a08
	ctx.lr = 0x828CAD58;
	sub_82DF3A08(ctx, base);
	// 828CAD58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CAD5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CAD60: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 828CAD64: 485913F5  bl 0x82e5c158
	ctx.lr = 0x828CAD68;
	sub_82E5C158(ctx, base);
	// 828CAD68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CAD6C: 809B0BD8  lwz r4, 0xbd8(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(3032 as u32) ) } as u64;
	// 828CAD70: 48528C99  bl 0x82df3a08
	ctx.lr = 0x828CAD74;
	sub_82DF3A08(ctx, base);
	// 828CAD74: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CAD78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CAD7C: 4BF2178D  bl 0x827ec508
	ctx.lr = 0x828CAD80;
	sub_827EC508(ctx, base);
	// 828CAD80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CAD84: 485286A5  bl 0x82df3428
	ctx.lr = 0x828CAD88;
	sub_82DF3428(ctx, base);
	// 828CAD88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CAD8C: C03A0000  lfs f1, 0(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CAD90: 480436C1  bl 0x8290e450
	ctx.lr = 0x828CAD94;
	sub_8290E450(ctx, base);
	// 828CAD94: C0BC08A8  lfs f5, 0x8a8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(2216 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 828CAD98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CAD9C: C09A0098  lfs f4, 0x98(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(152 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 828CADA0: C07A0094  lfs f3, 0x94(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(148 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828CADA4: FC202890  fmr f1, f5
	ctx.f[1].f64 = ctx.f[5].f64;
	// 828CADA8: C05A0090  lfs f2, 0x90(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(144 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828CADAC: 480454FD  bl 0x829102a8
	ctx.lr = 0x828CADB0;
	sub_829102A8(ctx, base);
	// 828CADB0: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 828CADB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CADB8: 48043249  bl 0x8290e000
	ctx.lr = 0x828CADBC;
	sub_8290E000(ctx, base);
	// 828CADBC: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828CADC0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CADC4: 38A00183  li r5, 0x183
	ctx.r[5].s64 = 387;
	// 828CADC8: 386000A0  li r3, 0xa0
	ctx.r[3].s64 = 160;
	// 828CADCC: 4B9F560D  bl 0x822c03d8
	ctx.lr = 0x828CADD0;
	sub_822C03D8(ctx, base);
	// 828CADD0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CADD4: 41820024  beq 0x828cadf8
	if ctx.cr[0].eq {
	pc = 0x828CADF8; continue 'dispatch;
	}
	// 828CADD8: 357DFFF0  addic. r11, r29, -0x10
	ctx.xer.ca = (ctx.r[29].u32 > (!(-16 as u32)));
	ctx.r[11].s64 = ctx.r[29].s64 + -16;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CADDC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828CADE0: 40820008  bne 0x828cade8
	if !ctx.cr[0].eq {
	pc = 0x828CADE8; continue 'dispatch;
	}
	// 828CADE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CADE8: 38BA00C8  addi r5, r26, 0xc8
	ctx.r[5].s64 = ctx.r[26].s64 + 200;
	// 828CADEC: 480752E5  bl 0x829400d0
	ctx.lr = 0x828CADF0;
	sub_829400D0(ctx, base);
	// 828CADF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CADF4: 48000008  b 0x828cadfc
	pc = 0x828CADFC; continue 'dispatch;
	// 828CADF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CADFC: 387D0380  addi r3, r29, 0x380
	ctx.r[3].s64 = ctx.r[29].s64 + 896;
	// 828CAE00: 4BF9D649  bl 0x82868448
	ctx.lr = 0x828CAE04;
	sub_82868448(ctx, base);
	// 828CAE04: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 828CAE08: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 828CAE0C: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828CAE10: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828CAE14: 3CE08202  lis r7, -0x7dfe
	ctx.r[7].s64 = -2113798144;
	// 828CAE18: C009614C  lfs f0, 0x614c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CAE1C: 3CC08208  lis r6, -0x7df8
	ctx.r[6].s64 = -2113404928;
	// 828CAE20: C1A89524  lfs f13, -0x6adc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828CAE24: 3CA08208  lis r5, -0x7df8
	ctx.r[5].s64 = -2113404928;
	// 828CAE28: 3BCB0EC8  addi r30, r11, 0xec8
	ctx.r[30].s64 = ctx.r[11].s64 + 3784;
	// 828CAE2C: D00B0EC8  stfs f0, 0xec8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3784 as u32), tmp.u32 ) };
	// 828CAE30: 392A0E9C  addi r9, r10, 0xe9c
	ctx.r[9].s64 = ctx.r[10].s64 + 3740;
	// 828CAE34: D00A0E9C  stfs f0, 0xe9c(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(3740 as u32), tmp.u32 ) };
	// 828CAE38: 3D008337  lis r8, -0x7cc9
	ctx.r[8].s64 = -2093547520;
	// 828CAE3C: C1874C5C  lfs f12, 0x4c5c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(19548 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828CAE40: C1666150  lfs f11, 0x6150(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24912 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828CAE44: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828CAE48: C1456154  lfs f10, 0x6154(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24916 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828CAE4C: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 828CAE50: D3BE0004  stfs f29, 4(r30)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828CAE54: D1BE0008  stfs f13, 8(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 828CAE58: D1BE000C  stfs f13, 0xc(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828CAE5C: D1880EB8  stfs f12, 0xeb8(r8)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(3768 as u32), tmp.u32 ) };
	// 828CAE60: D1690008  stfs f11, 8(r9)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 828CAE64: D1490004  stfs f10, 4(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828CAE68: 4BFFE2F1  bl 0x828c9158
	ctx.lr = 0x828CAE6C;
	sub_828C9158(ctx, base);
	// 828CAE6C: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828CAE70: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CAE74: 38A00194  li r5, 0x194
	ctx.r[5].s64 = 404;
	// 828CAE78: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828CAE7C: 4B9F555D  bl 0x822c03d8
	ctx.lr = 0x828CAE80;
	sub_822C03D8(ctx, base);
	// 828CAE80: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828CAE84: 4182002C  beq 0x828caeb0
	if ctx.cr[0].eq {
	pc = 0x828CAEB0; continue 'dispatch;
	}
	// 828CAE88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CAE8C: 4BF212D5  bl 0x827ec160
	ctx.lr = 0x828CAE90;
	sub_827EC160(ctx, base);
	// 828CAE90: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CAE94: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828CAE98: 38ABDC54  addi r5, r11, -0x23ac
	ctx.r[5].s64 = ctx.r[11].s64 + -9132;
	// 828CAE9C: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 828CAEA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CAEA4: 4805791D  bl 0x829227c0
	ctx.lr = 0x828CAEA8;
	sub_829227C0(ctx, base);
	// 828CAEA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CAEAC: 48000008  b 0x828caeb4
	pc = 0x828CAEB4; continue 'dispatch;
	// 828CAEB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CAEB4: 387D03A0  addi r3, r29, 0x3a0
	ctx.r[3].s64 = ctx.r[29].s64 + 928;
	// 828CAEB8: 4BF9E101  bl 0x82868fb8
	ctx.lr = 0x828CAEBC;
	sub_82868FB8(ctx, base);
	// 828CAEBC: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CAEC0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CAEC4: 419A00AC  beq cr6, 0x828caf70
	if ctx.cr[6].eq {
	pc = 0x828CAF70; continue 'dispatch;
	}
	// 828CAEC8: 386102E0  addi r3, r1, 0x2e0
	ctx.r[3].s64 = ctx.r[1].s64 + 736;
	// 828CAECC: 48288505  bl 0x82b533d0
	ctx.lr = 0x828CAED0;
	sub_82B533D0(ctx, base);
	// 828CAED0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CAED4: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 828CAED8: D3C1030C  stfs f30, 0x30c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(780 as u32), tmp.u32 ) };
	// 828CAEDC: 93E102E0  stw r31, 0x2e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(736 as u32), ctx.r[31].u32 ) };
	// 828CAEE0: 914102E4  stw r10, 0x2e4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(740 as u32), ctx.r[10].u32 ) };
	// 828CAEE4: 92C10308  stw r22, 0x308(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(776 as u32), ctx.r[22].u32 ) };
	// 828CAEE8: C00BCFC4  lfs f0, -0x303c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12348 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CAEEC: D0010304  stfs f0, 0x304(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(772 as u32), tmp.u32 ) };
	// 828CAEF0: 83DD0260  lwz r30, 0x260(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(608 as u32) ) } as u64;
	// 828CAEF4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828CAEF8: 419A0078  beq cr6, 0x828caf70
	if ctx.cr[6].eq {
	pc = 0x828CAF70; continue 'dispatch;
	}
	// 828CAEFC: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 828CAF00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CAF04: 48528B05  bl 0x82df3a08
	ctx.lr = 0x828CAF08;
	sub_82DF3A08(ctx, base);
	// 828CAF08: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 828CAF0C: 38E102E0  addi r7, r1, 0x2e0
	ctx.r[7].s64 = ctx.r[1].s64 + 736;
	// 828CAF10: 7E469378  mr r6, r18
	ctx.r[6].u64 = ctx.r[18].u64;
	// 828CAF14: 7E258B78  mr r5, r17
	ctx.r[5].u64 = ctx.r[17].u64;
	// 828CAF18: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 828CAF1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CAF20: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 828CAF24: 48048D25  bl 0x82913c48
	ctx.lr = 0x828CAF28;
	sub_82913C48(ctx, base);
	// 828CAF28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CAF2C: 485284FD  bl 0x82df3428
	ctx.lr = 0x828CAF30;
	sub_82DF3428(ctx, base);
	// 828CAF30: 3D60828C  lis r11, -0x7d74
	ctx.r[11].s64 = -2104754176;
	// 828CAF34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CAF38: 92610098  stw r19, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[19].u32 ) };
	// 828CAF3C: 396BD1F0  addi r11, r11, -0x2e10
	ctx.r[11].s64 = ctx.r[11].s64 + -11792;
	// 828CAF40: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828CAF44: E8A10098  ld r5, 0x98(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 828CAF48: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828CAF4C: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828CAF50: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828CAF54: 4BFFEFED  bl 0x828c9f40
	ctx.lr = 0x828CAF58;
	sub_828C9F40(ctx, base);
	// 828CAF58: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828CAF5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CAF60: 480479B9  bl 0x82912918
	ctx.lr = 0x828CAF64;
	sub_82912918(ctx, base);
	// 828CAF64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CAF68: 389A00A8  addi r4, r26, 0xa8
	ctx.r[4].s64 = ctx.r[26].s64 + 168;
	// 828CAF6C: 48047245  bl 0x829121b0
	ctx.lr = 0x828CAF70;
	sub_829121B0(ctx, base);
	// 828CAF70: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828CAF74: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828CAF78: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828CAF7C: 3BEB0ED8  addi r31, r11, 0xed8
	ctx.r[31].s64 = ctx.r[11].s64 + 3800;
	// 828CAF80: 4BF21649  bl 0x827ec5c8
	ctx.lr = 0x828CAF84;
	sub_827EC5C8(ctx, base);
	// 828CAF84: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CAF88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CAF8C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828CAF90: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828CAF94: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828CAF98: 4BF218A9  bl 0x827ec840
	ctx.lr = 0x828CAF9C;
	sub_827EC840(ctx, base);
	// 828CAF9C: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 828CAFA0: 4182001C  beq 0x828cafbc
	if ctx.cr[0].eq {
	pc = 0x828CAFBC; continue 'dispatch;
	}
	// 828CAFA4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CAFA8: C0380000  lfs f1, 0(r24)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CAFAC: 4BF212DD  bl 0x827ec288
	ctx.lr = 0x828CAFB0;
	sub_827EC288(ctx, base);
	// 828CAFB0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828CAFB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CAFB8: 4BF212B9  bl 0x827ec270
	ctx.lr = 0x828CAFBC;
	sub_827EC270(ctx, base);
	// 828CAFBC: 80990000  lwz r4, 0(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CAFC0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828CAFC4: 419A0018  beq cr6, 0x828cafdc
	if ctx.cr[6].eq {
	pc = 0x828CAFDC; continue 'dispatch;
	}
	// 828CAFC8: 817D03B0  lwz r11, 0x3b0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(944 as u32) ) } as u64;
	// 828CAFCC: 387D03B0  addi r3, r29, 0x3b0
	ctx.r[3].s64 = ctx.r[29].s64 + 944;
	// 828CAFD0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CAFD4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CAFD8: 4E800421  bctrl
	ctx.lr = 0x828CAFDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CAFDC: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 828CAFE0: 4BFFD6C1  bl 0x828c86a0
	ctx.lr = 0x828CAFE4;
	sub_828C86A0(ctx, base);
	// 828CAFE4: 382103C0  addi r1, r1, 0x3c0
	ctx.r[1].s64 = ctx.r[1].s64 + 960;
	// 828CAFE8: CBA1FF50  lfd f29, -0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-176 as u32) ) };
	// 828CAFEC: CBC1FF58  lfd f30, -0xa8(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-168 as u32) ) };
	// 828CAFF0: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 828CAFF4: 488DD18C  b 0x831a8180
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CAFF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CAFF8 size=60
    let mut pc: u32 = 0x828CAFF8;
    'dispatch: loop {
        match pc {
            0x828CAFF8 => {
    //   block [0x828CAFF8..0x828CB034)
	// 828CAFF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CAFFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CB000: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CB004: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CB008: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CB00C: 4804BECD  bl 0x82916ed8
	ctx.lr = 0x828CB010;
	sub_82916ED8(ctx, base);
	// 828CB010: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CB014: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CB018: 396BE014  addi r11, r11, -0x1fec
	ctx.r[11].s64 = ctx.r[11].s64 + -8172;
	// 828CB01C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CB020: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CB024: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CB028: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CB02C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CB030: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CB038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CB038 size=60
    let mut pc: u32 = 0x828CB038;
    'dispatch: loop {
        match pc {
            0x828CB038 => {
    //   block [0x828CB038..0x828CB074)
	// 828CB038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CB03C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CB040: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CB044: 4BF227D5  bl 0x827ed818
	ctx.lr = 0x828CB048;
	sub_827ED818(ctx, base);
	// 828CB048: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CB04C: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828CB050: 40820008  bne 0x828cb058
	if !ctx.cr[0].eq {
	pc = 0x828CB058; continue 'dispatch;
	}
	// 828CB054: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828CB058: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CB05C: 419A0008  beq cr6, 0x828cb064
	if ctx.cr[6].eq {
	pc = 0x828CB064; continue 'dispatch;
	}
	// 828CB060: 4BFFCBC9  bl 0x828c7c28
	ctx.lr = 0x828CB064;
	sub_828C7C28(ctx, base);
	// 828CB064: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CB068: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CB06C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CB070: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CB078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CB078 size=60
    let mut pc: u32 = 0x828CB078;
    'dispatch: loop {
        match pc {
            0x828CB078 => {
    //   block [0x828CB078..0x828CB0B4)
	// 828CB078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CB07C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CB080: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CB084: 4BF22795  bl 0x827ed818
	ctx.lr = 0x828CB088;
	sub_827ED818(ctx, base);
	// 828CB088: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CB08C: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828CB090: 40820008  bne 0x828cb098
	if !ctx.cr[0].eq {
	pc = 0x828CB098; continue 'dispatch;
	}
	// 828CB094: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828CB098: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CB09C: 419A0008  beq cr6, 0x828cb0a4
	if ctx.cr[6].eq {
	pc = 0x828CB0A4; continue 'dispatch;
	}
	// 828CB0A0: 4BFFCBD9  bl 0x828c7c78
	ctx.lr = 0x828CB0A4;
	sub_828C7C78(ctx, base);
	// 828CB0A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CB0A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CB0AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CB0B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CB0B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CB0B8 size=60
    let mut pc: u32 = 0x828CB0B8;
    'dispatch: loop {
        match pc {
            0x828CB0B8 => {
    //   block [0x828CB0B8..0x828CB0F4)
	// 828CB0B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CB0BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CB0C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CB0C4: 4BF22755  bl 0x827ed818
	ctx.lr = 0x828CB0C8;
	sub_827ED818(ctx, base);
	// 828CB0C8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CB0CC: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828CB0D0: 40820008  bne 0x828cb0d8
	if !ctx.cr[0].eq {
	pc = 0x828CB0D8; continue 'dispatch;
	}
	// 828CB0D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828CB0D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CB0DC: 419A0008  beq cr6, 0x828cb0e4
	if ctx.cr[6].eq {
	pc = 0x828CB0E4; continue 'dispatch;
	}
	// 828CB0E0: 4BFFD5C1  bl 0x828c86a0
	ctx.lr = 0x828CB0E4;
	sub_828C86A0(ctx, base);
	// 828CB0E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CB0E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CB0EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CB0F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CB0F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CB0F8 size=60
    let mut pc: u32 = 0x828CB0F8;
    'dispatch: loop {
        match pc {
            0x828CB0F8 => {
    //   block [0x828CB0F8..0x828CB134)
	// 828CB0F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CB0FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CB100: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CB104: 4BF22715  bl 0x827ed818
	ctx.lr = 0x828CB108;
	sub_827ED818(ctx, base);
	// 828CB108: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CB10C: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828CB110: 40820008  bne 0x828cb118
	if !ctx.cr[0].eq {
	pc = 0x828CB118; continue 'dispatch;
	}
	// 828CB114: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828CB118: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CB11C: 419A0008  beq cr6, 0x828cb124
	if ctx.cr[6].eq {
	pc = 0x828CB124; continue 'dispatch;
	}
	// 828CB120: 4BFFC799  bl 0x828c78b8
	ctx.lr = 0x828CB124;
	sub_828C78B8(ctx, base);
	// 828CB124: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CB128: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CB12C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CB130: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CB138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CB138 size=72
    let mut pc: u32 = 0x828CB138;
    'dispatch: loop {
        match pc {
            0x828CB138 => {
    //   block [0x828CB138..0x828CB180)
	// 828CB138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CB13C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CB140: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CB144: 4BF226D5  bl 0x827ed818
	ctx.lr = 0x828CB148;
	sub_827ED818(ctx, base);
	// 828CB148: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CB14C: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828CB150: 40820008  bne 0x828cb158
	if !ctx.cr[0].eq {
	pc = 0x828CB158; continue 'dispatch;
	}
	// 828CB154: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828CB158: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CB15C: 419A000C  beq cr6, 0x828cb168
	if ctx.cr[6].eq {
	pc = 0x828CB168; continue 'dispatch;
	}
	// 828CB160: 4BFFC761  bl 0x828c78c0
	ctx.lr = 0x828CB164;
	sub_828C78C0(ctx, base);
	// 828CB164: 4800000C  b 0x828cb170
	pc = 0x828CB170; continue 'dispatch;
	// 828CB168: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828CB16C: 386B0F08  addi r3, r11, 0xf08
	ctx.r[3].s64 = ctx.r[11].s64 + 3848;
	// 828CB170: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CB174: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CB178: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CB17C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CB180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CB180 size=88
    let mut pc: u32 = 0x828CB180;
    'dispatch: loop {
        match pc {
            0x828CB180 => {
    //   block [0x828CB180..0x828CB1D8)
	// 828CB180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CB184: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CB188: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CB18C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CB190: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CB194: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CB198: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CB19C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828CB1A0: 396BE014  addi r11, r11, -0x1fec
	ctx.r[11].s64 = ctx.r[11].s64 + -8172;
	// 828CB1A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CB1A8: 4804B9C1  bl 0x82916b68
	ctx.lr = 0x828CB1AC;
	sub_82916B68(ctx, base);
	// 828CB1AC: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CB1B0: 4182000C  beq 0x828cb1bc
	if ctx.cr[0].eq {
	pc = 0x828CB1BC; continue 'dispatch;
	}
	// 828CB1B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CB1B8: 4B9F50B1  bl 0x822c0268
	ctx.lr = 0x828CB1BC;
	sub_822C0268(ctx, base);
	// 828CB1BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CB1C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CB1C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CB1C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CB1CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CB1D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CB1D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CB1D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CB1D8 size=152
    let mut pc: u32 = 0x828CB1D8;
    'dispatch: loop {
        match pc {
            0x828CB1D8 => {
    //   block [0x828CB1D8..0x828CB270)
	// 828CB1D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CB1DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CB1E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CB1E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CB1E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CB1EC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828CB1F0: 4BF22629  bl 0x827ed818
	ctx.lr = 0x828CB1F4;
	sub_827ED818(ctx, base);
	// 828CB1F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CB1F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CB1FC: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828CB200: 40820008  bne 0x828cb208
	if !ctx.cr[0].eq {
	pc = 0x828CB208; continue 'dispatch;
	}
	// 828CB204: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828CB208: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CB20C: 419A0044  beq cr6, 0x828cb250
	if ctx.cr[6].eq {
	pc = 0x828CB250; continue 'dispatch;
	}
	// 828CB210: 4BFFC6C1  bl 0x828c78d0
	ctx.lr = 0x828CB214;
	sub_828C78D0(ctx, base);
	// 828CB214: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB218: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CB21C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB220: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CB224: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CB228: 419A0030  beq cr6, 0x828cb258
	if ctx.cr[6].eq {
	pc = 0x828CB258; continue 'dispatch;
	}
	// 828CB22C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828CB230: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828CB234: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CB238: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828CB23C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828CB240: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828CB244: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CB248: 4082FFE8  bne 0x828cb230
	if !ctx.cr[0].eq {
	pc = 0x828CB230; continue 'dispatch;
	}
	// 828CB24C: 4800000C  b 0x828cb258
	pc = 0x828CB258; continue 'dispatch;
	// 828CB250: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CB254: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CB258: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CB25C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CB260: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CB264: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CB268: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CB26C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CB270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828CB270 size=48
    let mut pc: u32 = 0x828CB270;
    'dispatch: loop {
        match pc {
            0x828CB270 => {
    //   block [0x828CB270..0x828CB2A0)
	// 828CB270: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828CB274: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828CB278: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 828CB27C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828CB280: C00B9524  lfs f0, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CB284: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828CB288: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828CB28C: C189D7BC  lfs f12, -0x2844(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828CB290: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828CB294: D1A30008  stfs f13, 8(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 828CB298: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828CB29C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CB2A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CB2A0 size=236
    let mut pc: u32 = 0x828CB2A0;
    'dispatch: loop {
        match pc {
            0x828CB2A0 => {
    //   block [0x828CB2A0..0x828CB38C)
	// 828CB2A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CB2A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CB2A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CB2AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CB2B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CB2B4: 4808EC5D  bl 0x82959f10
	ctx.lr = 0x828CB2B8;
	sub_82959F10(ctx, base);
	// 828CB2B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828CB2BC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828CB2C0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828CB2C4: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 828CB2C8: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 828CB2CC: C16BD7BC  lfs f11, -0x2844(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828CB2D0: 3CC08208  lis r6, -0x7df8
	ctx.r[6].s64 = -2113404928;
	// 828CB2D4: C14A9C28  lfs f10, -0x63d8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25560 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828CB2D8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828CB2DC: C12908A8  lfs f9, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 828CB2E0: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 828CB2E4: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828CB2E8: C1086150  lfs f8, 0x6150(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24912 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 828CB2EC: C007A1C4  lfs f0, -0x5e3c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CB2F0: 387F00C8  addi r3, r31, 0xc8
	ctx.r[3].s64 = ctx.r[31].s64 + 200;
	// 828CB2F4: C1A689AC  lfs f13, -0x7654(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828CB2F8: C18B6154  lfs f12, 0x6154(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24916 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828CB2FC: C0EADD6C  lfs f7, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 828CB300: C0C99524  lfs f6, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 828CB304: D17F0078  stfs f11, 0x78(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828CB308: D15F007C  stfs f10, 0x7c(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 828CB30C: D13F0080  stfs f9, 0x80(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 828CB310: D11F0084  stfs f8, 0x84(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828CB314: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828CB318: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 828CB31C: D1BF0090  stfs f13, 0x90(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828CB320: D19F0094  stfs f12, 0x94(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828CB324: D19F0098  stfs f12, 0x98(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 828CB328: D0FF009C  stfs f7, 0x9c(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 828CB32C: D1BF00A0  stfs f13, 0xa0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 828CB330: D0DF00A4  stfs f6, 0xa4(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 828CB334: 48073C35  bl 0x8293ef68
	ctx.lr = 0x828CB338;
	sub_8293EF68(ctx, base);
	// 828CB338: 387F00E0  addi r3, r31, 0xe0
	ctx.r[3].s64 = ctx.r[31].s64 + 224;
	// 828CB33C: 48075C9D  bl 0x82940fd8
	ctx.lr = 0x828CB340;
	sub_82940FD8(ctx, base);
	// 828CB340: 387F00EC  addi r3, r31, 0xec
	ctx.r[3].s64 = ctx.r[31].s64 + 236;
	// 828CB344: 48077C0D  bl 0x82942f50
	ctx.lr = 0x828CB348;
	sub_82942F50(ctx, base);
	// 828CB348: 387F00F4  addi r3, r31, 0xf4
	ctx.r[3].s64 = ctx.r[31].s64 + 244;
	// 828CB34C: 4807800D  bl 0x82943358
	ctx.lr = 0x828CB350;
	sub_82943358(ctx, base);
	// 828CB350: 387F0104  addi r3, r31, 0x104
	ctx.r[3].s64 = ctx.r[31].s64 + 260;
	// 828CB354: 4807759D  bl 0x829428f0
	ctx.lr = 0x828CB358;
	sub_829428F0(ctx, base);
	// 828CB358: 387F0114  addi r3, r31, 0x114
	ctx.r[3].s64 = ctx.r[31].s64 + 276;
	// 828CB35C: 4807549D  bl 0x829407f8
	ctx.lr = 0x828CB360;
	sub_829407F8(ctx, base);
	// 828CB360: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828CB364: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CB368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CB36C: 995F0058  stb r10, 0x58(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[10].u8 ) };
	// 828CB370: C00BE0B4  lfs f0, -0x1f4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8012 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CB374: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828CB378: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CB37C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CB380: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CB384: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CB388: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CB390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CB390 size=1728
    let mut pc: u32 = 0x828CB390;
    'dispatch: loop {
        match pc {
            0x828CB390 => {
    //   block [0x828CB390..0x828CBA50)
	// 828CB390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CB394: 488DCDD9  bl 0x831a816c
	ctx.lr = 0x828CB398;
	sub_831A8130(ctx, base);
	// 828CB398: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 828CB39C: 488DD6DD  bl 0x831a8a78
	ctx.lr = 0x828CB3A0;
	sub_831A8A40(ctx, base);
	// 828CB3A0: 9421FD50  stwu r1, -0x2b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-688 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CB3A4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CB3A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CB3AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB3B0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB3B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CB3B8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828CB3BC: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828CB3C0: 419A0024  beq cr6, 0x828cb3e4
	if ctx.cr[6].eq {
	pc = 0x828CB3E4; continue 'dispatch;
	}
	// 828CB3C4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828CB3C8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828CB3CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CB3D0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828CB3D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828CB3D8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828CB3DC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CB3E0: 4082FFE8  bne 0x828cb3c8
	if !ctx.cr[0].eq {
	pc = 0x828CB3C8; continue 'dispatch;
	}
	// 828CB3E4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828CB3E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CB3EC: 4808F72D  bl 0x8295ab18
	ctx.lr = 0x828CB3F0;
	sub_8295AB18(ctx, base);
	// 828CB3F0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828CB3F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CB3F8: 388B3D90  addi r4, r11, 0x3d90
	ctx.r[4].s64 = ctx.r[11].s64 + 15760;
	// 828CB3FC: 4852860D  bl 0x82df3a08
	ctx.lr = 0x828CB400;
	sub_82DF3A08(ctx, base);
	// 828CB400: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828CB404: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CB408: 388B3D88  addi r4, r11, 0x3d88
	ctx.r[4].s64 = ctx.r[11].s64 + 15752;
	// 828CB40C: 485285FD  bl 0x82df3a08
	ctx.lr = 0x828CB410;
	sub_82DF3A08(ctx, base);
	// 828CB410: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828CB414: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828CB418: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB41C: 4BCFF0E5  bl 0x825ca500
	ctx.lr = 0x828CB420;
	sub_825CA500(ctx, base);
	// 828CB420: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828CB424: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CB428: 48528001  bl 0x82df3428
	ctx.lr = 0x828CB42C;
	sub_82DF3428(ctx, base);
	// 828CB42C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CB430: 48527FF9  bl 0x82df3428
	ctx.lr = 0x828CB434;
	sub_82DF3428(ctx, base);
	// 828CB434: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CB438: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CB43C: 388BD32C  addi r4, r11, -0x2cd4
	ctx.r[4].s64 = ctx.r[11].s64 + -11476;
	// 828CB440: 485285C9  bl 0x82df3a08
	ctx.lr = 0x828CB444;
	sub_82DF3A08(ctx, base);
	// 828CB444: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CB448: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CB44C: 388BD318  addi r4, r11, -0x2ce8
	ctx.r[4].s64 = ctx.r[11].s64 + -11496;
	// 828CB450: 485285B9  bl 0x82df3a08
	ctx.lr = 0x828CB454;
	sub_82DF3A08(ctx, base);
	// 828CB454: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828CB458: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 828CB45C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828CB460: 38BE0078  addi r5, r30, 0x78
	ctx.r[5].s64 = ctx.r[30].s64 + 120;
	// 828CB464: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828CB468: C3CB964C  lfs f30, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828CB46C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828CB470: C3AA6218  lfs f29, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828CB474: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 828CB478: C0299528  lfs f1, -0x6ad8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CB47C: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 828CB480: 4BCD7E29  bl 0x825a32a8
	ctx.lr = 0x828CB484;
	sub_825A32A8(ctx, base);
	// 828CB484: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828CB488: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CB48C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828CB490: 4BCD62E1  bl 0x825a1770
	ctx.lr = 0x828CB494;
	sub_825A1770(ctx, base);
	// 828CB494: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 828CB498: 48527F91  bl 0x82df3428
	ctx.lr = 0x828CB49C;
	sub_82DF3428(ctx, base);
	// 828CB49C: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 828CB4A0: 4B9FD819  bl 0x822c8cb8
	ctx.lr = 0x828CB4A4;
	sub_822C8CB8(ctx, base);
	// 828CB4A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CB4A8: 48527F81  bl 0x82df3428
	ctx.lr = 0x828CB4AC;
	sub_82DF3428(ctx, base);
	// 828CB4AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CB4B0: 48527F79  bl 0x82df3428
	ctx.lr = 0x828CB4B4;
	sub_82DF3428(ctx, base);
	// 828CB4B4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CB4B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CB4BC: 388BE0EC  addi r4, r11, -0x1f14
	ctx.r[4].s64 = ctx.r[11].s64 + -7956;
	// 828CB4C0: 48528549  bl 0x82df3a08
	ctx.lr = 0x828CB4C4;
	sub_82DF3A08(ctx, base);
	// 828CB4C4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CB4C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CB4CC: 388BE0E0  addi r4, r11, -0x1f20
	ctx.r[4].s64 = ctx.r[11].s64 + -7968;
	// 828CB4D0: 48528539  bl 0x82df3a08
	ctx.lr = 0x828CB4D4;
	sub_82DF3A08(ctx, base);
	// 828CB4D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828CB4D8: 38BE0080  addi r5, r30, 0x80
	ctx.r[5].s64 = ctx.r[30].s64 + 128;
	// 828CB4DC: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 828CB4E0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828CB4E4: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 828CB4E8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828CB4EC: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828CB4F0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828CB4F4: 4BCD7DB5  bl 0x825a32a8
	ctx.lr = 0x828CB4F8;
	sub_825A32A8(ctx, base);
	// 828CB4F8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828CB4FC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828CB500: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CB504: 4BCD626D  bl 0x825a1770
	ctx.lr = 0x828CB508;
	sub_825A1770(ctx, base);
	// 828CB508: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 828CB50C: 48527F1D  bl 0x82df3428
	ctx.lr = 0x828CB510;
	sub_82DF3428(ctx, base);
	// 828CB510: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828CB514: 4B9FD7A5  bl 0x822c8cb8
	ctx.lr = 0x828CB518;
	sub_822C8CB8(ctx, base);
	// 828CB518: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CB51C: 48527F0D  bl 0x82df3428
	ctx.lr = 0x828CB520;
	sub_82DF3428(ctx, base);
	// 828CB520: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CB524: 48527F05  bl 0x82df3428
	ctx.lr = 0x828CB528;
	sub_82DF3428(ctx, base);
	// 828CB528: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB52C: 4BCFE7A5  bl 0x825c9cd0
	ctx.lr = 0x828CB530;
	sub_825C9CD0(ctx, base);
	// 828CB530: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828CB534: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CB538: 388B3DC4  addi r4, r11, 0x3dc4
	ctx.r[4].s64 = ctx.r[11].s64 + 15812;
	// 828CB53C: 485284CD  bl 0x82df3a08
	ctx.lr = 0x828CB540;
	sub_82DF3A08(ctx, base);
	// 828CB540: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CB544: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CB548: 388BD310  addi r4, r11, -0x2cf0
	ctx.r[4].s64 = ctx.r[11].s64 + -11504;
	// 828CB54C: 485284BD  bl 0x82df3a08
	ctx.lr = 0x828CB550;
	sub_82DF3A08(ctx, base);
	// 828CB550: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828CB554: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828CB558: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB55C: 4BCFEFA5  bl 0x825ca500
	ctx.lr = 0x828CB560;
	sub_825CA500(ctx, base);
	// 828CB560: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828CB564: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CB568: 48527EC1  bl 0x82df3428
	ctx.lr = 0x828CB56C;
	sub_82DF3428(ctx, base);
	// 828CB56C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CB570: 48527EB9  bl 0x82df3428
	ctx.lr = 0x828CB574;
	sub_82DF3428(ctx, base);
	// 828CB574: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CB578: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CB57C: 388BD2F8  addi r4, r11, -0x2d08
	ctx.r[4].s64 = ctx.r[11].s64 + -11528;
	// 828CB580: 48528489  bl 0x82df3a08
	ctx.lr = 0x828CB584;
	sub_82DF3A08(ctx, base);
	// 828CB584: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CB588: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CB58C: 388BD2E8  addi r4, r11, -0x2d18
	ctx.r[4].s64 = ctx.r[11].s64 + -11544;
	// 828CB590: 48528479  bl 0x82df3a08
	ctx.lr = 0x828CB594;
	sub_82DF3A08(ctx, base);
	// 828CB594: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828CB598: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828CB59C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828CB5A0: 38BE0084  addi r5, r30, 0x84
	ctx.r[5].s64 = ctx.r[30].s64 + 132;
	// 828CB5A4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828CB5A8: 386101F0  addi r3, r1, 0x1f0
	ctx.r[3].s64 = ctx.r[1].s64 + 496;
	// 828CB5AC: C38A08A8  lfs f28, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 828CB5B0: C06B9F7C  lfs f3, -0x6084(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24708 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828CB5B4: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 828CB5B8: 4BCD7CF1  bl 0x825a32a8
	ctx.lr = 0x828CB5BC;
	sub_825A32A8(ctx, base);
	// 828CB5BC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828CB5C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CB5C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CB5C8: 4BCD61A9  bl 0x825a1770
	ctx.lr = 0x828CB5CC;
	sub_825A1770(ctx, base);
	// 828CB5CC: 38610228  addi r3, r1, 0x228
	ctx.r[3].s64 = ctx.r[1].s64 + 552;
	// 828CB5D0: 48527E59  bl 0x82df3428
	ctx.lr = 0x828CB5D4;
	sub_82DF3428(ctx, base);
	// 828CB5D4: 38610208  addi r3, r1, 0x208
	ctx.r[3].s64 = ctx.r[1].s64 + 520;
	// 828CB5D8: 4B9FD6E1  bl 0x822c8cb8
	ctx.lr = 0x828CB5DC;
	sub_822C8CB8(ctx, base);
	// 828CB5DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CB5E0: 48527E49  bl 0x82df3428
	ctx.lr = 0x828CB5E4;
	sub_82DF3428(ctx, base);
	// 828CB5E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CB5E8: 48527E41  bl 0x82df3428
	ctx.lr = 0x828CB5EC;
	sub_82DF3428(ctx, base);
	// 828CB5EC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CB5F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CB5F4: 388BD2C4  addi r4, r11, -0x2d3c
	ctx.r[4].s64 = ctx.r[11].s64 + -11580;
	// 828CB5F8: 48528411  bl 0x82df3a08
	ctx.lr = 0x828CB5FC;
	sub_82DF3A08(ctx, base);
	// 828CB5FC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CB600: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CB604: 388BD2B4  addi r4, r11, -0x2d4c
	ctx.r[4].s64 = ctx.r[11].s64 + -11596;
	// 828CB608: 48528401  bl 0x82df3a08
	ctx.lr = 0x828CB60C;
	sub_82DF3A08(ctx, base);
	// 828CB60C: 38BE0088  addi r5, r30, 0x88
	ctx.r[5].s64 = ctx.r[30].s64 + 136;
	// 828CB610: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828CB614: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 828CB618: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 828CB61C: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 828CB620: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828CB624: 4BCD7C85  bl 0x825a32a8
	ctx.lr = 0x828CB628;
	sub_825A32A8(ctx, base);
	// 828CB628: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828CB62C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CB630: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CB634: 4BCD613D  bl 0x825a1770
	ctx.lr = 0x828CB638;
	sub_825A1770(ctx, base);
	// 828CB638: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 828CB63C: 48527DED  bl 0x82df3428
	ctx.lr = 0x828CB640;
	sub_82DF3428(ctx, base);
	// 828CB640: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 828CB644: 4B9FD675  bl 0x822c8cb8
	ctx.lr = 0x828CB648;
	sub_822C8CB8(ctx, base);
	// 828CB648: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CB64C: 48527DDD  bl 0x82df3428
	ctx.lr = 0x828CB650;
	sub_82DF3428(ctx, base);
	// 828CB650: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CB654: 48527DD5  bl 0x82df3428
	ctx.lr = 0x828CB658;
	sub_82DF3428(ctx, base);
	// 828CB658: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CB65C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CB660: 388BD2A8  addi r4, r11, -0x2d58
	ctx.r[4].s64 = ctx.r[11].s64 + -11608;
	// 828CB664: 485283A5  bl 0x82df3a08
	ctx.lr = 0x828CB668;
	sub_82DF3A08(ctx, base);
	// 828CB668: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CB66C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CB670: 388BD29C  addi r4, r11, -0x2d64
	ctx.r[4].s64 = ctx.r[11].s64 + -11620;
	// 828CB674: 48528395  bl 0x82df3a08
	ctx.lr = 0x828CB678;
	sub_82DF3A08(ctx, base);
	// 828CB678: 38BE008C  addi r5, r30, 0x8c
	ctx.r[5].s64 = ctx.r[30].s64 + 140;
	// 828CB67C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828CB680: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828CB684: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828CB688: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 828CB68C: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 828CB690: 4BCD7C19  bl 0x825a32a8
	ctx.lr = 0x828CB694;
	sub_825A32A8(ctx, base);
	// 828CB694: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828CB698: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CB69C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CB6A0: 4BCD60D1  bl 0x825a1770
	ctx.lr = 0x828CB6A4;
	sub_825A1770(ctx, base);
	// 828CB6A4: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 828CB6A8: 48527D81  bl 0x82df3428
	ctx.lr = 0x828CB6AC;
	sub_82DF3428(ctx, base);
	// 828CB6AC: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828CB6B0: 4B9FD609  bl 0x822c8cb8
	ctx.lr = 0x828CB6B4;
	sub_822C8CB8(ctx, base);
	// 828CB6B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CB6B8: 48527D71  bl 0x82df3428
	ctx.lr = 0x828CB6BC;
	sub_82DF3428(ctx, base);
	// 828CB6BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CB6C0: 48527D69  bl 0x82df3428
	ctx.lr = 0x828CB6C4;
	sub_82DF3428(ctx, base);
	// 828CB6C4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB6C8: 4BCFE609  bl 0x825c9cd0
	ctx.lr = 0x828CB6CC;
	sub_825C9CD0(ctx, base);
	// 828CB6CC: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 828CB6D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CB6D4: 388B7A1C  addi r4, r11, 0x7a1c
	ctx.r[4].s64 = ctx.r[11].s64 + 31260;
	// 828CB6D8: 48528331  bl 0x82df3a08
	ctx.lr = 0x828CB6DC;
	sub_82DF3A08(ctx, base);
	// 828CB6DC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828CB6E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CB6E4: 388BCB24  addi r4, r11, -0x34dc
	ctx.r[4].s64 = ctx.r[11].s64 + -13532;
	// 828CB6E8: 48528321  bl 0x82df3a08
	ctx.lr = 0x828CB6EC;
	sub_82DF3A08(ctx, base);
	// 828CB6EC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828CB6F0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828CB6F4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB6F8: 4BCFEE09  bl 0x825ca500
	ctx.lr = 0x828CB6FC;
	sub_825CA500(ctx, base);
	// 828CB6FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828CB700: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CB704: 48527D25  bl 0x82df3428
	ctx.lr = 0x828CB708;
	sub_82DF3428(ctx, base);
	// 828CB708: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CB70C: 48527D1D  bl 0x82df3428
	ctx.lr = 0x828CB710;
	sub_82DF3428(ctx, base);
	// 828CB710: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CB714: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CB718: 388BD3E4  addi r4, r11, -0x2c1c
	ctx.r[4].s64 = ctx.r[11].s64 + -11292;
	// 828CB71C: 485282ED  bl 0x82df3a08
	ctx.lr = 0x828CB720;
	sub_82DF3A08(ctx, base);
	// 828CB720: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CB724: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CB728: 388BD3D0  addi r4, r11, -0x2c30
	ctx.r[4].s64 = ctx.r[11].s64 + -11312;
	// 828CB72C: 485282DD  bl 0x82df3a08
	ctx.lr = 0x828CB730;
	sub_82DF3A08(ctx, base);
	// 828CB730: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828CB734: 38BE009C  addi r5, r30, 0x9c
	ctx.r[5].s64 = ctx.r[30].s64 + 156;
	// 828CB738: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 828CB73C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828CB740: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828CB744: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 828CB748: C3CBDD6C  lfs f30, -0x2294(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828CB74C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828CB750: 4BCD7B59  bl 0x825a32a8
	ctx.lr = 0x828CB754;
	sub_825A32A8(ctx, base);
	// 828CB754: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828CB758: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CB75C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CB760: 4BCD6011  bl 0x825a1770
	ctx.lr = 0x828CB764;
	sub_825A1770(ctx, base);
	// 828CB764: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 828CB768: 48527CC1  bl 0x82df3428
	ctx.lr = 0x828CB76C;
	sub_82DF3428(ctx, base);
	// 828CB76C: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 828CB770: 4B9FD549  bl 0x822c8cb8
	ctx.lr = 0x828CB774;
	sub_822C8CB8(ctx, base);
	// 828CB774: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CB778: 48527CB1  bl 0x82df3428
	ctx.lr = 0x828CB77C;
	sub_82DF3428(ctx, base);
	// 828CB77C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CB780: 48527CA9  bl 0x82df3428
	ctx.lr = 0x828CB784;
	sub_82DF3428(ctx, base);
	// 828CB784: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CB788: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CB78C: 388BD3BC  addi r4, r11, -0x2c44
	ctx.r[4].s64 = ctx.r[11].s64 + -11332;
	// 828CB790: 48528279  bl 0x82df3a08
	ctx.lr = 0x828CB794;
	sub_82DF3A08(ctx, base);
	// 828CB794: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CB798: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CB79C: 388BD3A4  addi r4, r11, -0x2c5c
	ctx.r[4].s64 = ctx.r[11].s64 + -11356;
	// 828CB7A0: 48528269  bl 0x82df3a08
	ctx.lr = 0x828CB7A4;
	sub_82DF3A08(ctx, base);
	// 828CB7A4: 38BE00A0  addi r5, r30, 0xa0
	ctx.r[5].s64 = ctx.r[30].s64 + 160;
	// 828CB7A8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828CB7AC: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 828CB7B0: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 828CB7B4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828CB7B8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828CB7BC: 4BCD7AED  bl 0x825a32a8
	ctx.lr = 0x828CB7C0;
	sub_825A32A8(ctx, base);
	// 828CB7C0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828CB7C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CB7C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CB7CC: 4BCD5FA5  bl 0x825a1770
	ctx.lr = 0x828CB7D0;
	sub_825A1770(ctx, base);
	// 828CB7D0: 386101E8  addi r3, r1, 0x1e8
	ctx.r[3].s64 = ctx.r[1].s64 + 488;
	// 828CB7D4: 48527C55  bl 0x82df3428
	ctx.lr = 0x828CB7D8;
	sub_82DF3428(ctx, base);
	// 828CB7D8: 386101C8  addi r3, r1, 0x1c8
	ctx.r[3].s64 = ctx.r[1].s64 + 456;
	// 828CB7DC: 4B9FD4DD  bl 0x822c8cb8
	ctx.lr = 0x828CB7E0;
	sub_822C8CB8(ctx, base);
	// 828CB7E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CB7E4: 48527C45  bl 0x82df3428
	ctx.lr = 0x828CB7E8;
	sub_82DF3428(ctx, base);
	// 828CB7E8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CB7EC: 48527C3D  bl 0x82df3428
	ctx.lr = 0x828CB7F0;
	sub_82DF3428(ctx, base);
	// 828CB7F0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CB7F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CB7F8: 388BE0C8  addi r4, r11, -0x1f38
	ctx.r[4].s64 = ctx.r[11].s64 + -7992;
	// 828CB7FC: 4852820D  bl 0x82df3a08
	ctx.lr = 0x828CB800;
	sub_82DF3A08(ctx, base);
	// 828CB800: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CB804: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CB808: 388BE0B0  addi r4, r11, -0x1f50
	ctx.r[4].s64 = ctx.r[11].s64 + -8016;
	// 828CB80C: 485281FD  bl 0x82df3a08
	ctx.lr = 0x828CB810;
	sub_82DF3A08(ctx, base);
	// 828CB810: 38BE00A4  addi r5, r30, 0xa4
	ctx.r[5].s64 = ctx.r[30].s64 + 164;
	// 828CB814: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828CB818: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 828CB81C: 38610230  addi r3, r1, 0x230
	ctx.r[3].s64 = ctx.r[1].s64 + 560;
	// 828CB820: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828CB824: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828CB828: 4BCD7A81  bl 0x825a32a8
	ctx.lr = 0x828CB82C;
	sub_825A32A8(ctx, base);
	// 828CB82C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828CB830: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CB834: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CB838: 4BCD5F39  bl 0x825a1770
	ctx.lr = 0x828CB83C;
	sub_825A1770(ctx, base);
	// 828CB83C: 38610268  addi r3, r1, 0x268
	ctx.r[3].s64 = ctx.r[1].s64 + 616;
	// 828CB840: 48527BE9  bl 0x82df3428
	ctx.lr = 0x828CB844;
	sub_82DF3428(ctx, base);
	// 828CB844: 38610248  addi r3, r1, 0x248
	ctx.r[3].s64 = ctx.r[1].s64 + 584;
	// 828CB848: 4B9FD471  bl 0x822c8cb8
	ctx.lr = 0x828CB84C;
	sub_822C8CB8(ctx, base);
	// 828CB84C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CB850: 48527BD9  bl 0x82df3428
	ctx.lr = 0x828CB854;
	sub_82DF3428(ctx, base);
	// 828CB854: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CB858: 48527BD1  bl 0x82df3428
	ctx.lr = 0x828CB85C;
	sub_82DF3428(ctx, base);
	// 828CB85C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB860: 4BCFE471  bl 0x825c9cd0
	ctx.lr = 0x828CB864;
	sub_825C9CD0(ctx, base);
	// 828CB864: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB868: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB86C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CB870: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828CB874: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828CB878: 419A0024  beq cr6, 0x828cb89c
	if ctx.cr[6].eq {
	pc = 0x828CB89C; continue 'dispatch;
	}
	// 828CB87C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828CB880: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828CB884: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CB888: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828CB88C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828CB890: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828CB894: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CB898: 4082FFE8  bne 0x828cb880
	if !ctx.cr[0].eq {
	pc = 0x828CB880; continue 'dispatch;
	}
	// 828CB89C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828CB8A0: 387E00A8  addi r3, r30, 0xa8
	ctx.r[3].s64 = ctx.r[30].s64 + 168;
	// 828CB8A4: 4804981D  bl 0x829150c0
	ctx.lr = 0x828CB8A8;
	sub_829150C0(ctx, base);
	// 828CB8A8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB8AC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB8B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CB8B4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828CB8B8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828CB8BC: 419A0024  beq cr6, 0x828cb8e0
	if ctx.cr[6].eq {
	pc = 0x828CB8E0; continue 'dispatch;
	}
	// 828CB8C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828CB8C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828CB8C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CB8CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828CB8D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828CB8D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828CB8D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CB8DC: 4082FFE8  bne 0x828cb8c4
	if !ctx.cr[0].eq {
	pc = 0x828CB8C4; continue 'dispatch;
	}
	// 828CB8E0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828CB8E4: 387E00C8  addi r3, r30, 0xc8
	ctx.r[3].s64 = ctx.r[30].s64 + 200;
	// 828CB8E8: 480742C1  bl 0x8293fba8
	ctx.lr = 0x828CB8EC;
	sub_8293FBA8(ctx, base);
	// 828CB8EC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB8F0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB8F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CB8F8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828CB8FC: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828CB900: 419A0024  beq cr6, 0x828cb924
	if ctx.cr[6].eq {
	pc = 0x828CB924; continue 'dispatch;
	}
	// 828CB904: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828CB908: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828CB90C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CB910: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828CB914: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828CB918: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828CB91C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CB920: 4082FFE8  bne 0x828cb908
	if !ctx.cr[0].eq {
	pc = 0x828CB908; continue 'dispatch;
	}
	// 828CB924: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828CB928: 387E00E0  addi r3, r30, 0xe0
	ctx.r[3].s64 = ctx.r[30].s64 + 224;
	// 828CB92C: 48075A7D  bl 0x829413a8
	ctx.lr = 0x828CB930;
	sub_829413A8(ctx, base);
	// 828CB930: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB934: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB938: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CB93C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828CB940: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828CB944: 419A0024  beq cr6, 0x828cb968
	if ctx.cr[6].eq {
	pc = 0x828CB968; continue 'dispatch;
	}
	// 828CB948: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828CB94C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828CB950: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CB954: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828CB958: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828CB95C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828CB960: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CB964: 4082FFE8  bne 0x828cb94c
	if !ctx.cr[0].eq {
	pc = 0x828CB94C; continue 'dispatch;
	}
	// 828CB968: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828CB96C: 387E00EC  addi r3, r30, 0xec
	ctx.r[3].s64 = ctx.r[30].s64 + 236;
	// 828CB970: 48077961  bl 0x829432d0
	ctx.lr = 0x828CB974;
	sub_829432D0(ctx, base);
	// 828CB974: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB978: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB97C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CB980: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828CB984: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828CB988: 419A0024  beq cr6, 0x828cb9ac
	if ctx.cr[6].eq {
	pc = 0x828CB9AC; continue 'dispatch;
	}
	// 828CB98C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828CB990: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828CB994: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CB998: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828CB99C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828CB9A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828CB9A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CB9A8: 4082FFE8  bne 0x828cb990
	if !ctx.cr[0].eq {
	pc = 0x828CB990; continue 'dispatch;
	}
	// 828CB9AC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828CB9B0: 387E00F4  addi r3, r30, 0xf4
	ctx.r[3].s64 = ctx.r[30].s64 + 244;
	// 828CB9B4: 480780DD  bl 0x82943a90
	ctx.lr = 0x828CB9B8;
	sub_82943A90(ctx, base);
	// 828CB9B8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CB9BC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CB9C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CB9C4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828CB9C8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828CB9CC: 419A0024  beq cr6, 0x828cb9f0
	if ctx.cr[6].eq {
	pc = 0x828CB9F0; continue 'dispatch;
	}
	// 828CB9D0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828CB9D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828CB9D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CB9DC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828CB9E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828CB9E4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828CB9E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CB9EC: 4082FFE8  bne 0x828cb9d4
	if !ctx.cr[0].eq {
	pc = 0x828CB9D4; continue 'dispatch;
	}
	// 828CB9F0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828CB9F4: 387E0104  addi r3, r30, 0x104
	ctx.r[3].s64 = ctx.r[30].s64 + 260;
	// 828CB9F8: 48077229  bl 0x82942c20
	ctx.lr = 0x828CB9FC;
	sub_82942C20(ctx, base);
	// 828CB9FC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CBA00: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CBA04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CBA08: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828CBA0C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828CBA10: 419A0024  beq cr6, 0x828cba34
	if ctx.cr[6].eq {
	pc = 0x828CBA34; continue 'dispatch;
	}
	// 828CBA14: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828CBA18: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828CBA1C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CBA20: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828CBA24: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828CBA28: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828CBA2C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CBA30: 4082FFE8  bne 0x828cba18
	if !ctx.cr[0].eq {
	pc = 0x828CBA18; continue 'dispatch;
	}
	// 828CBA34: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828CBA38: 387E0114  addi r3, r30, 0x114
	ctx.r[3].s64 = ctx.r[30].s64 + 276;
	// 828CBA3C: 48075205  bl 0x82940c40
	ctx.lr = 0x828CBA40;
	sub_82940C40(ctx, base);
	// 828CBA40: 382102B0  addi r1, r1, 0x2b0
	ctx.r[1].s64 = ctx.r[1].s64 + 688;
	// 828CBA44: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 828CBA48: 488DD07D  bl 0x831a8ac4
	ctx.lr = 0x828CBA4C;
	sub_831A8A8C(ctx, base);
	// 828CBA4C: 488DC770  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CBA50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CBA50 size=96
    let mut pc: u32 = 0x828CBA50;
    'dispatch: loop {
        match pc {
            0x828CBA50 => {
    //   block [0x828CBA50..0x828CBAB0)
	// 828CBA50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CBA54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CBA58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CBA5C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CBA60: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 828CBA64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CBA68: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 828CBA6C: 409A0030  bne cr6, 0x828cba9c
	if !ctx.cr[6].eq {
	pc = 0x828CBA9C; continue 'dispatch;
	}
	// 828CBA70: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CBA74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CBA78: 808B0B30  lwz r4, 0xb30(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2864 as u32) ) } as u64;
	// 828CBA7C: 48527F8D  bl 0x82df3a08
	ctx.lr = 0x828CBA80;
	sub_82DF3A08(ctx, base);
	// 828CBA80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CBA84: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 828CBA88: 48888B79  bl 0x83154600
	ctx.lr = 0x828CBA8C;
	sub_83154600(ctx, base);
	// 828CBA8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CBA90: 4BF23CB1  bl 0x827ef740
	ctx.lr = 0x828CBA94;
	sub_827EF740(ctx, base);
	// 828CBA94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CBA98: 48527991  bl 0x82df3428
	ctx.lr = 0x828CBA9C;
	sub_82DF3428(ctx, base);
	// 828CBA9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CBAA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CBAA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CBAA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CBAAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CBAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CBAB0 size=108
    let mut pc: u32 = 0x828CBAB0;
    'dispatch: loop {
        match pc {
            0x828CBAB0 => {
    //   block [0x828CBAB0..0x828CBB1C)
	// 828CBAB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CBAB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CBAB8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CBABC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828CBAC0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828CBAC4: 38C00058  li r6, 0x58
	ctx.r[6].s64 = 88;
	// 828CBAC8: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 828CBACC: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 828CBAD0: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 828CBAD4: 485265F5  bl 0x82df20c8
	ctx.lr = 0x828CBAD8;
	sub_82DF20C8(ctx, base);
	// 828CBAD8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828CBADC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CBAE0: 41820008  beq 0x828cbae8
	if ctx.cr[0].eq {
	pc = 0x828CBAE8; continue 'dispatch;
	}
	// 828CBAE4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828CBAE8: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CBAEC: 41820008  beq 0x828cbaf4
	if ctx.cr[0].eq {
	pc = 0x828CBAF4; continue 'dispatch;
	}
	// 828CBAF0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828CBAF4: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CBAF8: 41820008  beq 0x828cbb00
	if ctx.cr[0].eq {
	pc = 0x828CBB00; continue 'dispatch;
	}
	// 828CBAFC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828CBB00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CBB04: 99430051  stb r10, 0x51(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 828CBB08: 99630050  stb r11, 0x50(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 828CBB0C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CBB10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CBB14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CBB18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CBB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CBB20 size=88
    let mut pc: u32 = 0x828CBB20;
    'dispatch: loop {
        match pc {
            0x828CBB20 => {
    //   block [0x828CBB20..0x828CBB78)
	// 828CBB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CBB24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CBB28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CBB2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CBB30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CBB34: 4BFFFF7D  bl 0x828cbab0
	ctx.lr = 0x828CBB38;
	sub_828CBAB0(ctx, base);
	// 828CBB38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CBB3C: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 828CBB40: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828CBB44: 99630051  stb r11, 0x51(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 828CBB48: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CBB4C: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828CBB50: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CBB54: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CBB58: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CBB5C: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828CBB60: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CBB64: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CBB68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CBB6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CBB70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CBB74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CBB78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CBB78 size=72
    let mut pc: u32 = 0x828CBB78;
    'dispatch: loop {
        match pc {
            0x828CBB78 => {
    //   block [0x828CBB78..0x828CBBC0)
	// 828CBB78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CBB7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CBB80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CBB84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CBB88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CBB8C: 48888A75  bl 0x83154600
	ctx.lr = 0x828CBB90;
	sub_83154600(ctx, base);
	// 828CBB90: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 828CBB94: 41820018  beq 0x828cbbac
	if ctx.cr[0].eq {
	pc = 0x828CBBAC; continue 'dispatch;
	}
	// 828CBB98: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CBB9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CBBA0: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828CBBA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CBBA8: 4E800421  bctrl
	ctx.lr = 0x828CBBAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CBBAC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CBBB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CBBB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CBBB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CBBBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CBBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CBBC0 size=80
    let mut pc: u32 = 0x828CBBC0;
    'dispatch: loop {
        match pc {
            0x828CBBC0 => {
    //   block [0x828CBBC0..0x828CBC10)
	// 828CBBC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CBBC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CBBC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CBBCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CBBD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CBBD4: 48590D55  bl 0x82e5c928
	ctx.lr = 0x828CBBD8;
	sub_82E5C928(ctx, base);
	// 828CBBD8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CBBDC: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 828CBBE0: 396BE110  addi r11, r11, -0x1ef0
	ctx.r[11].s64 = ctx.r[11].s64 + -7920;
	// 828CBBE4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CBBE8: 4BFFFF39  bl 0x828cbb20
	ctx.lr = 0x828CBBEC;
	sub_828CBB20(ctx, base);
	// 828CBBEC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CBBF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CBBF4: 396BE148  addi r11, r11, -0x1eb8
	ctx.r[11].s64 = ctx.r[11].s64 + -7864;
	// 828CBBF8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CBBFC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CBC00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CBC04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CBC08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CBC0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CBC10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CBC10 size=96
    let mut pc: u32 = 0x828CBC10;
    'dispatch: loop {
        match pc {
            0x828CBC10 => {
    //   block [0x828CBC10..0x828CBC70)
	// 828CBC10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CBC14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CBC18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CBC1C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CBC20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CBC24: 4BFFFF9D  bl 0x828cbbc0
	ctx.lr = 0x828CBC28;
	sub_828CBBC0(ctx, base);
	// 828CBC28: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CBC2C: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828CBC30: 396BE180  addi r11, r11, -0x1e80
	ctx.r[11].s64 = ctx.r[11].s64 + -7808;
	// 828CBC34: 388A40A4  addi r4, r10, 0x40a4
	ctx.r[4].s64 = ctx.r[10].s64 + 16548;
	// 828CBC38: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CBC3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CBC40: 48527DC9  bl 0x82df3a08
	ctx.lr = 0x828CBC44;
	sub_82DF3A08(ctx, base);
	// 828CBC44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CBC48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CBC4C: 4858DA9D  bl 0x82e596e8
	ctx.lr = 0x828CBC50;
	sub_82E596E8(ctx, base);
	// 828CBC50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CBC54: 485277D5  bl 0x82df3428
	ctx.lr = 0x828CBC58;
	sub_82DF3428(ctx, base);
	// 828CBC58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CBC5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CBC60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CBC64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CBC68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CBC6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CBC70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CBC70 size=92
    let mut pc: u32 = 0x828CBC70;
    'dispatch: loop {
        match pc {
            0x828CBC70 => {
    //   block [0x828CBC70..0x828CBCCC)
	// 828CBC70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CBC74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CBC78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CBC7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CBC80: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CBC84: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828CBC88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CBC8C: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CBC90: 4BF23BC1  bl 0x827ef850
	ctx.lr = 0x828CBC94;
	sub_827EF850(ctx, base);
	// 828CBC94: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828CBC98: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 828CBC9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CBCA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CBCA4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CBCA8: C02B029C  lfs f1, 0x29c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(668 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CBCAC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828CBCB0: 4E800421  bctrl
	ctx.lr = 0x828CBCB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CBCB4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828CBCB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CBCBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CBCC0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CBCC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CBCC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CBCD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CBCD0 size=76
    let mut pc: u32 = 0x828CBCD0;
    'dispatch: loop {
        match pc {
            0x828CBCD0 => {
    //   block [0x828CBCD0..0x828CBD1C)
	// 828CBCD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CBCD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CBCD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CBCDC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CBCE0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CBCE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CBCE8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CBCEC: 808B0AF4  lwz r4, 0xaf4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2804 as u32) ) } as u64;
	// 828CBCF0: 48527D19  bl 0x82df3a08
	ctx.lr = 0x828CBCF4;
	sub_82DF3A08(ctx, base);
	// 828CBCF4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CBCF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CBCFC: 4BF23A45  bl 0x827ef740
	ctx.lr = 0x828CBD00;
	sub_827EF740(ctx, base);
	// 828CBD00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CBD04: 48527725  bl 0x82df3428
	ctx.lr = 0x828CBD08;
	sub_82DF3428(ctx, base);
	// 828CBD08: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CBD0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CBD10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CBD14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CBD18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CBD20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CBD20 size=196
    let mut pc: u32 = 0x828CBD20;
    'dispatch: loop {
        match pc {
            0x828CBD20 => {
    //   block [0x828CBD20..0x828CBDE4)
	// 828CBD20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CBD24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CBD28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CBD2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CBD30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CBD34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CBD38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CBD3C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828CBD40: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CBD44: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CBD48: 4B9F4BF1  bl 0x822c0938
	ctx.lr = 0x828CBD4C;
	sub_822C0938(ctx, base);
	// 828CBD4C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CBD50: 41820028  beq 0x828cbd78
	if ctx.cr[0].eq {
	pc = 0x828CBD78; continue 'dispatch;
	}
	// 828CBD54: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CBD58: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828CBD5C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CBD60: 392BE1BC  addi r9, r11, -0x1e44
	ctx.r[9].s64 = ctx.r[11].s64 + -7748;
	// 828CBD64: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828CBD68: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CBD6C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828CBD70: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CBD74: 48000008  b 0x828cbd7c
	pc = 0x828CBD7C; continue 'dispatch;
	// 828CBD78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CBD7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CBD80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CBD84: 409A0044  bne cr6, 0x828cbdc8
	if !ctx.cr[6].eq {
	pc = 0x828CBDC8; continue 'dispatch;
	}
	// 828CBD88: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CBD8C: 419A001C  beq cr6, 0x828cbda8
	if ctx.cr[6].eq {
	pc = 0x828CBDA8; continue 'dispatch;
	}
	// 828CBD90: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CBD94: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828CBD98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CBD9C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CBDA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CBDA4: 4E800421  bctrl
	ctx.lr = 0x828CBDA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CBDA8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CBDAC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828CBDB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CBDB4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828CBDB8: 816B4BC0  lwz r11, 0x4bc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19392 as u32) ) } as u64;
	// 828CBDBC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828CBDC0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828CBDC4: 4B9F423D  bl 0x822c0000
	ctx.lr = 0x828CBDC8;
	sub_822C0000(ctx, base);
	// 828CBDC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CBDCC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CBDD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CBDD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CBDD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CBDDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CBDE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CBDE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CBDE8 size=96
    let mut pc: u32 = 0x828CBDE8;
    'dispatch: loop {
        match pc {
            0x828CBDE8 => {
    //   block [0x828CBDE8..0x828CBE48)
	// 828CBDE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CBDEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CBDF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CBDF4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CBDF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CBDFC: 4BFFFDC5  bl 0x828cbbc0
	ctx.lr = 0x828CBE00;
	sub_828CBBC0(ctx, base);
	// 828CBE00: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CBE04: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828CBE08: 396BE1D0  addi r11, r11, -0x1e30
	ctx.r[11].s64 = ctx.r[11].s64 + -7728;
	// 828CBE0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CBE10: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CBE14: 808A0AF0  lwz r4, 0xaf0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2800 as u32) ) } as u64;
	// 828CBE18: 48527BF1  bl 0x82df3a08
	ctx.lr = 0x828CBE1C;
	sub_82DF3A08(ctx, base);
	// 828CBE1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CBE20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CBE24: 4858D8C5  bl 0x82e596e8
	ctx.lr = 0x828CBE28;
	sub_82E596E8(ctx, base);
	// 828CBE28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CBE2C: 485275FD  bl 0x82df3428
	ctx.lr = 0x828CBE30;
	sub_82DF3428(ctx, base);
	// 828CBE30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CBE34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CBE38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CBE3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CBE40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CBE44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CBE48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CBE48 size=112
    let mut pc: u32 = 0x828CBE48;
    'dispatch: loop {
        match pc {
            0x828CBE48 => {
    //   block [0x828CBE48..0x828CBEB8)
	// 828CBE48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CBE4C: 488DC321  bl 0x831a816c
	ctx.lr = 0x828CBE50;
	sub_831A8130(ctx, base);
	// 828CBE50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CBE54: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CBE58: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828CBE5C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CBE60: 388BE208  addi r4, r11, -0x1df8
	ctx.r[4].s64 = ctx.r[11].s64 + -7672;
	// 828CBE64: 38A0002E  li r5, 0x2e
	ctx.r[5].s64 = 46;
	// 828CBE68: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 828CBE6C: 4852657D  bl 0x82df23e8
	ctx.lr = 0x828CBE70;
	sub_82DF23E8(ctx, base);
	// 828CBE70: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CBE74: 41820010  beq 0x828cbe84
	if ctx.cr[0].eq {
	pc = 0x828CBE84; continue 'dispatch;
	}
	// 828CBE78: 4BFFFF71  bl 0x828cbde8
	ctx.lr = 0x828CBE7C;
	sub_828CBDE8(ctx, base);
	// 828CBE7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CBE80: 48000008  b 0x828cbe88
	pc = 0x828CBE88; continue 'dispatch;
	// 828CBE84: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828CBE88: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828CBE8C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828CBE90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CBE94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CBE98: 4BFFFE89  bl 0x828cbd20
	ctx.lr = 0x828CBE9C;
	sub_828CBD20(ctx, base);
	// 828CBE9C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828CBEA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CBEA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CBEA8: 4B9F4159  bl 0x822c0000
	ctx.lr = 0x828CBEAC;
	sub_822C0000(ctx, base);
	// 828CBEAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CBEB0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CBEB4: 488DC308  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CBEB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CBEB8 size=100
    let mut pc: u32 = 0x828CBEB8;
    'dispatch: loop {
        match pc {
            0x828CBEB8 => {
    //   block [0x828CBEB8..0x828CBF1C)
	// 828CBEB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CBEBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CBEC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CBEC4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CBEC8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CBECC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CBED0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CBED4: 808B0B30  lwz r4, 0xb30(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2864 as u32) ) } as u64;
	// 828CBED8: 48527B31  bl 0x82df3a08
	ctx.lr = 0x828CBEDC;
	sub_82DF3A08(ctx, base);
	// 828CBEDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CBEE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CBEE4: 4BF2385D  bl 0x827ef740
	ctx.lr = 0x828CBEE8;
	sub_827EF740(ctx, base);
	// 828CBEE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CBEEC: 4852753D  bl 0x82df3428
	ctx.lr = 0x828CBEF0;
	sub_82DF3428(ctx, base);
	// 828CBEF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CBEF4: 4804A875  bl 0x82916768
	ctx.lr = 0x828CBEF8;
	sub_82916768(ctx, base);
	// 828CBEF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828CBEFC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828CBF00: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CBF04: 48042E75  bl 0x8290ed78
	ctx.lr = 0x828CBF08;
	sub_8290ED78(ctx, base);
	// 828CBF08: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CBF0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CBF10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CBF14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CBF18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CBF20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CBF20 size=120
    let mut pc: u32 = 0x828CBF20;
    'dispatch: loop {
        match pc {
            0x828CBF20 => {
    //   block [0x828CBF20..0x828CBF98)
	// 828CBF20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CBF24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CBF28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CBF2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CBF30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CBF34: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CBF38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CBF3C: 4804A82D  bl 0x82916768
	ctx.lr = 0x828CBF40;
	sub_82916768(ctx, base);
	// 828CBF40: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CBF44: 4182003C  beq 0x828cbf80
	if ctx.cr[0].eq {
	pc = 0x828CBF80; continue 'dispatch;
	}
	// 828CBF48: 4803D641  bl 0x82909588
	ctx.lr = 0x828CBF4C;
	sub_82909588(ctx, base);
	// 828CBF4C: 4807455D  bl 0x829404a8
	ctx.lr = 0x828CBF50;
	sub_829404A8(ctx, base);
	// 828CBF50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CBF54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CBF58: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CBF5C: 4BF238F5  bl 0x827ef850
	ctx.lr = 0x828CBF60;
	sub_827EF850(ctx, base);
	// 828CBF60: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828CBF64: 815E0034  lwz r10, 0x34(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 828CBF68: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CBF6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CBF70: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CBF74: C02B029C  lfs f1, 0x29c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(668 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CBF78: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828CBF7C: 4E800421  bctrl
	ctx.lr = 0x828CBF80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CBF80: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828CBF84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CBF88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CBF8C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CBF90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CBF94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CBF98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CBF98 size=12
    let mut pc: u32 = 0x828CBF98;
    'dispatch: loop {
        match pc {
            0x828CBF98 => {
    //   block [0x828CBF98..0x828CBFA4)
	// 828CBF98: 81630078  lwz r11, 0x78(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 828CBF9C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828CBFA0: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CBFA4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CBFA4 size=8
    let mut pc: u32 = 0x828CBFA4;
    'dispatch: loop {
        match pc {
            0x828CBFA4 => {
    //   block [0x828CBFA4..0x828CBFAC)
	// 828CBFA4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828CBFA8: 4BFFF0D0  b 0x828cb078
	sub_828CB078(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CBFAC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CBFAC size=4
    let mut pc: u32 = 0x828CBFAC;
    'dispatch: loop {
        match pc {
            0x828CBFAC => {
    //   block [0x828CBFAC..0x828CBFB0)
	// 828CBFAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CBFB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CBFB0 size=108
    let mut pc: u32 = 0x828CBFB0;
    'dispatch: loop {
        match pc {
            0x828CBFB0 => {
    //   block [0x828CBFB0..0x828CC01C)
	// 828CBFB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CBFB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CBFB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CBFBC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CBFC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CBFC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CBFC8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CBFCC: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828CBFD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CBFD4: 4E800421  bctrl
	ctx.lr = 0x828CBFD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CBFD8: 4BF1E339  bl 0x827ea310
	ctx.lr = 0x828CBFDC;
	sub_827EA310(ctx, base);
	// 828CBFDC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CBFE0: 41820028  beq 0x828cc008
	if ctx.cr[0].eq {
	pc = 0x828CC008; continue 'dispatch;
	}
	// 828CBFE4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CBFE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CBFEC: 808B0AF8  lwz r4, 0xaf8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2808 as u32) ) } as u64;
	// 828CBFF0: 48527A19  bl 0x82df3a08
	ctx.lr = 0x828CBFF4;
	sub_82DF3A08(ctx, base);
	// 828CBFF4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CBFF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CBFFC: 4BF23745  bl 0x827ef740
	ctx.lr = 0x828CC000;
	sub_827EF740(ctx, base);
	// 828CC000: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CC004: 48527425  bl 0x82df3428
	ctx.lr = 0x828CC008;
	sub_82DF3428(ctx, base);
	// 828CC008: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CC00C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CC010: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CC014: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CC018: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CC020 size=96
    let mut pc: u32 = 0x828CC020;
    'dispatch: loop {
        match pc {
            0x828CC020 => {
    //   block [0x828CC020..0x828CC080)
	// 828CC020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CC024: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CC028: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CC02C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CC030: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CC034: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CC038: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CC03C: 808B4A84  lwz r4, 0x4a84(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19076 as u32) ) } as u64;
	// 828CC040: 485279C9  bl 0x82df3a08
	ctx.lr = 0x828CC044;
	sub_82DF3A08(ctx, base);
	// 828CC044: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC048: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CC04C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CC050: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828CC054: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CC058: 4E800421  bctrl
	ctx.lr = 0x828CC05C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CC05C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CC060: 485273C9  bl 0x82df3428
	ctx.lr = 0x828CC064;
	sub_82DF3428(ctx, base);
	// 828CC064: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CC068: 4BFFF091  bl 0x828cb0f8
	ctx.lr = 0x828CC06C;
	sub_828CB0F8(ctx, base);
	// 828CC06C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CC070: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CC074: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CC078: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CC07C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CC080 size=108
    let mut pc: u32 = 0x828CC080;
    'dispatch: loop {
        match pc {
            0x828CC080 => {
    //   block [0x828CC080..0x828CC0EC)
	// 828CC080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CC084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CC088: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CC08C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CC090: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CC094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CC098: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC09C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828CC0A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CC0A4: 4E800421  bctrl
	ctx.lr = 0x828CC0A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CC0A8: 4BF1E269  bl 0x827ea310
	ctx.lr = 0x828CC0AC;
	sub_827EA310(ctx, base);
	// 828CC0AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CC0B0: 41820028  beq 0x828cc0d8
	if ctx.cr[0].eq {
	pc = 0x828CC0D8; continue 'dispatch;
	}
	// 828CC0B4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CC0B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CC0BC: 808B0B30  lwz r4, 0xb30(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2864 as u32) ) } as u64;
	// 828CC0C0: 48527949  bl 0x82df3a08
	ctx.lr = 0x828CC0C4;
	sub_82DF3A08(ctx, base);
	// 828CC0C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CC0C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CC0CC: 4BF23675  bl 0x827ef740
	ctx.lr = 0x828CC0D0;
	sub_827EF740(ctx, base);
	// 828CC0D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CC0D4: 48527355  bl 0x82df3428
	ctx.lr = 0x828CC0D8;
	sub_82DF3428(ctx, base);
	// 828CC0D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CC0DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CC0E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CC0E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CC0E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CC0F0 size=8
    let mut pc: u32 = 0x828CC0F0;
    'dispatch: loop {
        match pc {
            0x828CC0F0 => {
    //   block [0x828CC0F0..0x828CC0F8)
	// 828CC0F0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828CC0F4: 4BFFEFC4  b 0x828cb0b8
	sub_828CB0B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC0F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CC0F8 size=128
    let mut pc: u32 = 0x828CC0F8;
    'dispatch: loop {
        match pc {
            0x828CC0F8 => {
    //   block [0x828CC0F8..0x828CC178)
	// 828CC0F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CC0FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CC100: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CC104: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CC108: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CC10C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CC110: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CC114: 4804A655  bl 0x82916768
	ctx.lr = 0x828CC118;
	sub_82916768(ctx, base);
	// 828CC118: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CC11C: 4182003C  beq 0x828cc158
	if ctx.cr[0].eq {
	pc = 0x828CC158; continue 'dispatch;
	}
	// 828CC120: 4803D469  bl 0x82909588
	ctx.lr = 0x828CC124;
	sub_82909588(ctx, base);
	// 828CC124: 48074385  bl 0x829404a8
	ctx.lr = 0x828CC128;
	sub_829404A8(ctx, base);
	// 828CC128: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CC12C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CC130: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC134: 4BF2371D  bl 0x827ef850
	ctx.lr = 0x828CC138;
	sub_827EF850(ctx, base);
	// 828CC138: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828CC13C: 815E0034  lwz r10, 0x34(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 828CC140: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CC144: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CC148: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CC14C: C02B029C  lfs f1, 0x29c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(668 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CC150: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828CC154: 4E800421  bctrl
	ctx.lr = 0x828CC158;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CC158: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CC15C: 4BFFEF9D  bl 0x828cb0f8
	ctx.lr = 0x828CC160;
	sub_828CB0F8(ctx, base);
	// 828CC160: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828CC164: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CC168: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CC16C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CC170: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CC174: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CC178 size=64
    let mut pc: u32 = 0x828CC178;
    'dispatch: loop {
        match pc {
            0x828CC178 => {
    //   block [0x828CC178..0x828CC1B8)
	// 828CC178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CC17C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CC180: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CC184: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CC188: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CC18C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CC190: 4BFFEF29  bl 0x828cb0b8
	ctx.lr = 0x828CC194;
	sub_828CB0B8(ctx, base);
	// 828CC194: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828CC198: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828CC19C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CC1A0: 4804AE81  bl 0x82917020
	ctx.lr = 0x828CC1A4;
	sub_82917020(ctx, base);
	// 828CC1A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CC1A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CC1AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CC1B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CC1B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC1B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828CC1B8 size=16
    let mut pc: u32 = 0x828CC1B8;
    'dispatch: loop {
        match pc {
            0x828CC1B8 => {
    //   block [0x828CC1B8..0x828CC1C8)
	// 828CC1B8: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC1BC: 816C0034  lwz r11, 0x34(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(52 as u32) ) } as u64;
	// 828CC1C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CC1C4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CC1C8 size=140
    let mut pc: u32 = 0x828CC1C8;
    'dispatch: loop {
        match pc {
            0x828CC1C8 => {
    //   block [0x828CC1C8..0x828CC254)
	// 828CC1C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CC1CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CC1D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CC1D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CC1D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CC1DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828CC1E0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828CC1E4: C01F0074  lfs f0, 0x74(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CC1E8: EDA00828  fsubs f13, f0, f1
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 828CC1EC: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CC1F0: D1BF0074  stfs f13, 0x74(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828CC1F4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828CC1F8: 41990048  bgt cr6, 0x828cc240
	if ctx.cr[6].gt {
	pc = 0x828CC240; continue 'dispatch;
	}
	// 828CC1FC: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 828CC200: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828CC204: 409A001C  bne cr6, 0x828cc220
	if !ctx.cr[6].eq {
	pc = 0x828CC220; continue 'dispatch;
	}
	// 828CC208: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 828CC20C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CC210: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828CC214: 4BFFEE65  bl 0x828cb078
	ctx.lr = 0x828CC218;
	sub_828CB078(ctx, base);
	// 828CC218: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CC21C: 48000020  b 0x828cc23c
	pc = 0x828CC23C; continue 'dispatch;
	// 828CC220: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CC224: 409A001C  bne cr6, 0x828cc240
	if !ctx.cr[6].eq {
	pc = 0x828CC240; continue 'dispatch;
	}
	// 828CC228: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 828CC22C: C00B0008  lfs f0, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CC230: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828CC234: 4BFFEE05  bl 0x828cb038
	ctx.lr = 0x828CC238;
	sub_828CB038(ctx, base);
	// 828CC238: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828CC23C: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 828CC240: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828CC244: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CC248: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CC24C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CC250: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CC258 size=196
    let mut pc: u32 = 0x828CC258;
    'dispatch: loop {
        match pc {
            0x828CC258 => {
    //   block [0x828CC258..0x828CC31C)
	// 828CC258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CC25C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CC260: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CC264: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CC268: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CC26C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CC270: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CC274: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828CC278: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CC27C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CC280: 4B9F46B9  bl 0x822c0938
	ctx.lr = 0x828CC284;
	sub_822C0938(ctx, base);
	// 828CC284: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CC288: 41820028  beq 0x828cc2b0
	if ctx.cr[0].eq {
	pc = 0x828CC2B0; continue 'dispatch;
	}
	// 828CC28C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CC290: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828CC294: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CC298: 392BE298  addi r9, r11, -0x1d68
	ctx.r[9].s64 = ctx.r[11].s64 + -7528;
	// 828CC29C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828CC2A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CC2A4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828CC2A8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CC2AC: 48000008  b 0x828cc2b4
	pc = 0x828CC2B4; continue 'dispatch;
	// 828CC2B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CC2B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CC2B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CC2BC: 409A0044  bne cr6, 0x828cc300
	if !ctx.cr[6].eq {
	pc = 0x828CC300; continue 'dispatch;
	}
	// 828CC2C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CC2C4: 419A001C  beq cr6, 0x828cc2e0
	if ctx.cr[6].eq {
	pc = 0x828CC2E0; continue 'dispatch;
	}
	// 828CC2C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC2CC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828CC2D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CC2D4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC2D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CC2DC: 4E800421  bctrl
	ctx.lr = 0x828CC2E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CC2E0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CC2E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828CC2E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CC2EC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828CC2F0: 816B4C60  lwz r11, 0x4c60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19552 as u32) ) } as u64;
	// 828CC2F4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828CC2F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828CC2FC: 4B9F3D05  bl 0x822c0000
	ctx.lr = 0x828CC300;
	sub_822C0000(ctx, base);
	// 828CC300: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CC304: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CC308: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CC30C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CC310: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CC314: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CC318: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CC320 size=196
    let mut pc: u32 = 0x828CC320;
    'dispatch: loop {
        match pc {
            0x828CC320 => {
    //   block [0x828CC320..0x828CC3E4)
	// 828CC320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CC324: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CC328: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CC32C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CC330: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CC334: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CC338: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CC33C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828CC340: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CC344: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CC348: 4B9F45F1  bl 0x822c0938
	ctx.lr = 0x828CC34C;
	sub_822C0938(ctx, base);
	// 828CC34C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CC350: 41820028  beq 0x828cc378
	if ctx.cr[0].eq {
	pc = 0x828CC378; continue 'dispatch;
	}
	// 828CC354: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CC358: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828CC35C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CC360: 392BE2AC  addi r9, r11, -0x1d54
	ctx.r[9].s64 = ctx.r[11].s64 + -7508;
	// 828CC364: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828CC368: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CC36C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828CC370: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CC374: 48000008  b 0x828cc37c
	pc = 0x828CC37C; continue 'dispatch;
	// 828CC378: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CC37C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CC380: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CC384: 409A0044  bne cr6, 0x828cc3c8
	if !ctx.cr[6].eq {
	pc = 0x828CC3C8; continue 'dispatch;
	}
	// 828CC388: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CC38C: 419A001C  beq cr6, 0x828cc3a8
	if ctx.cr[6].eq {
	pc = 0x828CC3A8; continue 'dispatch;
	}
	// 828CC390: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC394: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828CC398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CC39C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC3A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CC3A4: 4E800421  bctrl
	ctx.lr = 0x828CC3A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CC3A8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CC3AC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828CC3B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CC3B4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828CC3B8: 816B4C60  lwz r11, 0x4c60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19552 as u32) ) } as u64;
	// 828CC3BC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828CC3C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828CC3C4: 4B9F3C3D  bl 0x822c0000
	ctx.lr = 0x828CC3C8;
	sub_822C0000(ctx, base);
	// 828CC3C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CC3CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CC3D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CC3D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CC3D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CC3DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CC3E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CC3E8 size=196
    let mut pc: u32 = 0x828CC3E8;
    'dispatch: loop {
        match pc {
            0x828CC3E8 => {
    //   block [0x828CC3E8..0x828CC4AC)
	// 828CC3E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CC3EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CC3F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CC3F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CC3F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CC3FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CC400: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CC404: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828CC408: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CC40C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CC410: 4B9F4529  bl 0x822c0938
	ctx.lr = 0x828CC414;
	sub_822C0938(ctx, base);
	// 828CC414: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CC418: 41820028  beq 0x828cc440
	if ctx.cr[0].eq {
	pc = 0x828CC440; continue 'dispatch;
	}
	// 828CC41C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CC420: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828CC424: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CC428: 392BE2C0  addi r9, r11, -0x1d40
	ctx.r[9].s64 = ctx.r[11].s64 + -7488;
	// 828CC42C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828CC430: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CC434: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828CC438: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CC43C: 48000008  b 0x828cc444
	pc = 0x828CC444; continue 'dispatch;
	// 828CC440: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CC444: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CC448: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CC44C: 409A0044  bne cr6, 0x828cc490
	if !ctx.cr[6].eq {
	pc = 0x828CC490; continue 'dispatch;
	}
	// 828CC450: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CC454: 419A001C  beq cr6, 0x828cc470
	if ctx.cr[6].eq {
	pc = 0x828CC470; continue 'dispatch;
	}
	// 828CC458: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC45C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828CC460: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CC464: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC468: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CC46C: 4E800421  bctrl
	ctx.lr = 0x828CC470;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CC470: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CC474: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828CC478: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CC47C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828CC480: 816B4C60  lwz r11, 0x4c60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19552 as u32) ) } as u64;
	// 828CC484: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828CC488: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828CC48C: 4B9F3B75  bl 0x822c0000
	ctx.lr = 0x828CC490;
	sub_822C0000(ctx, base);
	// 828CC490: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CC494: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CC498: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CC49C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CC4A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CC4A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CC4A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC4B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CC4B0 size=196
    let mut pc: u32 = 0x828CC4B0;
    'dispatch: loop {
        match pc {
            0x828CC4B0 => {
    //   block [0x828CC4B0..0x828CC574)
	// 828CC4B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CC4B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CC4B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CC4BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CC4C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CC4C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CC4C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CC4CC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828CC4D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CC4D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CC4D8: 4B9F4461  bl 0x822c0938
	ctx.lr = 0x828CC4DC;
	sub_822C0938(ctx, base);
	// 828CC4DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CC4E0: 41820028  beq 0x828cc508
	if ctx.cr[0].eq {
	pc = 0x828CC508; continue 'dispatch;
	}
	// 828CC4E4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CC4E8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828CC4EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CC4F0: 392BE2D4  addi r9, r11, -0x1d2c
	ctx.r[9].s64 = ctx.r[11].s64 + -7468;
	// 828CC4F4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828CC4F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CC4FC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828CC500: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CC504: 48000008  b 0x828cc50c
	pc = 0x828CC50C; continue 'dispatch;
	// 828CC508: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CC50C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CC510: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CC514: 409A0044  bne cr6, 0x828cc558
	if !ctx.cr[6].eq {
	pc = 0x828CC558; continue 'dispatch;
	}
	// 828CC518: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CC51C: 419A001C  beq cr6, 0x828cc538
	if ctx.cr[6].eq {
	pc = 0x828CC538; continue 'dispatch;
	}
	// 828CC520: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC524: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828CC528: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CC52C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC530: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CC534: 4E800421  bctrl
	ctx.lr = 0x828CC538;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CC538: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CC53C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828CC540: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CC544: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828CC548: 816B4C60  lwz r11, 0x4c60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19552 as u32) ) } as u64;
	// 828CC54C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828CC550: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828CC554: 4B9F3AAD  bl 0x822c0000
	ctx.lr = 0x828CC558;
	sub_822C0000(ctx, base);
	// 828CC558: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CC55C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CC560: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CC564: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CC568: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CC56C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CC570: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CC578 size=196
    let mut pc: u32 = 0x828CC578;
    'dispatch: loop {
        match pc {
            0x828CC578 => {
    //   block [0x828CC578..0x828CC63C)
	// 828CC578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CC57C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CC580: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CC584: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CC588: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CC58C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CC590: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CC594: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828CC598: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CC59C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CC5A0: 4B9F4399  bl 0x822c0938
	ctx.lr = 0x828CC5A4;
	sub_822C0938(ctx, base);
	// 828CC5A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CC5A8: 41820028  beq 0x828cc5d0
	if ctx.cr[0].eq {
	pc = 0x828CC5D0; continue 'dispatch;
	}
	// 828CC5AC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CC5B0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828CC5B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CC5B8: 392BE2E8  addi r9, r11, -0x1d18
	ctx.r[9].s64 = ctx.r[11].s64 + -7448;
	// 828CC5BC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828CC5C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CC5C4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828CC5C8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CC5CC: 48000008  b 0x828cc5d4
	pc = 0x828CC5D4; continue 'dispatch;
	// 828CC5D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CC5D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CC5D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CC5DC: 409A0044  bne cr6, 0x828cc620
	if !ctx.cr[6].eq {
	pc = 0x828CC620; continue 'dispatch;
	}
	// 828CC5E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CC5E4: 419A001C  beq cr6, 0x828cc600
	if ctx.cr[6].eq {
	pc = 0x828CC600; continue 'dispatch;
	}
	// 828CC5E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC5EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828CC5F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CC5F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC5F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CC5FC: 4E800421  bctrl
	ctx.lr = 0x828CC600;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CC600: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CC604: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828CC608: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CC60C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828CC610: 816B4C60  lwz r11, 0x4c60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19552 as u32) ) } as u64;
	// 828CC614: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828CC618: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828CC61C: 4B9F39E5  bl 0x822c0000
	ctx.lr = 0x828CC620;
	sub_822C0000(ctx, base);
	// 828CC620: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CC624: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CC628: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CC62C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CC630: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CC634: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CC638: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CC640 size=196
    let mut pc: u32 = 0x828CC640;
    'dispatch: loop {
        match pc {
            0x828CC640 => {
    //   block [0x828CC640..0x828CC704)
	// 828CC640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CC644: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CC648: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CC64C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CC650: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CC654: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CC658: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CC65C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828CC660: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CC664: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CC668: 4B9F42D1  bl 0x822c0938
	ctx.lr = 0x828CC66C;
	sub_822C0938(ctx, base);
	// 828CC66C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CC670: 41820028  beq 0x828cc698
	if ctx.cr[0].eq {
	pc = 0x828CC698; continue 'dispatch;
	}
	// 828CC674: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CC678: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828CC67C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CC680: 392BE2FC  addi r9, r11, -0x1d04
	ctx.r[9].s64 = ctx.r[11].s64 + -7428;
	// 828CC684: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828CC688: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CC68C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828CC690: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CC694: 48000008  b 0x828cc69c
	pc = 0x828CC69C; continue 'dispatch;
	// 828CC698: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CC69C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CC6A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CC6A4: 409A0044  bne cr6, 0x828cc6e8
	if !ctx.cr[6].eq {
	pc = 0x828CC6E8; continue 'dispatch;
	}
	// 828CC6A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CC6AC: 419A001C  beq cr6, 0x828cc6c8
	if ctx.cr[6].eq {
	pc = 0x828CC6C8; continue 'dispatch;
	}
	// 828CC6B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC6B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828CC6B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CC6BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC6C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CC6C4: 4E800421  bctrl
	ctx.lr = 0x828CC6C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CC6C8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CC6CC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828CC6D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CC6D4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828CC6D8: 816B4C60  lwz r11, 0x4c60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19552 as u32) ) } as u64;
	// 828CC6DC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828CC6E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828CC6E4: 4B9F391D  bl 0x822c0000
	ctx.lr = 0x828CC6E8;
	sub_822C0000(ctx, base);
	// 828CC6E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CC6EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CC6F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CC6F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CC6F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CC6FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CC700: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CC708 size=196
    let mut pc: u32 = 0x828CC708;
    'dispatch: loop {
        match pc {
            0x828CC708 => {
    //   block [0x828CC708..0x828CC7CC)
	// 828CC708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CC70C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CC710: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CC714: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CC718: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CC71C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CC720: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CC724: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828CC728: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CC72C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CC730: 4B9F4209  bl 0x822c0938
	ctx.lr = 0x828CC734;
	sub_822C0938(ctx, base);
	// 828CC734: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CC738: 41820028  beq 0x828cc760
	if ctx.cr[0].eq {
	pc = 0x828CC760; continue 'dispatch;
	}
	// 828CC73C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CC740: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828CC744: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CC748: 392BE310  addi r9, r11, -0x1cf0
	ctx.r[9].s64 = ctx.r[11].s64 + -7408;
	// 828CC74C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828CC750: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CC754: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828CC758: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CC75C: 48000008  b 0x828cc764
	pc = 0x828CC764; continue 'dispatch;
	// 828CC760: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CC764: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CC768: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CC76C: 409A0044  bne cr6, 0x828cc7b0
	if !ctx.cr[6].eq {
	pc = 0x828CC7B0; continue 'dispatch;
	}
	// 828CC770: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CC774: 419A001C  beq cr6, 0x828cc790
	if ctx.cr[6].eq {
	pc = 0x828CC790; continue 'dispatch;
	}
	// 828CC778: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC77C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828CC780: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CC784: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC788: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CC78C: 4E800421  bctrl
	ctx.lr = 0x828CC790;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CC790: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CC794: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828CC798: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CC79C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828CC7A0: 816B4C60  lwz r11, 0x4c60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19552 as u32) ) } as u64;
	// 828CC7A4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828CC7A8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828CC7AC: 4B9F3855  bl 0x822c0000
	ctx.lr = 0x828CC7B0;
	sub_822C0000(ctx, base);
	// 828CC7B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CC7B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CC7B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CC7BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CC7C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CC7C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CC7C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC7D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CC7D0 size=196
    let mut pc: u32 = 0x828CC7D0;
    'dispatch: loop {
        match pc {
            0x828CC7D0 => {
    //   block [0x828CC7D0..0x828CC894)
	// 828CC7D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CC7D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CC7D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CC7DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CC7E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CC7E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CC7E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CC7EC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828CC7F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CC7F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CC7F8: 4B9F4141  bl 0x822c0938
	ctx.lr = 0x828CC7FC;
	sub_822C0938(ctx, base);
	// 828CC7FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CC800: 41820028  beq 0x828cc828
	if ctx.cr[0].eq {
	pc = 0x828CC828; continue 'dispatch;
	}
	// 828CC804: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CC808: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828CC80C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CC810: 392BE324  addi r9, r11, -0x1cdc
	ctx.r[9].s64 = ctx.r[11].s64 + -7388;
	// 828CC814: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828CC818: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CC81C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828CC820: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CC824: 48000008  b 0x828cc82c
	pc = 0x828CC82C; continue 'dispatch;
	// 828CC828: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CC82C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CC830: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CC834: 409A0044  bne cr6, 0x828cc878
	if !ctx.cr[6].eq {
	pc = 0x828CC878; continue 'dispatch;
	}
	// 828CC838: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CC83C: 419A001C  beq cr6, 0x828cc858
	if ctx.cr[6].eq {
	pc = 0x828CC858; continue 'dispatch;
	}
	// 828CC840: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC844: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828CC848: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CC84C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CC850: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CC854: 4E800421  bctrl
	ctx.lr = 0x828CC858;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CC858: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CC85C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828CC860: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CC864: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828CC868: 816B4C60  lwz r11, 0x4c60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19552 as u32) ) } as u64;
	// 828CC86C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828CC870: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828CC874: 4B9F378D  bl 0x822c0000
	ctx.lr = 0x828CC878;
	sub_822C0000(ctx, base);
	// 828CC878: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CC87C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CC880: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CC884: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CC888: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CC88C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CC890: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CC898 size=196
    let mut pc: u32 = 0x828CC898;
    'dispatch: loop {
        match pc {
            0x828CC898 => {
    //   block [0x828CC898..0x828CC95C)
	// 828CC898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CC89C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CC8A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CC8A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CC8A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CC8AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CC8B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CC8B4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828CC8B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CC8BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CC8C0: 4B9F4079  bl 0x822c0938
	ctx.lr = 0x828CC8C4;
	sub_822C0938(ctx, base);
	// 828CC8C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CC8C8: 41820028  beq 0x828cc8f0
	if ctx.cr[0].eq {
	pc = 0x828CC8F0; continue 'dispatch;
	}
	// 828CC8CC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CC8D0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828CC8D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828CC8D8: 392BE338  addi r9, r11, -0x1cc8
	ctx.r[9].s64 = ctx.r[11].s64 + -7368;
	// 828CC8DC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828CC8E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CC8E4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828CC8E8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828CC8EC: 48000008  b 0x828cc8f4
	pc = 0x828CC8F4; continue 'dispatch;
	// 828CC8F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CC8F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CC8F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CC8FC: 409A0044  bne cr6, 0x828cc940
	if !ctx.cr[6].eq {
	pc = 0x828CC940; continue 'dispatch;
	}
	// 828CC900: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CC904: 419A001C  beq cr6, 0x828cc920
	if ctx.cr[6].eq {
	pc = 0x828CC920; continue 'dispatch;
	}
	// 828CC908: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC90C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828CC910: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CC914: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC918: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CC91C: 4E800421  bctrl
	ctx.lr = 0x828CC920;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CC920: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CC924: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828CC928: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CC92C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828CC930: 816B4C60  lwz r11, 0x4c60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19552 as u32) ) } as u64;
	// 828CC934: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828CC938: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828CC93C: 4B9F36C5  bl 0x822c0000
	ctx.lr = 0x828CC940;
	sub_822C0000(ctx, base);
	// 828CC940: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CC944: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CC948: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CC94C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CC950: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CC954: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CC958: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CC960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CC960 size=472
    let mut pc: u32 = 0x828CC960;
    'dispatch: loop {
        match pc {
            0x828CC960 => {
    //   block [0x828CC960..0x828CCB38)
	// 828CC960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CC964: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CC968: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CC96C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CC970: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 828CC974: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828CC978: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CC97C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CC980: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828CC984: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CC988: 48049DE1  bl 0x82916768
	ctx.lr = 0x828CC98C;
	sub_82916768(ctx, base);
	// 828CC98C: 4803CBFD  bl 0x82909588
	ctx.lr = 0x828CC990;
	sub_82909588(ctx, base);
	// 828CC990: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 828CC994: 48073ABD  bl 0x82940450
	ctx.lr = 0x828CC998;
	sub_82940450(ctx, base);
	// 828CC998: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CC99C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CC9A0: 48075D31  bl 0x829426d0
	ctx.lr = 0x828CC9A4;
	sub_829426D0(ctx, base);
	// 828CC9A4: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828CC9A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CC9AC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828CC9B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CC9B4: 4E800421  bctrl
	ctx.lr = 0x828CC9B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CC9B8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CC9BC: 4182003C  beq 0x828cc9f8
	if ctx.cr[0].eq {
	pc = 0x828CC9F8; continue 'dispatch;
	}
	// 828CC9C0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CC9C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CC9C8: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828CC9CC: 4852703D  bl 0x82df3a08
	ctx.lr = 0x828CC9D0;
	sub_82DF3A08(ctx, base);
	// 828CC9D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CC9D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CC9D8: 4BF22D69  bl 0x827ef740
	ctx.lr = 0x828CC9DC;
	sub_827EF740(ctx, base);
	// 828CC9DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CC9E0: 48526A49  bl 0x82df3428
	ctx.lr = 0x828CC9E4;
	sub_82DF3428(ctx, base);
	// 828CC9E4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828CC9E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CC9EC: 419A012C  beq cr6, 0x828ccb18
	if ctx.cr[6].eq {
	pc = 0x828CCB18; continue 'dispatch;
	}
	// 828CC9F0: 4B9F3EA1  bl 0x822c0890
	ctx.lr = 0x828CC9F4;
	sub_822C0890(ctx, base);
	// 828CC9F4: 48000124  b 0x828ccb18
	pc = 0x828CCB18; continue 'dispatch;
	// 828CC9F8: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828CC9FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CCA00: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828CCA04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CCA08: 4E800421  bctrl
	ctx.lr = 0x828CCA0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CCA0C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CCA10: 3FC0832D  lis r30, -0x7cd3
	ctx.r[30].s64 = -2094202880;
	// 828CCA14: 4082003C  bne 0x828cca50
	if !ctx.cr[0].eq {
	pc = 0x828CCA50; continue 'dispatch;
	}
	// 828CCA18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CCA1C: 48049D4D  bl 0x82916768
	ctx.lr = 0x828CCA20;
	sub_82916768(ctx, base);
	// 828CCA20: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828CCA24: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828CCA28: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CCA2C: 4804234D  bl 0x8290ed78
	ctx.lr = 0x828CCA30;
	sub_8290ED78(ctx, base);
	// 828CCA30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CCA34: 809E0B10  lwz r4, 0xb10(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(2832 as u32) ) } as u64;
	// 828CCA38: 48526FD1  bl 0x82df3a08
	ctx.lr = 0x828CCA3C;
	sub_82DF3A08(ctx, base);
	// 828CCA3C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CCA40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CCA44: 4BF22CFD  bl 0x827ef740
	ctx.lr = 0x828CCA48;
	sub_827EF740(ctx, base);
	// 828CCA48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CCA4C: 485269DD  bl 0x82df3428
	ctx.lr = 0x828CCA50;
	sub_82DF3428(ctx, base);
	// 828CCA50: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828CCA54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CCA58: 419A0008  beq cr6, 0x828cca60
	if ctx.cr[6].eq {
	pc = 0x828CCA60; continue 'dispatch;
	}
	// 828CCA5C: 4B9F3E35  bl 0x822c0890
	ctx.lr = 0x828CCA60;
	sub_822C0890(ctx, base);
	// 828CCA60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CCA64: 4BFF5E6D  bl 0x828c28d0
	ctx.lr = 0x828CCA68;
	sub_828C28D0(ctx, base);
	// 828CCA68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CCA6C: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 828CCA70: 4BFFE6C9  bl 0x828cb138
	ctx.lr = 0x828CCA74;
	sub_828CB138(ctx, base);
	// 828CCA74: C003007C  lfs f0, 0x7c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CCA78: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 828CCA7C: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 828CCA80: 40990024  ble cr6, 0x828ccaa4
	if !ctx.cr[6].gt {
	pc = 0x828CCAA4; continue 'dispatch;
	}
	// 828CCA84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CCA88: 809E0B10  lwz r4, 0xb10(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(2832 as u32) ) } as u64;
	// 828CCA8C: 48526F7D  bl 0x82df3a08
	ctx.lr = 0x828CCA90;
	sub_82DF3A08(ctx, base);
	// 828CCA90: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CCA94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CCA98: 4BF22CA9  bl 0x827ef740
	ctx.lr = 0x828CCA9C;
	sub_827EF740(ctx, base);
	// 828CCA9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CCAA0: 48526989  bl 0x82df3428
	ctx.lr = 0x828CCAA4;
	sub_82DF3428(ctx, base);
	// 828CCAA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CCAA8: 48049CC1  bl 0x82916768
	ctx.lr = 0x828CCAAC;
	sub_82916768(ctx, base);
	// 828CCAAC: 4803CADD  bl 0x82909588
	ctx.lr = 0x828CCAB0;
	sub_82909588(ctx, base);
	// 828CCAB0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828CCAB4: 41820064  beq 0x828ccb18
	if ctx.cr[0].eq {
	pc = 0x828CCB18; continue 'dispatch;
	}
	// 828CCAB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CCABC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828CCAC0: 48073859  bl 0x82940318
	ctx.lr = 0x828CCAC4;
	sub_82940318(ctx, base);
	// 828CCAC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CCAC8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CCACC: 4807373D  bl 0x82940208
	ctx.lr = 0x828CCAD0;
	sub_82940208(ctx, base);
	// 828CCAD0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828CCAD4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828CCAD8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828CCADC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CCAE0: C02BD8B0  lfs f1, -0x2750(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10064 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CCAE4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CCAE8: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828CCAEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CCAF0: 4E800421  bctrl
	ctx.lr = 0x828CCAF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CCAF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CCAF8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828CCAFC: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CCB00: 48073719  bl 0x82940218
	ctx.lr = 0x828CCB04;
	sub_82940218(ctx, base);
	// 828CCB04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CCB08: 817E003C  lwz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CCB0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CCB10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CCB14: 4E800421  bctrl
	ctx.lr = 0x828CCB18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CCB18: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828CCB1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CCB20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CCB24: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828CCB28: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828CCB2C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CCB30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CCB34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CCB38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CCB38 size=300
    let mut pc: u32 = 0x828CCB38;
    'dispatch: loop {
        match pc {
            0x828CCB38 => {
    //   block [0x828CCB38..0x828CCC64)
	// 828CCB38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CCB3C: 488DB631  bl 0x831a816c
	ctx.lr = 0x828CCB40;
	sub_831A8130(ctx, base);
	// 828CCB40: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CCB44: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828CCB48: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828CCB4C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828CCB50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CCB54: 3BCB4C80  addi r30, r11, 0x4c80
	ctx.r[30].s64 = ctx.r[11].s64 + 19584;
	// 828CCB58: 3BAA4C70  addi r29, r10, 0x4c70
	ctx.r[29].s64 = ctx.r[10].s64 + 19568;
	// 828CCB5C: 4BF22C55  bl 0x827ef7b0
	ctx.lr = 0x828CCB60;
	sub_827EF7B0(ctx, base);
	// 828CCB60: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CCB64: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CCB68: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828CCB6C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 828CCB70: 485B04F1  bl 0x82e7d060
	ctx.lr = 0x828CCB74;
	sub_82E7D060(ctx, base);
	// 828CCB74: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CCB78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CCB7C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828CCB80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CCB84: 4E800421  bctrl
	ctx.lr = 0x828CCB88;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CCC68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CCC68 size=180
    let mut pc: u32 = 0x828CCC68;
    'dispatch: loop {
        match pc {
            0x828CCC68 => {
    //   block [0x828CCC68..0x828CCD1C)
	// 828CCC68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CCC6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CCC70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CCC74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CCC78: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CCC7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CCC80: 4BF22AB9  bl 0x827ef738
	ctx.lr = 0x828CCC84;
	sub_827EF738(ctx, base);
	// 828CCC84: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CCC88: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CCC8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CCC90: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CCC94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CCC98: 4E800421  bctrl
	ctx.lr = 0x828CCC9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CCC9C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 828CCCA0: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828CCCA4: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 828CCCA8: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 828CCCAC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828CCCB0: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 828CCCB4: 13DE58C7  vcmpequd (lvx128) v30, v30, v11
	tmp.u32 = ctx.r[30].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828CCCB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CCD20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CCD20 size=264
    let mut pc: u32 = 0x828CCD20;
    'dispatch: loop {
        match pc {
            0x828CCD20 => {
    //   block [0x828CCD20..0x828CCE28)
	// 828CCD20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CCD24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CCD28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CCD2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CCD30: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828CCD34: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CCD38: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CCD3C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828CCD40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CCD44: 4BFF5A55  bl 0x828c2798
	ctx.lr = 0x828CCD48;
	sub_828C2798(ctx, base);
	// 828CCD48: 4804F0D1  bl 0x8291be18
	ctx.lr = 0x828CCD4C;
	sub_8291BE18(ctx, base);
	// 828CCD4C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CCD50: 41820010  beq 0x828ccd60
	if ctx.cr[0].eq {
	pc = 0x828CCD60; continue 'dispatch;
	}
	// 828CCD54: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CCD58: 808B0B08  lwz r4, 0xb08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2824 as u32) ) } as u64;
	// 828CCD5C: 4800001C  b 0x828ccd78
	pc = 0x828CCD78; continue 'dispatch;
	// 828CCD60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CCD64: 4BFFFF05  bl 0x828ccc68
	ctx.lr = 0x828CCD68;
	sub_828CCC68(ctx, base);
	// 828CCD68: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CCD6C: 4182002C  beq 0x828ccd98
	if ctx.cr[0].eq {
	pc = 0x828CCD98; continue 'dispatch;
	}
	// 828CCD70: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CCD74: 808B0AF4  lwz r4, 0xaf4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2804 as u32) ) } as u64;
	// 828CCD78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CCD7C: 48526C8D  bl 0x82df3a08
	ctx.lr = 0x828CCD80;
	sub_82DF3A08(ctx, base);
	// 828CCD80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CCD84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CCD88: 4BF229B9  bl 0x827ef740
	ctx.lr = 0x828CCD8C;
	sub_827EF740(ctx, base);
	// 828CCD8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CCD90: 48526699  bl 0x82df3428
	ctx.lr = 0x828CCD94;
	sub_82DF3428(ctx, base);
	// 828CCD94: 48000078  b 0x828cce0c
	pc = 0x828CCE0C; continue 'dispatch;
	// 828CCD98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CCD9C: 480499CD  bl 0x82916768
	ctx.lr = 0x828CCDA0;
	sub_82916768(ctx, base);
	// 828CCDA0: 4803C7E9  bl 0x82909588
	ctx.lr = 0x828CCDA4;
	sub_82909588(ctx, base);
	// 828CCDA4: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828CCDA8: 41820064  beq 0x828cce0c
	if ctx.cr[0].eq {
	pc = 0x828CCE0C; continue 'dispatch;
	}
	// 828CCDAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CCDB0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828CCDB4: 48073565  bl 0x82940318
	ctx.lr = 0x828CCDB8;
	sub_82940318(ctx, base);
	// 828CCDB8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CCDBC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CCDC0: 48073449  bl 0x82940208
	ctx.lr = 0x828CCDC4;
	sub_82940208(ctx, base);
	// 828CCDC4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828CCDC8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828CCDCC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828CCDD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CCDD4: C02BD8B0  lfs f1, -0x2750(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10064 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828CCDD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CCDDC: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828CCDE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CCDE4: 4E800421  bctrl
	ctx.lr = 0x828CCDE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CCDE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CCDEC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828CCDF0: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CCDF4: 48073425  bl 0x82940218
	ctx.lr = 0x828CCDF8;
	sub_82940218(ctx, base);
	// 828CCDF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CCDFC: 817E003C  lwz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 828CCE00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CCE04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CCE08: 4E800421  bctrl
	ctx.lr = 0x828CCE0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CCE0C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828CCE10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CCE14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CCE18: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828CCE1C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CCE20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CCE24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CCE28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CCE28 size=348
    let mut pc: u32 = 0x828CCE28;
    'dispatch: loop {
        match pc {
            0x828CCE28 => {
    //   block [0x828CCE28..0x828CCF84)
	// 828CCE28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CCE2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CCE30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CCE34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CCE38: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CCE3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CCE40: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828CCE44: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828CCE48: 485AFFC1  bl 0x82e7ce08
	ctx.lr = 0x828CCE4C;
	sub_82E7CE08(ctx, base);
	// 828CCE4C: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CCF88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CCF88 size=520
    let mut pc: u32 = 0x828CCF88;
    'dispatch: loop {
        match pc {
            0x828CCF88 => {
    //   block [0x828CCF88..0x828CD190)
	// 828CCF88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CCF8C: 488DB1CD  bl 0x831a8158
	ctx.lr = 0x828CCF90;
	sub_831A8130(ctx, base);
	// 828CCF90: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CCF94: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 828CCF98: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 828CCF9C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828CCFA0: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 828CCFA4: 480497C5  bl 0x82916768
	ctx.lr = 0x828CCFA8;
	sub_82916768(ctx, base);
	// 828CCFA8: 4803C5E1  bl 0x82909588
	ctx.lr = 0x828CCFAC;
	sub_82909588(ctx, base);
	// 828CCFAC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828CCFB0: 418201A8  beq 0x828cd158
	if ctx.cr[0].eq {
	pc = 0x828CD158; continue 'dispatch;
	}
	// 828CCFB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CCFB8: 480734F1  bl 0x829404a8
	ctx.lr = 0x828CCFBC;
	sub_829404A8(ctx, base);
	// 828CCFBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CCFC0: 48075029  bl 0x82941fe8
	ctx.lr = 0x828CCFC4;
	sub_82941FE8(ctx, base);
	// 828CCFC4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CCFC8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CCFCC: 3B8BE358  addi r28, r11, -0x1ca8
	ctx.r[28].s64 = ctx.r[11].s64 + -7336;
	// 828CCFD0: 38A000A1  li r5, 0xa1
	ctx.r[5].s64 = 161;
	// 828CCFD4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828CCFD8: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828CCFDC: 4B9F33FD  bl 0x822c03d8
	ctx.lr = 0x828CCFE0;
	sub_822C03D8(ctx, base);
	// 828CCFE0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CCFE4: 41820018  beq 0x828ccffc
	if ctx.cr[0].eq {
	pc = 0x828CCFFC; continue 'dispatch;
	}
	// 828CCFE8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828CCFEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CCFF0: 48075019  bl 0x82942008
	ctx.lr = 0x828CCFF4;
	sub_82942008(ctx, base);
	// 828CCFF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CCFF8: 48000008  b 0x828cd000
	pc = 0x828CD000; continue 'dispatch;
	// 828CCFFC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828CD000: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828CD004: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CD008: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CD00C: 4BFA0E25  bl 0x8286de30
	ctx.lr = 0x828CD010;
	sub_8286DE30(ctx, base);
	// 828CD010: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828CD014: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CD018: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CD01C: 4B9F2FE5  bl 0x822c0000
	ctx.lr = 0x828CD020;
	sub_822C0000(ctx, base);
	// 828CD020: 83210054  lwz r25, 0x54(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CD024: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CD028: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 828CD02C: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 828CD030: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828CD034: 419A0024  beq cr6, 0x828cd058
	if ctx.cr[6].eq {
	pc = 0x828CD058; continue 'dispatch;
	}
	// 828CD038: 39790004  addi r11, r25, 4
	ctx.r[11].s64 = ctx.r[25].s64 + 4;
	// 828CD03C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828CD040: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CD044: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828CD048: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828CD04C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828CD050: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CD054: 4082FFE8  bne 0x828cd03c
	if !ctx.cr[0].eq {
	pc = 0x828CD03C; continue 'dispatch;
	}
	// 828CD058: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CD05C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CD060: 48073451  bl 0x829404b0
	ctx.lr = 0x828CD064;
	sub_829404B0(ctx, base);
	// 828CD064: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828CD068: 4BFFE0D1  bl 0x828cb138
	ctx.lr = 0x828CD06C;
	sub_828CB138(ctx, base);
	// 828CD06C: 3BA30114  addi r29, r3, 0x114
	ctx.r[29].s64 = ctx.r[3].s64 + 276;
	// 828CD070: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828CD074: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CD078: 38A000A7  li r5, 0xa7
	ctx.r[5].s64 = 167;
	// 828CD07C: 3860002C  li r3, 0x2c
	ctx.r[3].s64 = 44;
	// 828CD080: 4B9F3359  bl 0x822c03d8
	ctx.lr = 0x828CD084;
	sub_822C03D8(ctx, base);
	// 828CD084: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828CD088: 41820030  beq 0x828cd0b8
	if ctx.cr[0].eq {
	pc = 0x828CD0B8; continue 'dispatch;
	}
	// 828CD08C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828CD090: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CD094: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 828CD098: 48075639  bl 0x829426d0
	ctx.lr = 0x828CD09C;
	sub_829426D0(ctx, base);
	// 828CD09C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828CD0A0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828CD0A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CD0A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CD0AC: 48073D15  bl 0x82940dc0
	ctx.lr = 0x828CD0B0;
	sub_82940DC0(ctx, base);
	// 828CD0B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CD0B4: 48000008  b 0x828cd0bc
	pc = 0x828CD0BC; continue 'dispatch;
	// 828CD0B8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828CD0BC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828CD0C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CD0C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CD0C8: 4BFFF321  bl 0x828cc3e8
	ctx.lr = 0x828CD0CC;
	sub_828CC3E8(ctx, base);
	// 828CD0CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828CD0D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CD0D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CD0D8: 4B9F2F29  bl 0x822c0000
	ctx.lr = 0x828CD0DC;
	sub_822C0000(ctx, base);
	// 828CD0DC: 574B07FF  clrlwi. r11, r26, 0x1f
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CD0E0: 41820014  beq 0x828cd0f4
	if ctx.cr[0].eq {
	pc = 0x828CD0F4; continue 'dispatch;
	}
	// 828CD0E4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828CD0E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CD0EC: 419A0008  beq cr6, 0x828cd0f4
	if ctx.cr[6].eq {
	pc = 0x828CD0F4; continue 'dispatch;
	}
	// 828CD0F0: 4B9F37A1  bl 0x822c0890
	ctx.lr = 0x828CD0F4;
	sub_822C0890(ctx, base);
	// 828CD0F4: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CD0F8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CD0FC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CD100: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828CD104: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828CD108: 419A0024  beq cr6, 0x828cd12c
	if ctx.cr[6].eq {
	pc = 0x828CD12C; continue 'dispatch;
	}
	// 828CD10C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828CD110: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828CD114: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CD118: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828CD11C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828CD120: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828CD124: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CD128: 4082FFE8  bne 0x828cd110
	if !ctx.cr[0].eq {
	pc = 0x828CD110; continue 'dispatch;
	}
	// 828CD12C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CD130: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CD134: 4807337D  bl 0x829404b0
	ctx.lr = 0x828CD138;
	sub_829404B0(ctx, base);
	// 828CD138: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828CD13C: 419A000C  beq cr6, 0x828cd148
	if ctx.cr[6].eq {
	pc = 0x828CD148; continue 'dispatch;
	}
	// 828CD140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CD144: 4B9F374D  bl 0x822c0890
	ctx.lr = 0x828CD148;
	sub_822C0890(ctx, base);
	// 828CD148: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 828CD14C: 419A000C  beq cr6, 0x828cd158
	if ctx.cr[6].eq {
	pc = 0x828CD158; continue 'dispatch;
	}
	// 828CD150: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828CD154: 4B9F373D  bl 0x822c0890
	ctx.lr = 0x828CD158;
	sub_822C0890(ctx, base);
	// 828CD158: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CD15C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CD160: 808BF3FC  lwz r4, -0xc04(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3076 as u32) ) } as u64;
	// 828CD164: 485268A5  bl 0x82df3a08
	ctx.lr = 0x828CD168;
	sub_82DF3A08(ctx, base);
	// 828CD168: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CD16C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CD170: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828CD174: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828CD178: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CD17C: 4E800421  bctrl
	ctx.lr = 0x828CD180;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CD180: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CD184: 485262A5  bl 0x82df3428
	ctx.lr = 0x828CD188;
	sub_82DF3428(ctx, base);
	// 828CD188: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828CD18C: 488DB01C  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CD190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CD190 size=112
    let mut pc: u32 = 0x828CD190;
    'dispatch: loop {
        match pc {
            0x828CD190 => {
    //   block [0x828CD190..0x828CD200)
	// 828CD190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CD194: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CD198: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CD19C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CD1A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CD1A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CD1A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CD1AC: 4BFFE02D  bl 0x828cb1d8
	ctx.lr = 0x828CD1B0;
	sub_828CB1D8(ctx, base);
	// 828CD1B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828CD1B4: 3BFE006C  addi r31, r30, 0x6c
	ctx.r[31].s64 = ctx.r[30].s64 + 108;
	// 828CD1B8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 828CD1BC: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 828CD1C0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CD1C4: 917E006C  stw r11, 0x6c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 828CD1C8: 4B9F7299  bl 0x822c4460
	ctx.lr = 0x828CD1CC;
	sub_822C4460(ctx, base);
	// 828CD1CC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CD1D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CD1D4: 419A0008  beq cr6, 0x828cd1dc
	if ctx.cr[6].eq {
	pc = 0x828CD1DC; continue 'dispatch;
	}
	// 828CD1D8: 4B9F36B9  bl 0x822c0890
	ctx.lr = 0x828CD1DC;
	sub_822C0890(ctx, base);
	// 828CD1DC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CD1E0: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CD1E4: D01E0074  stfs f0, 0x74(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828CD1E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CD1EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CD1F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CD1F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CD1F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CD1FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CD200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CD200 size=548
    let mut pc: u32 = 0x828CD200;
    'dispatch: loop {
        match pc {
            0x828CD200 => {
    //   block [0x828CD200..0x828CD424)
	// 828CD200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CD204: 488DAF55  bl 0x831a8158
	ctx.lr = 0x828CD208;
	sub_831A8130(ctx, base);
	// 828CD208: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CD20C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828CD210: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828CD214: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828CD218: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 828CD21C: 4804954D  bl 0x82916768
	ctx.lr = 0x828CD220;
	sub_82916768(ctx, base);
	// 828CD220: 4803C369  bl 0x82909588
	ctx.lr = 0x828CD224;
	sub_82909588(ctx, base);
	// 828CD224: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CD228: 48073281  bl 0x829404a8
	ctx.lr = 0x828CD22C;
	sub_829404A8(ctx, base);
	// 828CD22C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CD230: 480750E1  bl 0x82942310
	ctx.lr = 0x828CD234;
	sub_82942310(ctx, base);
	// 828CD234: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828CD238: 4BF22501  bl 0x827ef738
	ctx.lr = 0x828CD23C;
	sub_827EF738(ctx, base);
	// 828CD23C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 828CD240: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 828CD244: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828CD248: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CD24C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CD250: 13E350C7  vcmpequd (lvx128) v31, v3, v10
	tmp.u32 = ctx.r[3].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828CD254: 3B8BE358  addi r28, r11, -0x1ca8
	ctx.r[28].s64 = ctx.r[11].s64 + -7336;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CD428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CD428 size=112
    let mut pc: u32 = 0x828CD428;
    'dispatch: loop {
        match pc {
            0x828CD428 => {
    //   block [0x828CD428..0x828CD498)
	// 828CD428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CD42C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CD430: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828CD434: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CD438: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CD43C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828CD440: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CD444: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828CD448: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CD44C: 4BFFF44D  bl 0x828cc898
	ctx.lr = 0x828CD450;
	sub_828CC898(ctx, base);
	// 828CD450: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828CD454: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CD458: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828CD45C: 4B9F2BA5  bl 0x822c0000
	ctx.lr = 0x828CD460;
	sub_822C0000(ctx, base);
	// 828CD460: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CD464: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CD468: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CD46C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CD470: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CD474: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828CD478: 419A0008  beq cr6, 0x828cd480
	if ctx.cr[6].eq {
	pc = 0x828CD480; continue 'dispatch;
	}
	// 828CD47C: 4B9F3415  bl 0x822c0890
	ctx.lr = 0x828CD480;
	sub_822C0890(ctx, base);
	// 828CD480: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CD484: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CD488: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CD48C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828CD490: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CD494: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CD498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CD498 size=468
    let mut pc: u32 = 0x828CD498;
    'dispatch: loop {
        match pc {
            0x828CD498 => {
    //   block [0x828CD498..0x828CD66C)
	// 828CD498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CD49C: 488DACC5  bl 0x831a8160
	ctx.lr = 0x828CD4A0;
	sub_831A8130(ctx, base);
	// 828CD4A0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CD4A4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CD4A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CD4AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CD4B0: 480492B9  bl 0x82916768
	ctx.lr = 0x828CD4B4;
	sub_82916768(ctx, base);
	// 828CD4B4: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828CD4B8: 41820128  beq 0x828cd5e0
	if ctx.cr[0].eq {
	pc = 0x828CD5E0; continue 'dispatch;
	}
	// 828CD4BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CD4C0: 4BFF8409  bl 0x828c58c8
	ctx.lr = 0x828CD4C4;
	sub_828C58C8(ctx, base);
	// 828CD4C4: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828CD4C8: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828CD4CC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828CD4D0: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828CD4D4: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828CD4D8: 419A0024  beq cr6, 0x828cd4fc
	if ctx.cr[6].eq {
	pc = 0x828CD4FC; continue 'dispatch;
	}
	// 828CD4DC: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828CD4E0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828CD4E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CD4E8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828CD4EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828CD4F0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828CD4F4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CD4F8: 4082FFE8  bne 0x828cd4e0
	if !ctx.cr[0].eq {
	pc = 0x828CD4E0; continue 'dispatch;
	}
	// 828CD4FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828CD500: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CD504: 4BC41FC5  bl 0x8250f4c8
	ctx.lr = 0x828CD508;
	sub_8250F4C8(ctx, base);
	// 828CD508: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CD50C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CD510: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 828CD514: 409A0008  bne cr6, 0x828cd51c
	if !ctx.cr[6].eq {
	pc = 0x828CD51C; continue 'dispatch;
	}
	// 828CD518: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828CD51C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828CD520: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828CD524: 4BC3B4F5  bl 0x82508a18
	ctx.lr = 0x828CD528;
	sub_82508A18(ctx, base);
	// 828CD528: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CD52C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828CD530: 3B4BE358  addi r26, r11, -0x1ca8
	ctx.r[26].s64 = ctx.r[11].s64 + -7336;
	// 828CD534: 38A00246  li r5, 0x246
	ctx.r[5].s64 = 582;
	// 828CD538: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828CD53C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CD540: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828CD544: 4BF226E5  bl 0x827efc28
	ctx.lr = 0x828CD548;
	sub_827EFC28(ctx, base);
	// 828CD548: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828CD54C: 48524745  bl 0x82df1c90
	ctx.lr = 0x828CD550;
	sub_82DF1C90(ctx, base);
	// 828CD550: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828CD554: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CD558: 38A00248  li r5, 0x248
	ctx.r[5].s64 = 584;
	// 828CD55C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828CD560: 48524E89  bl 0x82df23e8
	ctx.lr = 0x828CD564;
	sub_82DF23E8(ctx, base);
	// 828CD564: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CD568: 41820024  beq 0x828cd58c
	if ctx.cr[0].eq {
	pc = 0x828CD58C; continue 'dispatch;
	}
	// 828CD56C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CD570: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828CD574: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828CD578: 396BE34C  addi r11, r11, -0x1cb4
	ctx.r[11].s64 = ctx.r[11].s64 + -7348;
	// 828CD57C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828CD580: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CD584: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CD588: 48000008  b 0x828cd590
	pc = 0x828CD590; continue 'dispatch;
	// 828CD58C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828CD590: 387E006C  addi r3, r30, 0x6c
	ctx.r[3].s64 = ctx.r[30].s64 + 108;
	// 828CD594: 4BFFFE95  bl 0x828cd428
	ctx.lr = 0x828CD598;
	sub_828CD428(ctx, base);
	// 828CD598: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828CD59C: 807E0074  lwz r3, 0x74(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) } as u64;
	// 828CD5A0: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 828CD5A4: 4BCBD8C5  bl 0x8258ae68
	ctx.lr = 0x828CD5A8;
	sub_8258AE68(ctx, base);
	// 828CD5A8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828CD5AC: 807E0074  lwz r3, 0x74(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) } as u64;
	// 828CD5B0: 388BBA80  addi r4, r11, -0x4580
	ctx.r[4].s64 = ctx.r[11].s64 + -17792;
	// 828CD5B4: 4BCBD8FD  bl 0x8258aeb0
	ctx.lr = 0x828CD5B8;
	sub_8258AEB0(ctx, base);
	// 828CD5B8: 809E006C  lwz r4, 0x6c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 828CD5BC: 807E0074  lwz r3, 0x74(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) } as u64;
	// 828CD5C0: 48545501  bl 0x82e12ac0
	ctx.lr = 0x828CD5C4;
	sub_82E12AC0(ctx, base);
	// 828CD5C4: 809E0074  lwz r4, 0x74(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) } as u64;
	// 828CD5C8: 807B0040  lwz r3, 0x40(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(64 as u32) ) } as u64;
	// 828CD5CC: 48545865  bl 0x82e12e30
	ctx.lr = 0x828CD5D0;
	sub_82E12E30(ctx, base);
	// 828CD5D0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828CD5D4: 419A000C  beq cr6, 0x828cd5e0
	if ctx.cr[6].eq {
	pc = 0x828CD5E0; continue 'dispatch;
	}
	// 828CD5D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828CD5DC: 4B9F32B5  bl 0x822c0890
	ctx.lr = 0x828CD5E0;
	sub_822C0890(ctx, base);
	// 828CD5E0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828CD5E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CD5E8: 83CB666C  lwz r30, 0x666c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26220 as u32) ) } as u64;
	// 828CD5EC: 4BF2218D  bl 0x827ef778
	ctx.lr = 0x828CD5F0;
	sub_827EF778(ctx, base);
	// 828CD5F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CD5F4: 4BBC1DAD  bl 0x8248f3a0
	ctx.lr = 0x828CD5F8;
	sub_8248F3A0(ctx, base);
	// 828CD5F8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828CD5FC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828CD600: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CD604: 48049A1D  bl 0x82917020
	ctx.lr = 0x828CD608;
	sub_82917020(ctx, base);
	// 828CD608: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CD60C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CD610: 808B0BE8  lwz r4, 0xbe8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3048 as u32) ) } as u64;
	// 828CD614: 485263F5  bl 0x82df3a08
	ctx.lr = 0x828CD618;
	sub_82DF3A08(ctx, base);
	// 828CD618: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CD61C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CD620: 4BF22151  bl 0x827ef770
	ctx.lr = 0x828CD624;
	sub_827EF770(ctx, base);
	// 828CD624: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CD628: 48525E01  bl 0x82df3428
	ctx.lr = 0x828CD62C;
	sub_82DF3428(ctx, base);
	// 828CD62C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CD630: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CD634: 808BF42C  lwz r4, -0xbd4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3028 as u32) ) } as u64;
	// 828CD638: 485263D1  bl 0x82df3a08
	ctx.lr = 0x828CD63C;
	sub_82DF3A08(ctx, base);
	// 828CD63C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CD640: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CD644: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CD648: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828CD64C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828CD650: 4E800421  bctrl
	ctx.lr = 0x828CD654;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828CD654: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CD658: 48525DD1  bl 0x82df3428
	ctx.lr = 0x828CD65C;
	sub_82DF3428(ctx, base);
	// 828CD65C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CD660: 4BFFDA99  bl 0x828cb0f8
	ctx.lr = 0x828CD664;
	sub_828CB0F8(ctx, base);
	// 828CD664: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828CD668: 488DAB48  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CD670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CD670 size=352
    let mut pc: u32 = 0x828CD670;
    'dispatch: loop {
        match pc {
            0x828CD670 => {
    //   block [0x828CD670..0x828CD7D0)
	// 828CD670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CD674: 488DAAF5  bl 0x831a8168
	ctx.lr = 0x828CD678;
	sub_831A8130(ctx, base);
	// 828CD678: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828CD67C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CD680: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828CD684: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828CD688: 48886F79  bl 0x83154600
	ctx.lr = 0x828CD68C;
	sub_83154600(ctx, base);
	// 828CD68C: 480490DD  bl 0x82916768
	ctx.lr = 0x828CD690;
	sub_82916768(ctx, base);
	// 828CD690: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828CD694: 4182012C  beq 0x828cd7c0
	if ctx.cr[0].eq {
	pc = 0x828CD7C0; continue 'dispatch;
	}
	// 828CD698: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CD69C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CD6A0: 4BC41E29  bl 0x8250f4c8
	ctx.lr = 0x828CD6A4;
	sub_8250F4C8(ctx, base);
	// 828CD6A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CD6A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CD6AC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 828CD6B0: 409A0008  bne cr6, 0x828cd6b8
	if !ctx.cr[6].eq {
	pc = 0x828CD6B8; continue 'dispatch;
	}
	// 828CD6B4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828CD6B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828CD6BC: 4BC3B35D  bl 0x82508a18
	ctx.lr = 0x828CD6C0;
	sub_82508A18(ctx, base);
	// 828CD6C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CD6C4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828CD6C8: 485245C9  bl 0x82df1c90
	ctx.lr = 0x828CD6CC;
	sub_82DF1C90(ctx, base);
	// 828CD6CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CD6D0: 4873AA59  bl 0x83008128
	ctx.lr = 0x828CD6D4;
	sub_83008128(ctx, base);
	// 828CD6D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828CD6D8: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828CD6DC: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828CD6E0: 419A0084  beq cr6, 0x828cd764
	if ctx.cr[6].eq {
	pc = 0x828CD764; continue 'dispatch;
	}
	// 828CD6E4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828CD6E8: 4BAF1941  bl 0x823bf028
	ctx.lr = 0x828CD6EC;
	sub_823BF028(ctx, base);
	// 828CD6EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828CD6F0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828CD6F4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828CD6F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828CD6FC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828CD700: 419A0024  beq cr6, 0x828cd724
	if ctx.cr[6].eq {
	pc = 0x828CD724; continue 'dispatch;
	}
	// 828CD704: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828CD708: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828CD70C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CD710: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828CD714: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828CD718: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828CD71C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828CD720: 4082FFE8  bne 0x828cd708
	if !ctx.cr[0].eq {
	pc = 0x828CD708; continue 'dispatch;
	}
	// 828CD724: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CD728: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828CD72C: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 828CD730: 388BE358  addi r4, r11, -0x1ca8
	ctx.r[4].s64 = ctx.r[11].s64 + -7336;
	// 828CD734: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828CD738: 38A00283  li r5, 0x283
	ctx.r[5].s64 = 643;
	// 828CD73C: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 828CD740: 4858B301  bl 0x82e58a40
	ctx.lr = 0x828CD744;
	sub_82E58A40(ctx, base);
	// 828CD744: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828CD748: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CD74C: 419A0008  beq cr6, 0x828cd754
	if ctx.cr[6].eq {
	pc = 0x828CD754; continue 'dispatch;
	}
	// 828CD750: 4B9F3141  bl 0x822c0890
	ctx.lr = 0x828CD754;
	sub_822C0890(ctx, base);
	// 828CD754: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828CD758: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CD75C: 419A0008  beq cr6, 0x828cd764
	if ctx.cr[6].eq {
	pc = 0x828CD764; continue 'dispatch;
	}
	// 828CD760: 4B9F3131  bl 0x822c0890
	ctx.lr = 0x828CD764;
	sub_822C0890(ctx, base);
	// 828CD764: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828CD768: 48886E99  bl 0x83154600
	ctx.lr = 0x828CD76C;
	sub_83154600(ctx, base);
	// 828CD76C: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 828CD770: 4182000C  beq 0x828cd77c
	if ctx.cr[0].eq {
	pc = 0x828CD77C; continue 'dispatch;
	}
	// 828CD774: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828CD778: 4BFF80D1  bl 0x828c5848
	ctx.lr = 0x828CD77C;
	sub_828C5848(ctx, base);
	// 828CD77C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828CD780: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CD784: 808B0B70  lwz r4, 0xb70(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2928 as u32) ) } as u64;
	// 828CD788: 48526281  bl 0x82df3a08
	ctx.lr = 0x828CD78C;
	sub_82DF3A08(ctx, base);
	// 828CD78C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828CD790: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828CD794: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828CD798: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828CD79C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CD7A0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828CD7A4: 485912ED  bl 0x82e5ea90
	ctx.lr = 0x828CD7A8;
	sub_82E5EA90(ctx, base);
	// 828CD7A8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828CD7AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828CD7B0: 419A0008  beq cr6, 0x828cd7b8
	if ctx.cr[6].eq {
	pc = 0x828CD7B8; continue 'dispatch;
	}
	// 828CD7B4: 4B9F30DD  bl 0x822c0890
	ctx.lr = 0x828CD7B8;
	sub_822C0890(ctx, base);
	// 828CD7B8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828CD7BC: 48000008  b 0x828cd7c4
	pc = 0x828CD7C4; continue 'dispatch;
	// 828CD7C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828CD7C4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828CD7C8: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828CD7CC: 488DA9EC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CD7D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CD7D0 size=160
    let mut pc: u32 = 0x828CD7D0;
    'dispatch: loop {
        match pc {
            0x828CD7D0 => {
    //   block [0x828CD7D0..0x828CD870)
	// 828CD7D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CD7D4: 488DA995  bl 0x831a8168
	ctx.lr = 0x828CD7D8;
	sub_831A8130(ctx, base);
	// 828CD7D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CD7DC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828CD7E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828CD7E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828CD7E8: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 828CD7EC: 41820034  beq 0x828cd820
	if ctx.cr[0].eq {
	pc = 0x828CD820; continue 'dispatch;
	}
	// 828CD7F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CD7F4: 488DC195  bl 0x831a9988
	ctx.lr = 0x828CD7F8;
	sub_831A9988(ctx, base);
	// 828CD7F8: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 828CD7FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CD800: 386BFD00  addi r3, r11, -0x300
	ctx.r[3].s64 = ctx.r[11].s64 + -768;
	// 828CD804: 488DA8F5  bl 0x831a80f8
	ctx.lr = 0x828CD808;
	sub_831A80F8(ctx, base);
	// 828CD808: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CD80C: 41820014  beq 0x828cd820
	if ctx.cr[0].eq {
	pc = 0x828CD820; continue 'dispatch;
	}
	// 828CD810: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CD814: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CD818: 4BFF7AE9  bl 0x828c5300
	ctx.lr = 0x828CD81C;
	sub_828C5300(ctx, base);
	// 828CD81C: 4800004C  b 0x828cd868
	pc = 0x828CD868; continue 'dispatch;
	// 828CD820: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828CD824: 419A0034  beq cr6, 0x828cd858
	if ctx.cr[6].eq {
	pc = 0x828CD858; continue 'dispatch;
	}
	// 828CD828: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CD82C: 488DC15D  bl 0x831a9988
	ctx.lr = 0x828CD830;
	sub_831A9988(ctx, base);
	// 828CD830: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 828CD834: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CD838: 386B39EC  addi r3, r11, 0x39ec
	ctx.r[3].s64 = ctx.r[11].s64 + 14828;
	// 828CD83C: 488DA8BD  bl 0x831a80f8
	ctx.lr = 0x828CD840;
	sub_831A80F8(ctx, base);
	// 828CD840: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828CD844: 41820014  beq 0x828cd858
	if ctx.cr[0].eq {
	pc = 0x828CD858; continue 'dispatch;
	}
	// 828CD848: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CD84C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CD850: 4BFFFE21  bl 0x828cd670
	ctx.lr = 0x828CD854;
	sub_828CD670(ctx, base);
	// 828CD854: 48000014  b 0x828cd868
	pc = 0x828CD868; continue 'dispatch;
	// 828CD858: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828CD85C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828CD860: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828CD864: 488B0C25  bl 0x8317e488
	ctx.lr = 0x828CD868;
	sub_8317E488(ctx, base);
	// 828CD868: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828CD86C: 488DA94C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CD870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CD870 size=96
    let mut pc: u32 = 0x828CD870;
    'dispatch: loop {
        match pc {
            0x828CD870 => {
    //   block [0x828CD870..0x828CD8D0)
	// 828CD870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CD874: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CD878: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CD87C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CD880: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CD884: 4BFFE33D  bl 0x828cbbc0
	ctx.lr = 0x828CD888;
	sub_828CBBC0(ctx, base);
	// 828CD888: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CD88C: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828CD890: 396BE3E0  addi r11, r11, -0x1c20
	ctx.r[11].s64 = ctx.r[11].s64 + -7200;
	// 828CD894: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CD898: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CD89C: 808A0B30  lwz r4, 0xb30(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2864 as u32) ) } as u64;
	// 828CD8A0: 48526169  bl 0x82df3a08
	ctx.lr = 0x828CD8A4;
	sub_82DF3A08(ctx, base);
	// 828CD8A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CD8A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CD8AC: 4858BE3D  bl 0x82e596e8
	ctx.lr = 0x828CD8B0;
	sub_82E596E8(ctx, base);
	// 828CD8B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CD8B4: 48525B75  bl 0x82df3428
	ctx.lr = 0x828CD8B8;
	sub_82DF3428(ctx, base);
	// 828CD8B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CD8BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CD8C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CD8C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CD8C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CD8CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CD8D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828CD8D0 size=124
    let mut pc: u32 = 0x828CD8D0;
    'dispatch: loop {
        match pc {
            0x828CD8D0 => {
    //   block [0x828CD8D0..0x828CD94C)
	// 828CD8D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CD8D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CD8D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CD8DC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CD8E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CD8E4: 4BFFE2DD  bl 0x828cbbc0
	ctx.lr = 0x828CD8E8;
	sub_828CBBC0(ctx, base);
	// 828CD8E8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CD8EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828CD8F0: 392BE41C  addi r9, r11, -0x1be4
	ctx.r[9].s64 = ctx.r[11].s64 + -7140;
	// 828CD8F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828CD8F8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828CD8FC: 3D20832D  lis r9, -0x7cd3
	ctx.r[9].s64 = -2094202880;
	// 828CD900: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 828CD904: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CD908: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828CD90C: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 828CD910: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828CD914: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 828CD918: 80890B88  lwz r4, 0xb88(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2952 as u32) ) } as u64;
	// 828CD91C: 485260ED  bl 0x82df3a08
	ctx.lr = 0x828CD920;
	sub_82DF3A08(ctx, base);
	// 828CD920: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CD924: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CD928: 4858BDC1  bl 0x82e596e8
	ctx.lr = 0x828CD92C;
	sub_82E596E8(ctx, base);
	// 828CD92C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CD930: 48525AF9  bl 0x82df3428
	ctx.lr = 0x828CD934;
	sub_82DF3428(ctx, base);
	// 828CD934: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CD938: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CD93C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CD940: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CD944: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CD948: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CD950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CD950 size=96
    let mut pc: u32 = 0x828CD950;
    'dispatch: loop {
        match pc {
            0x828CD950 => {
    //   block [0x828CD950..0x828CD9B0)
	// 828CD950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CD954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CD958: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CD95C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CD960: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CD964: 4BFFE25D  bl 0x828cbbc0
	ctx.lr = 0x828CD968;
	sub_828CBBC0(ctx, base);
	// 828CD968: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CD96C: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828CD970: 396BE454  addi r11, r11, -0x1bac
	ctx.r[11].s64 = ctx.r[11].s64 + -7084;
	// 828CD974: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CD978: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CD97C: 808A0B50  lwz r4, 0xb50(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2896 as u32) ) } as u64;
	// 828CD980: 48526089  bl 0x82df3a08
	ctx.lr = 0x828CD984;
	sub_82DF3A08(ctx, base);
	// 828CD984: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CD988: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CD98C: 4858BD5D  bl 0x82e596e8
	ctx.lr = 0x828CD990;
	sub_82E596E8(ctx, base);
	// 828CD990: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CD994: 48525A95  bl 0x82df3428
	ctx.lr = 0x828CD998;
	sub_82DF3428(ctx, base);
	// 828CD998: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CD99C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CD9A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CD9A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CD9A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CD9AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CD9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CD9B0 size=96
    let mut pc: u32 = 0x828CD9B0;
    'dispatch: loop {
        match pc {
            0x828CD9B0 => {
    //   block [0x828CD9B0..0x828CDA10)
	// 828CD9B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CD9B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CD9B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CD9BC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CD9C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CD9C4: 4BFFE1FD  bl 0x828cbbc0
	ctx.lr = 0x828CD9C8;
	sub_828CBBC0(ctx, base);
	// 828CD9C8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CD9CC: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828CD9D0: 396BE48C  addi r11, r11, -0x1b74
	ctx.r[11].s64 = ctx.r[11].s64 + -7028;
	// 828CD9D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CD9D8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CD9DC: 808A0B34  lwz r4, 0xb34(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2868 as u32) ) } as u64;
	// 828CD9E0: 48526029  bl 0x82df3a08
	ctx.lr = 0x828CD9E4;
	sub_82DF3A08(ctx, base);
	// 828CD9E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CD9E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CD9EC: 4858BCFD  bl 0x82e596e8
	ctx.lr = 0x828CD9F0;
	sub_82E596E8(ctx, base);
	// 828CD9F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CD9F4: 48525A35  bl 0x82df3428
	ctx.lr = 0x828CD9F8;
	sub_82DF3428(ctx, base);
	// 828CD9F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CD9FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CDA00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CDA04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CDA08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CDA0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CDA10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CDA10 size=96
    let mut pc: u32 = 0x828CDA10;
    'dispatch: loop {
        match pc {
            0x828CDA10 => {
    //   block [0x828CDA10..0x828CDA70)
	// 828CDA10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CDA14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CDA18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CDA1C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CDA20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CDA24: 4BFFE19D  bl 0x828cbbc0
	ctx.lr = 0x828CDA28;
	sub_828CBBC0(ctx, base);
	// 828CDA28: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CDA2C: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828CDA30: 396BE4C4  addi r11, r11, -0x1b3c
	ctx.r[11].s64 = ctx.r[11].s64 + -6972;
	// 828CDA34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CDA38: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CDA3C: 808A0B10  lwz r4, 0xb10(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2832 as u32) ) } as u64;
	// 828CDA40: 48525FC9  bl 0x82df3a08
	ctx.lr = 0x828CDA44;
	sub_82DF3A08(ctx, base);
	// 828CDA44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CDA48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CDA4C: 4858BC9D  bl 0x82e596e8
	ctx.lr = 0x828CDA50;
	sub_82E596E8(ctx, base);
	// 828CDA50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CDA54: 485259D5  bl 0x82df3428
	ctx.lr = 0x828CDA58;
	sub_82DF3428(ctx, base);
	// 828CDA58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CDA5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CDA60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CDA64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CDA68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CDA6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CDA70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CDA70 size=140
    let mut pc: u32 = 0x828CDA70;
    'dispatch: loop {
        match pc {
            0x828CDA70 => {
    //   block [0x828CDA70..0x828CDAFC)
	// 828CDA70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CDA74: 488DA6F9  bl 0x831a816c
	ctx.lr = 0x828CDA78;
	sub_831A8130(ctx, base);
	// 828CDA78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CDA7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CDA80: 4BFFE141  bl 0x828cbbc0
	ctx.lr = 0x828CDA84;
	sub_828CBBC0(ctx, base);
	// 828CDA84: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CDA88: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828CDA8C: 396BE4FC  addi r11, r11, -0x1b04
	ctx.r[11].s64 = ctx.r[11].s64 + -6916;
	// 828CDA90: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828CDA94: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CDA98: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828CDA9C: 93DF006C  stw r30, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 828CDAA0: 388AE358  addi r4, r10, -0x1ca8
	ctx.r[4].s64 = ctx.r[10].s64 + -7336;
	// 828CDAA4: 93DF0070  stw r30, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828CDAA8: 38A0023A  li r5, 0x23a
	ctx.r[5].s64 = 570;
	// 828CDAAC: 93DF0074  stw r30, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 828CDAB0: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 828CDAB4: 93DF0078  stw r30, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 828CDAB8: 3BBF0074  addi r29, r31, 0x74
	ctx.r[29].s64 = ctx.r[31].s64 + 116;
	// 828CDABC: 4852492D  bl 0x82df23e8
	ctx.lr = 0x828CDAC0;
	sub_82DF23E8(ctx, base);
	// 828CDAC0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828CDAC4: 41820020  beq 0x828cdae4
	if ctx.cr[0].eq {
	pc = 0x828CDAE4; continue 'dispatch;
	}
	// 828CDAC8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828CDACC: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 828CDAD0: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 828CDAD4: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 828CDAD8: 4BCBD249  bl 0x8258ad20
	ctx.lr = 0x828CDADC;
	sub_8258AD20(ctx, base);
	// 828CDADC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828CDAE0: 48000008  b 0x828cdae8
	pc = 0x828CDAE8; continue 'dispatch;
	// 828CDAE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828CDAE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828CDAEC: 4BB05D3D  bl 0x823d3828
	ctx.lr = 0x828CDAF0;
	sub_823D3828(ctx, base);
	// 828CDAF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CDAF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CDAF8: 488DA6C4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828CDB00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828CDB00 size=96
    let mut pc: u32 = 0x828CDB00;
    'dispatch: loop {
        match pc {
            0x828CDB00 => {
    //   block [0x828CDB00..0x828CDB60)
	// 828CDB00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828CDB04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828CDB08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828CDB0C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828CDB10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828CDB14: 4BFFE0AD  bl 0x828cbbc0
	ctx.lr = 0x828CDB18;
	sub_828CBBC0(ctx, base);
	// 828CDB18: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828CDB1C: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828CDB20: 396BE534  addi r11, r11, -0x1acc
	ctx.r[11].s64 = ctx.r[11].s64 + -6860;
	// 828CDB24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CDB28: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828CDB2C: 808A0B08  lwz r4, 0xb08(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2824 as u32) ) } as u64;
	// 828CDB30: 48525ED9  bl 0x82df3a08
	ctx.lr = 0x828CDB34;
	sub_82DF3A08(ctx, base);
	// 828CDB34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CDB38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828CDB3C: 4858BBAD  bl 0x82e596e8
	ctx.lr = 0x828CDB40;
	sub_82E596E8(ctx, base);
	// 828CDB40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828CDB44: 485258E5  bl 0x82df3428
	ctx.lr = 0x828CDB48;
	sub_82DF3428(ctx, base);
	// 828CDB48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828CDB4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828CDB50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828CDB54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828CDB58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828CDB5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


