pub fn sub_82E0C030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0C030 size=104
    let mut pc: u32 = 0x82E0C030;
    'dispatch: loop {
        match pc {
            0x82E0C030 => {
    //   block [0x82E0C030..0x82E0C098)
	// 82E0C030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0C034: 4839C135  bl 0x831a8168
	ctx.lr = 0x82E0C038;
	sub_831A8130(ctx, base);
	// 82E0C038: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0C03C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E0C040: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E0C044: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82E0C048: 897E0015  lbz r11, 0x15(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(21 as u32) ) } as u64;
	// 82E0C04C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0C050: 409A0040  bne cr6, 0x82e0c090
	if !ctx.cr[6].eq {
	pc = 0x82E0C090; continue 'dispatch;
	}
	// 82E0C054: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 82E0C058: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E0C05C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0C060: 4BFFFFD1  bl 0x82e0c030
	ctx.lr = 0x82E0C064;
	sub_82E0C030(ctx, base);
	// 82E0C064: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E0C068: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E0C06C: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0C070: 4804B871  bl 0x82e578e0
	ctx.lr = 0x82E0C074;
	sub_82E578E0(ctx, base);
	// 82E0C074: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E0C078: 807C110C  lwz r3, 0x110c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E0C07C: 4BFE610D  bl 0x82df2188
	ctx.lr = 0x82E0C080;
	sub_82DF2188(ctx, base);
	// 82E0C080: 897F0015  lbz r11, 0x15(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 82E0C084: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82E0C088: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0C08C: 419AFFCC  beq cr6, 0x82e0c058
	if ctx.cr[6].eq {
	pc = 0x82E0C058; continue 'dispatch;
	}
	// 82E0C090: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E0C094: 4839C124  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0C098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0C098 size=188
    let mut pc: u32 = 0x82E0C098;
    'dispatch: loop {
        match pc {
            0x82E0C098 => {
    //   block [0x82E0C098..0x82E0C154)
	// 82E0C098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0C09C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0C0A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E0C0A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0C0A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0C0AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E0C0B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0C0B4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82E0C0B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E0C0BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E0C0C0: 4B4B4879  bl 0x822c0938
	ctx.lr = 0x82E0C0C4;
	sub_822C0938(ctx, base);
	// 82E0C0C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E0C0C8: 41820028  beq 0x82e0c0f0
	if ctx.cr[0].eq {
	pc = 0x82E0C0F0; continue 'dispatch;
	}
	// 82E0C0CC: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E0C0D0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82E0C0D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E0C0D8: 392BB8A8  addi r9, r11, -0x4758
	ctx.r[9].s64 = ctx.r[11].s64 + -18264;
	// 82E0C0DC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E0C0E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E0C0E4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E0C0E8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E0C0EC: 48000008  b 0x82e0c0f4
	pc = 0x82E0C0F4; continue 'dispatch;
	// 82E0C0F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0C0F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E0C0F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0C0FC: 409A003C  bne cr6, 0x82e0c138
	if !ctx.cr[6].eq {
	pc = 0x82E0C138; continue 'dispatch;
	}
	// 82E0C100: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E0C104: 419A0014  beq cr6, 0x82e0c118
	if ctx.cr[6].eq {
	pc = 0x82E0C118; continue 'dispatch;
	}
	// 82E0C108: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0C10C: 4BFFFAFD  bl 0x82e0bc08
	ctx.lr = 0x82E0C110;
	sub_82E0BC08(ctx, base);
	// 82E0C110: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0C114: 4B4B4155  bl 0x822c0268
	ctx.lr = 0x82E0C118;
	sub_822C0268(ctx, base);
	// 82E0C118: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82E0C11C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E0C120: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0C124: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82E0C128: 816BA3B0  lwz r11, -0x5c50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23632 as u32) ) } as u64;
	// 82E0C12C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82E0C130: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E0C134: 4B4B3ECD  bl 0x822c0000
	ctx.lr = 0x82E0C138;
	sub_822C0000(ctx, base);
	// 82E0C138: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E0C13C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E0C140: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0C144: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0C148: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E0C14C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E0C150: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0C158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0C158 size=64
    let mut pc: u32 = 0x82E0C158;
    'dispatch: loop {
        match pc {
            0x82E0C158 => {
    //   block [0x82E0C158..0x82E0C198)
	// 82E0C158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0C15C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0C160: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0C164: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0C168: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0C16C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E0C170: 419A0014  beq cr6, 0x82e0c184
	if ctx.cr[6].eq {
	pc = 0x82E0C184; continue 'dispatch;
	}
	// 82E0C174: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0C178: 4BFFFA91  bl 0x82e0bc08
	ctx.lr = 0x82E0C17C;
	sub_82E0BC08(ctx, base);
	// 82E0C17C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0C180: 4B4B40E9  bl 0x822c0268
	ctx.lr = 0x82E0C184;
	sub_822C0268(ctx, base);
	// 82E0C184: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E0C188: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0C18C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0C190: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E0C194: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0C198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0C198 size=84
    let mut pc: u32 = 0x82E0C198;
    'dispatch: loop {
        match pc {
            0x82E0C198 => {
    //   block [0x82E0C198..0x82E0C1EC)
	// 82E0C198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0C19C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0C1A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0C1A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0C1A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0C1AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0C1B0: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0C1B4: 4BFFFE7D  bl 0x82e0c030
	ctx.lr = 0x82E0C1B8;
	sub_82E0C030(ctx, base);
	// 82E0C1B8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0C1BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0C1C0: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E0C1C4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E0C1C8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0C1CC: 914A0000  stw r10, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E0C1D0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0C1D4: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E0C1D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E0C1DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0C1E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0C1E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E0C1E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0C1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0C1F0 size=416
    let mut pc: u32 = 0x82E0C1F0;
    'dispatch: loop {
        match pc {
            0x82E0C1F0 => {
    //   block [0x82E0C1F0..0x82E0C390)
	// 82E0C1F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0C1F4: 4839BF69  bl 0x831a815c
	ctx.lr = 0x82E0C1F8;
	sub_831A8130(ctx, base);
	// 82E0C1F8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0C1FC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82E0C200: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E0C204: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82E0C208: 38C000D2  li r6, 0xd2
	ctx.r[6].s64 = 210;
	// 82E0C20C: 38ABB8C8  addi r5, r11, -0x4738
	ctx.r[5].s64 = ctx.r[11].s64 + -18232;
	// 82E0C210: 389C0018  addi r4, r28, 0x18
	ctx.r[4].s64 = ctx.r[28].s64 + 24;
	// 82E0C214: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E0C218: 4BFED621  bl 0x82df9838
	ctx.lr = 0x82E0C21C;
	sub_82DF9838(ctx, base);
	// 82E0C21C: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0C220: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0C224: 3B3A0004  addi r25, r26, 4
	ctx.r[25].s64 = ctx.r[26].s64 + 4;
	// 82E0C228: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0C22C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E0C230: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82E0C234: 419A0024  beq cr6, 0x82e0c258
	if ctx.cr[6].eq {
	pc = 0x82E0C258; continue 'dispatch;
	}
	// 82E0C238: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E0C23C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E0C240: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0C244: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E0C248: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0C24C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0C250: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0C254: 4082FFE8  bne 0x82e0c23c
	if !ctx.cr[0].eq {
	pc = 0x82E0C23C; continue 'dispatch;
	}
	// 82E0C258: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E0C25C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E0C260: 4BFFF681  bl 0x82e0b8e0
	ctx.lr = 0x82E0C264;
	sub_82E0B8E0(ctx, base);
	// 82E0C264: 3B7C003C  addi r27, r28, 0x3c
	ctx.r[27].s64 = ctx.r[28].s64 + 60;
	// 82E0C268: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82E0C26C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E0C270: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0C274: 4BFFF9F5  bl 0x82e0bc68
	ctx.lr = 0x82E0C278;
	sub_82E0BC68(ctx, base);
	// 82E0C278: 83DC0040  lwz r30, 0x40(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E0C27C: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E0C280: 7F05F040  cmplw cr6, r5, r30
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82E0C284: 419A00D8  beq cr6, 0x82e0c35c
	if ctx.cr[6].eq {
	pc = 0x82E0C35C; continue 'dispatch;
	}
	// 82E0C288: 8165000C  lwz r11, 0xc(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0C28C: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0C290: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0C294: 7F05F840  cmplw cr6, r5, r31
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82E0C298: 419A0020  beq cr6, 0x82e0c2b8
	if ctx.cr[6].eq {
	pc = 0x82E0C2B8; continue 'dispatch;
	}
	// 82E0C29C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0C2A0: 48010BC1  bl 0x82e1ce60
	ctx.lr = 0x82E0C2A4;
	sub_82E1CE60(ctx, base);
	// 82E0C2A4: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E0C2A8: 8165000C  lwz r11, 0xc(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0C2AC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0C2B0: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82E0C2B4: 419AFFE0  beq cr6, 0x82e0c294
	if ctx.cr[6].eq {
	pc = 0x82E0C294; continue 'dispatch;
	}
	// 82E0C2B8: 8165000C  lwz r11, 0xc(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0C2BC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0C2C0: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82E0C2C4: 419A0030  beq cr6, 0x82e0c2f4
	if ctx.cr[6].eq {
	pc = 0x82E0C2F4; continue 'dispatch;
	}
	// 82E0C2C8: 48000020  b 0x82e0c2e8
	pc = 0x82E0C2E8; continue 'dispatch;
	// 82E0C2CC: 8165000C  lwz r11, 0xc(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0C2D0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0C2D4: 7F0AE800  cmpw cr6, r10, r29
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82E0C2D8: 409A0054  bne cr6, 0x82e0c32c
	if !ctx.cr[6].eq {
	pc = 0x82E0C32C; continue 'dispatch;
	}
	// 82E0C2DC: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0C2E0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82E0C2E4: 419A001C  beq cr6, 0x82e0c300
	if ctx.cr[6].eq {
	pc = 0x82E0C300; continue 'dispatch;
	}
	// 82E0C2E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0C2EC: 4BFEF96D  bl 0x82dfbc58
	ctx.lr = 0x82E0C2F0;
	sub_82DFBC58(ctx, base);
	// 82E0C2F0: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E0C2F4: 7F05F040  cmplw cr6, r5, r30
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82E0C2F8: 409AFFD4  bne cr6, 0x82e0c2cc
	if !ctx.cr[6].eq {
	pc = 0x82E0C2CC; continue 'dispatch;
	}
	// 82E0C2FC: 48000030  b 0x82e0c32c
	pc = 0x82E0C32C; continue 'dispatch;
	// 82E0C300: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E0C304: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0C308: 48011DF1  bl 0x82e1e0f8
	ctx.lr = 0x82E0C30C;
	sub_82E1E0F8(ctx, base);
	// 82E0C30C: 397C0120  addi r11, r28, 0x120
	ctx.r[11].s64 = ctx.r[28].s64 + 288;
	// 82E0C310: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E0C314: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0C318: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E0C31C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82E0C320: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0C324: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0C328: 4082FFE8  bne 0x82e0c310
	if !ctx.cr[0].eq {
	pc = 0x82E0C310; continue 'dispatch;
	}
	// 82E0C32C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E0C330: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0C334: 419A0008  beq cr6, 0x82e0c33c
	if ctx.cr[6].eq {
	pc = 0x82E0C33C; continue 'dispatch;
	}
	// 82E0C338: 4B4B4559  bl 0x822c0890
	ctx.lr = 0x82E0C33C;
	sub_822C0890(ctx, base);
	// 82E0C33C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E0C340: 4B4C32C1  bl 0x822cf600
	ctx.lr = 0x82E0C344;
	sub_822CF600(ctx, base);
	// 82E0C344: 80790000  lwz r3, 0(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0C348: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0C34C: 419A0008  beq cr6, 0x82e0c354
	if ctx.cr[6].eq {
	pc = 0x82E0C354; continue 'dispatch;
	}
	// 82E0C350: 4B4B4541  bl 0x822c0890
	ctx.lr = 0x82E0C354;
	sub_822C0890(ctx, base);
	// 82E0C354: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E0C358: 48000030  b 0x82e0c388
	pc = 0x82E0C388; continue 'dispatch;
	// 82E0C35C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E0C360: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0C364: 419A0008  beq cr6, 0x82e0c36c
	if ctx.cr[6].eq {
	pc = 0x82E0C36C; continue 'dispatch;
	}
	// 82E0C368: 4B4B4529  bl 0x822c0890
	ctx.lr = 0x82E0C36C;
	sub_822C0890(ctx, base);
	// 82E0C36C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E0C370: 4B4C3291  bl 0x822cf600
	ctx.lr = 0x82E0C374;
	sub_822CF600(ctx, base);
	// 82E0C374: 80790000  lwz r3, 0(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0C378: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0C37C: 419A0008  beq cr6, 0x82e0c384
	if ctx.cr[6].eq {
	pc = 0x82E0C384; continue 'dispatch;
	}
	// 82E0C380: 4B4B4511  bl 0x822c0890
	ctx.lr = 0x82E0C384;
	sub_822C0890(ctx, base);
	// 82E0C384: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E0C388: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E0C38C: 4839BE20  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0C390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E0C390 size=1468
    let mut pc: u32 = 0x82E0C390;
    'dispatch: loop {
        match pc {
            0x82E0C390 => {
    //   block [0x82E0C390..0x82E0C94C)
	// 82E0C390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0C394: 4839BDCD  bl 0x831a8160
	ctx.lr = 0x82E0C398;
	sub_831A8130(ctx, base);
	// 82E0C398: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0C39C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0C3A0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E0C3A4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E0C3A8: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82E0C3AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0C3B0: 409A0104  bne cr6, 0x82e0c4b4
	if !ctx.cr[6].eq {
	pc = 0x82E0C4B4; continue 'dispatch;
	}
	// 82E0C3B4: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E0C3B8: 38C00187  li r6, 0x187
	ctx.r[6].s64 = 391;
	// 82E0C3BC: 38ABB8C8  addi r5, r11, -0x4738
	ctx.r[5].s64 = ctx.r[11].s64 + -18232;
	// 82E0C3C0: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 82E0C3C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E0C3C8: 4BFED471  bl 0x82df9838
	ctx.lr = 0x82E0C3CC;
	sub_82DF9838(ctx, base);
	// 82E0C3CC: 897F0048  lbz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E0C3D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E0C3D4: 41820030  beq 0x82e0c404
	if ctx.cr[0].eq {
	pc = 0x82E0C404; continue 'dispatch;
	}
	// 82E0C3D8: 9B9F0048  stb r28, 0x48(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[28].u8 ) };
	// 82E0C3DC: 387F003C  addi r3, r31, 0x3c
	ctx.r[3].s64 = ctx.r[31].s64 + 60;
	// 82E0C3E0: 4BFFFDB9  bl 0x82e0c198
	ctx.lr = 0x82E0C3E4;
	sub_82E0C198(ctx, base);
	// 82E0C3E4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E0C3E8: 4BFFF9A9  bl 0x82e0bd90
	ctx.lr = 0x82E0C3EC;
	sub_82E0BD90(ctx, base);
	// 82E0C3EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E0C3F0: 387F0068  addi r3, r31, 0x68
	ctx.r[3].s64 = ctx.r[31].s64 + 104;
	// 82E0C3F4: 4BFFFA1D  bl 0x82e0be10
	ctx.lr = 0x82E0C3F8;
	sub_82E0BE10(ctx, base);
	// 82E0C3F8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E0C3FC: 4BFFF80D  bl 0x82e0bc08
	ctx.lr = 0x82E0C400;
	sub_82E0BC08(ctx, base);
	// 82E0C400: 939F0120  stw r28, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[28].u32 ) };
	// 82E0C404: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E0C408: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0C40C: 409A0054  bne cr6, 0x82e0c460
	if !ctx.cr[6].eq {
	pc = 0x82E0C460; continue 'dispatch;
	}
	// 82E0C410: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0C414: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0C418: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0C41C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0C420: 4E800421  bctrl
	ctx.lr = 0x82E0C424;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0C424: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E0C428: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0C42C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0C430: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0C434: 4E800421  bctrl
	ctx.lr = 0x82E0C438;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0C438: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E0C43C: 4BFFF955  bl 0x82e0bd90
	ctx.lr = 0x82E0C440;
	sub_82E0BD90(ctx, base);
	// 82E0C440: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E0C444: 387F0068  addi r3, r31, 0x68
	ctx.r[3].s64 = ctx.r[31].s64 + 104;
	// 82E0C448: 4BFFF9C9  bl 0x82e0be10
	ctx.lr = 0x82E0C44C;
	sub_82E0BE10(ctx, base);
	// 82E0C44C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E0C450: 4BFFF7B9  bl 0x82e0bc08
	ctx.lr = 0x82E0C454;
	sub_82E0BC08(ctx, base);
	// 82E0C454: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E0C458: 4B4C31A9  bl 0x822cf600
	ctx.lr = 0x82E0C45C;
	sub_822CF600(ctx, base);
	// 82E0C45C: 480004E8  b 0x82e0c944
	pc = 0x82E0C944; continue 'dispatch;
	// 82E0C460: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E0C464: 387F0068  addi r3, r31, 0x68
	ctx.r[3].s64 = ctx.r[31].s64 + 104;
	// 82E0C468: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0C46C: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0C470: 4BFFF9A1  bl 0x82e0be10
	ctx.lr = 0x82E0C474;
	sub_82E0BE10(ctx, base);
	// 82E0C474: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E0C478: 389F003C  addi r4, r31, 0x3c
	ctx.r[4].s64 = ctx.r[31].s64 + 60;
	// 82E0C47C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E0C480: 48011C79  bl 0x82e1e0f8
	ctx.lr = 0x82E0C484;
	sub_82E1E0F8(ctx, base);
	// 82E0C484: 397F0120  addi r11, r31, 0x120
	ctx.r[11].s64 = ctx.r[31].s64 + 288;
	// 82E0C488: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E0C48C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0C490: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E0C494: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82E0C498: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0C49C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0C4A0: 4082FFE8  bne 0x82e0c488
	if !ctx.cr[0].eq {
	pc = 0x82E0C488; continue 'dispatch;
	}
	// 82E0C4A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E0C4A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E0C4AC: 917F004C  stw r11, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82E0C4B0: 4B4C3151  bl 0x822cf600
	ctx.lr = 0x82E0C4B4;
	sub_822CF600(ctx, base);
	// 82E0C4B4: 815F004C  lwz r10, 0x4c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82E0C4B8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82E0C4BC: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 82E0C4C0: 3B6B6524  addi r27, r11, 0x6524
	ctx.r[27].s64 = ctx.r[11].s64 + 25892;
	// 82E0C4C4: 409A018C  bne cr6, 0x82e0c650
	if !ctx.cr[6].eq {
	pc = 0x82E0C650; continue 'dispatch;
	}
	// 82E0C4C8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82E0C4CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E0C4D0: 388B9BC9  addi r4, r11, -0x6437
	ctx.r[4].s64 = ctx.r[11].s64 + -25655;
	// 82E0C4D4: 4BFE7535  bl 0x82df3a08
	ctx.lr = 0x82E0C4D8;
	sub_82DF3A08(ctx, base);
	// 82E0C4D8: 3BDF0068  addi r30, r31, 0x68
	ctx.r[30].s64 = ctx.r[31].s64 + 104;
	// 82E0C4DC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82E0C4E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E0C4E4: 4BFE6E25  bl 0x82df3308
	ctx.lr = 0x82E0C4E8;
	sub_82DF3308(ctx, base);
	// 82E0C4E8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82E0C4EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E0C4F0: 4BFE6F39  bl 0x82df3428
	ctx.lr = 0x82E0C4F4;
	sub_82DF3428(ctx, base);
	// 82E0C4F4: 574B063F  clrlwi. r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0C4F8: 4182005C  beq 0x82e0c554
	if ctx.cr[0].eq {
	pc = 0x82E0C554; continue 'dispatch;
	}
	// 82E0C4FC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E0C500: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82E0C504: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E0C508: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82E0C50C: 9B8B0000  stb r28, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u8 ) };
	// 82E0C510: 88A10050  lbz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E0C514: 4B60F935  bl 0x8241be48
	ctx.lr = 0x82E0C518;
	sub_8241BE48(ctx, base);
	// 82E0C518: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E0C51C: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82E0C520: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E0C524: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82E0C528: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82E0C52C: 419A00F4  beq cr6, 0x82e0c620
	if ctx.cr[6].eq {
	pc = 0x82E0C620; continue 'dispatch;
	}
	// 82E0C530: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82E0C534: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E0C538: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0C53C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E0C540: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0C544: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0C548: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0C54C: 4082FFE8  bne 0x82e0c534
	if !ctx.cr[0].eq {
	pc = 0x82E0C534; continue 'dispatch;
	}
	// 82E0C550: 480000D0  b 0x82e0c620
	pc = 0x82E0C620; continue 'dispatch;
	// 82E0C554: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82E0C558: 897F0118  lbz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82E0C55C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E0C560: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0C564: 40820024  bne 0x82e0c588
	if !ctx.cr[0].eq {
	pc = 0x82E0C588; continue 'dispatch;
	}
	// 82E0C568: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0C56C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E0C570: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0C574: 4E800421  bctrl
	ctx.lr = 0x82E0C578;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0C578: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0C57C: 41820028  beq 0x82e0c5a4
	if ctx.cr[0].eq {
	pc = 0x82E0C5A4; continue 'dispatch;
	}
	// 82E0C580: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82E0C584: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0C588: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E0C58C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0C590: 4E800421  bctrl
	ctx.lr = 0x82E0C594;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0C594: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82E0C598: 907F0054  stw r3, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82E0C59C: 917F004C  stw r11, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82E0C5A0: 480000B0  b 0x82e0c650
	pc = 0x82E0C650; continue 'dispatch;
	// 82E0C5A4: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0C5A8: 395F005C  addi r10, r31, 0x5c
	ctx.r[10].s64 = ctx.r[31].s64 + 92;
	// 82E0C5AC: 389B0004  addi r4, r27, 4
	ctx.r[4].s64 = ctx.r[27].s64 + 4;
	// 82E0C5B0: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82E0C5B4: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E0C5B8: 4B4B7EA9  bl 0x822c4460
	ctx.lr = 0x82E0C5BC;
	sub_822C4460(ctx, base);
	// 82E0C5BC: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 82E0C5C0: 939F004C  stw r28, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[28].u32 ) };
	// 82E0C5C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0C5C8: 419A0088  beq cr6, 0x82e0c650
	if ctx.cr[6].eq {
	pc = 0x82E0C650; continue 'dispatch;
	}
	// 82E0C5CC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E0C5D0: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82E0C5D4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E0C5D8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82E0C5DC: 9B8B0000  stb r28, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u8 ) };
	// 82E0C5E0: 88A10050  lbz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E0C5E4: 4B60F865  bl 0x8241be48
	ctx.lr = 0x82E0C5E8;
	sub_8241BE48(ctx, base);
	// 82E0C5E8: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E0C5EC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82E0C5F0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E0C5F4: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82E0C5F8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82E0C5FC: 419A0024  beq cr6, 0x82e0c620
	if ctx.cr[6].eq {
	pc = 0x82E0C620; continue 'dispatch;
	}
	// 82E0C600: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82E0C604: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E0C608: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0C60C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E0C610: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0C614: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0C618: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0C61C: 4082FFE8  bne 0x82e0c604
	if !ctx.cr[0].eq {
	pc = 0x82E0C604; continue 'dispatch;
	}
	// 82E0C620: 393F0070  addi r9, r31, 0x70
	ctx.r[9].s64 = ctx.r[31].s64 + 112;
	// 82E0C624: 807F0108  lwz r3, 0x108(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 82E0C628: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82E0C62C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82E0C630: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82E0C634: 38BF006C  addi r5, r31, 0x6c
	ctx.r[5].s64 = ctx.r[31].s64 + 108;
	// 82E0C638: 389F0110  addi r4, r31, 0x110
	ctx.r[4].s64 = ctx.r[31].s64 + 272;
	// 82E0C63C: 48001695  bl 0x82e0dcd0
	ctx.lr = 0x82E0C640;
	sub_82E0DCD0(ctx, base);
	// 82E0C640: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E0C644: 419A000C  beq cr6, 0x82e0c650
	if ctx.cr[6].eq {
	pc = 0x82E0C650; continue 'dispatch;
	}
	// 82E0C648: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E0C64C: 4B4B4245  bl 0x822c0890
	ctx.lr = 0x82E0C650;
	sub_822C0890(ctx, base);
	// 82E0C650: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82E0C654: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82E0C658: 409A0138  bne cr6, 0x82e0c790
	if !ctx.cr[6].eq {
	pc = 0x82E0C790; continue 'dispatch;
	}
	// 82E0C65C: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82E0C660: 809F0054  lwz r4, 0x54(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E0C664: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0C668: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E0C66C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0C670: 4E800421  bctrl
	ctx.lr = 0x82E0C674;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0C674: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82E0C678: 408200B0  bne 0x82e0c728
	if !ctx.cr[0].eq {
	pc = 0x82E0C728; continue 'dispatch;
	}
	// 82E0C67C: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82E0C680: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0C684: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0C688: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0C68C: 4E800421  bctrl
	ctx.lr = 0x82E0C690;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0C690: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 82E0C694: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0C698: 419A0088  beq cr6, 0x82e0c720
	if ctx.cr[6].eq {
	pc = 0x82E0C720; continue 'dispatch;
	}
	// 82E0C69C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E0C6A0: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82E0C6A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E0C6A8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82E0C6AC: 9B8B0000  stb r28, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u8 ) };
	// 82E0C6B0: 88A10050  lbz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E0C6B4: 4B60F795  bl 0x8241be48
	ctx.lr = 0x82E0C6B8;
	sub_8241BE48(ctx, base);
	// 82E0C6B8: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82E0C6BC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82E0C6C0: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E0C6C4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E0C6C8: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82E0C6CC: 419A0024  beq cr6, 0x82e0c6f0
	if ctx.cr[6].eq {
	pc = 0x82E0C6F0; continue 'dispatch;
	}
	// 82E0C6D0: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82E0C6D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E0C6D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0C6DC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E0C6E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0C6E4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0C6E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0C6EC: 4082FFE8  bne 0x82e0c6d4
	if !ctx.cr[0].eq {
	pc = 0x82E0C6D4; continue 'dispatch;
	}
	// 82E0C6F0: 393F0070  addi r9, r31, 0x70
	ctx.r[9].s64 = ctx.r[31].s64 + 112;
	// 82E0C6F4: 807F0108  lwz r3, 0x108(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 82E0C6F8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82E0C6FC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82E0C700: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82E0C704: 38BF006C  addi r5, r31, 0x6c
	ctx.r[5].s64 = ctx.r[31].s64 + 108;
	// 82E0C708: 389F0110  addi r4, r31, 0x110
	ctx.r[4].s64 = ctx.r[31].s64 + 272;
	// 82E0C70C: 480015C5  bl 0x82e0dcd0
	ctx.lr = 0x82E0C710;
	sub_82E0DCD0(ctx, base);
	// 82E0C710: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E0C714: 419A000C  beq cr6, 0x82e0c720
	if ctx.cr[6].eq {
	pc = 0x82E0C720; continue 'dispatch;
	}
	// 82E0C718: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E0C71C: 4B4B4175  bl 0x822c0890
	ctx.lr = 0x82E0C720;
	sub_822C0890(ctx, base);
	// 82E0C720: 939F004C  stw r28, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[28].u32 ) };
	// 82E0C724: 48000220  b 0x82e0c944
	pc = 0x82E0C944; continue 'dispatch;
	// 82E0C728: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E0C72C: 4BFFA2DD  bl 0x82e06a08
	ctx.lr = 0x82E0C730;
	sub_82E06A08(ctx, base);
	// 82E0C730: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82E0C734: 41820054  beq 0x82e0c788
	if ctx.cr[0].eq {
	pc = 0x82E0C788; continue 'dispatch;
	}
	// 82E0C738: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E0C73C: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E0C740: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0C744: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E0C748: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82E0C74C: 419A0024  beq cr6, 0x82e0c770
	if ctx.cr[6].eq {
	pc = 0x82E0C770; continue 'dispatch;
	}
	// 82E0C750: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E0C754: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E0C758: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0C75C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E0C760: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0C764: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0C768: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0C76C: 4082FFE8  bne 0x82e0c754
	if !ctx.cr[0].eq {
	pc = 0x82E0C754; continue 'dispatch;
	}
	// 82E0C770: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82E0C774: 387F005C  addi r3, r31, 0x5c
	ctx.r[3].s64 = ctx.r[31].s64 + 92;
	// 82E0C778: 4BFFF731  bl 0x82e0bea8
	ctx.lr = 0x82E0C77C;
	sub_82E0BEA8(ctx, base);
	// 82E0C77C: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82E0C780: 917F004C  stw r11, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82E0C784: 4800000C  b 0x82e0c790
	pc = 0x82E0C790; continue 'dispatch;
	// 82E0C788: 3860000A  li r3, 0xa
	ctx.r[3].s64 = 10;
	// 82E0C78C: 4BFE5E5D  bl 0x82df25e8
	ctx.lr = 0x82E0C790;
	sub_82DF25E8(ctx, base);
	// 82E0C790: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82E0C794: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82E0C798: 409A0050  bne cr6, 0x82e0c7e8
	if !ctx.cr[6].eq {
	pc = 0x82E0C7E8; continue 'dispatch;
	}
	// 82E0C79C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82E0C7A0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82E0C7A4: 409A0008  bne cr6, 0x82e0c7ac
	if !ctx.cr[6].eq {
	pc = 0x82E0C7AC; continue 'dispatch;
	}
	// 82E0C7A8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E0C7AC: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E0C7B0: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82E0C7B4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E0C7B8: 41990008  bgt cr6, 0x82e0c7c0
	if ctx.cr[6].gt {
	pc = 0x82E0C7C0; continue 'dispatch;
	}
	// 82E0C7BC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82E0C7C0: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82E0C7C4: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 82E0C7C8: 809F005C  lwz r4, 0x5c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E0C7CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0C7D0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0C7D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0C7D8: 4E800421  bctrl
	ctx.lr = 0x82E0C7DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0C7DC: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82E0C7E0: 939F0050  stw r28, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82E0C7E4: 917F004C  stw r11, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82E0C7E8: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82E0C7EC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82E0C7F0: 409A0154  bne cr6, 0x82e0c944
	if !ctx.cr[6].eq {
	pc = 0x82E0C944; continue 'dispatch;
	}
	// 82E0C7F4: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82E0C7F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0C7FC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E0C800: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0C804: 4E800421  bctrl
	ctx.lr = 0x82E0C808;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0C808: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82E0C80C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0C810: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E0C814: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0C818: 4E800421  bctrl
	ctx.lr = 0x82E0C81C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0C81C: 815F0050  lwz r10, 0x50(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E0C820: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E0C824: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E0C828: 419A0118  beq cr6, 0x82e0c940
	if ctx.cr[6].eq {
	pc = 0x82E0C940; continue 'dispatch;
	}
	// 82E0C82C: 817F0128  lwz r11, 0x128(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 82E0C830: 7D4AF050  subf r10, r10, r30
	ctx.r[10].s64 = ctx.r[30].s64 - ctx.r[10].s64;
	// 82E0C834: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82E0C838: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E0C83C: 7D2BF010  subfc r9, r11, r30
	ctx.xer.ca = ctx.r[30].u32 >= ctx.r[11].u32;
	ctx.r[9].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 82E0C840: 915F0128  stw r10, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[10].u32 ) };
	// 82E0C844: 7D494910  subfe r10, r9, r9
	let x = (!ctx.r[9].u32);
	let y = ctx.r[9].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82E0C848: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0C84C: 555D063F  clrlwi. r29, r10, 0x18
	ctx.r[29].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82E0C850: 40820038  bne 0x82e0c888
	if !ctx.cr[0].eq {
	pc = 0x82E0C888; continue 'dispatch;
	}
	// 82E0C854: 815F0058  lwz r10, 0x58(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E0C858: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82E0C85C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E0C860: 40990008  ble cr6, 0x82e0c868
	if !ctx.cr[6].gt {
	pc = 0x82E0C868; continue 'dispatch;
	}
	// 82E0C864: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82E0C868: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82E0C86C: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 82E0C870: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E0C874: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82E0C878: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0C87C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0C880: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0C884: 4E800421  bctrl
	ctx.lr = 0x82E0C888;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0C888: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 82E0C88C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0C890: 419A005C  beq cr6, 0x82e0c8ec
	if ctx.cr[6].eq {
	pc = 0x82E0C8EC; continue 'dispatch;
	}
	// 82E0C894: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82E0C898: 815F005C  lwz r10, 0x5c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E0C89C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0C8A0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E0C8A4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82E0C8A8: 419A0024  beq cr6, 0x82e0c8cc
	if ctx.cr[6].eq {
	pc = 0x82E0C8CC; continue 'dispatch;
	}
	// 82E0C8AC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E0C8B0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E0C8B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0C8B8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E0C8BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0C8C0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0C8C4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0C8C8: 4082FFE8  bne 0x82e0c8b0
	if !ctx.cr[0].eq {
	pc = 0x82E0C8B0; continue 'dispatch;
	}
	// 82E0C8CC: 393F0070  addi r9, r31, 0x70
	ctx.r[9].s64 = ctx.r[31].s64 + 112;
	// 82E0C8D0: 811F0054  lwz r8, 0x54(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E0C8D4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82E0C8D8: 807F0108  lwz r3, 0x108(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 82E0C8DC: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82E0C8E0: 38BF006C  addi r5, r31, 0x6c
	ctx.r[5].s64 = ctx.r[31].s64 + 108;
	// 82E0C8E4: 389F0110  addi r4, r31, 0x110
	ctx.r[4].s64 = ctx.r[31].s64 + 272;
	// 82E0C8E8: 480013E9  bl 0x82e0dcd0
	ctx.lr = 0x82E0C8EC;
	sub_82E0DCD0(ctx, base);
	// 82E0C8EC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82E0C8F0: 419A0050  beq cr6, 0x82e0c940
	if ctx.cr[6].eq {
	pc = 0x82E0C940; continue 'dispatch;
	}
	// 82E0C8F4: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82E0C8F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0C8FC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0C900: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0C904: 4E800421  bctrl
	ctx.lr = 0x82E0C908;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0C908: 397F005C  addi r11, r31, 0x5c
	ctx.r[11].s64 = ctx.r[31].s64 + 92;
	// 82E0C90C: 389B0004  addi r4, r27, 4
	ctx.r[4].s64 = ctx.r[27].s64 + 4;
	// 82E0C910: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82E0C914: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0C918: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E0C91C: 4B4B7B45  bl 0x822c4460
	ctx.lr = 0x82E0C920;
	sub_822C4460(ctx, base);
	// 82E0C920: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E0C924: 4BFFF46D  bl 0x82e0bd90
	ctx.lr = 0x82E0C928;
	sub_82E0BD90(ctx, base);
	// 82E0C928: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E0C92C: 387F0068  addi r3, r31, 0x68
	ctx.r[3].s64 = ctx.r[31].s64 + 104;
	// 82E0C930: 4BFFF4E1  bl 0x82e0be10
	ctx.lr = 0x82E0C934;
	sub_82E0BE10(ctx, base);
	// 82E0C934: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E0C938: 4BFFF2D1  bl 0x82e0bc08
	ctx.lr = 0x82E0C93C;
	sub_82E0BC08(ctx, base);
	// 82E0C93C: 939F004C  stw r28, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[28].u32 ) };
	// 82E0C940: 93DF0050  stw r30, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E0C944: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 82E0C948: 4839B868  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0C950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0C950 size=116
    let mut pc: u32 = 0x82E0C950;
    'dispatch: loop {
        match pc {
            0x82E0C950 => {
    //   block [0x82E0C950..0x82E0C9C4)
	// 82E0C950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0C954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0C958: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0C95C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0C960: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0C964: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E0C968: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0C96C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0C970: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0C974: 419A0028  beq cr6, 0x82e0c99c
	if ctx.cr[6].eq {
	pc = 0x82E0C99C; continue 'dispatch;
	}
	// 82E0C978: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0C97C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0C980: 4E800421  bctrl
	ctx.lr = 0x82E0C984;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0C984: 4800002C  b 0x82e0c9b0
	pc = 0x82E0C9B0; continue 'dispatch;
	// 82E0C988: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0C98C: 809F0038  lwz r4, 0x38(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E0C990: 4BFFFA01  bl 0x82e0c390
	ctx.lr = 0x82E0C994;
	sub_82E0C390(ctx, base);
	// 82E0C994: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E0C998: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0C99C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E0C9A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0C9A4: 4E800421  bctrl
	ctx.lr = 0x82E0C9A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0C9A8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0C9AC: 4182FFDC  beq 0x82e0c988
	if ctx.cr[0].eq {
	pc = 0x82E0C988; continue 'dispatch;
	}
	// 82E0C9B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E0C9B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0C9B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0C9BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E0C9C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0C9C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0C9C8 size=88
    let mut pc: u32 = 0x82E0C9C8;
    'dispatch: loop {
        match pc {
            0x82E0C9C8 => {
    //   block [0x82E0C9C8..0x82E0CA20)
	// 82E0C9C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0C9CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0C9D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0C9D4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0C9D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0C9DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0C9E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E0C9E4: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0C9E8: 80A60000  lwz r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0C9EC: 48011B15  bl 0x82e1e500
	ctx.lr = 0x82E0C9F0;
	sub_82E1E500(ctx, base);
	// 82E0C9F0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E0C9F4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0C9F8: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E0C9FC: 4BFE578D  bl 0x82df2188
	ctx.lr = 0x82E0CA00;
	sub_82DF2188(ctx, base);
	// 82E0CA00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0CA04: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E0CA08: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E0CA0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E0CA10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0CA14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0CA18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E0CA1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0CA20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0CA20 size=176
    let mut pc: u32 = 0x82E0CA20;
    'dispatch: loop {
        match pc {
            0x82E0CA20 => {
    //   block [0x82E0CA20..0x82E0CAD0)
	// 82E0CA20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0CA24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0CA28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0CA2C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0CA30: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0CA34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0CA38: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 82E0CA3C: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82E0CA40: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E0CA44: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0CA48: 892B0015  lbz r9, 0x15(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82E0CA4C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E0CA50: 409A0048  bne cr6, 0x82e0ca98
	if !ctx.cr[6].eq {
	pc = 0x82E0CA98; continue 'dispatch;
	}
	// 82E0CA54: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0CA58: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0CA5C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0CA60: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82E0CA64: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0CA68: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82E0CA6C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E0CA70: 41990008  bgt cr6, 0x82e0ca78
	if ctx.cr[6].gt {
	pc = 0x82E0CA78; continue 'dispatch;
	}
	// 82E0CA74: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E0CA78: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E0CA7C: 4182000C  beq 0x82e0ca88
	if ctx.cr[0].eq {
	pc = 0x82E0CA88; continue 'dispatch;
	}
	// 82E0CA80: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0CA84: 48000008  b 0x82e0ca8c
	pc = 0x82E0CA8C; continue 'dispatch;
	// 82E0CA88: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0CA8C: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82E0CA90: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82E0CA94: 419AFFC8  beq cr6, 0x82e0ca5c
	if ctx.cr[6].eq {
	pc = 0x82E0CA5C; continue 'dispatch;
	}
	// 82E0CA98: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 82E0CA9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0CAA0: 48011AE9  bl 0x82e1e588
	ctx.lr = 0x82E0CAA4;
	sub_82E1E588(ctx, base);
	// 82E0CAA4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E0CAA8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E0CAAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0CAB0: 995F0004  stb r10, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 82E0CAB4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0CAB8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E0CABC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E0CAC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0CAC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0CAC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E0CACC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0CAD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0CAD0 size=128
    let mut pc: u32 = 0x82E0CAD0;
    'dispatch: loop {
        match pc {
            0x82E0CAD0 => {
    //   block [0x82E0CAD0..0x82E0CB50)
	// 82E0CAD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0CAD4: 4839B699  bl 0x831a816c
	ctx.lr = 0x82E0CAD8;
	sub_831A8130(ctx, base);
	// 82E0CAD8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0CADC: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82E0CAE0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82E0CAE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E0CAE8: 3BEB6518  addi r31, r11, 0x6518
	ctx.r[31].s64 = ctx.r[11].s64 + 25880;
	// 82E0CAEC: 816A6520  lwz r11, 0x6520(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25888 as u32) ) } as u64;
	// 82E0CAF0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82E0CAF4: 40820024  bne 0x82e0cb18
	if !ctx.cr[0].eq {
	pc = 0x82E0CB18; continue 'dispatch;
	}
	// 82E0CAF8: 3D2082E1  lis r9, -0x7d1f
	ctx.r[9].s64 = -2099183616;
	// 82E0CAFC: 3D0082E1  lis r8, -0x7d1f
	ctx.r[8].s64 = -2099183616;
	// 82E0CB00: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82E0CB04: 3929BD78  addi r9, r9, -0x4288
	ctx.r[9].s64 = ctx.r[9].s64 + -17032;
	// 82E0CB08: 3908B898  addi r8, r8, -0x4768
	ctx.r[8].s64 = ctx.r[8].s64 + -18280;
	// 82E0CB0C: 916A6520  stw r11, 0x6520(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(25888 as u32), ctx.r[11].u32 ) };
	// 82E0CB10: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82E0CB14: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82E0CB18: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E0CB1C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E0CB20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0CB24: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 82E0CB28: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82E0CB2C: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E0CB30: 4BFFEBC1  bl 0x82e0b6f0
	ctx.lr = 0x82E0CB34;
	sub_82E0B6F0(ctx, base);
	// 82E0CB34: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0CB38: 4182000C  beq 0x82e0cb44
	if ctx.cr[0].eq {
	pc = 0x82E0CB44; continue 'dispatch;
	}
	// 82E0CB3C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82E0CB40: 48000008  b 0x82e0cb48
	pc = 0x82E0CB48; continue 'dispatch;
	// 82E0CB44: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82E0CB48: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E0CB4C: 4839B670  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0CB50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0CB50 size=484
    let mut pc: u32 = 0x82E0CB50;
    'dispatch: loop {
        match pc {
            0x82E0CB50 => {
    //   block [0x82E0CB50..0x82E0CD34)
	// 82E0CB50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0CB54: 4839B609  bl 0x831a815c
	ctx.lr = 0x82E0CB58;
	sub_831A8130(ctx, base);
	// 82E0CB58: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0CB5C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82E0CB60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0CB64: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E0CB68: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82E0CB6C: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0CB70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0CB74: 409A0020  bne cr6, 0x82e0cb94
	if !ctx.cr[6].eq {
	pc = 0x82E0CB94; continue 'dispatch;
	}
	// 82E0CB78: 80DA0004  lwz r6, 4(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0CB7C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E0CB80: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82E0CB84: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E0CB88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0CB8C: 480119FD  bl 0x82e1e588
	ctx.lr = 0x82E0CB90;
	sub_82E1E588(ctx, base);
	// 82E0CB90: 48000198  b 0x82e0cd28
	pc = 0x82E0CD28; continue 'dispatch;
	// 82E0CB94: 833A0004  lwz r25, 4(r26)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0CB98: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0CB9C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E0CBA0: 409A0034  bne cr6, 0x82e0cbd4
	if !ctx.cr[6].eq {
	pc = 0x82E0CBD4; continue 'dispatch;
	}
	// 82E0CBA4: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0CBA8: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0CBAC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0CBB0: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0CBB4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82E0CBB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E0CBBC: 41990008  bgt cr6, 0x82e0cbc4
	if ctx.cr[6].gt {
	pc = 0x82E0CBC4; continue 'dispatch;
	}
	// 82E0CBC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0CBC4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0CBC8: 40820144  bne 0x82e0cd0c
	if !ctx.cr[0].eq {
	pc = 0x82E0CD0C; continue 'dispatch;
	}
	// 82E0CBCC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82E0CBD0: 4BFFFFAC  b 0x82e0cb7c
	pc = 0x82E0CB7C; continue 'dispatch;
	// 82E0CBD4: 7F1EC840  cmplw cr6, r30, r25
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82E0CBD8: 409A0038  bne cr6, 0x82e0cc10
	if !ctx.cr[6].eq {
	pc = 0x82E0CC10; continue 'dispatch;
	}
	// 82E0CBDC: 80D90008  lwz r6, 8(r25)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0CBE0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0CBE4: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0CBE8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0CBEC: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0CBF0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82E0CBF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E0CBF8: 41990008  bgt cr6, 0x82e0cc00
	if ctx.cr[6].gt {
	pc = 0x82E0CC00; continue 'dispatch;
	}
	// 82E0CBFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0CC00: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0CC04: 40820108  bne 0x82e0cd0c
	if !ctx.cr[0].eq {
	pc = 0x82E0CD0C; continue 'dispatch;
	}
	// 82E0CC08: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E0CC0C: 4BFFFF74  b 0x82e0cb80
	pc = 0x82E0CB80; continue 'dispatch;
	// 82E0CC10: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0CC14: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0CC18: 838B0008  lwz r28, 8(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0CC1C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E0CC20: 836A0008  lwz r27, 8(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0CC24: 7F1CD800  cmpw cr6, r28, r27
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[27].s32, &mut ctx.xer);
	// 82E0CC28: 41990008  bgt cr6, 0x82e0cc30
	if ctx.cr[6].gt {
	pc = 0x82E0CC30; continue 'dispatch;
	}
	// 82E0CC2C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0CC30: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0CC34: 40820064  bne 0x82e0cc98
	if !ctx.cr[0].eq {
	pc = 0x82E0CC98; continue 'dispatch;
	}
	// 82E0CC38: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E0CC3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0CC40: 48010221  bl 0x82e1ce60
	ctx.lr = 0x82E0CC44;
	sub_82E1CE60(ctx, base);
	// 82E0CC44: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E0CC48: 8166000C  lwz r11, 0xc(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0CC4C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0CC50: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82E0CC54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E0CC58: 41990008  bgt cr6, 0x82e0cc60
	if ctx.cr[6].gt {
	pc = 0x82E0CC60; continue 'dispatch;
	}
	// 82E0CC5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0CC60: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0CC64: 40820034  bne 0x82e0cc98
	if !ctx.cr[0].eq {
	pc = 0x82E0CC98; continue 'dispatch;
	}
	// 82E0CC68: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0CC6C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82E0CC70: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E0CC74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0CC78: 896B0015  lbz r11, 0x15(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82E0CC7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0CC80: 419A000C  beq cr6, 0x82e0cc8c
	if ctx.cr[6].eq {
	pc = 0x82E0CC8C; continue 'dispatch;
	}
	// 82E0CC84: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E0CC88: 4BFFFF04  b 0x82e0cb8c
	pc = 0x82E0CB8C; continue 'dispatch;
	// 82E0CC8C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82E0CC90: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E0CC94: 4BFFFEF8  b 0x82e0cb8c
	pc = 0x82E0CB8C; continue 'dispatch;
	// 82E0CC98: 7F1BE000  cmpw cr6, r27, r28
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82E0CC9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E0CCA0: 41990008  bgt cr6, 0x82e0cca8
	if ctx.cr[6].gt {
	pc = 0x82E0CCA8; continue 'dispatch;
	}
	// 82E0CCA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0CCA8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0CCAC: 40820060  bne 0x82e0cd0c
	if !ctx.cr[0].eq {
	pc = 0x82E0CD0C; continue 'dispatch;
	}
	// 82E0CCB0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E0CCB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0CCB8: 4BFEEFA1  bl 0x82dfbc58
	ctx.lr = 0x82E0CCBC;
	sub_82DFBC58(ctx, base);
	// 82E0CCBC: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E0CCC0: 7F06C840  cmplw cr6, r6, r25
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82E0CCC4: 419A0024  beq cr6, 0x82e0cce8
	if ctx.cr[6].eq {
	pc = 0x82E0CCE8; continue 'dispatch;
	}
	// 82E0CCC8: 8166000C  lwz r11, 0xc(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0CCCC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0CCD0: 7F0BD800  cmpw cr6, r11, r27
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[27].s32, &mut ctx.xer);
	// 82E0CCD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E0CCD8: 41990008  bgt cr6, 0x82e0cce0
	if ctx.cr[6].gt {
	pc = 0x82E0CCE0; continue 'dispatch;
	}
	// 82E0CCDC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0CCE0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0CCE4: 40820028  bne 0x82e0cd0c
	if !ctx.cr[0].eq {
	pc = 0x82E0CD0C; continue 'dispatch;
	}
	// 82E0CCE8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0CCEC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82E0CCF0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E0CCF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0CCF8: 896B0015  lbz r11, 0x15(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82E0CCFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0CD00: 419AFF90  beq cr6, 0x82e0cc90
	if ctx.cr[6].eq {
	pc = 0x82E0CC90; continue 'dispatch;
	}
	// 82E0CD04: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82E0CD08: 4BFFFF7C  b 0x82e0cc84
	pc = 0x82E0CC84; continue 'dispatch;
	// 82E0CD0C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E0CD10: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E0CD14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0CD18: 4BFFFD09  bl 0x82e0ca20
	ctx.lr = 0x82E0CD1C;
	sub_82E0CA20(ctx, base);
	// 82E0CD1C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E0CD20: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0CD24: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E0CD28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0CD2C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E0CD30: 4839B47C  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0CD38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0CD38 size=96
    let mut pc: u32 = 0x82E0CD38;
    'dispatch: loop {
        match pc {
            0x82E0CD38 => {
    //   block [0x82E0CD38..0x82E0CD98)
	// 82E0CD38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0CD3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0CD40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E0CD44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0CD48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0CD4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E0CD50: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82E0CD54: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82E0CD58: 48000020  b 0x82e0cd78
	pc = 0x82E0CD78; continue 'dispatch;
	// 82E0CD5C: 38A4000C  addi r5, r4, 0xc
	ctx.r[5].s64 = ctx.r[4].s64 + 12;
	// 82E0CD60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E0CD64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0CD68: 4BFFFCB9  bl 0x82e0ca20
	ctx.lr = 0x82E0CD6C;
	sub_82E0CA20(ctx, base);
	// 82E0CD6C: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 82E0CD70: 4BFEEEE9  bl 0x82dfbc58
	ctx.lr = 0x82E0CD74;
	sub_82DFBC58(ctx, base);
	// 82E0CD74: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82E0CD78: 7F04F840  cmplw cr6, r4, r31
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82E0CD7C: 409AFFE0  bne cr6, 0x82e0cd5c
	if !ctx.cr[6].eq {
	pc = 0x82E0CD5C; continue 'dispatch;
	}
	// 82E0CD80: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E0CD84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0CD88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0CD8C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E0CD90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E0CD94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0CD98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0CD98 size=172
    let mut pc: u32 = 0x82E0CD98;
    'dispatch: loop {
        match pc {
            0x82E0CD98 => {
    //   block [0x82E0CD98..0x82E0CE44)
	// 82E0CD98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0CD9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0CDA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0CDA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0CDA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0CDAC: 4BFFEBAD  bl 0x82e0b958
	ctx.lr = 0x82E0CDB0;
	sub_82E0B958(ctx, base);
	// 82E0CDB0: 387F0068  addi r3, r31, 0x68
	ctx.r[3].s64 = ctx.r[31].s64 + 104;
	// 82E0CDB4: 4BFFEE55  bl 0x82e0bc08
	ctx.lr = 0x82E0CDB8;
	sub_82E0BC08(ctx, base);
	// 82E0CDB8: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82E0CDBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0CDC0: 419A0008  beq cr6, 0x82e0cdc8
	if ctx.cr[6].eq {
	pc = 0x82E0CDC8; continue 'dispatch;
	}
	// 82E0CDC4: 4B4B3ACD  bl 0x822c0890
	ctx.lr = 0x82E0CDC8;
	sub_822C0890(ctx, base);
	// 82E0CDC8: 387F003C  addi r3, r31, 0x3c
	ctx.r[3].s64 = ctx.r[31].s64 + 60;
	// 82E0CDCC: 4BFFFBFD  bl 0x82e0c9c8
	ctx.lr = 0x82E0CDD0;
	sub_82E0C9C8(ctx, base);
	// 82E0CDD0: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E0CDD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0CDD8: 419A0008  beq cr6, 0x82e0cde0
	if ctx.cr[6].eq {
	pc = 0x82E0CDE0; continue 'dispatch;
	}
	// 82E0CDDC: 4B4B3AB5  bl 0x822c0890
	ctx.lr = 0x82E0CDE0;
	sub_822C0890(ctx, base);
	// 82E0CDE0: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E0CDE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0CDE8: 419A0008  beq cr6, 0x82e0cdf0
	if ctx.cr[6].eq {
	pc = 0x82E0CDF0; continue 'dispatch;
	}
	// 82E0CDEC: 4B4B3AA5  bl 0x822c0890
	ctx.lr = 0x82E0CDF0;
	sub_822C0890(ctx, base);
	// 82E0CDF0: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E0CDF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0CDF8: 419A0008  beq cr6, 0x82e0ce00
	if ctx.cr[6].eq {
	pc = 0x82E0CE00; continue 'dispatch;
	}
	// 82E0CDFC: 4B4B3A95  bl 0x822c0890
	ctx.lr = 0x82E0CE00;
	sub_822C0890(ctx, base);
	// 82E0CE00: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E0CE04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0CE08: 419A0008  beq cr6, 0x82e0ce10
	if ctx.cr[6].eq {
	pc = 0x82E0CE10; continue 'dispatch;
	}
	// 82E0CE0C: 4B4B3A85  bl 0x822c0890
	ctx.lr = 0x82E0CE10;
	sub_822C0890(ctx, base);
	// 82E0CE10: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0CE14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0CE18: 419A0008  beq cr6, 0x82e0ce20
	if ctx.cr[6].eq {
	pc = 0x82E0CE20; continue 'dispatch;
	}
	// 82E0CE1C: 4B4B3A75  bl 0x822c0890
	ctx.lr = 0x82E0CE20;
	sub_822C0890(ctx, base);
	// 82E0CE20: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0CE24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0CE28: 419A0008  beq cr6, 0x82e0ce30
	if ctx.cr[6].eq {
	pc = 0x82E0CE30; continue 'dispatch;
	}
	// 82E0CE2C: 4B4B3A65  bl 0x822c0890
	ctx.lr = 0x82E0CE30;
	sub_822C0890(ctx, base);
	// 82E0CE30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E0CE34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0CE38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0CE3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E0CE40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0CE48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0CE48 size=512
    let mut pc: u32 = 0x82E0CE48;
    'dispatch: loop {
        match pc {
            0x82E0CE48 => {
    //   block [0x82E0CE48..0x82E0D048)
	// 82E0CE48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0CE4C: 4839B30D  bl 0x831a8158
	ctx.lr = 0x82E0CE50;
	sub_831A8130(ctx, base);
	// 82E0CE50: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0CE54: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E0CE58: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E0CE5C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82E0CE60: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82E0CE64: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82E0CE68: 38C00098  li r6, 0x98
	ctx.r[6].s64 = 152;
	// 82E0CE6C: 38ABB8C8  addi r5, r11, -0x4738
	ctx.r[5].s64 = ctx.r[11].s64 + -18232;
	// 82E0CE70: 389C0018  addi r4, r28, 0x18
	ctx.r[4].s64 = ctx.r[28].s64 + 24;
	// 82E0CE74: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82E0CE78: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82E0CE7C: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 82E0CE80: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 82E0CE84: 4BFEC9B5  bl 0x82df9838
	ctx.lr = 0x82E0CE88;
	sub_82DF9838(ctx, base);
	// 82E0CE88: 386000B8  li r3, 0xb8
	ctx.r[3].s64 = 184;
	// 82E0CE8C: 4B4B3AAD  bl 0x822c0938
	ctx.lr = 0x82E0CE90;
	sub_822C0938(ctx, base);
	// 82E0CE90: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E0CE94: 41820024  beq 0x82e0ceb8
	if ctx.cr[0].eq {
	pc = 0x82E0CEB8; continue 'dispatch;
	}
	// 82E0CE98: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 82E0CE9C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82E0CEA0: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82E0CEA4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E0CEA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E0CEAC: 4BFFF0B5  bl 0x82e0bf60
	ctx.lr = 0x82E0CEB0;
	sub_82E0BF60(ctx, base);
	// 82E0CEB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0CEB4: 48000008  b 0x82e0cebc
	pc = 0x82E0CEBC; continue 'dispatch;
	// 82E0CEB8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E0CEBC: 93F80000  stw r31, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82E0CEC0: 3B780004  addi r27, r24, 4
	ctx.r[27].s64 = ctx.r[24].s64 + 4;
	// 82E0CEC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E0CEC8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E0CECC: 4BFFF1CD  bl 0x82e0c098
	ctx.lr = 0x82E0CED0;
	sub_82E0C098(ctx, base);
	// 82E0CED0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E0CED4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E0CED8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E0CEDC: 4B4B3125  bl 0x822c0000
	ctx.lr = 0x82E0CEE0;
	sub_822C0000(ctx, base);
	// 82E0CEE0: 83F80000  lwz r31, 0(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0CEE4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E0CEE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0CEEC: 409A0048  bne cr6, 0x82e0cf34
	if !ctx.cr[6].eq {
	pc = 0x82E0CF34; continue 'dispatch;
	}
	// 82E0CEF0: 809C002C  lwz r4, 0x2c(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E0CEF4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E0CEF8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0CEFC: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E0CF00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0CF04: 4E800421  bctrl
	ctx.lr = 0x82E0CF08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0CF08: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E0CF0C: 395F0010  addi r10, r31, 0x10
	ctx.r[10].s64 = ctx.r[31].s64 + 16;
	// 82E0CF10: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82E0CF14: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82E0CF18: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0CF1C: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82E0CF20: 4B4B7541  bl 0x822c4460
	ctx.lr = 0x82E0CF24;
	sub_822C4460(ctx, base);
	// 82E0CF24: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E0CF28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0CF2C: 419A0008  beq cr6, 0x82e0cf34
	if ctx.cr[6].eq {
	pc = 0x82E0CF34; continue 'dispatch;
	}
	// 82E0CF30: 4B4B3961  bl 0x822c0890
	ctx.lr = 0x82E0CF34;
	sub_822C0890(ctx, base);
	// 82E0CF34: 83FC0040  lwz r31, 0x40(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E0CF38: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82E0CF3C: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0CF40: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E0CF44: 48000028  b 0x82e0cf6c
	pc = 0x82E0CF6C; continue 'dispatch;
	// 82E0CF48: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E0CF4C: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0CF50: 4BFE62E9  bl 0x82df3238
	ctx.lr = 0x82E0CF54;
	sub_82DF3238(ctx, base);
	// 82E0CF54: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0CF58: 4182001C  beq 0x82e0cf74
	if ctx.cr[0].eq {
	pc = 0x82E0CF74; continue 'dispatch;
	}
	// 82E0CF5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0CF60: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82E0CF64: 4BFEECF5  bl 0x82dfbc58
	ctx.lr = 0x82E0CF68;
	sub_82DFBC58(ctx, base);
	// 82E0CF68: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E0CF6C: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82E0CF70: 409AFFD8  bne cr6, 0x82e0cf48
	if !ctx.cr[6].eq {
	pc = 0x82E0CF48; continue 'dispatch;
	}
	// 82E0CF74: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0CF78: 81580000  lwz r10, 0(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0CF7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0CF80: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E0CF84: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82E0CF88: 419A0024  beq cr6, 0x82e0cfac
	if ctx.cr[6].eq {
	pc = 0x82E0CFAC; continue 'dispatch;
	}
	// 82E0CF8C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E0CF90: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E0CF94: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0CF98: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E0CF9C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0CFA0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0CFA4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0CFA8: 4082FFE8  bne 0x82e0cf90
	if !ctx.cr[0].eq {
	pc = 0x82E0CF90; continue 'dispatch;
	}
	// 82E0CFAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E0CFB0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E0CFB4: 4BFFE92D  bl 0x82e0b8e0
	ctx.lr = 0x82E0CFB8;
	sub_82E0B8E0(ctx, base);
	// 82E0CFB8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82E0CFBC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E0CFC0: 389C003C  addi r4, r28, 0x3c
	ctx.r[4].s64 = ctx.r[28].s64 + 60;
	// 82E0CFC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0CFC8: 4BFFFB89  bl 0x82e0cb50
	ctx.lr = 0x82E0CFCC;
	sub_82E0CB50(ctx, base);
	// 82E0CFCC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E0CFD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0CFD4: 419A0008  beq cr6, 0x82e0cfdc
	if ctx.cr[6].eq {
	pc = 0x82E0CFDC; continue 'dispatch;
	}
	// 82E0CFD8: 4B4B38B9  bl 0x822c0890
	ctx.lr = 0x82E0CFDC;
	sub_822C0890(ctx, base);
	// 82E0CFDC: 397C0120  addi r11, r28, 0x120
	ctx.r[11].s64 = ctx.r[28].s64 + 288;
	// 82E0CFE0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E0CFE4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0CFE8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E0CFEC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0CFF0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0CFF4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0CFF8: 4082FFE8  bne 0x82e0cfe0
	if !ctx.cr[0].eq {
	pc = 0x82E0CFE0; continue 'dispatch;
	}
	// 82E0CFFC: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0D000: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D004: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0D008: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0D00C: 4E800421  bctrl
	ctx.lr = 0x82E0D010;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0D010: 807C0010  lwz r3, 0x10(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E0D014: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D018: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0D01C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0D020: 4E800421  bctrl
	ctx.lr = 0x82E0D024;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0D024: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82E0D028: 4B4C25D9  bl 0x822cf600
	ctx.lr = 0x82E0D02C;
	sub_822CF600(ctx, base);
	// 82E0D02C: 80790004  lwz r3, 4(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0D030: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0D034: 419A0008  beq cr6, 0x82e0d03c
	if ctx.cr[6].eq {
	pc = 0x82E0D03C; continue 'dispatch;
	}
	// 82E0D038: 4B4B3859  bl 0x822c0890
	ctx.lr = 0x82E0D03C;
	sub_822C0890(ctx, base);
	// 82E0D03C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82E0D040: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82E0D044: 4839B164  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0D048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0D048 size=580
    let mut pc: u32 = 0x82E0D048;
    'dispatch: loop {
        match pc {
            0x82E0D048 => {
    //   block [0x82E0D048..0x82E0D28C)
	// 82E0D048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0D04C: 4839B109  bl 0x831a8154
	ctx.lr = 0x82E0D050;
	sub_831A8130(ctx, base);
	// 82E0D050: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0D054: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E0D058: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E0D05C: 4805414D  bl 0x82e611a8
	ctx.lr = 0x82E0D060;
	sub_82E611A8(ctx, base);
	// 82E0D060: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E0D064: 3B5E0018  addi r26, r30, 0x18
	ctx.r[26].s64 = ctx.r[30].s64 + 24;
	// 82E0D068: 3B2BB8C8  addi r25, r11, -0x4738
	ctx.r[25].s64 = ctx.r[11].s64 + -18232;
	// 82E0D06C: 38C00148  li r6, 0x148
	ctx.r[6].s64 = 328;
	// 82E0D070: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82E0D074: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E0D078: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82E0D07C: 4BFEC7BD  bl 0x82df9838
	ctx.lr = 0x82E0D080;
	sub_82DF9838(ctx, base);
	// 82E0D080: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82E0D084: 815E0040  lwz r10, 0x40(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E0D088: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82E0D08C: 81210078  lwz r9, 0x78(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82E0D090: 3BFE003C  addi r31, r30, 0x3c
	ctx.r[31].s64 = ctx.r[30].s64 + 60;
	// 82E0D094: 917E0040  stw r11, 0x40(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82E0D098: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82E0D09C: 817E0044  lwz r11, 0x44(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E0D0A0: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82E0D0A4: 913E0044  stw r9, 0x44(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(68 as u32), ctx.r[9].u32 ) };
	// 82E0D0A8: 4B4C2559  bl 0x822cf600
	ctx.lr = 0x82E0D0AC;
	sub_822CF600(ctx, base);
	// 82E0D0AC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82E0D0B0: 7D785B78  mr r24, r11
	ctx.r[24].u64 = ctx.r[11].u64;
	// 82E0D0B4: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D0B8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E0D0BC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82E0D0C0: 419A0120  beq cr6, 0x82e0d1e0
	if ctx.cr[6].eq {
	pc = 0x82E0D1E0; continue 'dispatch;
	}
	// 82E0D0C4: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82E0D0C8: 839D000C  lwz r28, 0xc(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0D0CC: 897C00B0  lbz r11, 0xb0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(176 as u32) ) } as u64;
	// 82E0D0D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E0D0D4: 408200F8  bne 0x82e0d1cc
	if !ctx.cr[0].eq {
	pc = 0x82E0D1CC; continue 'dispatch;
	}
	// 82E0D0D8: 807C0010  lwz r3, 0x10(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E0D0DC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E0D0E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D0E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0D0E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0D0EC: 4E800421  bctrl
	ctx.lr = 0x82E0D0F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0D0F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0D0F4: 408200D0  bne 0x82e0d1c4
	if !ctx.cr[0].eq {
	pc = 0x82E0D1C4; continue 'dispatch;
	}
	// 82E0D0F8: 817C00A0  lwz r11, 0xa0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(160 as u32) ) } as u64;
	// 82E0D0FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0D100: 419A0088  beq cr6, 0x82e0d188
	if ctx.cr[6].eq {
	pc = 0x82E0D188; continue 'dispatch;
	}
	// 82E0D104: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E0D108: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 82E0D10C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E0D110: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82E0D114: 9AEB0000  stb r23, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[23].u8 ) };
	// 82E0D118: 88A10050  lbz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E0D11C: 4B60ED2D  bl 0x8241be48
	ctx.lr = 0x82E0D120;
	sub_8241BE48(ctx, base);
	// 82E0D120: 83610064  lwz r27, 0x64(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E0D124: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82E0D128: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82E0D12C: 9361006C  stw r27, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[27].u32 ) };
	// 82E0D130: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82E0D134: 419A0024  beq cr6, 0x82e0d158
	if ctx.cr[6].eq {
	pc = 0x82E0D158; continue 'dispatch;
	}
	// 82E0D138: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 82E0D13C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E0D140: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0D144: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E0D148: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0D14C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0D150: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0D154: 4082FFE8  bne 0x82e0d13c
	if !ctx.cr[0].eq {
	pc = 0x82E0D13C; continue 'dispatch;
	}
	// 82E0D158: 393C0008  addi r9, r28, 8
	ctx.r[9].s64 = ctx.r[28].s64 + 8;
	// 82E0D15C: 807C00A0  lwz r3, 0xa0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(160 as u32) ) } as u64;
	// 82E0D160: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82E0D164: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82E0D168: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 82E0D16C: 38BC0004  addi r5, r28, 4
	ctx.r[5].s64 = ctx.r[28].s64 + 4;
	// 82E0D170: 389C00A8  addi r4, r28, 0xa8
	ctx.r[4].s64 = ctx.r[28].s64 + 168;
	// 82E0D174: 48000B5D  bl 0x82e0dcd0
	ctx.lr = 0x82E0D178;
	sub_82E0DCD0(ctx, base);
	// 82E0D178: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82E0D17C: 419A000C  beq cr6, 0x82e0d188
	if ctx.cr[6].eq {
	pc = 0x82E0D188; continue 'dispatch;
	}
	// 82E0D180: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E0D184: 4B4B370D  bl 0x822c0890
	ctx.lr = 0x82E0D188;
	sub_822C0890(ctx, base);
	// 82E0D188: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E0D18C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82E0D190: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E0D194: 48010F65  bl 0x82e1e0f8
	ctx.lr = 0x82E0D198;
	sub_82E1E0F8(ctx, base);
	// 82E0D198: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D19C: 393E0120  addi r9, r30, 0x120
	ctx.r[9].s64 = ctx.r[30].s64 + 288;
	// 82E0D1A0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82E0D1A4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82E0D1A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0D1AC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82E0D1B0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E0D1B4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0D1B8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0D1BC: 4082FFE8  bne 0x82e0d1a4
	if !ctx.cr[0].eq {
	pc = 0x82E0D1A4; continue 'dispatch;
	}
	// 82E0D1C0: 48000018  b 0x82e0d1d8
	pc = 0x82E0D1D8; continue 'dispatch;
	// 82E0D1C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E0D1C8: 997C00B0  stb r11, 0xb0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(176 as u32), ctx.r[11].u8 ) };
	// 82E0D1CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E0D1D0: 4BFEEA89  bl 0x82dfbc58
	ctx.lr = 0x82E0D1D4;
	sub_82DFBC58(ctx, base);
	// 82E0D1D4: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E0D1D8: 7F1DC040  cmplw cr6, r29, r24
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82E0D1DC: 409AFEEC  bne cr6, 0x82e0d0c8
	if !ctx.cr[6].eq {
	pc = 0x82E0D0C8; continue 'dispatch;
	}
	// 82E0D1E0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82E0D1E4: 38C0016B  li r6, 0x16b
	ctx.r[6].s64 = 363;
	// 82E0D1E8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E0D1EC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82E0D1F0: 4BFEC649  bl 0x82df9838
	ctx.lr = 0x82E0D1F4;
	sub_82DF9838(ctx, base);
	// 82E0D1F4: 817E0044  lwz r11, 0x44(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E0D1F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0D1FC: 409A0048  bne cr6, 0x82e0d244
	if !ctx.cr[6].eq {
	pc = 0x82E0D244; continue 'dispatch;
	}
	// 82E0D200: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82E0D204: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0D208: 81210078  lwz r9, 0x78(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82E0D20C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E0D210: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82E0D214: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0D218: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82E0D21C: 893E0028  lbz r9, 0x28(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E0D220: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E0D224: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82E0D228: 4082004C  bne 0x82e0d274
	if !ctx.cr[0].eq {
	pc = 0x82E0D274; continue 'dispatch;
	}
	// 82E0D22C: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0D230: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D234: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0D238: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0D23C: 4E800421  bctrl
	ctx.lr = 0x82E0D240;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0D240: 48000034  b 0x82e0d274
	pc = 0x82E0D274; continue 'dispatch;
	// 82E0D244: 80BE0040  lwz r5, 0x40(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E0D248: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E0D24C: 80850000  lwz r4, 0(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D250: 4BFFFAE9  bl 0x82e0cd38
	ctx.lr = 0x82E0D254;
	sub_82E0CD38(ctx, base);
	// 82E0D254: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82E0D258: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0D25C: 81210078  lwz r9, 0x78(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82E0D260: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E0D264: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82E0D268: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0D26C: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82E0D270: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82E0D274: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82E0D278: 4B4C2389  bl 0x822cf600
	ctx.lr = 0x82E0D27C;
	sub_822CF600(ctx, base);
	// 82E0D27C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E0D280: 4BFFF749  bl 0x82e0c9c8
	ctx.lr = 0x82E0D284;
	sub_82E0C9C8(ctx, base);
	// 82E0D284: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82E0D288: 4839AF1C  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0D290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0D290 size=528
    let mut pc: u32 = 0x82E0D290;
    'dispatch: loop {
        match pc {
            0x82E0D290 => {
    //   block [0x82E0D290..0x82E0D4A0)
	// 82E0D290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0D294: 4839AEC5  bl 0x831a8158
	ctx.lr = 0x82E0D298;
	sub_831A8130(ctx, base);
	// 82E0D298: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0D29C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0D2A0: 3F808338  lis r28, -0x7cc8
	ctx.r[28].s64 = -2093481984;
	// 82E0D2A4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E0D2A8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82E0D2AC: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82E0D2B0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82E0D2B4: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82E0D2B8: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82E0D2BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E0D2C0: 807C5F9C  lwz r3, 0x5f9c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24476 as u32) ) } as u64;
	// 82E0D2C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D2C8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D2CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0D2D0: 4E800421  bctrl
	ctx.lr = 0x82E0D2D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0D2D4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82E0D2D8: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 82E0D2DC: 931F0008  stw r24, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	// 82E0D2E0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82E0D2E4: 3BAB0004  addi r29, r11, 4
	ctx.r[29].s64 = ctx.r[11].s64 + 4;
	// 82E0D2E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E0D2EC: 4BFEC6F5  bl 0x82df99e0
	ctx.lr = 0x82E0D2F0;
	sub_82DF99E0(ctx, base);
	// 82E0D2F0: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82E0D2F4: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82E0D2F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E0D2FC: 4B4B2D05  bl 0x822c0000
	ctx.lr = 0x82E0D300;
	sub_822C0000(ctx, base);
	// 82E0D300: 807C5F9C  lwz r3, 0x5f9c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24476 as u32) ) } as u64;
	// 82E0D304: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E0D308: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D30C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D310: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0D314: 4E800421  bctrl
	ctx.lr = 0x82E0D318;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0D318: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82E0D31C: 3BBF0010  addi r29, r31, 0x10
	ctx.r[29].s64 = ctx.r[31].s64 + 16;
	// 82E0D320: 931F0010  stw r24, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[24].u32 ) };
	// 82E0D324: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82E0D328: 3B9D0004  addi r28, r29, 4
	ctx.r[28].s64 = ctx.r[29].s64 + 4;
	// 82E0D32C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E0D330: 4BFEC6B1  bl 0x82df99e0
	ctx.lr = 0x82E0D334;
	sub_82DF99E0(ctx, base);
	// 82E0D334: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82E0D338: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82E0D33C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E0D340: 4B4B2CC1  bl 0x822c0000
	ctx.lr = 0x82E0D344;
	sub_822C0000(ctx, base);
	// 82E0D344: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E0D348: 806B16D4  lwz r3, 0x16d4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5844 as u32) ) } as u64;
	// 82E0D34C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D350: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D354: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0D358: 4E800421  bctrl
	ctx.lr = 0x82E0D35C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0D35C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82E0D360: 397F0018  addi r11, r31, 0x18
	ctx.r[11].s64 = ctx.r[31].s64 + 24;
	// 82E0D364: 931F0018  stw r24, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[24].u32 ) };
	// 82E0D368: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82E0D36C: 3B8B0004  addi r28, r11, 4
	ctx.r[28].s64 = ctx.r[11].s64 + 4;
	// 82E0D370: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E0D374: 4B4C216D  bl 0x822cf4e0
	ctx.lr = 0x82E0D378;
	sub_822CF4E0(ctx, base);
	// 82E0D378: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82E0D37C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82E0D380: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E0D384: 4B4B2C7D  bl 0x822c0000
	ctx.lr = 0x82E0D388;
	sub_822C0000(ctx, base);
	// 82E0D388: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 82E0D38C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D390: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82E0D394: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0D398: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0D39C: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82E0D3A0: 419A0024  beq cr6, 0x82e0d3c4
	if ctx.cr[6].eq {
	pc = 0x82E0D3C4; continue 'dispatch;
	}
	// 82E0D3A4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E0D3A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E0D3AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0D3B0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E0D3B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0D3B8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0D3BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0D3C0: 4082FFE8  bne 0x82e0d3a8
	if !ctx.cr[0].eq {
	pc = 0x82E0D3A8; continue 'dispatch;
	}
	// 82E0D3C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E0D3C8: 397F002C  addi r11, r31, 0x2c
	ctx.r[11].s64 = ctx.r[31].s64 + 44;
	// 82E0D3CC: 995F0028  stb r10, 0x28(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u8 ) };
	// 82E0D3D0: 3B9A0004  addi r28, r26, 4
	ctx.r[28].s64 = ctx.r[26].s64 + 4;
	// 82E0D3D4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D3D8: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82E0D3DC: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0D3E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0D3E4: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82E0D3E8: 419A0024  beq cr6, 0x82e0d40c
	if ctx.cr[6].eq {
	pc = 0x82E0D40C; continue 'dispatch;
	}
	// 82E0D3EC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E0D3F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E0D3F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0D3F8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E0D3FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0D400: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0D404: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0D408: 4082FFE8  bne 0x82e0d3f0
	if !ctx.cr[0].eq {
	pc = 0x82E0D3F0; continue 'dispatch;
	}
	// 82E0D40C: 9BDF0034  stb r30, 0x34(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u8 ) };
	// 82E0D410: 387F003C  addi r3, r31, 0x3c
	ctx.r[3].s64 = ctx.r[31].s64 + 60;
	// 82E0D414: 933F0038  stw r25, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[25].u32 ) };
	// 82E0D418: 48053D91  bl 0x82e611a8
	ctx.lr = 0x82E0D41C;
	sub_82E611A8(ctx, base);
	// 82E0D41C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82E0D420: 933F0058  stw r25, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 82E0D424: 397F005C  addi r11, r31, 0x5c
	ctx.r[11].s64 = ctx.r[31].s64 + 92;
	// 82E0D428: 9BDF0048  stb r30, 0x48(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u8 ) };
	// 82E0D42C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E0D430: 93DF004C  stw r30, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 82E0D434: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82E0D438: 93DF0050  stw r30, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E0D43C: 9BCA0000  stb r30, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	// 82E0D440: 93DF0054  stw r30, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82E0D444: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82E0D448: 88A10050  lbz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E0D44C: 4B60E9FD  bl 0x8241be48
	ctx.lr = 0x82E0D450;
	sub_8241BE48(ctx, base);
	// 82E0D450: 387F0068  addi r3, r31, 0x68
	ctx.r[3].s64 = ctx.r[31].s64 + 104;
	// 82E0D454: 4BFFE93D  bl 0x82e0bd90
	ctx.lr = 0x82E0D458;
	sub_82E0BD90(ctx, base);
	// 82E0D458: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D45C: 93DF0120  stw r30, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[30].u32 ) };
	// 82E0D460: 93DF0128  stw r30, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[30].u32 ) };
	// 82E0D464: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D468: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0D46C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0D470: 4E800421  bctrl
	ctx.lr = 0x82E0D474;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0D474: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D478: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0D47C: 419A0008  beq cr6, 0x82e0d484
	if ctx.cr[6].eq {
	pc = 0x82E0D484; continue 'dispatch;
	}
	// 82E0D480: 4B4B3411  bl 0x822c0890
	ctx.lr = 0x82E0D484;
	sub_822C0890(ctx, base);
	// 82E0D484: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0D488: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0D48C: 419A0008  beq cr6, 0x82e0d494
	if ctx.cr[6].eq {
	pc = 0x82E0D494; continue 'dispatch;
	}
	// 82E0D490: 4B4B3401  bl 0x822c0890
	ctx.lr = 0x82E0D494;
	sub_822C0890(ctx, base);
	// 82E0D494: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0D498: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E0D49C: 4839AD0C  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0D4A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0D4A0 size=12
    let mut pc: u32 = 0x82E0D4A0;
    'dispatch: loop {
        match pc {
            0x82E0D4A0 => {
    //   block [0x82E0D4A0..0x82E0D4AC)
	// 82E0D4A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D4A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0D4A8: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0D4AC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0D4AC size=20
    let mut pc: u32 = 0x82E0D4AC;
    'dispatch: loop {
        match pc {
            0x82E0D4AC => {
    //   block [0x82E0D4AC..0x82E0D4C0)
	// 82E0D4AC: 89630028  lbz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E0D4B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E0D4B4: 4182000C  beq 0x82e0d4c0
	if ctx.cr[0].eq {
		sub_82E0D4C0(ctx, base);
		return;
	}
	// 82E0D4B8: 80830038  lwz r4, 0x38(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E0D4BC: 4BFFEED4  b 0x82e0c390
	sub_82E0C390(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0D4C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0D4C0 size=8
    let mut pc: u32 = 0x82E0D4C0;
    'dispatch: loop {
        match pc {
            0x82E0D4C0 => {
    //   block [0x82E0D4C0..0x82E0D4C8)
	// 82E0D4C0: 4BFFFB88  b 0x82e0d048
	sub_82E0D048(ctx, base);
	return;
	// 82E0D4C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0D4C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0D4C8 size=108
    let mut pc: u32 = 0x82E0D4C8;
    'dispatch: loop {
        match pc {
            0x82E0D4C8 => {
    //   block [0x82E0D4C8..0x82E0D534)
	// 82E0D4C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0D4CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0D4D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0D4D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0D4D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0D4DC: 48000024  b 0x82e0d500
	pc = 0x82E0D500; continue 'dispatch;
	// 82E0D4E0: 897F0028  lbz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E0D4E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0D4E8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E0D4EC: 41820010  beq 0x82e0d4fc
	if ctx.cr[0].eq {
	pc = 0x82E0D4FC; continue 'dispatch;
	}
	// 82E0D4F0: 809F0038  lwz r4, 0x38(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E0D4F4: 4BFFEE9D  bl 0x82e0c390
	ctx.lr = 0x82E0D4F8;
	sub_82E0C390(ctx, base);
	// 82E0D4F8: 48000008  b 0x82e0d500
	pc = 0x82E0D500; continue 'dispatch;
	// 82E0D4FC: 4BFFFB4D  bl 0x82e0d048
	ctx.lr = 0x82E0D500;
	sub_82E0D048(ctx, base);
	// 82E0D500: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0D504: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D508: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0D50C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0D510: 4E800421  bctrl
	ctx.lr = 0x82E0D514;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0D514: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E0D518: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E0D51C: 4182FFC4  beq 0x82e0d4e0
	if ctx.cr[0].eq {
	pc = 0x82E0D4E0; continue 'dispatch;
	}
	// 82E0D520: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E0D524: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0D528: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0D52C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E0D530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0D538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0D538 size=176
    let mut pc: u32 = 0x82E0D538;
    'dispatch: loop {
        match pc {
            0x82E0D538 => {
    //   block [0x82E0D538..0x82E0D5E8)
	// 82E0D538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0D53C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0D540: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E0D544: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0D548: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0D54C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0D550: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0D554: 3D4082E1  lis r10, -0x7d1f
	ctx.r[10].s64 = -2099183616;
	// 82E0D558: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82E0D55C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E0D560: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82E0D564: 394AD4C8  addi r10, r10, -0x2b38
	ctx.r[10].s64 = ctx.r[10].s64 + -11064;
	// 82E0D568: 997F0034  stb r11, 0x34(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u8 ) };
	// 82E0D56C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E0D570: 997F0048  stb r11, 0x48(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u8 ) };
	// 82E0D574: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82E0D578: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E0D57C: 4BFFF555  bl 0x82e0cad0
	ctx.lr = 0x82E0D580;
	sub_82E0CAD0(ctx, base);
	// 82E0D580: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E0D584: 38CBB908  addi r6, r11, -0x46f8
	ctx.r[6].s64 = ctx.r[11].s64 + -18168;
	// 82E0D588: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82E0D58C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E0D590: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0D594: 4BFECA5D  bl 0x82df9ff0
	ctx.lr = 0x82E0D598;
	sub_82DF9FF0(ctx, base);
	// 82E0D598: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E0D59C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82E0D5A0: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82E0D5A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D5A8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E0D5AC: 4B4B6EB5  bl 0x822c4460
	ctx.lr = 0x82E0D5B0;
	sub_822C4460(ctx, base);
	// 82E0D5B0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E0D5B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0D5B8: 419A0008  beq cr6, 0x82e0d5c0
	if ctx.cr[6].eq {
	pc = 0x82E0D5C0; continue 'dispatch;
	}
	// 82E0D5BC: 4B4B32D5  bl 0x822c0890
	ctx.lr = 0x82E0D5C0;
	sub_822C0890(ctx, base);
	// 82E0D5C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E0D5C4: 4B4BB6F5  bl 0x822c8cb8
	ctx.lr = 0x82E0D5C8;
	sub_822C8CB8(ctx, base);
	// 82E0D5C8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D5CC: 48290E6D  bl 0x8309e438
	ctx.lr = 0x82E0D5D0;
	sub_8309E438(ctx, base);
	// 82E0D5D0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E0D5D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0D5D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0D5DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E0D5E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E0D5E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0D5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0D5E8 size=172
    let mut pc: u32 = 0x82E0D5E8;
    'dispatch: loop {
        match pc {
            0x82E0D5E8 => {
    //   block [0x82E0D5E8..0x82E0D694)
	// 82E0D5E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0D5EC: 4839AB81  bl 0x831a816c
	ctx.lr = 0x82E0D5F0;
	sub_831A8130(ctx, base);
	// 82E0D5F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0D5F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E0D5F8: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E0D5FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0D600: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E0D604: 38C00031  li r6, 0x31
	ctx.r[6].s64 = 49;
	// 82E0D608: 38ABB918  addi r5, r11, -0x46e8
	ctx.r[5].s64 = ctx.r[11].s64 + -18152;
	// 82E0D60C: 389E000C  addi r4, r30, 0xc
	ctx.r[4].s64 = ctx.r[30].s64 + 12;
	// 82E0D610: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E0D614: 4BFEC225  bl 0x82df9838
	ctx.lr = 0x82E0D618;
	sub_82DF9838(ctx, base);
	// 82E0D618: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E0D61C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E0D620: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0D624: 4BFF19D5  bl 0x82dfeff8
	ctx.lr = 0x82E0D628;
	sub_82DFEFF8(ctx, base);
	// 82E0D628: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E0D62C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0D630: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E0D634: 419A0040  beq cr6, 0x82e0d674
	if ctx.cr[6].eq {
	pc = 0x82E0D674; continue 'dispatch;
	}
	// 82E0D638: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E0D63C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E0D640: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E0D644: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0D648: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E0D64C: 419A0034  beq cr6, 0x82e0d680
	if ctx.cr[6].eq {
	pc = 0x82E0D680; continue 'dispatch;
	}
	// 82E0D650: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E0D654: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E0D658: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0D65C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E0D660: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0D664: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0D668: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0D66C: 4082FFE8  bne 0x82e0d654
	if !ctx.cr[0].eq {
	pc = 0x82E0D654; continue 'dispatch;
	}
	// 82E0D670: 48000010  b 0x82e0d680
	pc = 0x82E0D680; continue 'dispatch;
	// 82E0D674: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0D678: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E0D67C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E0D680: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E0D684: 4B4C1F7D  bl 0x822cf600
	ctx.lr = 0x82E0D688;
	sub_822CF600(ctx, base);
	// 82E0D688: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0D68C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E0D690: 4839AB2C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0D698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0D698 size=80
    let mut pc: u32 = 0x82E0D698;
    'dispatch: loop {
        match pc {
            0x82E0D698 => {
    //   block [0x82E0D698..0x82E0D6E8)
	// 82E0D698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0D69C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0D6A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0D6A4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0D6A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0D6AC: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E0D6B0: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82E0D6B4: 38ABB918  addi r5, r11, -0x46e8
	ctx.r[5].s64 = ctx.r[11].s64 + -18152;
	// 82E0D6B8: 38C00052  li r6, 0x52
	ctx.r[6].s64 = 82;
	// 82E0D6BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0D6C0: 4BFEC179  bl 0x82df9838
	ctx.lr = 0x82E0D6C4;
	sub_82DF9838(ctx, base);
	// 82E0D6C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0D6C8: 4BFF27F9  bl 0x82dffec0
	ctx.lr = 0x82E0D6CC;
	sub_82DFFEC0(ctx, base);
	// 82E0D6CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0D6D0: 4B4C1F31  bl 0x822cf600
	ctx.lr = 0x82E0D6D4;
	sub_822CF600(ctx, base);
	// 82E0D6D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E0D6D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0D6DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0D6E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E0D6E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0D6E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0D6E8 size=116
    let mut pc: u32 = 0x82E0D6E8;
    'dispatch: loop {
        match pc {
            0x82E0D6E8 => {
    //   block [0x82E0D6E8..0x82E0D75C)
	// 82E0D6E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0D6EC: 4839AA81  bl 0x831a816c
	ctx.lr = 0x82E0D6F0;
	sub_831A8130(ctx, base);
	// 82E0D6F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0D6F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E0D6F8: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E0D6FC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E0D700: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82E0D704: 389E000C  addi r4, r30, 0xc
	ctx.r[4].s64 = ctx.r[30].s64 + 12;
	// 82E0D708: 38ABB918  addi r5, r11, -0x46e8
	ctx.r[5].s64 = ctx.r[11].s64 + -18152;
	// 82E0D70C: 38C00024  li r6, 0x24
	ctx.r[6].s64 = 36;
	// 82E0D710: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0D714: 4BFEC125  bl 0x82df9838
	ctx.lr = 0x82E0D718;
	sub_82DF9838(ctx, base);
	// 82E0D718: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E0D71C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E0D720: 48006A81  bl 0x82e141a0
	ctx.lr = 0x82E0D724;
	sub_82E141A0(ctx, base);
	// 82E0D724: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D728: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E0D72C: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 82E0D730: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82E0D734: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E0D738: 4B4B6D29  bl 0x822c4460
	ctx.lr = 0x82E0D73C;
	sub_822C4460(ctx, base);
	// 82E0D73C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0D740: 4B4C1EC1  bl 0x822cf600
	ctx.lr = 0x82E0D744;
	sub_822CF600(ctx, base);
	// 82E0D744: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0D748: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0D74C: 419A0008  beq cr6, 0x82e0d754
	if ctx.cr[6].eq {
	pc = 0x82E0D754; continue 'dispatch;
	}
	// 82E0D750: 4B4B3141  bl 0x822c0890
	ctx.lr = 0x82E0D754;
	sub_822C0890(ctx, base);
	// 82E0D754: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E0D758: 4839AA64  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0D760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0D760 size=100
    let mut pc: u32 = 0x82E0D760;
    'dispatch: loop {
        match pc {
            0x82E0D760 => {
    //   block [0x82E0D760..0x82E0D7C4)
	// 82E0D760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0D764: 4839AA09  bl 0x831a816c
	ctx.lr = 0x82E0D768;
	sub_831A8130(ctx, base);
	// 82E0D768: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0D76C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0D770: 482B5BA9  bl 0x830c3318
	ctx.lr = 0x82E0D774;
	sub_830C3318(ctx, base);
	// 82E0D774: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E0D778: 806B16D4  lwz r3, 0x16d4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5844 as u32) ) } as u64;
	// 82E0D77C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D780: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D784: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0D788: 4E800421  bctrl
	ctx.lr = 0x82E0D78C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0D78C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E0D790: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 82E0D794: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82E0D798: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E0D79C: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 82E0D7A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E0D7A4: 4B4C1D3D  bl 0x822cf4e0
	ctx.lr = 0x82E0D7A8;
	sub_822CF4E0(ctx, base);
	// 82E0D7A8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E0D7AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E0D7B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E0D7B4: 4B4B284D  bl 0x822c0000
	ctx.lr = 0x82E0D7B8;
	sub_822C0000(ctx, base);
	// 82E0D7B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0D7BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E0D7C0: 4839A9FC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0D7C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0D7C8 size=20
    let mut pc: u32 = 0x82E0D7C8;
    'dispatch: loop {
        match pc {
            0x82E0D7C8 => {
    //   block [0x82E0D7C8..0x82E0D7DC)
	// 82E0D7C8: 80630020  lwz r3, 0x20(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E0D7CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D7D0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0D7D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0D7D8: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0D7E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0D7E0 size=20
    let mut pc: u32 = 0x82E0D7E0;
    'dispatch: loop {
        match pc {
            0x82E0D7E0 => {
    //   block [0x82E0D7E0..0x82E0D7F4)
	// 82E0D7E0: 80630020  lwz r3, 0x20(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E0D7E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D7E8: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E0D7EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0D7F0: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0D7F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0D7F8 size=156
    let mut pc: u32 = 0x82E0D7F8;
    'dispatch: loop {
        match pc {
            0x82E0D7F8 => {
    //   block [0x82E0D7F8..0x82E0D894)
	// 82E0D7F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0D7FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0D800: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0D804: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0D808: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0D80C: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E0D810: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D814: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E0D818: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0D81C: 4E800421  bctrl
	ctx.lr = 0x82E0D820;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0D820: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0D824: 4082005C  bne 0x82e0d880
	if !ctx.cr[0].eq {
	pc = 0x82E0D880; continue 'dispatch;
	}
	// 82E0D828: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E0D82C: 38C000A3  li r6, 0xa3
	ctx.r[6].s64 = 163;
	// 82E0D830: 38ABB95C  addi r5, r11, -0x46a4
	ctx.r[5].s64 = ctx.r[11].s64 + -18084;
	// 82E0D834: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 82E0D838: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0D83C: 4BFEBFFD  bl 0x82df9838
	ctx.lr = 0x82E0D840;
	sub_82DF9838(ctx, base);
	// 82E0D840: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E0D844: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E0D848: 997F0030  stb r11, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u8 ) };
	// 82E0D84C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D850: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0D854: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0D858: 4E800421  bctrl
	ctx.lr = 0x82E0D85C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0D85C: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E0D860: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82E0D864: 419A0014  beq cr6, 0x82e0d878
	if ctx.cr[6].eq {
	pc = 0x82E0D878; continue 'dispatch;
	}
	// 82E0D868: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D86C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0D870: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0D874: 4E800421  bctrl
	ctx.lr = 0x82E0D878;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0D878: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0D87C: 4B4C1D85  bl 0x822cf600
	ctx.lr = 0x82E0D880;
	sub_822CF600(ctx, base);
	// 82E0D880: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E0D884: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0D888: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0D88C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E0D890: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0D898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0D898 size=216
    let mut pc: u32 = 0x82E0D898;
    'dispatch: loop {
        match pc {
            0x82E0D898 => {
    //   block [0x82E0D898..0x82E0D970)
	// 82E0D898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0D89C: 4839A8C1  bl 0x831a815c
	ctx.lr = 0x82E0D8A0;
	sub_831A8130(ctx, base);
	// 82E0D8A0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0D8A4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E0D8A8: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82E0D8AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0D8B0: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82E0D8B4: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82E0D8B8: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82E0D8BC: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 82E0D8C0: 4BFE6341  bl 0x82df3c00
	ctx.lr = 0x82E0D8C4;
	sub_82DF3C00(ctx, base);
	// 82E0D8C4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82E0D8C8: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 82E0D8CC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D8D0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E0D8D4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0D8D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0D8DC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E0D8E0: 419A0024  beq cr6, 0x82e0d904
	if ctx.cr[6].eq {
	pc = 0x82E0D904; continue 'dispatch;
	}
	// 82E0D8E4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E0D8E8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E0D8EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0D8F0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E0D8F4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0D8F8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0D8FC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0D900: 4082FFE8  bne 0x82e0d8e8
	if !ctx.cr[0].eq {
	pc = 0x82E0D8E8; continue 'dispatch;
	}
	// 82E0D904: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D908: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 82E0D90C: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82E0D910: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0D914: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0D918: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82E0D91C: 419A0024  beq cr6, 0x82e0d940
	if ctx.cr[6].eq {
	pc = 0x82E0D940; continue 'dispatch;
	}
	// 82E0D920: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E0D924: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E0D928: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0D92C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E0D930: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0D934: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0D938: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0D93C: 4082FFE8  bne 0x82e0d924
	if !ctx.cr[0].eq {
	pc = 0x82E0D924; continue 'dispatch;
	}
	// 82E0D940: 937F0014  stw r27, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[27].u32 ) };
	// 82E0D944: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82E0D948: 935F0018  stw r26, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[26].u32 ) };
	// 82E0D94C: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 82E0D950: 4BFF5A41  bl 0x82e03390
	ctx.lr = 0x82E0D954;
	sub_82E03390(ctx, base);
	// 82E0D954: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0D958: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0D95C: 419A0008  beq cr6, 0x82e0d964
	if ctx.cr[6].eq {
	pc = 0x82E0D964; continue 'dispatch;
	}
	// 82E0D960: 4B4B2F31  bl 0x822c0890
	ctx.lr = 0x82E0D964;
	sub_822C0890(ctx, base);
	// 82E0D964: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0D968: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E0D96C: 4839A840  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0D970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0D970 size=208
    let mut pc: u32 = 0x82E0D970;
    'dispatch: loop {
        match pc {
            0x82E0D970 => {
    //   block [0x82E0D970..0x82E0DA40)
	// 82E0D970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0D974: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0D978: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E0D97C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0D980: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0D984: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0D988: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E0D98C: 4BFE6275  bl 0x82df3c00
	ctx.lr = 0x82E0D990;
	sub_82DF3C00(ctx, base);
	// 82E0D990: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82E0D994: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0D998: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E0D99C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0D9A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0D9A4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E0D9A8: 419A0024  beq cr6, 0x82e0d9cc
	if ctx.cr[6].eq {
	pc = 0x82E0D9CC; continue 'dispatch;
	}
	// 82E0D9AC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E0D9B0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E0D9B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0D9B8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E0D9BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0D9C0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0D9C4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0D9C8: 4082FFE8  bne 0x82e0d9b0
	if !ctx.cr[0].eq {
	pc = 0x82E0D9B0; continue 'dispatch;
	}
	// 82E0D9CC: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0D9D0: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 82E0D9D4: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82E0D9D8: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E0D9DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0D9E0: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82E0D9E4: 419A0024  beq cr6, 0x82e0da08
	if ctx.cr[6].eq {
	pc = 0x82E0DA08; continue 'dispatch;
	}
	// 82E0D9E8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E0D9EC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E0D9F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0D9F4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E0D9F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0D9FC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0DA00: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0DA04: 4082FFE8  bne 0x82e0d9ec
	if !ctx.cr[0].eq {
	pc = 0x82E0D9EC; continue 'dispatch;
	}
	// 82E0DA08: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E0DA0C: 389E0020  addi r4, r30, 0x20
	ctx.r[4].s64 = ctx.r[30].s64 + 32;
	// 82E0DA10: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 82E0DA14: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82E0DA18: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E0DA1C: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82E0DA20: 4BFF5971  bl 0x82e03390
	ctx.lr = 0x82E0DA24;
	sub_82E03390(ctx, base);
	// 82E0DA24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0DA28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E0DA2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0DA30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0DA34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E0DA38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E0DA3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0DA40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0DA40 size=480
    let mut pc: u32 = 0x82E0DA40;
    'dispatch: loop {
        match pc {
            0x82E0DA40 => {
    //   block [0x82E0DA40..0x82E0DC20)
	// 82E0DA40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0DA44: 4839A719  bl 0x831a815c
	ctx.lr = 0x82E0DA48;
	sub_831A8130(ctx, base);
	// 82E0DA48: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0DA4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E0DA50: 3D600164  lis r11, 0x164
	ctx.r[11].s64 = 23330816;
	// 82E0DA54: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82E0DA58: 617F2C85  ori r31, r11, 0x2c85
	ctx.r[31].u64 = ctx.r[11].u64 | 11397;
	// 82E0DA5C: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0DA60: 7D6AF850  subf r11, r10, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82E0DA64: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82E0DA68: 40980008  bge cr6, 0x82e0da70
	if !ctx.cr[6].lt {
	pc = 0x82E0DA70; continue 'dispatch;
	}
	// 82E0DA6C: 4BFFB465  bl 0x82e08ed0
	ctx.lr = 0x82E0DA70;
	sub_82E08ED0(ctx, base);
	// 82E0DA70: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0DA74: 556AF87E  srwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E0DA78: 2B0A0008  cmplwi cr6, r10, 8
	ctx.cr[6].compare_u32(ctx.r[10].u32, 8 as u32, &mut ctx.xer);
	// 82E0DA7C: 40980008  bge cr6, 0x82e0da84
	if !ctx.cr[6].lt {
	pc = 0x82E0DA84; continue 'dispatch;
	}
	// 82E0DA80: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 82E0DA84: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E0DA88: 40980014  bge cr6, 0x82e0da9c
	if !ctx.cr[6].lt {
	pc = 0x82E0DA9C; continue 'dispatch;
	}
	// 82E0DA8C: 7D2AF850  subf r9, r10, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82E0DA90: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E0DA94: 41990008  bgt cr6, 0x82e0da9c
	if ctx.cr[6].gt {
	pc = 0x82E0DA9C; continue 'dispatch;
	}
	// 82E0DA98: 7D5A5378  mr r26, r10
	ctx.r[26].u64 = ctx.r[10].u64;
	// 82E0DA9C: 3F208335  lis r25, -0x7ccb
	ctx.r[25].s64 = -2093678592;
	// 82E0DAA0: 83BE000C  lwz r29, 0xc(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0DAA4: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82E0DAA8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E0DAAC: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82E0DAB0: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 82E0DAB4: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 82E0DAB8: 8079110C  lwz r3, 0x110c(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E0DABC: 4BFE460D  bl 0x82df20c8
	ctx.lr = 0x82E0DAC0;
	sub_82DF20C8(ctx, base);
	// 82E0DAC0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0DAC4: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0DAC8: 57BF103A  slwi r31, r29, 2
	ctx.r[31].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82E0DACC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82E0DAD0: 7CABFA14  add r5, r11, r31
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82E0DAD4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E0DAD8: 7C7FDA14  add r3, r31, r27
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[27].u64;
	// 82E0DADC: 7D455050  subf r10, r5, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[5].s64;
	// 82E0DAE0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82E0DAE4: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0DAE8: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82E0DAEC: 7F861A14  add r28, r6, r3
	ctx.r[28].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 82E0DAF0: 4182000C  beq 0x82e0dafc
	if ctx.cr[0].eq {
	pc = 0x82E0DAFC; continue 'dispatch;
	}
	// 82E0DAF4: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82E0DAF8: 4839B211  bl 0x831a8d08
	ctx.lr = 0x82E0DAFC;
	sub_831A8D08(ctx, base);
	// 82E0DAFC: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0DB00: 7F1DD040  cmplw cr6, r29, r26
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82E0DB04: 4199007C  bgt cr6, 0x82e0db80
	if ctx.cr[6].gt {
	pc = 0x82E0DB80; continue 'dispatch;
	}
	// 82E0DB08: 7D652850  subf r11, r5, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[5].s64;
	// 82E0DB0C: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82E0DB10: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0DB14: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82E0DB18: 7FE6E214  add r31, r6, r28
	ctx.r[31].u64 = ctx.r[6].u64 + ctx.r[28].u64;
	// 82E0DB1C: 41820010  beq 0x82e0db2c
	if ctx.cr[0].eq {
	pc = 0x82E0DB2C; continue 'dispatch;
	}
	// 82E0DB20: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82E0DB24: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E0DB28: 4839B1E1  bl 0x831a8d08
	ctx.lr = 0x82E0DB2C;
	sub_831A8D08(ctx, base);
	// 82E0DB2C: 7D7DD051  subf. r11, r29, r26
	ctx.r[11].s64 = ctx.r[26].s64 - ctx.r[29].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0DB30: 41820024  beq 0x82e0db54
	if ctx.cr[0].eq {
	pc = 0x82E0DB54; continue 'dispatch;
	}
	// 82E0DB34: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82E0DB38: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82E0DB3C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E0DB40: 41820014  beq 0x82e0db54
	if ctx.cr[0].eq {
	pc = 0x82E0DB54; continue 'dispatch;
	}
	// 82E0DB44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0DB48: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E0DB4C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82E0DB50: 4200FFF8  bdnz 0x82e0db48
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E0DB48; continue 'dispatch;
	}
	// 82E0DB54: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82E0DB58: 419A009C  beq cr6, 0x82e0dbf4
	if ctx.cr[6].eq {
	pc = 0x82E0DBF4; continue 'dispatch;
	}
	// 82E0DB5C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82E0DB60: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E0DB64: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E0DB68: 4182008C  beq 0x82e0dbf4
	if ctx.cr[0].eq {
	pc = 0x82E0DBF4; continue 'dispatch;
	}
	// 82E0DB6C: 7FA903A6  mtctr r29
	ctx.ctr.u64 = ctx.r[29].u64;
	// 82E0DB70: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E0DB74: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E0DB78: 4200FFF8  bdnz 0x82e0db70
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E0DB70; continue 'dispatch;
	}
	// 82E0DB7C: 48000078  b 0x82e0dbf4
	pc = 0x82E0DBF4; continue 'dispatch;
	// 82E0DB80: 575D103A  slwi r29, r26, 2
	ctx.r[29].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 82E0DB84: 7D65E850  subf r11, r5, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[5].s64;
	// 82E0DB88: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 82E0DB8C: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0DB90: 41820014  beq 0x82e0dba4
	if ctx.cr[0].eq {
	pc = 0x82E0DBA4; continue 'dispatch;
	}
	// 82E0DB94: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82E0DB98: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E0DB9C: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82E0DBA0: 4839B169  bl 0x831a8d08
	ctx.lr = 0x82E0DBA4;
	sub_831A8D08(ctx, base);
	// 82E0DBA4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0DBA8: 7CBD5A14  add r5, r29, r11
	ctx.r[5].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82E0DBAC: 7D655850  subf r11, r5, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	// 82E0DBB0: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82E0DBB4: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0DBB8: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82E0DBBC: 7FE6DA14  add r31, r6, r27
	ctx.r[31].u64 = ctx.r[6].u64 + ctx.r[27].u64;
	// 82E0DBC0: 41820010  beq 0x82e0dbd0
	if ctx.cr[0].eq {
	pc = 0x82E0DBD0; continue 'dispatch;
	}
	// 82E0DBC4: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82E0DBC8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E0DBCC: 4839B13D  bl 0x831a8d08
	ctx.lr = 0x82E0DBD0;
	sub_831A8D08(ctx, base);
	// 82E0DBD0: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82E0DBD4: 419A0020  beq cr6, 0x82e0dbf4
	if ctx.cr[6].eq {
	pc = 0x82E0DBF4; continue 'dispatch;
	}
	// 82E0DBD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0DBDC: 281A0000  cmplwi r26, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E0DBE0: 41820014  beq 0x82e0dbf4
	if ctx.cr[0].eq {
	pc = 0x82E0DBF4; continue 'dispatch;
	}
	// 82E0DBE4: 7F4903A6  mtctr r26
	ctx.ctr.u64 = ctx.r[26].u64;
	// 82E0DBE8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E0DBEC: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82E0DBF0: 4200FFF8  bdnz 0x82e0dbe8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E0DBE8; continue 'dispatch;
	}
	// 82E0DBF4: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0DBF8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82E0DBFC: 419A000C  beq cr6, 0x82e0dc08
	if ctx.cr[6].eq {
	pc = 0x82E0DC08; continue 'dispatch;
	}
	// 82E0DC00: 8079110C  lwz r3, 0x110c(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E0DC04: 4BFE4585  bl 0x82df2188
	ctx.lr = 0x82E0DC08;
	sub_82DF2188(ctx, base);
	// 82E0DC08: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0DC0C: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82E0DC10: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82E0DC14: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E0DC18: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E0DC1C: 4839A590  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0DC20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0DC20 size=176
    let mut pc: u32 = 0x82E0DC20;
    'dispatch: loop {
        match pc {
            0x82E0DC20 => {
    //   block [0x82E0DC20..0x82E0DCD0)
	// 82E0DC20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0DC24: 4839A549  bl 0x831a816c
	ctx.lr = 0x82E0DC28;
	sub_831A8130(ctx, base);
	// 82E0DC28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0DC2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0DC30: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E0DC34: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E0DC38: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0DC3C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E0DC40: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E0DC44: 4199000C  bgt cr6, 0x82e0dc50
	if ctx.cr[6].gt {
	pc = 0x82E0DC50; continue 'dispatch;
	}
	// 82E0DC48: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E0DC4C: 4BFFFDF5  bl 0x82e0da40
	ctx.lr = 0x82E0DC50;
	sub_82E0DA40(ctx, base);
	// 82E0DC50: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0DC54: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E0DC58: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0DC5C: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82E0DC60: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E0DC64: 41990008  bgt cr6, 0x82e0dc6c
	if ctx.cr[6].gt {
	pc = 0x82E0DC6C; continue 'dispatch;
	}
	// 82E0DC68: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82E0DC6C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0DC70: 557E103A  slwi r30, r11, 2
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82E0DC74: 7D6AF02E  lwzx r11, r10, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82E0DC78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0DC7C: 409A0028  bne cr6, 0x82e0dca4
	if !ctx.cr[6].eq {
	pc = 0x82E0DCA4; continue 'dispatch;
	}
	// 82E0DC80: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E0DC84: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E0DC88: 38C000B8  li r6, 0xb8
	ctx.r[6].s64 = 184;
	// 82E0DC8C: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 82E0DC90: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 82E0DC94: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E0DC98: 4BFE4431  bl 0x82df20c8
	ctx.lr = 0x82E0DC9C;
	sub_82DF20C8(ctx, base);
	// 82E0DC9C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0DCA0: 7C6BF12E  stwx r3, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[3].u32) };
	// 82E0DCA4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0DCA8: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82E0DCAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0DCB0: 419A000C  beq cr6, 0x82e0dcbc
	if ctx.cr[6].eq {
	pc = 0x82E0DCBC; continue 'dispatch;
	}
	// 82E0DCB4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E0DCB8: 4BFFFCB9  bl 0x82e0d970
	ctx.lr = 0x82E0DCBC;
	sub_82E0D970(ctx, base);
	// 82E0DCBC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E0DCC0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E0DCC4: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82E0DCC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E0DCCC: 4839A4F0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0DCD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0DCD0 size=400
    let mut pc: u32 = 0x82E0DCD0;
    'dispatch: loop {
        match pc {
            0x82E0DCD0 => {
    //   block [0x82E0DCD0..0x82E0DE60)
	// 82E0DCD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0DCD4: 4839A489  bl 0x831a815c
	ctx.lr = 0x82E0DCD8;
	sub_831A8130(ctx, base);
	// 82E0DCD8: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0DCDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0DCE0: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E0DCE4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82E0DCE8: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82E0DCEC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82E0DCF0: 38C0003F  li r6, 0x3f
	ctx.r[6].s64 = 63;
	// 82E0DCF4: 38ABB95C  addi r5, r11, -0x46a4
	ctx.r[5].s64 = ctx.r[11].s64 + -18084;
	// 82E0DCF8: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 82E0DCFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0DD00: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82E0DD04: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 82E0DD08: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 82E0DD0C: 4BFEBB2D  bl 0x82df9838
	ctx.lr = 0x82E0DD10;
	sub_82DF9838(ctx, base);
	// 82E0DD10: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E0DD14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0DD18: 419A004C  beq cr6, 0x82e0dd64
	if ctx.cr[6].eq {
	pc = 0x82E0DD64; continue 'dispatch;
	}
	// 82E0DD1C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E0DD20: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0DD24: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E0DD28: 41990008  bgt cr6, 0x82e0dd30
	if ctx.cr[6].gt {
	pc = 0x82E0DD30; continue 'dispatch;
	}
	// 82E0DD2C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82E0DD30: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0DD34: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E0DD38: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E0DD3C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0DD40: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E0DD44: 419A0020  beq cr6, 0x82e0dd64
	if ctx.cr[6].eq {
	pc = 0x82E0DD64; continue 'dispatch;
	}
	// 82E0DD48: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0DD4C: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82E0DD50: 409A0014  bne cr6, 0x82e0dd64
	if !ctx.cr[6].eq {
	pc = 0x82E0DD64; continue 'dispatch;
	}
	// 82E0DD54: 938B0014  stw r28, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[28].u32 ) };
	// 82E0DD58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0DD5C: 4B4C18A5  bl 0x822cf600
	ctx.lr = 0x82E0DD60;
	sub_822CF600(ctx, base);
	// 82E0DD60: 480000E8  b 0x82e0de48
	pc = 0x82E0DE48; continue 'dispatch;
	// 82E0DD64: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0DD68: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0DD6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0DD70: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E0DD74: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82E0DD78: 419A0024  beq cr6, 0x82e0dd9c
	if ctx.cr[6].eq {
	pc = 0x82E0DD9C; continue 'dispatch;
	}
	// 82E0DD7C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E0DD80: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E0DD84: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0DD88: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E0DD8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0DD90: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0DD94: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0DD98: 4082FFE8  bne 0x82e0dd80
	if !ctx.cr[0].eq {
	pc = 0x82E0DD80; continue 'dispatch;
	}
	// 82E0DD9C: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 82E0DDA0: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82E0DDA4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82E0DDA8: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82E0DDAC: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82E0DDB0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E0DDB4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E0DDB8: 4BFFFAE1  bl 0x82e0d898
	ctx.lr = 0x82E0DDBC;
	sub_82E0D898(ctx, base);
	// 82E0DDBC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E0DDC0: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82E0DDC4: 4BFFFE5D  bl 0x82e0dc20
	ctx.lr = 0x82E0DDC8;
	sub_82E0DC20(ctx, base);
	// 82E0DDC8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E0DDCC: 4BFF5555  bl 0x82e03320
	ctx.lr = 0x82E0DDD0;
	sub_82E03320(ctx, base);
	// 82E0DDD0: 397F0038  addi r11, r31, 0x38
	ctx.r[11].s64 = ctx.r[31].s64 + 56;
	// 82E0DDD4: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82E0DDD8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0DDDC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E0DDE0: 7D3E5214  add r9, r30, r10
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 82E0DDE4: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0DDE8: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0DDEC: 4082FFE8  bne 0x82e0ddd4
	if !ctx.cr[0].eq {
	pc = 0x82E0DDD4; continue 'dispatch;
	}
	// 82E0DDF0: 397F0034  addi r11, r31, 0x34
	ctx.r[11].s64 = ctx.r[31].s64 + 52;
	// 82E0DDF4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E0DDF8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0DDFC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E0DE00: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0DE04: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0DE08: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0DE0C: 4082FFE8  bne 0x82e0ddf4
	if !ctx.cr[0].eq {
	pc = 0x82E0DDF4; continue 'dispatch;
	}
	// 82E0DE10: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E0DE14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0DE18: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0DE1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0DE20: 4E800421  bctrl
	ctx.lr = 0x82E0DE24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0DE24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0DE28: 4B4C17D9  bl 0x822cf600
	ctx.lr = 0x82E0DE2C;
	sub_822CF600(ctx, base);
	// 82E0DE2C: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E0DE30: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82E0DE34: 419A0014  beq cr6, 0x82e0de48
	if ctx.cr[6].eq {
	pc = 0x82E0DE48; continue 'dispatch;
	}
	// 82E0DE38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0DE3C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0DE40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0DE44: 4E800421  bctrl
	ctx.lr = 0x82E0DE48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0DE48: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0DE4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0DE50: 419A0008  beq cr6, 0x82e0de58
	if ctx.cr[6].eq {
	pc = 0x82E0DE58; continue 'dispatch;
	}
	// 82E0DE54: 4B4B2A3D  bl 0x822c0890
	ctx.lr = 0x82E0DE58;
	sub_822C0890(ctx, base);
	// 82E0DE58: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 82E0DE5C: 4839A350  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0DE60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0DE60 size=316
    let mut pc: u32 = 0x82E0DE60;
    'dispatch: loop {
        match pc {
            0x82E0DE60 => {
    //   block [0x82E0DE60..0x82E0DF9C)
	// 82E0DE60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0DE64: 4839A2FD  bl 0x831a8160
	ctx.lr = 0x82E0DE68;
	sub_831A8130(ctx, base);
	// 82E0DE68: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0DE6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0DE70: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E0DE74: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82E0DE78: 396BB57C  addi r11, r11, -0x4a84
	ctx.r[11].s64 = ctx.r[11].s64 + -19076;
	// 82E0DE7C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E0DE80: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E0DE84: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82E0DE88: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82E0DE8C: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82E0DE90: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82E0DE94: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82E0DE98: 806A16D4  lwz r3, 0x16d4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(5844 as u32) ) } as u64;
	// 82E0DE9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0DEA0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0DEA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0DEA8: 4E800421  bctrl
	ctx.lr = 0x82E0DEAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0DEAC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82E0DEB0: 397F0018  addi r11, r31, 0x18
	ctx.r[11].s64 = ctx.r[31].s64 + 24;
	// 82E0DEB4: 939F0018  stw r28, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[28].u32 ) };
	// 82E0DEB8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E0DEBC: 3BAB0004  addi r29, r11, 4
	ctx.r[29].s64 = ctx.r[11].s64 + 4;
	// 82E0DEC0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E0DEC4: 4B4C161D  bl 0x822cf4e0
	ctx.lr = 0x82E0DEC8;
	sub_822CF4E0(ctx, base);
	// 82E0DEC8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82E0DECC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E0DED0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E0DED4: 4B4B212D  bl 0x822c0000
	ctx.lr = 0x82E0DED8;
	sub_822C0000(ctx, base);
	// 82E0DED8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82E0DEDC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E0DEE0: 806B5F9C  lwz r3, 0x5f9c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24476 as u32) ) } as u64;
	// 82E0DEE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0DEE8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0DEEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0DEF0: 4E800421  bctrl
	ctx.lr = 0x82E0DEF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0DEF4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82E0DEF8: 3BBF0020  addi r29, r31, 0x20
	ctx.r[29].s64 = ctx.r[31].s64 + 32;
	// 82E0DEFC: 935F0020  stw r26, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[26].u32 ) };
	// 82E0DF00: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E0DF04: 3B9D0004  addi r28, r29, 4
	ctx.r[28].s64 = ctx.r[29].s64 + 4;
	// 82E0DF08: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E0DF0C: 4BFEBAD5  bl 0x82df99e0
	ctx.lr = 0x82E0DF10;
	sub_82DF99E0(ctx, base);
	// 82E0DF10: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82E0DF14: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E0DF18: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E0DF1C: 4B4B20E5  bl 0x822c0000
	ctx.lr = 0x82E0DF20;
	sub_822C0000(ctx, base);
	// 82E0DF20: 397F0028  addi r11, r31, 0x28
	ctx.r[11].s64 = ctx.r[31].s64 + 40;
	// 82E0DF24: 3B9B0004  addi r28, r27, 4
	ctx.r[28].s64 = ctx.r[27].s64 + 4;
	// 82E0DF28: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0DF2C: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82E0DF30: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0DF34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0DF38: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82E0DF3C: 419A0024  beq cr6, 0x82e0df60
	if ctx.cr[6].eq {
	pc = 0x82E0DF60; continue 'dispatch;
	}
	// 82E0DF40: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E0DF44: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E0DF48: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0DF4C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E0DF50: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0DF54: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0DF58: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0DF5C: 4082FFE8  bne 0x82e0df44
	if !ctx.cr[0].eq {
	pc = 0x82E0DF44; continue 'dispatch;
	}
	// 82E0DF60: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0DF64: 9BDF0030  stb r30, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u8 ) };
	// 82E0DF68: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 82E0DF6C: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 82E0DF70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0DF74: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0DF78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0DF7C: 4E800421  bctrl
	ctx.lr = 0x82E0DF80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0DF80: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0DF84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0DF88: 419A0008  beq cr6, 0x82e0df90
	if ctx.cr[6].eq {
	pc = 0x82E0DF90; continue 'dispatch;
	}
	// 82E0DF8C: 4B4B2905  bl 0x822c0890
	ctx.lr = 0x82E0DF90;
	sub_822C0890(ctx, base);
	// 82E0DF90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0DF94: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E0DF98: 4839A218  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0DFA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0DFA0 size=976
    let mut pc: u32 = 0x82E0DFA0;
    'dispatch: loop {
        match pc {
            0x82E0DFA0 => {
    //   block [0x82E0DFA0..0x82E0E370)
	// 82E0DFA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0DFA4: 4839A1C1  bl 0x831a8164
	ctx.lr = 0x82E0DFA8;
	sub_831A8130(ctx, base);
	// 82E0DFA8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0DFAC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E0DFB0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E0DFB4: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82E0DFB8: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E0DFBC: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 82E0DFC0: 3BBE0018  addi r29, r30, 0x18
	ctx.r[29].s64 = ctx.r[30].s64 + 24;
	// 82E0DFC4: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 82E0DFC8: 3B8BB95C  addi r28, r11, -0x46a4
	ctx.r[28].s64 = ctx.r[11].s64 + -18084;
	// 82E0DFCC: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 82E0DFD0: 38C00062  li r6, 0x62
	ctx.r[6].s64 = 98;
	// 82E0DFD4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82E0DFD8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E0DFDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0DFE0: 4BFEB859  bl 0x82df9838
	ctx.lr = 0x82E0DFE4;
	sub_82DF9838(ctx, base);
	// 82E0DFE4: 897E0030  lbz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E0DFE8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E0DFEC: 41820018  beq 0x82e0e004
	if ctx.cr[0].eq {
	pc = 0x82E0E004; continue 'dispatch;
	}
	// 82E0DFF0: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82E0DFF4: 4BFF5B95  bl 0x82e03b88
	ctx.lr = 0x82E0DFF8;
	sub_82E03B88(ctx, base);
	// 82E0DFF8: 9BFE0030  stb r31, 0x30(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[31].u8 ) };
	// 82E0DFFC: 93FE0034  stw r31, 0x34(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), ctx.r[31].u32 ) };
	// 82E0E000: 93FE0038  stw r31, 0x38(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[31].u32 ) };
	// 82E0E004: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E0E008: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0E00C: 409A0020  bne cr6, 0x82e0e02c
	if !ctx.cr[6].eq {
	pc = 0x82E0E02C; continue 'dispatch;
	}
	// 82E0E010: 807E0020  lwz r3, 0x20(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E0E014: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E018: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0E01C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0E020: 4E800421  bctrl
	ctx.lr = 0x82E0E024;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0E024: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0E028: 48000334  b 0x82e0e35c
	pc = 0x82E0E35C; continue 'dispatch;
	// 82E0E02C: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E0E030: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82E0E034: 81210068  lwz r9, 0x68(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82E0E038: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0E03C: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82E0E040: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0E044: 80E10070  lwz r7, 0x70(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82E0E048: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E0E04C: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0E050: 913E000C  stw r9, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82E0E054: 813E0010  lwz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E0E058: 917E0010  stw r11, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82E0E05C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E0E060: 91010064  stw r8, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 82E0E064: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82E0E068: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 82E0E06C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82E0E070: 90FE0014  stw r7, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 82E0E074: 4B4C158D  bl 0x822cf600
	ctx.lr = 0x82E0E078;
	sub_822CF600(ctx, base);
	// 82E0E078: 83E1006C  lwz r31, 0x6c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82E0E07C: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82E0E080: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82E0E084: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E0E088: 7D7F5850  subf r11, r31, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 82E0E08C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82E0E090: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0E094: 40820290  bne 0x82e0e324
	if !ctx.cr[0].eq {
	pc = 0x82E0E324; continue 'dispatch;
	}
	// 82E0E098: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82E0E09C: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82E0E0A0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82E0E0A4: 41990008  bgt cr6, 0x82e0e0ac
	if ctx.cr[6].gt {
	pc = 0x82E0E0AC; continue 'dispatch;
	}
	// 82E0E0A8: 7D2BF850  subf r9, r11, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82E0E0AC: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82E0E0B0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82E0E0B4: 41990008  bgt cr6, 0x82e0e0bc
	if ctx.cr[6].gt {
	pc = 0x82E0E0BC; continue 'dispatch;
	}
	// 82E0E0B8: 7D4BF850  subf r10, r11, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82E0E0BC: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82E0E0C0: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E0E0C4: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E0E0C8: 7D08502E  lwzx r8, r8, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E0E0CC: 7D29502E  lwzx r9, r9, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E0E0D0: 81080018  lwz r8, 0x18(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E0E0D4: 81290014  lwz r9, 0x14(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E0E0D8: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82E0E0DC: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82E0E0E0: 419800E0  blt cr6, 0x82e0e1c0
	if ctx.cr[6].lt {
	pc = 0x82E0E1C0; continue 'dispatch;
	}
	// 82E0E0E4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82E0E0E8: 41990008  bgt cr6, 0x82e0e0f0
	if ctx.cr[6].gt {
	pc = 0x82E0E0F0; continue 'dispatch;
	}
	// 82E0E0EC: 7D2BF850  subf r9, r11, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82E0E0F0: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82E0E0F4: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82E0E0F8: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82E0E0FC: 7CC8502E  lwzx r6, r8, r10
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E0E100: 41990008  bgt cr6, 0x82e0e108
	if ctx.cr[6].gt {
	pc = 0x82E0E108; continue 'dispatch;
	}
	// 82E0E104: 7D2BF850  subf r9, r11, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82E0E108: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82E0E10C: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82E0E110: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82E0E114: 7CE8502E  lwzx r7, r8, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E0E118: 41990008  bgt cr6, 0x82e0e120
	if ctx.cr[6].gt {
	pc = 0x82E0E120; continue 'dispatch;
	}
	// 82E0E11C: 7D2BF850  subf r9, r11, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82E0E120: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E0E124: 7D29502E  lwzx r9, r9, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E0E128: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0E12C: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82E0E130: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0E134: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E0E138: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82E0E13C: 419A002C  beq cr6, 0x82e0e168
	if ctx.cr[6].eq {
	pc = 0x82E0E168; continue 'dispatch;
	}
	// 82E0E140: 39690004  addi r11, r9, 4
	ctx.r[11].s64 = ctx.r[9].s64 + 4;
	// 82E0E144: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E0E148: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0E14C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E0E150: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0E154: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0E158: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0E15C: 4082FFE8  bne 0x82e0e144
	if !ctx.cr[0].eq {
	pc = 0x82E0E144; continue 'dispatch;
	}
	// 82E0E160: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82E0E164: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E0E168: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 82E0E16C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82E0E170: 41990008  bgt cr6, 0x82e0e178
	if ctx.cr[6].gt {
	pc = 0x82E0E178; continue 'dispatch;
	}
	// 82E0E174: 7D0BF850  subf r8, r11, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82E0E178: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82E0E17C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82E0E180: 41990008  bgt cr6, 0x82e0e188
	if ctx.cr[6].gt {
	pc = 0x82E0E188; continue 'dispatch;
	}
	// 82E0E184: 7D2BF850  subf r9, r11, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82E0E188: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E0E18C: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E190: 5505103A  slwi r5, r8, 2
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82E0E194: 80E70018  lwz r7, 0x18(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E0E198: 39060020  addi r8, r6, 0x20
	ctx.r[8].s64 = ctx.r[6].s64 + 32;
	// 82E0E19C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82E0E1A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E0E1A4: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E0E1A8: 7CA5502E  lwzx r5, r5, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E0E1AC: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0E1B0: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 82E0E1B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E0E1B8: 4E800421  bctrl
	ctx.lr = 0x82E0E1BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0E1BC: 480000F8  b 0x82e0e2b4
	pc = 0x82E0E2B4; continue 'dispatch;
	// 82E0E1C0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82E0E1C4: 41990008  bgt cr6, 0x82e0e1cc
	if ctx.cr[6].gt {
	pc = 0x82E0E1CC; continue 'dispatch;
	}
	// 82E0E1C8: 7D2BF850  subf r9, r11, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82E0E1CC: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82E0E1D0: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82E0E1D4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82E0E1D8: 7CA8502E  lwzx r5, r8, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E0E1DC: 41990008  bgt cr6, 0x82e0e1e4
	if ctx.cr[6].gt {
	pc = 0x82E0E1E4; continue 'dispatch;
	}
	// 82E0E1E0: 7D2BF850  subf r9, r11, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82E0E1E4: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82E0E1E8: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82E0E1EC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82E0E1F0: 7CC8502E  lwzx r6, r8, r10
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E0E1F4: 41990008  bgt cr6, 0x82e0e1fc
	if ctx.cr[6].gt {
	pc = 0x82E0E1FC; continue 'dispatch;
	}
	// 82E0E1F8: 7D2BF850  subf r9, r11, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82E0E1FC: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82E0E200: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82E0E204: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82E0E208: 7CE8502E  lwzx r7, r8, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E0E20C: 41990008  bgt cr6, 0x82e0e214
	if ctx.cr[6].gt {
	pc = 0x82E0E214; continue 'dispatch;
	}
	// 82E0E210: 7D2BF850  subf r9, r11, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82E0E214: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E0E218: 7D29502E  lwzx r9, r9, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E0E21C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0E220: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 82E0E224: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0E228: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E0E22C: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82E0E230: 419A002C  beq cr6, 0x82e0e25c
	if ctx.cr[6].eq {
	pc = 0x82E0E25C; continue 'dispatch;
	}
	// 82E0E234: 39690004  addi r11, r9, 4
	ctx.r[11].s64 = ctx.r[9].s64 + 4;
	// 82E0E238: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E0E23C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0E240: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E0E244: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0E248: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0E24C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0E250: 4082FFE8  bne 0x82e0e238
	if !ctx.cr[0].eq {
	pc = 0x82E0E238; continue 'dispatch;
	}
	// 82E0E254: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82E0E258: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E0E25C: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 82E0E260: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82E0E264: 41990008  bgt cr6, 0x82e0e26c
	if ctx.cr[6].gt {
	pc = 0x82E0E26C; continue 'dispatch;
	}
	// 82E0E268: 7D0BF850  subf r8, r11, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82E0E26C: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82E0E270: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82E0E274: 41990008  bgt cr6, 0x82e0e27c
	if ctx.cr[6].gt {
	pc = 0x82E0E27C; continue 'dispatch;
	}
	// 82E0E278: 7D2BF850  subf r9, r11, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82E0E27C: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E0E280: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E284: 551B103A  slwi r27, r8, 2
	ctx.r[27].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 82E0E288: 81060018  lwz r8, 0x18(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E0E28C: 39250020  addi r9, r5, 0x20
	ctx.r[9].s64 = ctx.r[5].s64 + 32;
	// 82E0E290: 80E70014  lwz r7, 0x14(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E0E294: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82E0E298: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E0E29C: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E0E2A0: 7CBB502E  lwzx r5, r27, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E0E2A4: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0E2A8: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 82E0E2AC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82E0E2B0: 4E800421  bctrl
	ctx.lr = 0x82E0E2B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0E2B4: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82E0E2B8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82E0E2BC: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82E0E2C0: 41990008  bgt cr6, 0x82e0e2c8
	if ctx.cr[6].gt {
	pc = 0x82E0E2C8; continue 'dispatch;
	}
	// 82E0E2C4: 7D6AF850  subf r11, r10, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82E0E2C8: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E0E2CC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E0E2D0: 38FE0038  addi r7, r30, 0x38
	ctx.r[7].s64 = ctx.r[30].s64 + 56;
	// 82E0E2D4: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82E0E2D8: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E0E2DC: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 82E0E2E0: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 82E0E2E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0E2E8: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82E0E2EC: 7D0B4A14  add r8, r11, r9
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82E0E2F0: 7D00392D  stwcx. r8, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0E2F4: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0E2F8: 4082FFE8  bne 0x82e0e2e0
	if !ctx.cr[0].eq {
	pc = 0x82E0E2E0; continue 'dispatch;
	}
	// 82E0E2FC: 393E0034  addi r9, r30, 0x34
	ctx.r[9].s64 = ctx.r[30].s64 + 52;
	// 82E0E300: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82E0E304: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0E308: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82E0E30C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E0E310: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E0E314: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E0E318: 4082FFE8  bne 0x82e0e300
	if !ctx.cr[0].eq {
	pc = 0x82E0E300; continue 'dispatch;
	}
	// 82E0E31C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82E0E320: 4BFFFD5C  b 0x82e0e07c
	pc = 0x82E0E07C; continue 'dispatch;
	// 82E0E324: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82E0E328: 38C00083  li r6, 0x83
	ctx.r[6].s64 = 131;
	// 82E0E32C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E0E330: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E0E334: 4BFEB505  bl 0x82df9838
	ctx.lr = 0x82E0E338;
	sub_82DF9838(ctx, base);
	// 82E0E338: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E0E33C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0E340: 409A0018  bne cr6, 0x82e0e358
	if !ctx.cr[6].eq {
	pc = 0x82E0E358; continue 'dispatch;
	}
	// 82E0E344: 807E0020  lwz r3, 0x20(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E0E348: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E34C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0E350: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0E354: 4E800421  bctrl
	ctx.lr = 0x82E0E358;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0E358: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E0E35C: 4B4C12A5  bl 0x822cf600
	ctx.lr = 0x82E0E360;
	sub_822CF600(ctx, base);
	// 82E0E360: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E0E364: 4BFF5825  bl 0x82e03b88
	ctx.lr = 0x82E0E368;
	sub_82E03B88(ctx, base);
	// 82E0E368: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E0E36C: 48399E48  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0E370 size=16
    let mut pc: u32 = 0x82E0E370;
    'dispatch: loop {
        match pc {
            0x82E0E370 => {
    //   block [0x82E0E370..0x82E0E380)
	// 82E0E370: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E374: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E0E378: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0E37C: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0E380 size=20
    let mut pc: u32 = 0x82E0E380;
    'dispatch: loop {
        match pc {
            0x82E0E380 => {
    //   block [0x82E0E380..0x82E0E394)
	// 82E0E380: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0E384: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E388: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0E38C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0E390: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0E398 size=24
    let mut pc: u32 = 0x82E0E398;
    'dispatch: loop {
        match pc {
            0x82E0E398 => {
    //   block [0x82E0E398..0x82E0E3B0)
	// 82E0E398: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E0E39C: 396BB994  addi r11, r11, -0x466c
	ctx.r[11].s64 = ctx.r[11].s64 + -18028;
	// 82E0E3A0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E0E3A4: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0E3A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0E3AC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0E3B0 size=8
    let mut pc: u32 = 0x82E0E3B0;
    'dispatch: loop {
        match pc {
            0x82E0E3B0 => {
    //   block [0x82E0E3B0..0x82E0E3B8)
	// 82E0E3B0: 4B4B24E0  b 0x822c0890
	sub_822C0890(ctx, base);
	return;
	// 82E0E3B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E3B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0E3B8 size=100
    let mut pc: u32 = 0x82E0E3B8;
    'dispatch: loop {
        match pc {
            0x82E0E3B8 => {
    //   block [0x82E0E3B8..0x82E0E41C)
	// 82E0E3B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0E3BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0E3C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E0E3C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0E3C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0E3CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0E3D0: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E0E3D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E0E3D8: 396BB994  addi r11, r11, -0x466c
	ctx.r[11].s64 = ctx.r[11].s64 + -18028;
	// 82E0E3DC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E0E3E0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0E3E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0E3E8: 419A0008  beq cr6, 0x82e0e3f0
	if ctx.cr[6].eq {
	pc = 0x82E0E3F0; continue 'dispatch;
	}
	// 82E0E3EC: 4B4B24A5  bl 0x822c0890
	ctx.lr = 0x82E0E3F0;
	sub_822C0890(ctx, base);
	// 82E0E3F0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0E3F4: 4182000C  beq 0x82e0e400
	if ctx.cr[0].eq {
	pc = 0x82E0E400; continue 'dispatch;
	}
	// 82E0E3F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0E3FC: 4BFE3FDD  bl 0x82df23d8
	ctx.lr = 0x82E0E400;
	sub_82DF23D8(ctx, base);
	// 82E0E400: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0E404: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E0E408: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0E40C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0E410: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E0E414: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E0E418: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0E420 size=132
    let mut pc: u32 = 0x82E0E420;
    'dispatch: loop {
        match pc {
            0x82E0E420 => {
    //   block [0x82E0E420..0x82E0E4A4)
	// 82E0E420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0E424: 48399D49  bl 0x831a816c
	ctx.lr = 0x82E0E428;
	sub_831A8130(ctx, base);
	// 82E0E428: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0E42C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0E430: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E0E434: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82E0E438: 396BB994  addi r11, r11, -0x466c
	ctx.r[11].s64 = ctx.r[11].s64 + -18028;
	// 82E0E43C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E0E440: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E0E444: 806A5F9C  lwz r3, 0x5f9c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24476 as u32) ) } as u64;
	// 82E0E448: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E44C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E450: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0E454: 4E800421  bctrl
	ctx.lr = 0x82E0E458;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0E458: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E0E45C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82E0E460: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82E0E464: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E0E468: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 82E0E46C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E0E470: 4BFEB571  bl 0x82df99e0
	ctx.lr = 0x82E0E474;
	sub_82DF99E0(ctx, base);
	// 82E0E474: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E0E478: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E0E47C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E0E480: 4B4B1B81  bl 0x822c0000
	ctx.lr = 0x82E0E484;
	sub_822C0000(ctx, base);
	// 82E0E484: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0E488: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E48C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0E490: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0E494: 4E800421  bctrl
	ctx.lr = 0x82E0E498;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0E498: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0E49C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E0E4A0: 48399D1C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E4A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0E4A8 size=32
    let mut pc: u32 = 0x82E0E4A8;
    'dispatch: loop {
        match pc {
            0x82E0E4A8 => {
    //   block [0x82E0E4A8..0x82E0E4C8)
	// 82E0E4A8: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E0E4AC: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0E4B0: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82E0E4B4: 7D2A1A14  add r9, r10, r3
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 82E0E4B8: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82E0E4BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E4C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0E4C4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E4C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0E4C8 size=36
    let mut pc: u32 = 0x82E0E4C8;
    'dispatch: loop {
        match pc {
            0x82E0E4C8 => {
    //   block [0x82E0E4C8..0x82E0E4EC)
	// 82E0E4C8: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E4CC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0E4D0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82E0E4D4: 5508003A  rlwinm r8, r8, 0, 0, 0x1d
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 82E0E4D8: 7CE8482E  lwzx r7, r8, r9
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82E0E4DC: 7CE74A14  add r7, r7, r9
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 82E0E4E0: 7CE8492E  stwx r7, r8, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32), ctx.r[7].u32) };
	// 82E0E4E4: 4082FFE4  bne 0x82e0e4c8
	if !ctx.cr[0].eq {
	pc = 0x82E0E4C8; continue 'dispatch;
	}
	// 82E0E4E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E4F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0E4F0 size=8
    let mut pc: u32 = 0x82E0E4F0;
    'dispatch: loop {
        match pc {
            0x82E0E4F0 => {
    //   block [0x82E0E4F0..0x82E0E4F8)
	// 82E0E4F0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E4F4: 4BDC810C  b 0x82bd6600
	sub_82BD6600(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E4F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0E4F8 size=80
    let mut pc: u32 = 0x82E0E4F8;
    'dispatch: loop {
        match pc {
            0x82E0E4F8 => {
    //   block [0x82E0E4F8..0x82E0E548)
	// 82E0E4F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0E4FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0E500: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E0E504: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0E508: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0E50C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E0E510: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E514: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E0E518: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E0E51C: 4BDC717D  bl 0x82bd5698
	ctx.lr = 0x82E0E520;
	sub_82BD5698(ctx, base);
	// 82E0E520: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E0E524: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E0E528: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E0E52C: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E0E530: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E0E534: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0E538: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0E53C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E0E540: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E0E544: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0E548 size=200
    let mut pc: u32 = 0x82E0E548;
    'dispatch: loop {
        match pc {
            0x82E0E548 => {
    //   block [0x82E0E548..0x82E0E610)
	// 82E0E548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0E54C: 48399C21  bl 0x831a816c
	ctx.lr = 0x82E0E550;
	sub_831A8130(ctx, base);
	// 82E0E550: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0E554: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E0E558: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E0E55C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E0E560: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E0E564: 419A00A4  beq cr6, 0x82e0e608
	if ctx.cr[6].eq {
	pc = 0x82E0E608; continue 'dispatch;
	}
	// 82E0E568: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0E56C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0E570: 419A0098  beq cr6, 0x82e0e608
	if ctx.cr[6].eq {
	pc = 0x82E0E608; continue 'dispatch;
	}
	// 82E0E574: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0E578: 395F0020  addi r10, r31, 0x20
	ctx.r[10].s64 = ctx.r[31].s64 + 32;
	// 82E0E57C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E0E580: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E584: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82E0E588: 796BFFE6  rldicr r11, r11, 0x3f, 0x3f
	ctx.r[11].u64 = (ctx.r[11].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82E0E58C: 7D665436  srd r6, r11, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[11].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 82E0E590: 4BDD3879  bl 0x82be1e08
	ctx.lr = 0x82E0E594;
	sub_82BE1E08(ctx, base);
	// 82E0E594: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0E598: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82E0E59C: 80FE0028  lwz r7, 0x28(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E0E5A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E0E5A4: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82E0E5A8: 39600014  li r11, 0x14
	ctx.r[11].s64 = 20;
	// 82E0E5AC: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82E0E5B0: 39000018  li r8, 0x18
	ctx.r[8].s64 = 24;
	// 82E0E5B4: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 82E0E5B8: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82E0E5BC: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 82E0E5C0: 91010084  stw r8, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[8].u32 ) };
	// 82E0E5C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E0E5C8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82E0E5CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E0E5D0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82E0E5D4: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 82E0E5D8: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82E0E5DC: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 82E0E5E0: 90E10088  stw r7, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[7].u32 ) };
	// 82E0E5E4: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E0E5E8: 815E001C  lwz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E0E5EC: 813E0020  lwz r9, 0x20(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E0E5F0: 811E0024  lwz r8, 0x24(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E0E5F4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82E0E5F8: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82E0E5FC: 91210070  stw r9, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 82E0E600: 9101007C  stw r8, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[8].u32 ) };
	// 82E0E604: 4B90ABC5  bl 0x827191c8
	ctx.lr = 0x82E0E608;
	sub_827191C8(ctx, base);
	// 82E0E608: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E0E60C: 48399BB0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0E610 size=8
    let mut pc: u32 = 0x82E0E610;
    'dispatch: loop {
        match pc {
            0x82E0E610 => {
    //   block [0x82E0E610..0x82E0E618)
	// 82E0E610: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82E0E614: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0E618 size=32
    let mut pc: u32 = 0x82E0E618;
    'dispatch: loop {
        match pc {
            0x82E0E618 => {
    //   block [0x82E0E618..0x82E0E638)
	// 82E0E618: 39640020  addi r11, r4, 0x20
	ctx.r[11].s64 = ctx.r[4].s64 + 32;
	// 82E0E61C: 80A5000C  lwz r5, 0xc(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0E620: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E0E624: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E628: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82E0E62C: 794AFFE6  rldicr r10, r10, 0x3f, 0x3f
	ctx.r[10].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82E0E630: 7D465C36  srd r6, r10, r11
	if (ctx.r[11].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[10].u64) >> ((ctx.r[11].u8 & 0x3F) as u32);
	}
	// 82E0E634: 4BDD37D4  b 0x82be1e08
	sub_82BE1E08(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0E638 size=4
    let mut pc: u32 = 0x82E0E638;
    'dispatch: loop {
        match pc {
            0x82E0E638 => {
    //   block [0x82E0E638..0x82E0E63C)
	// 82E0E638: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0E640 size=148
    let mut pc: u32 = 0x82E0E640;
    'dispatch: loop {
        match pc {
            0x82E0E640 => {
    //   block [0x82E0E640..0x82E0E6D4)
	// 82E0E640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0E644: 48399B29  bl 0x831a816c
	ctx.lr = 0x82E0E648;
	sub_831A8130(ctx, base);
	// 82E0E648: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0E64C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E0E650: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0E654: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82E0E658: 397E0020  addi r11, r30, 0x20
	ctx.r[11].s64 = ctx.r[30].s64 + 32;
	// 82E0E65C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E660: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E0E664: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82E0E668: 794AFFE6  rldicr r10, r10, 0x3f, 0x3f
	ctx.r[10].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82E0E66C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E0E670: 7D465C36  srd r6, r10, r11
	if (ctx.r[11].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[10].u64) >> ((ctx.r[11].u8 & 0x3F) as u32);
	}
	// 82E0E674: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E0E678: 4BDD3791  bl 0x82be1e08
	ctx.lr = 0x82E0E67C;
	sub_82BE1E08(ctx, base);
	// 82E0E67C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82E0E680: 2B1E0010  cmplwi cr6, r30, 0x10
	ctx.cr[6].compare_u32(ctx.r[30].u32, 16 as u32, &mut ctx.xer);
	// 82E0E684: 409AFFD4  bne cr6, 0x82e0e658
	if !ctx.cr[6].eq {
	pc = 0x82E0E658; continue 'dispatch;
	}
	// 82E0E688: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82E0E68C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82E0E690: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82E0E694: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E698: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82E0E69C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E0E6A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E0E6A4: 4BDC7045  bl 0x82bd56e8
	ctx.lr = 0x82E0E6A8;
	sub_82BD56E8(ctx, base);
	// 82E0E6A8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E0E6AC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E6B0: 4BDC7159  bl 0x82bd5808
	ctx.lr = 0x82E0E6B4;
	sub_82BD5808(ctx, base);
	// 82E0E6B4: 395F008C  addi r10, r31, 0x8c
	ctx.r[10].s64 = ctx.r[31].s64 + 140;
	// 82E0E6B8: 39600194  li r11, 0x194
	ctx.r[11].s64 = 404;
	// 82E0E6BC: 93AA0000  stw r29, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82E0E6C0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0E6C4: 394A008C  addi r10, r10, 0x8c
	ctx.r[10].s64 = ctx.r[10].s64 + 140;
	// 82E0E6C8: 4082FFF4  bne 0x82e0e6bc
	if !ctx.cr[0].eq {
	pc = 0x82E0E6BC; continue 'dispatch;
	}
	// 82E0E6CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E0E6D0: 48399AEC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E6D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E0E6D8 size=92
    let mut pc: u32 = 0x82E0E6D8;
    'dispatch: loop {
        match pc {
            0x82E0E6D8 => {
    //   block [0x82E0E6D8..0x82E0E734)
	// 82E0E6D8: 89640000  lbz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E6DC: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82E0E6E0: 89440001  lbz r10, 1(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(1 as u32) ) } as u64;
	// 82E0E6E4: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82E0E6E8: 556B403E  rotlwi r11, r11, 8
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(8)) as u64;
	// 82E0E6EC: 89040002  lbz r8, 2(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(2 as u32) ) } as u64;
	// 82E0E6F0: 88E40003  lbz r7, 3(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(3 as u32) ) } as u64;
	// 82E0E6F4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E0E6F8: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82E0E6FC: 89430038  lbz r10, 0x38(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E0E700: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E704: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E0E708: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E0E70C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E0E710: 7D6B4378  or r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[8].u64;
	// 82E0E714: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E0E718: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E0E71C: 7D673B78  or r7, r11, r7
	ctx.r[7].u64 = ctx.r[11].u64 | ctx.r[7].u64;
	// 82E0E720: 41820014  beq 0x82e0e734
	if ctx.cr[0].eq {
		sub_82E0E734(ctx, base);
		return;
	}
	// 82E0E724: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E0E728: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E0E72C: EC200828  fsubs f1, f0, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82E0E730: 4BDE84B0  b 0x82bf6be0
	sub_82BF6BE0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E734(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0E734 size=4
    let mut pc: u32 = 0x82E0E734;
    'dispatch: loop {
        match pc {
            0x82E0E734 => {
    //   block [0x82E0E734..0x82E0E738)
	// 82E0E734: 4BDE84AC  b 0x82bf6be0
	sub_82BF6BE0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E0E738 size=116
    let mut pc: u32 = 0x82E0E738;
    'dispatch: loop {
        match pc {
            0x82E0E738 => {
    //   block [0x82E0E738..0x82E0E7AC)
	// 82E0E738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0E73C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0E740: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0E744: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E0E748: 89630038  lbz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E0E74C: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 82E0E750: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 82E0E754: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E0E758: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	// 82E0E75C: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 82E0E760: C00A08A8  lfs f0, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E0E764: 41820010  beq 0x82e0e774
	if ctx.cr[0].eq {
	pc = 0x82E0E774; continue 'dispatch;
	}
	// 82E0E768: EDA00828  fsubs f13, f0, f1
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82E0E76C: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E0E770: 48000008  b 0x82e0e778
	pc = 0x82E0E778; continue 'dispatch;
	// 82E0E774: D0210060  stfs f1, 0x60(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E0E778: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0E77C: 419A0010  beq cr6, 0x82e0e78c
	if ctx.cr[6].eq {
	pc = 0x82E0E78C; continue 'dispatch;
	}
	// 82E0E780: EC001028  fsubs f0, f0, f2
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[2].f64) as f32) as f64);
	// 82E0E784: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82E0E788: 48000008  b 0x82e0e790
	pc = 0x82E0E790; continue 'dispatch;
	// 82E0E78C: D0410064  stfs f2, 0x64(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82E0E790: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E0E794: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E798: 4BDC7719  bl 0x82bd5eb0
	ctx.lr = 0x82E0E79C;
	sub_82BD5EB0(ctx, base);
	// 82E0E79C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E0E7A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0E7A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0E7A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0E7B0 size=8
    let mut pc: u32 = 0x82E0E7B0;
    'dispatch: loop {
        match pc {
            0x82E0E7B0 => {
    //   block [0x82E0E7B0..0x82E0E7B8)
	// 82E0E7B0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E7B4: 4BDC6DEC  b 0x82bd55a0
	sub_82BD55A0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E7B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0E7B8 size=212
    let mut pc: u32 = 0x82E0E7B8;
    'dispatch: loop {
        match pc {
            0x82E0E7B8 => {
    //   block [0x82E0E7B8..0x82E0E88C)
	// 82E0E7B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0E7BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0E7C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E0E7C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0E7C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0E7CC: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82E0E7D0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E0E7D4: 1D69008C  mulli r11, r9, 0x8c
	ctx.r[11].s64 = ctx.r[9].s64 * 140;
	// 82E0E7D8: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82E0E7DC: 3BEB0084  addi r31, r11, 0x84
	ctx.r[31].s64 = ctx.r[11].s64 + 132;
	// 82E0E7E0: 816B0088  lwz r11, 0x88(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 82E0E7E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0E7E8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0E7EC: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 82E0E7F0: 419A002C  beq cr6, 0x82e0e81c
	if ctx.cr[6].eq {
	pc = 0x82E0E81C; continue 'dispatch;
	}
	// 82E0E7F4: 2B0A0020  cmplwi cr6, r10, 0x20
	ctx.cr[6].compare_u32(ctx.r[10].u32, 32 as u32, &mut ctx.xer);
	// 82E0E7F8: 4098001C  bge cr6, 0x82e0e814
	if !ctx.cr[6].lt {
	pc = 0x82E0E814; continue 'dispatch;
	}
	// 82E0E7FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0E800: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E0E804: 7FCA592E  stwx r30, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[30].u32) };
	// 82E0E808: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E80C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0E810: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E0E814: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E0E818: 4800005C  b 0x82e0e874
	pc = 0x82E0E874; continue 'dispatch;
	// 82E0E81C: 2B0A0020  cmplwi cr6, r10, 0x20
	ctx.cr[6].compare_u32(ctx.r[10].u32, 32 as u32, &mut ctx.xer);
	// 82E0E820: 4098001C  bge cr6, 0x82e0e83c
	if !ctx.cr[6].lt {
	pc = 0x82E0E83C; continue 'dispatch;
	}
	// 82E0E824: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0E828: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E0E82C: 7FCA592E  stwx r30, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[30].u32) };
	// 82E0E830: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E834: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0E838: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E0E83C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E840: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0E844: 419A0010  beq cr6, 0x82e0e854
	if ctx.cr[6].eq {
	pc = 0x82E0E854; continue 'dispatch;
	}
	// 82E0E848: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E84C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82E0E850: 419A0020  beq cr6, 0x82e0e870
	if ctx.cr[6].eq {
	pc = 0x82E0E870; continue 'dispatch;
	}
	// 82E0E854: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E858: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E0E85C: 7D634A14  add r11, r3, r9
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[9].u64;
	// 82E0E860: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E0E864: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0E868: 4E800421  bctrl
	ctx.lr = 0x82E0E86C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0E86C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82E0E870: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E0E874: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E0E878: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0E87C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0E880: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E0E884: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E0E888: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0E890 size=128
    let mut pc: u32 = 0x82E0E890;
    'dispatch: loop {
        match pc {
            0x82E0E890 => {
    //   block [0x82E0E890..0x82E0E910)
	// 82E0E890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0E894: 483998D9  bl 0x831a816c
	ctx.lr = 0x82E0E898;
	sub_831A8130(ctx, base);
	// 82E0E898: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0E89C: 1D64008C  mulli r11, r4, 0x8c
	ctx.r[11].s64 = ctx.r[4].s64 * 140;
	// 82E0E8A0: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82E0E8A4: 3BEB0084  addi r31, r11, 0x84
	ctx.r[31].s64 = ctx.r[11].s64 + 132;
	// 82E0E8A8: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 82E0E8AC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0E8B0: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E8B4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82E0E8B8: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E0E8BC: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E0E8C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E0E8C4: 419A0040  beq cr6, 0x82e0e904
	if ctx.cr[6].eq {
	pc = 0x82E0E904; continue 'dispatch;
	}
	// 82E0E8C8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E8CC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E0E8D0: 7D4A582E  lwzx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E0E8D4: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E0E8D8: 419A002C  beq cr6, 0x82e0e904
	if ctx.cr[6].eq {
	pc = 0x82E0E904; continue 'dispatch;
	}
	// 82E0E8DC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E8E0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0E8E4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E0E8E8: 7D232214  add r9, r3, r4
	ctx.r[9].u64 = ctx.r[3].u64 + ctx.r[4].u64;
	// 82E0E8EC: 7FAA582E  lwzx r29, r10, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E0E8F0: 81690040  lwz r11, 0x40(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E0E8F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E0E8F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E0E8FC: 4E800421  bctrl
	ctx.lr = 0x82E0E900;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E0E900: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82E0E904: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E0E908: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E0E90C: 483998B0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0E910 size=40
    let mut pc: u32 = 0x82E0E910;
    'dispatch: loop {
        match pc {
            0x82E0E910 => {
    //   block [0x82E0E910..0x82E0E938)
	// 82E0E910: 1D64008C  mulli r11, r4, 0x8c
	ctx.r[11].s64 = ctx.r[4].s64 * 140;
	// 82E0E914: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82E0E918: 396B0084  addi r11, r11, 0x84
	ctx.r[11].s64 = ctx.r[11].s64 + 132;
	// 82E0E91C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0E920: 2B0A00FF  cmplwi cr6, r10, 0xff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 255 as u32, &mut ctx.xer);
	// 82E0E924: 4098000C  bge cr6, 0x82e0e930
	if !ctx.cr[6].lt {
	pc = 0x82E0E930; continue 'dispatch;
	}
	// 82E0E928: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E0E92C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E0E930: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E0E934: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0E938 size=24
    let mut pc: u32 = 0x82E0E938;
    'dispatch: loop {
        match pc {
            0x82E0E938 => {
    //   block [0x82E0E938..0x82E0E950)
	// 82E0E938: 1D64008C  mulli r11, r4, 0x8c
	ctx.r[11].s64 = ctx.r[4].s64 * 140;
	// 82E0E93C: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82E0E940: 396B0084  addi r11, r11, 0x84
	ctx.r[11].s64 = ctx.r[11].s64 + 132;
	// 82E0E944: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0E948: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E0E94C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0E950 size=12
    let mut pc: u32 = 0x82E0E950;
    'dispatch: loop {
        match pc {
            0x82E0E950 => {
    //   block [0x82E0E950..0x82E0E95C)
	// 82E0E950: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82E0E954: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E0E958: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E0E960 size=128
    let mut pc: u32 = 0x82E0E960;
    'dispatch: loop {
        match pc {
            0x82E0E960 => {
    //   block [0x82E0E960..0x82E0E9E0)
	// 82E0E960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0E964: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0E968: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0E96C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82E0E970: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0E974: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0E978: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 82E0E97C: 388000D0  li r4, 0xd0
	ctx.r[4].s64 = 208;
	// 82E0E980: 897F0038  lbz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E0E984: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E0E988: 41820020  beq 0x82e0e9a8
	if ctx.cr[0].eq {
	pc = 0x82E0E9A8; continue 'dispatch;
	}
	// 82E0E98C: FC000850  fneg f0, f1
	ctx.f[0].u64 = ctx.f[1].u64 ^ 0x8000_0000_0000_0000u64;
	// 82E0E990: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E0E994: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E0E998: 4B4D6951  bl 0x822e52e8
	ctx.lr = 0x82E0E99C;
	sub_822E52E8(ctx, base);
	// 82E0E99C: FC00F850  fneg f0, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = ctx.f[31].u64 ^ 0x8000_0000_0000_0000u64;
	// 82E0E9A0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E0E9A4: 48000014  b 0x82e0e9b8
	pc = 0x82E0E9B8; continue 'dispatch;
	// 82E0E9A8: D0210050  stfs f1, 0x50(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E0E9AC: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E0E9B0: 4B4D6939  bl 0x822e52e8
	ctx.lr = 0x82E0E9B4;
	sub_822E52E8(ctx, base);
	// 82E0E9B4: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E0E9B8: 388000CC  li r4, 0xcc
	ctx.r[4].s64 = 204;
	// 82E0E9BC: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E0E9C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0E9C4: 4B4D6925  bl 0x822e52e8
	ctx.lr = 0x82E0E9C8;
	sub_822E52E8(ctx, base);
	// 82E0E9C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E0E9CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0E9D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0E9D4: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E0E9D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E0E9DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0E9E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E0E9E0 size=172
    let mut pc: u32 = 0x82E0E9E0;
    'dispatch: loop {
        match pc {
            0x82E0E9E0 => {
    //   block [0x82E0E9E0..0x82E0EA8C)
	// 82E0E9E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0E9E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0E9E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0E9EC: 89630038  lbz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E0E9F0: 98830026  stb r4, 0x26(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(38 as u32), ctx.r[4].u8 ) };
	// 82E0E9F4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E0E9F8: 4182003C  beq 0x82e0ea34
	if ctx.cr[0].eq {
	pc = 0x82E0EA34; continue 'dispatch;
	}
	// 82E0E9FC: FC001850  fneg f0, f3
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = ctx.f[3].u64 ^ 0x8000_0000_0000_0000u64;
	// 82E0EA00: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E0EA04: FC002050  fneg f0, f4
	ctx.f[0].u64 = ctx.f[4].u64 ^ 0x8000_0000_0000_0000u64;
	// 82E0EA08: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E0EA0C: FC000850  fneg f0, f1
	ctx.f[0].u64 = ctx.f[1].u64 ^ 0x8000_0000_0000_0000u64;
	// 82E0EA10: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E0EA14: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E0EA18: FC001050  fneg f0, f2
	ctx.f[0].u64 = ctx.f[2].u64 ^ 0x8000_0000_0000_0000u64;
	// 82E0EA1C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E0EA20: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E0EA24: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E0EA28: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E0EA2C: 9103002C  stw r8, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[8].u32 ) };
	// 82E0EA30: 48000028  b 0x82e0ea58
	pc = 0x82E0EA58; continue 'dispatch;
	// 82E0EA34: D0610058  stfs f3, 0x58(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E0EA38: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E0EA3C: D0810058  stfs f4, 0x58(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E0EA40: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E0EA44: D0410058  stfs f2, 0x58(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E0EA48: D0210054  stfs f1, 0x54(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E0EA4C: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E0EA50: 9123002C  stw r9, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 82E0EA54: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E0EA58: 91630030  stw r11, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82E0EA5C: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0EA60: 91230028  stw r9, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82E0EA64: 91430034  stw r10, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 82E0EA68: 40820014  bne 0x82e0ea7c
	if !ctx.cr[0].eq {
	pc = 0x82E0EA7C; continue 'dispatch;
	}
	// 82E0EA6C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E0EA70: C04B08A4  lfs f2, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82E0EA74: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82E0EA78: 4BFFFEE9  bl 0x82e0e960
	ctx.lr = 0x82E0EA7C;
	sub_82E0E960(ctx, base);
	// 82E0EA7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E0EA80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0EA84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0EA88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0EA90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0EA90 size=24
    let mut pc: u32 = 0x82E0EA90;
    'dispatch: loop {
        match pc {
            0x82E0EA90 => {
    //   block [0x82E0EA90..0x82E0EAA8)
	// 82E0EA90: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0EA94: 98830038  stb r4, 0x38(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[4].u8 ) };
	// 82E0EA98: 3880002C  li r4, 0x2c
	ctx.r[4].s64 = 44;
	// 82E0EA9C: 4182000C  beq 0x82e0eaa8
	if ctx.cr[0].eq {
		sub_82E0EAA8(ctx, base);
		return;
	}
	// 82E0EAA0: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 82E0EAA4: 4B4D6844  b 0x822e52e8
	sub_822E52E8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0EAA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0EAA8 size=8
    let mut pc: u32 = 0x82E0EAA8;
    'dispatch: loop {
        match pc {
            0x82E0EAA8 => {
    //   block [0x82E0EAA8..0x82E0EAB0)
	// 82E0EAA8: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82E0EAAC: 4B4D683C  b 0x822e52e8
	sub_822E52E8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0EAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0EAB0 size=116
    let mut pc: u32 = 0x82E0EAB0;
    'dispatch: loop {
        match pc {
            0x82E0EAB0 => {
    //   block [0x82E0EAB0..0x82E0EB24)
	// 82E0EAB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0EAB4: 483996B1  bl 0x831a8164
	ctx.lr = 0x82E0EAB8;
	sub_831A8130(ctx, base);
	// 82E0EAB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0EABC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E0EAC0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E0EAC4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E0EAC8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E0EACC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82E0EAD0: 38C00018  li r6, 0x18
	ctx.r[6].s64 = 24;
	// 82E0EAD4: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E0EAD8: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 82E0EADC: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 82E0EAE0: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 82E0EAE4: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82E0EAE8: 4BFE35E1  bl 0x82df20c8
	ctx.lr = 0x82E0EAEC;
	sub_82DF20C8(ctx, base);
	// 82E0EAEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E0EAF0: 4182002C  beq 0x82e0eb1c
	if ctx.cr[0].eq {
	pc = 0x82E0EB1C; continue 'dispatch;
	}
	// 82E0EAF4: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82E0EAF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0EAFC: 93A30004  stw r29, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82E0EB00: 93830008  stw r28, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82E0EB04: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0EB08: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82E0EB0C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0EB10: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82E0EB14: 9B630014  stb r27, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[27].u8 ) };
	// 82E0EB18: 99630015  stb r11, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[11].u8 ) };
	// 82E0EB1C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E0EB20: 48399694  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0EB28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0EB28 size=148
    let mut pc: u32 = 0x82E0EB28;
    'dispatch: loop {
        match pc {
            0x82E0EB28 => {
    //   block [0x82E0EB28..0x82E0EBBC)
	// 82E0EB28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0EB2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0EB30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E0EB34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0EB38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0EB3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E0EB40: A17E0024  lhz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E0EB44: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E0EB48: 4082005C  bne 0x82e0eba4
	if !ctx.cr[0].eq {
	pc = 0x82E0EBA4; continue 'dispatch;
	}
	// 82E0EB4C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0EB50: 3BFE0014  addi r31, r30, 0x14
	ctx.r[31].s64 = ctx.r[30].s64 + 20;
	// 82E0EB54: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E0EB58: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82E0EB5C: 419A0048  beq cr6, 0x82e0eba4
	if ctx.cr[6].eq {
	pc = 0x82E0EBA4; continue 'dispatch;
	}
	// 82E0EB60: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E0EB64: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 82E0EB68: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82E0EB6C: 4B4B58F5  bl 0x822c4460
	ctx.lr = 0x82E0EB70;
	sub_822C4460(ctx, base);
	// 82E0EB70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0EB74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0EB78: 419A0018  beq cr6, 0x82e0eb90
	if ctx.cr[6].eq {
	pc = 0x82E0EB90; continue 'dispatch;
	}
	// 82E0EB7C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0EB80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0EB84: 419A0018  beq cr6, 0x82e0eb9c
	if ctx.cr[6].eq {
	pc = 0x82E0EB9C; continue 'dispatch;
	}
	// 82E0EB88: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0EB8C: 48000008  b 0x82e0eb94
	pc = 0x82E0EB94; continue 'dispatch;
	// 82E0EB90: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E0EB94: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0EB98: 4BDC9B69  bl 0x82bd8700
	ctx.lr = 0x82E0EB9C;
	sub_82BD8700(ctx, base);
	// 82E0EB9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0EBA0: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E0EBA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E0EBA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0EBAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0EBB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E0EBB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E0EBB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0EBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0EBC0 size=96
    let mut pc: u32 = 0x82E0EBC0;
    'dispatch: loop {
        match pc {
            0x82E0EBC0 => {
    //   block [0x82E0EBC0..0x82E0EC20)
	// 82E0EBC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0EBC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0EBC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0EBCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0EBD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0EBD4: A17F0024  lhz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E0EBD8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E0EBDC: 40820030  bne 0x82e0ec0c
	if !ctx.cr[0].eq {
	pc = 0x82E0EC0C; continue 'dispatch;
	}
	// 82E0EBE0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E0EBE4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0EBE8: 4BDC9B19  bl 0x82bd8700
	ctx.lr = 0x82E0EBEC;
	sub_82BD8700(ctx, base);
	// 82E0EBEC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E0EBF0: 397F0014  addi r11, r31, 0x14
	ctx.r[11].s64 = ctx.r[31].s64 + 20;
	// 82E0EBF4: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82E0EBF8: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E0EBFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0EC00: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82E0EC04: 419A0008  beq cr6, 0x82e0ec0c
	if ctx.cr[6].eq {
	pc = 0x82E0EC0C; continue 'dispatch;
	}
	// 82E0EC08: 4B4B1C89  bl 0x822c0890
	ctx.lr = 0x82E0EC0C;
	sub_822C0890(ctx, base);
	// 82E0EC0C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E0EC10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0EC14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0EC18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E0EC1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0EC20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0EC20 size=140
    let mut pc: u32 = 0x82E0EC20;
    'dispatch: loop {
        match pc {
            0x82E0EC20 => {
    //   block [0x82E0EC20..0x82E0ECAC)
	// 82E0EC20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0EC24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0EC28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E0EC2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0EC30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0EC34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E0EC38: A17E0024  lhz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E0EC3C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E0EC40: 40820054  bne 0x82e0ec94
	if !ctx.cr[0].eq {
	pc = 0x82E0EC94; continue 'dispatch;
	}
	// 82E0EC44: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0EC48: 3BFE001C  addi r31, r30, 0x1c
	ctx.r[31].s64 = ctx.r[30].s64 + 28;
	// 82E0EC4C: 815E001C  lwz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E0EC50: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82E0EC54: 419A0040  beq cr6, 0x82e0ec94
	if ctx.cr[6].eq {
	pc = 0x82E0EC94; continue 'dispatch;
	}
	// 82E0EC58: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E0EC5C: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 82E0EC60: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82E0EC64: 4B4B57FD  bl 0x822c4460
	ctx.lr = 0x82E0EC68;
	sub_822C4460(ctx, base);
	// 82E0EC68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0EC6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0EC70: 419A0018  beq cr6, 0x82e0ec88
	if ctx.cr[6].eq {
	pc = 0x82E0EC88; continue 'dispatch;
	}
	// 82E0EC74: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0EC78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0EC7C: 419A0018  beq cr6, 0x82e0ec94
	if ctx.cr[6].eq {
	pc = 0x82E0EC94; continue 'dispatch;
	}
	// 82E0EC80: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0EC84: 48000008  b 0x82e0ec8c
	pc = 0x82E0EC8C; continue 'dispatch;
	// 82E0EC88: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E0EC8C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0EC90: 4BDC97B9  bl 0x82bd8448
	ctx.lr = 0x82E0EC94;
	sub_82BD8448(ctx, base);
	// 82E0EC94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E0EC98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0EC9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0ECA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E0ECA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E0ECA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0ECB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0ECB0 size=96
    let mut pc: u32 = 0x82E0ECB0;
    'dispatch: loop {
        match pc {
            0x82E0ECB0 => {
    //   block [0x82E0ECB0..0x82E0ED10)
	// 82E0ECB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0ECB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0ECB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0ECBC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0ECC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0ECC4: A17F0024  lhz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E0ECC8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E0ECCC: 40820030  bne 0x82e0ecfc
	if !ctx.cr[0].eq {
	pc = 0x82E0ECFC; continue 'dispatch;
	}
	// 82E0ECD0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E0ECD4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0ECD8: 4BDC9771  bl 0x82bd8448
	ctx.lr = 0x82E0ECDC;
	sub_82BD8448(ctx, base);
	// 82E0ECDC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E0ECE0: 397F001C  addi r11, r31, 0x1c
	ctx.r[11].s64 = ctx.r[31].s64 + 28;
	// 82E0ECE4: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82E0ECE8: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E0ECEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E0ECF0: 915F0020  stw r10, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 82E0ECF4: 419A0008  beq cr6, 0x82e0ecfc
	if ctx.cr[6].eq {
	pc = 0x82E0ECFC; continue 'dispatch;
	}
	// 82E0ECF8: 4B4B1B99  bl 0x822c0890
	ctx.lr = 0x82E0ECFC;
	sub_822C0890(ctx, base);
	// 82E0ECFC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E0ED00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0ED04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0ED08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E0ED0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0ED10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0ED10 size=120
    let mut pc: u32 = 0x82E0ED10;
    'dispatch: loop {
        match pc {
            0x82E0ED10 => {
    //   block [0x82E0ED10..0x82E0ED88)
	// 82E0ED10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0ED14: 48399459  bl 0x831a816c
	ctx.lr = 0x82E0ED18;
	sub_831A8130(ctx, base);
	// 82E0ED18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0ED1C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E0ED20: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82E0ED24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E0ED28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E0ED2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E0ED30: 4BFED299  bl 0x82dfbfc8
	ctx.lr = 0x82E0ED34;
	sub_82DFBFC8(ctx, base);
	// 82E0ED34: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0ED38: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82E0ED3C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E0ED40: 419A002C  beq cr6, 0x82e0ed6c
	if ctx.cr[6].eq {
	pc = 0x82E0ED6C; continue 'dispatch;
	}
	// 82E0ED44: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0ED48: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0ED4C: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82E0ED50: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E0ED54: 41980008  blt cr6, 0x82e0ed5c
	if ctx.cr[6].lt {
	pc = 0x82E0ED5C; continue 'dispatch;
	}
	// 82E0ED58: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E0ED5C: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E0ED60: 4082000C  bne 0x82e0ed6c
	if !ctx.cr[0].eq {
	pc = 0x82E0ED6C; continue 'dispatch;
	}
	// 82E0ED64: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82E0ED68: 4800000C  b 0x82e0ed74
	pc = 0x82E0ED74; continue 'dispatch;
	// 82E0ED6C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E0ED70: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 82E0ED74: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0ED78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E0ED7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E0ED80: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E0ED84: 48399438  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0ED88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0ED88 size=124
    let mut pc: u32 = 0x82E0ED88;
    'dispatch: loop {
        match pc {
            0x82E0ED88 => {
    //   block [0x82E0ED88..0x82E0EE04)
	// 82E0ED88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0ED8C: 483993E1  bl 0x831a816c
	ctx.lr = 0x82E0ED90;
	sub_831A8130(ctx, base);
	// 82E0ED90: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0ED94: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E0ED98: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E0ED9C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E0EDA0: 419A005C  beq cr6, 0x82e0edfc
	if ctx.cr[6].eq {
	pc = 0x82E0EDFC; continue 'dispatch;
	}
	// 82E0EDA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0EDA8: 4BDC9D79  bl 0x82bd8b20
	ctx.lr = 0x82E0EDAC;
	sub_82BD8B20(ctx, base);
	// 82E0EDAC: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82E0EDB0: 3BBE0008  addi r29, r30, 8
	ctx.r[29].s64 = ctx.r[30].s64 + 8;
	// 82E0EDB4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E0EDB8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E0EDBC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E0EDC0: 4BFFFF51  bl 0x82e0ed10
	ctx.lr = 0x82E0EDC4;
	sub_82E0ED10(ctx, base);
	// 82E0EDC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0EDC8: 4BDD0211  bl 0x82bdefd8
	ctx.lr = 0x82E0EDCC;
	sub_82BDEFD8(ctx, base);
	// 82E0EDCC: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0EDD0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E0EDD4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E0EDD8: 419A0024  beq cr6, 0x82e0edfc
	if ctx.cr[6].eq {
	pc = 0x82E0EDFC; continue 'dispatch;
	}
	// 82E0EDDC: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82E0EDE0: 409A001C  bne cr6, 0x82e0edfc
	if !ctx.cr[6].eq {
	pc = 0x82E0EDFC; continue 'dispatch;
	}
	// 82E0EDE4: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E0EDE8: 4BDD01F1  bl 0x82bdefd8
	ctx.lr = 0x82E0EDEC;
	sub_82BDEFD8(ctx, base);
	// 82E0EDEC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E0EDF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E0EDF4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E0EDF8: 4B70D899  bl 0x8251c690
	ctx.lr = 0x82E0EDFC;
	sub_8251C690(ctx, base);
	// 82E0EDFC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E0EE00: 483993BC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0EE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0EE08 size=264
    let mut pc: u32 = 0x82E0EE08;
    'dispatch: loop {
        match pc {
            0x82E0EE08 => {
    //   block [0x82E0EE08..0x82E0EF10)
	// 82E0EE08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0EE0C: 48399355  bl 0x831a8160
	ctx.lr = 0x82E0EE10;
	sub_831A8130(ctx, base);
	// 82E0EE10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0EE14: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E0EE18: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82E0EE1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0EE20: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82E0EE24: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82E0EE28: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0EE2C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0EE30: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82E0EE34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E0EE38: 409A0040  bne cr6, 0x82e0ee78
	if !ctx.cr[6].eq {
	pc = 0x82E0EE78; continue 'dispatch;
	}
	// 82E0EE3C: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0EE40: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0EE44: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82E0EE48: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82E0EE4C: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82E0EE50: 41980008  blt cr6, 0x82e0ee58
	if ctx.cr[6].lt {
	pc = 0x82E0EE58; continue 'dispatch;
	}
	// 82E0EE54: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E0EE58: 555D063F  clrlwi. r29, r10, 0x18
	ctx.r[29].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82E0EE5C: 4182000C  beq 0x82e0ee68
	if ctx.cr[0].eq {
	pc = 0x82E0EE68; continue 'dispatch;
	}
	// 82E0EE60: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0EE64: 48000008  b 0x82e0ee6c
	pc = 0x82E0EE6C; continue 'dispatch;
	// 82E0EE68: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0EE6C: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82E0EE70: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E0EE74: 419AFFCC  beq cr6, 0x82e0ee40
	if ctx.cr[6].eq {
	pc = 0x82E0EE40; continue 'dispatch;
	}
	// 82E0EE78: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82E0EE7C: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0EE80: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82E0EE84: 41820048  beq 0x82e0eecc
	if ctx.cr[0].eq {
	pc = 0x82E0EECC; continue 'dispatch;
	}
	// 82E0EE88: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0EE8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0EE90: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0EE94: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E0EE98: 409A002C  bne cr6, 0x82e0eec4
	if !ctx.cr[6].eq {
	pc = 0x82E0EEC4; continue 'dispatch;
	}
	// 82E0EE9C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E0EEA0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E0EEA4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82E0EEA8: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82E0EEAC: 4BFF77AD  bl 0x82e06658
	ctx.lr = 0x82E0EEB0;
	sub_82E06658(ctx, base);
	// 82E0EEB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E0EEB4: 9B5F0004  stb r26, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u8 ) };
	// 82E0EEB8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0EEBC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E0EEC0: 48000044  b 0x82e0ef04
	pc = 0x82E0EF04; continue 'dispatch;
	// 82E0EEC4: 4800DF9D  bl 0x82e1ce60
	ctx.lr = 0x82E0EEC8;
	sub_82E1CE60(ctx, base);
	// 82E0EEC8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E0EECC: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0EED0: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0EED4: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82E0EED8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82E0EEDC: 41980008  blt cr6, 0x82e0eee4
	if ctx.cr[6].lt {
	pc = 0x82E0EEE4; continue 'dispatch;
	}
	// 82E0EEE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0EEE4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0EEE8: 41820010  beq 0x82e0eef8
	if ctx.cr[0].eq {
	pc = 0x82E0EEF8; continue 'dispatch;
	}
	// 82E0EEEC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E0EEF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0EEF4: 4BFFFFAC  b 0x82e0eea0
	pc = 0x82E0EEA0; continue 'dispatch;
	// 82E0EEF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0EEFC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E0EF00: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 82E0EF04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0EF08: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E0EF0C: 483992A4  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0EF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0EF10 size=452
    let mut pc: u32 = 0x82E0EF10;
    'dispatch: loop {
        match pc {
            0x82E0EF10 => {
    //   block [0x82E0EF10..0x82E0F0D4)
	// 82E0EF10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0EF14: 48399249  bl 0x831a815c
	ctx.lr = 0x82E0EF18;
	sub_831A8130(ctx, base);
	// 82E0EF18: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0EF1C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82E0EF20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0EF24: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E0EF28: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82E0EF2C: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0EF30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0EF34: 409A0020  bne cr6, 0x82e0ef54
	if !ctx.cr[6].eq {
	pc = 0x82E0EF54; continue 'dispatch;
	}
	// 82E0EF38: 80DA0004  lwz r6, 4(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0EF3C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E0EF40: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82E0EF44: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E0EF48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0EF4C: 4BFF770D  bl 0x82e06658
	ctx.lr = 0x82E0EF50;
	sub_82E06658(ctx, base);
	// 82E0EF50: 48000178  b 0x82e0f0c8
	pc = 0x82E0F0C8; continue 'dispatch;
	// 82E0EF54: 833A0004  lwz r25, 4(r26)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0EF58: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0EF5C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E0EF60: 409A002C  bne cr6, 0x82e0ef8c
	if !ctx.cr[6].eq {
	pc = 0x82E0EF8C; continue 'dispatch;
	}
	// 82E0EF64: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0EF68: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0EF6C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82E0EF70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E0EF74: 41980008  blt cr6, 0x82e0ef7c
	if ctx.cr[6].lt {
	pc = 0x82E0EF7C; continue 'dispatch;
	}
	// 82E0EF78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0EF7C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0EF80: 4182012C  beq 0x82e0f0ac
	if ctx.cr[0].eq {
	pc = 0x82E0F0AC; continue 'dispatch;
	}
	// 82E0EF84: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82E0EF88: 4BFFFFB4  b 0x82e0ef3c
	pc = 0x82E0EF3C; continue 'dispatch;
	// 82E0EF8C: 7F1EC840  cmplw cr6, r30, r25
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82E0EF90: 409A0030  bne cr6, 0x82e0efc0
	if !ctx.cr[6].eq {
	pc = 0x82E0EFC0; continue 'dispatch;
	}
	// 82E0EF94: 80D90008  lwz r6, 8(r25)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0EF98: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0EF9C: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0EFA0: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82E0EFA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E0EFA8: 41980008  blt cr6, 0x82e0efb0
	if ctx.cr[6].lt {
	pc = 0x82E0EFB0; continue 'dispatch;
	}
	// 82E0EFAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0EFB0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0EFB4: 418200F8  beq 0x82e0f0ac
	if ctx.cr[0].eq {
	pc = 0x82E0F0AC; continue 'dispatch;
	}
	// 82E0EFB8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E0EFBC: 4BFFFF84  b 0x82e0ef40
	pc = 0x82E0EF40; continue 'dispatch;
	// 82E0EFC0: 839D0000  lwz r28, 0(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0EFC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E0EFC8: 837E000C  lwz r27, 0xc(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0EFCC: 7F1CD800  cmpw cr6, r28, r27
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[27].s32, &mut ctx.xer);
	// 82E0EFD0: 41980008  blt cr6, 0x82e0efd8
	if ctx.cr[6].lt {
	pc = 0x82E0EFD8; continue 'dispatch;
	}
	// 82E0EFD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0EFD8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0EFDC: 41820060  beq 0x82e0f03c
	if ctx.cr[0].eq {
	pc = 0x82E0F03C; continue 'dispatch;
	}
	// 82E0EFE0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E0EFE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0EFE8: 4800DE79  bl 0x82e1ce60
	ctx.lr = 0x82E0EFEC;
	sub_82E1CE60(ctx, base);
	// 82E0EFEC: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E0EFF0: 8166000C  lwz r11, 0xc(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0EFF4: 7F0BE000  cmpw cr6, r11, r28
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82E0EFF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E0EFFC: 41980008  blt cr6, 0x82e0f004
	if ctx.cr[6].lt {
	pc = 0x82E0F004; continue 'dispatch;
	}
	// 82E0F000: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0F004: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0F008: 41820034  beq 0x82e0f03c
	if ctx.cr[0].eq {
	pc = 0x82E0F03C; continue 'dispatch;
	}
	// 82E0F00C: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0F010: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82E0F014: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E0F018: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0F01C: 896B0015  lbz r11, 0x15(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82E0F020: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0F024: 419A000C  beq cr6, 0x82e0f030
	if ctx.cr[6].eq {
	pc = 0x82E0F030; continue 'dispatch;
	}
	// 82E0F028: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E0F02C: 4BFFFF20  b 0x82e0ef4c
	pc = 0x82E0EF4C; continue 'dispatch;
	// 82E0F030: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82E0F034: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E0F038: 4BFFFF14  b 0x82e0ef4c
	pc = 0x82E0EF4C; continue 'dispatch;
	// 82E0F03C: 7F1BE000  cmpw cr6, r27, r28
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82E0F040: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E0F044: 41980008  blt cr6, 0x82e0f04c
	if ctx.cr[6].lt {
	pc = 0x82E0F04C; continue 'dispatch;
	}
	// 82E0F048: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0F04C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0F050: 4182005C  beq 0x82e0f0ac
	if ctx.cr[0].eq {
	pc = 0x82E0F0AC; continue 'dispatch;
	}
	// 82E0F054: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E0F058: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0F05C: 4B6DA035  bl 0x824e9090
	ctx.lr = 0x82E0F060;
	sub_824E9090(ctx, base);
	// 82E0F060: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E0F064: 7F06C840  cmplw cr6, r6, r25
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82E0F068: 419A0020  beq cr6, 0x82e0f088
	if ctx.cr[6].eq {
	pc = 0x82E0F088; continue 'dispatch;
	}
	// 82E0F06C: 8166000C  lwz r11, 0xc(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0F070: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82E0F074: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E0F078: 41980008  blt cr6, 0x82e0f080
	if ctx.cr[6].lt {
	pc = 0x82E0F080; continue 'dispatch;
	}
	// 82E0F07C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0F080: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0F084: 41820028  beq 0x82e0f0ac
	if ctx.cr[0].eq {
	pc = 0x82E0F0AC; continue 'dispatch;
	}
	// 82E0F088: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E0F08C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82E0F090: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E0F094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0F098: 896B0015  lbz r11, 0x15(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82E0F09C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0F0A0: 419AFF94  beq cr6, 0x82e0f034
	if ctx.cr[6].eq {
	pc = 0x82E0F034; continue 'dispatch;
	}
	// 82E0F0A4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82E0F0A8: 4BFFFF80  b 0x82e0f028
	pc = 0x82E0F028; continue 'dispatch;
	// 82E0F0AC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E0F0B0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E0F0B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0F0B8: 4BFFFD51  bl 0x82e0ee08
	ctx.lr = 0x82E0F0BC;
	sub_82E0EE08(ctx, base);
	// 82E0F0BC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E0F0C0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F0C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E0F0C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0F0CC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E0F0D0: 483990DC  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F0D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0F0D8 size=144
    let mut pc: u32 = 0x82E0F0D8;
    'dispatch: loop {
        match pc {
            0x82E0F0D8 => {
    //   block [0x82E0F0D8..0x82E0F168)
	// 82E0F0D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0F0DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0F0E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E0F0E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0F0E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0F0EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0F0F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E0F0F4: 4BFECED5  bl 0x82dfbfc8
	ctx.lr = 0x82E0F0F8;
	sub_82DFBFC8(ctx, base);
	// 82E0F0F8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E0F0FC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82E0F100: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E0F104: 419A0024  beq cr6, 0x82e0f128
	if ctx.cr[6].eq {
	pc = 0x82E0F128; continue 'dispatch;
	}
	// 82E0F108: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F10C: 8145000C  lwz r10, 0xc(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0F110: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82E0F114: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E0F118: 41980008  blt cr6, 0x82e0f120
	if ctx.cr[6].lt {
	pc = 0x82E0F120; continue 'dispatch;
	}
	// 82E0F11C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0F120: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0F124: 41820028  beq 0x82e0f14c
	if ctx.cr[0].eq {
	pc = 0x82E0F14C; continue 'dispatch;
	}
	// 82E0F128: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F12C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E0F130: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82E0F134: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82E0F138: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E0F13C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0F140: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82E0F144: 4BFFFDCD  bl 0x82e0ef10
	ctx.lr = 0x82E0F148;
	sub_82E0EF10(ctx, base);
	// 82E0F148: 80A30000  lwz r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F14C: 38650010  addi r3, r5, 0x10
	ctx.r[3].s64 = ctx.r[5].s64 + 16;
	// 82E0F150: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E0F154: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0F158: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0F15C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E0F160: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E0F164: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0F168 size=176
    let mut pc: u32 = 0x82E0F168;
    'dispatch: loop {
        match pc {
            0x82E0F168 => {
    //   block [0x82E0F168..0x82E0F218)
	// 82E0F168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0F16C: 48398FF5  bl 0x831a8160
	ctx.lr = 0x82E0F170;
	sub_831A8130(ctx, base);
	// 82E0F170: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0F174: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E0F178: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82E0F17C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82E0F180: 4BDC9899  bl 0x82bd8a18
	ctx.lr = 0x82E0F184;
	sub_82BD8A18(ctx, base);
	// 82E0F184: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82E0F188: 41820048  beq 0x82e0f1d0
	if ctx.cr[0].eq {
	pc = 0x82E0F1D0; continue 'dispatch;
	}
	// 82E0F18C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0F190: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82E0F194: 4BDC998D  bl 0x82bd8b20
	ctx.lr = 0x82E0F198;
	sub_82BD8B20(ctx, base);
	// 82E0F198: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82E0F19C: 3BDD0008  addi r30, r29, 8
	ctx.r[30].s64 = ctx.r[29].s64 + 8;
	// 82E0F1A0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E0F1A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E0F1A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E0F1AC: 4BFFFB65  bl 0x82e0ed10
	ctx.lr = 0x82E0F1B0;
	sub_82E0ED10(ctx, base);
	// 82E0F1B0: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E0F1B4: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E0F1B8: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E0F1BC: 419A0038  beq cr6, 0x82e0f1f4
	if ctx.cr[6].eq {
	pc = 0x82E0F1F4; continue 'dispatch;
	}
	// 82E0F1C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0F1C4: 4BDCFE15  bl 0x82bdefd8
	ctx.lr = 0x82E0F1C8;
	sub_82BDEFD8(ctx, base);
	// 82E0F1C8: 83FC0010  lwz r31, 0x10(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E0F1CC: 48000038  b 0x82e0f204
	pc = 0x82E0F204; continue 'dispatch;
	// 82E0F1D0: 3F408007  lis r26, -0x7ff9
	ctx.r[26].s64 = -2147024896;
	// 82E0F1D4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E0F1D8: 635A000E  ori r26, r26, 0xe
	ctx.r[26].u64 = ctx.r[26].u64 | 14;
	// 82E0F1DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E0F1E0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E0F1E4: 480040D5  bl 0x82e132b8
	ctx.lr = 0x82E0F1E8;
	sub_82E132B8(ctx, base);
	// 82E0F1E8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82E0F1EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E0F1F0: 48398FC0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
	// 82E0F1F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E0F1F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E0F1FC: 4BFFFEDD  bl 0x82e0f0d8
	ctx.lr = 0x82E0F200;
	sub_82E0F0D8(ctx, base);
	// 82E0F200: 93E30000  stw r31, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82E0F204: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0F208: 4BDCFD59  bl 0x82bdef60
	ctx.lr = 0x82E0F20C;
	sub_82BDEF60(ctx, base);
	// 82E0F20C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E0F210: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E0F214: 4BFFFFCC  b 0x82e0f1e0
	pc = 0x82E0F1E0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0F218 size=96
    let mut pc: u32 = 0x82E0F218;
    'dispatch: loop {
        match pc {
            0x82E0F218 => {
    //   block [0x82E0F218..0x82E0F278)
	// 82E0F218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0F21C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0F220: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E0F224: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0F228: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0F22C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0F230: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E0F234: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E0F238: 38C002C4  li r6, 0x2c4
	ctx.r[6].s64 = 708;
	// 82E0F23C: 38ABB9A8  addi r5, r11, -0x4658
	ctx.r[5].s64 = ctx.r[11].s64 + -18008;
	// 82E0F240: 389F0060  addi r4, r31, 0x60
	ctx.r[4].s64 = ctx.r[31].s64 + 96;
	// 82E0F244: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0F248: 4BFEA5F1  bl 0x82df9838
	ctx.lr = 0x82E0F24C;
	sub_82DF9838(ctx, base);
	// 82E0F24C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E0F250: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 82E0F254: 4BDA3EB5  bl 0x82bb3108
	ctx.lr = 0x82E0F258;
	sub_82BB3108(ctx, base);
	// 82E0F258: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0F25C: 4B4C03A5  bl 0x822cf600
	ctx.lr = 0x82E0F260;
	sub_822CF600(ctx, base);
	// 82E0F260: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E0F264: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0F268: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0F26C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E0F270: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E0F274: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0F278 size=228
    let mut pc: u32 = 0x82E0F278;
    'dispatch: loop {
        match pc {
            0x82E0F278 => {
    //   block [0x82E0F278..0x82E0F35C)
	// 82E0F278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0F27C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0F280: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0F284: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0F288: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0F28C: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82E0F290: 48051F19  bl 0x82e611a8
	ctx.lr = 0x82E0F294;
	sub_82E611A8(ctx, base);
	// 82E0F294: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E0F298: 395F0084  addi r10, r31, 0x84
	ctx.r[10].s64 = ctx.r[31].s64 + 132;
	// 82E0F29C: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82E0F2A0: 38C00193  li r6, 0x193
	ctx.r[6].s64 = 403;
	// 82E0F2A4: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82E0F2A8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82E0F2AC: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82E0F2B0: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82E0F2B4: B17F0024  sth r11, 0x24(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u16 ) };
	// 82E0F2B8: 997F0026  stb r11, 0x26(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(38 as u32), ctx.r[11].u8 ) };
	// 82E0F2BC: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82E0F2C0: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82E0F2C4: 917F004C  stw r11, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82E0F2C8: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E0F2CC: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82E0F2D0: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E0F2D4: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82E0F2D8: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82E0F2DC: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82E0F2E0: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82E0F2E4: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82E0F2E8: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82E0F2EC: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82E0F2F0: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82E0F2F4: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82E0F2F8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E0F2FC: 392A0008  addi r9, r10, 8
	ctx.r[9].s64 = ctx.r[10].s64 + 8;
	// 82E0F300: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E0F304: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 82E0F308: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82E0F30C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82E0F310: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82E0F314: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82E0F318: 4200FFF8  bdnz 0x82e0f310
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82E0F310; continue 'dispatch;
	}
	// 82E0F31C: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82E0F320: 394A008C  addi r10, r10, 0x8c
	ctx.r[10].s64 = ctx.r[10].s64 + 140;
	// 82E0F324: 4080FFD4  bge 0x82e0f2f8
	if !ctx.cr[0].lt {
	pc = 0x82E0F2F8; continue 'dispatch;
	}
	// 82E0F328: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E0F32C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E0F330: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82E0F334: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E0F338: 995F0038  stb r10, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u8 ) };
	// 82E0F33C: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82E0F340: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82E0F344: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82E0F348: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E0F34C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0F350: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0F354: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E0F358: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0F360 size=4
    let mut pc: u32 = 0x82E0F360;
    'dispatch: loop {
        match pc {
            0x82E0F360 => {
    //   block [0x82E0F360..0x82E0F364)
	// 82E0F360: 48002D28  b 0x82e12088
	sub_82E12088(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0F368 size=8
    let mut pc: u32 = 0x82E0F368;
    'dispatch: loop {
        match pc {
            0x82E0F368 => {
    //   block [0x82E0F368..0x82E0F370)
	// 82E0F368: 9883010F  stb r4, 0x10f(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(271 as u32), ctx.r[4].u8 ) };
	// 82E0F36C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E0F370 size=232
    let mut pc: u32 = 0x82E0F370;
    'dispatch: loop {
        match pc {
            0x82E0F370 => {
    //   block [0x82E0F370..0x82E0F458)
	// 82E0F370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0F374: 48398DF9  bl 0x831a816c
	ctx.lr = 0x82E0F378;
	sub_831A8130(ctx, base);
	// 82E0F378: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0F37C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0F380: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E0F384: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E0F388: 797EFFE6  rldicr r30, r11, 0x3f, 0x3f
	ctx.r[30].u64 = (ctx.r[11].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82E0F38C: 889F00E0  lbz r4, 0xe0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 82E0F390: 2B0400FF  cmplwi cr6, r4, 0xff
	ctx.cr[6].compare_u32(ctx.r[4].u32, 255 as u32, &mut ctx.xer);
	// 82E0F394: 419A0034  beq cr6, 0x82e0f3c8
	if ctx.cr[6].eq {
	pc = 0x82E0F3C8; continue 'dispatch;
	}
	// 82E0F398: 39640003  addi r11, r4, 3
	ctx.r[11].s64 = ctx.r[4].s64 + 3;
	// 82E0F39C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F3A0: 5489F0BE  srwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shr(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E0F3A4: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E0F3A8: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82E0F3AC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82E0F3B0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E0F3B4: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F3B8: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82E0F3BC: 7FCB5E34  srad r11, r30, r11
	tmp.u64 = (ctx.r[11].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[30].s64 < 0) && ((ctx.r[30].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[11].s64 = ctx.r[30].s64 >> tmp.u64;
	// 82E0F3C0: 7D674C36  srd r7, r11, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[11].u64) >> ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 82E0F3C4: 4BDC8CCD  bl 0x82bd8090
	ctx.lr = 0x82E0F3C8;
	sub_82BD8090(ctx, base);
	// 82E0F3C8: 889F00F6  lbz r4, 0xf6(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(246 as u32) ) } as u64;
	// 82E0F3CC: 2B0400FF  cmplwi cr6, r4, 0xff
	ctx.cr[6].compare_u32(ctx.r[4].u32, 255 as u32, &mut ctx.xer);
	// 82E0F3D0: 419A0080  beq cr6, 0x82e0f450
	if ctx.cr[6].eq {
	pc = 0x82E0F450; continue 'dispatch;
	}
	// 82E0F3D4: 39640003  addi r11, r4, 3
	ctx.r[11].s64 = ctx.r[4].s64 + 3;
	// 82E0F3D8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F3DC: 5489F0BE  srwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shr(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E0F3E0: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E0F3E4: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82E0F3E8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82E0F3EC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E0F3F0: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F3F4: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82E0F3F8: 7FCB5E34  srad r11, r30, r11
	tmp.u64 = (ctx.r[11].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[30].s64 < 0) && ((ctx.r[30].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[11].s64 = ctx.r[30].s64 >> tmp.u64;
	// 82E0F3FC: 7D674C36  srd r7, r11, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[11].u64) >> ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 82E0F400: 4BDC8D71  bl 0x82bd8170
	ctx.lr = 0x82E0F404;
	sub_82BD8170(ctx, base);
	// 82E0F404: 897F00F8  lbz r11, 0xf8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82E0F408: 2B0B00FF  cmplwi cr6, r11, 0xff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 255 as u32, &mut ctx.xer);
	// 82E0F40C: 419A0044  beq cr6, 0x82e0f450
	if ctx.cr[6].eq {
	pc = 0x82E0F450; continue 'dispatch;
	}
	// 82E0F410: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E0F414: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F418: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E0F41C: 4806C64D  bl 0x82e7ba68
	ctx.lr = 0x82E0F420;
	sub_82E7BA68(ctx, base);
	// 82E0F420: 889F00F8  lbz r4, 0xf8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82E0F424: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82E0F428: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F42C: 39640003  addi r11, r4, 3
	ctx.r[11].s64 = ctx.r[4].s64 + 3;
	// 82E0F430: 548AF0BE  srwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E0F434: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E0F438: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82E0F43C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82E0F440: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82E0F444: 7FCB5E34  srad r11, r30, r11
	tmp.u64 = (ctx.r[11].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[30].s64 < 0) && ((ctx.r[30].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[11].s64 = ctx.r[30].s64 >> tmp.u64;
	// 82E0F448: 7D675436  srd r7, r11, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[11].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 82E0F44C: 4BDC8D25  bl 0x82bd8170
	ctx.lr = 0x82E0F450;
	sub_82BD8170(ctx, base);
	// 82E0F450: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E0F454: 48398D68  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E0F458 size=156
    let mut pc: u32 = 0x82E0F458;
    'dispatch: loop {
        match pc {
            0x82E0F458 => {
    //   block [0x82E0F458..0x82E0F4F4)
	// 82E0F458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0F45C: 48398D11  bl 0x831a816c
	ctx.lr = 0x82E0F460;
	sub_831A8130(ctx, base);
	// 82E0F460: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0F464: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0F468: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E0F46C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E0F470: 797EFFE6  rldicr r30, r11, 0x3f, 0x3f
	ctx.r[30].u64 = (ctx.r[11].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82E0F474: 889F00E2  lbz r4, 0xe2(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(226 as u32) ) } as u64;
	// 82E0F478: 2B0400FF  cmplwi cr6, r4, 0xff
	ctx.cr[6].compare_u32(ctx.r[4].u32, 255 as u32, &mut ctx.xer);
	// 82E0F47C: 419A0034  beq cr6, 0x82e0f4b0
	if ctx.cr[6].eq {
	pc = 0x82E0F4B0; continue 'dispatch;
	}
	// 82E0F480: 39640003  addi r11, r4, 3
	ctx.r[11].s64 = ctx.r[4].s64 + 3;
	// 82E0F484: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F488: 5489F0BE  srwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shr(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E0F48C: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E0F490: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82E0F494: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82E0F498: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E0F49C: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F4A0: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82E0F4A4: 7FCB5E34  srad r11, r30, r11
	tmp.u64 = (ctx.r[11].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[30].s64 < 0) && ((ctx.r[30].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[11].s64 = ctx.r[30].s64 >> tmp.u64;
	// 82E0F4A8: 7D674C36  srd r7, r11, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[11].u64) >> ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 82E0F4AC: 4BDC8BE5  bl 0x82bd8090
	ctx.lr = 0x82E0F4B0;
	sub_82BD8090(ctx, base);
	// 82E0F4B0: 889F00FA  lbz r4, 0xfa(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(250 as u32) ) } as u64;
	// 82E0F4B4: 2B0400FF  cmplwi cr6, r4, 0xff
	ctx.cr[6].compare_u32(ctx.r[4].u32, 255 as u32, &mut ctx.xer);
	// 82E0F4B8: 419A0034  beq cr6, 0x82e0f4ec
	if ctx.cr[6].eq {
	pc = 0x82E0F4EC; continue 'dispatch;
	}
	// 82E0F4BC: 39640003  addi r11, r4, 3
	ctx.r[11].s64 = ctx.r[4].s64 + 3;
	// 82E0F4C0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F4C4: 5489F0BE  srwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shr(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E0F4C8: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E0F4CC: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82E0F4D0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82E0F4D4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E0F4D8: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F4DC: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82E0F4E0: 7FCB5E34  srad r11, r30, r11
	tmp.u64 = (ctx.r[11].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[30].s64 < 0) && ((ctx.r[30].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[11].s64 = ctx.r[30].s64 >> tmp.u64;
	// 82E0F4E4: 7D674C36  srd r7, r11, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[11].u64) >> ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 82E0F4E8: 4BDC8C89  bl 0x82bd8170
	ctx.lr = 0x82E0F4EC;
	sub_82BD8170(ctx, base);
	// 82E0F4EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E0F4F0: 48398CCC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F4F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0F4F8 size=16
    let mut pc: u32 = 0x82E0F4F8;
    'dispatch: loop {
        match pc {
            0x82E0F4F8 => {
    //   block [0x82E0F4F8..0x82E0F508)
	// 82E0F4F8: 896300E4  lbz r11, 0xe4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(228 as u32) ) } as u64;
	// 82E0F4FC: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82E0F500: 2B0B00FF  cmplwi cr6, r11, 0xff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 255 as u32, &mut ctx.xer);
	// 82E0F504: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E0F508 size=56
    let mut pc: u32 = 0x82E0F508;
    'dispatch: loop {
        match pc {
            0x82E0F508 => {
    //   block [0x82E0F508..0x82E0F540)
	// 82E0F508: 394B0003  addi r10, r11, 3
	ctx.r[10].s64 = ctx.r[11].s64 + 3;
	// 82E0F50C: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F510: 5568F0BE  srwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82E0F514: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E0F518: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82E0F51C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82E0F520: 78E7FFE6  rldicr r7, r7, 0x3f, 0x3f
	ctx.r[7].u64 = (ctx.r[7].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82E0F524: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F528: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82E0F52C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82E0F530: 7CEA5634  srad r10, r7, r10
	tmp.u64 = (ctx.r[10].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[7].s64 < 0) && ((ctx.r[7].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[10].s64 = ctx.r[7].s64 >> tmp.u64;
	// 82E0F534: 7D474436  srd r7, r10, r8
	if (ctx.r[8].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[10].u64) >> ((ctx.r[8].u8 & 0x3F) as u32);
	}
	// 82E0F538: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82E0F53C: 4BDC8B54  b 0x82bd8090
	sub_82BD8090(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0F540 size=4
    let mut pc: u32 = 0x82E0F540;
    'dispatch: loop {
        match pc {
            0x82E0F540 => {
    //   block [0x82E0F540..0x82E0F544)
	// 82E0F540: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0F548 size=16
    let mut pc: u32 = 0x82E0F548;
    'dispatch: loop {
        match pc {
            0x82E0F548 => {
    //   block [0x82E0F548..0x82E0F558)
	// 82E0F548: 896300E6  lbz r11, 0xe6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(230 as u32) ) } as u64;
	// 82E0F54C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82E0F550: 2B0B00FF  cmplwi cr6, r11, 0xff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 255 as u32, &mut ctx.xer);
	// 82E0F554: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E0F558 size=56
    let mut pc: u32 = 0x82E0F558;
    'dispatch: loop {
        match pc {
            0x82E0F558 => {
    //   block [0x82E0F558..0x82E0F590)
	// 82E0F558: 394B0003  addi r10, r11, 3
	ctx.r[10].s64 = ctx.r[11].s64 + 3;
	// 82E0F55C: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F560: 5568F0BE  srwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82E0F564: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E0F568: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82E0F56C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82E0F570: 78E7FFE6  rldicr r7, r7, 0x3f, 0x3f
	ctx.r[7].u64 = (ctx.r[7].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82E0F574: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F578: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82E0F57C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82E0F580: 7CEA5634  srad r10, r7, r10
	tmp.u64 = (ctx.r[10].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[7].s64 < 0) && ((ctx.r[7].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[10].s64 = ctx.r[7].s64 >> tmp.u64;
	// 82E0F584: 7D474436  srd r7, r10, r8
	if (ctx.r[8].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[10].u64) >> ((ctx.r[8].u8 & 0x3F) as u32);
	}
	// 82E0F588: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82E0F58C: 4BDC8B04  b 0x82bd8090
	sub_82BD8090(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0F590 size=4
    let mut pc: u32 = 0x82E0F590;
    'dispatch: loop {
        match pc {
            0x82E0F590 => {
    //   block [0x82E0F590..0x82E0F594)
	// 82E0F590: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E0F598 size=204
    let mut pc: u32 = 0x82E0F598;
    'dispatch: loop {
        match pc {
            0x82E0F598 => {
    //   block [0x82E0F598..0x82E0F664)
	// 82E0F598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0F59C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0F5A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0F5A4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0F5A8: 896300E8  lbz r11, 0xe8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(232 as u32) ) } as u64;
	// 82E0F5AC: 2B0B00FF  cmplwi cr6, r11, 0xff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 255 as u32, &mut ctx.xer);
	// 82E0F5B0: 419A00A0  beq cr6, 0x82e0f650
	if ctx.cr[6].eq {
	pc = 0x82E0F650; continue 'dispatch;
	}
	// 82E0F5B4: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 82E0F5B8: 13E020C7  vcmpequd (lvx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E0F5BC: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82E0F5C0: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F5C4: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82E0F5C8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82E0F5CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E0F5D0: 13C450C7  vcmpequd (lvx128) v30, v4, v10
	tmp.u32 = ctx.r[4].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E0F5D4: 3BE10070  addi r31, r1, 0x70
	ctx.r[31].s64 = ctx.r[1].s64 + 112;
	// 82E0F5D8: 13A448C7  vcmpequd (lvx128) v29, v4, v9
	tmp.u32 = ctx.r[4].u32 + ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0F668 size=16
    let mut pc: u32 = 0x82E0F668;
    'dispatch: loop {
        match pc {
            0x82E0F668 => {
    //   block [0x82E0F668..0x82E0F678)
	// 82E0F668: 896300EC  lbz r11, 0xec(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(236 as u32) ) } as u64;
	// 82E0F66C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82E0F670: 2B0B00FF  cmplwi cr6, r11, 0xff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 255 as u32, &mut ctx.xer);
	// 82E0F674: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E0F678 size=56
    let mut pc: u32 = 0x82E0F678;
    'dispatch: loop {
        match pc {
            0x82E0F678 => {
    //   block [0x82E0F678..0x82E0F6B0)
	// 82E0F678: 394B0003  addi r10, r11, 3
	ctx.r[10].s64 = ctx.r[11].s64 + 3;
	// 82E0F67C: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F680: 5568F0BE  srwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82E0F684: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E0F688: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82E0F68C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82E0F690: 78E7FFE6  rldicr r7, r7, 0x3f, 0x3f
	ctx.r[7].u64 = (ctx.r[7].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82E0F694: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F698: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82E0F69C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82E0F6A0: 7CEA5634  srad r10, r7, r10
	tmp.u64 = (ctx.r[10].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[7].s64 < 0) && ((ctx.r[7].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[10].s64 = ctx.r[7].s64 >> tmp.u64;
	// 82E0F6A4: 7D474436  srd r7, r10, r8
	if (ctx.r[8].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[10].u64) >> ((ctx.r[8].u8 & 0x3F) as u32);
	}
	// 82E0F6A8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82E0F6AC: 4BDC89E4  b 0x82bd8090
	sub_82BD8090(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F6B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0F6B0 size=4
    let mut pc: u32 = 0x82E0F6B0;
    'dispatch: loop {
        match pc {
            0x82E0F6B0 => {
    //   block [0x82E0F6B0..0x82E0F6B4)
	// 82E0F6B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F6B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0F6B8 size=16
    let mut pc: u32 = 0x82E0F6B8;
    'dispatch: loop {
        match pc {
            0x82E0F6B8 => {
    //   block [0x82E0F6B8..0x82E0F6C8)
	// 82E0F6B8: 896300EE  lbz r11, 0xee(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(238 as u32) ) } as u64;
	// 82E0F6BC: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82E0F6C0: 2B0B00FF  cmplwi cr6, r11, 0xff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 255 as u32, &mut ctx.xer);
	// 82E0F6C4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F6C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0F6C8 size=12
    let mut pc: u32 = 0x82E0F6C8;
    'dispatch: loop {
        match pc {
            0x82E0F6C8 => {
    //   block [0x82E0F6C8..0x82E0F6D4)
	// 82E0F6C8: 8943010F  lbz r10, 0x10f(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(271 as u32) ) } as u64;
	// 82E0F6CC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E0F6D0: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F6D4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E0F6D4 size=56
    let mut pc: u32 = 0x82E0F6D4;
    'dispatch: loop {
        match pc {
            0x82E0F6D4 => {
    //   block [0x82E0F6D4..0x82E0F70C)
	// 82E0F6D4: 394B0003  addi r10, r11, 3
	ctx.r[10].s64 = ctx.r[11].s64 + 3;
	// 82E0F6D8: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F6DC: 5568F0BE  srwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82E0F6E0: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E0F6E4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82E0F6E8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82E0F6EC: 78E7FFE6  rldicr r7, r7, 0x3f, 0x3f
	ctx.r[7].u64 = (ctx.r[7].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82E0F6F0: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F6F4: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82E0F6F8: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82E0F6FC: 7CEA5634  srad r10, r7, r10
	tmp.u64 = (ctx.r[10].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[7].s64 < 0) && ((ctx.r[7].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[10].s64 = ctx.r[7].s64 >> tmp.u64;
	// 82E0F700: 7D474436  srd r7, r10, r8
	if (ctx.r[8].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[10].u64) >> ((ctx.r[8].u8 & 0x3F) as u32);
	}
	// 82E0F704: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82E0F708: 4BDC8988  b 0x82bd8090
	sub_82BD8090(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F70C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0F70C size=4
    let mut pc: u32 = 0x82E0F70C;
    'dispatch: loop {
        match pc {
            0x82E0F70C => {
    //   block [0x82E0F70C..0x82E0F710)
	// 82E0F70C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E0F710 size=216
    let mut pc: u32 = 0x82E0F710;
    'dispatch: loop {
        match pc {
            0x82E0F710 => {
    //   block [0x82E0F710..0x82E0F7E8)
	// 82E0F710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0F714: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0F718: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0F71C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0F720: 896300F0  lbz r11, 0xf0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(240 as u32) ) } as u64;
	// 82E0F724: 2B0B00FF  cmplwi cr6, r11, 0xff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 255 as u32, &mut ctx.xer);
	// 82E0F728: 419A00AC  beq cr6, 0x82e0f7d4
	if ctx.cr[6].eq {
	pc = 0x82E0F7D4; continue 'dispatch;
	}
	// 82E0F72C: 8943010F  lbz r10, 0x10f(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(271 as u32) ) } as u64;
	// 82E0F730: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E0F734: 418200A0  beq 0x82e0f7d4
	if ctx.cr[0].eq {
	pc = 0x82E0F7D4; continue 'dispatch;
	}
	// 82E0F738: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 82E0F73C: 13E020C7  vcmpequd (lvx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E0F740: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82E0F744: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F748: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82E0F74C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82E0F750: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E0F754: 13C450C7  vcmpequd (lvx128) v30, v4, v10
	tmp.u32 = ctx.r[4].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E0F758: 3BE10070  addi r31, r1, 0x70
	ctx.r[31].s64 = ctx.r[1].s64 + 112;
	// 82E0F75C: 13A448C7  vcmpequd (lvx128) v29, v4, v9
	tmp.u32 = ctx.r[4].u32 + ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F7E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0F7E8 size=20
    let mut pc: u32 = 0x82E0F7E8;
    'dispatch: loop {
        match pc {
            0x82E0F7E8 => {
    //   block [0x82E0F7E8..0x82E0F7FC)
	// 82E0F7E8: 39640081  addi r11, r4, 0x81
	ctx.r[11].s64 = ctx.r[4].s64 + 129;
	// 82E0F7EC: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E0F7F0: 7D6B18AE  lbzx r11, r11, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82E0F7F4: 2B0B00FF  cmplwi cr6, r11, 0xff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 255 as u32, &mut ctx.xer);
	// 82E0F7F8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F7FC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E0F7FC size=108
    let mut pc: u32 = 0x82E0F7FC;
    'dispatch: loop {
        match pc {
            0x82E0F7FC => {
    //   block [0x82E0F7FC..0x82E0F868)
	// 82E0F7FC: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F800: 390B0178  addi r8, r11, 0x178
	ctx.r[8].s64 = ctx.r[11].s64 + 376;
	// 82E0F804: 5567F0BE  srwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82E0F808: 3CC08338  lis r6, -0x7cc8
	ctx.r[6].s64 = -2093481984;
	// 82E0F80C: 556A2036  slwi r10, r11, 4
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E0F810: 55082036  slwi r8, r8, 4
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82E0F814: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0F818: 39266910  addi r9, r6, 0x6910
	ctx.r[9].s64 = ctx.r[6].s64 + 26896;
	// 82E0F81C: 7CA73850  subf r5, r7, r7
	ctx.r[5].s64 = ctx.r[7].s64 - ctx.r[7].s64;
	// 82E0F820: C0066910  lfs f0, 0x6910(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(26896 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E0F824: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82E0F828: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82E0F82C: 78A50020  clrldi r5, r5, 0x20
	ctx.r[5].u64 = ctx.r[5].u64 & 0x00000000FFFFFFFFu64;
	// 82E0F830: 7C085D2E  stfsx f0, r8, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82E0F834: 78C8FFE6  rldicr r8, r6, 0x3f, 0x3f
	ctx.r[8].u64 = (ctx.r[6].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82E0F838: 7D082E34  srad r8, r8, r5
	tmp.u64 = (ctx.r[5].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[8].s64 < 0) && ((ctx.r[8].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[8].s64 = ctx.r[8].s64 >> tmp.u64;
	// 82E0F83C: 7D083C36  srd r8, r8, r7
	if (ctx.r[7].u8 & 0x40) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = (ctx.r[8].u64) >> ((ctx.r[7].u8 & 0x3F) as u32);
	}
	// 82E0F840: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E0F844: D00A1784  stfs f0, 0x1784(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(6020 as u32), tmp.u32 ) };
	// 82E0F848: C0090008  lfs f0, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E0F84C: D00A1788  stfs f0, 0x1788(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(6024 as u32), tmp.u32 ) };
	// 82E0F850: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E0F854: D00A178C  stfs f0, 0x178c(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(6028 as u32), tmp.u32 ) };
	// 82E0F858: E94B0008  ld r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82E0F85C: 7D0A5378  or r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 | ctx.r[10].u64;
	// 82E0F860: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82E0F864: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E0F868 size=388
    let mut pc: u32 = 0x82E0F868;
    'dispatch: loop {
        match pc {
            0x82E0F868 => {
    //   block [0x82E0F868..0x82E0F9EC)
	// 82E0F868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0F86C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0F870: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E0F874: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0F878: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E0F87C: 888300FE  lbz r4, 0xfe(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(254 as u32) ) } as u64;
	// 82E0F880: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 82E0F884: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 82E0F888: 38E00030  li r7, 0x30
	ctx.r[7].s64 = 48;
	// 82E0F88C: 39000040  li r8, 0x40
	ctx.r[8].s64 = 64;
	// 82E0F890: 13E0FC07  vcmpneb. (lvlx128) v31, v0, v31
	tmp.u32 = ctx.r[31].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E0F894: 39200050  li r9, 0x50
	ctx.r[9].s64 = 80;
	// 82E0F898: 13C5FC47  vcmpneh. (lvrx128) v30, v5, v31
	tmp.u32 = ctx.r[5].u32 + ctx.r[31].u32;
	// load reversed into ctx.v[62] using VectorMaskR (or zero if (tmp.u32 & 0xF) == 0)
	// 82E0F89C: 39400060  li r10, 0x60
	ctx.r[10].s64 = 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0F9F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E0F9F0 size=192
    let mut pc: u32 = 0x82E0F9F0;
    'dispatch: loop {
        match pc {
            0x82E0F9F0 => {
    //   block [0x82E0F9F0..0x82E0FAB0)
	// 82E0F9F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0F9F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E0F9F8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0F9FC: 888300FE  lbz r4, 0xfe(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(254 as u32) ) } as u64;
	// 82E0FA00: D0210050  stfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E0FA04: D0210054  stfs f1, 0x54(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E0FA08: D0210058  stfs f1, 0x58(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E0FA0C: 2B0400FF  cmplwi cr6, r4, 0xff
	ctx.cr[6].compare_u32(ctx.r[4].u32, 255 as u32, &mut ctx.xer);
	// 82E0FA10: D021005C  stfs f1, 0x5c(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82E0FA14: D0210060  stfs f1, 0x60(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E0FA18: D0210064  stfs f1, 0x64(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82E0FA1C: D0210068  stfs f1, 0x68(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82E0FA20: D021006C  stfs f1, 0x6c(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82E0FA24: D0210070  stfs f1, 0x70(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82E0FA28: D0210074  stfs f1, 0x74(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82E0FA2C: D0210078  stfs f1, 0x78(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82E0FA30: D021007C  stfs f1, 0x7c(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82E0FA34: D0210080  stfs f1, 0x80(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82E0FA38: D0210084  stfs f1, 0x84(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82E0FA3C: D0210088  stfs f1, 0x88(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82E0FA40: D021008C  stfs f1, 0x8c(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82E0FA44: D0210090  stfs f1, 0x90(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82E0FA48: D0210094  stfs f1, 0x94(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82E0FA4C: D0210098  stfs f1, 0x98(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82E0FA50: D021009C  stfs f1, 0x9c(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82E0FA54: D02100A0  stfs f1, 0xa0(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82E0FA58: D02100A4  stfs f1, 0xa4(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82E0FA5C: D02100A8  stfs f1, 0xa8(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82E0FA60: D02100AC  stfs f1, 0xac(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82E0FA64: 419A003C  beq cr6, 0x82e0faa0
	if ctx.cr[6].eq {
	pc = 0x82E0FAA0; continue 'dispatch;
	}
	// 82E0FA68: 39640005  addi r11, r4, 5
	ctx.r[11].s64 = ctx.r[4].s64 + 5;
	// 82E0FA6C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0FA70: 5489F0BE  srwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shr(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E0FA74: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E0FA78: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82E0FA7C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82E0FA80: 7908FFE6  rldicr r8, r8, 0x3f, 0x3f
	ctx.r[8].u64 = (ctx.r[8].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82E0FA84: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0FA88: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82E0FA8C: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 82E0FA90: 7D0B5E34  srad r11, r8, r11
	tmp.u64 = (ctx.r[11].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[8].s64 < 0) && ((ctx.r[8].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[11].s64 = ctx.r[8].s64 >> tmp.u64;
	// 82E0FA94: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E0FA98: 7D674C36  srd r7, r11, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[11].u64) >> ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 82E0FA9C: 4BDC86D5  bl 0x82bd8170
	ctx.lr = 0x82E0FAA0;
	sub_82BD8170(ctx, base);
	// 82E0FAA0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82E0FAA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E0FAA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E0FAAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0FAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0FAB0 size=12
    let mut pc: u32 = 0x82E0FAB0;
    'dispatch: loop {
        match pc {
            0x82E0FAB0 => {
    //   block [0x82E0FAB0..0x82E0FABC)
	// 82E0FAB0: 896300F4  lbz r11, 0xf4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(244 as u32) ) } as u64;
	// 82E0FAB4: 2B0B00FF  cmplwi cr6, r11, 0xff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 255 as u32, &mut ctx.xer);
	// 82E0FAB8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0FABC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E0FABC size=100
    let mut pc: u32 = 0x82E0FABC;
    'dispatch: loop {
        match pc {
            0x82E0FABC => {
    //   block [0x82E0FABC..0x82E0FB20)
	// 82E0FABC: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0FAC0: 390B0078  addi r8, r11, 0x78
	ctx.r[8].s64 = ctx.r[11].s64 + 120;
	// 82E0FAC4: 5567F0BE  srwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82E0FAC8: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E0FACC: 556A2036  slwi r10, r11, 4
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E0FAD0: 55082036  slwi r8, r8, 4
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82E0FAD4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82E0FAD8: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0FADC: 7D273850  subf r9, r7, r7
	ctx.r[9].s64 = ctx.r[7].s64 - ctx.r[7].s64;
	// 82E0FAE0: 78C6FFE6  rldicr r6, r6, 0x3f, 0x3f
	ctx.r[6].u64 = (ctx.r[6].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82E0FAE4: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82E0FAE8: 79290020  clrldi r9, r9, 0x20
	ctx.r[9].u64 = ctx.r[9].u64 & 0x00000000FFFFFFFFu64;
	// 82E0FAEC: 7C085D2E  stfsx f0, r8, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82E0FAF0: 7CC94E34  srad r9, r6, r9
	tmp.u64 = (ctx.r[9].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[6].s64 < 0) && ((ctx.r[6].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[9].s64 = ctx.r[6].s64 >> tmp.u64;
	// 82E0FAF4: 7D293C36  srd r9, r9, r7
	if (ctx.r[7].u8 & 0x40) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = (ctx.r[9].u64) >> ((ctx.r[7].u8 & 0x3F) as u32);
	}
	// 82E0FAF8: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E0FAFC: D00A0784  stfs f0, 0x784(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1924 as u32), tmp.u32 ) };
	// 82E0FB00: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E0FB04: D00A0788  stfs f0, 0x788(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1928 as u32), tmp.u32 ) };
	// 82E0FB08: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E0FB0C: D00A078C  stfs f0, 0x78c(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1932 as u32), tmp.u32 ) };
	// 82E0FB10: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82E0FB14: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82E0FB18: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82E0FB1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0FB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E0FB20 size=772
    let mut pc: u32 = 0x82E0FB20;
    'dispatch: loop {
        match pc {
            0x82E0FB20 => {
    //   block [0x82E0FB20..0x82E0FE24)
	// 82E0FB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0FB24: 48398621  bl 0x831a8144
	ctx.lr = 0x82E0FB28;
	sub_831A8130(ctx, base);
	// 82E0FB28: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0FB2C: 7CF63B78  mr r22, r7
	ctx.r[22].u64 = ctx.r[7].u64;
	// 82E0FB30: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E0FB34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0FB38: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82E0FB3C: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 82E0FB40: 56CB003B  rlwinm. r11, r22, 0, 0, 0x1d
	ctx.r[11].u64 = ctx.r[22].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0FB44: 3B600010  li r27, 0x10
	ctx.r[27].s64 = 16;
	// 82E0FB48: 3B800020  li r28, 0x20
	ctx.r[28].s64 = 32;
	// 82E0FB4C: 3BA00030  li r29, 0x30
	ctx.r[29].s64 = 48;
	// 82E0FB50: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82E0FB54: 795EFFE6  rldicr r30, r10, 0x3f, 0x3f
	ctx.r[30].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82E0FB58: 41820218  beq 0x82e0fd70
	if ctx.cr[0].eq {
	pc = 0x82E0FD70; continue 'dispatch;
	}
	// 82E0FB5C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E0FB60: 3944007D  addi r10, r4, 0x7d
	ctx.r[10].s64 = ctx.r[4].s64 + 125;
	// 82E0FB64: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E0FB68: 55482036  slwi r8, r10, 4
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82E0FB6C: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 82E0FB70: 39370002  addi r9, r23, 2
	ctx.r[9].s64 = ctx.r[23].s64 + 2;
	// 82E0FB74: 39440008  addi r10, r4, 8
	ctx.r[10].s64 = ctx.r[4].s64 + 8;
	// 82E0FB78: 7D68FA14  add r11, r8, r31
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[31].u64;
	// 82E0FB7C: 54B8103A  slwi r24, r5, 2
	ctx.r[24].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[24].u64 = ctx.r[24].u32 as u64;
	// 82E0FB80: 8909FFFE  lbz r8, -2(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-2 as u32) ) } as u64;
	// 82E0FB84: 38EAFFF8  addi r7, r10, -8
	ctx.r[7].s64 = ctx.r[10].s64 + -8;
	// 82E0FB88: 38CAFFFA  addi r6, r10, -6
	ctx.r[6].s64 = ctx.r[10].s64 + -6;
	// 82E0FB8C: 8869FFFF  lbz r3, -1(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-1 as u32) ) } as u64;
	// 82E0FB90: 5508303E  rotlwi r8, r8, 6
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(6)) as u64;
	// 82E0FB94: 8B290000  lbz r25, 0(r9)
	ctx.r[25].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0FB98: 54F5F0BE  srwi r21, r7, 2
	ctx.r[21].u32 = ctx.r[7].u32.wrapping_shr(2);
	ctx.r[21].u64 = ctx.r[21].u32 as u64;
	// 82E0FB9C: 8A890001  lbz r20, 1(r9)
	ctx.r[20].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(1 as u32) ) } as u64;
	// 82E0FBA0: 7D08D214  add r8, r8, r26
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[26].u64;
	// 82E0FBA4: EA7F0000  ld r19, 0(r31)
	ctx.r[19].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 82E0FBA8: 54C6F0BE  srwi r6, r6, 2
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shr(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82E0FBAC: 5467303E  rotlwi r7, r3, 6
	ctx.r[7].u64 = ((ctx.r[3].u32).rotate_left(6)) as u64;
	// 82E0FBB0: 7C753050  subf r3, r21, r6
	ctx.r[3].s64 = ctx.r[6].s64 - ctx.r[21].s64;
	// 82E0FBB4: 5726303E  rotlwi r6, r25, 6
	ctx.r[6].u64 = ((ctx.r[25].u32).rotate_left(6)) as u64;
	// 82E0FBB8: 13BC4407  vcmpneb. (lvlx128) v29, v28, v8
	tmp.u32 = ctx.r[28].u32 + ctx.r[8].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E0FBBC: 78790020  clrldi r25, r3, 0x20
	ctx.r[25].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 82E0FBC0: 139D4407  vcmpneb. (lvlx128) v28, v29, v8
	tmp.u32 = ctx.r[29].u32 + ctx.r[8].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E0FBC4: 5683303E  rotlwi r3, r20, 6
	ctx.r[3].u64 = ((ctx.r[20].u32).rotate_left(6)) as u64;
	// 82E0FBC8: 13E04407  vcmpneb. (lvlx128) v31, v0, v8
	tmp.u32 = ctx.r[8].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E0FBCC: 7FD9CE34  srad r25, r30, r25
	tmp.u64 = (ctx.r[25].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[30].s64 < 0) && ((ctx.r[30].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[25].s64 = ctx.r[30].s64 >> tmp.u64;
	// 82E0FBD0: 13DB4407  vcmpneb. (lvlx128) v30, v27, v8
	tmp.u32 = ctx.r[27].u32 + ctx.r[8].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0FE28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0FE28 size=20
    let mut pc: u32 = 0x82E0FE28;
    'dispatch: loop {
        match pc {
            0x82E0FE28 => {
    //   block [0x82E0FE28..0x82E0FE3C)
	// 82E0FE28: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E0FE2C: 40820010  bne 0x82e0fe3c
	if !ctx.cr[0].eq {
		sub_82E0FE3C(ctx, base);
		return;
	}
	// 82E0FE30: 8943010F  lbz r10, 0x10f(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(271 as u32) ) } as u64;
	// 82E0FE34: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E0FE38: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0FE3C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0FE3C size=28
    let mut pc: u32 = 0x82E0FE3C;
    'dispatch: loop {
        match pc {
            0x82E0FE3C => {
    //   block [0x82E0FE3C..0x82E0FE58)
	// 82E0FE3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E0FE40: 396300E8  addi r11, r3, 0xe8
	ctx.r[11].s64 = ctx.r[3].s64 + 232;
	// 82E0FE44: 409A0008  bne cr6, 0x82e0fe4c
	if !ctx.cr[6].eq {
	pc = 0x82E0FE4C; continue 'dispatch;
	}
	// 82E0FE48: 396300F0  addi r11, r3, 0xf0
	ctx.r[11].s64 = ctx.r[3].s64 + 240;
	// 82E0FE4C: 888B0000  lbz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0FE50: 2B0400FF  cmplwi cr6, r4, 0xff
	ctx.cr[6].compare_u32(ctx.r[4].u32, 255 as u32, &mut ctx.xer);
	// 82E0FE54: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0FE58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0FE58 size=12
    let mut pc: u32 = 0x82E0FE58;
    'dispatch: loop {
        match pc {
            0x82E0FE58 => {
    //   block [0x82E0FE58..0x82E0FE64)
	// 82E0FE58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0FE5C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E0FE60: 4BFFFCC0  b 0x82e0fb20
	sub_82E0FB20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0FE64(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E0FE64 size=4
    let mut pc: u32 = 0x82E0FE64;
    'dispatch: loop {
        match pc {
            0x82E0FE64 => {
    //   block [0x82E0FE64..0x82E0FE68)
	// 82E0FE64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E0FE68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E0FE68 size=1732
    let mut pc: u32 = 0x82E0FE68;
    'dispatch: loop {
        match pc {
            0x82E0FE68 => {
    //   block [0x82E0FE68..0x82E1052C)
	// 82E0FE68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E0FE6C: 483982C5  bl 0x831a8130
	ctx.lr = 0x82E0FE70;
	sub_831A8130(ctx, base);
	// 82E0FE70: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E0FE74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E0FE78: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E0FE7C: 39FF0018  addi r15, r31, 0x18
	ctx.r[15].s64 = ctx.r[31].s64 + 24;
	// 82E0FE80: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E0FE84: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 82E0FE88: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82E0FE8C: 3A1F0004  addi r16, r31, 4
	ctx.r[16].s64 = ctx.r[31].s64 + 4;
	// 82E0FE90: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82E0FE94: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82E0FE98: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82E0FE9C: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82E0FEA0: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82E0FEA4: 4838B9DD  bl 0x8319b880
	ctx.lr = 0x82E0FEA8;
	sub_8319B880(ctx, base);
	// 82E0FEA8: 39DF001C  addi r14, r31, 0x1c
	ctx.r[14].s64 = ctx.r[31].s64 + 28;
	// 82E0FEAC: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 82E0FEB0: 4838B9D1  bl 0x8319b880
	ctx.lr = 0x82E0FEB4;
	sub_8319B880(ctx, base);
	// 82E0FEB4: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 82E0FEB8: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82E0FEBC: 4838B9C5  bl 0x8319b880
	ctx.lr = 0x82E0FEC0;
	sub_8319B880(ctx, base);
	// 82E0FEC0: 387F0024  addi r3, r31, 0x24
	ctx.r[3].s64 = ctx.r[31].s64 + 36;
	// 82E0FEC4: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 82E0FEC8: 4838B9B9  bl 0x8319b880
	ctx.lr = 0x82E0FECC;
	sub_8319B880(ctx, base);
	// 82E0FECC: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82E0FED0: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82E0FED4: 4838B9AD  bl 0x8319b880
	ctx.lr = 0x82E0FED8;
	sub_8319B880(ctx, base);
	// 82E0FED8: 387F002C  addi r3, r31, 0x2c
	ctx.r[3].s64 = ctx.r[31].s64 + 44;
	// 82E0FEDC: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 82E0FEE0: 4838B9A1  bl 0x8319b880
	ctx.lr = 0x82E0FEE4;
	sub_8319B880(ctx, base);
	// 82E0FEE4: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 82E0FEE8: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82E0FEEC: 4838B995  bl 0x8319b880
	ctx.lr = 0x82E0FEF0;
	sub_8319B880(ctx, base);
	// 82E0FEF0: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 82E0FEF4: 9061006C  stw r3, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[3].u32 ) };
	// 82E0FEF8: 4838B989  bl 0x8319b880
	ctx.lr = 0x82E0FEFC;
	sub_8319B880(ctx, base);
	// 82E0FEFC: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 82E0FF00: 90610070  stw r3, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[3].u32 ) };
	// 82E0FF04: 4838B97D  bl 0x8319b880
	ctx.lr = 0x82E0FF08;
	sub_8319B880(ctx, base);
	// 82E0FF08: 387F003C  addi r3, r31, 0x3c
	ctx.r[3].s64 = ctx.r[31].s64 + 60;
	// 82E0FF0C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82E0FF10: 4838B971  bl 0x8319b880
	ctx.lr = 0x82E0FF14;
	sub_8319B880(ctx, base);
	// 82E0FF14: 387F0040  addi r3, r31, 0x40
	ctx.r[3].s64 = ctx.r[31].s64 + 64;
	// 82E0FF18: 90610078  stw r3, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 82E0FF1C: 4838B965  bl 0x8319b880
	ctx.lr = 0x82E0FF20;
	sub_8319B880(ctx, base);
	// 82E0FF20: 387F0044  addi r3, r31, 0x44
	ctx.r[3].s64 = ctx.r[31].s64 + 68;
	// 82E0FF24: 9061007C  stw r3, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	// 82E0FF28: 4838B959  bl 0x8319b880
	ctx.lr = 0x82E0FF2C;
	sub_8319B880(ctx, base);
	// 82E0FF2C: 387F0048  addi r3, r31, 0x48
	ctx.r[3].s64 = ctx.r[31].s64 + 72;
	// 82E0FF30: 90610080  stw r3, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 82E0FF34: 4838B94D  bl 0x8319b880
	ctx.lr = 0x82E0FF38;
	sub_8319B880(ctx, base);
	// 82E0FF38: 387F004C  addi r3, r31, 0x4c
	ctx.r[3].s64 = ctx.r[31].s64 + 76;
	// 82E0FF3C: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82E0FF40: 4838B941  bl 0x8319b880
	ctx.lr = 0x82E0FF44;
	sub_8319B880(ctx, base);
	// 82E0FF44: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 82E0FF48: 90610088  stw r3, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[3].u32 ) };
	// 82E0FF4C: 4838B935  bl 0x8319b880
	ctx.lr = 0x82E0FF50;
	sub_8319B880(ctx, base);
	// 82E0FF50: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 82E0FF54: 4838B92D  bl 0x8319b880
	ctx.lr = 0x82E0FF58;
	sub_8319B880(ctx, base);
	// 82E0FF58: 387F0058  addi r3, r31, 0x58
	ctx.r[3].s64 = ctx.r[31].s64 + 88;
	// 82E0FF5C: 4838B925  bl 0x8319b880
	ctx.lr = 0x82E0FF60;
	sub_8319B880(ctx, base);
	// 82E0FF60: 387F005C  addi r3, r31, 0x5c
	ctx.r[3].s64 = ctx.r[31].s64 + 92;
	// 82E0FF64: 9061008C  stw r3, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[3].u32 ) };
	// 82E0FF68: 4838B919  bl 0x8319b880
	ctx.lr = 0x82E0FF6C;
	sub_8319B880(ctx, base);
	// 82E0FF6C: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82E0FF70: 90610090  stw r3, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[3].u32 ) };
	// 82E0FF74: 4838B90D  bl 0x8319b880
	ctx.lr = 0x82E0FF78;
	sub_8319B880(ctx, base);
	// 82E0FF78: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 82E0FF7C: 90610094  stw r3, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82E0FF80: 4838B901  bl 0x8319b880
	ctx.lr = 0x82E0FF84;
	sub_8319B880(ctx, base);
	// 82E0FF84: 3B7F0068  addi r27, r31, 0x68
	ctx.r[27].s64 = ctx.r[31].s64 + 104;
	// 82E0FF88: 3B800003  li r28, 3
	ctx.r[28].s64 = 3;
	// 82E0FF8C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E0FF90: 4838B8F1  bl 0x8319b880
	ctx.lr = 0x82E0FF94;
	sub_8319B880(ctx, base);
	// 82E0FF94: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82E0FF98: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82E0FF9C: 4080FFF0  bge 0x82e0ff8c
	if !ctx.cr[0].lt {
	pc = 0x82E0FF8C; continue 'dispatch;
	}
	// 82E0FFA0: 3B7F0078  addi r27, r31, 0x78
	ctx.r[27].s64 = ctx.r[31].s64 + 120;
	// 82E0FFA4: 3B800003  li r28, 3
	ctx.r[28].s64 = 3;
	// 82E0FFA8: 93610098  stw r27, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[27].u32 ) };
	// 82E0FFAC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E0FFB0: 4838B8D1  bl 0x8319b880
	ctx.lr = 0x82E0FFB4;
	sub_8319B880(ctx, base);
	// 82E0FFB4: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82E0FFB8: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82E0FFBC: 4080FFF0  bge 0x82e0ffac
	if !ctx.cr[0].lt {
	pc = 0x82E0FFAC; continue 'dispatch;
	}
	// 82E0FFC0: 3B7F0088  addi r27, r31, 0x88
	ctx.r[27].s64 = ctx.r[31].s64 + 136;
	// 82E0FFC4: 3B800003  li r28, 3
	ctx.r[28].s64 = 3;
	// 82E0FFC8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E0FFCC: 4838B8B5  bl 0x8319b880
	ctx.lr = 0x82E0FFD0;
	sub_8319B880(ctx, base);
	// 82E0FFD0: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82E0FFD4: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82E0FFD8: 4080FFF0  bge 0x82e0ffc8
	if !ctx.cr[0].lt {
	pc = 0x82E0FFC8; continue 'dispatch;
	}
	// 82E0FFDC: 3B7F0098  addi r27, r31, 0x98
	ctx.r[27].s64 = ctx.r[31].s64 + 152;
	// 82E0FFE0: 3B800003  li r28, 3
	ctx.r[28].s64 = 3;
	// 82E0FFE4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E0FFE8: 4838B899  bl 0x8319b880
	ctx.lr = 0x82E0FFEC;
	sub_8319B880(ctx, base);
	// 82E0FFEC: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82E0FFF0: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82E0FFF4: 4080FFF0  bge 0x82e0ffe4
	if !ctx.cr[0].lt {
	pc = 0x82E0FFE4; continue 'dispatch;
	}
	// 82E0FFF8: 387F00A8  addi r3, r31, 0xa8
	ctx.r[3].s64 = ctx.r[31].s64 + 168;
	// 82E0FFFC: 4838B885  bl 0x8319b880
	ctx.lr = 0x82E10000;
	sub_8319B880(ctx, base);
	// 82E10000: 3B9F00AC  addi r28, r31, 0xac
	ctx.r[28].s64 = ctx.r[31].s64 + 172;
	// 82E10004: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E10008: 4838B879  bl 0x8319b880
	ctx.lr = 0x82E1000C;
	sub_8319B880(ctx, base);
	// 82E1000C: 3B7F00B0  addi r27, r31, 0xb0
	ctx.r[27].s64 = ctx.r[31].s64 + 176;
	// 82E10010: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E10014: 4838B86D  bl 0x8319b880
	ctx.lr = 0x82E10018;
	sub_8319B880(ctx, base);
	// 82E10018: 3B5F00B4  addi r26, r31, 0xb4
	ctx.r[26].s64 = ctx.r[31].s64 + 180;
	// 82E1001C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82E10020: 4838B861  bl 0x8319b880
	ctx.lr = 0x82E10024;
	sub_8319B880(ctx, base);
	// 82E10024: 3B3F00B8  addi r25, r31, 0xb8
	ctx.r[25].s64 = ctx.r[31].s64 + 184;
	// 82E10028: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82E1002C: 4838B855  bl 0x8319b880
	ctx.lr = 0x82E10030;
	sub_8319B880(ctx, base);
	// 82E10030: 3B1F00BC  addi r24, r31, 0xbc
	ctx.r[24].s64 = ctx.r[31].s64 + 188;
	// 82E10034: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82E10038: 4838B849  bl 0x8319b880
	ctx.lr = 0x82E1003C;
	sub_8319B880(ctx, base);
	// 82E1003C: 3AFF00C0  addi r23, r31, 0xc0
	ctx.r[23].s64 = ctx.r[31].s64 + 192;
	// 82E10040: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82E10044: 4838B83D  bl 0x8319b880
	ctx.lr = 0x82E10048;
	sub_8319B880(ctx, base);
	// 82E10048: 3ADF00C4  addi r22, r31, 0xc4
	ctx.r[22].s64 = ctx.r[31].s64 + 196;
	// 82E1004C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82E10050: 4838B831  bl 0x8319b880
	ctx.lr = 0x82E10054;
	sub_8319B880(ctx, base);
	// 82E10054: 3ABF00C8  addi r21, r31, 0xc8
	ctx.r[21].s64 = ctx.r[31].s64 + 200;
	// 82E10058: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82E1005C: 4838B825  bl 0x8319b880
	ctx.lr = 0x82E10060;
	sub_8319B880(ctx, base);
	// 82E10060: 3A9F00CC  addi r20, r31, 0xcc
	ctx.r[20].s64 = ctx.r[31].s64 + 204;
	// 82E10064: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82E10068: 4838B819  bl 0x8319b880
	ctx.lr = 0x82E1006C;
	sub_8319B880(ctx, base);
	// 82E1006C: 387F00D0  addi r3, r31, 0xd0
	ctx.r[3].s64 = ctx.r[31].s64 + 208;
	// 82E10070: 4838B811  bl 0x8319b880
	ctx.lr = 0x82E10074;
	sub_8319B880(ctx, base);
	// 82E10074: 3A7F00D4  addi r19, r31, 0xd4
	ctx.r[19].s64 = ctx.r[31].s64 + 212;
	// 82E10078: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 82E1007C: 4838B805  bl 0x8319b880
	ctx.lr = 0x82E10080;
	sub_8319B880(ctx, base);
	// 82E10080: 3A5F00D8  addi r18, r31, 0xd8
	ctx.r[18].s64 = ctx.r[31].s64 + 216;
	// 82E10084: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 82E10088: 4838B7F9  bl 0x8319b880
	ctx.lr = 0x82E1008C;
	sub_8319B880(ctx, base);
	// 82E1008C: 3A3F00DC  addi r17, r31, 0xdc
	ctx.r[17].s64 = ctx.r[31].s64 + 220;
	// 82E10090: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 82E10094: 4838B7ED  bl 0x8319b880
	ctx.lr = 0x82E10098;
	sub_8319B880(ctx, base);
	// 82E10098: 9BDF010F  stb r30, 0x10f(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(271 as u32), ctx.r[30].u8 ) };
	// 82E1009C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E100A0: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 82E100A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E100A8: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 82E100AC: 4B4B43B5  bl 0x822c4460
	ctx.lr = 0x82E100B0;
	sub_822C4460(ctx, base);
	// 82E100B0: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E100B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E100B8: 388BBC18  addi r4, r11, -0x43e8
	ctx.r[4].s64 = ctx.r[11].s64 + -17384;
	// 82E100BC: 4BFE9475  bl 0x82df9530
	ctx.lr = 0x82E100C0;
	sub_82DF9530(ctx, base);
	// 82E100C0: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E100C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E100C8: 388BBC04  addi r4, r11, -0x43fc
	ctx.r[4].s64 = ctx.r[11].s64 + -17404;
	// 82E100CC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E100D0: 916F0000  stw r11, 0(r15)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[15].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E100D4: 4BFE945D  bl 0x82df9530
	ctx.lr = 0x82E100D8;
	sub_82DF9530(ctx, base);
	// 82E100D8: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E100DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E100E0: 388BBBFC  addi r4, r11, -0x4404
	ctx.r[4].s64 = ctx.r[11].s64 + -17412;
	// 82E100E4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E100E8: 916E0000  stw r11, 0(r14)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[14].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E100EC: 4BFE9445  bl 0x82df9530
	ctx.lr = 0x82E100F0;
	sub_82DF9530(ctx, base);
	// 82E100F0: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E100F4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E100F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E100FC: 388ABBF0  addi r4, r10, -0x4410
	ctx.r[4].s64 = ctx.r[10].s64 + -17424;
	// 82E10100: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E10104: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E10108: 4BFE9429  bl 0x82df9530
	ctx.lr = 0x82E1010C;
	sub_82DF9530(ctx, base);
	// 82E1010C: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E10110: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E10114: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82E10118: 388ABBE4  addi r4, r10, -0x441c
	ctx.r[4].s64 = ctx.r[10].s64 + -17436;
	// 82E1011C: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E10120: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E10124: 4BFE940D  bl 0x82df9530
	ctx.lr = 0x82E10128;
	sub_82DF9530(ctx, base);
	// 82E10128: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E1012C: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82E10130: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E10134: 388BBBDC  addi r4, r11, -0x4424
	ctx.r[4].s64 = ctx.r[11].s64 + -17444;
	// 82E10138: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E1013C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E10140: 4BFE93F1  bl 0x82df9530
	ctx.lr = 0x82E10144;
	sub_82DF9530(ctx, base);
	// 82E10144: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E10148: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E1014C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82E10150: 388ABBCC  addi r4, r10, -0x4434
	ctx.r[4].s64 = ctx.r[10].s64 + -17460;
	// 82E10154: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E10158: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E1015C: 4BFE93D5  bl 0x82df9530
	ctx.lr = 0x82E10160;
	sub_82DF9530(ctx, base);
	// 82E10160: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E10164: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82E10168: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82E1016C: 388ABBBC  addi r4, r10, -0x4444
	ctx.r[4].s64 = ctx.r[10].s64 + -17476;
	// 82E10170: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E10174: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E10178: 4BFE93B9  bl 0x82df9530
	ctx.lr = 0x82E1017C;
	sub_82DF9530(ctx, base);
	// 82E1017C: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E10180: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82E10184: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82E10188: 388ABBAC  addi r4, r10, -0x4454
	ctx.r[4].s64 = ctx.r[10].s64 + -17492;
	// 82E1018C: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82E10190: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E10194: 4BFE939D  bl 0x82df9530
	ctx.lr = 0x82E10198;
	sub_82DF9530(ctx, base);
	// 82E10198: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E1019C: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82E101A0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E101A4: 388ABB94  addi r4, r10, -0x446c
	ctx.r[4].s64 = ctx.r[10].s64 + -17516;
	// 82E101A8: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82E101AC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E101B0: 4BFE9381  bl 0x82df9530
	ctx.lr = 0x82E101B4;
	sub_82DF9530(ctx, base);
	// 82E101B4: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E101B8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82E101BC: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82E101C0: 388ABB80  addi r4, r10, -0x4480
	ctx.r[4].s64 = ctx.r[10].s64 + -17536;
	// 82E101C4: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82E101C8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E101CC: 4BFE9365  bl 0x82df9530
	ctx.lr = 0x82E101D0;
	sub_82DF9530(ctx, base);
	// 82E101D0: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E101D4: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82E101D8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82E101DC: 388ABB74  addi r4, r10, -0x448c
	ctx.r[4].s64 = ctx.r[10].s64 + -17548;
	// 82E101E0: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82E101E4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E101E8: 4BFE9349  bl 0x82df9530
	ctx.lr = 0x82E101EC;
	sub_82DF9530(ctx, base);
	// 82E101EC: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E101F0: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82E101F4: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 82E101F8: 388ABB64  addi r4, r10, -0x449c
	ctx.r[4].s64 = ctx.r[10].s64 + -17564;
	// 82E101FC: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82E10200: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E10204: 4BFE932D  bl 0x82df9530
	ctx.lr = 0x82E10208;
	sub_82DF9530(ctx, base);
	// 82E10208: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E1020C: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82E10210: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82E10214: 388ABB58  addi r4, r10, -0x44a8
	ctx.r[4].s64 = ctx.r[10].s64 + -17576;
	// 82E10218: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82E1021C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E10220: 4BFE9311  bl 0x82df9530
	ctx.lr = 0x82E10224;
	sub_82DF9530(ctx, base);
	// 82E10224: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82E10228: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82E1022C: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82E10230: 388ABB20  addi r4, r10, -0x44e0
	ctx.r[4].s64 = ctx.r[10].s64 + -17632;
	// 82E10234: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82E10238: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E1023C: 4BFE92F5  bl 0x82df9530
	ctx.lr = 0x82E10240;
	sub_82DF9530(ctx, base);
	// 82E10240: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E10244: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82E10248: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82E1024C: 388ABB3C  addi r4, r10, -0x44c4
	ctx.r[4].s64 = ctx.r[10].s64 + -17604;
	// 82E10250: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82E10254: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E10258: 4BFE92D9  bl 0x82df9530
	ctx.lr = 0x82E1025C;
	sub_82DF9530(ctx, base);
	// 82E1025C: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E10260: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82E10264: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 82E10268: 388ABB24  addi r4, r10, -0x44dc
	ctx.r[4].s64 = ctx.r[10].s64 + -17628;
	// 82E1026C: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82E10270: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E10274: 4BFE92BD  bl 0x82df9530
	ctx.lr = 0x82E10278;
	sub_82DF9530(ctx, base);
	// 82E10278: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82E1027C: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E10280: 81210090  lwz r9, 0x90(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82E10284: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82E10288: 388ABB0C  addi r4, r10, -0x44f4
	ctx.r[4].s64 = ctx.r[10].s64 + -17652;
	// 82E1028C: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E10290: 4BFE92A1  bl 0x82df9530
	ctx.lr = 0x82E10294;
	sub_82DF9530(ctx, base);
	// 82E10294: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E10298: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82E1029C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82E102A0: 388ABAFC  addi r4, r10, -0x4504
	ctx.r[4].s64 = ctx.r[10].s64 + -17668;
	// 82E102A4: 81410090  lwz r10, 0x90(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82E102A8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E102AC: 4BFE375D  bl 0x82df3a08
	ctx.lr = 0x82E102B0;
	sub_82DF3A08(ctx, base);
	// 82E102B0: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E102B4: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 82E102B8: 388BBAEC  addi r4, r11, -0x4514
	ctx.r[4].s64 = ctx.r[11].s64 + -17684;
	// 82E102BC: 4BFE374D  bl 0x82df3a08
	ctx.lr = 0x82E102C0;
	sub_82DF3A08(ctx, base);
	// 82E102C0: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E102C4: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82E102C8: 388BBADC  addi r4, r11, -0x4524
	ctx.r[4].s64 = ctx.r[11].s64 + -17700;
	// 82E102CC: 4BFE373D  bl 0x82df3a08
	ctx.lr = 0x82E102D0;
	sub_82DF3A08(ctx, base);
	// 82E102D0: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E102D4: 386100AC  addi r3, r1, 0xac
	ctx.r[3].s64 = ctx.r[1].s64 + 172;
	// 82E102D8: 388BBACC  addi r4, r11, -0x4534
	ctx.r[4].s64 = ctx.r[11].s64 + -17716;
	// 82E102DC: 4BFE372D  bl 0x82df3a08
	ctx.lr = 0x82E102E0;
	sub_82DF3A08(ctx, base);
	// 82E102E0: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E102E4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82E102E8: 388BBABC  addi r4, r11, -0x4544
	ctx.r[4].s64 = ctx.r[11].s64 + -17732;
	// 82E102EC: 4BFE371D  bl 0x82df3a08
	ctx.lr = 0x82E102F0;
	sub_82DF3A08(ctx, base);
	// 82E102F0: 3D208203  lis r9, -0x7dfd
	ctx.r[9].s64 = -2113732608;
	// 82E102F4: 3D008203  lis r8, -0x7dfd
	ctx.r[8].s64 = -2113732608;
	// 82E102F8: 83C10098  lwz r30, 0x98(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 82E102FC: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E10300: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 82E10304: 39296008  addi r9, r9, 0x6008
	ctx.r[9].s64 = ctx.r[9].s64 + 24584;
	// 82E10308: 3908AF04  addi r8, r8, -0x50fc
	ctx.r[8].s64 = ctx.r[8].s64 + -20732;
	// 82E1030C: 3BA100A0  addi r29, r1, 0xa0
	ctx.r[29].s64 = ctx.r[1].s64 + 160;
	// 82E10310: 9121008C  stw r9, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[9].u32 ) };
	// 82E10314: 3A000004  li r16, 4
	ctx.r[16].s64 = 4;
	// 82E10318: 91010098  stw r8, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[8].u32 ) };
	// 82E1031C: 39EBBAB0  addi r15, r11, -0x4550
	ctx.r[15].s64 = ctx.r[11].s64 + -17744;
	// 82E10320: 39CA2534  addi r14, r10, 0x2534
	ctx.r[14].s64 = ctx.r[10].s64 + 9524;
	// 82E10324: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E10328: 80A10098  lwz r5, 0x98(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 82E1032C: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 82E10330: 4BFE39C9  bl 0x82df3cf8
	ctx.lr = 0x82E10334;
	sub_82DF3CF8(ctx, base);
	// 82E10334: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E10338: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82E1033C: 4BFE91C5  bl 0x82df9500
	ctx.lr = 0x82E10340;
	sub_82DF9500(ctx, base);
	// 82E10340: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82E10344: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 82E10348: 917EFFF0  stw r11, -0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82E1034C: 4BFE30DD  bl 0x82df3428
	ctx.lr = 0x82E10350;
	sub_82DF3428(ctx, base);
	// 82E10350: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E10354: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82E10358: 80A1008C  lwz r5, 0x8c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82E1035C: 4BFE399D  bl 0x82df3cf8
	ctx.lr = 0x82E10360;
	sub_82DF3CF8(ctx, base);
	// 82E10360: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E10364: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82E10368: 4BFE9199  bl 0x82df9500
	ctx.lr = 0x82E1036C;
	sub_82DF9500(ctx, base);
	// 82E1036C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82E10370: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82E10374: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E10378: 4BFE30B1  bl 0x82df3428
	ctx.lr = 0x82E1037C;
	sub_82DF3428(ctx, base);
	// 82E1037C: 7DC57378  mr r5, r14
	ctx.r[5].u64 = ctx.r[14].u64;
	// 82E10380: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E10384: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82E10388: 4BFE3971  bl 0x82df3cf8
	ctx.lr = 0x82E1038C;
	sub_82DF3CF8(ctx, base);
	// 82E1038C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E10390: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 82E10394: 4BFE916D  bl 0x82df9500
	ctx.lr = 0x82E10398;
	sub_82DF9500(ctx, base);
	// 82E10398: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82E1039C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82E103A0: 917E0010  stw r11, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82E103A4: 4BFE3085  bl 0x82df3428
	ctx.lr = 0x82E103A8;
	sub_82DF3428(ctx, base);
	// 82E103A8: 7DE57B78  mr r5, r15
	ctx.r[5].u64 = ctx.r[15].u64;
	// 82E103AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E103B0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82E103B4: 4BFE3945  bl 0x82df3cf8
	ctx.lr = 0x82E103B8;
	sub_82DF3CF8(ctx, base);
	// 82E103B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E103BC: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82E103C0: 4BFE9141  bl 0x82df9500
	ctx.lr = 0x82E103C4;
	sub_82DF9500(ctx, base);
	// 82E103C4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82E103C8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82E103CC: 917E0020  stw r11, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82E103D0: 4BFE3059  bl 0x82df3428
	ctx.lr = 0x82E103D4;
	sub_82DF3428(ctx, base);
	// 82E103D4: 3610FFFF  addic. r16, r16, -1
	ctx.xer.ca = (ctx.r[16].u32 > (!(-1 as u32)));
	ctx.r[16].s64 = ctx.r[16].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[16].s32, 0, &mut ctx.xer);
	// 82E103D8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82E103DC: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82E103E0: 4082FF44  bne 0x82e10324
	if !ctx.cr[0].eq {
	pc = 0x82E10324; continue 'dispatch;
	}
	// 82E103E4: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E103E8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82E103EC: 388BBA9C  addi r4, r11, -0x4564
	ctx.r[4].s64 = ctx.r[11].s64 + -17764;
	// 82E103F0: 4BFE9141  bl 0x82df9530
	ctx.lr = 0x82E103F4;
	sub_82DF9530(ctx, base);
	// 82E103F4: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E103F8: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 82E103FC: 388BBA84  addi r4, r11, -0x457c
	ctx.r[4].s64 = ctx.r[11].s64 + -17788;
	// 82E10400: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 82E10404: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E10408: 4BFE9129  bl 0x82df9530
	ctx.lr = 0x82E1040C;
	sub_82DF9530(ctx, base);
	// 82E1040C: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E10410: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82E10414: 388BBA70  addi r4, r11, -0x4590
	ctx.r[4].s64 = ctx.r[11].s64 + -17808;
	// 82E10418: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82E1041C: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E10420: 4BFE9111  bl 0x82df9530
	ctx.lr = 0x82E10424;
	sub_82DF9530(ctx, base);
	// 82E10424: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E10428: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 82E1042C: 388BBA58  addi r4, r11, -0x45a8
	ctx.r[4].s64 = ctx.r[11].s64 + -17832;
	// 82E10430: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 82E10434: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E10438: 4BFE90F9  bl 0x82df9530
	ctx.lr = 0x82E1043C;
	sub_82DF9530(ctx, base);
	// 82E1043C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82E10440: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82E10444: 388B8E1C  addi r4, r11, -0x71e4
	ctx.r[4].s64 = ctx.r[11].s64 + -29156;
	// 82E10448: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82E1044C: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E10450: 4BFE90E1  bl 0x82df9530
	ctx.lr = 0x82E10454;
	sub_82DF9530(ctx, base);
	// 82E10454: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E10458: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 82E1045C: 388BBA48  addi r4, r11, -0x45b8
	ctx.r[4].s64 = ctx.r[11].s64 + -17848;
	// 82E10460: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 82E10464: 91780000  stw r11, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E10468: 4BFE90C9  bl 0x82df9530
	ctx.lr = 0x82E1046C;
	sub_82DF9530(ctx, base);
	// 82E1046C: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E10470: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82E10474: 388BBA3C  addi r4, r11, -0x45c4
	ctx.r[4].s64 = ctx.r[11].s64 + -17860;
	// 82E10478: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82E1047C: 91770000  stw r11, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E10480: 4BFE90B1  bl 0x82df9530
	ctx.lr = 0x82E10484;
	sub_82DF9530(ctx, base);
	// 82E10484: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E10488: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 82E1048C: 388BBA24  addi r4, r11, -0x45dc
	ctx.r[4].s64 = ctx.r[11].s64 + -17884;
	// 82E10490: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 82E10494: 91760000  stw r11, 0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E10498: 4BFE9099  bl 0x82df9530
	ctx.lr = 0x82E1049C;
	sub_82DF9530(ctx, base);
	// 82E1049C: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E104A0: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82E104A4: 388BBA10  addi r4, r11, -0x45f0
	ctx.r[4].s64 = ctx.r[11].s64 + -17904;
	// 82E104A8: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82E104AC: 91750000  stw r11, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E104B0: 4BFE9081  bl 0x82df9530
	ctx.lr = 0x82E104B4;
	sub_82DF9530(ctx, base);
	// 82E104B4: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E104B8: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 82E104BC: 388BBA00  addi r4, r11, -0x4600
	ctx.r[4].s64 = ctx.r[11].s64 + -17920;
	// 82E104C0: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 82E104C4: 91740000  stw r11, 0(r20)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E104C8: 4BFE9069  bl 0x82df9530
	ctx.lr = 0x82E104CC;
	sub_82DF9530(ctx, base);
	// 82E104CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82E104D0: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82E104D4: 388B92E8  addi r4, r11, -0x6d18
	ctx.r[4].s64 = ctx.r[11].s64 + -27928;
	// 82E104D8: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82E104DC: 91730000  stw r11, 0(r19)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[19].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E104E0: 4BFE9051  bl 0x82df9530
	ctx.lr = 0x82E104E4;
	sub_82DF9530(ctx, base);
	// 82E104E4: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E104E8: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 82E104EC: 388BB9E8  addi r4, r11, -0x4618
	ctx.r[4].s64 = ctx.r[11].s64 + -17944;
	// 82E104F0: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 82E104F4: 91720000  stw r11, 0(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E104F8: 4BFE9039  bl 0x82df9530
	ctx.lr = 0x82E104FC;
	sub_82DF9530(ctx, base);
	// 82E104FC: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82E10500: 3BC100B4  addi r30, r1, 0xb4
	ctx.r[30].s64 = ctx.r[1].s64 + 180;
	// 82E10504: 3BA00004  li r29, 4
	ctx.r[29].s64 = 4;
	// 82E10508: 91710000  stw r11, 0(r17)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E1050C: 3BDEFFFC  addi r30, r30, -4
	ctx.r[30].s64 = ctx.r[30].s64 + -4;
	// 82E10510: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E10514: 4BFE2F15  bl 0x82df3428
	ctx.lr = 0x82E10518;
	sub_82DF3428(ctx, base);
	// 82E10518: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82E1051C: 4080FFF0  bge 0x82e1050c
	if !ctx.cr[0].lt {
	pc = 0x82E1050C; continue 'dispatch;
	}
	// 82E10520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E10524: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 82E10528: 48397C58  b 0x831a8180
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E10530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E10530 size=44
    let mut pc: u32 = 0x82E10530;
    'dispatch: loop {
        match pc {
            0x82E10530 => {
    //   block [0x82E10530..0x82E1055C)
	// 82E10530: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E10534: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E10538: 892B0015  lbz r9, 0x15(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82E1053C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E10540: 409A0030  bne cr6, 0x82e10570
	if !ctx.cr[6].eq {
		sub_82E1055C(ctx, base);
		return;
	}
	// 82E10544: 81250000  lwz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E10548: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E1054C: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E10550: 4098000C  bge cr6, 0x82e1055c
	if !ctx.cr[6].lt {
		sub_82E1055C(ctx, base);
		return;
	}
	// 82E10554: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E10558: 4800000C  b 0x82e10564
	sub_82E1055C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E1055C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E1055C size=60
    let mut pc: u32 = 0x82E1055C;
    'dispatch: loop {
        match pc {
            0x82E1055C => {
    //   block [0x82E1055C..0x82E10598)
	// 82E1055C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82E10560: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E10564: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82E10568: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82E1056C: 419AFFDC  beq cr6, 0x82e10548
	if ctx.cr[6].eq {
		sub_82E10530(ctx, base);
		return;
	}
	// 82E10570: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E10574: 9141FFF0  stw r10, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u32 ) };
	// 82E10578: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E1057C: 419A001C  beq cr6, 0x82e10598
	if ctx.cr[6].eq {
		sub_82E10598(ctx, base);
		return;
	}
	// 82E10580: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E10584: 81250000  lwz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E10588: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E1058C: 4198000C  blt cr6, 0x82e10598
	if ctx.cr[6].lt {
		sub_82E10598(ctx, base);
		return;
	}
	// 82E10590: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 82E10594: 4800000C  b 0x82e105a0
	sub_82E10598(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E10598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E10598 size=20
    let mut pc: u32 = 0x82E10598;
    'dispatch: loop {
        match pc {
            0x82E10598 => {
    //   block [0x82E10598..0x82E105AC)
	// 82E10598: 9161FFF4  stw r11, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[11].u32 ) };
	// 82E1059C: 3961FFF4  addi r11, r1, -0xc
	ctx.r[11].s64 = ctx.r[1].s64 + -12;
	// 82E105A0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E105A4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E105A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E105B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E105B0 size=1372
    let mut pc: u32 = 0x82E105B0;
    'dispatch: loop {
        match pc {
            0x82E105B0 => {
    //   block [0x82E105B0..0x82E10B0C)
	// 82E105B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E105B4: 48397BA1  bl 0x831a8154
	ctx.lr = 0x82E105B8;
	sub_831A8130(ctx, base);
	// 82E105B8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E105BC: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E105C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E105C4: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 82E105C8: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 82E105CC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E105D0: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82E105D4: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E105D8: 4B4B3E89  bl 0x822c4460
	ctx.lr = 0x82E105DC;
	sub_822C4460(ctx, base);
	// 82E105DC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E105E0: 3B1F0010  addi r24, r31, 0x10
	ctx.r[24].s64 = ctx.r[31].s64 + 16;
	// 82E105E4: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 82E105E8: 38780004  addi r3, r24, 4
	ctx.r[3].s64 = ctx.r[24].s64 + 4;
	// 82E105EC: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82E105F0: 4B4B3E71  bl 0x822c4460
	ctx.lr = 0x82E105F4;
	sub_822C4460(ctx, base);
	// 82E105F4: 3BA000FF  li r29, 0xff
	ctx.r[29].s64 = 255;
	// 82E105F8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E105FC: 9BBF00E0  stb r29, 0xe0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[29].u8 ) };
	// 82E10600: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E10604: 3B9F00E0  addi r28, r31, 0xe0
	ctx.r[28].s64 = ctx.r[31].s64 + 224;
	// 82E10608: 835F0018  lwz r26, 0x18(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E1060C: 837F0008  lwz r27, 8(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E10610: 3BDB000C  addi r30, r27, 0xc
	ctx.r[30].s64 = ctx.r[27].s64 + 12;
	// 82E10614: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82E10618: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E1061C: 4BFFFF15  bl 0x82e10530
	ctx.lr = 0x82E10620;
	sub_82E10530(ctx, base);
	// 82E10620: 815B0010  lwz r10, 0x10(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E10624: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E10628: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E1062C: 419A0018  beq cr6, 0x82e10644
	if ctx.cr[6].eq {
	pc = 0x82E10644; continue 'dispatch;
	}
	// 82E10630: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E10634: 392B0010  addi r9, r11, 0x10
	ctx.r[9].s64 = ctx.r[11].s64 + 16;
	// 82E10638: 995C0000  stb r10, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E1063C: 896B0011  lbz r11, 0x11(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82E10640: 997C0001  stb r11, 1(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 82E10644: 82FF0020  lwz r23, 0x20(r31)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E10648: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E1064C: 9BBF00E2  stb r29, 0xe2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(226 as u32), ctx.r[29].u8 ) };
	// 82E10650: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E10654: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E10658: 3B9F00E2  addi r28, r31, 0xe2
	ctx.r[28].s64 = ctx.r[31].s64 + 226;
	// 82E1065C: 92E10054  stw r23, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[23].u32 ) };
	// 82E10660: 4BFFFED1  bl 0x82e10530
	ctx.lr = 0x82E10664;
	sub_82E10530(ctx, base);
	// 82E10664: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E10668: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E1066C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E10670: 419A0018  beq cr6, 0x82e10688
	if ctx.cr[6].eq {
	pc = 0x82E10688; continue 'dispatch;
	}
	// 82E10674: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E10678: 392B0010  addi r9, r11, 0x10
	ctx.r[9].s64 = ctx.r[11].s64 + 16;
	// 82E1067C: 995C0000  stb r10, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E10680: 896B0011  lbz r11, 0x11(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82E10684: 997C0001  stb r11, 1(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 82E10688: 833F0024  lwz r25, 0x24(r31)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E1068C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E10690: 9BBF00E4  stb r29, 0xe4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[29].u8 ) };
	// 82E10694: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E10698: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E1069C: 3B9F00E4  addi r28, r31, 0xe4
	ctx.r[28].s64 = ctx.r[31].s64 + 228;
	// 82E106A0: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 82E106A4: 4BFFFE8D  bl 0x82e10530
	ctx.lr = 0x82E106A8;
	sub_82E10530(ctx, base);
	// 82E106A8: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E106AC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E106B0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E106B4: 419A0018  beq cr6, 0x82e106cc
	if ctx.cr[6].eq {
	pc = 0x82E106CC; continue 'dispatch;
	}
	// 82E106B8: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E106BC: 392B0010  addi r9, r11, 0x10
	ctx.r[9].s64 = ctx.r[11].s64 + 16;
	// 82E106C0: 995C0000  stb r10, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E106C4: 896B0011  lbz r11, 0x11(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82E106C8: 997C0001  stb r11, 1(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 82E106CC: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E106D0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E106D4: 9BBF00E6  stb r29, 0xe6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(230 as u32), ctx.r[29].u8 ) };
	// 82E106D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E106DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E106E0: 3B9F00E6  addi r28, r31, 0xe6
	ctx.r[28].s64 = ctx.r[31].s64 + 230;
	// 82E106E4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E106E8: 4BFFFE49  bl 0x82e10530
	ctx.lr = 0x82E106EC;
	sub_82E10530(ctx, base);
	// 82E106EC: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E106F0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E106F4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E106F8: 419A0018  beq cr6, 0x82e10710
	if ctx.cr[6].eq {
	pc = 0x82E10710; continue 'dispatch;
	}
	// 82E106FC: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E10700: 392B0010  addi r9, r11, 0x10
	ctx.r[9].s64 = ctx.r[11].s64 + 16;
	// 82E10704: 995C0000  stb r10, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E10708: 896B0011  lbz r11, 0x11(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82E1070C: 997C0001  stb r11, 1(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 82E10710: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E10714: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E10718: 9BBF00E8  stb r29, 0xe8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[29].u8 ) };
	// 82E1071C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E10720: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E10724: 3B9F00E8  addi r28, r31, 0xe8
	ctx.r[28].s64 = ctx.r[31].s64 + 232;
	// 82E10728: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E1072C: 4BFFFE05  bl 0x82e10530
	ctx.lr = 0x82E10730;
	sub_82E10530(ctx, base);
	// 82E10730: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E10734: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E10738: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E1073C: 419A0018  beq cr6, 0x82e10754
	if ctx.cr[6].eq {
	pc = 0x82E10754; continue 'dispatch;
	}
	// 82E10740: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E10744: 392B0010  addi r9, r11, 0x10
	ctx.r[9].s64 = ctx.r[11].s64 + 16;
	// 82E10748: 995C0000  stb r10, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E1074C: 896B0011  lbz r11, 0x11(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82E10750: 997C0001  stb r11, 1(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 82E10754: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E10758: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E1075C: 9BBF00EA  stb r29, 0xea(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(234 as u32), ctx.r[29].u8 ) };
	// 82E10760: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E10764: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E10768: 3B9F00EA  addi r28, r31, 0xea
	ctx.r[28].s64 = ctx.r[31].s64 + 234;
	// 82E1076C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E10770: 4BFFFDC1  bl 0x82e10530
	ctx.lr = 0x82E10774;
	sub_82E10530(ctx, base);
	// 82E10774: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E10778: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E1077C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E10780: 419A0018  beq cr6, 0x82e10798
	if ctx.cr[6].eq {
	pc = 0x82E10798; continue 'dispatch;
	}
	// 82E10784: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E10788: 392B0010  addi r9, r11, 0x10
	ctx.r[9].s64 = ctx.r[11].s64 + 16;
	// 82E1078C: 995C0000  stb r10, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E10790: 896B0011  lbz r11, 0x11(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82E10794: 997C0001  stb r11, 1(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 82E10798: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E1079C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E107A0: 9BBF00EC  stb r29, 0xec(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[29].u8 ) };
	// 82E107A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E107A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E107AC: 3B9F00EC  addi r28, r31, 0xec
	ctx.r[28].s64 = ctx.r[31].s64 + 236;
	// 82E107B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E107B4: 4BFFFD7D  bl 0x82e10530
	ctx.lr = 0x82E107B8;
	sub_82E10530(ctx, base);
	// 82E107B8: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E107BC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E107C0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E107C4: 419A0018  beq cr6, 0x82e107dc
	if ctx.cr[6].eq {
	pc = 0x82E107DC; continue 'dispatch;
	}
	// 82E107C8: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E107CC: 392B0010  addi r9, r11, 0x10
	ctx.r[9].s64 = ctx.r[11].s64 + 16;
	// 82E107D0: 995C0000  stb r10, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E107D4: 896B0011  lbz r11, 0x11(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82E107D8: 997C0001  stb r11, 1(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 82E107DC: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E107E0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E107E4: 9BBF00EE  stb r29, 0xee(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(238 as u32), ctx.r[29].u8 ) };
	// 82E107E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E107EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E107F0: 3B9F00EE  addi r28, r31, 0xee
	ctx.r[28].s64 = ctx.r[31].s64 + 238;
	// 82E107F4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E107F8: 4BFFFD39  bl 0x82e10530
	ctx.lr = 0x82E107FC;
	sub_82E10530(ctx, base);
	// 82E107FC: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E10800: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E10804: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E10808: 419A0018  beq cr6, 0x82e10820
	if ctx.cr[6].eq {
	pc = 0x82E10820; continue 'dispatch;
	}
	// 82E1080C: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E10810: 392B0010  addi r9, r11, 0x10
	ctx.r[9].s64 = ctx.r[11].s64 + 16;
	// 82E10814: 995C0000  stb r10, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E10818: 896B0011  lbz r11, 0x11(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82E1081C: 997C0001  stb r11, 1(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 82E10820: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82E10824: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E10828: 9BBF00F0  stb r29, 0xf0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[29].u8 ) };
	// 82E1082C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E10830: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E10834: 3B9F00F0  addi r28, r31, 0xf0
	ctx.r[28].s64 = ctx.r[31].s64 + 240;
	// 82E10838: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E1083C: 4BFFFCF5  bl 0x82e10530
	ctx.lr = 0x82E10840;
	sub_82E10530(ctx, base);
	// 82E10840: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E10844: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E10848: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E1084C: 419A0018  beq cr6, 0x82e10864
	if ctx.cr[6].eq {
	pc = 0x82E10864; continue 'dispatch;
	}
	// 82E10850: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E10854: 392B0010  addi r9, r11, 0x10
	ctx.r[9].s64 = ctx.r[11].s64 + 16;
	// 82E10858: 995C0000  stb r10, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E1085C: 896B0011  lbz r11, 0x11(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82E10860: 997C0001  stb r11, 1(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 82E10864: 817F00D8  lwz r11, 0xd8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 82E10868: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E1086C: 9BBF00F4  stb r29, 0xf4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[29].u8 ) };
	// 82E10870: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E10874: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E10878: 3B9F00F4  addi r28, r31, 0xf4
	ctx.r[28].s64 = ctx.r[31].s64 + 244;
	// 82E1087C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E10880: 4BFFFCB1  bl 0x82e10530
	ctx.lr = 0x82E10884;
	sub_82E10530(ctx, base);
	// 82E10884: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E10888: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E1088C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E10890: 419A0018  beq cr6, 0x82e108a8
	if ctx.cr[6].eq {
	pc = 0x82E108A8; continue 'dispatch;
	}
	// 82E10894: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E10898: 392B0010  addi r9, r11, 0x10
	ctx.r[9].s64 = ctx.r[11].s64 + 16;
	// 82E1089C: 995C0000  stb r10, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E108A0: 896B0011  lbz r11, 0x11(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82E108A4: 997C0001  stb r11, 1(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 82E108A8: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E108AC: 389B0024  addi r4, r27, 0x24
	ctx.r[4].s64 = ctx.r[27].s64 + 36;
	// 82E108B0: 9BBF00F2  stb r29, 0xf2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(242 as u32), ctx.r[29].u8 ) };
	// 82E108B4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E108B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E108BC: 3BDF00F2  addi r30, r31, 0xf2
	ctx.r[30].s64 = ctx.r[31].s64 + 242;
	// 82E108C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E108C4: 4BFFFC6D  bl 0x82e10530
	ctx.lr = 0x82E108C8;
	sub_82E10530(ctx, base);
	// 82E108C8: 815B0028  lwz r10, 0x28(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 82E108CC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E108D0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E108D4: 419A0018  beq cr6, 0x82e108ec
	if ctx.cr[6].eq {
	pc = 0x82E108EC; continue 'dispatch;
	}
	// 82E108D8: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E108DC: 392B0010  addi r9, r11, 0x10
	ctx.r[9].s64 = ctx.r[11].s64 + 16;
	// 82E108E0: 995E0000  stb r10, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E108E4: 896B0011  lbz r11, 0x11(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82E108E8: 997E0001  stb r11, 1(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 82E108EC: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82E108F0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E108F4: 9BBF00F6  stb r29, 0xf6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(246 as u32), ctx.r[29].u8 ) };
	// 82E108F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E108FC: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E10900: 3B9F00F6  addi r28, r31, 0xf6
	ctx.r[28].s64 = ctx.r[31].s64 + 246;
	// 82E10904: 3BCB000C  addi r30, r11, 0xc
	ctx.r[30].s64 = ctx.r[11].s64 + 12;
	// 82E10908: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E1090C: 4BFFFC25  bl 0x82e10530
	ctx.lr = 0x82E10910;
	sub_82E10530(ctx, base);
	// 82E10910: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E10914: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E10918: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E1091C: 419A0018  beq cr6, 0x82e10934
	if ctx.cr[6].eq {
	pc = 0x82E10934; continue 'dispatch;
	}
	// 82E10920: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E10924: 392B0010  addi r9, r11, 0x10
	ctx.r[9].s64 = ctx.r[11].s64 + 16;
	// 82E10928: 995C0000  stb r10, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E1092C: 896B0011  lbz r11, 0x11(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82E10930: 997C0001  stb r11, 1(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 82E10934: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E10938: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E1093C: 9BBF00F8  stb r29, 0xf8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[29].u8 ) };
	// 82E10940: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E10944: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E10948: 3B9F00F8  addi r28, r31, 0xf8
	ctx.r[28].s64 = ctx.r[31].s64 + 248;
	// 82E1094C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E10950: 4BFFFBE1  bl 0x82e10530
	ctx.lr = 0x82E10954;
	sub_82E10530(ctx, base);
	// 82E10954: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E10958: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E1095C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E10960: 419A0018  beq cr6, 0x82e10978
	if ctx.cr[6].eq {
	pc = 0x82E10978; continue 'dispatch;
	}
	// 82E10964: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E10968: 392B0010  addi r9, r11, 0x10
	ctx.r[9].s64 = ctx.r[11].s64 + 16;
	// 82E1096C: 995C0000  stb r10, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E10970: 896B0011  lbz r11, 0x11(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82E10974: 997C0001  stb r11, 1(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 82E10978: 92E10054  stw r23, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[23].u32 ) };
	// 82E1097C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E10980: 9BBF00FA  stb r29, 0xfa(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(250 as u32), ctx.r[29].u8 ) };
	// 82E10984: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E10988: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E1098C: 3B9F00FA  addi r28, r31, 0xfa
	ctx.r[28].s64 = ctx.r[31].s64 + 250;
	// 82E10990: 4BFFFBA1  bl 0x82e10530
	ctx.lr = 0x82E10994;
	sub_82E10530(ctx, base);
	// 82E10994: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E10998: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E1099C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E109A0: 419A0018  beq cr6, 0x82e109b8
	if ctx.cr[6].eq {
	pc = 0x82E109B8; continue 'dispatch;
	}
	// 82E109A4: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E109A8: 392B0010  addi r9, r11, 0x10
	ctx.r[9].s64 = ctx.r[11].s64 + 16;
	// 82E109AC: 995C0000  stb r10, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E109B0: 896B0011  lbz r11, 0x11(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82E109B4: 997C0001  stb r11, 1(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 82E109B8: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 82E109BC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E109C0: 9BBF00FC  stb r29, 0xfc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[29].u8 ) };
	// 82E109C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E109C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E109CC: 3B9F00FC  addi r28, r31, 0xfc
	ctx.r[28].s64 = ctx.r[31].s64 + 252;
	// 82E109D0: 4BFFFB61  bl 0x82e10530
	ctx.lr = 0x82E109D4;
	sub_82E10530(ctx, base);
	// 82E109D4: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E109D8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E109DC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E109E0: 419A0018  beq cr6, 0x82e109f8
	if ctx.cr[6].eq {
	pc = 0x82E109F8; continue 'dispatch;
	}
	// 82E109E4: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E109E8: 392B0010  addi r9, r11, 0x10
	ctx.r[9].s64 = ctx.r[11].s64 + 16;
	// 82E109EC: 995C0000  stb r10, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E109F0: 896B0011  lbz r11, 0x11(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82E109F4: 997C0001  stb r11, 1(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 82E109F8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82E109FC: 3BDF0102  addi r30, r31, 0x102
	ctx.r[30].s64 = ctx.r[31].s64 + 258;
	// 82E10A00: 3B5F0078  addi r26, r31, 0x78
	ctx.r[26].s64 = ctx.r[31].s64 + 120;
	// 82E10A04: 3B3F010A  addi r25, r31, 0x10a
	ctx.r[25].s64 = ctx.r[31].s64 + 266;
	// 82E10A08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E10A0C: 9BBE0000  stb r29, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82E10A10: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E10A14: 7D79D9AE  stbx r11, r25, r27
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[25].u32.wrapping_add(ctx.r[27].u32), ctx.r[11].u8) };
	// 82E10A18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E10A1C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E10A20: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E10A24: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E10A28: 3B8B000C  addi r28, r11, 0xc
	ctx.r[28].s64 = ctx.r[11].s64 + 12;
	// 82E10A2C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E10A30: 4BFFFB01  bl 0x82e10530
	ctx.lr = 0x82E10A34;
	sub_82E10530(ctx, base);
	// 82E10A34: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E10A38: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E10A3C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E10A40: 419A0018  beq cr6, 0x82e10a58
	if ctx.cr[6].eq {
	pc = 0x82E10A58; continue 'dispatch;
	}
	// 82E10A44: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E10A48: 392B0010  addi r9, r11, 0x10
	ctx.r[9].s64 = ctx.r[11].s64 + 16;
	// 82E10A4C: 995E0000  stb r10, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E10A50: 896B0011  lbz r11, 0x11(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82E10A54: 997E0001  stb r11, 1(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 82E10A58: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82E10A5C: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 82E10A60: 3BDE0002  addi r30, r30, 2
	ctx.r[30].s64 = ctx.r[30].s64 + 2;
	// 82E10A64: 2F1B0004  cmpwi cr6, r27, 4
	ctx.cr[6].compare_i32(ctx.r[27].s32, 4, &mut ctx.xer);
	// 82E10A68: 4198FFA0  blt cr6, 0x82e10a08
	if ctx.cr[6].lt {
	pc = 0x82E10A08; continue 'dispatch;
	}
	// 82E10A6C: 815F00D0  lwz r10, 0xd0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 82E10A70: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E10A74: 9BBF00FE  stb r29, 0xfe(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(254 as u32), ctx.r[29].u8 ) };
	// 82E10A78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E10A7C: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E10A80: 3B9F00FE  addi r28, r31, 0xfe
	ctx.r[28].s64 = ctx.r[31].s64 + 254;
	// 82E10A84: 3BCB000C  addi r30, r11, 0xc
	ctx.r[30].s64 = ctx.r[11].s64 + 12;
	// 82E10A88: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82E10A8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E10A90: 4BFFFAA1  bl 0x82e10530
	ctx.lr = 0x82E10A94;
	sub_82E10530(ctx, base);
	// 82E10A94: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E10A98: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E10A9C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E10AA0: 419A0018  beq cr6, 0x82e10ab8
	if ctx.cr[6].eq {
	pc = 0x82E10AB8; continue 'dispatch;
	}
	// 82E10AA4: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E10AA8: 392B0010  addi r9, r11, 0x10
	ctx.r[9].s64 = ctx.r[11].s64 + 16;
	// 82E10AAC: 995C0000  stb r10, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E10AB0: 896B0011  lbz r11, 0x11(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82E10AB4: 997C0001  stb r11, 1(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 82E10AB8: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 82E10ABC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E10AC0: 9BBF0100  stb r29, 0x100(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[29].u8 ) };
	// 82E10AC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E10AC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E10ACC: 3B9F0100  addi r28, r31, 0x100
	ctx.r[28].s64 = ctx.r[31].s64 + 256;
	// 82E10AD0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E10AD4: 4BFFFA5D  bl 0x82e10530
	ctx.lr = 0x82E10AD8;
	sub_82E10530(ctx, base);
	// 82E10AD8: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E10ADC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E10AE0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E10AE4: 419A0018  beq cr6, 0x82e10afc
	if ctx.cr[6].eq {
	pc = 0x82E10AFC; continue 'dispatch;
	}
	// 82E10AE8: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E10AEC: 392B0010  addi r9, r11, 0x10
	ctx.r[9].s64 = ctx.r[11].s64 + 16;
	// 82E10AF0: 995C0000  stb r10, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82E10AF4: 896B0011  lbz r11, 0x11(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82E10AF8: 997C0001  stb r11, 1(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 82E10AFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E10B00: 997F010E  stb r11, 0x10e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(270 as u32), ctx.r[11].u8 ) };
	// 82E10B04: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E10B08: 4839769C  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E10B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E10B10 size=204
    let mut pc: u32 = 0x82E10B10;
    'dispatch: loop {
        match pc {
            0x82E10B10 => {
    //   block [0x82E10B10..0x82E10BDC)
	// 82E10B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E10B14: 48397659  bl 0x831a816c
	ctx.lr = 0x82E10B18;
	sub_831A8130(ctx, base);
	// 82E10B18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E10B1C: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 82E10B20: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E10B24: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82E10B28: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E10B2C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E10B30: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E10B34: 3BCB000C  addi r30, r11, 0xc
	ctx.r[30].s64 = ctx.r[11].s64 + 12;
	// 82E10B38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E10B3C: 4BFFF9F5  bl 0x82e10530
	ctx.lr = 0x82E10B40;
	sub_82E10530(ctx, base);
	// 82E10B40: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E10B44: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E10B48: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E10B4C: 419A0014  beq cr6, 0x82e10b60
	if ctx.cr[6].eq {
	pc = 0x82E10B60; continue 'dispatch;
	}
	// 82E10B50: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E10B54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E10B58: B1410050  sth r10, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u16 ) };
	// 82E10B5C: 48000008  b 0x82e10b64
	pc = 0x82E10B64; continue 'dispatch;
	// 82E10B60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E10B64: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E10B68: 4182006C  beq 0x82e10bd4
	if ctx.cr[0].eq {
	pc = 0x82E10BD4; continue 'dispatch;
	}
	// 82E10B6C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E10B70: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E10B74: 811D0000  lwz r8, 0(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E10B78: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82E10B7C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82E10B80: 5566F0BE  srwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82E10B84: 394A0078  addi r10, r10, 0x78
	ctx.r[10].s64 = ctx.r[10].s64 + 120;
	// 82E10B88: 5569203E  rotlwi r9, r11, 4
	ctx.r[9].u64 = ((ctx.r[11].u32).rotate_left(4)) as u64;
	// 82E10B8C: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E10B90: 55482036  slwi r8, r10, 4
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82E10B94: 7CA63050  subf r5, r6, r6
	ctx.r[5].s64 = ctx.r[6].s64 - ctx.r[6].s64;
	// 82E10B98: 7D495A14  add r10, r9, r11
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82E10B9C: 78E9FFE6  rldicr r9, r7, 0x3f, 0x3f
	ctx.r[9].u64 = (ctx.r[7].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82E10BA0: 78A70020  clrldi r7, r5, 0x20
	ctx.r[7].u64 = ctx.r[5].u64 & 0x00000000FFFFFFFFu64;
	// 82E10BA4: 7C085D2E  stfsx f0, r8, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82E10BA8: 7D293E34  srad r9, r9, r7
	tmp.u64 = (ctx.r[7].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[9].s64 < 0) && ((ctx.r[9].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[9].s64 = ctx.r[9].s64 >> tmp.u64;
	// 82E10BAC: 7D293436  srd r9, r9, r6
	if (ctx.r[6].u8 & 0x40) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = (ctx.r[9].u64) >> ((ctx.r[6].u8 & 0x3F) as u32);
	}
	// 82E10BB0: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E10BB4: D00A0784  stfs f0, 0x784(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1924 as u32), tmp.u32 ) };
	// 82E10BB8: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E10BBC: D00A0788  stfs f0, 0x788(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1928 as u32), tmp.u32 ) };
	// 82E10BC0: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E10BC4: D00A078C  stfs f0, 0x78c(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1932 as u32), tmp.u32 ) };
	// 82E10BC8: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82E10BCC: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82E10BD0: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82E10BD4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E10BD8: 483975E4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E10BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E10BE0 size=164
    let mut pc: u32 = 0x82E10BE0;
    'dispatch: loop {
        match pc {
            0x82E10BE0 => {
    //   block [0x82E10BE0..0x82E10C84)
	// 82E10BE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E10BE4: 48397589  bl 0x831a816c
	ctx.lr = 0x82E10BE8;
	sub_831A8130(ctx, base);
	// 82E10BE8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E10BEC: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 82E10BF0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E10BF4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E10BF8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E10BFC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E10C00: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E10C04: 3BEB000C  addi r31, r11, 0xc
	ctx.r[31].s64 = ctx.r[11].s64 + 12;
	// 82E10C08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E10C0C: 4BFFF925  bl 0x82e10530
	ctx.lr = 0x82E10C10;
	sub_82E10530(ctx, base);
	// 82E10C10: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E10C14: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E10C18: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E10C1C: 419A0014  beq cr6, 0x82e10c30
	if ctx.cr[6].eq {
	pc = 0x82E10C30; continue 'dispatch;
	}
	// 82E10C20: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E10C24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E10C28: B1410050  sth r10, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u16 ) };
	// 82E10C2C: 48000008  b 0x82e10c34
	pc = 0x82E10C34; continue 'dispatch;
	// 82E10C30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E10C34: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E10C38: 41820044  beq 0x82e10c7c
	if ctx.cr[0].eq {
	pc = 0x82E10C7C; continue 'dispatch;
	}
	// 82E10C3C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E10C40: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E10C44: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E10C48: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82E10C4C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82E10C50: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E10C54: 39040003  addi r8, r4, 3
	ctx.r[8].s64 = ctx.r[4].s64 + 3;
	// 82E10C58: 794AFFE6  rldicr r10, r10, 0x3f, 0x3f
	ctx.r[10].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82E10C5C: 5508F0BE  srwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82E10C60: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E10C64: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E10C68: 7D2B4050  subf r9, r11, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82E10C6C: 79290020  clrldi r9, r9, 0x20
	ctx.r[9].u64 = ctx.r[9].u64 & 0x00000000FFFFFFFFu64;
	// 82E10C70: 7D4A4E34  srad r10, r10, r9
	tmp.u64 = (ctx.r[9].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[10].s64 < 0) && ((ctx.r[10].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[10].s64 = ctx.r[10].s64 >> tmp.u64;
	// 82E10C74: 7D475C36  srd r7, r10, r11
	if (ctx.r[11].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[10].u64) >> ((ctx.r[11].u8 & 0x3F) as u32);
	}
	// 82E10C78: 4BDC7419  bl 0x82bd8090
	ctx.lr = 0x82E10C7C;
	sub_82BD8090(ctx, base);
	// 82E10C7C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E10C80: 4839753C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E10C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E10C88 size=132
    let mut pc: u32 = 0x82E10C88;
    'dispatch: loop {
        match pc {
            0x82E10C88 => {
    //   block [0x82E10C88..0x82E10D0C)
	// 82E10C88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E10C8C: 483974E1  bl 0x831a816c
	ctx.lr = 0x82E10C90;
	sub_831A8130(ctx, base);
	// 82E10C90: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E10C94: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 82E10C98: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E10C9C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E10CA0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E10CA4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E10CA8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E10CAC: 3BEB0024  addi r31, r11, 0x24
	ctx.r[31].s64 = ctx.r[11].s64 + 36;
	// 82E10CB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E10CB4: 4BFFF87D  bl 0x82e10530
	ctx.lr = 0x82E10CB8;
	sub_82E10530(ctx, base);
	// 82E10CB8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E10CBC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E10CC0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E10CC4: 419A0014  beq cr6, 0x82e10cd8
	if ctx.cr[6].eq {
	pc = 0x82E10CD8; continue 'dispatch;
	}
	// 82E10CC8: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E10CCC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E10CD0: B1410050  sth r10, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u16 ) };
	// 82E10CD4: 48000008  b 0x82e10cdc
	pc = 0x82E10CDC; continue 'dispatch;
	// 82E10CD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E10CDC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E10CE0: 41820024  beq 0x82e10d04
	if ctx.cr[0].eq {
	pc = 0x82E10D04; continue 'dispatch;
	}
	// 82E10CE4: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82E10CE8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E10CEC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82E10CF0: 88810050  lbz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E10CF4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82E10CF8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82E10CFC: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E10D00: 4BDC7551  bl 0x82bd8250
	ctx.lr = 0x82E10D04;
	sub_82BD8250(ctx, base);
	// 82E10D04: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E10D08: 483974B4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E10D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E10D10 size=168
    let mut pc: u32 = 0x82E10D10;
    'dispatch: loop {
        match pc {
            0x82E10D10 => {
    //   block [0x82E10D10..0x82E10DB8)
	// 82E10D10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E10D14: 48397455  bl 0x831a8168
	ctx.lr = 0x82E10D18;
	sub_831A8130(ctx, base);
	// 82E10D18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E10D1C: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 82E10D20: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E10D24: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82E10D28: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E10D2C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E10D30: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82E10D34: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E10D38: 3BEB000C  addi r31, r11, 0xc
	ctx.r[31].s64 = ctx.r[11].s64 + 12;
	// 82E10D3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E10D40: 4BFFF7F1  bl 0x82e10530
	ctx.lr = 0x82E10D44;
	sub_82E10530(ctx, base);
	// 82E10D44: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E10D48: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E10D4C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E10D50: 419A0014  beq cr6, 0x82e10d64
	if ctx.cr[6].eq {
	pc = 0x82E10D64; continue 'dispatch;
	}
	// 82E10D54: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E10D58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E10D5C: B1410050  sth r10, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u16 ) };
	// 82E10D60: 48000008  b 0x82e10d68
	pc = 0x82E10D68; continue 'dispatch;
	// 82E10D64: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E10D68: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E10D6C: 41820044  beq 0x82e10db0
	if ctx.cr[0].eq {
	pc = 0x82E10DB0; continue 'dispatch;
	}
	// 82E10D70: 88810050  lbz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E10D74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E10D78: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E10D7C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82E10D80: 7D64EA14  add r11, r4, r29
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[29].u64;
	// 82E10D84: 5488F0BE  srwi r8, r4, 2
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shr(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82E10D88: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E10D8C: 794AFFE6  rldicr r10, r10, 0x3f, 0x3f
	ctx.r[10].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82E10D90: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E10D94: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E10D98: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82E10D9C: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82E10DA0: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82E10DA4: 7D4B5E34  srad r11, r10, r11
	tmp.u64 = (ctx.r[11].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[10].s64 < 0) && ((ctx.r[10].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[11].s64 = ctx.r[10].s64 >> tmp.u64;
	// 82E10DA8: 7D674436  srd r7, r11, r8
	if (ctx.r[8].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[11].u64) >> ((ctx.r[8].u8 & 0x3F) as u32);
	}
	// 82E10DAC: 4BDC73C5  bl 0x82bd8170
	ctx.lr = 0x82E10DB0;
	sub_82BD8170(ctx, base);
	// 82E10DB0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E10DB4: 48397404  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E10DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E10DB8 size=244
    let mut pc: u32 = 0x82E10DB8;
    'dispatch: loop {
        match pc {
            0x82E10DB8 => {
    //   block [0x82E10DB8..0x82E10EAC)
	// 82E10DB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E10DBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E10DC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E10DC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E10DC8: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82E10DCC: 48397CAD  bl 0x831a8a78
	ctx.lr = 0x82E10DD0;
	sub_831A8A40(ctx, base);
	// 82E10DD0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E10DD4: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 82E10DD8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E10DDC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E10DE0: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82E10DE4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E10DE8: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82E10DEC: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 82E10DF0: FF802090  fmr f28, f4
	ctx.f[28].f64 = ctx.f[4].f64;
	// 82E10DF4: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E10DF8: 3BEB000C  addi r31, r11, 0xc
	ctx.r[31].s64 = ctx.r[11].s64 + 12;
	// 82E10DFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E10E00: 4BFFF731  bl 0x82e10530
	ctx.lr = 0x82E10E04;
	sub_82E10530(ctx, base);
	// 82E10E04: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E10E08: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E10E0C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E10E10: 419A0014  beq cr6, 0x82e10e24
	if ctx.cr[6].eq {
	pc = 0x82E10E24; continue 'dispatch;
	}
	// 82E10E14: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E10E18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E10E1C: B1410050  sth r10, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u16 ) };
	// 82E10E20: 48000008  b 0x82e10e28
	pc = 0x82E10E28; continue 'dispatch;
	// 82E10E24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E10E28: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E10E2C: 41820060  beq 0x82e10e8c
	if ctx.cr[0].eq {
	pc = 0x82E10E8C; continue 'dispatch;
	}
	// 82E10E30: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E10E34: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E10E38: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E10E3C: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E10E40: 7947FFE6  rldicr r7, r10, 0x3f, 0x3f
	ctx.r[7].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82E10E44: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82E10E48: 5566F0BE  srwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82E10E4C: 5569203E  rotlwi r9, r11, 4
	ctx.r[9].u64 = ((ctx.r[11].u32).rotate_left(4)) as u64;
	// 82E10E50: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E10E54: 390A0178  addi r8, r10, 0x178
	ctx.r[8].s64 = ctx.r[10].s64 + 376;
	// 82E10E58: 7D495A14  add r10, r9, r11
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82E10E5C: 55092036  slwi r9, r8, 4
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E10E60: 7D063050  subf r8, r6, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[6].s64;
	// 82E10E64: 79080020  clrldi r8, r8, 0x20
	ctx.r[8].u64 = ctx.r[8].u64 & 0x00000000FFFFFFFFu64;
	// 82E10E68: D38A178C  stfs f28, 0x178c(r10)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(6028 as u32), tmp.u32 ) };
	// 82E10E6C: D3CA1784  stfs f30, 0x1784(r10)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(6020 as u32), tmp.u32 ) };
	// 82E10E70: D3AA1788  stfs f29, 0x1788(r10)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(6024 as u32), tmp.u32 ) };
	// 82E10E74: 7FE95D2E  stfsx f31, r9, r11
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82E10E78: 7CE94634  srad r9, r7, r8
	tmp.u64 = (ctx.r[8].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[7].s64 < 0) && ((ctx.r[7].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[9].s64 = ctx.r[7].s64 >> tmp.u64;
	// 82E10E7C: 7D2A3436  srd r10, r9, r6
	if (ctx.r[6].u8 & 0x40) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = (ctx.r[9].u64) >> ((ctx.r[6].u8 & 0x3F) as u32);
	}
	// 82E10E80: E92B0008  ld r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82E10E84: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82E10E88: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82E10E8C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E10E90: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82E10E94: 48397C31  bl 0x831a8ac4
	ctx.lr = 0x82E10E98;
	sub_831A8A8C(ctx, base);
	// 82E10E98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E10E9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E10EA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E10EA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E10EA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E10EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E10EB0 size=204
    let mut pc: u32 = 0x82E10EB0;
    'dispatch: loop {
        match pc {
            0x82E10EB0 => {
    //   block [0x82E10EB0..0x82E10F7C)
	// 82E10EB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E10EB4: 483972B9  bl 0x831a816c
	ctx.lr = 0x82E10EB8;
	sub_831A8130(ctx, base);
	// 82E10EB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E10EBC: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 82E10EC0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E10EC4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82E10EC8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E10ECC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E10ED0: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E10ED4: 3BCB000C  addi r30, r11, 0xc
	ctx.r[30].s64 = ctx.r[11].s64 + 12;
	// 82E10ED8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E10EDC: 4BFFF655  bl 0x82e10530
	ctx.lr = 0x82E10EE0;
	sub_82E10530(ctx, base);
	// 82E10EE0: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E10EE4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E10EE8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E10EEC: 419A0014  beq cr6, 0x82e10f00
	if ctx.cr[6].eq {
	pc = 0x82E10F00; continue 'dispatch;
	}
	// 82E10EF0: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E10EF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E10EF8: B1410050  sth r10, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u16 ) };
	// 82E10EFC: 48000008  b 0x82e10f04
	pc = 0x82E10F04; continue 'dispatch;
	// 82E10F00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E10F04: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E10F08: 4182006C  beq 0x82e10f74
	if ctx.cr[0].eq {
	pc = 0x82E10F74; continue 'dispatch;
	}
	// 82E10F0C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E10F10: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E10F14: 811D0000  lwz r8, 0(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E10F18: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82E10F1C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82E10F20: 5566F0BE  srwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82E10F24: 394A0178  addi r10, r10, 0x178
	ctx.r[10].s64 = ctx.r[10].s64 + 376;
	// 82E10F28: 5569203E  rotlwi r9, r11, 4
	ctx.r[9].u64 = ((ctx.r[11].u32).rotate_left(4)) as u64;
	// 82E10F2C: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E10F30: 55482036  slwi r8, r10, 4
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82E10F34: 7CA63050  subf r5, r6, r6
	ctx.r[5].s64 = ctx.r[6].s64 - ctx.r[6].s64;
	// 82E10F38: 7D495A14  add r10, r9, r11
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82E10F3C: 78E9FFE6  rldicr r9, r7, 0x3f, 0x3f
	ctx.r[9].u64 = (ctx.r[7].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82E10F40: 78A70020  clrldi r7, r5, 0x20
	ctx.r[7].u64 = ctx.r[5].u64 & 0x00000000FFFFFFFFu64;
	// 82E10F44: 7C085D2E  stfsx f0, r8, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82E10F48: 7D293E34  srad r9, r9, r7
	tmp.u64 = (ctx.r[7].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[9].s64 < 0) && ((ctx.r[9].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[9].s64 = ctx.r[9].s64 >> tmp.u64;
	// 82E10F4C: 7D293436  srd r9, r9, r6
	if (ctx.r[6].u8 & 0x40) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = (ctx.r[9].u64) >> ((ctx.r[6].u8 & 0x3F) as u32);
	}
	// 82E10F50: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E10F54: D00A1784  stfs f0, 0x1784(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(6020 as u32), tmp.u32 ) };
	// 82E10F58: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E10F5C: D00A1788  stfs f0, 0x1788(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(6024 as u32), tmp.u32 ) };
	// 82E10F60: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E10F64: D00A178C  stfs f0, 0x178c(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(6028 as u32), tmp.u32 ) };
	// 82E10F68: E94B0008  ld r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82E10F6C: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82E10F70: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82E10F74: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E10F78: 48397244  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E10F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E10F80 size=132
    let mut pc: u32 = 0x82E10F80;
    'dispatch: loop {
        match pc {
            0x82E10F80 => {
    //   block [0x82E10F80..0x82E11004)
	// 82E10F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E10F84: 483971E9  bl 0x831a816c
	ctx.lr = 0x82E10F88;
	sub_831A8130(ctx, base);
	// 82E10F88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E10F8C: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 82E10F90: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E10F94: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E10F98: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E10F9C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E10FA0: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E10FA4: 3BEB0024  addi r31, r11, 0x24
	ctx.r[31].s64 = ctx.r[11].s64 + 36;
	// 82E10FA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E10FAC: 4BFFF585  bl 0x82e10530
	ctx.lr = 0x82E10FB0;
	sub_82E10530(ctx, base);
	// 82E10FB0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E10FB4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E10FB8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E10FBC: 419A0014  beq cr6, 0x82e10fd0
	if ctx.cr[6].eq {
	pc = 0x82E10FD0; continue 'dispatch;
	}
	// 82E10FC0: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E10FC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E10FC8: B1410050  sth r10, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u16 ) };
	// 82E10FCC: 48000008  b 0x82e10fd4
	pc = 0x82E10FD4; continue 'dispatch;
	// 82E10FD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E10FD4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E10FD8: 41820024  beq 0x82e10ffc
	if ctx.cr[0].eq {
	pc = 0x82E10FFC; continue 'dispatch;
	}
	// 82E10FDC: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82E10FE0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E10FE4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82E10FE8: 88810050  lbz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E10FEC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82E10FF0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82E10FF4: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E10FF8: 4BDC72B9  bl 0x82bd82b0
	ctx.lr = 0x82E10FFC;
	sub_82BD82B0(ctx, base);
	// 82E10FFC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E11000: 483971BC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E11008 size=80
    let mut pc: u32 = 0x82E11008;
    'dispatch: loop {
        match pc {
            0x82E11008 => {
    //   block [0x82E11008..0x82E11058)
	// 82E11008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E1100C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E11010: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E11014: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E11018: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E1101C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E11020: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E11024: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E11028: 809F0030  lwz r4, 0x30(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E1102C: 4BFFFAE5  bl 0x82e10b10
	ctx.lr = 0x82E11030;
	sub_82E10B10(ctx, base);
	// 82E11030: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E11034: 809F0030  lwz r4, 0x30(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E11038: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E1103C: 4BFFFE75  bl 0x82e10eb0
	ctx.lr = 0x82E11040;
	sub_82E10EB0(ctx, base);
	// 82E11040: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E11044: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E11048: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E1104C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E11050: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E11054: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E11058 size=80
    let mut pc: u32 = 0x82E11058;
    'dispatch: loop {
        match pc {
            0x82E11058 => {
    //   block [0x82E11058..0x82E110A8)
	// 82E11058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E1105C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E11060: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E11064: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E11068: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E1106C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E11070: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E11074: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E11078: 809F0034  lwz r4, 0x34(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E1107C: 4BFFFA95  bl 0x82e10b10
	ctx.lr = 0x82E11080;
	sub_82E10B10(ctx, base);
	// 82E11080: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E11084: 809F0034  lwz r4, 0x34(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E11088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E1108C: 4BFFFE25  bl 0x82e10eb0
	ctx.lr = 0x82E11090;
	sub_82E10EB0(ctx, base);
	// 82E11090: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E11094: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E11098: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E1109C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E110A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E110A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E110A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E110A8 size=140
    let mut pc: u32 = 0x82E110A8;
    'dispatch: loop {
        match pc {
            0x82E110A8 => {
    //   block [0x82E110A8..0x82E11134)
	// 82E110A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E110AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E110B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E110B4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E110B8: 7C8A07B4  extsw r10, r4
	ctx.r[10].s64 = ctx.r[4].s32 as i64;
	// 82E110BC: 7CAB07B4  extsw r11, r5
	ctx.r[11].s64 = ctx.r[5].s32 as i64;
	// 82E110C0: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82E110C4: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E110C8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82E110CC: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82E110D0: FD60069C  fcfid f11, f0
	ctx.f[11].f64 = (ctx.f[0].s64 as f64);
	// 82E110D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E110D8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82E110DC: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E110E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E110E4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E110E8: 809F0038  lwz r4, 0x38(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E110EC: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82E110F0: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E110F4: FDA05818  frsp f13, f11
	ctx.f[13].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82E110F8: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E110FC: ED806024  fdivs f12, f0, f12
	ctx.f[12].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 82E11100: D181005C  stfs f12, 0x5c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82E11104: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82E11108: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E1110C: 4BFFFA05  bl 0x82e10b10
	ctx.lr = 0x82E11110;
	sub_82E10B10(ctx, base);
	// 82E11110: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E11114: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E11118: 809F0038  lwz r4, 0x38(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E1111C: 4BFFFD95  bl 0x82e10eb0
	ctx.lr = 0x82E11120;
	sub_82E10EB0(ctx, base);
	// 82E11120: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E11124: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E11128: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E1112C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E11130: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E11138 size=92
    let mut pc: u32 = 0x82E11138;
    'dispatch: loop {
        match pc {
            0x82E11138 => {
    //   block [0x82E11138..0x82E11194)
	// 82E11138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E1113C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E11140: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E11144: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E11148: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82E1114C: D0210050  stfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82E11150: D0410054  stfs f2, 0x54(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82E11154: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E11158: D0610058  stfs f3, 0x58(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82E1115C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E11160: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E11164: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82E11168: 809F003C  lwz r4, 0x3c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E1116C: 4BFFF9A5  bl 0x82e10b10
	ctx.lr = 0x82E11170;
	sub_82E10B10(ctx, base);
	// 82E11170: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E11174: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E11178: 809F003C  lwz r4, 0x3c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E1117C: 4BFFFD35  bl 0x82e10eb0
	ctx.lr = 0x82E11180;
	sub_82E10EB0(ctx, base);
	// 82E11180: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E11184: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E11188: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E1118C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E11190: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E11198 size=12
    let mut pc: u32 = 0x82E11198;
    'dispatch: loop {
        match pc {
            0x82E11198 => {
    //   block [0x82E11198..0x82E111A4)
	// 82E11198: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82E1119C: 80830054  lwz r4, 0x54(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E111A0: 4BFFFA40  b 0x82e10be0
	sub_82E10BE0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E111A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E111A8 size=12
    let mut pc: u32 = 0x82E111A8;
    'dispatch: loop {
        match pc {
            0x82E111A8 => {
    //   block [0x82E111A8..0x82E111B4)
	// 82E111A8: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82E111AC: 80830058  lwz r4, 0x58(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E111B0: 4BFFFA30  b 0x82e10be0
	sub_82E10BE0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E111B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E111B8 size=80
    let mut pc: u32 = 0x82E111B8;
    'dispatch: loop {
        match pc {
            0x82E111B8 => {
    //   block [0x82E111B8..0x82E11208)
	// 82E111B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E111BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E111C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E111C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E111C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E111CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E111D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E111D4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E111D8: 809F005C  lwz r4, 0x5c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E111DC: 4BFFF935  bl 0x82e10b10
	ctx.lr = 0x82E111E0;
	sub_82E10B10(ctx, base);
	// 82E111E0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E111E4: 809F005C  lwz r4, 0x5c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E111E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E111EC: 4BFFFCC5  bl 0x82e10eb0
	ctx.lr = 0x82E111F0;
	sub_82E10EB0(ctx, base);
	// 82E111F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E111F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E111F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E111FC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E11200: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E11204: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E11208 size=80
    let mut pc: u32 = 0x82E11208;
    'dispatch: loop {
        match pc {
            0x82E11208 => {
    //   block [0x82E11208..0x82E11258)
	// 82E11208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E1120C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E11210: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E11214: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E11218: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E1121C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E11220: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E11224: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E11228: 809F0060  lwz r4, 0x60(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82E1122C: 4BFFF8E5  bl 0x82e10b10
	ctx.lr = 0x82E11230;
	sub_82E10B10(ctx, base);
	// 82E11230: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E11234: 809F0060  lwz r4, 0x60(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82E11238: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E1123C: 4BFFFC75  bl 0x82e10eb0
	ctx.lr = 0x82E11240;
	sub_82E10EB0(ctx, base);
	// 82E11240: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E11244: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E11248: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E1124C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E11250: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E11254: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E11258 size=80
    let mut pc: u32 = 0x82E11258;
    'dispatch: loop {
        match pc {
            0x82E11258 => {
    //   block [0x82E11258..0x82E112A8)
	// 82E11258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E1125C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E11260: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E11264: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E11268: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E1126C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E11270: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E11274: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E11278: 809F0064  lwz r4, 0x64(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E1127C: 4BFFF895  bl 0x82e10b10
	ctx.lr = 0x82E11280;
	sub_82E10B10(ctx, base);
	// 82E11280: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E11284: 809F0064  lwz r4, 0x64(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82E11288: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E1128C: 4BFFFC25  bl 0x82e10eb0
	ctx.lr = 0x82E11290;
	sub_82E10EB0(ctx, base);
	// 82E11290: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E11294: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E11298: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E1129C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E112A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E112A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E112A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E112A8 size=192
    let mut pc: u32 = 0x82E112A8;
    'dispatch: loop {
        match pc {
            0x82E112A8 => {
    //   block [0x82E112A8..0x82E11368)
	// 82E112A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E112AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E112B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E112B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E112B8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E112BC: 39400044  li r10, 0x44
	ctx.r[10].s64 = 68;
	// 82E112C0: 39200040  li r9, 0x40
	ctx.r[9].s64 = 64;
	// 82E112C4: 3900004C  li r8, 0x4c
	ctx.r[8].s64 = 76;
	// 82E112C8: 38E00048  li r7, 0x48
	ctx.r[7].s64 = 72;
	// 82E112CC: 39650010  addi r11, r5, 0x10
	ctx.r[11].s64 = ctx.r[5].s64 + 16;
	// 82E112D0: 13E55407  vcmpneb. (lvlx128) v31, v5, v10
	tmp.u32 = ctx.r[5].u32 + ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E112D4: 39450030  addi r10, r5, 0x30
	ctx.r[10].s64 = ctx.r[5].s64 + 48;
	// 82E112D8: 13C54C07  vcmpneb. (lvlx128) v30, v5, v9
	tmp.u32 = ctx.r[5].u32 + ctx.r[9].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E112DC: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E11368 size=140
    let mut pc: u32 = 0x82E11368;
    'dispatch: loop {
        match pc {
            0x82E11368 => {
    //   block [0x82E11368..0x82E113F4)
	// 82E11368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E1136C: 48396DF5  bl 0x831a8160
	ctx.lr = 0x82E11370;
	sub_831A8130(ctx, base);
	// 82E11370: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E11374: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E11378: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82E1137C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82E11380: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82E11384: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E11388: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E1138C: 419A0010  beq cr6, 0x82e1139c
	if ctx.cr[6].eq {
	pc = 0x82E1139C; continue 'dispatch;
	}
	// 82E11390: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E11394: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E11398: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82E1139C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E113A0: 419A004C  beq cr6, 0x82e113ec
	if ctx.cr[6].eq {
	pc = 0x82E113EC; continue 'dispatch;
	}
	// 82E113A4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E113A8: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82E113AC: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E113B0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82E113B4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82E113B8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E113BC: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E113C0: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 82E113C4: 480188AD  bl 0x82e29c70
	ctx.lr = 0x82E113C8;
	sub_82E29C70(ctx, base);
	// 82E113C8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E113CC: 41820014  beq 0x82e113e0
	if ctx.cr[0].eq {
	pc = 0x82E113E0; continue 'dispatch;
	}
	// 82E113D0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82E113D4: 88810050  lbz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E113D8: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E113DC: 4BFFD235  bl 0x82e0e610
	ctx.lr = 0x82E113E0;
	sub_82E0E610(ctx, base);
	// 82E113E0: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82E113E4: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82E113E8: 4082FFC4  bne 0x82e113ac
	if !ctx.cr[0].eq {
	pc = 0x82E113AC; continue 'dispatch;
	}
	// 82E113EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E113F0: 48396DC0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E113F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E113F8 size=136
    let mut pc: u32 = 0x82E113F8;
    'dispatch: loop {
        match pc {
            0x82E113F8 => {
    //   block [0x82E113F8..0x82E11480)
	// 82E113F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E113FC: 48396D69  bl 0x831a8164
	ctx.lr = 0x82E11400;
	sub_831A8130(ctx, base);
	// 82E11400: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E11404: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E11408: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E1140C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82E11410: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E11414: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E11418: 419A0010  beq cr6, 0x82e11428
	if ctx.cr[6].eq {
	pc = 0x82E11428; continue 'dispatch;
	}
	// 82E1141C: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E11420: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E11424: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82E11428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E1142C: 419A004C  beq cr6, 0x82e11478
	if ctx.cr[6].eq {
	pc = 0x82E11478; continue 'dispatch;
	}
	// 82E11430: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E11434: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82E11438: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E1143C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82E11440: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82E11444: 809C002C  lwz r4, 0x2c(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E11448: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E1144C: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 82E11450: 48018821  bl 0x82e29c70
	ctx.lr = 0x82E11454;
	sub_82E29C70(ctx, base);
	// 82E11454: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E11458: 41820014  beq 0x82e1146c
	if ctx.cr[0].eq {
	pc = 0x82E1146C; continue 'dispatch;
	}
	// 82E1145C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82E11460: 88810050  lbz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E11464: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E11468: 4BFFD0E1  bl 0x82e0e548
	ctx.lr = 0x82E1146C;
	sub_82E0E548(ctx, base);
	// 82E1146C: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82E11470: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82E11474: 4082FFC4  bne 0x82e11438
	if !ctx.cr[0].eq {
	pc = 0x82E11438; continue 'dispatch;
	}
	// 82E11478: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E1147C: 48396D38  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E11480 size=156
    let mut pc: u32 = 0x82E11480;
    'dispatch: loop {
        match pc {
            0x82E11480 => {
    //   block [0x82E11480..0x82E1151C)
	// 82E11480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E11484: 48396CE5  bl 0x831a8168
	ctx.lr = 0x82E11488;
	sub_831A8130(ctx, base);
	// 82E11488: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E1148C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82E11490: 807C000C  lwz r3, 0xc(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E11494: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E11498: 419A0018  beq cr6, 0x82e114b0
	if ctx.cr[6].eq {
	pc = 0x82E114B0; continue 'dispatch;
	}
	// 82E1149C: 480188A5  bl 0x82e29d40
	ctx.lr = 0x82E114A0;
	sub_82E29D40(ctx, base);
	// 82E114A0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E114A4: 4082000C  bne 0x82e114b0
	if !ctx.cr[0].eq {
	pc = 0x82E114B0; continue 'dispatch;
	}
	// 82E114A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82E114AC: 48000068  b 0x82e11514
	pc = 0x82E11514; continue 'dispatch;
	// 82E114B0: 817C001C  lwz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E114B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E114B8: 409A000C  bne cr6, 0x82e114c4
	if !ctx.cr[6].eq {
	pc = 0x82E114C4; continue 'dispatch;
	}
	// 82E114BC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E114C0: 48000010  b 0x82e114d0
	pc = 0x82E114D0; continue 'dispatch;
	// 82E114C4: 815C0020  lwz r10, 0x20(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E114C8: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E114CC: 7D7D1E70  srawi r29, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82E114D0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E114D4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82E114D8: 419A0038  beq cr6, 0x82e11510
	if ctx.cr[6].eq {
	pc = 0x82E11510; continue 'dispatch;
	}
	// 82E114DC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E114E0: 817C001C  lwz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E114E4: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82E114E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E114EC: 419A0014  beq cr6, 0x82e11500
	if ctx.cr[6].eq {
	pc = 0x82E11500; continue 'dispatch;
	}
	// 82E114F0: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82E114F4: 4BFED2ED  bl 0x82dfe7e0
	ctx.lr = 0x82E114F8;
	sub_82DFE7E0(ctx, base);
	// 82E114F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E114FC: 4182FFAC  beq 0x82e114a8
	if ctx.cr[0].eq {
	pc = 0x82E114A8; continue 'dispatch;
	}
	// 82E11500: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82E11504: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82E11508: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82E1150C: 4198FFD4  blt cr6, 0x82e114e0
	if ctx.cr[6].lt {
	pc = 0x82E114E0; continue 'dispatch;
	}
	// 82E11510: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E11514: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E11518: 48396CA0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E11520 size=292
    let mut pc: u32 = 0x82E11520;
    'dispatch: loop {
        match pc {
            0x82E11520 => {
    //   block [0x82E11520..0x82E11644)
	// 82E11520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E11524: 48396C3D  bl 0x831a8160
	ctx.lr = 0x82E11528;
	sub_831A8130(ctx, base);
	// 82E11528: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82E1152C: 4839754D  bl 0x831a8a78
	ctx.lr = 0x82E11530;
	sub_831A8A40(ctx, base);
	// 82E11530: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E11534: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E11538: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82E1153C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82E11540: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82E11544: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 82E11548: FF802090  fmr f28, f4
	ctx.f[28].f64 = ctx.f[4].f64;
	// 82E1154C: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E11550: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E11554: 419A0010  beq cr6, 0x82e11564
	if ctx.cr[6].eq {
	pc = 0x82E11564; continue 'dispatch;
	}
	// 82E11558: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E1155C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E11560: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82E11564: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E11568: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E1156C: 419A00C4  beq cr6, 0x82e11630
	if ctx.cr[6].eq {
	pc = 0x82E11630; continue 'dispatch;
	}
	// 82E11570: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 82E11574: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E11578: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 82E1157C: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E11580: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E11584: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E11588: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82E1158C: 3BEB000C  addi r31, r11, 0xc
	ctx.r[31].s64 = ctx.r[11].s64 + 12;
	// 82E11590: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E11594: 4BFFEF9D  bl 0x82e10530
	ctx.lr = 0x82E11598;
	sub_82E10530(ctx, base);
	// 82E11598: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E1159C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E115A0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E115A4: 419A0014  beq cr6, 0x82e115b8
	if ctx.cr[6].eq {
	pc = 0x82E115B8; continue 'dispatch;
	}
	// 82E115A8: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E115AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E115B0: B1410050  sth r10, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u16 ) };
	// 82E115B4: 48000008  b 0x82e115bc
	pc = 0x82E115BC; continue 'dispatch;
	// 82E115B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E115BC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E115C0: 41820064  beq 0x82e11624
	if ctx.cr[0].eq {
	pc = 0x82E11624; continue 'dispatch;
	}
	// 82E115C4: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E115C8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E115CC: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E115D0: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82E115D4: 7948FFE6  rldicr r8, r10, 0x3f, 0x3f
	ctx.r[8].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82E115D8: 7D4BD214  add r10, r11, r26
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82E115DC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82E115E0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E115E4: 38EA0178  addi r7, r10, 0x178
	ctx.r[7].s64 = ctx.r[10].s64 + 376;
	// 82E115E8: 55492036  slwi r9, r10, 4
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E115EC: 54E72036  slwi r7, r7, 4
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82E115F0: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82E115F4: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E115F8: 7CCA5050  subf r6, r10, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[10].s64;
	// 82E115FC: 7FE75D2E  stfsx f31, r7, r11
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82E11600: D3C91784  stfs f30, 0x1784(r9)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(6020 as u32), tmp.u32 ) };
	// 82E11604: 78C70020  clrldi r7, r6, 0x20
	ctx.r[7].u64 = ctx.r[6].u64 & 0x00000000FFFFFFFFu64;
	// 82E11608: D3A91788  stfs f29, 0x1788(r9)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(6024 as u32), tmp.u32 ) };
	// 82E1160C: D389178C  stfs f28, 0x178c(r9)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(6028 as u32), tmp.u32 ) };
	// 82E11610: 7D093E34  srad r9, r8, r7
	tmp.u64 = (ctx.r[7].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[8].s64 < 0) && ((ctx.r[8].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[9].s64 = ctx.r[8].s64 >> tmp.u64;
	// 82E11614: 7D2A5436  srd r10, r9, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = (ctx.r[9].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 82E11618: E92B0008  ld r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82E1161C: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82E11620: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82E11624: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82E11628: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82E1162C: 4082FF50  bne 0x82e1157c
	if !ctx.cr[0].eq {
	pc = 0x82E1157C; continue 'dispatch;
	}
	// 82E11630: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E11634: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82E11638: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82E1163C: 48397489  bl 0x831a8ac4
	ctx.lr = 0x82E11640;
	sub_831A8A8C(ctx, base);
	// 82E11640: 48396B70  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E11648 size=276
    let mut pc: u32 = 0x82E11648;
    'dispatch: loop {
        match pc {
            0x82E11648 => {
    //   block [0x82E11648..0x82E1175C)
	// 82E11648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E1164C: 48396B11  bl 0x831a815c
	ctx.lr = 0x82E11650;
	sub_831A8130(ctx, base);
	// 82E11650: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E11654: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E11658: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82E1165C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82E11660: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E11664: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E11668: 419A0010  beq cr6, 0x82e11678
	if ctx.cr[6].eq {
	pc = 0x82E11678; continue 'dispatch;
	}
	// 82E1166C: 815D0020  lwz r10, 0x20(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E11670: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E11674: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82E11678: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82E1167C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E11680: 419A00D0  beq cr6, 0x82e11750
	if ctx.cr[6].eq {
	pc = 0x82E11750; continue 'dispatch;
	}
	// 82E11684: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 82E11688: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E1168C: 7D795B78  mr r25, r11
	ctx.r[25].u64 = ctx.r[11].u64;
	// 82E11690: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E11694: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E11698: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E1169C: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82E116A0: 3BCB000C  addi r30, r11, 0xc
	ctx.r[30].s64 = ctx.r[11].s64 + 12;
	// 82E116A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E116A8: 4BFFEE89  bl 0x82e10530
	ctx.lr = 0x82E116AC;
	sub_82E10530(ctx, base);
	// 82E116AC: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E116B0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E116B4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E116B8: 419A0014  beq cr6, 0x82e116cc
	if ctx.cr[6].eq {
	pc = 0x82E116CC; continue 'dispatch;
	}
	// 82E116BC: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E116C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E116C4: B1410050  sth r10, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u16 ) };
	// 82E116C8: 48000008  b 0x82e116d0
	pc = 0x82E116D0; continue 'dispatch;
	// 82E116CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E116D0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E116D4: 41820070  beq 0x82e11744
	if ctx.cr[0].eq {
	pc = 0x82E11744; continue 'dispatch;
	}
	// 82E116D8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E116DC: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E116E0: 813D0014  lwz r9, 0x14(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E116E4: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E116E8: 7948FFE6  rldicr r8, r10, 0x3f, 0x3f
	ctx.r[8].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82E116EC: 7D4BD214  add r10, r11, r26
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82E116F0: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82E116F4: 38EA0178  addi r7, r10, 0x178
	ctx.r[7].s64 = ctx.r[10].s64 + 376;
	// 82E116F8: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E116FC: 55492036  slwi r9, r10, 4
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E11700: 54E72036  slwi r7, r7, 4
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82E11704: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82E11708: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82E1170C: 7CCA5050  subf r6, r10, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[10].s64;
	// 82E11710: 7C075D2E  stfsx f0, r7, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82E11714: 78C70020  clrldi r7, r6, 0x20
	ctx.r[7].u64 = ctx.r[6].u64 & 0x00000000FFFFFFFFu64;
	// 82E11718: 7D083E34  srad r8, r8, r7
	tmp.u64 = (ctx.r[7].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[8].s64 < 0) && ((ctx.r[8].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[8].s64 = ctx.r[8].s64 >> tmp.u64;
	// 82E1171C: 7D0A5436  srd r10, r8, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = (ctx.r[8].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 82E11720: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E11724: D0091784  stfs f0, 0x1784(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(6020 as u32), tmp.u32 ) };
	// 82E11728: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E1172C: D0091788  stfs f0, 0x1788(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(6024 as u32), tmp.u32 ) };
	// 82E11730: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E11734: D009178C  stfs f0, 0x178c(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(6028 as u32), tmp.u32 ) };
	// 82E11738: E92B0008  ld r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82E1173C: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82E11740: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82E11744: 3739FFFF  addic. r25, r25, -1
	ctx.xer.ca = (ctx.r[25].u32 > (!(-1 as u32)));
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 82E11748: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 82E1174C: 4082FF44  bne 0x82e11690
	if !ctx.cr[0].eq {
	pc = 0x82E11690; continue 'dispatch;
	}
	// 82E11750: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E11754: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E11758: 48396A54  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E11760 size=276
    let mut pc: u32 = 0x82E11760;
    'dispatch: loop {
        match pc {
            0x82E11760 => {
    //   block [0x82E11760..0x82E11874)
	// 82E11760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E11764: 483969F5  bl 0x831a8158
	ctx.lr = 0x82E11768;
	sub_831A8130(ctx, base);
	// 82E11768: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E1176C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E11770: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 82E11774: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82E11778: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82E1177C: 930100E4  stw r24, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[24].u32 ) };
	// 82E11780: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E11784: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E11788: 419A0010  beq cr6, 0x82e11798
	if ctx.cr[6].eq {
	pc = 0x82E11798; continue 'dispatch;
	}
	// 82E1178C: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E11790: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E11794: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82E11798: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E1179C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E117A0: 419A00C8  beq cr6, 0x82e11868
	if ctx.cr[6].eq {
	pc = 0x82E11868; continue 'dispatch;
	}
	// 82E117A4: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 82E117A8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82E117AC: 7D795B78  mr r25, r11
	ctx.r[25].u64 = ctx.r[11].u64;
	// 82E117B0: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E117B4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E117B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E117BC: 7D6BD82E  lwzx r11, r11, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82E117C0: 3BEB000C  addi r31, r11, 0xc
	ctx.r[31].s64 = ctx.r[11].s64 + 12;
	// 82E117C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E117C8: 4BFFED69  bl 0x82e10530
	ctx.lr = 0x82E117CC;
	sub_82E10530(ctx, base);
	// 82E117CC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E117D0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E117D4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E117D8: 419A0014  beq cr6, 0x82e117ec
	if ctx.cr[6].eq {
	pc = 0x82E117EC; continue 'dispatch;
	}
	// 82E117DC: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E117E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E117E4: B1410050  sth r10, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u16 ) };
	// 82E117E8: 48000008  b 0x82e117f0
	pc = 0x82E117F0; continue 'dispatch;
	// 82E117EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E117F0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E117F4: 41820068  beq 0x82e1185c
	if ctx.cr[0].eq {
	pc = 0x82E1185C; continue 'dispatch;
	}
	// 82E117F8: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82E117FC: 3941005C  addi r10, r1, 0x5c
	ctx.r[10].s64 = ctx.r[1].s64 + 92;
	// 82E11800: 7D7C5850  subf r11, r28, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 82E11804: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E11808: 7F0BC000  cmpw cr6, r11, r24
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[24].s32, &mut ctx.xer);
	// 82E1180C: 41980008  blt cr6, 0x82e11814
	if ctx.cr[6].lt {
	pc = 0x82E11814; continue 'dispatch;
	}
	// 82E11810: 394100E4  addi r10, r1, 0xe4
	ctx.r[10].s64 = ctx.r[1].s64 + 228;
	// 82E11814: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E11818: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82E1181C: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E11820: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82E11824: 7C8BE214  add r4, r11, r28
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82E11828: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E1182C: 7929FFE6  rldicr r9, r9, 0x3f, 0x3f
	ctx.r[9].u64 = (ctx.r[9].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82E11830: 7D643214  add r11, r4, r6
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[6].u64;
	// 82E11834: 5488F0BE  srwi r8, r4, 2
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shr(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82E11838: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82E1183C: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E11840: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E11844: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82E11848: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82E1184C: 7D2B5E34  srad r11, r9, r11
	tmp.u64 = (ctx.r[11].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[9].s64 < 0) && ((ctx.r[9].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[11].s64 = ctx.r[9].s64 >> tmp.u64;
	// 82E11850: 7D674436  srd r7, r11, r8
	if (ctx.r[8].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[11].u64) >> ((ctx.r[8].u8 & 0x3F) as u32);
	}
	// 82E11854: 4BDC691D  bl 0x82bd8170
	ctx.lr = 0x82E11858;
	sub_82BD8170(ctx, base);
	// 82E11858: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82E1185C: 3739FFFF  addic. r25, r25, -1
	ctx.xer.ca = (ctx.r[25].u32 > (!(-1 as u32)));
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 82E11860: 3B7B0008  addi r27, r27, 8
	ctx.r[27].s64 = ctx.r[27].s64 + 8;
	// 82E11864: 4082FF4C  bne 0x82e117b0
	if !ctx.cr[0].eq {
	pc = 0x82E117B0; continue 'dispatch;
	}
	// 82E11868: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E1186C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E11870: 48396938  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E11878 size=236
    let mut pc: u32 = 0x82E11878;
    'dispatch: loop {
        match pc {
            0x82E11878 => {
    //   block [0x82E11878..0x82E11964)
	// 82E11878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E1187C: 483968E1  bl 0x831a815c
	ctx.lr = 0x82E11880;
	sub_831A8130(ctx, base);
	// 82E11880: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E11884: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E11888: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82E1188C: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 82E11890: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E11894: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E11898: 419A0010  beq cr6, 0x82e118a8
	if ctx.cr[6].eq {
	pc = 0x82E118A8; continue 'dispatch;
	}
	// 82E1189C: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E118A0: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E118A4: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82E118A8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E118AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E118B0: 419A00A8  beq cr6, 0x82e11958
	if ctx.cr[6].eq {
	pc = 0x82E11958; continue 'dispatch;
	}
	// 82E118B4: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 82E118B8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E118BC: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 82E118C0: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E118C4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E118C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E118CC: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82E118D0: 3BEB000C  addi r31, r11, 0xc
	ctx.r[31].s64 = ctx.r[11].s64 + 12;
	// 82E118D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E118D8: 4BFFEC59  bl 0x82e10530
	ctx.lr = 0x82E118DC;
	sub_82E10530(ctx, base);
	// 82E118DC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E118E0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E118E4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E118E8: 419A0014  beq cr6, 0x82e118fc
	if ctx.cr[6].eq {
	pc = 0x82E118FC; continue 'dispatch;
	}
	// 82E118EC: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E118F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E118F4: B1410050  sth r10, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u16 ) };
	// 82E118F8: 48000008  b 0x82e11900
	pc = 0x82E11900; continue 'dispatch;
	// 82E118FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E11900: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E11904: 41820048  beq 0x82e1194c
	if ctx.cr[0].eq {
	pc = 0x82E1194C; continue 'dispatch;
	}
	// 82E11908: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E1190C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E11910: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E11914: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82E11918: 7C8BD214  add r4, r11, r26
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82E1191C: 794AFFE6  rldicr r10, r10, 0x3f, 0x3f
	ctx.r[10].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 82E11920: 39640003  addi r11, r4, 3
	ctx.r[11].s64 = ctx.r[4].s64 + 3;
	// 82E11924: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82E11928: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E1192C: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82E11930: 5489F0BE  srwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shr(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82E11934: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82E11938: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82E1193C: 7D4B5E34  srad r11, r10, r11
	tmp.u64 = (ctx.r[11].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[10].s64 < 0) && ((ctx.r[10].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[11].s64 = ctx.r[10].s64 >> tmp.u64;
	// 82E11940: 7D674C36  srd r7, r11, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[11].u64) >> ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 82E11944: 4BDC682D  bl 0x82bd8170
	ctx.lr = 0x82E11948;
	sub_82BD8170(ctx, base);
	// 82E11948: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82E1194C: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82E11950: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82E11954: 4082FF6C  bne 0x82e118c0
	if !ctx.cr[0].eq {
	pc = 0x82E118C0; continue 'dispatch;
	}
	// 82E11958: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E1195C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E11960: 4839684C  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E11968 size=236
    let mut pc: u32 = 0x82E11968;
    'dispatch: loop {
        match pc {
            0x82E11968 => {
    //   block [0x82E11968..0x82E11A54)
	// 82E11968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E1196C: 483967ED  bl 0x831a8158
	ctx.lr = 0x82E11970;
	sub_831A8130(ctx, base);
	// 82E11970: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E11974: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E11978: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 82E1197C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82E11980: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 82E11984: 930100E4  stw r24, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[24].u32 ) };
	// 82E11988: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E1198C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E11990: 419A0010  beq cr6, 0x82e119a0
	if ctx.cr[6].eq {
	pc = 0x82E119A0; continue 'dispatch;
	}
	// 82E11994: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E11998: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E1199C: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82E119A0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E119A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E119A8: 419A00A0  beq cr6, 0x82e11a48
	if ctx.cr[6].eq {
	pc = 0x82E11A48; continue 'dispatch;
	}
	// 82E119AC: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 82E119B0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E119B4: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 82E119B8: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E119BC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E119C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E119C4: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82E119C8: 3BEB0018  addi r31, r11, 0x18
	ctx.r[31].s64 = ctx.r[11].s64 + 24;
	// 82E119CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E119D0: 4BFFEB61  bl 0x82e10530
	ctx.lr = 0x82E119D4;
	sub_82E10530(ctx, base);
	// 82E119D4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E119D8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E119DC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E119E0: 419A0014  beq cr6, 0x82e119f4
	if ctx.cr[6].eq {
	pc = 0x82E119F4; continue 'dispatch;
	}
	// 82E119E4: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E119E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E119EC: B1410050  sth r10, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u16 ) };
	// 82E119F0: 48000008  b 0x82e119f8
	pc = 0x82E119F8; continue 'dispatch;
	// 82E119F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E119F8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E119FC: 41820040  beq 0x82e11a3c
	if ctx.cr[0].eq {
	pc = 0x82E11A3C; continue 'dispatch;
	}
	// 82E11A00: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82E11A04: 3941005C  addi r10, r1, 0x5c
	ctx.r[10].s64 = ctx.r[1].s64 + 92;
	// 82E11A08: 7D7B5850  subf r11, r27, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[27].s64;
	// 82E11A0C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E11A10: 7F0BC000  cmpw cr6, r11, r24
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[24].s32, &mut ctx.xer);
	// 82E11A14: 41980008  blt cr6, 0x82e11a1c
	if ctx.cr[6].lt {
	pc = 0x82E11A1C; continue 'dispatch;
	}
	// 82E11A18: 394100E4  addi r10, r1, 0xe4
	ctx.r[10].s64 = ctx.r[1].s64 + 228;
	// 82E11A1C: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E11A20: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82E11A24: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E11A28: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E11A2C: 7C8BDA14  add r4, r11, r27
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82E11A30: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E11A34: 4BDC6935  bl 0x82bd8368
	ctx.lr = 0x82E11A38;
	sub_82BD8368(ctx, base);
	// 82E11A38: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82E11A3C: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82E11A40: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82E11A44: 4082FF74  bne 0x82e119b8
	if !ctx.cr[0].eq {
	pc = 0x82E119B8; continue 'dispatch;
	}
	// 82E11A48: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E11A4C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E11A50: 48396758  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11A58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E11A58 size=208
    let mut pc: u32 = 0x82E11A58;
    'dispatch: loop {
        match pc {
            0x82E11A58 => {
    //   block [0x82E11A58..0x82E11B28)
	// 82E11A58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E11A5C: 48396701  bl 0x831a815c
	ctx.lr = 0x82E11A60;
	sub_831A8130(ctx, base);
	// 82E11A60: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E11A64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E11A68: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82E11A6C: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 82E11A70: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E11A74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E11A78: 419A0010  beq cr6, 0x82e11a88
	if ctx.cr[6].eq {
	pc = 0x82E11A88; continue 'dispatch;
	}
	// 82E11A7C: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E11A80: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E11A84: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82E11A88: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82E11A8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E11A90: 419A008C  beq cr6, 0x82e11b1c
	if ctx.cr[6].eq {
	pc = 0x82E11B1C; continue 'dispatch;
	}
	// 82E11A94: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 82E11A98: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E11A9C: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 82E11AA0: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E11AA4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E11AA8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E11AAC: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82E11AB0: 3BEB0024  addi r31, r11, 0x24
	ctx.r[31].s64 = ctx.r[11].s64 + 36;
	// 82E11AB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E11AB8: 4BFFEA79  bl 0x82e10530
	ctx.lr = 0x82E11ABC;
	sub_82E10530(ctx, base);
	// 82E11ABC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E11AC0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E11AC4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E11AC8: 419A0014  beq cr6, 0x82e11adc
	if ctx.cr[6].eq {
	pc = 0x82E11ADC; continue 'dispatch;
	}
	// 82E11ACC: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E11AD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E11AD4: B1410050  sth r10, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u16 ) };
	// 82E11AD8: 48000008  b 0x82e11ae0
	pc = 0x82E11AE0; continue 'dispatch;
	// 82E11ADC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E11AE0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E11AE4: 4182002C  beq 0x82e11b10
	if ctx.cr[0].eq {
	pc = 0x82E11B10; continue 'dispatch;
	}
	// 82E11AE8: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 82E11AEC: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E11AF0: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E11AF4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82E11AF8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E11AFC: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82E11B00: 7C8AD214  add r4, r10, r26
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 82E11B04: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E11B08: 4BDC67A9  bl 0x82bd82b0
	ctx.lr = 0x82E11B0C;
	sub_82BD82B0(ctx, base);
	// 82E11B0C: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82E11B10: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82E11B14: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82E11B18: 4082FF88  bne 0x82e11aa0
	if !ctx.cr[0].eq {
	pc = 0x82E11AA0; continue 'dispatch;
	}
	// 82E11B1C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E11B20: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E11B24: 48396688  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11B28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E11B28 size=236
    let mut pc: u32 = 0x82E11B28;
    'dispatch: loop {
        match pc {
            0x82E11B28 => {
    //   block [0x82E11B28..0x82E11C14)
	// 82E11B28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E11B2C: 4839662D  bl 0x831a8158
	ctx.lr = 0x82E11B30;
	sub_831A8130(ctx, base);
	// 82E11B30: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E11B34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E11B38: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 82E11B3C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82E11B40: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 82E11B44: 930100E4  stw r24, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[24].u32 ) };
	// 82E11B48: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E11B4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E11B50: 419A0010  beq cr6, 0x82e11b60
	if ctx.cr[6].eq {
	pc = 0x82E11B60; continue 'dispatch;
	}
	// 82E11B54: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E11B58: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E11B5C: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82E11B60: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E11B64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E11B68: 419A00A0  beq cr6, 0x82e11c08
	if ctx.cr[6].eq {
	pc = 0x82E11C08; continue 'dispatch;
	}
	// 82E11B6C: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 82E11B70: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E11B74: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 82E11B78: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E11B7C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E11B80: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E11B84: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82E11B88: 3BEB0024  addi r31, r11, 0x24
	ctx.r[31].s64 = ctx.r[11].s64 + 36;
	// 82E11B8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E11B90: 4BFFE9A1  bl 0x82e10530
	ctx.lr = 0x82E11B94;
	sub_82E10530(ctx, base);
	// 82E11B94: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E11B98: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E11B9C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E11BA0: 419A0014  beq cr6, 0x82e11bb4
	if ctx.cr[6].eq {
	pc = 0x82E11BB4; continue 'dispatch;
	}
	// 82E11BA4: A14B0010  lhz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E11BA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E11BAC: B1410050  sth r10, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u16 ) };
	// 82E11BB0: 48000008  b 0x82e11bb8
	pc = 0x82E11BB8; continue 'dispatch;
	// 82E11BB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E11BB8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E11BBC: 41820040  beq 0x82e11bfc
	if ctx.cr[0].eq {
	pc = 0x82E11BFC; continue 'dispatch;
	}
	// 82E11BC0: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82E11BC4: 3941005C  addi r10, r1, 0x5c
	ctx.r[10].s64 = ctx.r[1].s64 + 92;
	// 82E11BC8: 7D7B5850  subf r11, r27, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[27].s64;
	// 82E11BCC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E11BD0: 7F0BC000  cmpw cr6, r11, r24
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[24].s32, &mut ctx.xer);
	// 82E11BD4: 41980008  blt cr6, 0x82e11bdc
	if ctx.cr[6].lt {
	pc = 0x82E11BDC; continue 'dispatch;
	}
	// 82E11BD8: 394100E4  addi r10, r1, 0xe4
	ctx.r[10].s64 = ctx.r[1].s64 + 228;
	// 82E11BDC: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E11BE0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82E11BE4: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E11BE8: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E11BEC: 7C8BDA14  add r4, r11, r27
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82E11BF0: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E11BF4: 4BDC66BD  bl 0x82bd82b0
	ctx.lr = 0x82E11BF8;
	sub_82BD82B0(ctx, base);
	// 82E11BF8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82E11BFC: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82E11C00: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82E11C04: 4082FF74  bne 0x82e11b78
	if !ctx.cr[0].eq {
	pc = 0x82E11B78; continue 'dispatch;
	}
	// 82E11C08: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E11C0C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E11C10: 48396598  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E11C18 size=8
    let mut pc: u32 = 0x82E11C18;
    'dispatch: loop {
        match pc {
            0x82E11C18 => {
    //   block [0x82E11C18..0x82E11C20)
	// 82E11C18: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E11C1C: 4BFFF904  b 0x82e11520
	sub_82E11520(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E11C20 size=12
    let mut pc: u32 = 0x82E11C20;
    'dispatch: loop {
        match pc {
            0x82E11C20 => {
    //   block [0x82E11C20..0x82E11C2C)
	// 82E11C20: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82E11C24: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E11C28: 4BFFFA20  b 0x82e11648
	sub_82E11648(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E11C30 size=16
    let mut pc: u32 = 0x82E11C30;
    'dispatch: loop {
        match pc {
            0x82E11C30 => {
    //   block [0x82E11C30..0x82E11C40)
	// 82E11C30: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 82E11C34: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82E11C38: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E11C3C: 4BFFFB24  b 0x82e11760
	sub_82E11760(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E11C40 size=12
    let mut pc: u32 = 0x82E11C40;
    'dispatch: loop {
        match pc {
            0x82E11C40 => {
    //   block [0x82E11C40..0x82E11C4C)
	// 82E11C40: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82E11C44: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E11C48: 4BFFFC30  b 0x82e11878
	sub_82E11878(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E11C50 size=12
    let mut pc: u32 = 0x82E11C50;
    'dispatch: loop {
        match pc {
            0x82E11C50 => {
    //   block [0x82E11C50..0x82E11C5C)
	// 82E11C50: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82E11C54: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E11C58: 4BFFFE00  b 0x82e11a58
	sub_82E11A58(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E11C60 size=632
    let mut pc: u32 = 0x82E11C60;
    'dispatch: loop {
        match pc {
            0x82E11C60 => {
    //   block [0x82E11C60..0x82E11ED8)
	// 82E11C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E11C64: 483964E9  bl 0x831a814c
	ctx.lr = 0x82E11C68;
	sub_831A8130(ctx, base);
	// 82E11C68: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E11C6C: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 82E11C70: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 82E11C74: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 82E11C78: 8175001C  lwz r11, 0x1c(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E11C7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E11C80: 419A0010  beq cr6, 0x82e11c90
	if ctx.cr[6].eq {
	pc = 0x82E11C90; continue 'dispatch;
	}
	// 82E11C84: 81550020  lwz r10, 0x20(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E11C88: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E11C8C: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82E11C90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E11C94: 419A00C4  beq cr6, 0x82e11d58
	if ctx.cr[6].eq {
	pc = 0x82E11D58; continue 'dispatch;
	}
	// 82E11C98: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82E11C9C: 7D785B78  mr r24, r11
	ctx.r[24].u64 = ctx.r[11].u64;
	// 82E11CA0: 8175001C  lwz r11, 0x1c(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E11CA4: 83B70014  lwz r29, 0x14(r23)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E11CA8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82E11CAC: 7D59582E  lwzx r10, r25, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E11CB0: 419A009C  beq cr6, 0x82e11d4c
	if ctx.cr[6].eq {
	pc = 0x82E11D4C; continue 'dispatch;
	}
	// 82E11CB4: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E11CB8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82E11CBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E11CC0: 419A008C  beq cr6, 0x82e11d4c
	if ctx.cr[6].eq {
	pc = 0x82E11D4C; continue 'dispatch;
	}
	// 82E11CC4: 813D0014  lwz r9, 0x14(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E11CC8: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82E11CCC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E11CD0: 4081007C  ble 0x82e11d4c
	if !ctx.cr[0].gt {
	pc = 0x82E11D4C; continue 'dispatch;
	}
	// 82E11CD4: 3B6A0030  addi r27, r10, 0x30
	ctx.r[27].s64 = ctx.r[10].s64 + 48;
	// 82E11CD8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E11CDC: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 82E11CE0: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E11CE4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82E11CE8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82E11CEC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E11CF0: 7FFE582E  lwzx r31, r30, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E11CF4: 809F002C  lwz r4, 0x2c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E11CF8: 48017ED9  bl 0x82e29bd0
	ctx.lr = 0x82E11CFC;
	sub_82E29BD0(ctx, base);
	// 82E11CFC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E11D00: 41820040  beq 0x82e11d40
	if ctx.cr[0].eq {
	pc = 0x82E11D40; continue 'dispatch;
	}
	// 82E11D04: 88810050  lbz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E11D08: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E11D0C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E11D10: 80750014  lwz r3, 0x14(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E11D14: 7D4B2030  slw r11, r10, r4
	if (ctx.r[4].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[10].u32) << ((ctx.r[4].u8 & 0x1F) as u32)) as u64;
	}
	// 82E11D18: 7D7CE378  or r28, r11, r28
	ctx.r[28].u64 = ctx.r[11].u64 | ctx.r[28].u64;
	// 82E11D1C: 4BFFC82D  bl 0x82e0e548
	ctx.lr = 0x82E11D20;
	sub_82E0E548(ctx, base);
	// 82E11D20: 897F0014  lbz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E11D24: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E11D28: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 82E11D2C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82E11D30: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82E11D34: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82E11D38: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82E11D3C: 7C0AB52E  stfsx f0, r10, r22
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[22].u32), tmp.u32) };
	// 82E11D40: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82E11D44: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82E11D48: 4082FF98  bne 0x82e11ce0
	if !ctx.cr[0].eq {
	pc = 0x82E11CE0; continue 'dispatch;
	}
	// 82E11D4C: 3718FFFF  addic. r24, r24, -1
	ctx.xer.ca = (ctx.r[24].u32 > (!(-1 as u32)));
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 82E11D50: 3B390008  addi r25, r25, 8
	ctx.r[25].s64 = ctx.r[25].s64 + 8;
	// 82E11D54: 4082FF4C  bne 0x82e11ca0
	if !ctx.cr[0].eq {
	pc = 0x82E11CA0; continue 'dispatch;
	}
	// 82E11D58: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82E11D5C: 816A6530  lwz r11, 0x6530(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25904 as u32) ) } as u64;
	// 82E11D60: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82E11D64: 40820020  bne 0x82e11d84
	if !ctx.cr[0].eq {
	pc = 0x82E11D84; continue 'dispatch;
	}
	// 82E11D68: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82E11D6C: 3D208212  lis r9, -0x7dee
	ctx.r[9].s64 = -2112749568;
	// 82E11D70: 916A6530  stw r11, 0x6530(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(25904 as u32), ctx.r[11].u32 ) };
	// 82E11D74: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82E11D78: 3889BC28  addi r4, r9, -0x43d8
	ctx.r[4].s64 = ctx.r[9].s64 + -17368;
	// 82E11D7C: 386B652C  addi r3, r11, 0x652c
	ctx.r[3].s64 = ctx.r[11].s64 + 25900;
	// 82E11D80: 4BFE77B1  bl 0x82df9530
	ctx.lr = 0x82E11D84;
	sub_82DF9530(ctx, base);
	// 82E11D84: 81750014  lwz r11, 0x14(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E11D88: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 82E11D8C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82E11D90: 78E7C1C6  sldi r7, r7, 0x38
	ctx.r[7].u64 = ctx.r[7].u64.wrapping_shl(56);
	ctx.r[7].u32 = ctx.r[7].u64 as u32;
	// 82E11D94: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 82E11D98: 3880001A  li r4, 0x1a
	ctx.r[4].s64 = 26;
	// 82E11D9C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E11DA0: 4BDC63D1  bl 0x82bd8170
	ctx.lr = 0x82E11DA4;
	sub_82BD8170(ctx, base);
	// 82E11DA4: 8977004F  lbz r11, 0x4f(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(79 as u32) ) } as u64;
	// 82E11DA8: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E11DAC: 4082005C  bne 0x82e11e08
	if !ctx.cr[0].eq {
	pc = 0x82E11E08; continue 'dispatch;
	}
	// 82E11DB0: 81770020  lwz r11, 0x20(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E11DB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E11DB8: 409A000C  bne cr6, 0x82e11dc4
	if !ctx.cr[6].eq {
	pc = 0x82E11DC4; continue 'dispatch;
	}
	// 82E11DBC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E11DC0: 48000010  b 0x82e11dd0
	pc = 0x82E11DD0; continue 'dispatch;
	// 82E11DC4: 81570024  lwz r10, 0x24(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(36 as u32) ) } as u64;
	// 82E11DC8: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E11DCC: 7D7F1E70  srawi r31, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82E11DD0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E11DD4: 419A0034  beq cr6, 0x82e11e08
	if ctx.cr[6].eq {
	pc = 0x82E11E08; continue 'dispatch;
	}
	// 82E11DD8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E11DDC: 81770020  lwz r11, 0x20(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E11DE0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E11DE4: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82E11DE8: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E11DEC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E11DF0: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E11DF4: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E11DF8: 4BFFF969  bl 0x82e11760
	ctx.lr = 0x82E11DFC;
	sub_82E11760(ctx, base);
	// 82E11DFC: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82E11E00: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82E11E04: 4082FFD8  bne 0x82e11ddc
	if !ctx.cr[0].eq {
	pc = 0x82E11DDC; continue 'dispatch;
	}
	// 82E11E08: 8977004F  lbz r11, 0x4f(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(79 as u32) ) } as u64;
	// 82E11E0C: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E11E10: 4082005C  bne 0x82e11e6c
	if !ctx.cr[0].eq {
	pc = 0x82E11E6C; continue 'dispatch;
	}
	// 82E11E14: 81770030  lwz r11, 0x30(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E11E18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E11E1C: 409A000C  bne cr6, 0x82e11e28
	if !ctx.cr[6].eq {
	pc = 0x82E11E28; continue 'dispatch;
	}
	// 82E11E20: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E11E24: 48000010  b 0x82e11e34
	pc = 0x82E11E34; continue 'dispatch;
	// 82E11E28: 81570034  lwz r10, 0x34(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E11E2C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E11E30: 7D7F1E70  srawi r31, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82E11E34: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E11E38: 419A0034  beq cr6, 0x82e11e6c
	if ctx.cr[6].eq {
	pc = 0x82E11E6C; continue 'dispatch;
	}
	// 82E11E3C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E11E40: 81770030  lwz r11, 0x30(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E11E44: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E11E48: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82E11E4C: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E11E50: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E11E54: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E11E58: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E11E5C: 4BFFFB0D  bl 0x82e11968
	ctx.lr = 0x82E11E60;
	sub_82E11968(ctx, base);
	// 82E11E60: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82E11E64: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82E11E68: 4082FFD8  bne 0x82e11e40
	if !ctx.cr[0].eq {
	pc = 0x82E11E40; continue 'dispatch;
	}
	// 82E11E6C: 8977004F  lbz r11, 0x4f(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(79 as u32) ) } as u64;
	// 82E11E70: 556B077B  rlwinm. r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E11E74: 4082005C  bne 0x82e11ed0
	if !ctx.cr[0].eq {
	pc = 0x82E11ED0; continue 'dispatch;
	}
	// 82E11E78: 81770040  lwz r11, 0x40(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E11E7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E11E80: 409A000C  bne cr6, 0x82e11e8c
	if !ctx.cr[6].eq {
	pc = 0x82E11E8C; continue 'dispatch;
	}
	// 82E11E84: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E11E88: 48000010  b 0x82e11e98
	pc = 0x82E11E98; continue 'dispatch;
	// 82E11E8C: 81570044  lwz r10, 0x44(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E11E90: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E11E94: 7D7F1E70  srawi r31, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82E11E98: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E11E9C: 419A0034  beq cr6, 0x82e11ed0
	if ctx.cr[6].eq {
	pc = 0x82E11ED0; continue 'dispatch;
	}
	// 82E11EA0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E11EA4: 81770040  lwz r11, 0x40(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(64 as u32) ) } as u64;
	// 82E11EA8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E11EAC: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82E11EB0: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82E11EB4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E11EB8: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E11EBC: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E11EC0: 4BFFFC69  bl 0x82e11b28
	ctx.lr = 0x82E11EC4;
	sub_82E11B28(ctx, base);
	// 82E11EC4: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82E11EC8: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82E11ECC: 4082FFD8  bne 0x82e11ea4
	if !ctx.cr[0].eq {
	pc = 0x82E11EA4; continue 'dispatch;
	}
	// 82E11ED0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82E11ED4: 483962C8  b 0x831a819c
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E11ED8 size=24
    let mut pc: u32 = 0x82E11ED8;
    'dispatch: loop {
        match pc {
            0x82E11ED8 => {
    //   block [0x82E11ED8..0x82E11EF0)
	// 82E11ED8: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E11EDC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E11EE0: 396BBC3C  addi r11, r11, -0x43c4
	ctx.r[11].s64 = ctx.r[11].s64 + -17348;
	// 82E11EE4: 99430004  stb r10, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 82E11EE8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E11EEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E11EF0 size=16
    let mut pc: u32 = 0x82E11EF0;
    'dispatch: loop {
        match pc {
            0x82E11EF0 => {
    //   block [0x82E11EF0..0x82E11F00)
	// 82E11EF0: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E11EF4: 396BBC3C  addi r11, r11, -0x43c4
	ctx.r[11].s64 = ctx.r[11].s64 + -17348;
	// 82E11EF8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E11EFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E11F00 size=12
    let mut pc: u32 = 0x82E11F00;
    'dispatch: loop {
        match pc {
            0x82E11F00 => {
    //   block [0x82E11F00..0x82E11F0C)
	// 82E11F00: 89630004  lbz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E11F04: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E11F08: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11F0C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E11F0C size=16
    let mut pc: u32 = 0x82E11F0C;
    'dispatch: loop {
        match pc {
            0x82E11F0C => {
    //   block [0x82E11F0C..0x82E11F1C)
	// 82E11F0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E11F10: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E11F14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E11F18: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11F1C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E11F1C size=4
    let mut pc: u32 = 0x82E11F1C;
    'dispatch: loop {
        match pc {
            0x82E11F1C => {
    //   block [0x82E11F1C..0x82E11F20)
	// 82E11F1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11F20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E11F20 size=8
    let mut pc: u32 = 0x82E11F20;
    'dispatch: loop {
        match pc {
            0x82E11F20 => {
    //   block [0x82E11F20..0x82E11F28)
	// 82E11F20: 98830004  stb r4, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u8 ) };
	// 82E11F24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E11F28 size=68
    let mut pc: u32 = 0x82E11F28;
    'dispatch: loop {
        match pc {
            0x82E11F28 => {
    //   block [0x82E11F28..0x82E11F6C)
	// 82E11F28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E11F2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E11F30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E11F34: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E11F38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E11F3C: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E11F40: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E11F44: 396BBC3C  addi r11, r11, -0x43c4
	ctx.r[11].s64 = ctx.r[11].s64 + -17348;
	// 82E11F48: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E11F4C: 41820008  beq 0x82e11f54
	if ctx.cr[0].eq {
	pc = 0x82E11F54; continue 'dispatch;
	}
	// 82E11F50: 4BFE0489  bl 0x82df23d8
	ctx.lr = 0x82E11F54;
	sub_82DF23D8(ctx, base);
	// 82E11F54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E11F58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E11F5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E11F60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E11F64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E11F68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E11F70 size=120
    let mut pc: u32 = 0x82E11F70;
    'dispatch: loop {
        match pc {
            0x82E11F70 => {
    //   block [0x82E11F70..0x82E11FE8)
	// 82E11F70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E11F74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E11F78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E11F7C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E11F80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E11F84: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82E11F88: 396B9B90  addi r11, r11, -0x6470
	ctx.r[11].s64 = ctx.r[11].s64 + -25712;
	// 82E11F8C: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E11F90: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E11F94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E11F98: 419A0018  beq cr6, 0x82e11fb0
	if ctx.cr[6].eq {
	pc = 0x82E11FB0; continue 'dispatch;
	}
	// 82E11F9C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E11FA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E11FA4: 409A001C  bne cr6, 0x82e11fc0
	if !ctx.cr[6].eq {
	pc = 0x82E11FC0; continue 'dispatch;
	}
	// 82E11FA8: 483B30A1  bl 0x831c5048
	ctx.lr = 0x82E11FAC;
	sub_831C5048(ctx, base);
	// 82E11FAC: 48000014  b 0x82e11fc0
	pc = 0x82E11FC0; continue 'dispatch;
	// 82E11FB0: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E11FB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E11FB8: 419A0008  beq cr6, 0x82e11fc0
	if ctx.cr[6].eq {
	pc = 0x82E11FC0; continue 'dispatch;
	}
	// 82E11FBC: 4BDCD01D  bl 0x82bdefd8
	ctx.lr = 0x82E11FC0;
	sub_82BDEFD8(ctx, base);
	// 82E11FC0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82E11FC4: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82E11FC8: 396B9B84  addi r11, r11, -0x647c
	ctx.r[11].s64 = ctx.r[11].s64 + -25724;
	// 82E11FCC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E11FD0: 4BFE1459  bl 0x82df3428
	ctx.lr = 0x82E11FD4;
	sub_82DF3428(ctx, base);
	// 82E11FD4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E11FD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E11FDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E11FE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E11FE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E11FE8 size=16
    let mut pc: u32 = 0x82E11FE8;
    'dispatch: loop {
        match pc {
            0x82E11FE8 => {
    //   block [0x82E11FE8..0x82E11FF8)
	// 82E11FE8: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82E11FEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E11FF0: 996A6534  stb r11, 0x6534(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(25908 as u32), ctx.r[11].u8 ) };
	// 82E11FF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E11FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E11FF8 size=16
    let mut pc: u32 = 0x82E11FF8;
    'dispatch: loop {
        match pc {
            0x82E11FF8 => {
    //   block [0x82E11FF8..0x82E12008)
	// 82E11FF8: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82E11FFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E12000: 996A6534  stb r11, 0x6534(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(25908 as u32), ctx.r[11].u8 ) };
	// 82E12004: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E12008 size=124
    let mut pc: u32 = 0x82E12008;
    'dispatch: loop {
        match pc {
            0x82E12008 => {
    //   block [0x82E12008..0x82E12084)
	// 82E12008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E1200C: 48396161  bl 0x831a816c
	ctx.lr = 0x82E12010;
	sub_831A8130(ctx, base);
	// 82E12010: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E12014: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E12018: 3FA08338  lis r29, -0x7cc8
	ctx.r[29].s64 = -2093481984;
	// 82E1201C: 3FC08338  lis r30, -0x7cc8
	ctx.r[30].s64 = -2093481984;
	// 82E12020: 897D6534  lbz r11, 0x6534(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(25908 as u32) ) } as u64;
	// 82E12024: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E12028: 41820018  beq 0x82e12040
	if ctx.cr[0].eq {
	pc = 0x82E12040; continue 'dispatch;
	}
	// 82E1202C: 807E6538  lwz r3, 0x6538(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(25912 as u32) ) } as u64;
	// 82E12030: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12034: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E12038: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E1203C: 4E800421  bctrl
	ctx.lr = 0x82E12040;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E12040: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E12044: 997F0039  stb r11, 0x39(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(57 as u32), ctx.r[11].u8 ) };
	// 82E12048: 897D6534  lbz r11, 0x6534(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(25908 as u32) ) } as u64;
	// 82E1204C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E12050: 41820018  beq 0x82e12068
	if ctx.cr[0].eq {
	pc = 0x82E12068; continue 'dispatch;
	}
	// 82E12054: 807E6538  lwz r3, 0x6538(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(25912 as u32) ) } as u64;
	// 82E12058: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E1205C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E12060: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E12064: 4E800421  bctrl
	ctx.lr = 0x82E12068;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E12068: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E1206C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E12070: 419A000C  beq cr6, 0x82e1207c
	if ctx.cr[6].eq {
	pc = 0x82E1207C; continue 'dispatch;
	}
	// 82E12074: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82E12078: 4BFFFFA8  b 0x82e12020
	pc = 0x82E12020; continue 'dispatch;
	// 82E1207C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E12080: 4839613C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E12088 size=80
    let mut pc: u32 = 0x82E12088;
    'dispatch: loop {
        match pc {
            0x82E12088 => {
    //   block [0x82E12088..0x82E120D8)
	// 82E12088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E1208C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E12090: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E12094: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E12098: 3FE08338  lis r31, -0x7cc8
	ctx.r[31].s64 = -2093481984;
	// 82E1209C: 817F6538  lwz r11, 0x6538(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(25912 as u32) ) } as u64;
	// 82E120A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E120A4: 409A0020  bne cr6, 0x82e120c4
	if !ctx.cr[6].eq {
	pc = 0x82E120C4; continue 'dispatch;
	}
	// 82E120A8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E120AC: 806B16D4  lwz r3, 0x16d4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5844 as u32) ) } as u64;
	// 82E120B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E120B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E120B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E120BC: 4E800421  bctrl
	ctx.lr = 0x82E120C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E120C0: 907F6538  stw r3, 0x6538(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(25912 as u32), ctx.r[3].u32 ) };
	// 82E120C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E120C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E120CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E120D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E120D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E120D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E120D8 size=112
    let mut pc: u32 = 0x82E120D8;
    'dispatch: loop {
        match pc {
            0x82E120D8 => {
    //   block [0x82E120D8..0x82E12148)
	// 82E120D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E120DC: 4839608D  bl 0x831a8168
	ctx.lr = 0x82E120E0;
	sub_831A8130(ctx, base);
	// 82E120E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E120E4: 3FE08338  lis r31, -0x7cc8
	ctx.r[31].s64 = -2093481984;
	// 82E120E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E120EC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E120F0: 3F808338  lis r28, -0x7cc8
	ctx.r[28].s64 = -2093481984;
	// 82E120F4: 897F6534  lbz r11, 0x6534(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25908 as u32) ) } as u64;
	// 82E120F8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E120FC: 41820018  beq 0x82e12114
	if ctx.cr[0].eq {
	pc = 0x82E12114; continue 'dispatch;
	}
	// 82E12100: 807C6538  lwz r3, 0x6538(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(25912 as u32) ) } as u64;
	// 82E12104: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12108: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E1210C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E12110: 4E800421  bctrl
	ctx.lr = 0x82E12114;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E12114: 897E003A  lbz r11, 0x3a(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(58 as u32) ) } as u64;
	// 82E12118: 7D6BEB78  or r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[29].u64;
	// 82E1211C: 997E003A  stb r11, 0x3a(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(58 as u32), ctx.r[11].u8 ) };
	// 82E12120: 897F6534  lbz r11, 0x6534(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25908 as u32) ) } as u64;
	// 82E12124: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E12128: 41820018  beq 0x82e12140
	if ctx.cr[0].eq {
	pc = 0x82E12140; continue 'dispatch;
	}
	// 82E1212C: 807C6538  lwz r3, 0x6538(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(25912 as u32) ) } as u64;
	// 82E12130: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12134: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E12138: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E1213C: 4E800421  bctrl
	ctx.lr = 0x82E12140;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E12140: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E12144: 48396074  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E12148 size=112
    let mut pc: u32 = 0x82E12148;
    'dispatch: loop {
        match pc {
            0x82E12148 => {
    //   block [0x82E12148..0x82E121B8)
	// 82E12148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E1214C: 4839601D  bl 0x831a8168
	ctx.lr = 0x82E12150;
	sub_831A8130(ctx, base);
	// 82E12150: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E12154: 3FE08338  lis r31, -0x7cc8
	ctx.r[31].s64 = -2093481984;
	// 82E12158: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E1215C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E12160: 3F808338  lis r28, -0x7cc8
	ctx.r[28].s64 = -2093481984;
	// 82E12164: 897F6534  lbz r11, 0x6534(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25908 as u32) ) } as u64;
	// 82E12168: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E1216C: 41820018  beq 0x82e12184
	if ctx.cr[0].eq {
	pc = 0x82E12184; continue 'dispatch;
	}
	// 82E12170: 807C6538  lwz r3, 0x6538(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(25912 as u32) ) } as u64;
	// 82E12174: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12178: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E1217C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E12180: 4E800421  bctrl
	ctx.lr = 0x82E12184;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E12184: 897E003A  lbz r11, 0x3a(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(58 as u32) ) } as u64;
	// 82E12188: 7D6BE878  andc r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 & !ctx.r[29].u64;
	// 82E1218C: 997E003A  stb r11, 0x3a(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(58 as u32), ctx.r[11].u8 ) };
	// 82E12190: 897F6534  lbz r11, 0x6534(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25908 as u32) ) } as u64;
	// 82E12194: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E12198: 41820018  beq 0x82e121b0
	if ctx.cr[0].eq {
	pc = 0x82E121B0; continue 'dispatch;
	}
	// 82E1219C: 807C6538  lwz r3, 0x6538(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(25912 as u32) ) } as u64;
	// 82E121A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E121A4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E121A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E121AC: 4E800421  bctrl
	ctx.lr = 0x82E121B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E121B0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E121B4: 48396004  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E121B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E121B8 size=124
    let mut pc: u32 = 0x82E121B8;
    'dispatch: loop {
        match pc {
            0x82E121B8 => {
    //   block [0x82E121B8..0x82E12234)
	// 82E121B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E121BC: 48395FB1  bl 0x831a816c
	ctx.lr = 0x82E121C0;
	sub_831A8130(ctx, base);
	// 82E121C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E121C4: 3FC08338  lis r30, -0x7cc8
	ctx.r[30].s64 = -2093481984;
	// 82E121C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E121CC: 3FA08338  lis r29, -0x7cc8
	ctx.r[29].s64 = -2093481984;
	// 82E121D0: 897E6534  lbz r11, 0x6534(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(25908 as u32) ) } as u64;
	// 82E121D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E121D8: 41820018  beq 0x82e121f0
	if ctx.cr[0].eq {
	pc = 0x82E121F0; continue 'dispatch;
	}
	// 82E121DC: 807D6538  lwz r3, 0x6538(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(25912 as u32) ) } as u64;
	// 82E121E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E121E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E121E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E121EC: 4E800421  bctrl
	ctx.lr = 0x82E121F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E121F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E121F4: 997F0038  stb r11, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u8 ) };
	// 82E121F8: 997F0039  stb r11, 0x39(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(57 as u32), ctx.r[11].u8 ) };
	// 82E121FC: 897E6534  lbz r11, 0x6534(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(25908 as u32) ) } as u64;
	// 82E12200: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E12204: 41820018  beq 0x82e1221c
	if ctx.cr[0].eq {
	pc = 0x82E1221C; continue 'dispatch;
	}
	// 82E12208: 807D6538  lwz r3, 0x6538(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(25912 as u32) ) } as u64;
	// 82E1220C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12210: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E12214: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E12218: 4E800421  bctrl
	ctx.lr = 0x82E1221C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E1221C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E12220: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E12224: 419A0008  beq cr6, 0x82e1222c
	if ctx.cr[6].eq {
	pc = 0x82E1222C; continue 'dispatch;
	}
	// 82E12228: 4BFFFDE1  bl 0x82e12008
	ctx.lr = 0x82E1222C;
	sub_82E12008(ctx, base);
	// 82E1222C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E12230: 48395F8C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E12238 size=64
    let mut pc: u32 = 0x82E12238;
    'dispatch: loop {
        match pc {
            0x82E12238 => {
    //   block [0x82E12238..0x82E12278)
	// 82E12238: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E1223C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12240: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E12244: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12248: 892A0019  lbz r9, 0x19(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(25 as u32) ) } as u64;
	// 82E1224C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E12250: 409A0008  bne cr6, 0x82e12258
	if !ctx.cr[6].eq {
	pc = 0x82E12258; continue 'dispatch;
	}
	// 82E12254: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82E12258: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E1225C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E12260: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E12264: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E12268: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E1226C: 409A000C  bne cr6, 0x82e12278
	if !ctx.cr[6].eq {
		sub_82E12278(ctx, base);
		return;
	}
	// 82E12270: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E12274: 48000020  b 0x82e12294
	sub_82E12290(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E12278 size=24
    let mut pc: u32 = 0x82E12278;
    'dispatch: loop {
        match pc {
            0x82E12278 => {
    //   block [0x82E12278..0x82E12290)
	// 82E12278: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E1227C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12280: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E12284: 409A000C  bne cr6, 0x82e12290
	if !ctx.cr[6].eq {
		sub_82E12290(ctx, base);
		return;
	}
	// 82E12288: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E1228C: 48000008  b 0x82e12294
	sub_82E12290(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E12290 size=16
    let mut pc: u32 = 0x82E12290;
    'dispatch: loop {
        match pc {
            0x82E12290 => {
    //   block [0x82E12290..0x82E122A0)
	// 82E12290: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E12294: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82E12298: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E1229C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E122A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E122A0 size=64
    let mut pc: u32 = 0x82E122A0;
    'dispatch: loop {
        match pc {
            0x82E122A0 => {
    //   block [0x82E122A0..0x82E122E0)
	// 82E122A0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E122A4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E122A8: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E122AC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E122B0: 892A0019  lbz r9, 0x19(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(25 as u32) ) } as u64;
	// 82E122B4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E122B8: 409A0008  bne cr6, 0x82e122c0
	if !ctx.cr[6].eq {
	pc = 0x82E122C0; continue 'dispatch;
	}
	// 82E122BC: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82E122C0: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E122C4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E122C8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E122CC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E122D0: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E122D4: 409A000C  bne cr6, 0x82e122e0
	if !ctx.cr[6].eq {
		sub_82E122E0(ctx, base);
		return;
	}
	// 82E122D8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E122DC: 48000020  b 0x82e122fc
	sub_82E122F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E122E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E122E0 size=24
    let mut pc: u32 = 0x82E122E0;
    'dispatch: loop {
        match pc {
            0x82E122E0 => {
    //   block [0x82E122E0..0x82E122F8)
	// 82E122E0: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E122E4: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E122E8: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E122EC: 409A000C  bne cr6, 0x82e122f8
	if !ctx.cr[6].eq {
		sub_82E122F8(ctx, base);
		return;
	}
	// 82E122F0: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E122F4: 48000008  b 0x82e122fc
	sub_82E122F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E122F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E122F8 size=16
    let mut pc: u32 = 0x82E122F8;
    'dispatch: loop {
        match pc {
            0x82E122F8 => {
    //   block [0x82E122F8..0x82E12308)
	// 82E122F8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E122FC: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82E12300: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E12304: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E12308 size=88
    let mut pc: u32 = 0x82E12308;
    'dispatch: loop {
        match pc {
            0x82E12308 => {
    //   block [0x82E12308..0x82E12360)
	// 82E12308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E1230C: 48395E61  bl 0x831a816c
	ctx.lr = 0x82E12310;
	sub_831A8130(ctx, base);
	// 82E12310: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E12314: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E12318: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E1231C: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E12320: 48000028  b 0x82e12348
	pc = 0x82E12348; continue 'dispatch;
	// 82E12324: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82E12328: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E1232C: 4BFE0F0D  bl 0x82df3238
	ctx.lr = 0x82E12330;
	sub_82DF3238(ctx, base);
	// 82E12330: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E12334: 41820010  beq 0x82e12344
	if ctx.cr[0].eq {
	pc = 0x82E12344; continue 'dispatch;
	}
	// 82E12338: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82E1233C: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12340: 48000008  b 0x82e12348
	pc = 0x82E12348; continue 'dispatch;
	// 82E12344: 83FF0008  lwz r31, 8(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E12348: 897F0019  lbz r11, 0x19(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25 as u32) ) } as u64;
	// 82E1234C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E12350: 419AFFD4  beq cr6, 0x82e12324
	if ctx.cr[6].eq {
	pc = 0x82E12324; continue 'dispatch;
	}
	// 82E12354: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E12358: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E1235C: 48395E60  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E12360 size=184
    let mut pc: u32 = 0x82E12360;
    'dispatch: loop {
        match pc {
            0x82E12360 => {
    //   block [0x82E12360..0x82E12418)
	// 82E12360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E12364: 48395E09  bl 0x831a816c
	ctx.lr = 0x82E12368;
	sub_831A8130(ctx, base);
	// 82E12368: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E1236C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E12370: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E12374: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E12378: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E1237C: 419A0008  beq cr6, 0x82e12384
	if ctx.cr[6].eq {
	pc = 0x82E12384; continue 'dispatch;
	}
	// 82E12380: 4BFFFFE1  bl 0x82e12360
	ctx.lr = 0x82E12384;
	sub_82E12360(ctx, base);
	// 82E12384: 897F0038  lbz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E12388: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82E1238C: 409A001C  bne cr6, 0x82e123a8
	if !ctx.cr[6].eq {
	pc = 0x82E123A8; continue 'dispatch;
	}
	// 82E12390: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E12394: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E12398: 419A0078  beq cr6, 0x82e12410
	if ctx.cr[6].eq {
	pc = 0x82E12410; continue 'dispatch;
	}
	// 82E1239C: 896B0039  lbz r11, 0x39(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 82E123A0: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82E123A4: 419A006C  beq cr6, 0x82e12410
	if ctx.cr[6].eq {
	pc = 0x82E12410; continue 'dispatch;
	}
	// 82E123A8: 897F003A  lbz r11, 0x3a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(58 as u32) ) } as u64;
	// 82E123AC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E123B0: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E123B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E123B8: 40820008  bne 0x82e123c0
	if !ctx.cr[0].eq {
	pc = 0x82E123C0; continue 'dispatch;
	}
	// 82E123BC: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E123C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E123C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E123C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E123CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E123D0: 4E800421  bctrl
	ctx.lr = 0x82E123D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E123D4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E123D8: 40820008  bne 0x82e123e0
	if !ctx.cr[0].eq {
	pc = 0x82E123E0; continue 'dispatch;
	}
	// 82E123DC: 9BDF0038  stb r30, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u8 ) };
	// 82E123E0: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E123E4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E123E8: 48000010  b 0x82e123f8
	pc = 0x82E123F8; continue 'dispatch;
	// 82E123EC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E123F0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E123F4: 9BA90038  stb r29, 0x38(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(56 as u32), ctx.r[29].u8 ) };
	// 82E123F8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E123FC: 409AFFF0  bne cr6, 0x82e123ec
	if !ctx.cr[6].eq {
	pc = 0x82E123EC; continue 'dispatch;
	}
	// 82E12400: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E12404: 9BBF0039  stb r29, 0x39(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(57 as u32), ctx.r[29].u8 ) };
	// 82E12408: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E1240C: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82E12410: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E12414: 48395DA8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E12418 size=188
    let mut pc: u32 = 0x82E12418;
    'dispatch: loop {
        match pc {
            0x82E12418 => {
    //   block [0x82E12418..0x82E124D4)
	// 82E12418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E1241C: 48395D4D  bl 0x831a8168
	ctx.lr = 0x82E12420;
	sub_831A8130(ctx, base);
	// 82E12420: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E12424: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E12428: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E1242C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E12430: 839E0010  lwz r28, 0x10(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E12434: 83FE000C  lwz r31, 0xc(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E12438: 997E003D  stb r11, 0x3d(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(61 as u32), ctx.r[11].u8 ) };
	// 82E1243C: 48000080  b 0x82e124bc
	pc = 0x82E124BC; continue 'dispatch;
	// 82E12440: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12444: 89630038  lbz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E12448: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82E1244C: 409A0010  bne cr6, 0x82e1245c
	if !ctx.cr[6].eq {
	pc = 0x82E1245C; continue 'dispatch;
	}
	// 82E12450: 897E0039  lbz r11, 0x39(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(57 as u32) ) } as u64;
	// 82E12454: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82E12458: 419A0054  beq cr6, 0x82e124ac
	if ctx.cr[6].eq {
	pc = 0x82E124AC; continue 'dispatch;
	}
	// 82E1245C: 8963003A  lbz r11, 0x3a(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(58 as u32) ) } as u64;
	// 82E12460: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E12464: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E12468: 40820008  bne 0x82e12470
	if !ctx.cr[0].eq {
	pc = 0x82E12470; continue 'dispatch;
	}
	// 82E1246C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E12470: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12474: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E12478: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E1247C: 4E800421  bctrl
	ctx.lr = 0x82E12480;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E12480: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E12484: 4082000C  bne 0x82e12490
	if !ctx.cr[0].eq {
	pc = 0x82E12490; continue 'dispatch;
	}
	// 82E12488: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E1248C: 9BAB0038  stb r29, 0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[29].u8 ) };
	// 82E12490: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12494: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E12498: 994B0039  stb r10, 0x39(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(57 as u32), ctx.r[10].u8 ) };
	// 82E1249C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E124A0: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E124A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E124A8: 914B0034  stw r10, 0x34(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 82E124AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E124B0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E124B4: 4BFFFF65  bl 0x82e12418
	ctx.lr = 0x82E124B8;
	sub_82E12418(ctx, base);
	// 82E124B8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82E124BC: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82E124C0: 409AFF80  bne cr6, 0x82e12440
	if !ctx.cr[6].eq {
	pc = 0x82E12440; continue 'dispatch;
	}
	// 82E124C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E124C8: 48000729  bl 0x82e12bf0
	ctx.lr = 0x82E124CC;
	sub_82E12BF0(ctx, base);
	// 82E124CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E124D0: 48395CE8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E124D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E124D8 size=12
    let mut pc: u32 = 0x82E124D8;
    'dispatch: loop {
        match pc {
            0x82E124D8 => {
    //   block [0x82E124D8..0x82E124E4)
	// 82E124D8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82E124DC: 808BA4E8  lwz r4, -0x5b18(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23320 as u32) ) } as u64;
	// 82E124E0: 4BFFFF38  b 0x82e12418
	sub_82E12418(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E124E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E124E8 size=88
    let mut pc: u32 = 0x82E124E8;
    'dispatch: loop {
        match pc {
            0x82E124E8 => {
    //   block [0x82E124E8..0x82E12540)
	// 82E124E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E124EC: 48395C81  bl 0x831a816c
	ctx.lr = 0x82E124F0;
	sub_831A8130(ctx, base);
	// 82E124F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E124F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E124F8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82E124FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E12500: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82E12504: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E12508: 7D655850  subf r11, r5, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	// 82E1250C: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E12510: 40810014  ble 0x82e12524
	if !ctx.cr[0].gt {
	pc = 0x82E12524; continue 'dispatch;
	}
	// 82E12514: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82E12518: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E1251C: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82E12520: 483967E9  bl 0x831a8d08
	ctx.lr = 0x82E12524;
	sub_831A8D08(ctx, base);
	// 82E12524: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E12528: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E1252C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82E12530: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 82E12534: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E12538: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E1253C: 48395C80  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E12540 size=148
    let mut pc: u32 = 0x82E12540;
    'dispatch: loop {
        match pc {
            0x82E12540 => {
    //   block [0x82E12540..0x82E125D4)
	// 82E12540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E12544: 48395C25  bl 0x831a8168
	ctx.lr = 0x82E12548;
	sub_831A8130(ctx, base);
	// 82E12548: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E1254C: 3FC08338  lis r30, -0x7cc8
	ctx.r[30].s64 = -2093481984;
	// 82E12550: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E12554: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E12558: 3F808338  lis r28, -0x7cc8
	ctx.r[28].s64 = -2093481984;
	// 82E1255C: 897E6534  lbz r11, 0x6534(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(25908 as u32) ) } as u64;
	// 82E12560: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E12564: 41820018  beq 0x82e1257c
	if ctx.cr[0].eq {
	pc = 0x82E1257C; continue 'dispatch;
	}
	// 82E12568: 807C6538  lwz r3, 0x6538(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(25912 as u32) ) } as u64;
	// 82E1256C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12570: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E12574: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E12578: 4E800421  bctrl
	ctx.lr = 0x82E1257C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E1257C: 80BF001C  lwz r5, 0x1c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E12580: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E12584: 48000014  b 0x82e12598
	pc = 0x82E12598; continue 'dispatch;
	// 82E12588: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E1258C: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82E12590: 419A0010  beq cr6, 0x82e125a0
	if ctx.cr[6].eq {
	pc = 0x82E125A0; continue 'dispatch;
	}
	// 82E12594: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 82E12598: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E1259C: 409AFFEC  bne cr6, 0x82e12588
	if !ctx.cr[6].eq {
	pc = 0x82E12588; continue 'dispatch;
	}
	// 82E125A0: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 82E125A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E125A8: 4BFFFF41  bl 0x82e124e8
	ctx.lr = 0x82E125AC;
	sub_82E124E8(ctx, base);
	// 82E125AC: 897E6534  lbz r11, 0x6534(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(25908 as u32) ) } as u64;
	// 82E125B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E125B4: 41820018  beq 0x82e125cc
	if ctx.cr[0].eq {
	pc = 0x82E125CC; continue 'dispatch;
	}
	// 82E125B8: 807C6538  lwz r3, 0x6538(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(25912 as u32) ) } as u64;
	// 82E125BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E125C0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E125C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E125C8: 4E800421  bctrl
	ctx.lr = 0x82E125CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E125CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E125D0: 48395BE8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E125D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E125D8 size=312
    let mut pc: u32 = 0x82E125D8;
    'dispatch: loop {
        match pc {
            0x82E125D8 => {
    //   block [0x82E125D8..0x82E12710)
	// 82E125D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E125DC: 48395B81  bl 0x831a815c
	ctx.lr = 0x82E125E0;
	sub_831A8130(ctx, base);
	// 82E125E0: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82E125E4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E125E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E125EC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82E125F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E125F4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E125F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E125FC: 4E800421  bctrl
	ctx.lr = 0x82E12600;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E12600: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E12604: 837F0034  lwz r27, 0x34(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E12608: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82E1260C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82E12610: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E12614: 419A007C  beq cr6, 0x82e12690
	if ctx.cr[6].eq {
	pc = 0x82E12690; continue 'dispatch;
	}
	// 82E12618: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82E1261C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E12620: 7D6A1671  srawi. r10, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E12624: 4182006C  beq 0x82e12690
	if ctx.cr[0].eq {
	pc = 0x82E12690; continue 'dispatch;
	}
	// 82E12628: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82E1262C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E12630: 419A0060  beq cr6, 0x82e12690
	if ctx.cr[6].eq {
	pc = 0x82E12690; continue 'dispatch;
	}
	// 82E12634: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	// 82E12638: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E1263C: 3BAB0004  addi r29, r11, 4
	ctx.r[29].s64 = ctx.r[11].s64 + 4;
	// 82E12640: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E12644: 7C005A2C  dcbt 0, r11
	// 82E12648: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E1264C: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82E12650: 419A0034  beq cr6, 0x82e12684
	if ctx.cr[6].eq {
	pc = 0x82E12684; continue 'dispatch;
	}
	// 82E12654: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12658: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E1265C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82E12660: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E12664: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E12668: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E1266C: 4E800421  bctrl
	ctx.lr = 0x82E12670;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E12670: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E12674: 4082000C  bne 0x82e12680
	if !ctx.cr[0].eq {
	pc = 0x82E12680; continue 'dispatch;
	}
	// 82E12678: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82E1267C: 48000008  b 0x82e12684
	pc = 0x82E12684; continue 'dispatch;
	// 82E12680: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82E12684: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82E12688: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82E1268C: 4082FFAC  bne 0x82e12638
	if !ctx.cr[0].eq {
	pc = 0x82E12638; continue 'dispatch;
	}
	// 82E12690: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82E12694: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E12698: 419A0068  beq cr6, 0x82e12700
	if ctx.cr[6].eq {
	pc = 0x82E12700; continue 'dispatch;
	}
	// 82E1269C: 83DF002C  lwz r30, 0x2c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82E126A0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E126A4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E126A8: 48000050  b 0x82e126f8
	pc = 0x82E126F8; continue 'dispatch;
	// 82E126AC: 83EB0010  lwz r31, 0x10(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E126B0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E126B4: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82E126B8: 419A0034  beq cr6, 0x82e126ec
	if ctx.cr[6].eq {
	pc = 0x82E126EC; continue 'dispatch;
	}
	// 82E126BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E126C0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E126C4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82E126C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E126CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E126D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E126D4: 4E800421  bctrl
	ctx.lr = 0x82E126D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E126D8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E126DC: 4082000C  bne 0x82e126e8
	if !ctx.cr[0].eq {
	pc = 0x82E126E8; continue 'dispatch;
	}
	// 82E126E0: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82E126E4: 48000008  b 0x82e126ec
	pc = 0x82E126EC; continue 'dispatch;
	// 82E126E8: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82E126EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E126F0: 482AD139  bl 0x830bf828
	ctx.lr = 0x82E126F4;
	sub_830BF828(ctx, base);
	// 82E126F4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E126F8: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82E126FC: 409AFFB0  bne cr6, 0x82e126ac
	if !ctx.cr[6].eq {
	pc = 0x82E126AC; continue 'dispatch;
	}
	// 82E12700: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82E12704: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E12708: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82E1270C: 48395AA0  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E12710 size=12
    let mut pc: u32 = 0x82E12710;
    'dispatch: loop {
        match pc {
            0x82E12710 => {
    //   block [0x82E12710..0x82E1271C)
	// 82E12710: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82E12714: 808BA4E8  lwz r4, -0x5b18(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23320 as u32) ) } as u64;
	// 82E12718: 4BFFFC48  b 0x82e12360
	sub_82E12360(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E12720 size=292
    let mut pc: u32 = 0x82E12720;
    'dispatch: loop {
        match pc {
            0x82E12720 => {
    //   block [0x82E12720..0x82E12844)
	// 82E12720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E12724: 48395A3D  bl 0x831a8160
	ctx.lr = 0x82E12728;
	sub_831A8130(ctx, base);
	// 82E12728: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E1272C: 3F808338  lis r28, -0x7cc8
	ctx.r[28].s64 = -2093481984;
	// 82E12730: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82E12734: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E12738: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E1273C: 3F408338  lis r26, -0x7cc8
	ctx.r[26].s64 = -2093481984;
	// 82E12740: 897C6534  lbz r11, 0x6534(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(25908 as u32) ) } as u64;
	// 82E12744: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E12748: 41820018  beq 0x82e12760
	if ctx.cr[0].eq {
	pc = 0x82E12760; continue 'dispatch;
	}
	// 82E1274C: 807A6538  lwz r3, 0x6538(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(25912 as u32) ) } as u64;
	// 82E12750: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12754: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E12758: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E1275C: 4E800421  bctrl
	ctx.lr = 0x82E12760;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E12760: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E12764: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12768: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E1276C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82E12770: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82E12774: 419A0024  beq cr6, 0x82e12798
	if ctx.cr[6].eq {
	pc = 0x82E12798; continue 'dispatch;
	}
	// 82E12778: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82E1277C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E12780: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E12784: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E12788: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E1278C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E12790: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E12794: 4082FFE8  bne 0x82e1277c
	if !ctx.cr[0].eq {
	pc = 0x82E1277C; continue 'dispatch;
	}
	// 82E12798: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E1279C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E127A0: 4BFE1461  bl 0x82df3c00
	ctx.lr = 0x82E127A4;
	sub_82DF3C00(ctx, base);
	// 82E127A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E127A8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82E127AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E127B0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E127B4: 48032CCD  bl 0x82e45480
	ctx.lr = 0x82E127B8;
	sub_82E45480(ctx, base);
	// 82E127B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E127BC: 4BFE0C6D  bl 0x82df3428
	ctx.lr = 0x82E127C0;
	sub_82DF3428(ctx, base);
	// 82E127C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E127C4: 419A000C  beq cr6, 0x82e127d0
	if ctx.cr[6].eq {
	pc = 0x82E127D0; continue 'dispatch;
	}
	// 82E127C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E127CC: 4B4AE0C5  bl 0x822c0890
	ctx.lr = 0x82E127D0;
	sub_822C0890(ctx, base);
	// 82E127D0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82E127D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E127D8: 4BFEC519  bl 0x82dfecf0
	ctx.lr = 0x82E127DC;
	sub_82DFECF0(ctx, base);
	// 82E127DC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82E127E0: 389B0028  addi r4, r27, 0x28
	ctx.r[4].s64 = ctx.r[27].s64 + 40;
	// 82E127E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E127E8: 4BFED9F9  bl 0x82e001e0
	ctx.lr = 0x82E127EC;
	sub_82E001E0(ctx, base);
	// 82E127EC: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82E127F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E127F4: 419A0008  beq cr6, 0x82e127fc
	if ctx.cr[6].eq {
	pc = 0x82E127FC; continue 'dispatch;
	}
	// 82E127F8: 4B4AE099  bl 0x822c0890
	ctx.lr = 0x82E127FC;
	sub_822C0890(ctx, base);
	// 82E127FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E12800: 4BFE0C29  bl 0x82df3428
	ctx.lr = 0x82E12804;
	sub_82DF3428(ctx, base);
	// 82E12804: 80610078  lwz r3, 0x78(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82E12808: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E1280C: 419A0008  beq cr6, 0x82e12814
	if ctx.cr[6].eq {
	pc = 0x82E12814; continue 'dispatch;
	}
	// 82E12810: 4B4AE081  bl 0x822c0890
	ctx.lr = 0x82E12814;
	sub_822C0890(ctx, base);
	// 82E12814: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82E12818: 4BFE0C11  bl 0x82df3428
	ctx.lr = 0x82E1281C;
	sub_82DF3428(ctx, base);
	// 82E1281C: 897C6534  lbz r11, 0x6534(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(25908 as u32) ) } as u64;
	// 82E12820: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E12824: 41820018  beq 0x82e1283c
	if ctx.cr[0].eq {
	pc = 0x82E1283C; continue 'dispatch;
	}
	// 82E12828: 807A6538  lwz r3, 0x6538(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(25912 as u32) ) } as u64;
	// 82E1282C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12830: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E12834: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E12838: 4E800421  bctrl
	ctx.lr = 0x82E1283C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E1283C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82E12840: 48395970  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E12848 size=100
    let mut pc: u32 = 0x82E12848;
    'dispatch: loop {
        match pc {
            0x82E12848 => {
    //   block [0x82E12848..0x82E128AC)
	// 82E12848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E1284C: 48395921  bl 0x831a816c
	ctx.lr = 0x82E12850;
	sub_831A8130(ctx, base);
	// 82E12850: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E12854: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E12858: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E1285C: 4BFFFAAD  bl 0x82e12308
	ctx.lr = 0x82E12860;
	sub_82E12308(ctx, base);
	// 82E12860: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E12864: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E12868: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E1286C: 48032145  bl 0x82e449b0
	ctx.lr = 0x82E12870;
	sub_82E449B0(ctx, base);
	// 82E12870: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E12874: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E12878: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E1287C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E12880: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82E12884: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E12888: 4BFE9B41  bl 0x82dfc3c8
	ctx.lr = 0x82E1288C;
	sub_82DFC3C8(ctx, base);
	// 82E1288C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82E12890: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E12894: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E12898: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82E1289C: 4BFF137D  bl 0x82e03c18
	ctx.lr = 0x82E128A0;
	sub_82E03C18(ctx, base);
	// 82E128A0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E128A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E128A8: 48395914  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E128B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E128B0 size=112
    let mut pc: u32 = 0x82E128B0;
    'dispatch: loop {
        match pc {
            0x82E128B0 => {
    //   block [0x82E128B0..0x82E12920)
	// 82E128B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E128B4: 483958B5  bl 0x831a8168
	ctx.lr = 0x82E128B8;
	sub_831A8130(ctx, base);
	// 82E128B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E128BC: 3FE08338  lis r31, -0x7cc8
	ctx.r[31].s64 = -2093481984;
	// 82E128C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E128C4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E128C8: 3F808338  lis r28, -0x7cc8
	ctx.r[28].s64 = -2093481984;
	// 82E128CC: 897F6534  lbz r11, 0x6534(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25908 as u32) ) } as u64;
	// 82E128D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E128D4: 41820018  beq 0x82e128ec
	if ctx.cr[0].eq {
	pc = 0x82E128EC; continue 'dispatch;
	}
	// 82E128D8: 807C6538  lwz r3, 0x6538(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(25912 as u32) ) } as u64;
	// 82E128DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E128E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E128E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E128E8: 4E800421  bctrl
	ctx.lr = 0x82E128EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E128EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E128F0: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82E128F4: 4BFFFF55  bl 0x82e12848
	ctx.lr = 0x82E128F8;
	sub_82E12848(ctx, base);
	// 82E128F8: 897F6534  lbz r11, 0x6534(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25908 as u32) ) } as u64;
	// 82E128FC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E12900: 41820018  beq 0x82e12918
	if ctx.cr[0].eq {
	pc = 0x82E12918; continue 'dispatch;
	}
	// 82E12904: 807C6538  lwz r3, 0x6538(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(25912 as u32) ) } as u64;
	// 82E12908: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E1290C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E12910: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E12914: 4E800421  bctrl
	ctx.lr = 0x82E12918;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E12918: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E1291C: 4839589C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E12920 size=212
    let mut pc: u32 = 0x82E12920;
    'dispatch: loop {
        match pc {
            0x82E12920 => {
    //   block [0x82E12920..0x82E129F4)
	// 82E12920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E12924: 48395845  bl 0x831a8168
	ctx.lr = 0x82E12928;
	sub_831A8130(ctx, base);
	// 82E12928: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E1292C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E12930: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E12934: 9381009C  stw r28, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[28].u32 ) };
	// 82E12938: 54AB063F  clrlwi. r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E1293C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82E12940: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E12944: 4182000C  beq 0x82e12950
	if ctx.cr[0].eq {
	pc = 0x82E12950; continue 'dispatch;
	}
	// 82E12948: 4BFFF791  bl 0x82e120d8
	ctx.lr = 0x82E1294C;
	sub_82E120D8(ctx, base);
	// 82E1294C: 48000008  b 0x82e12954
	pc = 0x82E12954; continue 'dispatch;
	// 82E12950: 4BFFF7F9  bl 0x82e12148
	ctx.lr = 0x82E12954;
	sub_82E12148(ctx, base);
	// 82E12954: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82E12958: 897E003D  lbz r11, 0x3d(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(61 as u32) ) } as u64;
	// 82E1295C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E12960: 4182001C  beq 0x82e1297c
	if ctx.cr[0].eq {
	pc = 0x82E1297C; continue 'dispatch;
	}
	// 82E12964: 3881009C  addi r4, r1, 0x9c
	ctx.r[4].s64 = ctx.r[1].s64 + 156;
	// 82E12968: 387E0040  addi r3, r30, 0x40
	ctx.r[3].s64 = ctx.r[30].s64 + 64;
	// 82E1296C: 480123DD  bl 0x82e24d48
	ctx.lr = 0x82E12970;
	sub_82E24D48(ctx, base);
	// 82E12970: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E12974: 997E003C  stb r11, 0x3c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), ctx.r[11].u8 ) };
	// 82E12978: 48000074  b 0x82e129ec
	pc = 0x82E129EC; continue 'dispatch;
	// 82E1297C: 3FE08338  lis r31, -0x7cc8
	ctx.r[31].s64 = -2093481984;
	// 82E12980: 3FA08338  lis r29, -0x7cc8
	ctx.r[29].s64 = -2093481984;
	// 82E12984: 897F6534  lbz r11, 0x6534(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25908 as u32) ) } as u64;
	// 82E12988: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E1298C: 41820018  beq 0x82e129a4
	if ctx.cr[0].eq {
	pc = 0x82E129A4; continue 'dispatch;
	}
	// 82E12990: 807D6538  lwz r3, 0x6538(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(25912 as u32) ) } as u64;
	// 82E12994: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12998: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E1299C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E129A0: 4E800421  bctrl
	ctx.lr = 0x82E129A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E129A4: 3881009C  addi r4, r1, 0x9c
	ctx.r[4].s64 = ctx.r[1].s64 + 156;
	// 82E129A8: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 82E129AC: 4801239D  bl 0x82e24d48
	ctx.lr = 0x82E129B0;
	sub_82E24D48(ctx, base);
	// 82E129B0: 897F6534  lbz r11, 0x6534(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25908 as u32) ) } as u64;
	// 82E129B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E129B8: 41820018  beq 0x82e129d0
	if ctx.cr[0].eq {
	pc = 0x82E129D0; continue 'dispatch;
	}
	// 82E129BC: 807D6538  lwz r3, 0x6538(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(25912 as u32) ) } as u64;
	// 82E129C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E129C4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E129C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E129CC: 4E800421  bctrl
	ctx.lr = 0x82E129D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E129D0: 3FE08332  lis r31, -0x7cce
	ctx.r[31].s64 = -2093875200;
	// 82E129D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E129D8: 809FA4E8  lwz r4, -0x5b18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-23320 as u32) ) } as u64;
	// 82E129DC: 4BFFF985  bl 0x82e12360
	ctx.lr = 0x82E129E0;
	sub_82E12360(ctx, base);
	// 82E129E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E129E4: 809FA4E8  lwz r4, -0x5b18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-23320 as u32) ) } as u64;
	// 82E129E8: 4BFFFA31  bl 0x82e12418
	ctx.lr = 0x82E129EC;
	sub_82E12418(ctx, base);
	// 82E129EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E129F0: 483957C8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E129F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E129F8 size=196
    let mut pc: u32 = 0x82E129F8;
    'dispatch: loop {
        match pc {
            0x82E129F8 => {
    //   block [0x82E129F8..0x82E12ABC)
	// 82E129F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E129FC: 4839576D  bl 0x831a8168
	ctx.lr = 0x82E12A00;
	sub_831A8130(ctx, base);
	// 82E12A00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E12A04: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E12A08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E12A0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E12A10: 93A1009C  stw r29, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[29].u32 ) };
	// 82E12A14: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E12A18: 897F003D  lbz r11, 0x3d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(61 as u32) ) } as u64;
	// 82E12A1C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E12A20: 4182001C  beq 0x82e12a3c
	if ctx.cr[0].eq {
	pc = 0x82E12A3C; continue 'dispatch;
	}
	// 82E12A24: 3881009C  addi r4, r1, 0x9c
	ctx.r[4].s64 = ctx.r[1].s64 + 156;
	// 82E12A28: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 82E12A2C: 4801231D  bl 0x82e24d48
	ctx.lr = 0x82E12A30;
	sub_82E24D48(ctx, base);
	// 82E12A30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E12A34: 997F003C  stb r11, 0x3c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u8 ) };
	// 82E12A38: 4800007C  b 0x82e12ab4
	pc = 0x82E12AB4; continue 'dispatch;
	// 82E12A3C: 3FC08338  lis r30, -0x7cc8
	ctx.r[30].s64 = -2093481984;
	// 82E12A40: 3F808338  lis r28, -0x7cc8
	ctx.r[28].s64 = -2093481984;
	// 82E12A44: 897E6534  lbz r11, 0x6534(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(25908 as u32) ) } as u64;
	// 82E12A48: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E12A4C: 41820018  beq 0x82e12a64
	if ctx.cr[0].eq {
	pc = 0x82E12A64; continue 'dispatch;
	}
	// 82E12A50: 807C6538  lwz r3, 0x6538(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(25912 as u32) ) } as u64;
	// 82E12A54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12A58: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E12A5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E12A60: 4E800421  bctrl
	ctx.lr = 0x82E12A64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E12A64: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E12A68: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E12A6C: 48000014  b 0x82e12a80
	pc = 0x82E12A80; continue 'dispatch;
	// 82E12A70: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12A74: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82E12A78: 419A0010  beq cr6, 0x82e12a88
	if ctx.cr[6].eq {
	pc = 0x82E12A88; continue 'dispatch;
	}
	// 82E12A7C: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 82E12A80: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E12A84: 409AFFEC  bne cr6, 0x82e12a70
	if !ctx.cr[6].eq {
	pc = 0x82E12A70; continue 'dispatch;
	}
	// 82E12A88: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 82E12A8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E12A90: 4BFFFA59  bl 0x82e124e8
	ctx.lr = 0x82E12A94;
	sub_82E124E8(ctx, base);
	// 82E12A94: 897E6534  lbz r11, 0x6534(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(25908 as u32) ) } as u64;
	// 82E12A98: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E12A9C: 41820018  beq 0x82e12ab4
	if ctx.cr[0].eq {
	pc = 0x82E12AB4; continue 'dispatch;
	}
	// 82E12AA0: 807C6538  lwz r3, 0x6538(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(25912 as u32) ) } as u64;
	// 82E12AA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12AA8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E12AAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E12AB0: 4E800421  bctrl
	ctx.lr = 0x82E12AB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E12AB4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E12AB8: 48395700  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12AC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E12AC0 size=144
    let mut pc: u32 = 0x82E12AC0;
    'dispatch: loop {
        match pc {
            0x82E12AC0 => {
    //   block [0x82E12AC0..0x82E12B50)
	// 82E12AC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E12AC4: 483956A5  bl 0x831a8168
	ctx.lr = 0x82E12AC8;
	sub_831A8130(ctx, base);
	// 82E12AC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E12ACC: 3FC08338  lis r30, -0x7cc8
	ctx.r[30].s64 = -2093481984;
	// 82E12AD0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E12AD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E12AD8: 93A1009C  stw r29, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[29].u32 ) };
	// 82E12ADC: 3F808338  lis r28, -0x7cc8
	ctx.r[28].s64 = -2093481984;
	// 82E12AE0: 897E6534  lbz r11, 0x6534(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(25908 as u32) ) } as u64;
	// 82E12AE4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E12AE8: 41820018  beq 0x82e12b00
	if ctx.cr[0].eq {
	pc = 0x82E12B00; continue 'dispatch;
	}
	// 82E12AEC: 807C6538  lwz r3, 0x6538(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(25912 as u32) ) } as u64;
	// 82E12AF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12AF4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E12AF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E12AFC: 4E800421  bctrl
	ctx.lr = 0x82E12B00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E12B00: 3881009C  addi r4, r1, 0x9c
	ctx.r[4].s64 = ctx.r[1].s64 + 156;
	// 82E12B04: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 82E12B08: 48012241  bl 0x82e24d48
	ctx.lr = 0x82E12B0C;
	sub_82E24D48(ctx, base);
	// 82E12B0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E12B10: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E12B14: 997F0039  stb r11, 0x39(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(57 as u32), ctx.r[11].u8 ) };
	// 82E12B18: 897E6534  lbz r11, 0x6534(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(25908 as u32) ) } as u64;
	// 82E12B1C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E12B20: 41820018  beq 0x82e12b38
	if ctx.cr[0].eq {
	pc = 0x82E12B38; continue 'dispatch;
	}
	// 82E12B24: 807C6538  lwz r3, 0x6538(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(25912 as u32) ) } as u64;
	// 82E12B28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12B2C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E12B30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E12B34: 4E800421  bctrl
	ctx.lr = 0x82E12B38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E12B38: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E12B3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E12B40: 419A0008  beq cr6, 0x82e12b48
	if ctx.cr[6].eq {
	pc = 0x82E12B48; continue 'dispatch;
	}
	// 82E12B44: 4BFFF4C5  bl 0x82e12008
	ctx.lr = 0x82E12B48;
	sub_82E12008(ctx, base);
	// 82E12B48: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E12B4C: 4839566C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E12B50 size=160
    let mut pc: u32 = 0x82E12B50;
    'dispatch: loop {
        match pc {
            0x82E12B50 => {
    //   block [0x82E12B50..0x82E12BF0)
	// 82E12B50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E12B54: 48395619  bl 0x831a816c
	ctx.lr = 0x82E12B58;
	sub_831A8130(ctx, base);
	// 82E12B58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E12B5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E12B60: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E12B64: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E12B68: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E12B6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E12B70: 419A000C  beq cr6, 0x82e12b7c
	if ctx.cr[6].eq {
	pc = 0x82E12B7C; continue 'dispatch;
	}
	// 82E12B74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E12B78: 4BFFFE81  bl 0x82e129f8
	ctx.lr = 0x82E12B7C;
	sub_82E129F8(ctx, base);
	// 82E12B7C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E12B80: 419A0018  beq cr6, 0x82e12b98
	if ctx.cr[6].eq {
	pc = 0x82E12B98; continue 'dispatch;
	}
	// 82E12B84: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E12B88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E12B8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E12B90: 4BFFFD91  bl 0x82e12920
	ctx.lr = 0x82E12B94;
	sub_82E12920(ctx, base);
	// 82E12B94: 48000054  b 0x82e12be8
	pc = 0x82E12BE8; continue 'dispatch;
	// 82E12B98: 3FC08338  lis r30, -0x7cc8
	ctx.r[30].s64 = -2093481984;
	// 82E12B9C: 3FA08338  lis r29, -0x7cc8
	ctx.r[29].s64 = -2093481984;
	// 82E12BA0: 897E6534  lbz r11, 0x6534(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(25908 as u32) ) } as u64;
	// 82E12BA4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E12BA8: 41820018  beq 0x82e12bc0
	if ctx.cr[0].eq {
	pc = 0x82E12BC0; continue 'dispatch;
	}
	// 82E12BAC: 807D6538  lwz r3, 0x6538(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(25912 as u32) ) } as u64;
	// 82E12BB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12BB4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E12BB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E12BBC: 4E800421  bctrl
	ctx.lr = 0x82E12BC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E12BC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E12BC4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E12BC8: 897E6534  lbz r11, 0x6534(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(25908 as u32) ) } as u64;
	// 82E12BCC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E12BD0: 41820018  beq 0x82e12be8
	if ctx.cr[0].eq {
	pc = 0x82E12BE8; continue 'dispatch;
	}
	// 82E12BD4: 807D6538  lwz r3, 0x6538(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(25912 as u32) ) } as u64;
	// 82E12BD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12BDC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E12BE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E12BE4: 4E800421  bctrl
	ctx.lr = 0x82E12BE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E12BE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E12BEC: 483955D0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12BF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E12BF0 size=236
    let mut pc: u32 = 0x82E12BF0;
    'dispatch: loop {
        match pc {
            0x82E12BF0 => {
    //   block [0x82E12BF0..0x82E12CDC)
	// 82E12BF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E12BF4: 4839556D  bl 0x831a8160
	ctx.lr = 0x82E12BF8;
	sub_831A8130(ctx, base);
	// 82E12BF8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E12BFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E12C00: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82E12C04: 897F003C  lbz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82E12C08: 9B5F003D  stb r26, 0x3d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(61 as u32), ctx.r[26].u8 ) };
	// 82E12C0C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E12C10: 418200C4  beq 0x82e12cd4
	if ctx.cr[0].eq {
	pc = 0x82E12CD4; continue 'dispatch;
	}
	// 82E12C14: 83BF0048  lwz r29, 0x48(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E12C18: 83DF0044  lwz r30, 0x44(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E12C1C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82E12C20: 419A0030  beq cr6, 0x82e12c50
	if ctx.cr[6].eq {
	pc = 0x82E12C50; continue 'dispatch;
	}
	// 82E12C24: 3B9F0008  addi r28, r31, 8
	ctx.r[28].s64 = ctx.r[31].s64 + 8;
	// 82E12C28: 3F608332  lis r27, -0x7cce
	ctx.r[27].s64 = -2093875200;
	// 82E12C2C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E12C30: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E12C34: 48012115  bl 0x82e24d48
	ctx.lr = 0x82E12C38;
	sub_82E24D48(ctx, base);
	// 82E12C38: 809BA4E8  lwz r4, -0x5b18(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-23320 as u32) ) } as u64;
	// 82E12C3C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12C40: 4BFFF7D9  bl 0x82e12418
	ctx.lr = 0x82E12C44;
	sub_82E12418(ctx, base);
	// 82E12C44: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82E12C48: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82E12C4C: 409AFFE0  bne cr6, 0x82e12c2c
	if !ctx.cr[6].eq {
	pc = 0x82E12C2C; continue 'dispatch;
	}
	// 82E12C50: 389F0040  addi r4, r31, 0x40
	ctx.r[4].s64 = ctx.r[31].s64 + 64;
	// 82E12C54: 80DF0048  lwz r6, 0x48(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82E12C58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E12C5C: 80BF0044  lwz r5, 0x44(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82E12C60: 48052119  bl 0x82e64d78
	ctx.lr = 0x82E12C64;
	sub_82E64D78(ctx, base);
	// 82E12C64: 83BF0058  lwz r29, 0x58(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E12C68: 83DF0054  lwz r30, 0x54(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E12C6C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82E12C70: 419A004C  beq cr6, 0x82e12cbc
	if ctx.cr[6].eq {
	pc = 0x82E12CBC; continue 'dispatch;
	}
	// 82E12C74: 3B9F0008  addi r28, r31, 8
	ctx.r[28].s64 = ctx.r[31].s64 + 8;
	// 82E12C78: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E12C7C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E12C80: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E12C84: 419A0020  beq cr6, 0x82e12ca4
	if ctx.cr[6].eq {
	pc = 0x82E12CA4; continue 'dispatch;
	}
	// 82E12C88: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12C8C: 81250000  lwz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12C90: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E12C94: 419A0010  beq cr6, 0x82e12ca4
	if ctx.cr[6].eq {
	pc = 0x82E12CA4; continue 'dispatch;
	}
	// 82E12C98: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 82E12C9C: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E12CA0: 409AFFEC  bne cr6, 0x82e12c8c
	if !ctx.cr[6].eq {
	pc = 0x82E12C8C; continue 'dispatch;
	}
	// 82E12CA4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E12CA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E12CAC: 4BFFF83D  bl 0x82e124e8
	ctx.lr = 0x82E12CB0;
	sub_82E124E8(ctx, base);
	// 82E12CB0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82E12CB4: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82E12CB8: 409AFFC0  bne cr6, 0x82e12c78
	if !ctx.cr[6].eq {
	pc = 0x82E12C78; continue 'dispatch;
	}
	// 82E12CBC: 389F0050  addi r4, r31, 0x50
	ctx.r[4].s64 = ctx.r[31].s64 + 80;
	// 82E12CC0: 80DF0058  lwz r6, 0x58(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82E12CC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E12CC8: 80BF0054  lwz r5, 0x54(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E12CCC: 480520AD  bl 0x82e64d78
	ctx.lr = 0x82E12CD0;
	sub_82E64D78(ctx, base);
	// 82E12CD0: 9B5F003C  stb r26, 0x3c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[26].u8 ) };
	// 82E12CD4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E12CD8: 483954D8  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E12CE0 size=152
    let mut pc: u32 = 0x82E12CE0;
    'dispatch: loop {
        match pc {
            0x82E12CE0 => {
    //   block [0x82E12CE0..0x82E12D78)
	// 82E12CE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E12CE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E12CE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E12CEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E12CF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E12CF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E12CF8: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E12CFC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E12D00: 396BBC48  addi r11, r11, -0x43b8
	ctx.r[11].s64 = ctx.r[11].s64 + -17336;
	// 82E12D04: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82E12D08: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82E12D0C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E12D10: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82E12D14: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82E12D18: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82E12D1C: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82E12D20: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82E12D24: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 82E12D28: 482B05F1  bl 0x830c3318
	ctx.lr = 0x82E12D2C;
	sub_830C3318(ctx, base);
	// 82E12D2C: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 82E12D30: 9BDF0038  stb r30, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u8 ) };
	// 82E12D34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E12D38: 9BDF0039  stb r30, 0x39(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(57 as u32), ctx.r[30].u8 ) };
	// 82E12D3C: 9BDF003A  stb r30, 0x3a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(58 as u32), ctx.r[30].u8 ) };
	// 82E12D40: 9BDF003C  stb r30, 0x3c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u8 ) };
	// 82E12D44: 9BDF003D  stb r30, 0x3d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(61 as u32), ctx.r[30].u8 ) };
	// 82E12D48: 93DF0044  stw r30, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[30].u32 ) };
	// 82E12D4C: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 82E12D50: 93DF004C  stw r30, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 82E12D54: 93DF0054  stw r30, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82E12D58: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82E12D5C: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82E12D60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E12D64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E12D68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E12D6C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E12D70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E12D74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E12D78 size=180
    let mut pc: u32 = 0x82E12D78;
    'dispatch: loop {
        match pc {
            0x82E12D78 => {
    //   block [0x82E12D78..0x82E12E2C)
	// 82E12D78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E12D7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E12D80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E12D84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E12D88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E12D8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E12D90: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E12D94: 396BBC48  addi r11, r11, -0x43b8
	ctx.r[11].s64 = ctx.r[11].s64 + -17336;
	// 82E12D98: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E12D9C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E12DA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E12DA4: 419A000C  beq cr6, 0x82e12db0
	if ctx.cr[6].eq {
	pc = 0x82E12DB0; continue 'dispatch;
	}
	// 82E12DA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E12DAC: 4BFFFC4D  bl 0x82e129f8
	ctx.lr = 0x82E12DB0;
	sub_82E129F8(ctx, base);
	// 82E12DB0: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E12DB4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E12DB8: 48000014  b 0x82e12dcc
	pc = 0x82E12DCC; continue 'dispatch;
	// 82E12DBC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12DC0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82E12DC4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E12DC8: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82E12DCC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E12DD0: 409AFFEC  bne cr6, 0x82e12dbc
	if !ctx.cr[6].eq {
	pc = 0x82E12DBC; continue 'dispatch;
	}
	// 82E12DD4: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 82E12DD8: 80DF0010  lwz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E12DDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E12DE0: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E12DE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E12DE8: 48051F91  bl 0x82e64d78
	ctx.lr = 0x82E12DEC;
	sub_82E64D78(ctx, base);
	// 82E12DEC: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 82E12DF0: 4BFEC2E9  bl 0x82dff0d8
	ctx.lr = 0x82E12DF4;
	sub_82DFF0D8(ctx, base);
	// 82E12DF4: 387F0040  addi r3, r31, 0x40
	ctx.r[3].s64 = ctx.r[31].s64 + 64;
	// 82E12DF8: 4BFEC2E1  bl 0x82dff0d8
	ctx.lr = 0x82E12DFC;
	sub_82DFF0D8(ctx, base);
	// 82E12DFC: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82E12E00: 4BFF1139  bl 0x82e03f38
	ctx.lr = 0x82E12E04;
	sub_82E03F38(ctx, base);
	// 82E12E04: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 82E12E08: 4BFEC2D1  bl 0x82dff0d8
	ctx.lr = 0x82E12E0C;
	sub_82DFF0D8(ctx, base);
	// 82E12E0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E12E10: 4BFEC2C9  bl 0x82dff0d8
	ctx.lr = 0x82E12E14;
	sub_82DFF0D8(ctx, base);
	// 82E12E14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E12E18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E12E1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E12E20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E12E24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E12E28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12E30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E12E30 size=8
    let mut pc: u32 = 0x82E12E30;
    'dispatch: loop {
        match pc {
            0x82E12E30 => {
    //   block [0x82E12E30..0x82E12E38)
	// 82E12E30: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E12E34: 4BFFFAEC  b 0x82e12920
	sub_82E12920(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E12E38 size=8
    let mut pc: u32 = 0x82E12E38;
    'dispatch: loop {
        match pc {
            0x82E12E38 => {
    //   block [0x82E12E38..0x82E12E40)
	// 82E12E38: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E12E3C: 4BFFFAE4  b 0x82e12920
	sub_82E12920(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E12E40 size=400
    let mut pc: u32 = 0x82E12E40;
    'dispatch: loop {
        match pc {
            0x82E12E40 => {
    //   block [0x82E12E40..0x82E12FD0)
	// 82E12E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E12E44: 48395315  bl 0x831a8158
	ctx.lr = 0x82E12E48;
	sub_831A8130(ctx, base);
	// 82E12E48: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82E12E4C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E12E50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E12E54: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82E12E58: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82E12E5C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E12E60: 54EB063F  clrlwi. r11, r7, 0x18
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E12E64: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82E12E68: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82E12E6C: 40820010  bne 0x82e12e7c
	if !ctx.cr[0].eq {
	pc = 0x82E12E7C; continue 'dispatch;
	}
	// 82E12E70: 897F0038  lbz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82E12E74: 7F0BC840  cmplw cr6, r11, r25
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82E12E78: 419A00AC  beq cr6, 0x82e12f24
	if ctx.cr[6].eq {
	pc = 0x82E12F24; continue 'dispatch;
	}
	// 82E12E7C: 897F003A  lbz r11, 0x3a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(58 as u32) ) } as u64;
	// 82E12E80: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E12E84: 40820098  bne 0x82e12f1c
	if !ctx.cr[0].eq {
	pc = 0x82E12F1C; continue 'dispatch;
	}
	// 82E12E88: 3FC08338  lis r30, -0x7cc8
	ctx.r[30].s64 = -2093481984;
	// 82E12E8C: 3F808338  lis r28, -0x7cc8
	ctx.r[28].s64 = -2093481984;
	// 82E12E90: 897E6534  lbz r11, 0x6534(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(25908 as u32) ) } as u64;
	// 82E12E94: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E12E98: 41820018  beq 0x82e12eb0
	if ctx.cr[0].eq {
	pc = 0x82E12EB0; continue 'dispatch;
	}
	// 82E12E9C: 807C6538  lwz r3, 0x6538(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(25912 as u32) ) } as u64;
	// 82E12EA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12EA4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E12EA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E12EAC: 4E800421  bctrl
	ctx.lr = 0x82E12EB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E12EB0: 897F003A  lbz r11, 0x3a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(58 as u32) ) } as u64;
	// 82E12EB4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E12EB8: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E12EBC: 40820008  bne 0x82e12ec4
	if !ctx.cr[0].eq {
	pc = 0x82E12EC4; continue 'dispatch;
	}
	// 82E12EC0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E12EC4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12EC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E12ECC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E12ED0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E12ED4: 4E800421  bctrl
	ctx.lr = 0x82E12ED8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E12ED8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E12EDC: 4082000C  bne 0x82e12ee8
	if !ctx.cr[0].eq {
	pc = 0x82E12EE8; continue 'dispatch;
	}
	// 82E12EE0: 9B3F0038  stb r25, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[25].u8 ) };
	// 82E12EE4: 48000008  b 0x82e12eec
	pc = 0x82E12EEC; continue 'dispatch;
	// 82E12EE8: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82E12EEC: 897E6534  lbz r11, 0x6534(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(25908 as u32) ) } as u64;
	// 82E12EF0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E12EF4: 41820018  beq 0x82e12f0c
	if ctx.cr[0].eq {
	pc = 0x82E12F0C; continue 'dispatch;
	}
	// 82E12EF8: 807C6538  lwz r3, 0x6538(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(25912 as u32) ) } as u64;
	// 82E12EFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12F00: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E12F04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E12F08: 4E800421  bctrl
	ctx.lr = 0x82E12F0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E12F0C: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82E12F10: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82E12F14: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E12F18: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82E12F1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E12F20: 997F0039  stb r11, 0x39(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(57 as u32), ctx.r[11].u8 ) };
	// 82E12F24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E12F28: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E12F2C: 4BFFF6AD  bl 0x82e125d8
	ctx.lr = 0x82E12F30;
	sub_82E125D8(ctx, base);
	// 82E12F30: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82E12F34: 409A0008  bne cr6, 0x82e12f3c
	if !ctx.cr[6].eq {
	pc = 0x82E12F3C; continue 'dispatch;
	}
	// 82E12F38: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82E12F3C: 897F0039  lbz r11, 0x39(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(57 as u32) ) } as u64;
	// 82E12F40: 7F0BC840  cmplw cr6, r11, r25
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82E12F44: 419A007C  beq cr6, 0x82e12fc0
	if ctx.cr[6].eq {
	pc = 0x82E12FC0; continue 'dispatch;
	}
	// 82E12F48: 897F003A  lbz r11, 0x3a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(58 as u32) ) } as u64;
	// 82E12F4C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E12F50: 839F0010  lwz r28, 0x10(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E12F54: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82E12F58: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E12F5C: 995F003D  stb r10, 0x3d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(61 as u32), ctx.r[10].u8 ) };
	// 82E12F60: 40820008  bne 0x82e12f68
	if !ctx.cr[0].eq {
	pc = 0x82E12F68; continue 'dispatch;
	}
	// 82E12F64: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82E12F68: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E12F6C: 48000030  b 0x82e12f9c
	pc = 0x82E12F9C; continue 'dispatch;
	// 82E12F70: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E12F74: 7C001A2C  dcbt 0, r3
	// 82E12F78: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82E12F7C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E12F80: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82E12F84: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82E12F88: 4BFFFEB9  bl 0x82e12e40
	ctx.lr = 0x82E12F8C;
	sub_82E12E40(ctx, base);
	// 82E12F8C: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82E12F90: 409A0008  bne cr6, 0x82e12f98
	if !ctx.cr[6].eq {
	pc = 0x82E12F98; continue 'dispatch;
	}
	// 82E12F94: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82E12F98: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82E12F9C: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82E12FA0: 409AFFD0  bne cr6, 0x82e12f70
	if !ctx.cr[6].eq {
	pc = 0x82E12F70; continue 'dispatch;
	}
	// 82E12FA4: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E12FA8: 4182000C  beq 0x82e12fb4
	if ctx.cr[0].eq {
	pc = 0x82E12FB4; continue 'dispatch;
	}
	// 82E12FAC: 9B3F0039  stb r25, 0x39(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(57 as u32), ctx.r[25].u8 ) };
	// 82E12FB0: 48000008  b 0x82e12fb8
	pc = 0x82E12FB8; continue 'dispatch;
	// 82E12FB4: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82E12FB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E12FBC: 4BFFFC35  bl 0x82e12bf0
	ctx.lr = 0x82E12FC0;
	sub_82E12BF0(ctx, base);
	// 82E12FC0: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82E12FC4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E12FC8: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82E12FCC: 483951DC  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E12FD0 size=8
    let mut pc: u32 = 0x82E12FD0;
    'dispatch: loop {
        match pc {
            0x82E12FD0 => {
    //   block [0x82E12FD0..0x82E12FD8)
	// 82E12FD0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E12FD4: 4BFFFB7C  b 0x82e12b50
	sub_82E12B50(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E12FD8 size=8
    let mut pc: u32 = 0x82E12FD8;
    'dispatch: loop {
        match pc {
            0x82E12FD8 => {
    //   block [0x82E12FD8..0x82E12FE0)
	// 82E12FD8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E12FDC: 4BFFFB74  b 0x82e12b50
	sub_82E12B50(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E12FE0 size=20
    let mut pc: u32 = 0x82E12FE0;
    'dispatch: loop {
        match pc {
            0x82E12FE0 => {
    //   block [0x82E12FE0..0x82E12FF4)
	// 82E12FE0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82E12FE4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82E12FE8: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 82E12FEC: 808BA4E8  lwz r4, -0x5b18(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23320 as u32) ) } as u64;
	// 82E12FF0: 4BFFFE50  b 0x82e12e40
	sub_82E12E40(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E12FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E12FF8 size=8
    let mut pc: u32 = 0x82E12FF8;
    'dispatch: loop {
        match pc {
            0x82E12FF8 => {
    //   block [0x82E12FF8..0x82E13000)
	// 82E12FF8: 38630060  addi r3, r3, 0x60
	ctx.r[3].s64 = ctx.r[3].s64 + 96;
	// 82E12FFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E13000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E13000 size=8
    let mut pc: u32 = 0x82E13000;
    'dispatch: loop {
        match pc {
            0x82E13000 => {
    //   block [0x82E13000..0x82E13008)
	// 82E13000: 386300A0  addi r3, r3, 0xa0
	ctx.r[3].s64 = ctx.r[3].s64 + 160;
	// 82E13004: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E13008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E13008 size=152
    let mut pc: u32 = 0x82E13008;
    'dispatch: loop {
        match pc {
            0x82E13008 => {
    //   block [0x82E13008..0x82E130A0)
	// 82E13008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E1300C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E13010: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E13014: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E13018: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E1301C: 4BFFFCC5  bl 0x82e12ce0
	ctx.lr = 0x82E13020;
	sub_82E12CE0(ctx, base);
	// 82E13020: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82E13024: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E13028: 38CB6880  addi r6, r11, 0x6880
	ctx.r[6].s64 = ctx.r[11].s64 + 26752;
	// 82E1302C: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82E13030: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82E13034: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82E13038: 397F0060  addi r11, r31, 0x60
	ctx.r[11].s64 = ctx.r[31].s64 + 96;
	// 82E1303C: 38AABC58  addi r5, r10, -0x43a8
	ctx.r[5].s64 = ctx.r[10].s64 + -17320;
	// 82E13040: 395F00A0  addi r10, r31, 0xa0
	ctx.r[10].s64 = ctx.r[31].s64 + 160;
	// 82E13044: 90BF0000  stw r5, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82E13048: 13E73407  vcmpneb. (lvlx128) v31, v7, v6
	tmp.u32 = ctx.r[7].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E1304C: 13C83407  vcmpneb. (lvlx128) v30, v8, v6
	tmp.u32 = ctx.r[8].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E13050: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E13054: 13A93407  vcmpneb. (lvlx128) v29, v9, v6
	tmp.u32 = ctx.r[9].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E13058: 13803407  vcmpneb. (lvlx128) v28, v0, v6
	tmp.u32 = ctx.r[6].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E130A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E130A0 size=76
    let mut pc: u32 = 0x82E130A0;
    'dispatch: loop {
        match pc {
            0x82E130A0 => {
    //   block [0x82E130A0..0x82E130EC)
	// 82E130A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E130A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E130A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E130AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E130B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E130B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E130B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E130BC: 4BFFFCBD  bl 0x82e12d78
	ctx.lr = 0x82E130C0;
	sub_82E12D78(ctx, base);
	// 82E130C0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E130C4: 4182000C  beq 0x82e130d0
	if ctx.cr[0].eq {
	pc = 0x82E130D0; continue 'dispatch;
	}
	// 82E130C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E130CC: 4BFDF30D  bl 0x82df23d8
	ctx.lr = 0x82E130D0;
	sub_82DF23D8(ctx, base);
	// 82E130D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E130D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E130D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E130DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E130E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E130E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E130E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E130F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E130F0 size=156
    let mut pc: u32 = 0x82E130F0;
    'dispatch: loop {
        match pc {
            0x82E130F0 => {
    //   block [0x82E130F0..0x82E1318C)
	// 82E130F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E130F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E130F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E130FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E13100: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E13104: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E13108: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E1310C: 4BFFFBD5  bl 0x82e12ce0
	ctx.lr = 0x82E13110;
	sub_82E12CE0(ctx, base);
	// 82E13110: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E13114: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82E13118: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82E1311C: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82E13120: 397F0060  addi r11, r31, 0x60
	ctx.r[11].s64 = ctx.r[31].s64 + 96;
	// 82E13124: 38CABC58  addi r6, r10, -0x43a8
	ctx.r[6].s64 = ctx.r[10].s64 + -17320;
	// 82E13128: 395F00A0  addi r10, r31, 0xa0
	ctx.r[10].s64 = ctx.r[31].s64 + 160;
	// 82E1312C: 90DF0000  stw r6, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82E13130: 13E7F407  vcmpneb. (lvlx128) v31, v7, v30
	tmp.u32 = ctx.r[7].u32 + ctx.r[30].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E13134: 13C8F407  vcmpneb. (lvlx128) v30, v8, v30
	tmp.u32 = ctx.r[8].u32 + ctx.r[30].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E13138: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E1313C: 13A9F407  vcmpneb. (lvlx128) v29, v9, v30
	tmp.u32 = ctx.r[9].u32 + ctx.r[30].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E13140: 1380F407  vcmpneb. (lvlx128) v28, v0, v30
	tmp.u32 = ctx.r[30].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E13190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E13190 size=204
    let mut pc: u32 = 0x82E13190;
    'dispatch: loop {
        match pc {
            0x82E13190 => {
    //   block [0x82E13190..0x82E1325C)
	// 82E13190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E13194: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E13198: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E1319C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E131A0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E131A4: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82E131A8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82E131AC: 419A0060  beq cr6, 0x82e1320c
	if ctx.cr[6].eq {
	pc = 0x82E1320C; continue 'dispatch;
	}
	// 82E131B0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E131B4: 3BEA00A0  addi r31, r10, 0xa0
	ctx.r[31].s64 = ctx.r[10].s64 + 160;
	// 82E131B8: 3BCA0060  addi r30, r10, 0x60
	ctx.r[30].s64 = ctx.r[10].s64 + 96;
	// 82E131BC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82E131C0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E131C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E131C8: 4E800421  bctrl
	ctx.lr = 0x82E131CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E131CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E131D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E131D4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E131D8: 4B4B1729  bl 0x822c4900
	ctx.lr = 0x82E131DC;
	sub_822C4900(ctx, base);
	// 82E131DC: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82E131E0: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82E131E4: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E131E8: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82E131EC: 13C71C07  vcmpneb. (lvlx128) v30, v7, v3
	tmp.u32 = ctx.r[7].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E131F0: 13A81C07  vcmpneb. (lvlx128) v29, v8, v3
	tmp.u32 = ctx.r[8].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E131F4: 13891C07  vcmpneb. (lvlx128) v28, v9, v3
	tmp.u32 = ctx.r[9].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E13260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E13260 size=52
    let mut pc: u32 = 0x82E13260;
    'dispatch: loop {
        match pc {
            0x82E13260 => {
    //   block [0x82E13260..0x82E13294)
	// 82E13260: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82E13264: 13E02407  vcmpneb. (lvlx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E13268: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 82E1326C: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 82E13270: 39630060  addi r11, r3, 0x60
	ctx.r[11].s64 = ctx.r[3].s64 + 96;
	// 82E13274: 13C82407  vcmpneb. (lvlx128) v30, v8, v4
	tmp.u32 = ctx.r[8].u32 + ctx.r[4].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E13278: 13A92407  vcmpneb. (lvlx128) v29, v9, v4
	tmp.u32 = ctx.r[9].u32 + ctx.r[4].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E1327C: 138A2407  vcmpneb. (lvlx128) v28, v10, v4
	tmp.u32 = ctx.r[10].u32 + ctx.r[4].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E13298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E13298 size=16
    let mut pc: u32 = 0x82E13298;
    'dispatch: loop {
        match pc {
            0x82E13298 => {
    //   block [0x82E13298..0x82E132A8)
	// 82E13298: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E1329C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E132A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E132A4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E132A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E132A8 size=8
    let mut pc: u32 = 0x82E132A8;
    'dispatch: loop {
        match pc {
            0x82E132A8 => {
    //   block [0x82E132A8..0x82E132B0)
	// 82E132A8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E132AC: 4BFFBADC  b 0x82e0ed88
	sub_82E0ED88(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E132B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E132B0 size=4
    let mut pc: u32 = 0x82E132B0;
    'dispatch: loop {
        match pc {
            0x82E132B0 => {
    //   block [0x82E132B0..0x82E132B4)
	// 82E132B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E132B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E132B8 size=60
    let mut pc: u32 = 0x82E132B8;
    'dispatch: loop {
        match pc {
            0x82E132B8 => {
    //   block [0x82E132B8..0x82E132F4)
	// 82E132B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E132BC: 48394EB1  bl 0x831a816c
	ctx.lr = 0x82E132C0;
	sub_831A8130(ctx, base);
	// 82E132C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E132C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E132C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E132CC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E132D0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E132D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E132D8: 419A000C  beq cr6, 0x82e132e4
	if ctx.cr[6].eq {
	pc = 0x82E132E4; continue 'dispatch;
	}
	// 82E132DC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E132E0: 4BFFBAA9  bl 0x82e0ed88
	ctx.lr = 0x82E132E4;
	sub_82E0ED88(ctx, base);
	// 82E132E4: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82E132E8: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82E132EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E132F0: 48394ECC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E132F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E132F8 size=76
    let mut pc: u32 = 0x82E132F8;
    'dispatch: loop {
        match pc {
            0x82E132F8 => {
    //   block [0x82E132F8..0x82E13344)
	// 82E132F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E132FC: 48394E71  bl 0x831a816c
	ctx.lr = 0x82E13300;
	sub_831A8130(ctx, base);
	// 82E13300: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E13304: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E13308: 83C40000  lwz r30, 0(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E1330C: 83A40004  lwz r29, 4(r4)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E13310: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E13314: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E13318: 419A000C  beq cr6, 0x82e13324
	if ctx.cr[6].eq {
	pc = 0x82E13324; continue 'dispatch;
	}
	// 82E1331C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13320: 4BFFBA69  bl 0x82e0ed88
	ctx.lr = 0x82E13324;
	sub_82E0ED88(ctx, base);
	// 82E13324: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82E13328: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E1332C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82E13330: 419A000C  beq cr6, 0x82e1333c
	if ctx.cr[6].eq {
	pc = 0x82E1333C; continue 'dispatch;
	}
	// 82E13334: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E13338: 4BDCBC29  bl 0x82bdef60
	ctx.lr = 0x82E1333C;
	sub_82BDEF60(ctx, base);
	// 82E1333C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E13340: 48394E7C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E13348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E13348 size=16
    let mut pc: u32 = 0x82E13348;
    'dispatch: loop {
        match pc {
            0x82E13348 => {
    //   block [0x82E13348..0x82E13358)
	// 82E13348: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E1334C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E13350: 419A0008  beq cr6, 0x82e13358
	if ctx.cr[6].eq {
		sub_82E13358(ctx, base);
		return;
	}
	// 82E13354: 4BFEB48C  b 0x82dfe7e0
	sub_82DFE7E0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E13358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E13358 size=8
    let mut pc: u32 = 0x82E13358;
    'dispatch: loop {
        match pc {
            0x82E13358 => {
    //   block [0x82E13358..0x82E13360)
	// 82E13358: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E1335C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E13360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E13360 size=80
    let mut pc: u32 = 0x82E13360;
    'dispatch: loop {
        match pc {
            0x82E13360 => {
    //   block [0x82E13360..0x82E133B0)
	// 82E13360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E13364: 48394E01  bl 0x831a8164
	ctx.lr = 0x82E13368;
	sub_831A8130(ctx, base);
	// 82E13368: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E1336C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E13370: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E13374: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82E13378: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82E1337C: 83FE000C  lwz r31, 0xc(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E13380: 4800001C  b 0x82e1339c
	pc = 0x82E1339C; continue 'dispatch;
	// 82E13384: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82E13388: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E1338C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82E13390: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E13394: 4BFFEB6D  bl 0x82e11f00
	ctx.lr = 0x82E13398;
	sub_82E11F00(ctx, base);
	// 82E13398: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82E1339C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E133A0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E133A4: 409AFFE0  bne cr6, 0x82e13384
	if !ctx.cr[6].eq {
	pc = 0x82E13384; continue 'dispatch;
	}
	// 82E133A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E133AC: 48394E08  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E133B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E133B0 size=84
    let mut pc: u32 = 0x82E133B0;
    'dispatch: loop {
        match pc {
            0x82E133B0 => {
    //   block [0x82E133B0..0x82E13404)
	// 82E133B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E133B4: 48394DB5  bl 0x831a8168
	ctx.lr = 0x82E133B8;
	sub_831A8130(ctx, base);
	// 82E133B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E133BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E133C0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E133C4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82E133C8: 83FE000C  lwz r31, 0xc(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E133CC: 48000024  b 0x82e133f0
	pc = 0x82E133F0; continue 'dispatch;
	// 82E133D0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E133D4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82E133D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E133DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E133E0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E133E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E133E8: 4E800421  bctrl
	ctx.lr = 0x82E133EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E133EC: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82E133F0: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E133F4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E133F8: 409AFFD8  bne cr6, 0x82e133d0
	if !ctx.cr[6].eq {
	pc = 0x82E133D0; continue 'dispatch;
	}
	// 82E133FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E13400: 48394DB8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E13408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E13408 size=144
    let mut pc: u32 = 0x82E13408;
    'dispatch: loop {
        match pc {
            0x82E13408 => {
    //   block [0x82E13408..0x82E13498)
	// 82E13408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E1340C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E13410: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E13414: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E13418: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E1341C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E13420: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E13424: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E13428: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E1342C: 419A0054  beq cr6, 0x82e13480
	if ctx.cr[6].eq {
	pc = 0x82E13480; continue 'dispatch;
	}
	// 82E13430: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13434: 81250000  lwz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13438: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82E1343C: 419A0010  beq cr6, 0x82e1344c
	if ctx.cr[6].eq {
	pc = 0x82E1344C; continue 'dispatch;
	}
	// 82E13440: 38A50008  addi r5, r5, 8
	ctx.r[5].s64 = ctx.r[5].s64 + 8;
	// 82E13444: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E13448: 409AFFEC  bne cr6, 0x82e13434
	if !ctx.cr[6].eq {
	pc = 0x82E13434; continue 'dispatch;
	}
	// 82E1344C: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E13450: 419A0030  beq cr6, 0x82e13480
	if ctx.cr[6].eq {
	pc = 0x82E13480; continue 'dispatch;
	}
	// 82E13454: 38650008  addi r3, r5, 8
	ctx.r[3].s64 = ctx.r[5].s64 + 8;
	// 82E13458: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E1345C: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 82E13460: 4803FFE9  bl 0x82e53448
	ctx.lr = 0x82E13464;
	sub_82E53448(ctx, base);
	// 82E13464: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E13468: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E1346C: 3864FFF8  addi r3, r4, -8
	ctx.r[3].s64 = ctx.r[4].s64 + -8;
	// 82E13470: 4B9BEED9  bl 0x827d2348
	ctx.lr = 0x82E13474;
	sub_827D2348(ctx, base);
	// 82E13474: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E13478: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 82E1347C: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82E13480: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E13484: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E13488: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E1348C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E13490: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E13494: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E13498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E13498 size=8
    let mut pc: u32 = 0x82E13498;
    'dispatch: loop {
        match pc {
            0x82E13498 => {
    //   block [0x82E13498..0x82E134A0)
	// 82E13498: 38630008  addi r3, r3, 8
	ctx.r[3].s64 = ctx.r[3].s64 + 8;
	// 82E1349C: 48003E04  b 0x82e172a0
	sub_82E172A0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E134A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E134A0 size=8
    let mut pc: u32 = 0x82E134A0;
    'dispatch: loop {
        match pc {
            0x82E134A0 => {
    //   block [0x82E134A0..0x82E134A8)
	// 82E134A0: 8063016C  lwz r3, 0x16c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(364 as u32) ) } as u64;
	// 82E134A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E134A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E134A8 size=20
    let mut pc: u32 = 0x82E134A8;
    'dispatch: loop {
        match pc {
            0x82E134A8 => {
    //   block [0x82E134A8..0x82E134BC)
	// 82E134A8: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82E134AC: 40980010  bge cr6, 0x82e134bc
	if !ctx.cr[6].lt {
		sub_82E134BC(ctx, base);
		return;
	}
	// 82E134B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E134B4: B16301B0  sth r11, 0x1b0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(432 as u32), ctx.r[11].u16 ) };
	// 82E134B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E134BC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E134BC size=8
    let mut pc: u32 = 0x82E134BC;
    'dispatch: loop {
        match pc {
            0x82E134BC => {
    //   block [0x82E134BC..0x82E134C4)
	// 82E134BC: B08301B0  sth r4, 0x1b0(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(432 as u32), ctx.r[4].u16 ) };
	// 82E134C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E134C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E134C8 size=20
    let mut pc: u32 = 0x82E134C8;
    'dispatch: loop {
        match pc {
            0x82E134C8 => {
    //   block [0x82E134C8..0x82E134DC)
	// 82E134C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E134CC: D02301A8  stfs f1, 0x1a8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 82E134D0: D04301AC  stfs f2, 0x1ac(r3)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(428 as u32), tmp.u32 ) };
	// 82E134D4: 996301A7  stb r11, 0x1a7(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(423 as u32), ctx.r[11].u8 ) };
	// 82E134D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E134E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E134E0 size=172
    let mut pc: u32 = 0x82E134E0;
    'dispatch: loop {
        match pc {
            0x82E134E0 => {
    //   block [0x82E134E0..0x82E1358C)
	// 82E134E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E134E4: 48394C89  bl 0x831a816c
	ctx.lr = 0x82E134E8;
	sub_831A8130(ctx, base);
	// 82E134E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E134EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E134F0: 817E016C  lwz r11, 0x16c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(364 as u32) ) } as u64;
	// 82E134F4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82E134F8: 409A0080  bne cr6, 0x82e13578
	if !ctx.cr[6].eq {
	pc = 0x82E13578; continue 'dispatch;
	}
	// 82E134FC: 807E015C  lwz r3, 0x15c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(348 as u32) ) } as u64;
	// 82E13500: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E13504: 419A0074  beq cr6, 0x82e13578
	if ctx.cr[6].eq {
	pc = 0x82E13578; continue 'dispatch;
	}
	// 82E13508: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E1350C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E13510: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E13514: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E13518: 4E800421  bctrl
	ctx.lr = 0x82E1351C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E1351C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E13520: 40810058  ble 0x82e13578
	if !ctx.cr[0].gt {
	pc = 0x82E13578; continue 'dispatch;
	}
	// 82E13524: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E13528: 817E0190  lwz r11, 0x190(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(400 as u32) ) } as u64;
	// 82E1352C: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82E13530: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E13534: 409A0020  bne cr6, 0x82e13554
	if !ctx.cr[6].eq {
	pc = 0x82E13554; continue 'dispatch;
	}
	// 82E13538: 807E015C  lwz r3, 0x15c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(348 as u32) ) } as u64;
	// 82E1353C: 38BE0010  addi r5, r30, 0x10
	ctx.r[5].s64 = ctx.r[30].s64 + 16;
	// 82E13540: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E13544: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13548: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E1354C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E13550: 4E800421  bctrl
	ctx.lr = 0x82E13554;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E13554: 807E015C  lwz r3, 0x15c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(348 as u32) ) } as u64;
	// 82E13558: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82E1355C: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82E13560: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13564: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E13568: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E1356C: 4E800421  bctrl
	ctx.lr = 0x82E13570;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E13570: 7F1F1800  cmpw cr6, r31, r3
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[3].s32, &mut ctx.xer);
	// 82E13574: 4198FFB4  blt cr6, 0x82e13528
	if ctx.cr[6].lt {
	pc = 0x82E13528; continue 'dispatch;
	}
	// 82E13578: 897E01A6  lbz r11, 0x1a6(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(422 as u32) ) } as u64;
	// 82E1357C: 616B000C  ori r11, r11, 0xc
	ctx.r[11].u64 = ctx.r[11].u64 | 12;
	// 82E13580: 997E01A6  stb r11, 0x1a6(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(422 as u32), ctx.r[11].u8 ) };
	// 82E13584: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E13588: 48394C34  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E13590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E13590 size=28
    let mut pc: u32 = 0x82E13590;
    'dispatch: loop {
        match pc {
            0x82E13590 => {
    //   block [0x82E13590..0x82E135AC)
	// 82E13590: 39600090  li r11, 0x90
	ctx.r[11].s64 = 144;
	// 82E13594: 13E020C7  vcmpequd (lvx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E135B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E135B0 size=28
    let mut pc: u32 = 0x82E135B0;
    'dispatch: loop {
        match pc {
            0x82E135B0 => {
    //   block [0x82E135B0..0x82E135CC)
	// 82E135B0: 39600130  li r11, 0x130
	ctx.r[11].s64 = 304;
	// 82E135B4: 13E020C7  vcmpequd (lvx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E135D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E135D0 size=212
    let mut pc: u32 = 0x82E135D0;
    'dispatch: loop {
        match pc {
            0x82E135D0 => {
    //   block [0x82E135D0..0x82E136A4)
	// 82E135D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E135D4: 48394B95  bl 0x831a8168
	ctx.lr = 0x82E135D8;
	sub_831A8130(ctx, base);
	// 82E135D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E135DC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E135E0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82E135E4: 419A00B8  beq cr6, 0x82e1369c
	if ctx.cr[6].eq {
	pc = 0x82E1369C; continue 'dispatch;
	}
	// 82E135E8: 81630150  lwz r11, 0x150(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(336 as u32) ) } as u64;
	// 82E135EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E135F0: 419A00AC  beq cr6, 0x82e1369c
	if ctx.cr[6].eq {
	pc = 0x82E1369C; continue 'dispatch;
	}
	// 82E135F4: 81430154  lwz r10, 0x154(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(340 as u32) ) } as u64;
	// 82E135F8: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E135FC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E13600: 4182009C  beq 0x82e1369c
	if ctx.cr[0].eq {
	pc = 0x82E1369C; continue 'dispatch;
	}
	// 82E13604: 81630150  lwz r11, 0x150(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(336 as u32) ) } as u64;
	// 82E13608: 7D7E07B4  extsw r30, r11
	ctx.r[30].s64 = ctx.r[11].s32 as i64;
	// 82E1360C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E13610: 409A000C  bne cr6, 0x82e1361c
	if !ctx.cr[6].eq {
	pc = 0x82E1361C; continue 'dispatch;
	}
	// 82E13614: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82E13618: 4800001C  b 0x82e13634
	pc = 0x82E13634; continue 'dispatch;
	// 82E1361C: 81430154  lwz r10, 0x154(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(340 as u32) ) } as u64;
	// 82E13620: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E13624: 7D7D1E70  srawi r29, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82E13628: 2B1D0004  cmplwi cr6, r29, 4
	ctx.cr[6].compare_u32(ctx.r[29].u32, 4 as u32, &mut ctx.xer);
	// 82E1362C: 41980008  blt cr6, 0x82e13634
	if ctx.cr[6].lt {
	pc = 0x82E13634; continue 'dispatch;
	}
	// 82E13630: 3BA00004  li r29, 4
	ctx.r[29].s64 = 4;
	// 82E13634: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E13638: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82E1363C: 419A0024  beq cr6, 0x82e13660
	if ctx.cr[6].eq {
	pc = 0x82E13660; continue 'dispatch;
	}
	// 82E13640: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E13644: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13648: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E1364C: 4BFFDC5D  bl 0x82e112a8
	ctx.lr = 0x82E13650;
	sub_82E112A8(ctx, base);
	// 82E13650: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82E13654: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82E13658: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82E1365C: 4198FFE4  blt cr6, 0x82e13640
	if ctx.cr[6].lt {
	pc = 0x82E13640; continue 'dispatch;
	}
	// 82E13660: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82E13664: 2B1D0004  cmplwi cr6, r29, 4
	ctx.cr[6].compare_u32(ctx.r[29].u32, 4 as u32, &mut ctx.xer);
	// 82E13668: 40980034  bge cr6, 0x82e1369c
	if !ctx.cr[6].lt {
	pc = 0x82E1369C; continue 'dispatch;
	}
	// 82E1366C: 3BDC010A  addi r30, r28, 0x10a
	ctx.r[30].s64 = ctx.r[28].s64 + 266;
	// 82E13670: 7D7EF8AE  lbzx r11, r30, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82E13674: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E13678: 40820018  bne 0x82e13690
	if !ctx.cr[0].eq {
	pc = 0x82E13690; continue 'dispatch;
	}
	// 82E1367C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82E13680: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E13684: 7D7EF9AE  stbx r11, r30, r31
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32), ctx.r[11].u8) };
	// 82E13688: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E1368C: 4BFFC15D  bl 0x82e0f7e8
	ctx.lr = 0x82E13690;
	sub_82E0F7E8(ctx, base);
	// 82E13690: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82E13694: 2B1F0004  cmplwi cr6, r31, 4
	ctx.cr[6].compare_u32(ctx.r[31].u32, 4 as u32, &mut ctx.xer);
	// 82E13698: 4198FFD8  blt cr6, 0x82e13670
	if ctx.cr[6].lt {
	pc = 0x82E13670; continue 'dispatch;
	}
	// 82E1369C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E136A0: 48394B18  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E136A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E136A8 size=36
    let mut pc: u32 = 0x82E136A8;
    'dispatch: loop {
        match pc {
            0x82E136A8 => {
    //   block [0x82E136A8..0x82E136CC)
	// 82E136A8: 81630150  lwz r11, 0x150(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(336 as u32) ) } as u64;
	// 82E136AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E136B0: 419A0010  beq cr6, 0x82e136c0
	if ctx.cr[6].eq {
	pc = 0x82E136C0; continue 'dispatch;
	}
	// 82E136B4: 81430154  lwz r10, 0x154(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(340 as u32) ) } as u64;
	// 82E136B8: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E136BC: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82E136C0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82E136C4: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82E136C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E136D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E136D0 size=196
    let mut pc: u32 = 0x82E136D0;
    'dispatch: loop {
        match pc {
            0x82E136D0 => {
    //   block [0x82E136D0..0x82E13794)
	// 82E136D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E136D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E136D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E136DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E136E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E136E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E136E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E136EC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82E136F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82E136F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E136F8: 4B4AD241  bl 0x822c0938
	ctx.lr = 0x82E136FC;
	sub_822C0938(ctx, base);
	// 82E136FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E13700: 41820028  beq 0x82e13728
	if ctx.cr[0].eq {
	pc = 0x82E13728; continue 'dispatch;
	}
	// 82E13704: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E13708: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82E1370C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82E13710: 392BB790  addi r9, r11, -0x4870
	ctx.r[9].s64 = ctx.r[11].s64 + -18544;
	// 82E13714: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E13718: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E1371C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82E13720: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82E13724: 48000008  b 0x82e1372c
	pc = 0x82E1372C; continue 'dispatch;
	// 82E13728: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E1372C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E13730: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E13734: 409A0044  bne cr6, 0x82e13778
	if !ctx.cr[6].eq {
	pc = 0x82E13778; continue 'dispatch;
	}
	// 82E13738: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E1373C: 419A001C  beq cr6, 0x82e13758
	if ctx.cr[6].eq {
	pc = 0x82E13758; continue 'dispatch;
	}
	// 82E13740: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13744: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82E13748: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E1374C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13750: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E13754: 4E800421  bctrl
	ctx.lr = 0x82E13758;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E13758: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82E1375C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82E13760: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E13764: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82E13768: 816BA500  lwz r11, -0x5b00(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23296 as u32) ) } as u64;
	// 82E1376C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82E13770: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82E13774: 4B4AC88D  bl 0x822c0000
	ctx.lr = 0x82E13778;
	sub_822C0000(ctx, base);
	// 82E13778: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E1377C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E13780: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E13784: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E13788: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E1378C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E13790: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E13798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82E13798 size=160
    let mut pc: u32 = 0x82E13798;
    'dispatch: loop {
        match pc {
            0x82E13798 => {
    //   block [0x82E13798..0x82E13838)
	// 82E13798: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E1379C: 483949D1  bl 0x831a816c
	ctx.lr = 0x82E137A0;
	sub_831A8130(ctx, base);
	// 82E137A0: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 82E137A4: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82E137A8: 38C1FFB0  addi r6, r1, -0x50
	ctx.r[6].s64 = ctx.r[1].s64 + -80;
	// 82E137AC: 3941FFA0  addi r10, r1, -0x60
	ctx.r[10].s64 = ctx.r[1].s64 + -96;
	// 82E137B0: 38A1FFC0  addi r5, r1, -0x40
	ctx.r[5].s64 = ctx.r[1].s64 + -64;
	// 82E137B4: 3881FFD0  addi r4, r1, -0x30
	ctx.r[4].s64 = ctx.r[1].s64 + -48;
	// 82E137B8: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E137BC: 13C75C07  vcmpneb. (lvlx128) v30, v7, v11
	tmp.u32 = ctx.r[7].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E137C0: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82E137C4: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E13838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E13838 size=136
    let mut pc: u32 = 0x82E13838;
    'dispatch: loop {
        match pc {
            0x82E13838 => {
    //   block [0x82E13838..0x82E138C0)
	// 82E13838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E1383C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E13840: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E13844: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E13848: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E1384C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E13850: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E13854: 4BFFFF45  bl 0x82e13798
	ctx.lr = 0x82E13858;
	sub_82E13798(ctx, base);
	// 82E13858: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82E1385C: 1380F407  vcmpneb. (lvlx128) v28, v0, v30
	tmp.u32 = ctx.r[30].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E13860: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 82E13864: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 82E13868: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 82E1386C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E13870: 13E8F407  vcmpneb. (lvlx128) v31, v8, v30
	tmp.u32 = ctx.r[8].u32 + ctx.r[30].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E13874: 13C9F407  vcmpneb. (lvlx128) v30, v9, v30
	tmp.u32 = ctx.r[9].u32 + ctx.r[30].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E13878: 13AAF407  vcmpneb. (lvlx128) v29, v10, v30
	tmp.u32 = ctx.r[10].u32 + ctx.r[30].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E138C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E138C0 size=112
    let mut pc: u32 = 0x82E138C0;
    'dispatch: loop {
        match pc {
            0x82E138C0 => {
    //   block [0x82E138C0..0x82E13930)
	// 82E138C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E138C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E138C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E138CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E138D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E138D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E138D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E138DC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E138E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E138E4: 4BFFFDED  bl 0x82e136d0
	ctx.lr = 0x82E138E8;
	sub_82E136D0(ctx, base);
	// 82E138E8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82E138EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E138F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E138F4: 4B4AC70D  bl 0x822c0000
	ctx.lr = 0x82E138F8;
	sub_822C0000(ctx, base);
	// 82E138F8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E138FC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E13900: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E13904: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E13908: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E1390C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E13910: 419A0008  beq cr6, 0x82e13918
	if ctx.cr[6].eq {
	pc = 0x82E13918; continue 'dispatch;
	}
	// 82E13914: 4B4ACF7D  bl 0x822c0890
	ctx.lr = 0x82E13918;
	sub_822C0890(ctx, base);
	// 82E13918: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E1391C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E13920: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E13924: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E13928: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E1392C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E13930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E13930 size=244
    let mut pc: u32 = 0x82E13930;
    'dispatch: loop {
        match pc {
            0x82E13930 => {
    //   block [0x82E13930..0x82E13A24)
	// 82E13930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E13934: 48394835  bl 0x831a8168
	ctx.lr = 0x82E13938;
	sub_831A8130(ctx, base);
	// 82E13938: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E1393C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E13940: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E13944: 83DD0178  lwz r30, 0x178(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(376 as u32) ) } as u64;
	// 82E13948: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E1394C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E13950: 48000058  b 0x82e139a8
	pc = 0x82E139A8; continue 'dispatch;
	// 82E13954: 83EB0014  lwz r31, 0x14(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E13958: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E1395C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E13960: 419A0024  beq cr6, 0x82e13984
	if ctx.cr[6].eq {
	pc = 0x82E13984; continue 'dispatch;
	}
	// 82E13964: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82E13968: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E1396C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E13970: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E13974: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E13978: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E1397C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E13980: 4082FFE8  bne 0x82e13968
	if !ctx.cr[0].eq {
	pc = 0x82E13968; continue 'dispatch;
	}
	// 82E13984: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E13988: 4BFFF649  bl 0x82e12fd0
	ctx.lr = 0x82E1398C;
	sub_82E12FD0(ctx, base);
	// 82E1398C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E13990: 482ABE99  bl 0x830bf828
	ctx.lr = 0x82E13994;
	sub_830BF828(ctx, base);
	// 82E13994: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E13998: 419A000C  beq cr6, 0x82e139a4
	if ctx.cr[6].eq {
	pc = 0x82E139A4; continue 'dispatch;
	}
	// 82E1399C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E139A0: 4B4ACEF1  bl 0x822c0890
	ctx.lr = 0x82E139A4;
	sub_822C0890(ctx, base);
	// 82E139A4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E139A8: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82E139AC: 409AFFA8  bne cr6, 0x82e13954
	if !ctx.cr[6].eq {
	pc = 0x82E13954; continue 'dispatch;
	}
	// 82E139B0: 83DD0184  lwz r30, 0x184(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(388 as u32) ) } as u64;
	// 82E139B4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E139B8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E139BC: 48000058  b 0x82e13a14
	pc = 0x82E13A14; continue 'dispatch;
	// 82E139C0: 83EB0014  lwz r31, 0x14(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E139C4: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E139C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E139CC: 419A0024  beq cr6, 0x82e139f0
	if ctx.cr[6].eq {
	pc = 0x82E139F0; continue 'dispatch;
	}
	// 82E139D0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82E139D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E139D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E139DC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E139E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E139E4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E139E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E139EC: 4082FFE8  bne 0x82e139d4
	if !ctx.cr[0].eq {
	pc = 0x82E139D4; continue 'dispatch;
	}
	// 82E139F0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E139F4: 4BFFF5DD  bl 0x82e12fd0
	ctx.lr = 0x82E139F8;
	sub_82E12FD0(ctx, base);
	// 82E139F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E139FC: 482ABE2D  bl 0x830bf828
	ctx.lr = 0x82E13A00;
	sub_830BF828(ctx, base);
	// 82E13A00: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E13A04: 419A000C  beq cr6, 0x82e13a10
	if ctx.cr[6].eq {
	pc = 0x82E13A10; continue 'dispatch;
	}
	// 82E13A08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E13A0C: 4B4ACE85  bl 0x822c0890
	ctx.lr = 0x82E13A10;
	sub_822C0890(ctx, base);
	// 82E13A10: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E13A14: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82E13A18: 409AFFA8  bne cr6, 0x82e139c0
	if !ctx.cr[6].eq {
	pc = 0x82E139C0; continue 'dispatch;
	}
	// 82E13A1C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E13A20: 48394798  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E13A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E13A28 size=8
    let mut pc: u32 = 0x82E13A28;
    'dispatch: loop {
        match pc {
            0x82E13A28 => {
    //   block [0x82E13A28..0x82E13A30)
	// 82E13A28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E13A2C: 4800004C  b 0x82e13a78
	sub_82E13A30(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E13A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E13A30 size=88
    let mut pc: u32 = 0x82E13A30;
    'dispatch: loop {
        match pc {
            0x82E13A30 => {
    //   block [0x82E13A30..0x82E13A88)
	// 82E13A30: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82E13A34: 419A003C  beq cr6, 0x82e13a70
	if ctx.cr[6].eq {
	pc = 0x82E13A70; continue 'dispatch;
	}
	// 82E13A38: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13A3C: 91450000  stw r10, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E13A40: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E13A44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E13A48: 91450004  stw r10, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82E13A4C: 419A0024  beq cr6, 0x82e13a70
	if ctx.cr[6].eq {
	pc = 0x82E13A70; continue 'dispatch;
	}
	// 82E13A50: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82E13A54: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82E13A58: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E13A5C: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82E13A60: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82E13A64: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E13A68: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E13A6C: 4082FFE8  bne 0x82e13a54
	if !ctx.cr[0].eq {
	pc = 0x82E13A54; continue 'dispatch;
	}
	// 82E13A70: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82E13A74: 38A50008  addi r5, r5, 8
	ctx.r[5].s64 = ctx.r[5].s64 + 8;
	// 82E13A78: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82E13A7C: 409AFFB4  bne cr6, 0x82e13a30
	if !ctx.cr[6].eq {
	pc = 0x82E13A30; continue 'dispatch;
	}
	// 82E13A80: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82E13A84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E13A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E13A88 size=212
    let mut pc: u32 = 0x82E13A88;
    'dispatch: loop {
        match pc {
            0x82E13A88 => {
    //   block [0x82E13A88..0x82E13B5C)
	// 82E13A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E13A8C: 483946E1  bl 0x831a816c
	ctx.lr = 0x82E13A90;
	sub_831A8130(ctx, base);
	// 82E13A90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E13A94: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E13A98: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E13A9C: 3BFE0164  addi r31, r30, 0x164
	ctx.r[31].s64 = ctx.r[30].s64 + 356;
	// 82E13AA0: 807E0164  lwz r3, 0x164(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(356 as u32) ) } as u64;
	// 82E13AA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E13AA8: 419A000C  beq cr6, 0x82e13ab4
	if ctx.cr[6].eq {
	pc = 0x82E13AB4; continue 'dispatch;
	}
	// 82E13AAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E13AB0: 4BFFEA91  bl 0x82e12540
	ctx.lr = 0x82E13AB4;
	sub_82E12540(ctx, base);
	// 82E13AB4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13AB8: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 82E13ABC: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82E13AC0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E13AC4: 4B4B099D  bl 0x822c4460
	ctx.lr = 0x82E13AC8;
	sub_822C4460(ctx, base);
	// 82E13AC8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E13ACC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13AD0: 4BFFE891  bl 0x82e12360
	ctx.lr = 0x82E13AD4;
	sub_82E12360(ctx, base);
	// 82E13AD4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13AD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13ADC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E13AE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E13AE4: 4E800421  bctrl
	ctx.lr = 0x82E13AE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E13AE8: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82E13AEC: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82E13AF0: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E13AF4: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82E13AF8: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 82E13AFC: 395E0050  addi r10, r30, 0x50
	ctx.r[10].s64 = ctx.r[30].s64 + 80;
	// 82E13B00: 13C71C07  vcmpneb. (lvlx128) v30, v7, v3
	tmp.u32 = ctx.r[7].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E13B04: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E13B08: 13A81C07  vcmpneb. (lvlx128) v29, v8, v3
	tmp.u32 = ctx.r[8].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E13B0C: 13891C07  vcmpneb. (lvlx128) v28, v9, v3
	tmp.u32 = ctx.r[9].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E13B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E13B60 size=200
    let mut pc: u32 = 0x82E13B60;
    'dispatch: loop {
        match pc {
            0x82E13B60 => {
    //   block [0x82E13B60..0x82E13C28)
	// 82E13B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E13B64: 48394609  bl 0x831a816c
	ctx.lr = 0x82E13B68;
	sub_831A8130(ctx, base);
	// 82E13B68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E13B6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E13B70: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E13B74: 3BDF0164  addi r30, r31, 0x164
	ctx.r[30].s64 = ctx.r[31].s64 + 356;
	// 82E13B78: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82E13B7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E13B80: 419A000C  beq cr6, 0x82e13b8c
	if ctx.cr[6].eq {
	pc = 0x82E13B8C; continue 'dispatch;
	}
	// 82E13B84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E13B88: 4BFFE9B9  bl 0x82e12540
	ctx.lr = 0x82E13B8C;
	sub_82E12540(ctx, base);
	// 82E13B8C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13B90: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 82E13B94: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82E13B98: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E13B9C: 4B4B08C5  bl 0x822c4460
	ctx.lr = 0x82E13BA0;
	sub_822C4460(ctx, base);
	// 82E13BA0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13BA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13BA8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E13BAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E13BB0: 4E800421  bctrl
	ctx.lr = 0x82E13BB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E13BB4: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82E13BB8: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82E13BBC: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E13BC0: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82E13BC4: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 82E13BC8: 395F0050  addi r10, r31, 0x50
	ctx.r[10].s64 = ctx.r[31].s64 + 80;
	// 82E13BCC: 13C71C07  vcmpneb. (lvlx128) v30, v7, v3
	tmp.u32 = ctx.r[7].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E13BD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E13BD4: 13A81C07  vcmpneb. (lvlx128) v29, v8, v3
	tmp.u32 = ctx.r[8].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E13BD8: 13891C07  vcmpneb. (lvlx128) v28, v9, v3
	tmp.u32 = ctx.r[9].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E13C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E13C28 size=96
    let mut pc: u32 = 0x82E13C28;
    'dispatch: loop {
        match pc {
            0x82E13C28 => {
    //   block [0x82E13C28..0x82E13C88)
	// 82E13C28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E13C2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E13C30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E13C34: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E13C38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E13C3C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E13C40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E13C44: 419A0020  beq cr6, 0x82e13c64
	if ctx.cr[6].eq {
	pc = 0x82E13C64; continue 'dispatch;
	}
	// 82E13C48: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E13C4C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E13C50: 4803B3A1  bl 0x82e4eff0
	ctx.lr = 0x82E13C54;
	sub_82E4EFF0(ctx, base);
	// 82E13C54: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82E13C58: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E13C5C: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 82E13C60: 4BFDE529  bl 0x82df2188
	ctx.lr = 0x82E13C64;
	sub_82DF2188(ctx, base);
	// 82E13C64: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E13C68: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E13C6C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82E13C70: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82E13C74: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E13C78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E13C7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E13C80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E13C84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E13C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E13C88 size=236
    let mut pc: u32 = 0x82E13C88;
    'dispatch: loop {
        match pc {
            0x82E13C88 => {
    //   block [0x82E13C88..0x82E13D74)
	// 82E13C88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E13C8C: 483944D5  bl 0x831a8160
	ctx.lr = 0x82E13C90;
	sub_831A8130(ctx, base);
	// 82E13C90: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E13C94: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E13C98: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82E13C9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E13CA0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82E13CA4: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82E13CA8: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E13CAC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E13CB0: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82E13CB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E13CB8: 409A0038  bne cr6, 0x82e13cf0
	if !ctx.cr[6].eq {
	pc = 0x82E13CF0; continue 'dispatch;
	}
	// 82E13CBC: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13CC0: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E13CC4: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82E13CC8: 7D295010  subfc r9, r9, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[9].u32;
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82E13CCC: 7D294910  subfe r9, r9, r9
	let x = (!ctx.r[9].u32);
	let y = ctx.r[9].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[9].u32 = res;
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82E13CD0: 553D07FF  clrlwi. r29, r9, 0x1f
	ctx.r[29].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82E13CD4: 4182000C  beq 0x82e13ce0
	if ctx.cr[0].eq {
	pc = 0x82E13CE0; continue 'dispatch;
	}
	// 82E13CD8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13CDC: 48000008  b 0x82e13ce4
	pc = 0x82E13CE4; continue 'dispatch;
	// 82E13CE0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E13CE4: 892B0019  lbz r9, 0x19(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82E13CE8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E13CEC: 419AFFD4  beq cr6, 0x82e13cc0
	if ctx.cr[6].eq {
	pc = 0x82E13CC0; continue 'dispatch;
	}
	// 82E13CF0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82E13CF4: 57AA063F  clrlwi. r10, r29, 0x18
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82E13CF8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E13CFC: 41820044  beq 0x82e13d40
	if ctx.cr[0].eq {
	pc = 0x82E13D40; continue 'dispatch;
	}
	// 82E13D00: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E13D04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E13D08: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13D0C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E13D10: 409A0028  bne cr6, 0x82e13d38
	if !ctx.cr[6].eq {
	pc = 0x82E13D38; continue 'dispatch;
	}
	// 82E13D14: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E13D18: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E13D1C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82E13D20: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82E13D24: 4BFEBF75  bl 0x82dffc98
	ctx.lr = 0x82E13D28;
	sub_82DFFC98(ctx, base);
	// 82E13D28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E13D2C: 9B5F0004  stb r26, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u8 ) };
	// 82E13D30: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13D34: 48000030  b 0x82e13d64
	pc = 0x82E13D64; continue 'dispatch;
	// 82E13D38: 48007511  bl 0x82e1b248
	ctx.lr = 0x82E13D3C;
	sub_82E1B248(ctx, base);
	// 82E13D3C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E13D40: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E13D44: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13D48: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E13D4C: 40980010  bge cr6, 0x82e13d5c
	if !ctx.cr[6].lt {
	pc = 0x82E13D5C; continue 'dispatch;
	}
	// 82E13D50: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E13D54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E13D58: 4BFFFFC0  b 0x82e13d18
	pc = 0x82E13D18; continue 'dispatch;
	// 82E13D5C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82E13D60: 995F0004  stb r10, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 82E13D64: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E13D68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E13D6C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E13D70: 48394440  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E13D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E13D78 size=356
    let mut pc: u32 = 0x82E13D78;
    'dispatch: loop {
        match pc {
            0x82E13D78 => {
    //   block [0x82E13D78..0x82E13EDC)
	// 82E13D78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E13D7C: 483943E1  bl 0x831a815c
	ctx.lr = 0x82E13D80;
	sub_831A8130(ctx, base);
	// 82E13D80: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E13D84: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E13D88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E13D8C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82E13D90: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82E13D94: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E13D98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E13D9C: 409A0020  bne cr6, 0x82e13dbc
	if !ctx.cr[6].eq {
	pc = 0x82E13DBC; continue 'dispatch;
	}
	// 82E13DA0: 80DC0004  lwz r6, 4(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E13DA4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E13DA8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82E13DAC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E13DB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E13DB4: 4BFEBEE5  bl 0x82dffc98
	ctx.lr = 0x82E13DB8;
	sub_82DFFC98(ctx, base);
	// 82E13DB8: 48000118  b 0x82e13ed0
	pc = 0x82E13ED0; continue 'dispatch;
	// 82E13DBC: 833C0004  lwz r25, 4(r28)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E13DC0: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13DC4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E13DC8: 409A001C  bne cr6, 0x82e13de4
	if !ctx.cr[6].eq {
	pc = 0x82E13DE4; continue 'dispatch;
	}
	// 82E13DCC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13DD0: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E13DD4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E13DD8: 409800DC  bge cr6, 0x82e13eb4
	if !ctx.cr[6].lt {
	pc = 0x82E13EB4; continue 'dispatch;
	}
	// 82E13DDC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82E13DE0: 4BFFFFC4  b 0x82e13da4
	pc = 0x82E13DA4; continue 'dispatch;
	// 82E13DE4: 7F1EC840  cmplw cr6, r30, r25
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82E13DE8: 409A0020  bne cr6, 0x82e13e08
	if !ctx.cr[6].eq {
	pc = 0x82E13E08; continue 'dispatch;
	}
	// 82E13DEC: 80D90008  lwz r6, 8(r25)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E13DF0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13DF4: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E13DF8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E13DFC: 409800B8  bge cr6, 0x82e13eb4
	if !ctx.cr[6].lt {
	pc = 0x82E13EB4; continue 'dispatch;
	}
	// 82E13E00: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E13E04: 4BFFFFA4  b 0x82e13da8
	pc = 0x82E13DA8; continue 'dispatch;
	// 82E13E08: 837D0000  lwz r27, 0(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13E0C: 835E000C  lwz r26, 0xc(r30)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E13E10: 7F1AD840  cmplw cr6, r26, r27
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82E13E14: 40990054  ble cr6, 0x82e13e68
	if !ctx.cr[6].gt {
	pc = 0x82E13E68; continue 'dispatch;
	}
	// 82E13E18: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E13E1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E13E20: 48007429  bl 0x82e1b248
	ctx.lr = 0x82E13E24;
	sub_82E1B248(ctx, base);
	// 82E13E24: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E13E28: 8166000C  lwz r11, 0xc(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E13E2C: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82E13E30: 40980034  bge cr6, 0x82e13e64
	if !ctx.cr[6].lt {
	pc = 0x82E13E64; continue 'dispatch;
	}
	// 82E13E34: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E13E38: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82E13E3C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E13E40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E13E44: 896B0019  lbz r11, 0x19(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82E13E48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E13E4C: 419A000C  beq cr6, 0x82e13e58
	if ctx.cr[6].eq {
	pc = 0x82E13E58; continue 'dispatch;
	}
	// 82E13E50: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E13E54: 4BFFFF60  b 0x82e13db4
	pc = 0x82E13DB4; continue 'dispatch;
	// 82E13E58: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82E13E5C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E13E60: 4BFFFF54  b 0x82e13db4
	pc = 0x82E13DB4; continue 'dispatch;
	// 82E13E64: 7F1AD840  cmplw cr6, r26, r27
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82E13E68: 4098004C  bge cr6, 0x82e13eb4
	if !ctx.cr[6].lt {
	pc = 0x82E13EB4; continue 'dispatch;
	}
	// 82E13E6C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82E13E70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E13E74: 482AB9B5  bl 0x830bf828
	ctx.lr = 0x82E13E78;
	sub_830BF828(ctx, base);
	// 82E13E78: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E13E7C: 7F06C840  cmplw cr6, r6, r25
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82E13E80: 419A0010  beq cr6, 0x82e13e90
	if ctx.cr[6].eq {
	pc = 0x82E13E90; continue 'dispatch;
	}
	// 82E13E84: 8166000C  lwz r11, 0xc(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E13E88: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E13E8C: 40980028  bge cr6, 0x82e13eb4
	if !ctx.cr[6].lt {
	pc = 0x82E13EB4; continue 'dispatch;
	}
	// 82E13E90: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E13E94: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82E13E98: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E13E9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E13EA0: 896B0019  lbz r11, 0x19(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82E13EA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E13EA8: 419AFFB4  beq cr6, 0x82e13e5c
	if ctx.cr[6].eq {
	pc = 0x82E13E5C; continue 'dispatch;
	}
	// 82E13EAC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82E13EB0: 4BFFFFA0  b 0x82e13e50
	pc = 0x82E13E50; continue 'dispatch;
	// 82E13EB4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82E13EB8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E13EBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E13EC0: 4BFFFDC9  bl 0x82e13c88
	ctx.lr = 0x82E13EC4;
	sub_82E13C88(ctx, base);
	// 82E13EC4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E13EC8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13ECC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E13ED0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E13ED4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E13ED8: 483942D4  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E13EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E13EE0 size=424
    let mut pc: u32 = 0x82E13EE0;
    'dispatch: loop {
        match pc {
            0x82E13EE0 => {
    //   block [0x82E13EE0..0x82E14088)
	// 82E13EE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E13EE4: 4839427D  bl 0x831a8160
	ctx.lr = 0x82E13EE8;
	sub_831A8130(ctx, base);
	// 82E13EE8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E13EEC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E13EF0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E13EF4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82E13EF8: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82E13EFC: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E13F00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E13F04: 409A0020  bne cr6, 0x82e13f24
	if !ctx.cr[6].eq {
	pc = 0x82E13F24; continue 'dispatch;
	}
	// 82E13F08: 80DD0004  lwz r6, 4(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E13F0C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E13F10: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82E13F14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E13F18: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E13F1C: 4BFEBB55  bl 0x82dffa70
	ctx.lr = 0x82E13F20;
	sub_82DFFA70(ctx, base);
	// 82E13F20: 4800015C  b 0x82e1407c
	pc = 0x82E1407C; continue 'dispatch;
	// 82E13F24: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E13F28: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E13F2C: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E13F30: 409A0020  bne cr6, 0x82e13f50
	if !ctx.cr[6].eq {
	pc = 0x82E13F50; continue 'dispatch;
	}
	// 82E13F34: 389C000C  addi r4, r28, 0xc
	ctx.r[4].s64 = ctx.r[28].s64 + 12;
	// 82E13F38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E13F3C: 4BFDF2FD  bl 0x82df3238
	ctx.lr = 0x82E13F40;
	sub_82DF3238(ctx, base);
	// 82E13F40: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E13F44: 4182011C  beq 0x82e14060
	if ctx.cr[0].eq {
	pc = 0x82E14060; continue 'dispatch;
	}
	// 82E13F48: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82E13F4C: 4BFFFFC0  b 0x82e13f0c
	pc = 0x82E13F0C; continue 'dispatch;
	// 82E13F50: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E13F54: 409A002C  bne cr6, 0x82e13f80
	if !ctx.cr[6].eq {
	pc = 0x82E13F80; continue 'dispatch;
	}
	// 82E13F58: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E13F5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E13F60: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82E13F64: 4BFDF2D5  bl 0x82df3238
	ctx.lr = 0x82E13F68;
	sub_82DF3238(ctx, base);
	// 82E13F68: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E13F6C: 418200F4  beq 0x82e14060
	if ctx.cr[0].eq {
	pc = 0x82E14060; continue 'dispatch;
	}
	// 82E13F70: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E13F74: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E13F78: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E13F7C: 4BFFFF94  b 0x82e13f10
	pc = 0x82E13F10; continue 'dispatch;
	// 82E13F80: 3B5C000C  addi r26, r28, 0xc
	ctx.r[26].s64 = ctx.r[28].s64 + 12;
	// 82E13F84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E13F88: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E13F8C: 4BFDF2AD  bl 0x82df3238
	ctx.lr = 0x82E13F90;
	sub_82DF3238(ctx, base);
	// 82E13F90: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E13F94: 4182005C  beq 0x82e13ff0
	if ctx.cr[0].eq {
	pc = 0x82E13FF0; continue 'dispatch;
	}
	// 82E13F98: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82E13F9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E13FA0: 480072A9  bl 0x82e1b248
	ctx.lr = 0x82E13FA4;
	sub_82E1B248(ctx, base);
	// 82E13FA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E13FA8: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E13FAC: 387B000C  addi r3, r27, 0xc
	ctx.r[3].s64 = ctx.r[27].s64 + 12;
	// 82E13FB0: 4BFDF289  bl 0x82df3238
	ctx.lr = 0x82E13FB4;
	sub_82DF3238(ctx, base);
	// 82E13FB4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E13FB8: 41820038  beq 0x82e13ff0
	if ctx.cr[0].eq {
	pc = 0x82E13FF0; continue 'dispatch;
	}
	// 82E13FBC: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E13FC0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82E13FC4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E13FC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E13FCC: 896B0019  lbz r11, 0x19(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82E13FD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E13FD4: 419A0010  beq cr6, 0x82e13fe4
	if ctx.cr[6].eq {
	pc = 0x82E13FE4; continue 'dispatch;
	}
	// 82E13FD8: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82E13FDC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82E13FE0: 4BFFFF3C  b 0x82e13f1c
	pc = 0x82E13F1C; continue 'dispatch;
	// 82E13FE4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82E13FE8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82E13FEC: 4BFFFF30  b 0x82e13f1c
	pc = 0x82E13F1C; continue 'dispatch;
	// 82E13FF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E13FF4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82E13FF8: 4BFDF241  bl 0x82df3238
	ctx.lr = 0x82E13FFC;
	sub_82DF3238(ctx, base);
	// 82E13FFC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E14000: 41820060  beq 0x82e14060
	if ctx.cr[0].eq {
	pc = 0x82E14060; continue 'dispatch;
	}
	// 82E14004: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82E14008: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E1400C: 482AB81D  bl 0x830bf828
	ctx.lr = 0x82E14010;
	sub_830BF828(ctx, base);
	// 82E14010: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E14014: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E14018: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E1401C: 419A0018  beq cr6, 0x82e14034
	if ctx.cr[6].eq {
	pc = 0x82E14034; continue 'dispatch;
	}
	// 82E14020: 389B000C  addi r4, r27, 0xc
	ctx.r[4].s64 = ctx.r[27].s64 + 12;
	// 82E14024: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E14028: 4BFDF211  bl 0x82df3238
	ctx.lr = 0x82E1402C;
	sub_82DF3238(ctx, base);
	// 82E1402C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E14030: 41820030  beq 0x82e14060
	if ctx.cr[0].eq {
	pc = 0x82E14060; continue 'dispatch;
	}
	// 82E14034: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E14038: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82E1403C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E14040: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E14044: 896B0019  lbz r11, 0x19(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82E14048: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E1404C: 419A000C  beq cr6, 0x82e14058
	if ctx.cr[6].eq {
	pc = 0x82E14058; continue 'dispatch;
	}
	// 82E14050: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82E14054: 4BFFFF88  b 0x82e13fdc
	pc = 0x82E13FDC; continue 'dispatch;
	// 82E14058: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82E1405C: 4BFFFF8C  b 0x82e13fe8
	pc = 0x82E13FE8; continue 'dispatch;
	// 82E14060: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E14064: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E14068: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E1406C: 4BFEC175  bl 0x82e001e0
	ctx.lr = 0x82E14070;
	sub_82E001E0(ctx, base);
	// 82E14070: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E14074: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E14078: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E1407C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E14080: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E14084: 4839412C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E14088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E14088 size=76
    let mut pc: u32 = 0x82E14088;
    'dispatch: loop {
        match pc {
            0x82E14088 => {
    //   block [0x82E14088..0x82E140D4)
	// 82E14088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E1408C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E14090: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E14094: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E14098: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E1409C: 4BFEA6FD  bl 0x82dfe798
	ctx.lr = 0x82E140A0;
	sub_82DFE798(ctx, base);
	// 82E140A0: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E140A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E140A8: 394ABC68  addi r10, r10, -0x4398
	ctx.r[10].s64 = ctx.r[10].s64 + -17304;
	// 82E140AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E140B0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E140B4: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82E140B8: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82E140BC: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82E140C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E140C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E140C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E140CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E140D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E140D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E140D8 size=200
    let mut pc: u32 = 0x82E140D8;
    'dispatch: loop {
        match pc {
            0x82E140D8 => {
    //   block [0x82E140D8..0x82E141A0)
	// 82E140D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E140DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E140E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E140E4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E140E8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E140EC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E140F0: 892B0019  lbz r9, 0x19(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82E140F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E140F8: 409A0030  bne cr6, 0x82e14128
	if !ctx.cr[6].eq {
	pc = 0x82E14128; continue 'dispatch;
	}
	// 82E140FC: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E14100: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E14104: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82E14108: 4098000C  bge cr6, 0x82e14114
	if !ctx.cr[6].lt {
	pc = 0x82E14114; continue 'dispatch;
	}
	// 82E1410C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E14110: 4800000C  b 0x82e1411c
	pc = 0x82E1411C; continue 'dispatch;
	// 82E14114: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82E14118: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E1411C: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82E14120: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82E14124: 419AFFDC  beq cr6, 0x82e14100
	if ctx.cr[6].eq {
	pc = 0x82E14100; continue 'dispatch;
	}
	// 82E14128: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E1412C: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 82E14130: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E14134: 419A0014  beq cr6, 0x82e14148
	if ctx.cr[6].eq {
	pc = 0x82E14148; continue 'dispatch;
	}
	// 82E14138: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E1413C: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E14140: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E14144: 40980044  bge cr6, 0x82e14188
	if !ctx.cr[6].lt {
	pc = 0x82E14188; continue 'dispatch;
	}
	// 82E14148: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E1414C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E14150: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E14154: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E14158: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82E1415C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82E14160: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E14164: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E14168: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82E1416C: 4BFFFC0D  bl 0x82e13d78
	ctx.lr = 0x82E14170;
	sub_82E13D78(ctx, base);
	// 82E14170: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82E14174: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E14178: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E1417C: 419A000C  beq cr6, 0x82e14188
	if ctx.cr[6].eq {
	pc = 0x82E14188; continue 'dispatch;
	}
	// 82E14180: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E14184: 4B4AC70D  bl 0x822c0890
	ctx.lr = 0x82E14188;
	sub_822C0890(ctx, base);
	// 82E14188: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82E1418C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82E14190: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E14194: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E14198: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E1419C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E141A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E141A0 size=152
    let mut pc: u32 = 0x82E141A0;
    'dispatch: loop {
        match pc {
            0x82E141A0 => {
    //   block [0x82E141A0..0x82E14238)
	// 82E141A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E141A4: 48393FC9  bl 0x831a816c
	ctx.lr = 0x82E141A8;
	sub_831A8130(ctx, base);
	// 82E141A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E141AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E141B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E141B4: 480307FD  bl 0x82e449b0
	ctx.lr = 0x82E141B8;
	sub_82E449B0(ctx, base);
	// 82E141B8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E141BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E141C0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E141C4: 419A0018  beq cr6, 0x82e141dc
	if ctx.cr[6].eq {
	pc = 0x82E141DC; continue 'dispatch;
	}
	// 82E141C8: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82E141CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E141D0: 4BFDF069  bl 0x82df3238
	ctx.lr = 0x82E141D4;
	sub_82DF3238(ctx, base);
	// 82E141D4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E141D8: 41820054  beq 0x82e1422c
	if ctx.cr[0].eq {
	pc = 0x82E1422C; continue 'dispatch;
	}
	// 82E141DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E141E0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82E141E4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82E141E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E141EC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82E141F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E141F4: 4803128D  bl 0x82e45480
	ctx.lr = 0x82E141F8;
	sub_82E45480(ctx, base);
	// 82E141F8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82E141FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E14200: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82E14204: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E14208: 4BFFFCD9  bl 0x82e13ee0
	ctx.lr = 0x82E1420C;
	sub_82E13EE0(ctx, base);
	// 82E1420C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82E14210: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E14214: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E14218: 419A000C  beq cr6, 0x82e14224
	if ctx.cr[6].eq {
	pc = 0x82E14224; continue 'dispatch;
	}
	// 82E1421C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82E14220: 4B4AC671  bl 0x822c0890
	ctx.lr = 0x82E14224;
	sub_822C0890(ctx, base);
	// 82E14224: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82E14228: 4BFDF201  bl 0x82df3428
	ctx.lr = 0x82E1422C;
	sub_82DF3428(ctx, base);
	// 82E1422C: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82E14230: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E14234: 48393F88  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E14238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E14238 size=344
    let mut pc: u32 = 0x82E14238;
    'dispatch: loop {
        match pc {
            0x82E14238 => {
    //   block [0x82E14238..0x82E14390)
	// 82E14238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E1423C: 48393F29  bl 0x831a8164
	ctx.lr = 0x82E14240;
	sub_831A8130(ctx, base);
	// 82E14240: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E14244: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82E14248: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E1424C: 936100BC  stw r27, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[27].u32 ) };
	// 82E14250: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82E14254: 3B9E0174  addi r28, r30, 0x174
	ctx.r[28].s64 = ctx.r[30].s64 + 372;
	// 82E14258: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82E1425C: 38A100BC  addi r5, r1, 0xbc
	ctx.r[5].s64 = ctx.r[1].s64 + 188;
	// 82E14260: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E14264: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E14268: 48001111  bl 0x82e15378
	ctx.lr = 0x82E1426C;
	sub_82E15378(ctx, base);
	// 82E1426C: 815E0178  lwz r10, 0x178(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(376 as u32) ) } as u64;
	// 82E14270: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E14274: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E14278: 419A0040  beq cr6, 0x82e142b8
	if ctx.cr[6].eq {
	pc = 0x82E142B8; continue 'dispatch;
	}
	// 82E1427C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E14280: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E14284: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E14288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E1428C: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E14290: 419A00F4  beq cr6, 0x82e14384
	if ctx.cr[6].eq {
	pc = 0x82E14384; continue 'dispatch;
	}
	// 82E14294: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E14298: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E1429C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E142A0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E142A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E142A8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E142AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E142B0: 4082FFE8  bne 0x82e14298
	if !ctx.cr[0].eq {
	pc = 0x82E14298; continue 'dispatch;
	}
	// 82E142B4: 480000D0  b 0x82e14384
	pc = 0x82E14384; continue 'dispatch;
	// 82E142B8: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E142BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82E142C0: 388BBC70  addi r4, r11, -0x4390
	ctx.r[4].s64 = ctx.r[11].s64 + -17296;
	// 82E142C4: 38A000C4  li r5, 0xc4
	ctx.r[5].s64 = 196;
	// 82E142C8: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 82E142CC: 4BFDE11D  bl 0x82df23e8
	ctx.lr = 0x82E142D0;
	sub_82DF23E8(ctx, base);
	// 82E142D0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E142D4: 41820018  beq 0x82e142ec
	if ctx.cr[0].eq {
	pc = 0x82E142EC; continue 'dispatch;
	}
	// 82E142D8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82E142DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E142E0: 48015B89  bl 0x82e29e68
	ctx.lr = 0x82E142E4;
	sub_82E29E68(ctx, base);
	// 82E142E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E142E8: 48000008  b 0x82e142f0
	pc = 0x82E142F0; continue 'dispatch;
	// 82E142EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E142F0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82E142F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E142F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E142FC: 4BFFF3D5  bl 0x82e136d0
	ctx.lr = 0x82E14300;
	sub_82E136D0(ctx, base);
	// 82E14300: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E14304: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E14308: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E1430C: 4B4ABCF5  bl 0x822c0000
	ctx.lr = 0x82E14310;
	sub_822C0000(ctx, base);
	// 82E14310: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E14314: 389E015C  addi r4, r30, 0x15c
	ctx.r[4].s64 = ctx.r[30].s64 + 348;
	// 82E14318: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E1431C: 48015D95  bl 0x82e2a0b0
	ctx.lr = 0x82E14320;
	sub_82E2A0B0(ctx, base);
	// 82E14320: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E14324: 807E0164  lwz r3, 0x164(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(356 as u32) ) } as u64;
	// 82E14328: 4BFFEB09  bl 0x82e12e30
	ctx.lr = 0x82E1432C;
	sub_82E12E30(ctx, base);
	// 82E1432C: 388100BC  addi r4, r1, 0xbc
	ctx.r[4].s64 = ctx.r[1].s64 + 188;
	// 82E14330: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E14334: 4BFFFDA5  bl 0x82e140d8
	ctx.lr = 0x82E14338;
	sub_82E140D8(ctx, base);
	// 82E14338: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E1433C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82E14340: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82E14344: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82E14348: 4B4B0119  bl 0x822c4460
	ctx.lr = 0x82E1434C;
	sub_822C4460(ctx, base);
	// 82E1434C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E14350: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82E14354: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E14358: 907D0004  stw r3, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82E1435C: 419A0028  beq cr6, 0x82e14384
	if ctx.cr[6].eq {
	pc = 0x82E14384; continue 'dispatch;
	}
	// 82E14360: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 82E14364: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E14368: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E1436C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E14370: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E14374: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E14378: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E1437C: 4082FFE8  bne 0x82e14364
	if !ctx.cr[0].eq {
	pc = 0x82E14364; continue 'dispatch;
	}
	// 82E14380: 4B4AC511  bl 0x822c0890
	ctx.lr = 0x82E14384;
	sub_822C0890(ctx, base);
	// 82E14384: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82E14388: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E1438C: 48393E28  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E14390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E14390 size=408
    let mut pc: u32 = 0x82E14390;
    'dispatch: loop {
        match pc {
            0x82E14390 => {
    //   block [0x82E14390..0x82E14528)
	// 82E14390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E14394: 48393DCD  bl 0x831a8160
	ctx.lr = 0x82E14398;
	sub_831A8130(ctx, base);
	// 82E14398: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E1439C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E143A0: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82E143A4: 3B7D0180  addi r27, r29, 0x180
	ctx.r[27].s64 = ctx.r[29].s64 + 384;
	// 82E143A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82E143AC: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82E143B0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82E143B4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E143B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E143BC: 4BFEAC3D  bl 0x82dfeff8
	ctx.lr = 0x82E143C0;
	sub_82DFEFF8(ctx, base);
	// 82E143C0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E143C4: 815D0184  lwz r10, 0x184(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(388 as u32) ) } as u64;
	// 82E143C8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82E143CC: 419A0040  beq cr6, 0x82e1440c
	if ctx.cr[6].eq {
	pc = 0x82E1440C; continue 'dispatch;
	}
	// 82E143D0: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E143D4: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82E143D8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E143DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E143E0: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E143E4: 419A0138  beq cr6, 0x82e1451c
	if ctx.cr[6].eq {
	pc = 0x82E1451C; continue 'dispatch;
	}
	// 82E143E8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82E143EC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E143F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E143F4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E143F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E143FC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E14400: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E14404: 4082FFE8  bne 0x82e143ec
	if !ctx.cr[0].eq {
	pc = 0x82E143EC; continue 'dispatch;
	}
	// 82E14408: 48000114  b 0x82e1451c
	pc = 0x82E1451C; continue 'dispatch;
	// 82E1440C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E14410: 4BFEA3D1  bl 0x82dfe7e0
	ctx.lr = 0x82E14414;
	sub_82DFE7E0(ctx, base);
	// 82E14414: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E14418: 41820038  beq 0x82e14450
	if ctx.cr[0].eq {
	pc = 0x82E14450; continue 'dispatch;
	}
	// 82E1441C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E14420: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E14424: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E14428: 4BFDF7D9  bl 0x82df3c00
	ctx.lr = 0x82E1442C;
	sub_82DF3C00(ctx, base);
	// 82E1442C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E14430: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82E14434: 48011F7D  bl 0x82e263b0
	ctx.lr = 0x82E14438;
	sub_82E263B0(ctx, base);
	// 82E14438: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82E1443C: 40800014  bge 0x82e14450
	if !ctx.cr[0].lt {
	pc = 0x82E14450; continue 'dispatch;
	}
	// 82E14440: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82E14444: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E14448: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82E1444C: 480000D0  b 0x82e1451c
	pc = 0x82E1451C; continue 'dispatch;
	// 82E14450: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E14454: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82E14458: 388BBC70  addi r4, r11, -0x4390
	ctx.r[4].s64 = ctx.r[11].s64 + -17296;
	// 82E1445C: 38A000E6  li r5, 0xe6
	ctx.r[5].s64 = 230;
	// 82E14460: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 82E14464: 4BFDDF85  bl 0x82df23e8
	ctx.lr = 0x82E14468;
	sub_82DF23E8(ctx, base);
	// 82E14468: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E1446C: 41820018  beq 0x82e14484
	if ctx.cr[0].eq {
	pc = 0x82E14484; continue 'dispatch;
	}
	// 82E14470: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82E14474: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E14478: 48015B49  bl 0x82e29fc0
	ctx.lr = 0x82E1447C;
	sub_82E29FC0(ctx, base);
	// 82E1447C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E14480: 48000008  b 0x82e14488
	pc = 0x82E14488; continue 'dispatch;
	// 82E14484: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82E14488: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82E1448C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E14490: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E14494: 4BFFF23D  bl 0x82e136d0
	ctx.lr = 0x82E14498;
	sub_82E136D0(ctx, base);
	// 82E14498: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82E1449C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E144A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E144A4: 4B4ABB5D  bl 0x822c0000
	ctx.lr = 0x82E144A8;
	sub_822C0000(ctx, base);
	// 82E144A8: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E144AC: 389D015C  addi r4, r29, 0x15c
	ctx.r[4].s64 = ctx.r[29].s64 + 348;
	// 82E144B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E144B4: 48015BFD  bl 0x82e2a0b0
	ctx.lr = 0x82E144B8;
	sub_82E2A0B0(ctx, base);
	// 82E144B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E144BC: 807D0164  lwz r3, 0x164(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(356 as u32) ) } as u64;
	// 82E144C0: 4BFFE971  bl 0x82e12e30
	ctx.lr = 0x82E144C4;
	sub_82E12E30(ctx, base);
	// 82E144C4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E144C8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82E144CC: 4BFFFCD5  bl 0x82e141a0
	ctx.lr = 0x82E144D0;
	sub_82E141A0(ctx, base);
	// 82E144D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82E144D4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82E144D8: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82E144DC: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82E144E0: 4B4AFF81  bl 0x822c4460
	ctx.lr = 0x82E144E4;
	sub_822C4460(ctx, base);
	// 82E144E4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E144E8: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82E144EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E144F0: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82E144F4: 419A0028  beq cr6, 0x82e1451c
	if ctx.cr[6].eq {
	pc = 0x82E1451C; continue 'dispatch;
	}
	// 82E144F8: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 82E144FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E14500: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E14504: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E14508: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E1450C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E14510: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E14514: 4082FFE8  bne 0x82e144fc
	if !ctx.cr[0].eq {
	pc = 0x82E144FC; continue 'dispatch;
	}
	// 82E14518: 4B4AC379  bl 0x822c0890
	ctx.lr = 0x82E1451C;
	sub_822C0890(ctx, base);
	// 82E1451C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E14520: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82E14524: 48393C8C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E14528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E14528 size=304
    let mut pc: u32 = 0x82E14528;
    'dispatch: loop {
        match pc {
            0x82E14528 => {
    //   block [0x82E14528..0x82E14658)
	// 82E14528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E1452C: 48393C15  bl 0x831a8140
	ctx.lr = 0x82E14530;
	sub_831A8130(ctx, base);
	// 82E14530: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E14534: 7CB32B78  mr r19, r5
	ctx.r[19].u64 = ctx.r[5].u64;
	// 82E14538: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 82E1453C: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 82E14540: 81730000  lwz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E14544: 81560170  lwz r10, 0x170(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(368 as u32) ) } as u64;
	// 82E14548: 836B0050  lwz r27, 0x50(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E1454C: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82E14550: 419800C8  blt cr6, 0x82e14618
	if ctx.cr[6].lt {
	pc = 0x82E14618; continue 'dispatch;
	}
	// 82E14554: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E14558: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82E1455C: 82AB0054  lwz r21, 0x54(r11)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E14560: 7F17C378  mr r23, r24
	ctx.r[23].u64 = ctx.r[24].u64;
	// 82E14564: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82E14568: 419A00E4  beq cr6, 0x82e1464c
	if ctx.cr[6].eq {
	pc = 0x82E1464C; continue 'dispatch;
	}
	// 82E1456C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82E14570: 419A00DC  beq cr6, 0x82e1464c
	if ctx.cr[6].eq {
	pc = 0x82E1464C; continue 'dispatch;
	}
	// 82E14574: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82E14578: 7F19C378  mr r25, r24
	ctx.r[25].u64 = ctx.r[24].u64;
	// 82E1457C: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 82E14580: 3B8A0004  addi r28, r10, 4
	ctx.r[28].s64 = ctx.r[10].s64 + 4;
	// 82E14584: 3B4BA504  addi r26, r11, -0x5afc
	ctx.r[26].s64 = ctx.r[11].s64 + -23292;
	// 82E14588: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 82E1458C: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 82E14590: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E14594: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E14598: 4BFDF471  bl 0x82df3a08
	ctx.lr = 0x82E1459C;
	sub_82DF3A08(ctx, base);
	// 82E1459C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E145A0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82E145A4: 4BFDED65  bl 0x82df3308
	ctx.lr = 0x82E145A8;
	sub_82DF3308(ctx, base);
	// 82E145A8: 7C721B78  mr r18, r3
	ctx.r[18].u64 = ctx.r[3].u64;
	// 82E145AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E145B0: 4BFDEE79  bl 0x82df3428
	ctx.lr = 0x82E145B4;
	sub_82DF3428(ctx, base);
	// 82E145B4: 564B063F  clrlwi. r11, r18, 0x18
	ctx.r[11].u64 = ctx.r[18].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E145B8: 40820018  bne 0x82e145d0
	if !ctx.cr[0].eq {
	pc = 0x82E145D0; continue 'dispatch;
	}
	// 82E145BC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82E145C0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82E145C4: 2B1E0010  cmplwi cr6, r30, 0x10
	ctx.cr[6].compare_u32(ctx.r[30].u32, 16 as u32, &mut ctx.xer);
	// 82E145C8: 4198FFC8  blt cr6, 0x82e14590
	if ctx.cr[6].lt {
	pc = 0x82E14590; continue 'dispatch;
	}
	// 82E145CC: 4800000C  b 0x82e145d8
	pc = 0x82E145D8; continue 'dispatch;
	// 82E145D0: 7FB7EB78  mr r23, r29
	ctx.r[23].u64 = ctx.r[29].u64;
	// 82E145D4: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 82E145D8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82E145DC: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 82E145E0: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82E145E4: 4198FFA4  blt cr6, 0x82e14588
	if ctx.cr[6].lt {
	pc = 0x82E14588; continue 'dispatch;
	}
	// 82E145E8: 572B063F  clrlwi. r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E145EC: 4182004C  beq 0x82e14638
	if ctx.cr[0].eq {
	pc = 0x82E14638; continue 'dispatch;
	}
	// 82E145F0: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 82E145F4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82E145F8: 419A0020  beq cr6, 0x82e14618
	if ctx.cr[6].eq {
	pc = 0x82E14618; continue 'dispatch;
	}
	// 82E145FC: 7D4BA8AE  lbzx r10, r11, r21
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[21].u32)) } as u64;
	// 82E14600: 7F0AB840  cmplw cr6, r10, r23
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[23].u32, &mut ctx.xer);
	// 82E14604: 409A0008  bne cr6, 0x82e1460c
	if !ctx.cr[6].eq {
	pc = 0x82E1460C; continue 'dispatch;
	}
	// 82E14608: 91760170  stw r11, 0x170(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(368 as u32), ctx.r[11].u32 ) };
	// 82E1460C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82E14610: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82E14614: 4198FFE8  blt cr6, 0x82e145fc
	if ctx.cr[6].lt {
	pc = 0x82E145FC; continue 'dispatch;
	}
	// 82E14618: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 82E1461C: 80D60170  lwz r6, 0x170(r22)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(368 as u32) ) } as u64;
	// 82E14620: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82E14624: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82E14628: 4BFFFC11  bl 0x82e14238
	ctx.lr = 0x82E1462C;
	sub_82E14238(ctx, base);
	// 82E1462C: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82E14630: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82E14634: 48393B5C  b 0x831a8190
	sub_831A8180(ctx, base);
	return;
	// 82E14638: 217B0001  subfic r11, r27, 1
	ctx.xer.ca = ctx.r[27].u32 <= 1 as u32;
	ctx.r[11].s64 = (1 as i64) - ctx.r[27].s64;
	// 82E1463C: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82E14640: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82E14644: 91760170  stw r11, 0x170(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(368 as u32), ctx.r[11].u32 ) };
	// 82E14648: 4BFFFFD0  b 0x82e14618
	pc = 0x82E14618; continue 'dispatch;
	// 82E1464C: 93140000  stw r24, 0(r20)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 82E14650: 93140004  stw r24, 4(r20)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[20].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 82E14654: 4BFFFFD8  b 0x82e1462c
	pc = 0x82E1462C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E14658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E14658 size=196
    let mut pc: u32 = 0x82E14658;
    'dispatch: loop {
        match pc {
            0x82E14658 => {
    //   block [0x82E14658..0x82E1471C)
	// 82E14658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E1465C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E14660: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E14664: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E14668: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E1466C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E14670: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E14674: 396BBCD4  addi r11, r11, -0x432c
	ctx.r[11].s64 = ctx.r[11].s64 + -17196;
	// 82E14678: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82E1467C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E14680: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E14684: 419A000C  beq cr6, 0x82e14690
	if ctx.cr[6].eq {
	pc = 0x82E14690; continue 'dispatch;
	}
	// 82E14688: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82E1468C: 4BFFDEB5  bl 0x82e12540
	ctx.lr = 0x82E14690;
	sub_82E12540(ctx, base);
	// 82E14690: 807F01A0  lwz r3, 0x1a0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 82E14694: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E14698: 419A0008  beq cr6, 0x82e146a0
	if ctx.cr[6].eq {
	pc = 0x82E146A0; continue 'dispatch;
	}
	// 82E1469C: 4B4AC1F5  bl 0x822c0890
	ctx.lr = 0x82E146A0;
	sub_822C0890(ctx, base);
	// 82E146A0: 387F018C  addi r3, r31, 0x18c
	ctx.r[3].s64 = ctx.r[31].s64 + 396;
	// 82E146A4: 4BFFF585  bl 0x82e13c28
	ctx.lr = 0x82E146A8;
	sub_82E13C28(ctx, base);
	// 82E146A8: 387F0180  addi r3, r31, 0x180
	ctx.r[3].s64 = ctx.r[31].s64 + 384;
	// 82E146AC: 4BFEF88D  bl 0x82e03f38
	ctx.lr = 0x82E146B0;
	sub_82E03F38(ctx, base);
	// 82E146B0: 387F0174  addi r3, r31, 0x174
	ctx.r[3].s64 = ctx.r[31].s64 + 372;
	// 82E146B4: 482AF38D  bl 0x830c3a40
	ctx.lr = 0x82E146B8;
	sub_830C3A40(ctx, base);
	// 82E146B8: 807F0168  lwz r3, 0x168(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82E146BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E146C0: 419A0008  beq cr6, 0x82e146c8
	if ctx.cr[6].eq {
	pc = 0x82E146C8; continue 'dispatch;
	}
	// 82E146C4: 4B4AC1CD  bl 0x822c0890
	ctx.lr = 0x82E146C8;
	sub_822C0890(ctx, base);
	// 82E146C8: 807F0160  lwz r3, 0x160(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82E146CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E146D0: 419A0008  beq cr6, 0x82e146d8
	if ctx.cr[6].eq {
	pc = 0x82E146D8; continue 'dispatch;
	}
	// 82E146D4: 4B4AC1BD  bl 0x822c0890
	ctx.lr = 0x82E146D8;
	sub_822C0890(ctx, base);
	// 82E146D8: 3BDF0140  addi r30, r31, 0x140
	ctx.r[30].s64 = ctx.r[31].s64 + 320;
	// 82E146DC: 387E000C  addi r3, r30, 0xc
	ctx.r[3].s64 = ctx.r[30].s64 + 12;
	// 82E146E0: 4BFFF549  bl 0x82e13c28
	ctx.lr = 0x82E146E4;
	sub_82E13C28(ctx, base);
	// 82E146E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82E146E8: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 82E146EC: 396B9B84  addi r11, r11, -0x647c
	ctx.r[11].s64 = ctx.r[11].s64 + -25724;
	// 82E146F0: 917F0140  stw r11, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 82E146F4: 4BFDED35  bl 0x82df3428
	ctx.lr = 0x82E146F8;
	sub_82DF3428(ctx, base);
	// 82E146F8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82E146FC: 396BA980  addi r11, r11, -0x5680
	ctx.r[11].s64 = ctx.r[11].s64 + -22144;
	// 82E14700: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E14704: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E14708: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E1470C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E14710: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E14714: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E14718: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E14720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E14720 size=432
    let mut pc: u32 = 0x82E14720;
    'dispatch: loop {
        match pc {
            0x82E14720 => {
    //   block [0x82E14720..0x82E148D0)
	// 82E14720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E14724: 48393A35  bl 0x831a8158
	ctx.lr = 0x82E14728;
	sub_831A8130(ctx, base);
	// 82E14728: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E1472C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E14730: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82E14734: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 82E14738: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 82E1473C: 3BDF018C  addi r30, r31, 0x18c
	ctx.r[30].s64 = ctx.r[31].s64 + 396;
	// 82E14740: 817F0190  lwz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82E14744: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82E14748: 807F015C  lwz r3, 0x15c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 82E1474C: 3B7F015C  addi r27, r31, 0x15c
	ctx.r[27].s64 = ctx.r[31].s64 + 348;
	// 82E14750: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E14754: 409A000C  bne cr6, 0x82e14760
	if !ctx.cr[6].eq {
	pc = 0x82E14760; continue 'dispatch;
	}
	// 82E14758: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82E1475C: 48000010  b 0x82e1476c
	pc = 0x82E1476C; continue 'dispatch;
	// 82E14760: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E14764: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E14768: 7D7D1E70  srawi r29, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82E1476C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E14770: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E14774: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E14778: 4E800421  bctrl
	ctx.lr = 0x82E1477C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E1477C: 7F1D1840  cmplw cr6, r29, r3
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82E14780: 40980030  bge cr6, 0x82e147b0
	if !ctx.cr[6].lt {
	pc = 0x82E147B0; continue 'dispatch;
	}
	// 82E14784: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E14788: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E1478C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E14790: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E14794: 4E800421  bctrl
	ctx.lr = 0x82E14798;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E14798: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82E1479C: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82E147A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E147A4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E147A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E147AC: 480847A5  bl 0x82e98f50
	ctx.lr = 0x82E147B0;
	sub_82E98F50(ctx, base);
	// 82E147B0: 817F0190  lwz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82E147B4: 579D1838  slwi r29, r28, 3
	ctx.r[29].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 82E147B8: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82E147BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82E147C0: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82E147C4: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82E147C8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E147CC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E147D0: 4B4AFC91  bl 0x822c4460
	ctx.lr = 0x82E147D4;
	sub_822C4460(ctx, base);
	// 82E147D4: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E147D8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82E147DC: 409A006C  bne cr6, 0x82e14848
	if !ctx.cr[6].eq {
	pc = 0x82E14848; continue 'dispatch;
	}
	// 82E147E0: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82E147E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82E147E8: 388BBC70  addi r4, r11, -0x4390
	ctx.r[4].s64 = ctx.r[11].s64 + -17296;
	// 82E147EC: 38A0014F  li r5, 0x14f
	ctx.r[5].s64 = 335;
	// 82E147F0: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 82E147F4: 4BFDDBF5  bl 0x82df23e8
	ctx.lr = 0x82E147F8;
	sub_82DF23E8(ctx, base);
	// 82E147F8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82E147FC: 41820018  beq 0x82e14814
	if ctx.cr[0].eq {
	pc = 0x82E14814; continue 'dispatch;
	}
	// 82E14800: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82E14804: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E14808: 48015C01  bl 0x82e2a408
	ctx.lr = 0x82E1480C;
	sub_82E2A408(ctx, base);
	// 82E1480C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E14810: 48000008  b 0x82e14818
	pc = 0x82E14818; continue 'dispatch;
	// 82E14814: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82E14818: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E1481C: 4BFFF0A5  bl 0x82e138c0
	ctx.lr = 0x82E14820;
	sub_82E138C0(ctx, base);
	// 82E14820: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E14824: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E14828: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E1482C: 48015D05  bl 0x82e2a530
	ctx.lr = 0x82E14830;
	sub_82E2A530(ctx, base);
	// 82E14830: 817F0190  lwz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82E14834: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82E14838: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82E1483C: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82E14840: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82E14844: 4B4AFC1D  bl 0x822c4460
	ctx.lr = 0x82E14848;
	sub_822C4460(ctx, base);
	// 82E14848: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82E1484C: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82E14850: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E14854: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82E14858: 419A0024  beq cr6, 0x82e1487c
	if ctx.cr[6].eq {
	pc = 0x82E1487C; continue 'dispatch;
	}
	// 82E1485C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82E14860: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E14864: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E14868: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E1486C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E14870: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E14874: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E14878: 4082FFE8  bne 0x82e14860
	if !ctx.cr[0].eq {
	pc = 0x82E14860; continue 'dispatch;
	}
	// 82E1487C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82E14880: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E14884: 808BA514  lwz r4, -0x5aec(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23276 as u32) ) } as u64;
	// 82E14888: 4BFDF181  bl 0x82df3a08
	ctx.lr = 0x82E1488C;
	sub_82DF3A08(ctx, base);
	// 82E1488C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82E14890: 80780000  lwz r3, 0(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E14894: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82E14898: 4BFFDE89  bl 0x82e12720
	ctx.lr = 0x82E1489C;
	sub_82E12720(ctx, base);
	// 82E1489C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E148A0: 4BFDEB89  bl 0x82df3428
	ctx.lr = 0x82E148A4;
	sub_82DF3428(ctx, base);
	// 82E148A4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82E148A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E148AC: 419A0008  beq cr6, 0x82e148b4
	if ctx.cr[6].eq {
	pc = 0x82E148B4; continue 'dispatch;
	}
	// 82E148B0: 4B4ABFE1  bl 0x822c0890
	ctx.lr = 0x82E148B4;
	sub_822C0890(ctx, base);
	// 82E148B4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E148B8: 419A000C  beq cr6, 0x82e148c4
	if ctx.cr[6].eq {
	pc = 0x82E148C4; continue 'dispatch;
	}
	// 82E148BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E148C0: 4B4ABFD1  bl 0x822c0890
	ctx.lr = 0x82E148C4;
	sub_822C0890(ctx, base);
	// 82E148C4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82E148C8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82E148CC: 483938DC  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E148D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E148D0 size=608
    let mut pc: u32 = 0x82E148D0;
    'dispatch: loop {
        match pc {
            0x82E148D0 => {
    //   block [0x82E148D0..0x82E14B30)
	// 82E148D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E148D4: 48393889  bl 0x831a815c
	ctx.lr = 0x82E148D8;
	sub_831A8130(ctx, base);
	// 82E148D8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E148DC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82E148E0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82E148E4: 3B5C018C  addi r26, r28, 0x18c
	ctx.r[26].s64 = ctx.r[28].s64 + 396;
	// 82E148E8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82E148EC: 817C0190  lwz r11, 0x190(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(400 as u32) ) } as u64;
	// 82E148F0: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E148F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E148F8: 409A000C  bne cr6, 0x82e14904
	if !ctx.cr[6].eq {
	pc = 0x82E14904; continue 'dispatch;
	}
	// 82E148FC: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 82E14900: 48000010  b 0x82e14910
	pc = 0x82E14910; continue 'dispatch;
	// 82E14904: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E14908: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E1490C: 7D7F1E70  srawi r31, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82E14910: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E14914: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E14918: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E1491C: 4E800421  bctrl
	ctx.lr = 0x82E14920;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E14920: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82E14924: 40980030  bge cr6, 0x82e14954
	if !ctx.cr[6].lt {
	pc = 0x82E14954; continue 'dispatch;
	}
	// 82E14928: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E1492C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E14930: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E14934: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E14938: 4E800421  bctrl
	ctx.lr = 0x82E1493C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E1493C: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82E14940: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 82E14944: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E14948: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82E1494C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82E14950: 48084601  bl 0x82e98f50
	ctx.lr = 0x82E14954;
	sub_82E98F50(ctx, base);
	// 82E14954: 83BC0178  lwz r29, 0x178(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(376 as u32) ) } as u64;
	// 82E14958: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E1495C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E14960: 48000064  b 0x82e149c4
	pc = 0x82E149C4; continue 'dispatch;
	// 82E14964: 83EB0014  lwz r31, 0x14(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E14968: 83CB0010  lwz r30, 0x10(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E1496C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E14970: 419A0024  beq cr6, 0x82e14994
	if ctx.cr[6].eq {
	pc = 0x82E14994; continue 'dispatch;
	}
	// 82E14974: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82E14978: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E1497C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E14980: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E14984: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E14988: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E1498C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E14990: 4082FFE8  bne 0x82e14978
	if !ctx.cr[0].eq {
	pc = 0x82E14978; continue 'dispatch;
	}
	// 82E14994: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E14998: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E1499C: 48015715  bl 0x82e2a0b0
	ctx.lr = 0x82E149A0;
	sub_82E2A0B0(ctx, base);
	// 82E149A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E149A4: 4BFFD815  bl 0x82e121b8
	ctx.lr = 0x82E149A8;
	sub_82E121B8(ctx, base);
	// 82E149A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E149AC: 482AAE7D  bl 0x830bf828
	ctx.lr = 0x82E149B0;
	sub_830BF828(ctx, base);
	// 82E149B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E149B4: 419A000C  beq cr6, 0x82e149c0
	if ctx.cr[6].eq {
	pc = 0x82E149C0; continue 'dispatch;
	}
	// 82E149B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E149BC: 4B4ABED5  bl 0x822c0890
	ctx.lr = 0x82E149C0;
	sub_822C0890(ctx, base);
	// 82E149C0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E149C4: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82E149C8: 409AFF9C  bne cr6, 0x82e14964
	if !ctx.cr[6].eq {
	pc = 0x82E14964; continue 'dispatch;
	}
	// 82E149CC: 83BC0184  lwz r29, 0x184(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(388 as u32) ) } as u64;
	// 82E149D0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E149D4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82E149D8: 48000064  b 0x82e14a3c
	pc = 0x82E14A3C; continue 'dispatch;
	// 82E149DC: 83EB0014  lwz r31, 0x14(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E149E0: 83CB0010  lwz r30, 0x10(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82E149E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E149E8: 419A0024  beq cr6, 0x82e14a0c
	if ctx.cr[6].eq {
	pc = 0x82E14A0C; continue 'dispatch;
	}
	// 82E149EC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82E149F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E149F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E149F8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E149FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E14A00: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E14A04: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E14A08: 4082FFE8  bne 0x82e149f0
	if !ctx.cr[0].eq {
	pc = 0x82E149F0; continue 'dispatch;
	}
	// 82E14A0C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E14A10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E14A14: 4801569D  bl 0x82e2a0b0
	ctx.lr = 0x82E14A18;
	sub_82E2A0B0(ctx, base);
	// 82E14A18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82E14A1C: 4BFFD79D  bl 0x82e121b8
	ctx.lr = 0x82E14A20;
	sub_82E121B8(ctx, base);
	// 82E14A20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E14A24: 482AAE05  bl 0x830bf828
	ctx.lr = 0x82E14A28;
	sub_830BF828(ctx, base);
	// 82E14A28: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E14A2C: 419A000C  beq cr6, 0x82e14a38
	if ctx.cr[6].eq {
	pc = 0x82E14A38; continue 'dispatch;
	}
	// 82E14A30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E14A34: 4B4ABE5D  bl 0x822c0890
	ctx.lr = 0x82E14A38;
	sub_822C0890(ctx, base);
	// 82E14A38: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82E14A3C: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82E14A40: 409AFF9C  bne cr6, 0x82e149dc
	if !ctx.cr[6].eq {
	pc = 0x82E149DC; continue 'dispatch;
	}
	// 82E14A44: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82E14A48: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82E14A4C: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E14A50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82E14A54: 419A007C  beq cr6, 0x82e14ad0
	if ctx.cr[6].eq {
	pc = 0x82E14AD0; continue 'dispatch;
	}
	// 82E14A58: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E14A5C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82E14A60: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82E14A64: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82E14A68: 40980068  bge cr6, 0x82e14ad0
	if !ctx.cr[6].lt {
	pc = 0x82E14AD0; continue 'dispatch;
	}
	// 82E14A6C: 817C0190  lwz r11, 0x190(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(400 as u32) ) } as u64;
	// 82E14A70: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82E14A74: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E14A78: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E14A7C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E14A80: 419A0024  beq cr6, 0x82e14aa4
	if ctx.cr[6].eq {
	pc = 0x82E14AA4; continue 'dispatch;
	}
	// 82E14A84: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82E14A88: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82E14A8C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E14A90: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82E14A94: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82E14A98: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82E14A9C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82E14AA0: 4082FFE8  bne 0x82e14a88
	if !ctx.cr[0].eq {
	pc = 0x82E14A88; continue 'dispatch;
	}
	// 82E14AA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E14AA8: 419A000C  beq cr6, 0x82e14ab4
	if ctx.cr[6].eq {
	pc = 0x82E14AB4; continue 'dispatch;
	}
	// 82E14AAC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82E14AB0: 48015A81  bl 0x82e2a530
	ctx.lr = 0x82E14AB4;
	sub_82E2A530(ctx, base);
	// 82E14AB4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82E14AB8: 419A000C  beq cr6, 0x82e14ac4
	if ctx.cr[6].eq {
	pc = 0x82E14AC4; continue 'dispatch;
	}
	// 82E14ABC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E14AC0: 4B4ABDD1  bl 0x822c0890
	ctx.lr = 0x82E14AC4;
	sub_822C0890(ctx, base);
	// 82E14AC4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82E14AC8: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82E14ACC: 4BFFFF80  b 0x82e14a4c
	pc = 0x82E14A4C; continue 'dispatch;
	// 82E14AD0: 807C015C  lwz r3, 0x15c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(348 as u32) ) } as u64;
	// 82E14AD4: 3BFC015C  addi r31, r28, 0x15c
	ctx.r[31].s64 = ctx.r[28].s64 + 348;
	// 82E14AD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E14ADC: 419A0018  beq cr6, 0x82e14af4
	if ctx.cr[6].eq {
	pc = 0x82E14AF4; continue 'dispatch;
	}
	// 82E14AE0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E14AE4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82E14AE8: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E14AEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E14AF0: 4E800421  bctrl
	ctx.lr = 0x82E14AF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E14AF4: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E14AF8: 389B0004  addi r4, r27, 4
	ctx.r[4].s64 = ctx.r[27].s64 + 4;
	// 82E14AFC: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82E14B00: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82E14B04: 4B4AF95D  bl 0x822c4460
	ctx.lr = 0x82E14B08;
	sub_822C4460(ctx, base);
	// 82E14B08: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E14B0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82E14B10: 419A0018  beq cr6, 0x82e14b28
	if ctx.cr[6].eq {
	pc = 0x82E14B28; continue 'dispatch;
	}
	// 82E14B14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E14B18: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82E14B1C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82E14B20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E14B24: 4E800421  bctrl
	ctx.lr = 0x82E14B28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E14B28: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82E14B2C: 48393680  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E14B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E14B30 size=516
    let mut pc: u32 = 0x82E14B30;
    'dispatch: loop {
        match pc {
            0x82E14B30 => {
    //   block [0x82E14B30..0x82E14D34)
	// 82E14B30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E14B34: 48393631  bl 0x831a8164
	ctx.lr = 0x82E14B38;
	sub_831A8130(ctx, base);
	// 82E14B38: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E14B3C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82E14B40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E14B44: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82E14B48: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82E14B4C: 897F01A4  lbz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 82E14B50: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82E14B54: 7F8B5214  add r28, r11, r10
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82E14B58: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82E14B5C: 419A0134  beq cr6, 0x82e14c90
	if ctx.cr[6].eq {
	pc = 0x82E14C90; continue 'dispatch;
	}
	// 82E14B60: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82E14B64: 419A012C  beq cr6, 0x82e14c90
	if ctx.cr[6].eq {
	pc = 0x82E14C90; continue 'dispatch;
	}
	// 82E14B68: 39650010  addi r11, r5, 0x10
	ctx.r[11].s64 = ctx.r[5].s64 + 16;
	// 82E14B6C: C0050020  lfs f0, 0x20(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82E14B70: 39400130  li r10, 0x130
	ctx.r[10].s64 = 304;
	// 82E14B74: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82E14B78: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82E14B7C: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 82E14B80: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82E14B84: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E14B88: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 82E14B8C: 13DF50C7  vcmpequd (lvx128) v30, v31, v10
	tmp.u32 = ctx.r[31].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E14B90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E14D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82E14D38 size=400
    let mut pc: u32 = 0x82E14D38;
    'dispatch: loop {
        match pc {
            0x82E14D38 => {
    //   block [0x82E14D38..0x82E14EC8)
	// 82E14D38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E14D3C: 48393429  bl 0x831a8164
	ctx.lr = 0x82E14D40;
	sub_831A8130(ctx, base);
	// 82E14D40: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82E14D44: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E14D48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E14D4C: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82E14D50: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82E14D54: 38AABCD4  addi r5, r10, -0x432c
	ctx.r[5].s64 = ctx.r[10].s64 + -17196;
	// 82E14D58: 38CB6880  addi r6, r11, 0x6880
	ctx.r[6].s64 = ctx.r[11].s64 + 26752;
	// 82E14D5C: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82E14D60: 90BF0000  stw r5, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82E14D64: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 82E14D68: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82E14D6C: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 82E14D70: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82E14D74: 3C808338  lis r4, -0x7cc8
	ctx.r[4].s64 = -2093481984;
	// 82E14D78: 395F0050  addi r10, r31, 0x50
	ctx.r[10].s64 = ctx.r[31].s64 + 80;
	// 82E14D7C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82E14D80: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82E14D84: 13E73407  vcmpneb. (lvlx128) v31, v7, v6
	tmp.u32 = ctx.r[7].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E14D88: 3FA08200  lis r29, -0x7e00
	ctx.r[29].s64 = -2113929216;
	// 82E14D8C: 13C83407  vcmpneb. (lvlx128) v30, v8, v6
	tmp.u32 = ctx.r[8].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E14D90: 38846910  addi r4, r4, 0x6910
	ctx.r[4].s64 = ctx.r[4].s64 + 26896;
	// 82E14D94: 13A93407  vcmpneb. (lvlx128) v29, v9, v6
	tmp.u32 = ctx.r[9].u32 + ctx.r[6].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E14D98: 13803407  vcmpneb. (lvlx128) v28, v0, v6
	tmp.u32 = ctx.r[6].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82E14D9C: 3B8000A0  li r28, 0xa0
	ctx.r[28].s64 = 160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E14EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E14EC8 size=76
    let mut pc: u32 = 0x82E14EC8;
    'dispatch: loop {
        match pc {
            0x82E14EC8 => {
    //   block [0x82E14EC8..0x82E14F14)
	// 82E14EC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E14ECC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E14ED0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E14ED4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E14ED8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E14EDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E14EE0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E14EE4: 4BFFF775  bl 0x82e14658
	ctx.lr = 0x82E14EE8;
	sub_82E14658(ctx, base);
	// 82E14EE8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E14EEC: 4182000C  beq 0x82e14ef8
	if ctx.cr[0].eq {
	pc = 0x82E14EF8; continue 'dispatch;
	}
	// 82E14EF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E14EF4: 4BFDD4E5  bl 0x82df23d8
	ctx.lr = 0x82E14EF8;
	sub_82DF23D8(ctx, base);
	// 82E14EF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E14EFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E14F00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E14F04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E14F08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E14F0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E14F10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E14F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E14F18 size=68
    let mut pc: u32 = 0x82E14F18;
    'dispatch: loop {
        match pc {
            0x82E14F18 => {
    //   block [0x82E14F18..0x82E14F5C)
	// 82E14F18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E14F1C: 48393251  bl 0x831a816c
	ctx.lr = 0x82E14F20;
	sub_831A8130(ctx, base);
	// 82E14F20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E14F24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E14F28: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E14F2C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82E14F30: 480143E9  bl 0x82e29318
	ctx.lr = 0x82E14F34;
	sub_82E29318(ctx, base);
	// 82E14F34: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82E14F38: 4182001C  beq 0x82e14f54
	if ctx.cr[0].eq {
	pc = 0x82E14F54; continue 'dispatch;
	}
	// 82E14F3C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E14F40: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82E14F44: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82E14F48: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82E14F4C: 80AB0074  lwz r5, 0x74(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 82E14F50: 4BFFFBE1  bl 0x82e14b30
	ctx.lr = 0x82E14F54;
	sub_82E14B30(ctx, base);
	// 82E14F54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E14F58: 48393264  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E14F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E14F60 size=8
    let mut pc: u32 = 0x82E14F60;
    'dispatch: loop {
        match pc {
            0x82E14F60 => {
    //   block [0x82E14F60..0x82E14F68)
	// 82E14F60: 80630084  lwz r3, 0x84(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) } as u64;
	// 82E14F64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E14F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E14F68 size=8
    let mut pc: u32 = 0x82E14F68;
    'dispatch: loop {
        match pc {
            0x82E14F68 => {
    //   block [0x82E14F68..0x82E14F70)
	// 82E14F68: 80630084  lwz r3, 0x84(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) } as u64;
	// 82E14F6C: 4BFFE644  b 0x82e135b0
	sub_82E135B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E14F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E14F70 size=84
    let mut pc: u32 = 0x82E14F70;
    'dispatch: loop {
        match pc {
            0x82E14F70 => {
    //   block [0x82E14F70..0x82E14FC4)
	// 82E14F70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E14F74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E14F78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82E14F7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E14F80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E14F84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E14F88: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82E14F8C: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82E14F90: 4BFFF941  bl 0x82e148d0
	ctx.lr = 0x82E14F94;
	sub_82E148D0(ctx, base);
	// 82E14F94: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E14F98: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 82E14F9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82E14FA0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82E14FA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82E14FA8: 4E800421  bctrl
	ctx.lr = 0x82E14FAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82E14FAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E14FB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E14FB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E14FB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82E14FBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E14FC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E14FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E14FC8 size=76
    let mut pc: u32 = 0x82E14FC8;
    'dispatch: loop {
        match pc {
            0x82E14FC8 => {
    //   block [0x82E14FC8..0x82E15014)
	// 82E14FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E14FCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E14FD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E14FD4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E14FD8: 83E30008  lwz r31, 8(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82E14FDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82E14FE0: 4BFDEC21  bl 0x82df3c00
	ctx.lr = 0x82E14FE4;
	sub_82DF3C00(ctx, base);
	// 82E14FE4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82E14FE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E14FEC: 480113C5  bl 0x82e263b0
	ctx.lr = 0x82E14FF0;
	sub_82E263B0(ctx, base);
	// 82E14FF0: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82E14FF4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82E14FF8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82E14FFC: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82E15000: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82E15004: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E15008: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E1500C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E15010: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E15018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E15018 size=8
    let mut pc: u32 = 0x82E15018;
    'dispatch: loop {
        match pc {
            0x82E15018 => {
    //   block [0x82E15018..0x82E15020)
	// 82E15018: 80630084  lwz r3, 0x84(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) } as u64;
	// 82E1501C: 4BFFE574  b 0x82e13590
	sub_82E13590(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E15020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E15020 size=8
    let mut pc: u32 = 0x82E15020;
    'dispatch: loop {
        match pc {
            0x82E15020 => {
    //   block [0x82E15020..0x82E15028)
	// 82E15020: 80630084  lwz r3, 0x84(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) } as u64;
	// 82E15024: 4BFFE484  b 0x82e134a8
	sub_82E134A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E15028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82E15028 size=8
    let mut pc: u32 = 0x82E15028;
    'dispatch: loop {
        match pc {
            0x82E15028 => {
    //   block [0x82E15028..0x82E15030)
	// 82E15028: 80630084  lwz r3, 0x84(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) } as u64;
	// 82E1502C: 4BFFE49C  b 0x82e134c8
	sub_82E134C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82E15030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82E15030 size=64
    let mut pc: u32 = 0x82E15030;
    'dispatch: loop {
        match pc {
            0x82E15030 => {
    //   block [0x82E15030..0x82E15070)
	// 82E15030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82E15034: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82E15038: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82E1503C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82E15040: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82E15044: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82E15048: 38AB0008  addi r5, r11, 8
	ctx.r[5].s64 = ctx.r[11].s64 + 8;
	// 82E1504C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82E15050: 808B0084  lwz r4, 0x84(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 82E15054: 4BFFF33D  bl 0x82e14390
	ctx.lr = 0x82E15058;
	sub_82E14390(ctx, base);
	// 82E15058: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82E1505C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82E15060: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82E15064: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82E15068: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82E1506C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


