pub fn sub_825C9148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9148 size=116
    let mut pc: u32 = 0x825C9148;
    'dispatch: loop {
        match pc {
            0x825C9148 => {
    //   block [0x825C9148..0x825C91BC)
	// 825C9148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C914C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C9150: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825C9154: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825C9158: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C915C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825C9160: 83FE0018  lwz r31, 0x18(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825C9164: 48000028  b 0x825c918c
	pc = 0x825C918C; continue 'dispatch;
	// 825C9168: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C916C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C9170: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825C9174: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C9178: 4E800421  bctrl
	ctx.lr = 0x825C917C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C917C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825C9180: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825C9184: 419A0030  beq cr6, 0x825c91b4
	if ctx.cr[6].eq {
	pc = 0x825C91B4; continue 'dispatch;
	}
	// 825C9188: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 825C918C: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 825C9190: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825C9194: 409AFFD4  bne cr6, 0x825c9168
	if !ctx.cr[6].eq {
	pc = 0x825C9168; continue 'dispatch;
	}
	// 825C9198: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825C919C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825C91A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825C91A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825C91A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825C91AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825C91B0: 4E800020  blr
	return;
	// 825C91B4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825C91B8: 4BFFFFE4  b 0x825c919c
	pc = 0x825C919C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C91C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C91C0 size=84
    let mut pc: u32 = 0x825C91C0;
    'dispatch: loop {
        match pc {
            0x825C91C0 => {
    //   block [0x825C91C0..0x825C9214)
	// 825C91C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C91C4: 48BDEFA5  bl 0x831a8168
	ctx.lr = 0x825C91C8;
	sub_831A8130(ctx, base);
	// 825C91C8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C91CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C91D0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825C91D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825C91D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825C91DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C91E0: 839F0000  lwz r28, 0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C91E4: 4BFC2D2D  bl 0x8258bf10
	ctx.lr = 0x825C91E8;
	sub_8258BF10(ctx, base);
	// 825C91E8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825C91EC: 817C0040  lwz r11, 0x40(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 825C91F0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825C91F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C91F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C91FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C9200: 4E800421  bctrl
	ctx.lr = 0x825C9204;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C9204: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C9208: 4BCFFAB1  bl 0x822c8cb8
	ctx.lr = 0x825C920C;
	sub_822C8CB8(ctx, base);
	// 825C920C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825C9210: 48BDEFA8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9218 size=92
    let mut pc: u32 = 0x825C9218;
    'dispatch: loop {
        match pc {
            0x825C9218 => {
    //   block [0x825C9218..0x825C9274)
	// 825C9218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C921C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C9220: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825C9224: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825C9228: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C922C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825C9230: 83FE0018  lwz r31, 0x18(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825C9234: 4800001C  b 0x825c9250
	pc = 0x825C9250; continue 'dispatch;
	// 825C9238: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C923C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C9240: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825C9244: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C9248: 4E800421  bctrl
	ctx.lr = 0x825C924C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C924C: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 825C9250: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 825C9254: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825C9258: 409AFFE0  bne cr6, 0x825c9238
	if !ctx.cr[6].eq {
	pc = 0x825C9238; continue 'dispatch;
	}
	// 825C925C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825C9260: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825C9264: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825C9268: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825C926C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825C9270: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9278 size=112
    let mut pc: u32 = 0x825C9278;
    'dispatch: loop {
        match pc {
            0x825C9278 => {
    //   block [0x825C9278..0x825C92E8)
	// 825C9278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C927C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C9280: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825C9284: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825C9288: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C928C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825C9290: 83FE0018  lwz r31, 0x18(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825C9294: 48000024  b 0x825c92b8
	pc = 0x825C92B8; continue 'dispatch;
	// 825C9298: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C929C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C92A0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825C92A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C92A8: 4E800421  bctrl
	ctx.lr = 0x825C92AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C92AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C92B0: 41820030  beq 0x825c92e0
	if ctx.cr[0].eq {
	pc = 0x825C92E0; continue 'dispatch;
	}
	// 825C92B4: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 825C92B8: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 825C92BC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825C92C0: 409AFFD8  bne cr6, 0x825c9298
	if !ctx.cr[6].eq {
	pc = 0x825C9298; continue 'dispatch;
	}
	// 825C92C4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825C92C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825C92CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825C92D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825C92D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825C92D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825C92DC: 4E800020  blr
	return;
	// 825C92E0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825C92E4: 4BFFFFE4  b 0x825c92c8
	pc = 0x825C92C8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C92E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C92E8 size=112
    let mut pc: u32 = 0x825C92E8;
    'dispatch: loop {
        match pc {
            0x825C92E8 => {
    //   block [0x825C92E8..0x825C9358)
	// 825C92E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C92EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C92F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825C92F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825C92F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C92FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825C9300: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C9304: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825C9308: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825C930C: 4BFFFBE5  bl 0x825c8ef0
	ctx.lr = 0x825C9310;
	sub_825C8EF0(ctx, base);
	// 825C9310: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825C9314: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C9318: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825C931C: 4BCF6CE5  bl 0x822c0000
	ctx.lr = 0x825C9320;
	sub_822C0000(ctx, base);
	// 825C9320: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825C9324: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825C9328: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825C932C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C9330: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825C9334: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825C9338: 419A0008  beq cr6, 0x825c9340
	if ctx.cr[6].eq {
	pc = 0x825C9340; continue 'dispatch;
	}
	// 825C933C: 4BCF7555  bl 0x822c0890
	ctx.lr = 0x825C9340;
	sub_822C0890(ctx, base);
	// 825C9340: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825C9344: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825C9348: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825C934C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825C9350: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825C9354: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9358 size=172
    let mut pc: u32 = 0x825C9358;
    'dispatch: loop {
        match pc {
            0x825C9358 => {
    //   block [0x825C9358..0x825C9404)
	// 825C9358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C935C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C9360: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825C9364: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825C9368: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C936C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825C9370: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C9374: 389E0024  addi r4, r30, 0x24
	ctx.r[4].s64 = ctx.r[30].s64 + 36;
	// 825C9378: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C937C: 4BEC8F8D  bl 0x82492308
	ctx.lr = 0x825C9380;
	sub_82492308(ctx, base);
	// 825C9380: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825C9384: 815E0028  lwz r10, 0x28(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 825C9388: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825C938C: 419A0050  beq cr6, 0x825c93dc
	if ctx.cr[6].eq {
	pc = 0x825C93DC; continue 'dispatch;
	}
	// 825C9390: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825C9394: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825C9398: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C939C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825C93A0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C93A4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825C93A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C93AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C93B0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825C93B4: 419A0034  beq cr6, 0x825c93e8
	if ctx.cr[6].eq {
	pc = 0x825C93E8; continue 'dispatch;
	}
	// 825C93B8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825C93BC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825C93C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825C93C4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825C93C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825C93CC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825C93D0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825C93D4: 4082FFE8  bne 0x825c93bc
	if !ctx.cr[0].eq {
	pc = 0x825C93BC; continue 'dispatch;
	}
	// 825C93D8: 48000010  b 0x825c93e8
	pc = 0x825C93E8; continue 'dispatch;
	// 825C93DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825C93E0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825C93E4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825C93E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C93EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825C93F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825C93F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825C93F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825C93FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825C9400: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9408 size=88
    let mut pc: u32 = 0x825C9408;
    'dispatch: loop {
        match pc {
            0x825C9408 => {
    //   block [0x825C9408..0x825C9460)
	// 825C9408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C940C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C9410: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825C9414: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C9418: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C941C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 825C9420: 389F0040  addi r4, r31, 0x40
	ctx.r[4].s64 = ctx.r[31].s64 + 64;
	// 825C9424: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C9428: 4BEC8EE1  bl 0x82492308
	ctx.lr = 0x825C942C;
	sub_82492308(ctx, base);
	// 825C942C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825C9430: 815F0044  lwz r10, 0x44(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 825C9434: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825C9438: 419A000C  beq cr6, 0x825c9444
	if ctx.cr[6].eq {
	pc = 0x825C9444; continue 'dispatch;
	}
	// 825C943C: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825C9440: 4800000C  b 0x825c944c
	pc = 0x825C944C; continue 'dispatch;
	// 825C9444: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825C9448: 806BCDF4  lwz r3, -0x320c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12812 as u32) ) } as u64;
	// 825C944C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825C9450: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825C9454: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825C9458: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825C945C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9460 size=192
    let mut pc: u32 = 0x825C9460;
    'dispatch: loop {
        match pc {
            0x825C9460 => {
    //   block [0x825C9460..0x825C9520)
	// 825C9460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C9464: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C9468: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825C946C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C9470: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C9474: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 825C9478: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C947C: 409A000C  bne cr6, 0x825c9488
	if !ctx.cr[6].eq {
	pc = 0x825C9488; continue 'dispatch;
	}
	// 825C9480: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825C9484: 48000088  b 0x825c950c
	pc = 0x825C950C; continue 'dispatch;
	// 825C9488: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 825C948C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825C9490: 809F004C  lwz r4, 0x4c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 825C9494: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825C9498: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825C949C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825C94A0: 419A000C  beq cr6, 0x825c94ac
	if ctx.cr[6].eq {
	pc = 0x825C94AC; continue 'dispatch;
	}
	// 825C94A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C94A8: 4BEC7B91  bl 0x82491038
	ctx.lr = 0x825C94AC;
	sub_82491038(ctx, base);
	// 825C94AC: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 825C94B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825C94B4: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825C94B8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825C94BC: 409A0014  bne cr6, 0x825c94d0
	if !ctx.cr[6].eq {
	pc = 0x825C94D0; continue 'dispatch;
	}
	// 825C94C0: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825C94C4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825C94C8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 825C94CC: 419A0008  beq cr6, 0x825c94d4
	if ctx.cr[6].eq {
	pc = 0x825C94D4; continue 'dispatch;
	}
	// 825C94D0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825C94D4: 5529063F  clrlwi. r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825C94D8: 40820030  bne 0x825c9508
	if !ctx.cr[0].eq {
	pc = 0x825C9508; continue 'dispatch;
	}
	// 825C94DC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 825C94E0: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C94E4: 7D295830  slw r9, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825C94E8: 7D294039  and. r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825C94EC: 4182FF94  beq 0x825c9480
	if ctx.cr[0].eq {
	pc = 0x825C9480; continue 'dispatch;
	}
	// 825C94F0: 2B0B001F  cmplwi cr6, r11, 0x1f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 31 as u32, &mut ctx.xer);
	// 825C94F4: 4098000C  bge cr6, 0x825c9500
	if !ctx.cr[6].lt {
	pc = 0x825C9500; continue 'dispatch;
	}
	// 825C94F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825C94FC: 4BFFFFB8  b 0x825c94b4
	pc = 0x825C94B4; continue 'dispatch;
	// 825C9500: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825C9504: 4BFFFFAC  b 0x825c94b0
	pc = 0x825C94B0; continue 'dispatch;
	// 825C9508: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825C950C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825C9510: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825C9514: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825C9518: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825C951C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9520 size=192
    let mut pc: u32 = 0x825C9520;
    'dispatch: loop {
        match pc {
            0x825C9520 => {
    //   block [0x825C9520..0x825C95E0)
	// 825C9520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C9524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C9528: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825C952C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C9530: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C9534: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 825C9538: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C953C: 419A008C  beq cr6, 0x825c95c8
	if ctx.cr[6].eq {
	pc = 0x825C95C8; continue 'dispatch;
	}
	// 825C9540: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 825C9544: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825C9548: 809F004C  lwz r4, 0x4c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 825C954C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825C9550: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825C9554: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825C9558: 419A000C  beq cr6, 0x825c9564
	if ctx.cr[6].eq {
	pc = 0x825C9564; continue 'dispatch;
	}
	// 825C955C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C9560: 4BEC7AD9  bl 0x82491038
	ctx.lr = 0x825C9564;
	sub_82491038(ctx, base);
	// 825C9564: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 825C9568: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825C956C: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825C9570: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825C9574: 409A0014  bne cr6, 0x825c9588
	if !ctx.cr[6].eq {
	pc = 0x825C9588; continue 'dispatch;
	}
	// 825C9578: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825C957C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825C9580: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 825C9584: 419A0008  beq cr6, 0x825c958c
	if ctx.cr[6].eq {
	pc = 0x825C958C; continue 'dispatch;
	}
	// 825C9588: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825C958C: 5529063F  clrlwi. r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825C9590: 40820038  bne 0x825c95c8
	if !ctx.cr[0].eq {
	pc = 0x825C95C8; continue 'dispatch;
	}
	// 825C9594: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 825C9598: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C959C: 7D295830  slw r9, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825C95A0: 7D294039  and. r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825C95A4: 4082001C  bne 0x825c95c0
	if !ctx.cr[0].eq {
	pc = 0x825C95C0; continue 'dispatch;
	}
	// 825C95A8: 2B0B001F  cmplwi cr6, r11, 0x1f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 31 as u32, &mut ctx.xer);
	// 825C95AC: 4098000C  bge cr6, 0x825c95b8
	if !ctx.cr[6].lt {
	pc = 0x825C95B8; continue 'dispatch;
	}
	// 825C95B0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825C95B4: 4BFFFFB8  b 0x825c956c
	pc = 0x825C956C; continue 'dispatch;
	// 825C95B8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825C95BC: 4BFFFFAC  b 0x825c9568
	pc = 0x825C9568; continue 'dispatch;
	// 825C95C0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825C95C4: 48000008  b 0x825c95cc
	pc = 0x825C95CC; continue 'dispatch;
	// 825C95C8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825C95CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825C95D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825C95D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825C95D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825C95DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C95E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C95E0 size=96
    let mut pc: u32 = 0x825C95E0;
    'dispatch: loop {
        match pc {
            0x825C95E0 => {
    //   block [0x825C95E0..0x825C9640)
	// 825C95E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C95E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C95E8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C95EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825C95F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C95F4: 388BD610  addi r4, r11, -0x29f0
	ctx.r[4].s64 = ctx.r[11].s64 + -10736;
	// 825C95F8: 4BCFC2D1  bl 0x822c58c8
	ctx.lr = 0x825C95FC;
	sub_822C58C8(ctx, base);
	// 825C95FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825C9600: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825C9604: 4BD008AD  bl 0x822c9eb0
	ctx.lr = 0x825C9608;
	sub_822C9EB0(ctx, base);
	// 825C9608: 4BCFACA9  bl 0x822c42b0
	ctx.lr = 0x825C960C;
	sub_822C42B0(ctx, base);
	// 825C960C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825C9610: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825C9614: 396B9600  addi r11, r11, -0x6a00
	ctx.r[11].s64 = ctx.r[11].s64 + -27136;
	// 825C9618: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825C961C: 4BCFBE55  bl 0x822c5470
	ctx.lr = 0x825C9620;
	sub_822C5470(ctx, base);
	// 825C9620: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825C9624: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825C9628: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C962C: 4BCFB6B5  bl 0x822c4ce0
	ctx.lr = 0x825C9630;
	sub_822C4CE0(ctx, base);
	// 825C9630: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825C9634: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825C9638: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825C963C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9640 size=108
    let mut pc: u32 = 0x825C9640;
    'dispatch: loop {
        match pc {
            0x825C9640 => {
    //   block [0x825C9640..0x825C96AC)
	// 825C9640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C9644: 48BDEB29  bl 0x831a816c
	ctx.lr = 0x825C9648;
	sub_831A8130(ctx, base);
	// 825C9648: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C964C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825C9650: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825C9654: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C9658: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C965C: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825C9660: 4199000C  bgt cr6, 0x825c966c
	if ctx.cr[6].gt {
	pc = 0x825C966C; continue 'dispatch;
	}
	// 825C9664: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825C9668: 4BFFFF79  bl 0x825c95e0
	ctx.lr = 0x825C966C;
	sub_825C95E0(ctx, base);
	// 825C966C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C9670: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825C9674: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825C9678: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825C967C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825C9680: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825C9684: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825C9688: 4BEC7BB1  bl 0x82491238
	ctx.lr = 0x825C968C;
	sub_82491238(ctx, base);
	// 825C968C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825C9690: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C9694: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C9698: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C969C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825C96A0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825C96A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825C96A8: 48BDEB14  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C96B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C96B0 size=128
    let mut pc: u32 = 0x825C96B0;
    'dispatch: loop {
        match pc {
            0x825C96B0 => {
    //   block [0x825C96B0..0x825C9730)
	// 825C96B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C96B4: 48BDEAB9  bl 0x831a816c
	ctx.lr = 0x825C96B8;
	sub_831A8130(ctx, base);
	// 825C96B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C96BC: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825C96C0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825C96C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825C96C8: 3BEB7D14  addi r31, r11, 0x7d14
	ctx.r[31].s64 = ctx.r[11].s64 + 32020;
	// 825C96CC: 816A7D1C  lwz r11, 0x7d1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32028 as u32) ) } as u64;
	// 825C96D0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825C96D4: 40820024  bne 0x825c96f8
	if !ctx.cr[0].eq {
	pc = 0x825C96F8; continue 'dispatch;
	}
	// 825C96D8: 3D208256  lis r9, -0x7daa
	ctx.r[9].s64 = -2108293120;
	// 825C96DC: 3D00825D  lis r8, -0x7da3
	ctx.r[8].s64 = -2107834368;
	// 825C96E0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825C96E4: 3929DA70  addi r9, r9, -0x2590
	ctx.r[9].s64 = ctx.r[9].s64 + -9616;
	// 825C96E8: 39089020  addi r8, r8, -0x6fe0
	ctx.r[8].s64 = ctx.r[8].s64 + -28640;
	// 825C96EC: 916A7D1C  stw r11, 0x7d1c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32028 as u32), ctx.r[11].u32 ) };
	// 825C96F0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825C96F4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825C96F8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825C96FC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825C9700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C9704: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 825C9708: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825C970C: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825C9710: 48009211  bl 0x825d2920
	ctx.lr = 0x825C9714;
	sub_825D2920(ctx, base);
	// 825C9714: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C9718: 4182000C  beq 0x825c9724
	if ctx.cr[0].eq {
	pc = 0x825C9724; continue 'dispatch;
	}
	// 825C971C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825C9720: 48000008  b 0x825c9728
	pc = 0x825C9728; continue 'dispatch;
	// 825C9724: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825C9728: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825C972C: 48BDEA90  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9730 size=128
    let mut pc: u32 = 0x825C9730;
    'dispatch: loop {
        match pc {
            0x825C9730 => {
    //   block [0x825C9730..0x825C97B0)
	// 825C9730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C9734: 48BDEA39  bl 0x831a816c
	ctx.lr = 0x825C9738;
	sub_831A8130(ctx, base);
	// 825C9738: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C973C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825C9740: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825C9744: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825C9748: 3BEB7D20  addi r31, r11, 0x7d20
	ctx.r[31].s64 = ctx.r[11].s64 + 32032;
	// 825C974C: 816A7D28  lwz r11, 0x7d28(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32040 as u32) ) } as u64;
	// 825C9750: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825C9754: 40820024  bne 0x825c9778
	if !ctx.cr[0].eq {
	pc = 0x825C9778; continue 'dispatch;
	}
	// 825C9758: 3D208256  lis r9, -0x7daa
	ctx.r[9].s64 = -2108293120;
	// 825C975C: 3D00825D  lis r8, -0x7da3
	ctx.r[8].s64 = -2107834368;
	// 825C9760: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825C9764: 3929DA70  addi r9, r9, -0x2590
	ctx.r[9].s64 = ctx.r[9].s64 + -9616;
	// 825C9768: 39089068  addi r8, r8, -0x6f98
	ctx.r[8].s64 = ctx.r[8].s64 + -28568;
	// 825C976C: 916A7D28  stw r11, 0x7d28(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32040 as u32), ctx.r[11].u32 ) };
	// 825C9770: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825C9774: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825C9778: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825C977C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825C9780: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C9784: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 825C9788: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825C978C: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825C9790: 48009191  bl 0x825d2920
	ctx.lr = 0x825C9794;
	sub_825D2920(ctx, base);
	// 825C9794: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C9798: 4182000C  beq 0x825c97a4
	if ctx.cr[0].eq {
	pc = 0x825C97A4; continue 'dispatch;
	}
	// 825C979C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825C97A0: 48000008  b 0x825c97a8
	pc = 0x825C97A8; continue 'dispatch;
	// 825C97A4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825C97A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825C97AC: 48BDEA10  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C97B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C97B0 size=204
    let mut pc: u32 = 0x825C97B0;
    'dispatch: loop {
        match pc {
            0x825C97B0 => {
    //   block [0x825C97B0..0x825C987C)
	// 825C97B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C97B4: 48BDE9AD  bl 0x831a8160
	ctx.lr = 0x825C97B8;
	sub_831A8130(ctx, base);
	// 825C97B8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C97BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C97C0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 825C97C4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825C97C8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825C97CC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C97D0: 4BFD7319  bl 0x825a0ae8
	ctx.lr = 0x825C97D4;
	sub_825A0AE8(ctx, base);
	// 825C97D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825C97D8: 4182009C  beq 0x825c9874
	if ctx.cr[0].eq {
	pc = 0x825C9874; continue 'dispatch;
	}
	// 825C97DC: 3BBF0040  addi r29, r31, 0x40
	ctx.r[29].s64 = ctx.r[31].s64 + 64;
	// 825C97E0: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825C97E4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825C97E8: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C97EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C97F0: 4BFD74F1  bl 0x825a0ce0
	ctx.lr = 0x825C97F4;
	sub_825A0CE0(ctx, base);
	// 825C97F4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825C97F8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825C97FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825C9800: 4BEC8B09  bl 0x82492308
	ctx.lr = 0x825C9804;
	sub_82492308(ctx, base);
	// 825C9804: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C9808: 48829C21  bl 0x82df3428
	ctx.lr = 0x825C980C;
	sub_82DF3428(ctx, base);
	// 825C980C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825C9810: 815F0044  lwz r10, 0x44(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 825C9814: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825C9818: 419A0048  beq cr6, 0x825c9860
	if ctx.cr[6].eq {
	pc = 0x825C9860; continue 'dispatch;
	}
	// 825C981C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825C9820: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825C9824: 409A003C  bne cr6, 0x825c9860
	if !ctx.cr[6].eq {
	pc = 0x825C9860; continue 'dispatch;
	}
	// 825C9828: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825C982C: 389F004C  addi r4, r31, 0x4c
	ctx.r[4].s64 = ctx.r[31].s64 + 76;
	// 825C9830: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825C9834: 4BFFFE0D  bl 0x825c9640
	ctx.lr = 0x825C9838;
	sub_825C9640(ctx, base);
	// 825C9838: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C983C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C9840: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C9844: 7F6A5030  slw r10, r27, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[27].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825C9848: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C984C: 4182000C  beq 0x825c9858
	if ctx.cr[0].eq {
	pc = 0x825C9858; continue 'dispatch;
	}
	// 825C9850: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 825C9854: 48000008  b 0x825c985c
	pc = 0x825C985C; continue 'dispatch;
	// 825C9858: 7D2A5078  andc r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 & !ctx.r[10].u64;
	// 825C985C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825C9860: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C9864: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 825C9868: 4BFD7281  bl 0x825a0ae8
	ctx.lr = 0x825C986C;
	sub_825A0AE8(ctx, base);
	// 825C986C: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 825C9870: 4198FF74  blt cr6, 0x825c97e4
	if ctx.cr[6].lt {
	pc = 0x825C97E4; continue 'dispatch;
	}
	// 825C9874: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825C9878: 48BDE938  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9880 size=136
    let mut pc: u32 = 0x825C9880;
    'dispatch: loop {
        match pc {
            0x825C9880 => {
    //   block [0x825C9880..0x825C9908)
	// 825C9880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C9884: 48BDE8E1  bl 0x831a8164
	ctx.lr = 0x825C9888;
	sub_831A8130(ctx, base);
	// 825C9888: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C988C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825C9890: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825C9894: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825C9898: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C989C: 4BFD724D  bl 0x825a0ae8
	ctx.lr = 0x825C98A0;
	sub_825A0AE8(ctx, base);
	// 825C98A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825C98A4: 4182005C  beq 0x825c9900
	if ctx.cr[0].eq {
	pc = 0x825C9900; continue 'dispatch;
	}
	// 825C98A8: 3B9D004C  addi r28, r29, 0x4c
	ctx.r[28].s64 = ctx.r[29].s64 + 76;
	// 825C98AC: 57FF063E  clrlwi r31, r31, 0x18
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 825C98B0: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825C98B4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825C98B8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825C98BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C98C0: 4BFFFD81  bl 0x825c9640
	ctx.lr = 0x825C98C4;
	sub_825C9640(ctx, base);
	// 825C98C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C98C8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C98CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825C98D0: 7F6A5030  slw r10, r27, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[27].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825C98D4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C98D8: 419A000C  beq cr6, 0x825c98e4
	if ctx.cr[6].eq {
	pc = 0x825C98E4; continue 'dispatch;
	}
	// 825C98DC: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 825C98E0: 48000008  b 0x825c98e8
	pc = 0x825C98E8; continue 'dispatch;
	// 825C98E4: 7D2A5078  andc r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 & !ctx.r[10].u64;
	// 825C98E8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825C98EC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 825C98F0: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C98F4: 4BFD71F5  bl 0x825a0ae8
	ctx.lr = 0x825C98F8;
	sub_825A0AE8(ctx, base);
	// 825C98F8: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 825C98FC: 4198FFB8  blt cr6, 0x825c98b4
	if ctx.cr[6].lt {
	pc = 0x825C98B4; continue 'dispatch;
	}
	// 825C9900: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825C9904: 48BDE8B0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9908 size=140
    let mut pc: u32 = 0x825C9908;
    'dispatch: loop {
        match pc {
            0x825C9908 => {
    //   block [0x825C9908..0x825C9994)
	// 825C9908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C990C: 48BDE861  bl 0x831a816c
	ctx.lr = 0x825C9910;
	sub_831A8130(ctx, base);
	// 825C9910: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C9914: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825C9918: 3BE3004C  addi r31, r3, 0x4c
	ctx.r[31].s64 = ctx.r[3].s64 + 76;
	// 825C991C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825C9920: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825C9924: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C9928: 4BFFFD19  bl 0x825c9640
	ctx.lr = 0x825C992C;
	sub_825C9640(ctx, base);
	// 825C992C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825C9930: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 825C9934: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825C9938: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825C993C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825C9940: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C9944: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C9948: 7FCB5830  slw r11, r30, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[30].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825C994C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C9950: 7D6B5038  and r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	// 825C9954: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825C9958: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825C995C: 697F0001  xori r31, r11, 1
	ctx.r[31].u64 = ctx.r[11].u64 ^ 1;
	// 825C9960: 4BFFFCE1  bl 0x825c9640
	ctx.lr = 0x825C9964;
	sub_825C9640(ctx, base);
	// 825C9964: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C9968: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C996C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C9970: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C9974: 7FCA5030  slw r10, r30, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[30].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825C9978: 4082000C  bne 0x825c9984
	if !ctx.cr[0].eq {
	pc = 0x825C9984; continue 'dispatch;
	}
	// 825C997C: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 825C9980: 48000008  b 0x825c9988
	pc = 0x825C9988; continue 'dispatch;
	// 825C9984: 7D2A5078  andc r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 & !ctx.r[10].u64;
	// 825C9988: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825C998C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825C9990: 48BDE82C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9998 size=80
    let mut pc: u32 = 0x825C9998;
    'dispatch: loop {
        match pc {
            0x825C9998 => {
    //   block [0x825C9998..0x825C99E8)
	// 825C9998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C999C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C99A0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C99A4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 825C99A8: 3883004C  addi r4, r3, 0x4c
	ctx.r[4].s64 = ctx.r[3].s64 + 76;
	// 825C99AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C99B0: 4BFFFC91  bl 0x825c9640
	ctx.lr = 0x825C99B4;
	sub_825C9640(ctx, base);
	// 825C99B4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C99B8: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C99BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825C99C0: 7D6B4830  slw r11, r11, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[11].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 825C99C4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C99C8: 7D6B5038  and r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	// 825C99CC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825C99D0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825C99D4: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 825C99D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825C99DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825C99E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825C99E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C99E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C99E8 size=144
    let mut pc: u32 = 0x825C99E8;
    'dispatch: loop {
        match pc {
            0x825C99E8 => {
    //   block [0x825C99E8..0x825C9A78)
	// 825C99E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C99EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C99F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825C99F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825C99F8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C99FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825C9A00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C9A04: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825C9A08: 48010389  bl 0x825d9d90
	ctx.lr = 0x825C9A0C;
	sub_825D9D90(ctx, base);
	// 825C9A0C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825C9A10: 419A003C  beq cr6, 0x825c9a4c
	if ctx.cr[6].eq {
	pc = 0x825C9A4C; continue 'dispatch;
	}
	// 825C9A14: 3D60827F  lis r11, -0x7d81
	ctx.r[11].s64 = -2105606144;
	// 825C9A18: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 825C9A1C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825C9A20: 396BAFC0  addi r11, r11, -0x5040
	ctx.r[11].s64 = ctx.r[11].s64 + -20544;
	// 825C9A24: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825C9A28: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825C9A2C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825C9A30: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825C9A34: 4BFFFC7D  bl 0x825c96b0
	ctx.lr = 0x825C9A38;
	sub_825C96B0(ctx, base);
	// 825C9A38: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825C9A3C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825C9A40: 388B5C34  addi r4, r11, 0x5c34
	ctx.r[4].s64 = ctx.r[11].s64 + 23604;
	// 825C9A44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C9A48: 48010499  bl 0x825d9ee0
	ctx.lr = 0x825C9A4C;
	sub_825D9EE0(ctx, base);
	// 825C9A4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825C9A50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C9A54: 480103AD  bl 0x825d9e00
	ctx.lr = 0x825C9A58;
	sub_825D9E00(ctx, base);
	// 825C9A58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C9A5C: 4801036D  bl 0x825d9dc8
	ctx.lr = 0x825C9A60;
	sub_825D9DC8(ctx, base);
	// 825C9A60: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825C9A64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825C9A68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825C9A6C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825C9A70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825C9A74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9A78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9A78 size=52
    let mut pc: u32 = 0x825C9A78;
    'dispatch: loop {
        match pc {
            0x825C9A78 => {
    //   block [0x825C9A78..0x825C9AAC)
	// 825C9A78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C9A7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C9A80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825C9A84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C9A88: 38630040  addi r3, r3, 0x40
	ctx.r[3].s64 = ctx.r[3].s64 + 64;
	// 825C9A8C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825C9A90: 4BF305F1  bl 0x824fa080
	ctx.lr = 0x825C9A94;
	sub_824FA080(ctx, base);
	// 825C9A94: 93E30000  stw r31, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825C9A98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825C9A9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825C9AA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825C9AA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825C9AA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9AB0 size=144
    let mut pc: u32 = 0x825C9AB0;
    'dispatch: loop {
        match pc {
            0x825C9AB0 => {
    //   block [0x825C9AB0..0x825C9B40)
	// 825C9AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C9AB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C9AB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825C9ABC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825C9AC0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C9AC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825C9AC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C9ACC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825C9AD0: 480102C1  bl 0x825d9d90
	ctx.lr = 0x825C9AD4;
	sub_825D9D90(ctx, base);
	// 825C9AD4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825C9AD8: 419A003C  beq cr6, 0x825c9b14
	if ctx.cr[6].eq {
	pc = 0x825C9B14; continue 'dispatch;
	}
	// 825C9ADC: 3D60827F  lis r11, -0x7d81
	ctx.r[11].s64 = -2105606144;
	// 825C9AE0: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 825C9AE4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825C9AE8: 396BAFC0  addi r11, r11, -0x5040
	ctx.r[11].s64 = ctx.r[11].s64 + -20544;
	// 825C9AEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825C9AF0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825C9AF4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825C9AF8: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825C9AFC: 4BFFFC35  bl 0x825c9730
	ctx.lr = 0x825C9B00;
	sub_825C9730(ctx, base);
	// 825C9B00: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825C9B04: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825C9B08: 388B57E8  addi r4, r11, 0x57e8
	ctx.r[4].s64 = ctx.r[11].s64 + 22504;
	// 825C9B0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C9B10: 480103D1  bl 0x825d9ee0
	ctx.lr = 0x825C9B14;
	sub_825D9EE0(ctx, base);
	// 825C9B14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825C9B18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C9B1C: 480102E5  bl 0x825d9e00
	ctx.lr = 0x825C9B20;
	sub_825D9E00(ctx, base);
	// 825C9B20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C9B24: 480102A5  bl 0x825d9dc8
	ctx.lr = 0x825C9B28;
	sub_825D9DC8(ctx, base);
	// 825C9B28: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825C9B2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825C9B30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825C9B34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825C9B38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825C9B3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9B40 size=180
    let mut pc: u32 = 0x825C9B40;
    'dispatch: loop {
        match pc {
            0x825C9B40 => {
    //   block [0x825C9B40..0x825C9BF4)
	// 825C9B40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C9B44: 48BDE625  bl 0x831a8168
	ctx.lr = 0x825C9B48;
	sub_831A8130(ctx, base);
	// 825C9B48: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C9B4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825C9B50: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825C9B54: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825C9B58: 48010239  bl 0x825d9d90
	ctx.lr = 0x825C9B5C;
	sub_825D9D90(ctx, base);
	// 825C9B5C: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 825C9B60: 83FE0018  lwz r31, 0x18(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825C9B64: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825C9B68: 419A0070  beq cr6, 0x825c9bd8
	if ctx.cr[6].eq {
	pc = 0x825C9BD8; continue 'dispatch;
	}
	// 825C9B6C: 3D60825C  lis r11, -0x7da4
	ctx.r[11].s64 = -2107899904;
	// 825C9B70: 396BF350  addi r11, r11, -0xcb0
	ctx.r[11].s64 = ctx.r[11].s64 + -3248;
	// 825C9B74: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825C9B78: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C9B7C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825C9B80: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825C9B84: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 825C9B88: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825C9B8C: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825C9B90: 4BFF66A1  bl 0x825c0230
	ctx.lr = 0x825C9B94;
	sub_825C0230(ctx, base);
	// 825C9B94: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C9B98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C9B9C: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 825C9BA0: 4882A061  bl 0x82df3c00
	ctx.lr = 0x825C9BA4;
	sub_82DF3C00(ctx, base);
	// 825C9BA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C9BA8: 3B810070  addi r28, r1, 0x70
	ctx.r[28].s64 = ctx.r[1].s64 + 112;
	// 825C9BAC: 48829605  bl 0x82df31b0
	ctx.lr = 0x825C9BB0;
	sub_82DF31B0(ctx, base);
	// 825C9BB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825C9BB4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825C9BB8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825C9BBC: 48010325  bl 0x825d9ee0
	ctx.lr = 0x825C9BC0;
	sub_825D9EE0(ctx, base);
	// 825C9BC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C9BC4: 48829865  bl 0x82df3428
	ctx.lr = 0x825C9BC8;
	sub_82DF3428(ctx, base);
	// 825C9BC8: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 825C9BCC: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 825C9BD0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825C9BD4: 409AFFA4  bne cr6, 0x825c9b78
	if !ctx.cr[6].eq {
	pc = 0x825C9B78; continue 'dispatch;
	}
	// 825C9BD8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825C9BDC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825C9BE0: 48010221  bl 0x825d9e00
	ctx.lr = 0x825C9BE4;
	sub_825D9E00(ctx, base);
	// 825C9BE4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825C9BE8: 480101E1  bl 0x825d9dc8
	ctx.lr = 0x825C9BEC;
	sub_825D9DC8(ctx, base);
	// 825C9BEC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825C9BF0: 48BDE5C8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9BF8 size=88
    let mut pc: u32 = 0x825C9BF8;
    'dispatch: loop {
        match pc {
            0x825C9BF8 => {
    //   block [0x825C9BF8..0x825C9C50)
	// 825C9BF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C9BFC: 48BDE571  bl 0x831a816c
	ctx.lr = 0x825C9C00;
	sub_831A8130(ctx, base);
	// 825C9C00: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C9C04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C9C08: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825C9C0C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825C9C10: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C9C14: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C9C18: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825C9C1C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825C9C20: 419A000C  beq cr6, 0x825c9c2c
	if ctx.cr[6].eq {
	pc = 0x825C9C2C; continue 'dispatch;
	}
	// 825C9C24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C9C28: 4BEC7411  bl 0x82491038
	ctx.lr = 0x825C9C2C;
	sub_82491038(ctx, base);
	// 825C9C2C: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 825C9C30: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825C9C34: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 825C9C38: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825C9C3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825C9C40: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825C9C44: 4BEC7F15  bl 0x82491b58
	ctx.lr = 0x825C9C48;
	sub_82491B58(ctx, base);
	// 825C9C48: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825C9C4C: 48BDE570  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9C50 size=128
    let mut pc: u32 = 0x825C9C50;
    'dispatch: loop {
        match pc {
            0x825C9C50 => {
    //   block [0x825C9C50..0x825C9CD0)
	// 825C9C50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C9C54: 48BDE511  bl 0x831a8164
	ctx.lr = 0x825C9C58;
	sub_831A8130(ctx, base);
	// 825C9C58: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C9C5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C9C60: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825C9C64: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825C9C68: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 825C9C6C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825C9C70: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C9C74: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C9C78: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825C9C7C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825C9C80: 419A000C  beq cr6, 0x825c9c8c
	if ctx.cr[6].eq {
	pc = 0x825C9C8C; continue 'dispatch;
	}
	// 825C9C84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C9C88: 4BEC73B1  bl 0x82491038
	ctx.lr = 0x825C9C8C;
	sub_82491038(ctx, base);
	// 825C9C8C: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 825C9C90: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825C9C94: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 825C9C98: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825C9C9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825C9CA0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825C9CA4: 4BEC7EB5  bl 0x82491b58
	ctx.lr = 0x825C9CA8;
	sub_82491B58(ctx, base);
	// 825C9CA8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C9CAC: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 825C9CB0: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825C9CB4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825C9CB8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825C9CBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C9CC0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825C9CC4: 4BEC81C5  bl 0x82491e88
	ctx.lr = 0x825C9CC8;
	sub_82491E88(ctx, base);
	// 825C9CC8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825C9CCC: 48BDE4E8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9CD0 size=484
    let mut pc: u32 = 0x825C9CD0;
    'dispatch: loop {
        match pc {
            0x825C9CD0 => {
    //   block [0x825C9CD0..0x825C9EB4)
	// 825C9CD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C9CD4: 48BDE495  bl 0x831a8168
	ctx.lr = 0x825C9CD8;
	sub_831A8130(ctx, base);
	// 825C9CD8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C9CDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C9CE0: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 825C9CE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C9CE8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C9CEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C9CF0: 4E800421  bctrl
	ctx.lr = 0x825C9CF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C9CF4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C9CF8: 4BFD6DF1  bl 0x825a0ae8
	ctx.lr = 0x825C9CFC;
	sub_825A0AE8(ctx, base);
	// 825C9CFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825C9D00: 40820018  bne 0x825c9d18
	if !ctx.cr[0].eq {
	pc = 0x825C9D18; continue 'dispatch;
	}
	// 825C9D04: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825C9D08: 939F0038  stw r28, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[28].u32 ) };
	// 825C9D0C: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 825C9D10: 939F003C  stw r28, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[28].u32 ) };
	// 825C9D14: 4800018C  b 0x825c9ea0
	pc = 0x825C9EA0; continue 'dispatch;
	// 825C9D18: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 825C9D1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C9D20: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 825C9D24: 48829EDD  bl 0x82df3c00
	ctx.lr = 0x825C9D28;
	sub_82DF3C00(ctx, base);
	// 825C9D28: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C9D2C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825C9D30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825C9D34: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825C9D38: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C9D3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C9D40: 4E800421  bctrl
	ctx.lr = 0x825C9D44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C9D44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C9D48: 488296E1  bl 0x82df3428
	ctx.lr = 0x825C9D4C;
	sub_82DF3428(ctx, base);
	// 825C9D4C: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 825C9D50: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825C9D54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C9D58: 409A0118  bne cr6, 0x825c9e70
	if !ctx.cr[6].eq {
	pc = 0x825C9E70; continue 'dispatch;
	}
	// 825C9D5C: 83BF003C  lwz r29, 0x3c(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 825C9D60: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 825C9D64: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825C9D68: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 825C9D6C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825C9D70: 419A0024  beq cr6, 0x825c9d94
	if ctx.cr[6].eq {
	pc = 0x825C9D94; continue 'dispatch;
	}
	// 825C9D74: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825C9D78: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825C9D7C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825C9D80: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825C9D84: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825C9D88: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825C9D8C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825C9D90: 4082FFE8  bne 0x825c9d78
	if !ctx.cr[0].eq {
	pc = 0x825C9D78; continue 'dispatch;
	}
	// 825C9D94: 3BDF0014  addi r30, r31, 0x14
	ctx.r[30].s64 = ctx.r[31].s64 + 20;
	// 825C9D98: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825C9D9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825C9DA0: 485E9369  bl 0x82bb3108
	ctx.lr = 0x825C9DA4;
	sub_82BB3108(ctx, base);
	// 825C9DA4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825C9DA8: 419A000C  beq cr6, 0x825c9db4
	if ctx.cr[6].eq {
	pc = 0x825C9DB4; continue 'dispatch;
	}
	// 825C9DAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C9DB0: 4BCF6AE1  bl 0x822c0890
	ctx.lr = 0x825C9DB4;
	sub_822C0890(ctx, base);
	// 825C9DB4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C9DB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C9DBC: 409A000C  bne cr6, 0x825c9dc8
	if !ctx.cr[6].eq {
	pc = 0x825C9DC8; continue 'dispatch;
	}
	// 825C9DC0: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 825C9DC4: 48000010  b 0x825c9dd4
	pc = 0x825C9DD4; continue 'dispatch;
	// 825C9DC8: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C9DCC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825C9DD0: 7D7E1E70  srawi r30, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825C9DD4: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 825C9DD8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825C9DDC: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 825C9DE0: 48829E21  bl 0x82df3c00
	ctx.lr = 0x825C9DE4;
	sub_82DF3C00(ctx, base);
	// 825C9DE4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825C9DE8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825C9DEC: 48829E15  bl 0x82df3c00
	ctx.lr = 0x825C9DF0;
	sub_82DF3C00(ctx, base);
	// 825C9DF0: 397EFFFF  addi r11, r30, -1
	ctx.r[11].s64 = ctx.r[30].s64 + -1;
	// 825C9DF4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825C9DF8: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825C9DFC: 4882962D  bl 0x82df3428
	ctx.lr = 0x825C9E00;
	sub_82DF3428(ctx, base);
	// 825C9E00: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825C9E04: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825C9E08: 48829DF9  bl 0x82df3c00
	ctx.lr = 0x825C9E0C;
	sub_82DF3C00(ctx, base);
	// 825C9E0C: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825C9E10: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825C9E14: 389F0024  addi r4, r31, 0x24
	ctx.r[4].s64 = ctx.r[31].s64 + 36;
	// 825C9E18: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825C9E1C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825C9E20: 485B4C51  bl 0x82b7ea70
	ctx.lr = 0x825C9E24;
	sub_82B7EA70(ctx, base);
	// 825C9E24: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825C9E28: 48829601  bl 0x82df3428
	ctx.lr = 0x825C9E2C;
	sub_82DF3428(ctx, base);
	// 825C9E2C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825C9E30: 488295F9  bl 0x82df3428
	ctx.lr = 0x825C9E34;
	sub_82DF3428(ctx, base);
	// 825C9E34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825C9E38: 83DF0038  lwz r30, 0x38(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 825C9E3C: 389E000C  addi r4, r30, 0xc
	ctx.r[4].s64 = ctx.r[30].s64 + 12;
	// 825C9E40: 48829DC1  bl 0x82df3c00
	ctx.lr = 0x825C9E44;
	sub_82DF3C00(ctx, base);
	// 825C9E44: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C9E48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825C9E4C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C9E50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C9E54: 4E800421  bctrl
	ctx.lr = 0x825C9E58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C9E58: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825C9E5C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825C9E60: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 825C9E64: 4BCF619D  bl 0x822c0000
	ctx.lr = 0x825C9E68;
	sub_822C0000(ctx, base);
	// 825C9E68: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825C9E6C: 488295BD  bl 0x82df3428
	ctx.lr = 0x825C9E70;
	sub_82DF3428(ctx, base);
	// 825C9E70: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 825C9E74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C9E78: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825C9E7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825C9E80: 4E800421  bctrl
	ctx.lr = 0x825C9E84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825C9E84: 939F0038  stw r28, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[28].u32 ) };
	// 825C9E88: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 825C9E8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825C9E90: 939F003C  stw r28, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[28].u32 ) };
	// 825C9E94: 419A0008  beq cr6, 0x825c9e9c
	if ctx.cr[6].eq {
	pc = 0x825C9E9C; continue 'dispatch;
	}
	// 825C9E98: 4BCF69F9  bl 0x822c0890
	ctx.lr = 0x825C9E9C;
	sub_822C0890(ctx, base);
	// 825C9E9C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825C9EA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825C9EA4: 419A0008  beq cr6, 0x825c9eac
	if ctx.cr[6].eq {
	pc = 0x825C9EAC; continue 'dispatch;
	}
	// 825C9EA8: 4BCF69E9  bl 0x822c0890
	ctx.lr = 0x825C9EAC;
	sub_822C0890(ctx, base);
	// 825C9EAC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825C9EB0: 48BDE308  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9EB8 size=96
    let mut pc: u32 = 0x825C9EB8;
    'dispatch: loop {
        match pc {
            0x825C9EB8 => {
    //   block [0x825C9EB8..0x825C9F18)
	// 825C9EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C9EBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C9EC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825C9EC4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C9EC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C9ECC: 4BFDB705  bl 0x825a55d0
	ctx.lr = 0x825C9ED0;
	sub_825A55D0(ctx, base);
	// 825C9ED0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C9ED4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C9ED8: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 825C9EDC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C9EE0: 556B077D  rlwinm. r11, r11, 0, 0x1d, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C9EE4: 40820018  bne 0x825c9efc
	if !ctx.cr[0].eq {
	pc = 0x825C9EFC; continue 'dispatch;
	}
	// 825C9EE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C9EEC: 4BDE73ED  bl 0x823b12d8
	ctx.lr = 0x825C9EF0;
	sub_823B12D8(ctx, base);
	// 825C9EF0: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 825C9EF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825C9EF8: 419A0008  beq cr6, 0x825c9f00
	if ctx.cr[6].eq {
	pc = 0x825C9F00; continue 'dispatch;
	}
	// 825C9EFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825C9F00: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825C9F04: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825C9F08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825C9F0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825C9F10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825C9F14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9F18 size=88
    let mut pc: u32 = 0x825C9F18;
    'dispatch: loop {
        match pc {
            0x825C9F18 => {
    //   block [0x825C9F18..0x825C9F70)
	// 825C9F18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C9F1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C9F20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825C9F24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C9F28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C9F2C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825C9F30: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825C9F34: 392BD634  addi r9, r11, -0x29cc
	ctx.r[9].s64 = ctx.r[11].s64 + -10700;
	// 825C9F38: 397F004C  addi r11, r31, 0x4c
	ctx.r[11].s64 = ctx.r[31].s64 + 76;
	// 825C9F3C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825C9F40: 915F004C  stw r10, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[10].u32 ) };
	// 825C9F44: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 825C9F48: 4BEA00B9  bl 0x8246a000
	ctx.lr = 0x825C9F4C;
	sub_8246A000(ctx, base);
	// 825C9F4C: 387F0040  addi r3, r31, 0x40
	ctx.r[3].s64 = ctx.r[31].s64 + 64;
	// 825C9F50: 481E3241  bl 0x827ad190
	ctx.lr = 0x825C9F54;
	sub_827AD190(ctx, base);
	// 825C9F54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C9F58: 4BFFEB49  bl 0x825c8aa0
	ctx.lr = 0x825C9F5C;
	sub_825C8AA0(ctx, base);
	// 825C9F5C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825C9F60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825C9F64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825C9F68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825C9F6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9F70 size=76
    let mut pc: u32 = 0x825C9F70;
    'dispatch: loop {
        match pc {
            0x825C9F70 => {
    //   block [0x825C9F70..0x825C9FBC)
	// 825C9F70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C9F74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C9F78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825C9F7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825C9F80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C9F84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C9F88: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825C9F8C: 4BFFFF8D  bl 0x825c9f18
	ctx.lr = 0x825C9F90;
	sub_825C9F18(ctx, base);
	// 825C9F90: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C9F94: 4182000C  beq 0x825c9fa0
	if ctx.cr[0].eq {
	pc = 0x825C9FA0; continue 'dispatch;
	}
	// 825C9F98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C9F9C: 4BCF62CD  bl 0x822c0268
	ctx.lr = 0x825C9FA0;
	sub_822C0268(ctx, base);
	// 825C9FA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C9FA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825C9FA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825C9FAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825C9FB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825C9FB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825C9FB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C9FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C9FC0 size=108
    let mut pc: u32 = 0x825C9FC0;
    'dispatch: loop {
        match pc {
            0x825C9FC0 => {
    //   block [0x825C9FC0..0x825CA02C)
	// 825C9FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C9FC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C9FC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825C9FCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825C9FD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C9FD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C9FD8: 4BFF03C9  bl 0x825ba3a0
	ctx.lr = 0x825C9FDC;
	sub_825BA3A0(ctx, base);
	// 825C9FDC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825C9FE0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825C9FE4: 396BD634  addi r11, r11, -0x29cc
	ctx.r[11].s64 = ctx.r[11].s64 + -10700;
	// 825C9FE8: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 825C9FEC: 387F0040  addi r3, r31, 0x40
	ctx.r[3].s64 = ctx.r[31].s64 + 64;
	// 825C9FF0: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 825C9FF4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825C9FF8: 4BD3F431  bl 0x82309428
	ctx.lr = 0x825C9FFC;
	sub_82309428(ctx, base);
	// 825C9FFC: 93DF004C  stw r30, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 825CA000: 93DF0054  stw r30, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825CA004: 397F004C  addi r11, r31, 0x4c
	ctx.r[11].s64 = ctx.r[31].s64 + 76;
	// 825CA008: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 825CA00C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CA010: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 825CA014: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CA018: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CA01C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CA020: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CA024: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CA028: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CA030 size=84
    let mut pc: u32 = 0x825CA030;
    'dispatch: loop {
        match pc {
            0x825CA030 => {
    //   block [0x825CA030..0x825CA084)
	// 825CA030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CA034: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CA038: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CA03C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CA040: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CA044: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CA048: 3BFE004C  addi r31, r30, 0x4c
	ctx.r[31].s64 = ctx.r[30].s64 + 76;
	// 825CA04C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CA050: 4BFFFBA9  bl 0x825c9bf8
	ctx.lr = 0x825CA054;
	sub_825C9BF8(ctx, base);
	// 825CA054: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CA058: 4BFD6A91  bl 0x825a0ae8
	ctx.lr = 0x825CA05C;
	sub_825A0AE8(ctx, base);
	// 825CA05C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CA060: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825CA064: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CA068: 4BFFFBE9  bl 0x825c9c50
	ctx.lr = 0x825CA06C;
	sub_825C9C50(ctx, base);
	// 825CA06C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CA070: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CA074: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CA078: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CA07C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CA080: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CA088 size=444
    let mut pc: u32 = 0x825CA088;
    'dispatch: loop {
        match pc {
            0x825CA088 => {
    //   block [0x825CA088..0x825CA244)
	// 825CA088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CA08C: 48BDE0D5  bl 0x831a8160
	ctx.lr = 0x825CA090;
	sub_831A8130(ctx, base);
	// 825CA090: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CA094: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CA098: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825CA09C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 825CA0A0: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825CA0A4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825CA0A8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA0AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA0B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CA0B4: 4E800421  bctrl
	ctx.lr = 0x825CA0B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CA0B8: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825CA0BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825CA0C0: 419A003C  beq cr6, 0x825ca0fc
	if ctx.cr[6].eq {
	pc = 0x825CA0FC; continue 'dispatch;
	}
	// 825CA0C4: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825CA0C8: 915A0000  stw r10, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825CA0CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CA0D0: 917A0004  stw r11, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825CA0D4: 419A0164  beq cr6, 0x825ca238
	if ctx.cr[6].eq {
	pc = 0x825CA238; continue 'dispatch;
	}
	// 825CA0D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825CA0DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825CA0E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CA0E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825CA0E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825CA0EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825CA0F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CA0F4: 4082FFE8  bne 0x825ca0dc
	if !ctx.cr[0].eq {
	pc = 0x825CA0DC; continue 'dispatch;
	}
	// 825CA0F8: 48000130  b 0x825ca228
	pc = 0x825CA228; continue 'dispatch;
	// 825CA0FC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CA100: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825CA104: 388BD690  addi r4, r11, -0x2970
	ctx.r[4].s64 = ctx.r[11].s64 + -10608;
	// 825CA108: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825CA10C: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 825CA110: 38A00247  li r5, 0x247
	ctx.r[5].s64 = 583;
	// 825CA114: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 825CA118: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 825CA11C: 4BCF62BD  bl 0x822c03d8
	ctx.lr = 0x825CA120;
	sub_822C03D8(ctx, base);
	// 825CA120: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825CA124: 41820034  beq 0x825ca158
	if ctx.cr[0].eq {
	pc = 0x825CA158; continue 'dispatch;
	}
	// 825CA128: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825CA12C: 80DE0030  lwz r6, 0x30(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 825CA130: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825CA134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CA138: 4BFF0269  bl 0x825ba3a0
	ctx.lr = 0x825CA13C;
	sub_825BA3A0(ctx, base);
	// 825CA13C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CA140: 93BF0038  stw r29, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[29].u32 ) };
	// 825CA144: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CA148: 396BD55C  addi r11, r11, -0x2aa4
	ctx.r[11].s64 = ctx.r[11].s64 + -10916;
	// 825CA14C: 93BF003C  stw r29, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[29].u32 ) };
	// 825CA150: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CA154: 48000008  b 0x825ca15c
	pc = 0x825CA15C; continue 'dispatch;
	// 825CA158: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825CA15C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825CA160: 4BFFE891  bl 0x825c89f0
	ctx.lr = 0x825CA164;
	sub_825C89F0(ctx, base);
	// 825CA164: 3BFE0014  addi r31, r30, 0x14
	ctx.r[31].s64 = ctx.r[30].s64 + 20;
	// 825CA168: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825CA16C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CA170: 485E8F99  bl 0x82bb3108
	ctx.lr = 0x825CA174;
	sub_82BB3108(ctx, base);
	// 825CA174: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825CA178: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CA17C: 419A0010  beq cr6, 0x825ca18c
	if ctx.cr[6].eq {
	pc = 0x825CA18C; continue 'dispatch;
	}
	// 825CA180: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CA184: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825CA188: 7D7D1E70  srawi r29, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825CA18C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825CA190: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CA194: 48829A6D  bl 0x82df3c00
	ctx.lr = 0x825CA198;
	sub_82DF3C00(ctx, base);
	// 825CA198: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CA19C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825CA1A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CA1A4: 48829A5D  bl 0x82df3c00
	ctx.lr = 0x825CA1A8;
	sub_82DF3C00(ctx, base);
	// 825CA1A8: 397DFFFF  addi r11, r29, -1
	ctx.r[11].s64 = ctx.r[29].s64 + -1;
	// 825CA1AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CA1B0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825CA1B4: 48829275  bl 0x82df3428
	ctx.lr = 0x825CA1B8;
	sub_82DF3428(ctx, base);
	// 825CA1B8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825CA1BC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825CA1C0: 48829A41  bl 0x82df3c00
	ctx.lr = 0x825CA1C4;
	sub_82DF3C00(ctx, base);
	// 825CA1C4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825CA1C8: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825CA1CC: 389E0024  addi r4, r30, 0x24
	ctx.r[4].s64 = ctx.r[30].s64 + 36;
	// 825CA1D0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825CA1D4: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825CA1D8: 485B4899  bl 0x82b7ea70
	ctx.lr = 0x825CA1DC;
	sub_82B7EA70(ctx, base);
	// 825CA1DC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825CA1E0: 48829249  bl 0x82df3428
	ctx.lr = 0x825CA1E4;
	sub_82DF3428(ctx, base);
	// 825CA1E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825CA1E8: 48829241  bl 0x82df3428
	ctx.lr = 0x825CA1EC;
	sub_82DF3428(ctx, base);
	// 825CA1EC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825CA1F0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825CA1F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CA1F8: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CA1FC: 907A0004  stw r3, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 825CA200: 419A0028  beq cr6, 0x825ca228
	if ctx.cr[6].eq {
	pc = 0x825CA228; continue 'dispatch;
	}
	// 825CA204: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 825CA208: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825CA20C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CA210: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825CA214: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825CA218: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825CA21C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CA220: 4082FFE8  bne 0x825ca208
	if !ctx.cr[0].eq {
	pc = 0x825CA208; continue 'dispatch;
	}
	// 825CA224: 4BCF666D  bl 0x822c0890
	ctx.lr = 0x825CA228;
	sub_822C0890(ctx, base);
	// 825CA228: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825CA22C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CA230: 419A0008  beq cr6, 0x825ca238
	if ctx.cr[6].eq {
	pc = 0x825CA238; continue 'dispatch;
	}
	// 825CA234: 4BCF665D  bl 0x822c0890
	ctx.lr = 0x825CA238;
	sub_822C0890(ctx, base);
	// 825CA238: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825CA23C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825CA240: 48BDDF70  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CA248 size=188
    let mut pc: u32 = 0x825CA248;
    'dispatch: loop {
        match pc {
            0x825CA248 => {
    //   block [0x825CA248..0x825CA304)
	// 825CA248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CA24C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CA250: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CA254: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CA258: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CA25C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825CA260: 4BFDB859  bl 0x825a5ab8
	ctx.lr = 0x825CA264;
	sub_825A5AB8(ctx, base);
	// 825CA264: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825CA268: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA26C: 4BFDAE6D  bl 0x825a50d8
	ctx.lr = 0x825CA270;
	sub_825A50D8(ctx, base);
	// 825CA270: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA274: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CA278: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 825CA27C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CA280: 556B077D  rlwinm. r11, r11, 0, 0x1d, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CA284: 40820018  bne 0x825ca29c
	if !ctx.cr[0].eq {
	pc = 0x825CA29C; continue 'dispatch;
	}
	// 825CA288: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825CA28C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825CA290: 4BFFFC29  bl 0x825c9eb8
	ctx.lr = 0x825CA294;
	sub_825C9EB8(ctx, base);
	// 825CA294: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CA298: 40820048  bne 0x825ca2e0
	if !ctx.cr[0].eq {
	pc = 0x825CA2E0; continue 'dispatch;
	}
	// 825CA29C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825CA2A0: 3D008326  lis r8, -0x7cda
	ctx.r[8].s64 = -2094661632;
	// 825CA2A4: 396B94B4  addi r11, r11, -0x6b4c
	ctx.r[11].s64 = ctx.r[11].s64 + -27468;
	// 825CA2A8: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 825CA2AC: 3D208327  lis r9, -0x7cd9
	ctx.r[9].s64 = -2094596096;
	// 825CA2B0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825CA2B4: 394AC284  addi r10, r10, -0x3d7c
	ctx.r[10].s64 = ctx.r[10].s64 + -15740;
	// 825CA2B8: 39293CA4  addi r9, r9, 0x3ca4
	ctx.r[9].s64 = ctx.r[9].s64 + 15524;
	// 825CA2BC: 396886A8  addi r11, r8, -0x7958
	ctx.r[11].s64 = ctx.r[8].s64 + -31064;
	// 825CA2C0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825CA2C4: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 825CA2C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825CA2CC: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825CA2D0: 4BCF5D31  bl 0x822c0000
	ctx.lr = 0x825CA2D4;
	sub_822C0000(ctx, base);
	// 825CA2D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825CA2D8: 396B0818  addi r11, r11, 0x818
	ctx.r[11].s64 = ctx.r[11].s64 + 2072;
	// 825CA2DC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825CA2E0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825CA2E4: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CA2E8: 4BDDDAE9  bl 0x823a7dd0
	ctx.lr = 0x825CA2EC;
	sub_823A7DD0(ctx, base);
	// 825CA2EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CA2F0: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 825CA2F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CA2F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CA2FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CA300: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CA308 size=372
    let mut pc: u32 = 0x825CA308;
    'dispatch: loop {
        match pc {
            0x825CA308 => {
    //   block [0x825CA308..0x825CA47C)
	// 825CA308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CA30C: 48BDDE59  bl 0x831a8164
	ctx.lr = 0x825CA310;
	sub_831A8130(ctx, base);
	// 825CA310: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CA314: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825CA318: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825CA31C: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CA320: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA324: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CA328: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CA32C: 4E800421  bctrl
	ctx.lr = 0x825CA330;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CA330: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825CA334: 4800FA5D  bl 0x825d9d90
	ctx.lr = 0x825CA338;
	sub_825D9D90(ctx, base);
	// 825CA338: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825CA33C: 419A0124  beq cr6, 0x825ca460
	if ctx.cr[6].eq {
	pc = 0x825CA460; continue 'dispatch;
	}
	// 825CA340: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CA344: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CA348: 419A0118  beq cr6, 0x825ca460
	if ctx.cr[6].eq {
	pc = 0x825CA460; continue 'dispatch;
	}
	// 825CA34C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825CA350: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825CA354: 4800F64D  bl 0x825d99a0
	ctx.lr = 0x825CA358;
	sub_825D99A0(ctx, base);
	// 825CA358: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825CA35C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825CA360: 419A0090  beq cr6, 0x825ca3f0
	if ctx.cr[6].eq {
	pc = 0x825CA3F0; continue 'dispatch;
	}
	// 825CA364: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CA368: 3BDD0040  addi r30, r29, 0x40
	ctx.r[30].s64 = ctx.r[29].s64 + 64;
	// 825CA36C: 3BEBB8AC  addi r31, r11, -0x4754
	ctx.r[31].s64 = ctx.r[11].s64 + -18260;
	// 825CA370: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CA374: 4800F1F5  bl 0x825d9568
	ctx.lr = 0x825CA378;
	sub_825D9568(ctx, base);
	// 825CA378: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CA37C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CA380: 4BF2FD01  bl 0x824fa080
	ctx.lr = 0x825CA384;
	sub_824FA080(ctx, base);
	// 825CA384: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825CA388: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825CA38C: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825CA390: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825CA394: 4800F0BD  bl 0x825d9450
	ctx.lr = 0x825CA398;
	sub_825D9450(ctx, base);
	// 825CA398: 4BFDB9F1  bl 0x825a5d88
	ctx.lr = 0x825CA39C;
	sub_825A5D88(ctx, base);
	// 825CA39C: 907B0000  stw r3, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 825CA3A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CA3A4: 48829085  bl 0x82df3428
	ctx.lr = 0x825CA3A8;
	sub_82DF3428(ctx, base);
	// 825CA3A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825CA3AC: 4882907D  bl 0x82df3428
	ctx.lr = 0x825CA3B0;
	sub_82DF3428(ctx, base);
	// 825CA3B0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825CA3B4: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825CA3B8: 4800F701  bl 0x825d9ab8
	ctx.lr = 0x825CA3BC;
	sub_825D9AB8(ctx, base);
	// 825CA3BC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825CA3C0: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825CA3C4: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 825CA3C8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA3CC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825CA3D0: 4BCFA091  bl 0x822c4460
	ctx.lr = 0x825CA3D4;
	sub_822C4460(ctx, base);
	// 825CA3D4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825CA3D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CA3DC: 419A0008  beq cr6, 0x825ca3e4
	if ctx.cr[6].eq {
	pc = 0x825CA3E4; continue 'dispatch;
	}
	// 825CA3E0: 4BCF64B1  bl 0x822c0890
	ctx.lr = 0x825CA3E4;
	sub_822C0890(ctx, base);
	// 825CA3E4: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825CA3E8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825CA3EC: 409AFF84  bne cr6, 0x825ca370
	if !ctx.cr[6].eq {
	pc = 0x825CA370; continue 'dispatch;
	}
	// 825CA3F0: 817D004C  lwz r11, 0x4c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 825CA3F4: 3BDD004C  addi r30, r29, 0x4c
	ctx.r[30].s64 = ctx.r[29].s64 + 76;
	// 825CA3F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825CA3FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CA400: 40990050  ble cr6, 0x825ca450
	if !ctx.cr[6].gt {
	pc = 0x825CA450; continue 'dispatch;
	}
	// 825CA404: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825CA408: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CA40C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825CA410: 4BFFF231  bl 0x825c9640
	ctx.lr = 0x825CA414;
	sub_825C9640(ctx, base);
	// 825CA414: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA418: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CA41C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825CA420: 7D6B4830  slw r11, r11, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[11].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 825CA424: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA428: 7D6B5039  and. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CA42C: 41820014  beq 0x825ca440
	if ctx.cr[0].eq {
	pc = 0x825CA440; continue 'dispatch;
	}
	// 825CA430: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825CA434: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CA438: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825CA43C: 4BFD70FD  bl 0x825a1538
	ctx.lr = 0x825CA440;
	sub_825A1538(ctx, base);
	// 825CA440: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA444: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825CA448: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CA44C: 4198FFB8  blt cr6, 0x825ca404
	if ctx.cr[6].lt {
	pc = 0x825CA404; continue 'dispatch;
	}
	// 825CA450: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825CA454: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CA458: 419A0008  beq cr6, 0x825ca460
	if ctx.cr[6].eq {
	pc = 0x825CA460; continue 'dispatch;
	}
	// 825CA45C: 4BCF6435  bl 0x822c0890
	ctx.lr = 0x825CA460;
	sub_822C0890(ctx, base);
	// 825CA460: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825CA464: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825CA468: 4800F999  bl 0x825d9e00
	ctx.lr = 0x825CA46C;
	sub_825D9E00(ctx, base);
	// 825CA46C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825CA470: 4800F959  bl 0x825d9dc8
	ctx.lr = 0x825CA474;
	sub_825D9DC8(ctx, base);
	// 825CA474: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825CA478: 48BDDD3C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CA480 size=124
    let mut pc: u32 = 0x825CA480;
    'dispatch: loop {
        match pc {
            0x825CA480 => {
    //   block [0x825CA480..0x825CA4FC)
	// 825CA480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CA484: 48BDDCE5  bl 0x831a8168
	ctx.lr = 0x825CA488;
	sub_831A8130(ctx, base);
	// 825CA488: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CA48C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CA490: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 825CA494: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825CA498: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CA49C: 4BFD664D  bl 0x825a0ae8
	ctx.lr = 0x825CA4A0;
	sub_825A0AE8(ctx, base);
	// 825CA4A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825CA4A4: 41820050  beq 0x825ca4f4
	if ctx.cr[0].eq {
	pc = 0x825CA4F4; continue 'dispatch;
	}
	// 825CA4A8: 3BBE0040  addi r29, r30, 0x40
	ctx.r[29].s64 = ctx.r[30].s64 + 64;
	// 825CA4AC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825CA4B0: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CA4B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CA4B8: 4BFD6829  bl 0x825a0ce0
	ctx.lr = 0x825CA4BC;
	sub_825A0CE0(ctx, base);
	// 825CA4BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CA4C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825CA4C4: 4BF2FBBD  bl 0x824fa080
	ctx.lr = 0x825CA4C8;
	sub_824FA080(ctx, base);
	// 825CA4C8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825CA4CC: 3861009C  addi r3, r1, 0x9c
	ctx.r[3].s64 = ctx.r[1].s64 + 156;
	// 825CA4D0: 4BFFFD79  bl 0x825ca248
	ctx.lr = 0x825CA4D4;
	sub_825CA248(ctx, base);
	// 825CA4D4: 907C0000  stw r3, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 825CA4D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CA4DC: 48828F4D  bl 0x82df3428
	ctx.lr = 0x825CA4E0;
	sub_82DF3428(ctx, base);
	// 825CA4E0: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CA4E4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825CA4E8: 4BFD6601  bl 0x825a0ae8
	ctx.lr = 0x825CA4EC;
	sub_825A0AE8(ctx, base);
	// 825CA4EC: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 825CA4F0: 4198FFBC  blt cr6, 0x825ca4ac
	if ctx.cr[6].lt {
	pc = 0x825CA4AC; continue 'dispatch;
	}
	// 825CA4F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825CA4F8: 48BDDCC0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CA500 size=420
    let mut pc: u32 = 0x825CA500;
    'dispatch: loop {
        match pc {
            0x825CA500 => {
    //   block [0x825CA500..0x825CA6A4)
	// 825CA500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CA504: 48BDDC65  bl 0x831a8168
	ctx.lr = 0x825CA508;
	sub_831A8130(ctx, base);
	// 825CA508: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CA50C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CA510: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CA514: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825CA518: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825CA51C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CA520: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA524: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CA528: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA52C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CA530: 4E800421  bctrl
	ctx.lr = 0x825CA534;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CA534: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CA538: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CA53C: 419A009C  beq cr6, 0x825ca5d8
	if ctx.cr[6].eq {
	pc = 0x825CA5D8; continue 'dispatch;
	}
	// 825CA540: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA544: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CA548: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CA54C: 4E800421  bctrl
	ctx.lr = 0x825CA550;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CA550: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CA554: 4182006C  beq 0x825ca5c0
	if ctx.cr[0].eq {
	pc = 0x825CA5C0; continue 'dispatch;
	}
	// 825CA558: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825CA55C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CA560: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 825CA564: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CA568: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 825CA56C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825CA570: 419A0024  beq cr6, 0x825ca594
	if ctx.cr[6].eq {
	pc = 0x825CA594; continue 'dispatch;
	}
	// 825CA574: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825CA578: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825CA57C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CA580: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825CA584: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825CA588: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825CA58C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CA590: 4082FFE8  bne 0x825ca578
	if !ctx.cr[0].eq {
	pc = 0x825CA578; continue 'dispatch;
	}
	// 825CA594: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 825CA598: 397F0038  addi r11, r31, 0x38
	ctx.r[11].s64 = ctx.r[31].s64 + 56;
	// 825CA59C: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 825CA5A0: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 825CA5A4: 4BCF9EBD  bl 0x822c4460
	ctx.lr = 0x825CA5A8;
	sub_822C4460(ctx, base);
	// 825CA5A8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825CA5AC: 419A000C  beq cr6, 0x825ca5b8
	if ctx.cr[6].eq {
	pc = 0x825CA5B8; continue 'dispatch;
	}
	// 825CA5B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CA5B4: 4BCF62DD  bl 0x822c0890
	ctx.lr = 0x825CA5B8;
	sub_822C0890(ctx, base);
	// 825CA5B8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CA5BC: 480000B4  b 0x825ca670
	pc = 0x825CA670; continue 'dispatch;
	// 825CA5C0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825CA5C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CA5C8: 419A0008  beq cr6, 0x825ca5d0
	if ctx.cr[6].eq {
	pc = 0x825CA5D0; continue 'dispatch;
	}
	// 825CA5CC: 4BCF62C5  bl 0x822c0890
	ctx.lr = 0x825CA5D0;
	sub_822C0890(ctx, base);
	// 825CA5D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825CA5D4: 480000C8  b 0x825ca69c
	pc = 0x825CA69C; continue 'dispatch;
	// 825CA5D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CA5DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825CA5E0: 3BABD690  addi r29, r11, -0x2970
	ctx.r[29].s64 = ctx.r[11].s64 + -10608;
	// 825CA5E4: 38A000D3  li r5, 0xd3
	ctx.r[5].s64 = 211;
	// 825CA5E8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825CA5EC: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 825CA5F0: 4BCF5DE9  bl 0x822c03d8
	ctx.lr = 0x825CA5F4;
	sub_822C03D8(ctx, base);
	// 825CA5F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825CA5F8: 4182001C  beq 0x825ca614
	if ctx.cr[0].eq {
	pc = 0x825CA614; continue 'dispatch;
	}
	// 825CA5FC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825CA600: 80DF0030  lwz r6, 0x30(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 825CA604: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CA608: 4BFFF9B9  bl 0x825c9fc0
	ctx.lr = 0x825CA60C;
	sub_825C9FC0(ctx, base);
	// 825CA60C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CA610: 48000008  b 0x825ca618
	pc = 0x825CA618; continue 'dispatch;
	// 825CA614: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825CA618: 3BFF0038  addi r31, r31, 0x38
	ctx.r[31].s64 = ctx.r[31].s64 + 56;
	// 825CA61C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CA620: 4BFFECC9  bl 0x825c92e8
	ctx.lr = 0x825CA624;
	sub_825C92E8(ctx, base);
	// 825CA624: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825CA628: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825CA62C: 38A000D4  li r5, 0xd4
	ctx.r[5].s64 = 212;
	// 825CA630: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 825CA634: 4BCF5DA5  bl 0x822c03d8
	ctx.lr = 0x825CA638;
	sub_822C03D8(ctx, base);
	// 825CA638: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825CA63C: 41820010  beq 0x825ca64c
	if ctx.cr[0].eq {
	pc = 0x825CA64C; continue 'dispatch;
	}
	// 825CA640: 4BFD7C71  bl 0x825a22b0
	ctx.lr = 0x825CA644;
	sub_825A22B0(ctx, base);
	// 825CA644: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CA648: 48000008  b 0x825ca650
	pc = 0x825CA650; continue 'dispatch;
	// 825CA64C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825CA650: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA654: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA658: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CA65C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CA660: 4E800421  bctrl
	ctx.lr = 0x825CA664;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CA664: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CA668: 4BFEB399  bl 0x825b5a00
	ctx.lr = 0x825CA66C;
	sub_825B5A00(ctx, base);
	// 825CA66C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA670: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA674: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CA678: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CA67C: 4E800421  bctrl
	ctx.lr = 0x825CA680;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CA680: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825CA684: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA688: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CA68C: 419A000C  beq cr6, 0x825ca698
	if ctx.cr[6].eq {
	pc = 0x825CA698; continue 'dispatch;
	}
	// 825CA690: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825CA694: 4BCF61FD  bl 0x822c0890
	ctx.lr = 0x825CA698;
	sub_822C0890(ctx, base);
	// 825CA698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CA69C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825CA6A0: 48BDDB18  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CA6A8 size=84
    let mut pc: u32 = 0x825CA6A8;
    'dispatch: loop {
        match pc {
            0x825CA6A8 => {
    //   block [0x825CA6A8..0x825CA6FC)
	// 825CA6A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CA6AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CA6B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CA6B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CA6B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CA6BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CA6C0: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825CA6C4: 4BFFFE3D  bl 0x825ca500
	ctx.lr = 0x825CA6C8;
	sub_825CA500(ctx, base);
	// 825CA6C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CA6CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CA6D0: 4BFE71F9  bl 0x825b18c8
	ctx.lr = 0x825CA6D4;
	sub_825B18C8(ctx, base);
	// 825CA6D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CA6D8: 4BFFF5F9  bl 0x825c9cd0
	ctx.lr = 0x825CA6DC;
	sub_825C9CD0(ctx, base);
	// 825CA6DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CA6E0: 4BCFE5D9  bl 0x822c8cb8
	ctx.lr = 0x825CA6E4;
	sub_822C8CB8(ctx, base);
	// 825CA6E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CA6E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CA6EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CA6F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CA6F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CA6F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CA700 size=12
    let mut pc: u32 = 0x825CA700;
    'dispatch: loop {
        match pc {
            0x825CA700 => {
    //   block [0x825CA700..0x825CA70C)
	// 825CA700: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CA704: 99630128  stb r11, 0x128(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(296 as u32), ctx.r[11].u8 ) };
	// 825CA708: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CA710 size=20
    let mut pc: u32 = 0x825CA710;
    'dispatch: loop {
        match pc {
            0x825CA710 => {
    //   block [0x825CA710..0x825CA724)
	// 825CA710: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825CA714: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825CA718: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825CA71C: 994B0128  stb r10, 0x128(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(296 as u32), ctx.r[10].u8 ) };
	// 825CA720: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CA728 size=164
    let mut pc: u32 = 0x825CA728;
    'dispatch: loop {
        match pc {
            0x825CA728 => {
    //   block [0x825CA728..0x825CA7CC)
	// 825CA728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CA72C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CA730: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CA734: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CA738: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CA73C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CA740: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CA744: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CA748: 4BFF7F01  bl 0x825c2648
	ctx.lr = 0x825CA74C;
	sub_825C2648(ctx, base);
	// 825CA74C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825CA750: 7D6BF039  and. r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[30].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CA754: 41820018  beq 0x825ca76c
	if ctx.cr[0].eq {
	pc = 0x825CA76C; continue 'dispatch;
	}
	// 825CA758: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CA75C: 93DF0120  stw r30, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[30].u32 ) };
	// 825CA760: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825CA764: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 825CA768: 4800004C  b 0x825ca7b4
	pc = 0x825CA7B4; continue 'dispatch;
	// 825CA76C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CA770: 7D6BF039  and. r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[30].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CA774: 4182003C  beq 0x825ca7b0
	if ctx.cr[0].eq {
	pc = 0x825CA7B0; continue 'dispatch;
	}
	// 825CA778: 817F0120  lwz r11, 0x120(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 825CA77C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825CA780: 409AFFD8  bne cr6, 0x825ca758
	if !ctx.cr[6].eq {
	pc = 0x825CA758; continue 'dispatch;
	}
	// 825CA784: 817F0124  lwz r11, 0x124(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 825CA788: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825CA78C: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 825CA790: 2B0B001E  cmplwi cr6, r11, 0x1e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 30 as u32, &mut ctx.xer);
	// 825CA794: 4099001C  ble cr6, 0x825ca7b0
	if !ctx.cr[6].gt {
	pc = 0x825CA7B0; continue 'dispatch;
	}
	// 825CA798: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 825CA79C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825CA7A0: 7D4B5396  divwu r10, r11, r10
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 825CA7A4: 1D4A0003  mulli r10, r10, 3
	ctx.r[10].s64 = ctx.r[10].s64 * 3;
	// 825CA7A8: 7D6A5851  subf. r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CA7AC: 40820008  bne 0x825ca7b4
	if !ctx.cr[0].eq {
	pc = 0x825CA7B4; continue 'dispatch;
	}
	// 825CA7B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825CA7B4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825CA7B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CA7BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CA7C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CA7C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CA7C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA7D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CA7D0 size=12
    let mut pc: u32 = 0x825CA7D0;
    'dispatch: loop {
        match pc {
            0x825CA7D0 => {
    //   block [0x825CA7D0..0x825CA7DC)
	// 825CA7D0: 80830108  lwz r4, 0x108(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(264 as u32) ) } as u64;
	// 825CA7D4: 80630130  lwz r3, 0x130(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(304 as u32) ) } as u64;
	// 825CA7D8: 4BFE1718  b 0x825abef0
	sub_825ABEF0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA7E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CA7E0 size=16
    let mut pc: u32 = 0x825CA7E0;
    'dispatch: loop {
        match pc {
            0x825CA7E0 => {
    //   block [0x825CA7E0..0x825CA7F0)
	// 825CA7E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA7E4: 894B0039  lbz r10, 0x39(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 825CA7E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825CA7EC: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA7F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CA7F0 size=24
    let mut pc: u32 = 0x825CA7F0;
    'dispatch: loop {
        match pc {
            0x825CA7F0 => {
    //   block [0x825CA7F0..0x825CA808)
	// 825CA7F0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CA7F4: 892A0039  lbz r9, 0x39(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(57 as u32) ) } as u64;
	// 825CA7F8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825CA7FC: 409A0040  bne cr6, 0x825ca83c
	if !ctx.cr[6].eq {
		sub_825CA824(ctx, base);
		return;
	}
	// 825CA800: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA804: 4800000C  b 0x825ca810
	sub_825CA808(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CA808 size=28
    let mut pc: u32 = 0x825CA808;
    'dispatch: loop {
        match pc {
            0x825CA808 => {
    //   block [0x825CA808..0x825CA824)
	// 825CA808: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825CA80C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA810: 892B0039  lbz r9, 0x39(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 825CA814: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825CA818: 419AFFF0  beq cr6, 0x825ca808
	if ctx.cr[6].eq {
	pc = 0x825CA808; continue 'dispatch;
	}
	// 825CA81C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825CA820: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA824(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CA824 size=48
    let mut pc: u32 = 0x825CA824;
    'dispatch: loop {
        match pc {
            0x825CA824 => {
    //   block [0x825CA824..0x825CA854)
	// 825CA824: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA828: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CA82C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825CA830: 409A001C  bne cr6, 0x825ca84c
	if !ctx.cr[6].eq {
	pc = 0x825CA84C; continue 'dispatch;
	}
	// 825CA834: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CA838: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825CA83C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CA840: 894B0039  lbz r10, 0x39(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 825CA844: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825CA848: 419AFFDC  beq cr6, 0x825ca824
	if ctx.cr[6].eq {
	pc = 0x825CA824; continue 'dispatch;
	}
	// 825CA84C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CA850: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CA858 size=144
    let mut pc: u32 = 0x825CA858;
    'dispatch: loop {
        match pc {
            0x825CA858 => {
    //   block [0x825CA858..0x825CA8E8)
	// 825CA858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CA85C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CA860: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CA864: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CA868: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CA86C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CA870: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825CA874: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 825CA878: 409A0028  bne cr6, 0x825ca8a0
	if !ctx.cr[6].eq {
	pc = 0x825CA8A0; continue 'dispatch;
	}
	// 825CA87C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825CA880: 419A0050  beq cr6, 0x825ca8d0
	if ctx.cr[6].eq {
	pc = 0x825CA8D0; continue 'dispatch;
	}
	// 825CA884: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA888: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CA88C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CA890: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825CA894: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CA898: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825CA89C: 48000034  b 0x825ca8d0
	pc = 0x825CA8D0; continue 'dispatch;
	// 825CA8A0: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 825CA8A4: 419A002C  beq cr6, 0x825ca8d0
	if ctx.cr[6].eq {
	pc = 0x825CA8D0; continue 'dispatch;
	}
	// 825CA8A8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825CA8AC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA8B0: 388BB138  addi r4, r11, -0x4ec8
	ctx.r[4].s64 = ctx.r[11].s64 + -20168;
	// 825CA8B4: 48BDD845  bl 0x831a80f8
	ctx.lr = 0x825CA8B8;
	sub_831A80F8(ctx, base);
	// 825CA8B8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CA8BC: 4182000C  beq 0x825ca8c8
	if ctx.cr[0].eq {
	pc = 0x825CA8C8; continue 'dispatch;
	}
	// 825CA8C0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825CA8C4: 4800000C  b 0x825ca8d0
	pc = 0x825CA8D0; continue 'dispatch;
	// 825CA8C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CA8CC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CA8D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CA8D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CA8D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CA8DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CA8E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CA8E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA8E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CA8E8 size=104
    let mut pc: u32 = 0x825CA8E8;
    'dispatch: loop {
        match pc {
            0x825CA8E8 => {
    //   block [0x825CA8E8..0x825CA950)
	// 825CA8E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CA8EC: 48BDD87D  bl 0x831a8168
	ctx.lr = 0x825CA8F0;
	sub_831A8130(ctx, base);
	// 825CA8F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CA8F4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825CA8F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CA8FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CA900: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825CA904: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825CA908: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825CA90C: 488292F5  bl 0x82df3c00
	ctx.lr = 0x825CA910;
	sub_82DF3C00(ctx, base);
	// 825CA910: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825CA914: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA918: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825CA91C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CA920: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CA924: 4E800421  bctrl
	ctx.lr = 0x825CA928;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CA928: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CA92C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CA930: 488292D1  bl 0x82df3c00
	ctx.lr = 0x825CA934;
	sub_82DF3C00(ctx, base);
	// 825CA934: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CA938: 48828AF1  bl 0x82df3428
	ctx.lr = 0x825CA93C;
	sub_82DF3428(ctx, base);
	// 825CA93C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825CA940: 48828AE9  bl 0x82df3428
	ctx.lr = 0x825CA944;
	sub_82DF3428(ctx, base);
	// 825CA944: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CA948: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825CA94C: 48BDD86C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825CA950 size=44
    let mut pc: u32 = 0x825CA950;
    'dispatch: loop {
        match pc {
            0x825CA950 => {
    //   block [0x825CA950..0x825CA97C)
	// 825CA950: E963010A  lwa r11, 0x108(r3)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(264 as u32) ) } as i32) as i64;
	// 825CA954: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825CA958: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 825CA95C: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CA960: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 825CA964: 8123010C  lwz r9, 0x10c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 825CA968: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825CA96C: C00AD6F0  lfs f0, -0x2910(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10512 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CA970: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825CA974: D00900B0  stfs f0, 0xb0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 825CA978: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CA980 size=20
    let mut pc: u32 = 0x825CA980;
    'dispatch: loop {
        match pc {
            0x825CA980 => {
    //   block [0x825CA980..0x825CA994)
	// 825CA980: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CA984: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CA988: 894B0039  lbz r10, 0x39(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 825CA98C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825CA990: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA994(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CA994 size=40
    let mut pc: u32 = 0x825CA994;
    'dispatch: loop {
        match pc {
            0x825CA994 => {
    //   block [0x825CA994..0x825CA9BC)
	// 825CA994: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA998: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825CA99C: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825CA9A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825CA9A4: 41980008  blt cr6, 0x825ca9ac
	if ctx.cr[6].lt {
	pc = 0x825CA9AC; continue 'dispatch;
	}
	// 825CA9A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825CA9AC: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825CA9B0: 4182000C  beq 0x825ca9bc
	if ctx.cr[0].eq {
		sub_825CA9BC(ctx, base);
		return;
	}
	// 825CA9B4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CA9B8: 4800000C  b 0x825ca9c4
	sub_825CA9BC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA9BC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CA9BC size=24
    let mut pc: u32 = 0x825CA9BC;
    'dispatch: loop {
        match pc {
            0x825CA9BC => {
    //   block [0x825CA9BC..0x825CA9D4)
	// 825CA9BC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825CA9C0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CA9C4: 894B0039  lbz r10, 0x39(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 825CA9C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825CA9CC: 419AFFCC  beq cr6, 0x825ca998
	if ctx.cr[6].eq {
		sub_825CA994(ctx, base);
		return;
	}
	// 825CA9D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CA9D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CA9D8 size=72
    let mut pc: u32 = 0x825CA9D8;
    'dispatch: loop {
        match pc {
            0x825CA9D8 => {
    //   block [0x825CA9D8..0x825CAA20)
	// 825CA9D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CA9DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CA9E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CA9E4: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 825CA9E8: 419A001C  beq cr6, 0x825caa04
	if ctx.cr[6].eq {
	pc = 0x825CAA04; continue 'dispatch;
	}
	// 825CA9EC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825CA9F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825CA9F4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 825CA9F8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CA9FC: 4BFFFE5D  bl 0x825ca858
	ctx.lr = 0x825CAA00;
	sub_825CA858(ctx, base);
	// 825CAA00: 48000010  b 0x825caa10
	pc = 0x825CAA10; continue 'dispatch;
	// 825CAA04: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825CAA08: 396BB138  addi r11, r11, -0x4ec8
	ctx.r[11].s64 = ctx.r[11].s64 + -20168;
	// 825CAA0C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CAA10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825CAA14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CAA18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CAA1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CAA20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CAA20 size=264
    let mut pc: u32 = 0x825CAA20;
    'dispatch: loop {
        match pc {
            0x825CAA20 => {
    //   block [0x825CAA20..0x825CAB28)
	// 825CAA20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CAA24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CAA28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CAA2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CAA30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CAA34: 3FC08335  lis r30, -0x7ccb
	ctx.r[30].s64 = -2093678592;
	// 825CAA38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CAA3C: 807E1494  lwz r3, 0x1494(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(5268 as u32) ) } as u64;
	// 825CAA40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CAA44: 409A000C  bne cr6, 0x825caa50
	if !ctx.cr[6].eq {
	pc = 0x825CAA50; continue 'dispatch;
	}
	// 825CAA48: 4BCF5D29  bl 0x822c0770
	ctx.lr = 0x825CAA4C;
	sub_822C0770(ctx, base);
	// 825CAA4C: 907E1494  stw r3, 0x1494(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(5268 as u32), ctx.r[3].u32 ) };
	// 825CAA50: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825CAA54: 488D490D  bl 0x82e9f360
	ctx.lr = 0x825CAA58;
	sub_82E9F360(ctx, base);
	// 825CAA58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CAA5C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 825CAA60: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 825CAA64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CAA68: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 825CAA6C: A3CA0002  lhz r30, 2(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 825CAA70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CAA74: 4E800421  bctrl
	ctx.lr = 0x825CAA78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CAA78: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CAA7C: 40820060  bne 0x825caadc
	if !ctx.cr[0].eq {
	pc = 0x825CAADC; continue 'dispatch;
	}
	// 825CAA80: 2B1E0051  cmplwi cr6, r30, 0x51
	ctx.cr[6].compare_u32(ctx.r[30].u32, 81 as u32, &mut ctx.xer);
	// 825CAA84: 419A0058  beq cr6, 0x825caadc
	if ctx.cr[6].eq {
	pc = 0x825CAADC; continue 'dispatch;
	}
	// 825CAA88: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CAA8C: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 825CAA90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CAA94: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 825CAA98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CAA9C: 4E800421  bctrl
	ctx.lr = 0x825CAAA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CAAA0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CAAA4: 4082000C  bne 0x825caab0
	if !ctx.cr[0].eq {
	pc = 0x825CAAB0; continue 'dispatch;
	}
	// 825CAAA8: 2B1E0052  cmplwi cr6, r30, 0x52
	ctx.cr[6].compare_u32(ctx.r[30].u32, 82 as u32, &mut ctx.xer);
	// 825CAAAC: 409A0064  bne cr6, 0x825cab10
	if !ctx.cr[6].eq {
	pc = 0x825CAB10; continue 'dispatch;
	}
	// 825CAAB0: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 825CAAB4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CAAB8: 40800054  bge 0x825cab0c
	if !ctx.cr[0].lt {
	pc = 0x825CAB0C; continue 'dispatch;
	}
	// 825CAABC: 817F00A4  lwz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 825CAAC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CAAC4: 419A0010  beq cr6, 0x825caad4
	if ctx.cr[6].eq {
	pc = 0x825CAAD4; continue 'dispatch;
	}
	// 825CAAC8: 815F00A8  lwz r10, 0xa8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 825CAACC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825CAAD0: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825CAAD4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825CAAD8: 48000034  b 0x825cab0c
	pc = 0x825CAB0C; continue 'dispatch;
	// 825CAADC: 817F00A4  lwz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 825CAAE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CAAE4: 419A0010  beq cr6, 0x825caaf4
	if ctx.cr[6].eq {
	pc = 0x825CAAF4; continue 'dispatch;
	}
	// 825CAAE8: 815F00A8  lwz r10, 0xa8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 825CAAEC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825CAAF0: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825CAAF4: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 825CAAF8: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 825CAAFC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825CAB00: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825CAB04: 40990008  ble cr6, 0x825cab0c
	if !ctx.cr[6].gt {
	pc = 0x825CAB0C; continue 'dispatch;
	}
	// 825CAB08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CAB0C: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 825CAB10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CAB14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CAB18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CAB1C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CAB20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CAB24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CAB28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CAB28 size=16
    let mut pc: u32 = 0x825CAB28;
    'dispatch: loop {
        match pc {
            0x825CAB28 => {
    //   block [0x825CAB28..0x825CAB38)
	// 825CAB28: 81630148  lwz r11, 0x148(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(328 as u32) ) } as u64;
	// 825CAB2C: 8143014C  lwz r10, 0x14c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(332 as u32) ) } as u64;
	// 825CAB30: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825CAB34: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CAB38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CAB38 size=56
    let mut pc: u32 = 0x825CAB38;
    'dispatch: loop {
        match pc {
            0x825CAB38 => {
    //   block [0x825CAB38..0x825CAB70)
	// 825CAB38: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825CAB3C: 392000FF  li r9, 0xff
	ctx.r[9].s64 = 255;
	// 825CAB40: 9941FFF1  stb r10, -0xf(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(-15 as u32), ctx.r[10].u8 ) };
	// 825CAB44: 9921FFF0  stb r9, -0x10(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u8 ) };
	// 825CAB48: 9941FFF2  stb r10, -0xe(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(-14 as u32), ctx.r[10].u8 ) };
	// 825CAB4C: 9941FFF3  stb r10, -0xd(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(-13 as u32), ctx.r[10].u8 ) };
	// 825CAB50: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CAB54: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825CAB58: 8121FFF0  lwz r9, -0x10(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 825CAB5C: 912A00B8  stw r9, 0xb8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(184 as u32), ctx.r[9].u32 ) };
	// 825CAB60: 8143014C  lwz r10, 0x14c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(332 as u32) ) } as u64;
	// 825CAB64: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825CAB68: 409AFFE8  bne cr6, 0x825cab50
	if !ctx.cr[6].eq {
	pc = 0x825CAB50; continue 'dispatch;
	}
	// 825CAB6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CAB70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CAB70 size=120
    let mut pc: u32 = 0x825CAB70;
    'dispatch: loop {
        match pc {
            0x825CAB70 => {
    //   block [0x825CAB70..0x825CABE8)
	// 825CAB70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CAB74: 48BDD5F9  bl 0x831a816c
	ctx.lr = 0x825CAB78;
	sub_831A8130(ctx, base);
	// 825CAB78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CAB7C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825CAB80: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825CAB84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CAB88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CAB8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825CAB90: 4BFFFDF1  bl 0x825ca980
	ctx.lr = 0x825CAB94;
	sub_825CA980(ctx, base);
	// 825CAB94: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CAB98: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 825CAB9C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CABA0: 419A002C  beq cr6, 0x825cabcc
	if ctx.cr[6].eq {
	pc = 0x825CABCC; continue 'dispatch;
	}
	// 825CABA4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CABA8: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 825CABAC: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825CABB0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825CABB4: 41980008  blt cr6, 0x825cabbc
	if ctx.cr[6].lt {
	pc = 0x825CABBC; continue 'dispatch;
	}
	// 825CABB8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825CABBC: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825CABC0: 4082000C  bne 0x825cabcc
	if !ctx.cr[0].eq {
	pc = 0x825CABCC; continue 'dispatch;
	}
	// 825CABC4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825CABC8: 4800000C  b 0x825cabd4
	pc = 0x825CABD4; continue 'dispatch;
	// 825CABCC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825CABD0: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 825CABD4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CABD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CABDC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CABE0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825CABE4: 48BDD5D8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CABE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CABE8 size=104
    let mut pc: u32 = 0x825CABE8;
    'dispatch: loop {
        match pc {
            0x825CABE8 => {
    //   block [0x825CABE8..0x825CAC50)
	// 825CABE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CABEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CABF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CABF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CABF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CABFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CAC00: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 825CAC04: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 825CAC08: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 825CAC0C: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 825CAC10: 38870008  addi r4, r7, 8
	ctx.r[4].s64 = ctx.r[7].s64 + 8;
	// 825CAC14: 90BF0004  stw r5, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 825CAC18: 90DF0008  stw r6, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 825CAC1C: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CAC20: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 825CAC24: 4BFC12ED  bl 0x8258bf10
	ctx.lr = 0x825CAC28;
	sub_8258BF10(ctx, base);
	// 825CAC28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CAC2C: 9BDF0038  stb r30, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u8 ) };
	// 825CAC30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CAC34: 997F0039  stb r11, 0x39(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(57 as u32), ctx.r[11].u8 ) };
	// 825CAC38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CAC3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CAC40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CAC44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CAC48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CAC4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CAC50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CAC50 size=88
    let mut pc: u32 = 0x825CAC50;
    'dispatch: loop {
        match pc {
            0x825CAC50 => {
    //   block [0x825CAC50..0x825CACA8)
	// 825CAC50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CAC54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CAC58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CAC5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CAC60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CAC64: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CAC68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CAC6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CAC70: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CAC74: 48828D95  bl 0x82df3a08
	ctx.lr = 0x825CAC78;
	sub_82DF3A08(ctx, base);
	// 825CAC78: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825CAC7C: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CAC80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CAC84: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CAC88: 4BFFFC61  bl 0x825ca8e8
	ctx.lr = 0x825CAC8C;
	sub_825CA8E8(ctx, base);
	// 825CAC8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CAC90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CAC94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CAC98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CAC9C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CACA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CACA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CACA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CACA8 size=108
    let mut pc: u32 = 0x825CACA8;
    'dispatch: loop {
        match pc {
            0x825CACA8 => {
    //   block [0x825CACA8..0x825CAD14)
	// 825CACA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CACAC: 48BDD4B5  bl 0x831a8160
	ctx.lr = 0x825CACB0;
	sub_831A8130(ctx, base);
	// 825CACB0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CACB4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825CACB8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825CACBC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CACC0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825CACC4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825CACC8: 38C00040  li r6, 0x40
	ctx.r[6].s64 = 64;
	// 825CACCC: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 825CACD0: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 825CACD4: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 825CACD8: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 825CACDC: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 825CACE0: 488273E9  bl 0x82df20c8
	ctx.lr = 0x825CACE4;
	sub_82DF20C8(ctx, base);
	// 825CACE4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825CACE8: 41820020  beq 0x825cad08
	if ctx.cr[0].eq {
	pc = 0x825CAD08; continue 'dispatch;
	}
	// 825CACEC: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 825CACF0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825CACF4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825CACF8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825CACFC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CAD00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CAD04: 4BFFFEE5  bl 0x825cabe8
	ctx.lr = 0x825CAD08;
	sub_825CABE8(ctx, base);
	// 825CAD08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CAD0C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825CAD10: 48BDD4A0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CAD18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CAD18 size=48
    let mut pc: u32 = 0x825CAD18;
    'dispatch: loop {
        match pc {
            0x825CAD18 => {
    //   block [0x825CAD18..0x825CAD48)
	// 825CAD18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CAD1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CAD20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CAD24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CAD28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CAD2C: 4BFFFF25  bl 0x825cac50
	ctx.lr = 0x825CAD30;
	sub_825CAC50(ctx, base);
	// 825CAD30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CAD34: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825CAD38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CAD3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CAD40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CAD44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CAD48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CAD48 size=548
    let mut pc: u32 = 0x825CAD48;
    'dispatch: loop {
        match pc {
            0x825CAD48 => {
    //   block [0x825CAD48..0x825CAF6C)
	// 825CAD48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CAD4C: 48BDD415  bl 0x831a8160
	ctx.lr = 0x825CAD50;
	sub_831A8130(ctx, base);
	// 825CAD50: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CAD54: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CAD58: 3D600666  lis r11, 0x666
	ctx.r[11].s64 = 107347968;
	// 825CAD5C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825CAD60: 616B6665  ori r11, r11, 0x6665
	ctx.r[11].u64 = ctx.r[11].u64 | 26213;
	// 825CAD64: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 825CAD68: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CAD6C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 825CAD70: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 825CAD74: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CAD78: 41980048  blt cr6, 0x825cadc0
	if ctx.cr[6].lt {
	pc = 0x825CADC0; continue 'dispatch;
	}
	// 825CAD7C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825CAD80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CAD84: 388B9BCC  addi r4, r11, -0x6434
	ctx.r[4].s64 = ctx.r[11].s64 + -25652;
	// 825CAD88: 4BCFAB41  bl 0x822c58c8
	ctx.lr = 0x825CAD8C;
	sub_822C58C8(ctx, base);
	// 825CAD8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825CAD90: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825CAD94: 4BCFAA85  bl 0x822c5818
	ctx.lr = 0x825CAD98;
	sub_822C5818(ctx, base);
	// 825CAD98: 4BCF9519  bl 0x822c42b0
	ctx.lr = 0x825CAD9C;
	sub_822C42B0(ctx, base);
	// 825CAD9C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825CADA0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825CADA4: 396B94A0  addi r11, r11, -0x6b60
	ctx.r[11].s64 = ctx.r[11].s64 + -27488;
	// 825CADA8: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825CADAC: 4BCFA6C5  bl 0x822c5470
	ctx.lr = 0x825CADB0;
	sub_822C5470(ctx, base);
	// 825CADB0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825CADB4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825CADB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CADBC: 4BCF9F25  bl 0x822c4ce0
	ctx.lr = 0x825CADC0;
	sub_822C4CE0(ctx, base);
	// 825CADC0: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CADC4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825CADC8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 825CADCC: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 825CADD0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825CADD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CADD8: 4BFFFED1  bl 0x825caca8
	ctx.lr = 0x825CADDC;
	sub_825CACA8(ctx, base);
	// 825CADDC: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CADE0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CADE4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825CADE8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825CADEC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CADF0: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825CADF4: 409A0018  bne cr6, 0x825cae0c
	if !ctx.cr[6].eq {
	pc = 0x825CAE0C; continue 'dispatch;
	}
	// 825CADF8: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 825CADFC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CAE00: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825CAE04: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CAE08: 4800003C  b 0x825cae44
	pc = 0x825CAE44; continue 'dispatch;
	// 825CAE0C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CAE10: 41820020  beq 0x825cae30
	if ctx.cr[0].eq {
	pc = 0x825CAE30; continue 'dispatch;
	}
	// 825CAE14: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825CAE18: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CAE1C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CAE20: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825CAE24: 409A0024  bne cr6, 0x825cae48
	if !ctx.cr[6].eq {
	pc = 0x825CAE48; continue 'dispatch;
	}
	// 825CAE28: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825CAE2C: 4800001C  b 0x825cae48
	pc = 0x825CAE48; continue 'dispatch;
	// 825CAE30: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 825CAE34: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CAE38: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CAE3C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825CAE40: 409A0008  bne cr6, 0x825cae48
	if !ctx.cr[6].eq {
	pc = 0x825CAE48; continue 'dispatch;
	}
	// 825CAE44: 938B0008  stw r28, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 825CAE48: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CAE4C: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825CAE50: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 825CAE54: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 825CAE58: 894A0038  lbz r10, 0x38(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 825CAE5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825CAE60: 409A00F0  bne cr6, 0x825caf50
	if !ctx.cr[6].eq {
	pc = 0x825CAF50; continue 'dispatch;
	}
	// 825CAE64: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825CAE68: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CAE6C: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CAE70: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CAE74: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825CAE78: 409A0054  bne cr6, 0x825caecc
	if !ctx.cr[6].eq {
	pc = 0x825CAECC; continue 'dispatch;
	}
	// 825CAE7C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CAE80: 892A0038  lbz r9, 0x38(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 825CAE84: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825CAE88: 419A0054  beq cr6, 0x825caedc
	if ctx.cr[6].eq {
	pc = 0x825CAEDC; continue 'dispatch;
	}
	// 825CAE8C: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CAE90: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CAE94: 409A0010  bne cr6, 0x825caea4
	if !ctx.cr[6].eq {
	pc = 0x825CAEA4; continue 'dispatch;
	}
	// 825CAE98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CAE9C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825CAEA0: 485E2F21  bl 0x82baddc0
	ctx.lr = 0x825CAEA4;
	sub_82BADDC0(ctx, base);
	// 825CAEA4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CAEA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CAEAC: 9BAB0038  stb r29, 0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[29].u8 ) };
	// 825CAEB0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CAEB4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CAEB8: 9B6B0038  stb r27, 0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[27].u8 ) };
	// 825CAEBC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CAEC0: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CAEC4: 485E2F65  bl 0x82bade28
	ctx.lr = 0x825CAEC8;
	sub_82BADE28(ctx, base);
	// 825CAEC8: 48000074  b 0x825caf3c
	pc = 0x825CAF3C; continue 'dispatch;
	// 825CAECC: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CAED0: 892A0038  lbz r9, 0x38(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 825CAED4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825CAED8: 409A0028  bne cr6, 0x825caf00
	if !ctx.cr[6].eq {
	pc = 0x825CAF00; continue 'dispatch;
	}
	// 825CAEDC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CAEE0: 9BA90038  stb r29, 0x38(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(56 as u32), ctx.r[29].u8 ) };
	// 825CAEE4: 9BAA0038  stb r29, 0x38(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(56 as u32), ctx.r[29].u8 ) };
	// 825CAEE8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CAEEC: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CAEF0: 9B6A0038  stb r27, 0x38(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(56 as u32), ctx.r[27].u8 ) };
	// 825CAEF4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CAEF8: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CAEFC: 48000040  b 0x825caf3c
	pc = 0x825CAF3C; continue 'dispatch;
	// 825CAF00: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CAF04: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CAF08: 409A0010  bne cr6, 0x825caf18
	if !ctx.cr[6].eq {
	pc = 0x825CAF18; continue 'dispatch;
	}
	// 825CAF0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CAF10: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825CAF14: 485E2F15  bl 0x82bade28
	ctx.lr = 0x825CAF18;
	sub_82BADE28(ctx, base);
	// 825CAF18: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CAF1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CAF20: 9BAB0038  stb r29, 0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[29].u8 ) };
	// 825CAF24: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CAF28: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CAF2C: 9B6B0038  stb r27, 0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[27].u8 ) };
	// 825CAF30: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CAF34: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CAF38: 485E2E89  bl 0x82baddc0
	ctx.lr = 0x825CAF3C;
	sub_82BADDC0(ctx, base);
	// 825CAF3C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CAF40: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825CAF44: 894A0038  lbz r10, 0x38(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 825CAF48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825CAF4C: 419AFF1C  beq cr6, 0x825cae68
	if ctx.cr[6].eq {
	pc = 0x825CAE68; continue 'dispatch;
	}
	// 825CAF50: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CAF54: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825CAF58: 939A0000  stw r28, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825CAF5C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CAF60: 9BAB0038  stb r29, 0x38(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[29].u8 ) };
	// 825CAF64: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 825CAF68: 48BDD248  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CAF70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CAF70 size=100
    let mut pc: u32 = 0x825CAF70;
    'dispatch: loop {
        match pc {
            0x825CAF70 => {
    //   block [0x825CAF70..0x825CAFD4)
	// 825CAF70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CAF74: 48BDD1F5  bl 0x831a8168
	ctx.lr = 0x825CAF78;
	sub_831A8130(ctx, base);
	// 825CAF78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CAF7C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CAF80: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825CAF84: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 825CAF88: 897E0039  lbz r11, 0x39(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(57 as u32) ) } as u64;
	// 825CAF8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CAF90: 409A003C  bne cr6, 0x825cafcc
	if !ctx.cr[6].eq {
	pc = 0x825CAFCC; continue 'dispatch;
	}
	// 825CAF94: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 825CAF98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825CAF9C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CAFA0: 4BFFFFD1  bl 0x825caf70
	ctx.lr = 0x825CAFA4;
	sub_825CAF70(ctx, base);
	// 825CAFA4: 387E0018  addi r3, r30, 0x18
	ctx.r[3].s64 = ctx.r[30].s64 + 24;
	// 825CAFA8: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CAFAC: 4BCFDD0D  bl 0x822c8cb8
	ctx.lr = 0x825CAFB0;
	sub_822C8CB8(ctx, base);
	// 825CAFB0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CAFB4: 807C110C  lwz r3, 0x110c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4364 as u32) ) } as u64;
	// 825CAFB8: 488271D1  bl 0x82df2188
	ctx.lr = 0x825CAFBC;
	sub_82DF2188(ctx, base);
	// 825CAFBC: 897F0039  lbz r11, 0x39(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(57 as u32) ) } as u64;
	// 825CAFC0: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 825CAFC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CAFC8: 419AFFD0  beq cr6, 0x825caf98
	if ctx.cr[6].eq {
	pc = 0x825CAF98; continue 'dispatch;
	}
	// 825CAFCC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825CAFD0: 48BDD1E8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CAFD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CAFD8 size=132
    let mut pc: u32 = 0x825CAFD8;
    'dispatch: loop {
        match pc {
            0x825CAFD8 => {
    //   block [0x825CAFD8..0x825CB05C)
	// 825CAFD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CAFDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CAFE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CAFE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CAFE8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CAFEC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825CAFF0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CAFF4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CAFF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CAFFC: 409A0018  bne cr6, 0x825cb014
	if !ctx.cr[6].eq {
	pc = 0x825CB014; continue 'dispatch;
	}
	// 825CB000: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825CB004: 4BD085D5  bl 0x822d35d8
	ctx.lr = 0x825CB008;
	sub_822D35D8(ctx, base);
	// 825CB008: 4BCF4FF9  bl 0x822c0000
	ctx.lr = 0x825CB00C;
	sub_822C0000(ctx, base);
	// 825CB00C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825CB010: 4BD07801  bl 0x822d2810
	ctx.lr = 0x825CB014;
	sub_822D2810(ctx, base);
	// 825CB014: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CB018: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 825CB01C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CB020: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CB024: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CB028: 4E800421  bctrl
	ctx.lr = 0x825CB02C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CB02C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CB030: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CB034: 48828BCD  bl 0x82df3c00
	ctx.lr = 0x825CB038;
	sub_82DF3C00(ctx, base);
	// 825CB038: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CB03C: 488283ED  bl 0x82df3428
	ctx.lr = 0x825CB040;
	sub_82DF3428(ctx, base);
	// 825CB040: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CB044: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825CB048: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CB04C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CB050: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CB054: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CB058: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CB060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CB060 size=100
    let mut pc: u32 = 0x825CB060;
    'dispatch: loop {
        match pc {
            0x825CB060 => {
    //   block [0x825CB060..0x825CB0C4)
	// 825CB060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CB064: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CB068: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CB06C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CB070: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CB074: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CB078: 4882E711  bl 0x82df9788
	ctx.lr = 0x825CB07C;
	sub_82DF9788(ctx, base);
	// 825CB07C: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 825CB080: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 825CB084: 4198000C  blt cr6, 0x825cb090
	if ctx.cr[6].lt {
	pc = 0x825CB090; continue 'dispatch;
	}
	// 825CB088: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CB08C: 48000008  b 0x825cb094
	pc = 0x825CB094; continue 'dispatch;
	// 825CB090: 38830004  addi r4, r3, 4
	ctx.r[4].s64 = ctx.r[3].s64 + 4;
	// 825CB094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CB098: 4BCFE259  bl 0x822c92f0
	ctx.lr = 0x825CB09C;
	sub_822C92F0(ctx, base);
	// 825CB09C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825CB0A0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825CB0A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CB0A8: 4BCFDD89  bl 0x822c8e30
	ctx.lr = 0x825CB0AC;
	sub_822C8E30(ctx, base);
	// 825CB0AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CB0B0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825CB0B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CB0B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CB0BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CB0C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CB0C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CB0C8 size=124
    let mut pc: u32 = 0x825CB0C8;
    'dispatch: loop {
        match pc {
            0x825CB0C8 => {
    //   block [0x825CB0C8..0x825CB144)
	// 825CB0C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CB0CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CB0D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CB0D4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CB0D8: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CB0DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CB0E0: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CB0E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CB0E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825CB0EC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825CB0F0: 419A0024  beq cr6, 0x825cb114
	if ctx.cr[6].eq {
	pc = 0x825CB114; continue 'dispatch;
	}
	// 825CB0F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825CB0F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825CB0FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CB100: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825CB104: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825CB108: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825CB10C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CB110: 4082FFE8  bne 0x825cb0f8
	if !ctx.cr[0].eq {
	pc = 0x825CB0F8; continue 'dispatch;
	}
	// 825CB114: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825CB118: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825CB11C: 4BFFFF45  bl 0x825cb060
	ctx.lr = 0x825CB120;
	sub_825CB060(ctx, base);
	// 825CB120: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825CB124: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825CB128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CB12C: 48AF7855  bl 0x830c2980
	ctx.lr = 0x825CB130;
	sub_830C2980(ctx, base);
	// 825CB130: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825CB134: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CB138: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CB13C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CB140: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CB148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CB148 size=896
    let mut pc: u32 = 0x825CB148;
    'dispatch: loop {
        match pc {
            0x825CB148 => {
    //   block [0x825CB148..0x825CB4C8)
	// 825CB148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CB14C: 48BDD009  bl 0x831a8154
	ctx.lr = 0x825CB150;
	sub_831A8130(ctx, base);
	// 825CB150: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CB154: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CB158: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825CB15C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825CB160: 817E0138  lwz r11, 0x138(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(312 as u32) ) } as u64;
	// 825CB164: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CB168: 419A0358  beq cr6, 0x825cb4c0
	if ctx.cr[6].eq {
	pc = 0x825CB4C0; continue 'dispatch;
	}
	// 825CB16C: 815E013C  lwz r10, 0x13c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(316 as u32) ) } as u64;
	// 825CB170: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825CB174: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825CB178: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CB17C: 40980344  bge cr6, 0x825cb4c0
	if !ctx.cr[6].lt {
	pc = 0x825CB4C0; continue 'dispatch;
	}
	// 825CB180: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825CB184: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825CB188: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825CB18C: 4BCFDCA5  bl 0x822c8e30
	ctx.lr = 0x825CB190;
	sub_822C8E30(ctx, base);
	// 825CB190: 38DF0001  addi r6, r31, 1
	ctx.r[6].s64 = ctx.r[31].s64 + 1;
	// 825CB194: 2F060009  cmpwi cr6, r6, 9
	ctx.cr[6].compare_i32(ctx.r[6].s32, 9, &mut ctx.xer);
	// 825CB198: 41990010  bgt cr6, 0x825cb1a8
	if ctx.cr[6].gt {
	pc = 0x825CB1A8; continue 'dispatch;
	}
	// 825CB19C: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825CB1A0: 38AB5744  addi r5, r11, 0x5744
	ctx.r[5].s64 = ctx.r[11].s64 + 22340;
	// 825CB1A4: 48000024  b 0x825cb1c8
	pc = 0x825CB1C8; continue 'dispatch;
	// 825CB1A8: 2F060010  cmpwi cr6, r6, 0x10
	ctx.cr[6].compare_i32(ctx.r[6].s32, 16, &mut ctx.xer);
	// 825CB1AC: 41990014  bgt cr6, 0x825cb1c0
	if ctx.cr[6].gt {
	pc = 0x825CB1C0; continue 'dispatch;
	}
	// 825CB1B0: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825CB1B4: 38C60037  addi r6, r6, 0x37
	ctx.r[6].s64 = ctx.r[6].s64 + 55;
	// 825CB1B8: 38AB5750  addi r5, r11, 0x5750
	ctx.r[5].s64 = ctx.r[11].s64 + 22352;
	// 825CB1BC: 4800000C  b 0x825cb1c8
	pc = 0x825CB1C8; continue 'dispatch;
	// 825CB1C0: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 825CB1C4: 38AB575C  addi r5, r11, 0x575c
	ctx.r[5].s64 = ctx.r[11].s64 + 22364;
	// 825CB1C8: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 825CB1CC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825CB1D0: 48BDE6B1  bl 0x831a9880
	ctx.lr = 0x825CB1D4;
	sub_831A9880(ctx, base);
	// 825CB1D4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825CB1D8: 48BDDEF1  bl 0x831a90c8
	ctx.lr = 0x825CB1DC;
	sub_831A90C8(ctx, base);
	// 825CB1DC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825CB1E0: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 825CB1E4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825CB1E8: 4BCFE041  bl 0x822c9228
	ctx.lr = 0x825CB1EC;
	sub_822C9228(ctx, base);
	// 825CB1EC: 817E0138  lwz r11, 0x138(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(312 as u32) ) } as u64;
	// 825CB1F0: 57FD1838  slwi r29, r31, 3
	ctx.r[29].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 825CB1F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825CB1F8: 7C8BE82E  lwzx r4, r11, r29
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 825CB1FC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CB200: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825CB204: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CB208: 4E800421  bctrl
	ctx.lr = 0x825CB20C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CB20C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825CB210: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 825CB214: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CB218: 4882E4B1  bl 0x82df96c8
	ctx.lr = 0x825CB21C;
	sub_82DF96C8(ctx, base);
	// 825CB21C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CB220: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825CB224: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 825CB228: 48828A19  bl 0x82df3c40
	ctx.lr = 0x825CB22C;
	sub_82DF3C40(ctx, base);
	// 825CB22C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CB230: 488281F9  bl 0x82df3428
	ctx.lr = 0x825CB234;
	sub_82DF3428(ctx, base);
	// 825CB234: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825CB238: 488281F1  bl 0x82df3428
	ctx.lr = 0x825CB23C;
	sub_82DF3428(ctx, base);
	// 825CB23C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825CB240: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825CB244: 488289BD  bl 0x82df3c00
	ctx.lr = 0x825CB248;
	sub_82DF3C00(ctx, base);
	// 825CB248: 807E0154  lwz r3, 0x154(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(340 as u32) ) } as u64;
	// 825CB24C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CB250: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CB254: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 825CB258: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CB25C: 4E800421  bctrl
	ctx.lr = 0x825CB260;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CB260: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CB264: 41820010  beq 0x825cb274
	if ctx.cr[0].eq {
	pc = 0x825CB274; continue 'dispatch;
	}
	// 825CB268: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CB26C: 388BD70C  addi r4, r11, -0x28f4
	ctx.r[4].s64 = ctx.r[11].s64 + -10484;
	// 825CB270: 4800000C  b 0x825cb27c
	pc = 0x825CB27C; continue 'dispatch;
	// 825CB274: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825CB278: 388BBD38  addi r4, r11, -0x42c8
	ctx.r[4].s64 = ctx.r[11].s64 + -17096;
	// 825CB27C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825CB280: 48828789  bl 0x82df3a08
	ctx.lr = 0x825CB284;
	sub_82DF3A08(ctx, base);
	// 825CB284: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825CB288: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CB28C: 388B9BC9  addi r4, r11, -0x6437
	ctx.r[4].s64 = ctx.r[11].s64 + -25655;
	// 825CB290: 48828779  bl 0x82df3a08
	ctx.lr = 0x825CB294;
	sub_82DF3A08(ctx, base);
	// 825CB294: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825CB298: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825CB29C: 48828005  bl 0x82df32a0
	ctx.lr = 0x825CB2A0;
	sub_82DF32A0(ctx, base);
	// 825CB2A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CB2A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CB2A8: 48828181  bl 0x82df3428
	ctx.lr = 0x825CB2AC;
	sub_82DF3428(ctx, base);
	// 825CB2AC: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CB2B0: 418201B0  beq 0x825cb460
	if ctx.cr[0].eq {
	pc = 0x825CB460; continue 'dispatch;
	}
	// 825CB2B4: 817E0138  lwz r11, 0x138(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(312 as u32) ) } as u64;
	// 825CB2B8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825CB2BC: 83FE0154  lwz r31, 0x154(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(340 as u32) ) } as u64;
	// 825CB2C0: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 825CB2C4: 388B00C4  addi r4, r11, 0xc4
	ctx.r[4].s64 = ctx.r[11].s64 + 196;
	// 825CB2C8: 48828939  bl 0x82df3c00
	ctx.lr = 0x825CB2CC;
	sub_82DF3C00(ctx, base);
	// 825CB2CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CB2D0: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 825CB2D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CB2D8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825CB2DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CB2E0: 4E800421  bctrl
	ctx.lr = 0x825CB2E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CB2E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CB2E8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825CB2EC: 4882813D  bl 0x82df3428
	ctx.lr = 0x825CB2F0;
	sub_82DF3428(ctx, base);
	// 825CB2F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CB2F4: 816BCDF4  lwz r11, -0x320c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12812 as u32) ) } as u64;
	// 825CB2F8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CB2FC: 409A001C  bne cr6, 0x825cb318
	if !ctx.cr[6].eq {
	pc = 0x825CB318; continue 'dispatch;
	}
	// 825CB300: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CB304: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825CB308: 388BD704  addi r4, r11, -0x28fc
	ctx.r[4].s64 = ctx.r[11].s64 + -10492;
	// 825CB30C: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 825CB310: 488286F9  bl 0x82df3a08
	ctx.lr = 0x825CB314;
	sub_82DF3A08(ctx, base);
	// 825CB314: 48000014  b 0x825cb328
	pc = 0x825CB328; continue 'dispatch;
	// 825CB318: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CB31C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825CB320: 3BE00002  li r31, 2
	ctx.r[31].s64 = 2;
	// 825CB324: 4BFF4045  bl 0x825bf368
	ctx.lr = 0x825CB328;
	sub_825BF368(ctx, base);
	// 825CB328: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CB32C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CB330: 488288D1  bl 0x82df3c00
	ctx.lr = 0x825CB334;
	sub_82DF3C00(ctx, base);
	// 825CB334: 57EB07BD  rlwinm. r11, r31, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CB338: 41820010  beq 0x825cb348
	if ctx.cr[0].eq {
	pc = 0x825CB348; continue 'dispatch;
	}
	// 825CB33C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825CB340: 57FF07FA  rlwinm r31, r31, 0, 0x1f, 0x1d
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 825CB344: 488280E5  bl 0x82df3428
	ctx.lr = 0x825CB348;
	sub_82DF3428(ctx, base);
	// 825CB348: 57EB07FF  clrlwi. r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CB34C: 4182000C  beq 0x825cb358
	if ctx.cr[0].eq {
	pc = 0x825CB358; continue 'dispatch;
	}
	// 825CB350: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825CB354: 488280D5  bl 0x82df3428
	ctx.lr = 0x825CB358;
	sub_82DF3428(ctx, base);
	// 825CB358: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CB35C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825CB360: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825CB364: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825CB368: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 825CB36C: 3CC08204  lis r6, -0x7dfc
	ctx.r[6].s64 = -2113667072;
	// 825CB370: 388BBEE4  addi r4, r11, -0x411c
	ctx.r[4].s64 = ctx.r[11].s64 + -16668;
	// 825CB374: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 825CB378: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 825CB37C: 3BEAD700  addi r31, r10, -0x2900
	ctx.r[31].s64 = ctx.r[10].s64 + -10496;
	// 825CB380: 3B89D6FC  addi r28, r9, -0x2904
	ctx.r[28].s64 = ctx.r[9].s64 + -10500;
	// 825CB384: 3B68D6F8  addi r27, r8, -0x2908
	ctx.r[27].s64 = ctx.r[8].s64 + -10504;
	// 825CB388: 3B47D6F4  addi r26, r7, -0x290c
	ctx.r[26].s64 = ctx.r[7].s64 + -10508;
	// 825CB38C: 3B26D254  addi r25, r6, -0x2dac
	ctx.r[25].s64 = ctx.r[6].s64 + -11692;
	// 825CB390: 3B010050  addi r24, r1, 0x50
	ctx.r[24].s64 = ctx.r[1].s64 + 80;
	// 825CB394: 3AE10060  addi r23, r1, 0x60
	ctx.r[23].s64 = ctx.r[1].s64 + 96;
	// 825CB398: 48828909  bl 0x82df3ca0
	ctx.lr = 0x825CB39C;
	sub_82DF3CA0(ctx, base);
	// 825CB39C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CB3A0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825CB3A4: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 825CB3A8: 48828951  bl 0x82df3cf8
	ctx.lr = 0x825CB3AC;
	sub_82DF3CF8(ctx, base);
	// 825CB3AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CB3B0: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 825CB3B4: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 825CB3B8: 48828941  bl 0x82df3cf8
	ctx.lr = 0x825CB3BC;
	sub_82DF3CF8(ctx, base);
	// 825CB3BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CB3C0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825CB3C4: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 825CB3C8: 48828879  bl 0x82df3c40
	ctx.lr = 0x825CB3CC;
	sub_82DF3C40(ctx, base);
	// 825CB3CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CB3D0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825CB3D4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 825CB3D8: 48828921  bl 0x82df3cf8
	ctx.lr = 0x825CB3DC;
	sub_82DF3CF8(ctx, base);
	// 825CB3DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CB3E0: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 825CB3E4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825CB3E8: 48828911  bl 0x82df3cf8
	ctx.lr = 0x825CB3EC;
	sub_82DF3CF8(ctx, base);
	// 825CB3EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CB3F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825CB3F4: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 825CB3F8: 48828849  bl 0x82df3c40
	ctx.lr = 0x825CB3FC;
	sub_82DF3C40(ctx, base);
	// 825CB3FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CB400: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825CB404: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825CB408: 488288F1  bl 0x82df3cf8
	ctx.lr = 0x825CB40C;
	sub_82DF3CF8(ctx, base);
	// 825CB40C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CB410: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825CB414: 4882849D  bl 0x82df38b0
	ctx.lr = 0x825CB418;
	sub_82DF38B0(ctx, base);
	// 825CB418: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825CB41C: 4882800D  bl 0x82df3428
	ctx.lr = 0x825CB420;
	sub_82DF3428(ctx, base);
	// 825CB420: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825CB424: 48828005  bl 0x82df3428
	ctx.lr = 0x825CB428;
	sub_82DF3428(ctx, base);
	// 825CB428: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 825CB42C: 48827FFD  bl 0x82df3428
	ctx.lr = 0x825CB430;
	sub_82DF3428(ctx, base);
	// 825CB430: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825CB434: 48827FF5  bl 0x82df3428
	ctx.lr = 0x825CB438;
	sub_82DF3428(ctx, base);
	// 825CB438: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825CB43C: 48827FED  bl 0x82df3428
	ctx.lr = 0x825CB440;
	sub_82DF3428(ctx, base);
	// 825CB440: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 825CB444: 48827FE5  bl 0x82df3428
	ctx.lr = 0x825CB448;
	sub_82DF3428(ctx, base);
	// 825CB448: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825CB44C: 48827FDD  bl 0x82df3428
	ctx.lr = 0x825CB450;
	sub_82DF3428(ctx, base);
	// 825CB450: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 825CB454: 48827FD5  bl 0x82df3428
	ctx.lr = 0x825CB458;
	sub_82DF3428(ctx, base);
	// 825CB458: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CB45C: 48827FCD  bl 0x82df3428
	ctx.lr = 0x825CB460;
	sub_82DF3428(ctx, base);
	// 825CB460: 817E0148  lwz r11, 0x148(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(328 as u32) ) } as u64;
	// 825CB464: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825CB468: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 825CB46C: 7FEBE82E  lwzx r31, r11, r29
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 825CB470: 4BFFFBF1  bl 0x825cb060
	ctx.lr = 0x825CB474;
	sub_825CB060(ctx, base);
	// 825CB474: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CB478: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 825CB47C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825CB480: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 825CB484: 4BCFDCAD  bl 0x822c9130
	ctx.lr = 0x825CB488;
	sub_822C9130(ctx, base);
	// 825CB488: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825CB48C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825CB490: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 825CB494: 4BCFD99D  bl 0x822c8e30
	ctx.lr = 0x825CB498;
	sub_822C8E30(ctx, base);
	// 825CB498: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825CB49C: 48827F8D  bl 0x82df3428
	ctx.lr = 0x825CB4A0;
	sub_82DF3428(ctx, base);
	// 825CB4A0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825CB4A4: 48827F85  bl 0x82df3428
	ctx.lr = 0x825CB4A8;
	sub_82DF3428(ctx, base);
	// 825CB4A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825CB4AC: 48827F7D  bl 0x82df3428
	ctx.lr = 0x825CB4B0;
	sub_82DF3428(ctx, base);
	// 825CB4B0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825CB4B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825CB4B8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825CB4BC: 4BCFD975  bl 0x822c8e30
	ctx.lr = 0x825CB4C0;
	sub_822C8E30(ctx, base);
	// 825CB4C0: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 825CB4C4: 48BDCCE0  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CB4C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CB4C8 size=100
    let mut pc: u32 = 0x825CB4C8;
    'dispatch: loop {
        match pc {
            0x825CB4C8 => {
    //   block [0x825CB4C8..0x825CB52C)
	// 825CB4C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CB4CC: 48BDCCA1  bl 0x831a816c
	ctx.lr = 0x825CB4D0;
	sub_831A8130(ctx, base);
	// 825CB4D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CB4D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CB4D8: 83FE0138  lwz r31, 0x138(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(312 as u32) ) } as u64;
	// 825CB4DC: 4800003C  b 0x825cb518
	pc = 0x825CB518; continue 'dispatch;
	// 825CB4E0: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CB4E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CB4E8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CB4EC: 83A400C8  lwz r29, 0xc8(r4)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(200 as u32) ) } as u64;
	// 825CB4F0: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 825CB4F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CB4F8: 4E800421  bctrl
	ctx.lr = 0x825CB4FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CB4FC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825CB500: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825CB504: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CB508: 4BFFFC41  bl 0x825cb148
	ctx.lr = 0x825CB50C;
	sub_825CB148(ctx, base);
	// 825CB50C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CB510: 48827F19  bl 0x82df3428
	ctx.lr = 0x825CB514;
	sub_82DF3428(ctx, base);
	// 825CB514: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 825CB518: 817E013C  lwz r11, 0x13c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(316 as u32) ) } as u64;
	// 825CB51C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CB520: 409AFFC0  bne cr6, 0x825cb4e0
	if !ctx.cr[6].eq {
	pc = 0x825CB4E0; continue 'dispatch;
	}
	// 825CB524: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825CB528: 48BDCC94  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CB530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CB530 size=264
    let mut pc: u32 = 0x825CB530;
    'dispatch: loop {
        match pc {
            0x825CB530 => {
    //   block [0x825CB530..0x825CB638)
	// 825CB530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CB534: 48BDCC2D  bl 0x831a8160
	ctx.lr = 0x825CB538;
	sub_831A8130(ctx, base);
	// 825CB538: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CB53C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825CB540: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 825CB544: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CB548: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 825CB54C: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 825CB550: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CB554: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CB558: 894B0039  lbz r10, 0x39(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 825CB55C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825CB560: 409A0040  bne cr6, 0x825cb5a0
	if !ctx.cr[6].eq {
	pc = 0x825CB5A0; continue 'dispatch;
	}
	// 825CB564: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CB568: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825CB56C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 825CB570: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825CB574: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 825CB578: 41980008  blt cr6, 0x825cb580
	if ctx.cr[6].lt {
	pc = 0x825CB580; continue 'dispatch;
	}
	// 825CB57C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825CB580: 555D063F  clrlwi. r29, r10, 0x18
	ctx.r[29].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825CB584: 4182000C  beq 0x825cb590
	if ctx.cr[0].eq {
	pc = 0x825CB590; continue 'dispatch;
	}
	// 825CB588: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CB58C: 48000008  b 0x825cb594
	pc = 0x825CB594; continue 'dispatch;
	// 825CB590: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CB594: 894B0039  lbz r10, 0x39(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 825CB598: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825CB59C: 419AFFCC  beq cr6, 0x825cb568
	if ctx.cr[6].eq {
	pc = 0x825CB568; continue 'dispatch;
	}
	// 825CB5A0: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 825CB5A4: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CB5A8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825CB5AC: 41820048  beq 0x825cb5f4
	if ctx.cr[0].eq {
	pc = 0x825CB5F4; continue 'dispatch;
	}
	// 825CB5B0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CB5B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CB5B8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CB5BC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CB5C0: 409A002C  bne cr6, 0x825cb5ec
	if !ctx.cr[6].eq {
	pc = 0x825CB5EC; continue 'dispatch;
	}
	// 825CB5C4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825CB5C8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825CB5CC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825CB5D0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825CB5D4: 4BFFF775  bl 0x825cad48
	ctx.lr = 0x825CB5D8;
	sub_825CAD48(ctx, base);
	// 825CB5D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825CB5DC: 9B5F0004  stb r26, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u8 ) };
	// 825CB5E0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CB5E4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CB5E8: 48000044  b 0x825cb62c
	pc = 0x825CB62C; continue 'dispatch;
	// 825CB5EC: 485E240D  bl 0x82bad9f8
	ctx.lr = 0x825CB5F0;
	sub_82BAD9F8(ctx, base);
	// 825CB5F0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CB5F4: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 825CB5F8: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CB5FC: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825CB600: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 825CB604: 41980008  blt cr6, 0x825cb60c
	if ctx.cr[6].lt {
	pc = 0x825CB60C; continue 'dispatch;
	}
	// 825CB608: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CB60C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CB610: 41820010  beq 0x825cb620
	if ctx.cr[0].eq {
	pc = 0x825CB620; continue 'dispatch;
	}
	// 825CB614: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825CB618: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CB61C: 4BFFFFAC  b 0x825cb5c8
	pc = 0x825CB5C8; continue 'dispatch;
	// 825CB620: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CB624: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825CB628: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 825CB62C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CB630: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825CB634: 48BDCB7C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CB638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CB638 size=452
    let mut pc: u32 = 0x825CB638;
    'dispatch: loop {
        match pc {
            0x825CB638 => {
    //   block [0x825CB638..0x825CB7FC)
	// 825CB638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CB63C: 48BDCB21  bl 0x831a815c
	ctx.lr = 0x825CB640;
	sub_831A8130(ctx, base);
	// 825CB640: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CB644: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 825CB648: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CB64C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825CB650: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825CB654: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CB658: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CB65C: 409A0020  bne cr6, 0x825cb67c
	if !ctx.cr[6].eq {
	pc = 0x825CB67C; continue 'dispatch;
	}
	// 825CB660: 80DA0004  lwz r6, 4(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CB664: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825CB668: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 825CB66C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825CB670: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CB674: 4BFFF6D5  bl 0x825cad48
	ctx.lr = 0x825CB678;
	sub_825CAD48(ctx, base);
	// 825CB678: 48000178  b 0x825cb7f0
	pc = 0x825CB7F0; continue 'dispatch;
	// 825CB67C: 833A0004  lwz r25, 4(r26)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CB680: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CB684: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CB688: 409A002C  bne cr6, 0x825cb6b4
	if !ctx.cr[6].eq {
	pc = 0x825CB6B4; continue 'dispatch;
	}
	// 825CB68C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CB690: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825CB694: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825CB698: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825CB69C: 41980008  blt cr6, 0x825cb6a4
	if ctx.cr[6].lt {
	pc = 0x825CB6A4; continue 'dispatch;
	}
	// 825CB6A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CB6A4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CB6A8: 4182012C  beq 0x825cb7d4
	if ctx.cr[0].eq {
	pc = 0x825CB7D4; continue 'dispatch;
	}
	// 825CB6AC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825CB6B0: 4BFFFFB4  b 0x825cb664
	pc = 0x825CB664; continue 'dispatch;
	// 825CB6B4: 7F1EC840  cmplw cr6, r30, r25
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[25].u32, &mut ctx.xer);
	// 825CB6B8: 409A0030  bne cr6, 0x825cb6e8
	if !ctx.cr[6].eq {
	pc = 0x825CB6E8; continue 'dispatch;
	}
	// 825CB6BC: 80D90008  lwz r6, 8(r25)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CB6C0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CB6C4: 81460010  lwz r10, 0x10(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 825CB6C8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825CB6CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825CB6D0: 41980008  blt cr6, 0x825cb6d8
	if ctx.cr[6].lt {
	pc = 0x825CB6D8; continue 'dispatch;
	}
	// 825CB6D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CB6D8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CB6DC: 418200F8  beq 0x825cb7d4
	if ctx.cr[0].eq {
	pc = 0x825CB7D4; continue 'dispatch;
	}
	// 825CB6E0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825CB6E4: 4BFFFF84  b 0x825cb668
	pc = 0x825CB668; continue 'dispatch;
	// 825CB6E8: 839D0000  lwz r28, 0(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CB6EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825CB6F0: 837E0010  lwz r27, 0x10(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825CB6F4: 7F1CD800  cmpw cr6, r28, r27
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[27].s32, &mut ctx.xer);
	// 825CB6F8: 41980008  blt cr6, 0x825cb700
	if ctx.cr[6].lt {
	pc = 0x825CB700; continue 'dispatch;
	}
	// 825CB6FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CB700: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CB704: 41820060  beq 0x825cb764
	if ctx.cr[0].eq {
	pc = 0x825CB764; continue 'dispatch;
	}
	// 825CB708: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825CB70C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CB710: 485E22E9  bl 0x82bad9f8
	ctx.lr = 0x825CB714;
	sub_82BAD9F8(ctx, base);
	// 825CB714: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CB718: 81660010  lwz r11, 0x10(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 825CB71C: 7F0BE000  cmpw cr6, r11, r28
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[28].s32, &mut ctx.xer);
	// 825CB720: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825CB724: 41980008  blt cr6, 0x825cb72c
	if ctx.cr[6].lt {
	pc = 0x825CB72C; continue 'dispatch;
	}
	// 825CB728: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CB72C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CB730: 41820034  beq 0x825cb764
	if ctx.cr[0].eq {
	pc = 0x825CB764; continue 'dispatch;
	}
	// 825CB734: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CB738: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 825CB73C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825CB740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CB744: 896B0039  lbz r11, 0x39(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 825CB748: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CB74C: 419A000C  beq cr6, 0x825cb758
	if ctx.cr[6].eq {
	pc = 0x825CB758; continue 'dispatch;
	}
	// 825CB750: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825CB754: 4BFFFF20  b 0x825cb674
	pc = 0x825CB674; continue 'dispatch;
	// 825CB758: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825CB75C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825CB760: 4BFFFF14  b 0x825cb674
	pc = 0x825CB674; continue 'dispatch;
	// 825CB764: 7F1BE000  cmpw cr6, r27, r28
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[28].s32, &mut ctx.xer);
	// 825CB768: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825CB76C: 41980008  blt cr6, 0x825cb774
	if ctx.cr[6].lt {
	pc = 0x825CB774; continue 'dispatch;
	}
	// 825CB770: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CB774: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CB778: 4182005C  beq 0x825cb7d4
	if ctx.cr[0].eq {
	pc = 0x825CB7D4; continue 'dispatch;
	}
	// 825CB77C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825CB780: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CB784: 4BFFF05D  bl 0x825ca7e0
	ctx.lr = 0x825CB788;
	sub_825CA7E0(ctx, base);
	// 825CB788: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CB78C: 7F06C840  cmplw cr6, r6, r25
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[25].u32, &mut ctx.xer);
	// 825CB790: 419A0020  beq cr6, 0x825cb7b0
	if ctx.cr[6].eq {
	pc = 0x825CB7B0; continue 'dispatch;
	}
	// 825CB794: 81660010  lwz r11, 0x10(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 825CB798: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825CB79C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825CB7A0: 41980008  blt cr6, 0x825cb7a8
	if ctx.cr[6].lt {
	pc = 0x825CB7A8; continue 'dispatch;
	}
	// 825CB7A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CB7A8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CB7AC: 41820028  beq 0x825cb7d4
	if ctx.cr[0].eq {
	pc = 0x825CB7D4; continue 'dispatch;
	}
	// 825CB7B0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CB7B4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 825CB7B8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825CB7BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CB7C0: 896B0039  lbz r11, 0x39(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 825CB7C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CB7C8: 419AFF94  beq cr6, 0x825cb75c
	if ctx.cr[6].eq {
	pc = 0x825CB75C; continue 'dispatch;
	}
	// 825CB7CC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825CB7D0: 4BFFFF80  b 0x825cb750
	pc = 0x825CB750; continue 'dispatch;
	// 825CB7D4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825CB7D8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825CB7DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CB7E0: 4BFFFD51  bl 0x825cb530
	ctx.lr = 0x825CB7E4;
	sub_825CB530(ctx, base);
	// 825CB7E4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825CB7E8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CB7EC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CB7F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CB7F4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825CB7F8: 48BDC9B4  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CB800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CB800 size=84
    let mut pc: u32 = 0x825CB800;
    'dispatch: loop {
        match pc {
            0x825CB800 => {
    //   block [0x825CB800..0x825CB854)
	// 825CB800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CB804: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CB808: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CB80C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CB810: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CB814: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CB818: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CB81C: 4BFFF755  bl 0x825caf70
	ctx.lr = 0x825CB820;
	sub_825CAF70(ctx, base);
	// 825CB820: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CB824: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CB828: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825CB82C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825CB830: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CB834: 914A0000  stw r10, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825CB838: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CB83C: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825CB840: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825CB844: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CB848: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CB84C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CB850: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CB858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CB858 size=140
    let mut pc: u32 = 0x825CB858;
    'dispatch: loop {
        match pc {
            0x825CB858 => {
    //   block [0x825CB858..0x825CB8E4)
	// 825CB858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CB85C: 48BDC911  bl 0x831a816c
	ctx.lr = 0x825CB860;
	sub_831A8130(ctx, base);
	// 825CB860: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CB864: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825CB868: F8A100A8  std r5, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[5].u64 ) };
	// 825CB86C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825CB870: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CB874: 3BEB7D2C  addi r31, r11, 0x7d2c
	ctx.r[31].s64 = ctx.r[11].s64 + 32044;
	// 825CB878: 816A7D34  lwz r11, 0x7d34(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32052 as u32) ) } as u64;
	// 825CB87C: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825CB880: 40820024  bne 0x825cb8a4
	if !ctx.cr[0].eq {
	pc = 0x825CB8A4; continue 'dispatch;
	}
	// 825CB884: 3D20825D  lis r9, -0x7da3
	ctx.r[9].s64 = -2107834368;
	// 825CB888: 3D00825D  lis r8, -0x7da3
	ctx.r[8].s64 = -2107834368;
	// 825CB88C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825CB890: 3929AD18  addi r9, r9, -0x52e8
	ctx.r[9].s64 = ctx.r[9].s64 + -21224;
	// 825CB894: 3908A9D8  addi r8, r8, -0x5628
	ctx.r[8].s64 = ctx.r[8].s64 + -22056;
	// 825CB898: 916A7D34  stw r11, 0x7d34(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32052 as u32), ctx.r[11].u32 ) };
	// 825CB89C: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825CB8A0: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825CB8A4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825CB8A8: 814100A8  lwz r10, 0xa8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 825CB8AC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825CB8B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CB8B4: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 825CB8B8: 794507E6  rldicr r5, r10, 0x20, 0x3f
	ctx.r[5].u64 = (ctx.r[10].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 825CB8BC: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825CB8C0: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CB8C4: 4BD3BDFD  bl 0x823076c0
	ctx.lr = 0x825CB8C8;
	sub_823076C0(ctx, base);
	// 825CB8C8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CB8CC: 4182000C  beq 0x825cb8d8
	if ctx.cr[0].eq {
	pc = 0x825CB8D8; continue 'dispatch;
	}
	// 825CB8D0: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825CB8D4: 48000008  b 0x825cb8dc
	pc = 0x825CB8DC; continue 'dispatch;
	// 825CB8D8: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825CB8DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825CB8E0: 48BDC8DC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CB8E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CB8E8 size=136
    let mut pc: u32 = 0x825CB8E8;
    'dispatch: loop {
        match pc {
            0x825CB8E8 => {
    //   block [0x825CB8E8..0x825CB970)
	// 825CB8E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CB8EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CB8F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CB8F4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CB8F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CB8FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CB900: 38BF0108  addi r5, r31, 0x108
	ctx.r[5].s64 = ctx.r[31].s64 + 264;
	// 825CB904: 389F00C0  addi r4, r31, 0xc0
	ctx.r[4].s64 = ctx.r[31].s64 + 192;
	// 825CB908: 4BFFF269  bl 0x825cab70
	ctx.lr = 0x825CB90C;
	sub_825CAB70(ctx, base);
	// 825CB90C: 815F00C4  lwz r10, 0xc4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 825CB910: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CB914: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825CB918: 419A0044  beq cr6, 0x825cb95c
	if ctx.cr[6].eq {
	pc = 0x825CB95C; continue 'dispatch;
	}
	// 825CB91C: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825CB920: 386B0018  addi r3, r11, 0x18
	ctx.r[3].s64 = ctx.r[11].s64 + 24;
	// 825CB924: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825CB928: 419A0034  beq cr6, 0x825cb95c
	if ctx.cr[6].eq {
	pc = 0x825CB95C; continue 'dispatch;
	}
	// 825CB92C: 3D60822C  lis r11, -0x7dd4
	ctx.r[11].s64 = -2111045632;
	// 825CB930: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 825CB934: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CB938: 419A0024  beq cr6, 0x825cb95c
	if ctx.cr[6].eq {
	pc = 0x825CB95C; continue 'dispatch;
	}
	// 825CB93C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CB940: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CB944: 419A0018  beq cr6, 0x825cb95c
	if ctx.cr[6].eq {
	pc = 0x825CB95C; continue 'dispatch;
	}
	// 825CB948: 3D60822C  lis r11, -0x7dd4
	ctx.r[11].s64 = -2111045632;
	// 825CB94C: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 825CB950: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CB954: 419A0008  beq cr6, 0x825cb95c
	if ctx.cr[6].eq {
	pc = 0x825CB95C; continue 'dispatch;
	}
	// 825CB958: 4BE87D29  bl 0x82453680
	ctx.lr = 0x825CB95C;
	sub_82453680(ctx, base);
	// 825CB95C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CB960: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CB964: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CB968: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CB96C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CB970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CB970 size=16
    let mut pc: u32 = 0x825CB970;
    'dispatch: loop {
        match pc {
            0x825CB970 => {
    //   block [0x825CB970..0x825CB980)
	// 825CB970: 386300E8  addi r3, r3, 0xe8
	ctx.r[3].s64 = ctx.r[3].s64 + 232;
	// 825CB974: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CB978: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CB97C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CB980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CB980 size=16
    let mut pc: u32 = 0x825CB980;
    'dispatch: loop {
        match pc {
            0x825CB980 => {
    //   block [0x825CB980..0x825CB990)
	// 825CB980: 3D60822C  lis r11, -0x7dd4
	ctx.r[11].s64 = -2111045632;
	// 825CB984: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 825CB988: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CB98C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CB990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CB990 size=8
    let mut pc: u32 = 0x825CB990;
    'dispatch: loop {
        match pc {
            0x825CB990 => {
    //   block [0x825CB990..0x825CB998)
	// 825CB990: 4BE87CF0  b 0x82453680
	sub_82453680(ctx, base);
	return;
	// 825CB994: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CB998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CB998 size=136
    let mut pc: u32 = 0x825CB998;
    'dispatch: loop {
        match pc {
            0x825CB998 => {
    //   block [0x825CB998..0x825CBA20)
	// 825CB998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CB99C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CB9A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CB9A4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CB9A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CB9AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CB9B0: 38BF0108  addi r5, r31, 0x108
	ctx.r[5].s64 = ctx.r[31].s64 + 264;
	// 825CB9B4: 389F00CC  addi r4, r31, 0xcc
	ctx.r[4].s64 = ctx.r[31].s64 + 204;
	// 825CB9B8: 4BFFF1B9  bl 0x825cab70
	ctx.lr = 0x825CB9BC;
	sub_825CAB70(ctx, base);
	// 825CB9BC: 815F00C4  lwz r10, 0xc4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 825CB9C0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CB9C4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825CB9C8: 419A0044  beq cr6, 0x825cba0c
	if ctx.cr[6].eq {
	pc = 0x825CBA0C; continue 'dispatch;
	}
	// 825CB9CC: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825CB9D0: 386B0018  addi r3, r11, 0x18
	ctx.r[3].s64 = ctx.r[11].s64 + 24;
	// 825CB9D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825CB9D8: 419A0034  beq cr6, 0x825cba0c
	if ctx.cr[6].eq {
	pc = 0x825CBA0C; continue 'dispatch;
	}
	// 825CB9DC: 3D60822C  lis r11, -0x7dd4
	ctx.r[11].s64 = -2111045632;
	// 825CB9E0: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 825CB9E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CB9E8: 419A0024  beq cr6, 0x825cba0c
	if ctx.cr[6].eq {
	pc = 0x825CBA0C; continue 'dispatch;
	}
	// 825CB9EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CB9F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CB9F4: 419A0018  beq cr6, 0x825cba0c
	if ctx.cr[6].eq {
	pc = 0x825CBA0C; continue 'dispatch;
	}
	// 825CB9F8: 3D60822C  lis r11, -0x7dd4
	ctx.r[11].s64 = -2111045632;
	// 825CB9FC: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 825CBA00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CBA04: 419A0008  beq cr6, 0x825cba0c
	if ctx.cr[6].eq {
	pc = 0x825CBA0C; continue 'dispatch;
	}
	// 825CBA08: 4BE87C79  bl 0x82453680
	ctx.lr = 0x825CBA0C;
	sub_82453680(ctx, base);
	// 825CBA0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CBA10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CBA14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CBA18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CBA1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CBA20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CBA20 size=76
    let mut pc: u32 = 0x825CBA20;
    'dispatch: loop {
        match pc {
            0x825CBA20 => {
    //   block [0x825CBA20..0x825CBA6C)
	// 825CBA20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CBA24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CBA28: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CBA2C: 80830108  lwz r4, 0x108(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(264 as u32) ) } as u64;
	// 825CBA30: 394000FF  li r10, 0xff
	ctx.r[10].s64 = 255;
	// 825CBA34: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CBA38: 38630144  addi r3, r3, 0x144
	ctx.r[3].s64 = ctx.r[3].s64 + 324;
	// 825CBA3C: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 825CBA40: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 825CBA44: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 825CBA48: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 825CBA4C: 4BFD5A85  bl 0x825a14d0
	ctx.lr = 0x825CBA50;
	sub_825A14D0(ctx, base);
	// 825CBA50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CBA54: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CBA58: 914B00B8  stw r10, 0xb8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(184 as u32), ctx.r[10].u32 ) };
	// 825CBA5C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825CBA60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CBA64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CBA68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CBA70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CBA70 size=156
    let mut pc: u32 = 0x825CBA70;
    'dispatch: loop {
        match pc {
            0x825CBA70 => {
    //   block [0x825CBA70..0x825CBB0C)
	// 825CBA70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CBA74: 48BDC6F9  bl 0x831a816c
	ctx.lr = 0x825CBA78;
	sub_831A8130(ctx, base);
	// 825CBA78: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CBA7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CBA80: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825CBA84: 4BFFEEFD  bl 0x825ca980
	ctx.lr = 0x825CBA88;
	sub_825CA980(ctx, base);
	// 825CBA88: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CBA8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CBA90: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CBA94: 419A0024  beq cr6, 0x825cbab8
	if ctx.cr[6].eq {
	pc = 0x825CBAB8; continue 'dispatch;
	}
	// 825CBA98: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CBA9C: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825CBAA0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825CBAA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825CBAA8: 41980008  blt cr6, 0x825cbab0
	if ctx.cr[6].lt {
	pc = 0x825CBAB0; continue 'dispatch;
	}
	// 825CBAAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CBAB0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CBAB4: 4182004C  beq 0x825cbb00
	if ctx.cr[0].eq {
	pc = 0x825CBB00; continue 'dispatch;
	}
	// 825CBAB8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CBABC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825CBAC0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825CBAC4: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825CBAC8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825CBACC: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 825CBAD0: 4BFC0441  bl 0x8258bf10
	ctx.lr = 0x825CBAD4;
	sub_8258BF10(ctx, base);
	// 825CBAD4: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 825CBAD8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825CBADC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CBAE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CBAE4: 4BFFFB55  bl 0x825cb638
	ctx.lr = 0x825CBAE8;
	sub_825CB638(ctx, base);
	// 825CBAE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825CBAEC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825CBAF0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CBAF4: 4BCFD1C5  bl 0x822c8cb8
	ctx.lr = 0x825CBAF8;
	sub_822C8CB8(ctx, base);
	// 825CBAF8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825CBAFC: 4BCFD1BD  bl 0x822c8cb8
	ctx.lr = 0x825CBB00;
	sub_822C8CB8(ctx, base);
	// 825CBB00: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 825CBB04: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 825CBB08: 48BDC6B4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CBB10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CBB10 size=212
    let mut pc: u32 = 0x825CBB10;
    'dispatch: loop {
        match pc {
            0x825CBB10 => {
    //   block [0x825CBB10..0x825CBBE4)
	// 825CBB10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CBB14: 48BDC651  bl 0x831a8164
	ctx.lr = 0x825CBB18;
	sub_831A8130(ctx, base);
	// 825CBB18: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CBB1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CBB20: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825CBB24: 3B7F00B0  addi r27, r31, 0xb0
	ctx.r[27].s64 = ctx.r[31].s64 + 176;
	// 825CBB28: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825CBB2C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825CBB30: E97F010A  lwa r11, 0x108(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as i32) as i64;
	// 825CBB34: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 825CBB38: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825CBB3C: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 825CBB40: 813F010C  lwz r9, 0x10c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 825CBB44: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825CBB48: C00AD6F0  lfs f0, -0x2910(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10512 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CBB4C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825CBB50: D00900B0  stfs f0, 0xb0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 825CBB54: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CBB58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CBB5C: 419A0080  beq cr6, 0x825cbbdc
	if ctx.cr[6].eq {
	pc = 0x825CBBDC; continue 'dispatch;
	}
	// 825CBB60: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CBB64: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825CBB68: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825CBB6C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CBB70: 4098006C  bge cr6, 0x825cbbdc
	if !ctx.cr[6].lt {
	pc = 0x825CBBDC; continue 'dispatch;
	}
	// 825CBB74: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825CBB78: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825CBB7C: 817F00B4  lwz r11, 0xb4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 825CBB80: 387F00D8  addi r3, r31, 0xd8
	ctx.r[3].s64 = ctx.r[31].s64 + 216;
	// 825CBB84: 7F8BE82E  lwzx r28, r11, r29
	ctx.r[28].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 825CBB88: 4BFFFEE9  bl 0x825cba70
	ctx.lr = 0x825CBB8C;
	sub_825CBA70(ctx, base);
	// 825CBB8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CBB90: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825CBB94: 4BFFF445  bl 0x825cafd8
	ctx.lr = 0x825CBB98;
	sub_825CAFD8(ctx, base);
	// 825CBB98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CBB9C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825CBBA0: 4BFFF4C1  bl 0x825cb060
	ctx.lr = 0x825CBBA4;
	sub_825CB060(ctx, base);
	// 825CBBA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CBBA8: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 825CBBAC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825CBBB0: 387C0090  addi r3, r28, 0x90
	ctx.r[3].s64 = ctx.r[28].s64 + 144;
	// 825CBBB4: 4BCFD57D  bl 0x822c9130
	ctx.lr = 0x825CBBB8;
	sub_822C9130(ctx, base);
	// 825CBBB8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825CBBBC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825CBBC0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825CBBC4: 4BCFD26D  bl 0x822c8e30
	ctx.lr = 0x825CBBC8;
	sub_822C8E30(ctx, base);
	// 825CBBC8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825CBBCC: 4882785D  bl 0x82df3428
	ctx.lr = 0x825CBBD0;
	sub_82DF3428(ctx, base);
	// 825CBBD0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 825CBBD4: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 825CBBD8: 4BFFFF7C  b 0x825cbb54
	pc = 0x825CBB54; continue 'dispatch;
	// 825CBBDC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825CBBE0: 48BDC5D4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CBBE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CBBE8 size=724
    let mut pc: u32 = 0x825CBBE8;
    'dispatch: loop {
        match pc {
            0x825CBBE8 => {
    //   block [0x825CBBE8..0x825CBEBC)
	// 825CBBE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CBBEC: 48BDC581  bl 0x831a816c
	ctx.lr = 0x825CBBF0;
	sub_831A8130(ctx, base);
	// 825CBBF0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CBBF4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CBBF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CBBFC: 807E0034  lwz r3, 0x34(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 825CBC00: 4837B351  bl 0x82946f50
	ctx.lr = 0x825CBC04;
	sub_82946F50(ctx, base);
	// 825CBC04: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CBC08: 408202AC  bne 0x825cbeb4
	if !ctx.cr[0].eq {
	pc = 0x825CBEB4; continue 'dispatch;
	}
	// 825CBC0C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CBC10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CBC14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CBC18: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 825CBC1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CBC20: 4E800421  bctrl
	ctx.lr = 0x825CBC24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CBC24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CBC28: 4BFFF8A1  bl 0x825cb4c8
	ctx.lr = 0x825CBC2C;
	sub_825CB4C8(ctx, base);
	// 825CBC2C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CBC30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CBC34: 4BFFFEDD  bl 0x825cbb10
	ctx.lr = 0x825CBC38;
	sub_825CBB10(ctx, base);
	// 825CBC38: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	// 825CBC3C: 807D1494  lwz r3, 0x1494(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(5268 as u32) ) } as u64;
	// 825CBC40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CBC44: 409A000C  bne cr6, 0x825cbc50
	if !ctx.cr[6].eq {
	pc = 0x825CBC50; continue 'dispatch;
	}
	// 825CBC48: 4BCF4B29  bl 0x822c0770
	ctx.lr = 0x825CBC4C;
	sub_822C0770(ctx, base);
	// 825CBC4C: 907D1494  stw r3, 0x1494(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(5268 as u32), ctx.r[3].u32 ) };
	// 825CBC50: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825CBC54: 488D370D  bl 0x82e9f360
	ctx.lr = 0x825CBC58;
	sub_82E9F360(ctx, base);
	// 825CBC58: 817F0130  lwz r11, 0x130(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 825CBC5C: A1430002  lhz r10, 2(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(2 as u32) ) } as u64;
	// 825CBC60: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825CBC64: 4198022C  blt cr6, 0x825cbe90
	if ctx.cr[6].lt {
	pc = 0x825CBE90; continue 'dispatch;
	}
	// 825CBC68: 419A00B0  beq cr6, 0x825cbd18
	if ctx.cr[6].eq {
	pc = 0x825CBD18; continue 'dispatch;
	}
	// 825CBC6C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 825CBC70: 40980234  bge cr6, 0x825cbea4
	if !ctx.cr[6].lt {
	pc = 0x825CBEA4; continue 'dispatch;
	}
	// 825CBC74: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CBC78: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 825CBC7C: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CBC80: 41820028  beq 0x825cbca8
	if ctx.cr[0].eq {
	pc = 0x825CBCA8; continue 'dispatch;
	}
	// 825CBC84: 93BF0130  stw r29, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[29].u32 ) };
	// 825CBC88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CBC8C: 4BFFEE9D  bl 0x825cab28
	ctx.lr = 0x825CBC90;
	sub_825CAB28(ctx, base);
	// 825CBC90: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CBC94: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CBC98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CBC9C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825CBCA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CBCA4: 4E800421  bctrl
	ctx.lr = 0x825CBCA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CBCA8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CBCAC: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CBCB0: 41820028  beq 0x825cbcd8
	if ctx.cr[0].eq {
	pc = 0x825CBCD8; continue 'dispatch;
	}
	// 825CBCB4: 93BF0130  stw r29, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[29].u32 ) };
	// 825CBCB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CBCBC: 4BFFEE6D  bl 0x825cab28
	ctx.lr = 0x825CBCC0;
	sub_825CAB28(ctx, base);
	// 825CBCC0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CBCC4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CBCC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CBCCC: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825CBCD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CBCD4: 4E800421  bctrl
	ctx.lr = 0x825CBCD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CBCD8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CBCDC: 556B06F7  rlwinm. r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CBCE0: 4182001C  beq 0x825cbcfc
	if ctx.cr[0].eq {
	pc = 0x825CBCFC; continue 'dispatch;
	}
	// 825CBCE4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CBCE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CBCEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CBCF0: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 825CBCF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CBCF8: 4E800421  bctrl
	ctx.lr = 0x825CBCFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CBCFC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CBD00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CBD04: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 825CBD08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CBD0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CBD10: 4E800421  bctrl
	ctx.lr = 0x825CBD14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CBD14: 48000190  b 0x825cbea4
	pc = 0x825CBEA4; continue 'dispatch;
	// 825CBD18: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CBD1C: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825CBD20: 4082013C  bne 0x825cbe5c
	if !ctx.cr[0].eq {
	pc = 0x825CBE5C; continue 'dispatch;
	}
	// 825CBD24: 2B0A0028  cmplwi cr6, r10, 0x28
	ctx.cr[6].compare_u32(ctx.r[10].u32, 40 as u32, &mut ctx.xer);
	// 825CBD28: 419A0134  beq cr6, 0x825cbe5c
	if ctx.cr[6].eq {
	pc = 0x825CBE5C; continue 'dispatch;
	}
	// 825CBD2C: 2B0A004F  cmplwi cr6, r10, 0x4f
	ctx.cr[6].compare_u32(ctx.r[10].u32, 79 as u32, &mut ctx.xer);
	// 825CBD30: 419A012C  beq cr6, 0x825cbe5c
	if ctx.cr[6].eq {
	pc = 0x825CBE5C; continue 'dispatch;
	}
	// 825CBD34: 556A07BD  rlwinm. r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825CBD38: 408200FC  bne 0x825cbe34
	if !ctx.cr[0].eq {
	pc = 0x825CBE34; continue 'dispatch;
	}
	// 825CBD3C: 556A06F7  rlwinm. r10, r11, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825CBD40: 41820014  beq 0x825cbd54
	if ctx.cr[0].eq {
	pc = 0x825CBD54; continue 'dispatch;
	}
	// 825CBD44: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CBD48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CBD4C: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 825CBD50: 4BFFFFB8  b 0x825cbd08
	pc = 0x825CBD08; continue 'dispatch;
	// 825CBD54: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CBD58: 554A0529  rlwinm. r10, r10, 0, 0x14, 0x14
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825CBD5C: 41820018  beq 0x825cbd74
	if ctx.cr[0].eq {
	pc = 0x825CBD74; continue 'dispatch;
	}
	// 825CBD60: 556A0739  rlwinm. r10, r11, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825CBD64: 41820010  beq 0x825cbd74
	if ctx.cr[0].eq {
	pc = 0x825CBD74; continue 'dispatch;
	}
	// 825CBD68: 807E0034  lwz r3, 0x34(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 825CBD6C: 4BFF69D5  bl 0x825c2740
	ctx.lr = 0x825CBD70;
	sub_825C2740(ctx, base);
	// 825CBD70: 48000134  b 0x825cbea4
	pc = 0x825CBEA4; continue 'dispatch;
	// 825CBD74: 556B0739  rlwinm. r11, r11, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CBD78: 41820018  beq 0x825cbd90
	if ctx.cr[0].eq {
	pc = 0x825CBD90; continue 'dispatch;
	}
	// 825CBD7C: 807F0154  lwz r3, 0x154(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 825CBD80: 809F0108  lwz r4, 0x108(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 825CBD84: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CBD88: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825CBD8C: 4BFFFF80  b 0x825cbd0c
	pc = 0x825CBD0C; continue 'dispatch;
	// 825CBD90: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CBD94: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 825CBD98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CBD9C: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 825CBDA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CBDA4: 4E800421  bctrl
	ctx.lr = 0x825CBDA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CBDA8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CBDAC: 41820038  beq 0x825cbde4
	if ctx.cr[0].eq {
	pc = 0x825CBDE4; continue 'dispatch;
	}
	// 825CBDB0: 817F00A4  lwz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 825CBDB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CBDB8: 419A0010  beq cr6, 0x825cbdc8
	if ctx.cr[6].eq {
	pc = 0x825CBDC8; continue 'dispatch;
	}
	// 825CBDBC: 815F00A8  lwz r10, 0xa8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 825CBDC0: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825CBDC4: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825CBDC8: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 825CBDCC: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 825CBDD0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825CBDD4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825CBDD8: 40990054  ble cr6, 0x825cbe2c
	if !ctx.cr[6].gt {
	pc = 0x825CBE2C; continue 'dispatch;
	}
	// 825CBDDC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CBDE0: 4800004C  b 0x825cbe2c
	pc = 0x825CBE2C; continue 'dispatch;
	// 825CBDE4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CBDE8: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 825CBDEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CBDF0: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 825CBDF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CBDF8: 4E800421  bctrl
	ctx.lr = 0x825CBDFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CBDFC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CBE00: 418200A4  beq 0x825cbea4
	if ctx.cr[0].eq {
	pc = 0x825CBEA4; continue 'dispatch;
	}
	// 825CBE04: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 825CBE08: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CBE0C: 40800020  bge 0x825cbe2c
	if !ctx.cr[0].lt {
	pc = 0x825CBE2C; continue 'dispatch;
	}
	// 825CBE10: 817F00A4  lwz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 825CBE14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CBE18: 419A0010  beq cr6, 0x825cbe28
	if ctx.cr[6].eq {
	pc = 0x825CBE28; continue 'dispatch;
	}
	// 825CBE1C: 815F00A8  lwz r10, 0xa8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 825CBE20: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825CBE24: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825CBE28: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825CBE2C: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 825CBE30: 48000074  b 0x825cbea4
	pc = 0x825CBEA4; continue 'dispatch;
	// 825CBE34: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 825CBE38: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 825CBE3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CBE40: 419A0064  beq cr6, 0x825cbea4
	if ctx.cr[6].eq {
	pc = 0x825CBEA4; continue 'dispatch;
	}
	// 825CBE44: 3D60822C  lis r11, -0x7dd4
	ctx.r[11].s64 = -2111045632;
	// 825CBE48: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 825CBE4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CBE50: 419A0054  beq cr6, 0x825cbea4
	if ctx.cr[6].eq {
	pc = 0x825CBEA4; continue 'dispatch;
	}
	// 825CBE54: 4BE8782D  bl 0x82453680
	ctx.lr = 0x825CBE58;
	sub_82453680(ctx, base);
	// 825CBE58: 4800004C  b 0x825cbea4
	pc = 0x825CBEA4; continue 'dispatch;
	// 825CBE5C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CBE60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CBE64: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CBE68: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 825CBE6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CBE70: 4E800421  bctrl
	ctx.lr = 0x825CBE74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CBE74: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CBE78: 4182002C  beq 0x825cbea4
	if ctx.cr[0].eq {
	pc = 0x825CBEA4; continue 'dispatch;
	}
	// 825CBE7C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 825CBE80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CBE84: 917F0130  stw r11, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 825CBE88: 4BFFFB99  bl 0x825cba20
	ctx.lr = 0x825CBE8C;
	sub_825CBA20(ctx, base);
	// 825CBE8C: 48000018  b 0x825cbea4
	pc = 0x825CBEA4; continue 'dispatch;
	// 825CBE90: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CBE94: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CBE98: 4082000C  bne 0x825cbea4
	if !ctx.cr[0].eq {
	pc = 0x825CBEA4; continue 'dispatch;
	}
	// 825CBE9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825CBEA0: 917F0130  stw r11, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 825CBEA4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825CBEA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CBEAC: 419A0008  beq cr6, 0x825cbeb4
	if ctx.cr[6].eq {
	pc = 0x825CBEB4; continue 'dispatch;
	}
	// 825CBEB0: 4BCF49E1  bl 0x822c0890
	ctx.lr = 0x825CBEB4;
	sub_822C0890(ctx, base);
	// 825CBEB4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825CBEB8: 48BDC304  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CBEC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CBEC0 size=88
    let mut pc: u32 = 0x825CBEC0;
    'dispatch: loop {
        match pc {
            0x825CBEC0 => {
    //   block [0x825CBEC0..0x825CBF18)
	// 825CBEC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CBEC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CBEC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CBECC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CBED0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CBED4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CBED8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CBEDC: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CBEE0: 80A60000  lwz r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CBEE4: 4BFE8435  bl 0x825b4318
	ctx.lr = 0x825CBEE8;
	sub_825B4318(ctx, base);
	// 825CBEE8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825CBEEC: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CBEF0: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 825CBEF4: 48826295  bl 0x82df2188
	ctx.lr = 0x825CBEF8;
	sub_82DF2188(ctx, base);
	// 825CBEF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CBEFC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825CBF00: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825CBF04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CBF08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CBF0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CBF10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CBF14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CBF18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CBF18 size=116
    let mut pc: u32 = 0x825CBF18;
    'dispatch: loop {
        match pc {
            0x825CBF18 => {
    //   block [0x825CBF18..0x825CBF8C)
	// 825CBF18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CBF1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CBF20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CBF24: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CBF28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CBF2C: 48AF6C5D  bl 0x830c2b88
	ctx.lr = 0x825CBF30;
	sub_830C2B88(ctx, base);
	// 825CBF30: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825CBF34: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CBF38: 392AD76C  addi r9, r10, -0x2894
	ctx.r[9].s64 = ctx.r[10].s64 + -10388;
	// 825CBF3C: 394000FF  li r10, 0xff
	ctx.r[10].s64 = 255;
	// 825CBF40: 390000C8  li r8, 0xc8
	ctx.r[8].s64 = 200;
	// 825CBF44: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825CBF48: 917F00A4  stw r11, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 825CBF4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CBF50: 917F00A8  stw r11, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 825CBF54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825CBF58: 917F00AC  stw r11, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 825CBF5C: 997F0090  stb r11, 0x90(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u8 ) };
	// 825CBF60: 99010050  stb r8, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u8 ) };
	// 825CBF64: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 825CBF68: 99410052  stb r10, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[10].u8 ) };
	// 825CBF6C: 99410053  stb r10, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[10].u8 ) };
	// 825CBF70: 48AF7131  bl 0x830c30a0
	ctx.lr = 0x825CBF74;
	sub_830C30A0(ctx, base);
	// 825CBF74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CBF78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CBF7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CBF80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CBF84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CBF88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CBF90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CBF90 size=100
    let mut pc: u32 = 0x825CBF90;
    'dispatch: loop {
        match pc {
            0x825CBF90 => {
    //   block [0x825CBF90..0x825CBFF4)
	// 825CBF90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CBF94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CBF98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CBF9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CBFA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CBFA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CBFA8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CBFAC: 387F00A0  addi r3, r31, 0xa0
	ctx.r[3].s64 = ctx.r[31].s64 + 160;
	// 825CBFB0: 396BD76C  addi r11, r11, -0x2894
	ctx.r[11].s64 = ctx.r[11].s64 + -10388;
	// 825CBFB4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CBFB8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CBFBC: 4BEE52E5  bl 0x824b12a0
	ctx.lr = 0x825CBFC0;
	sub_824B12A0(ctx, base);
	// 825CBFC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CBFC4: 48AF6B25  bl 0x830c2ae8
	ctx.lr = 0x825CBFC8;
	sub_830C2AE8(ctx, base);
	// 825CBFC8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CBFCC: 4182000C  beq 0x825cbfd8
	if ctx.cr[0].eq {
	pc = 0x825CBFD8; continue 'dispatch;
	}
	// 825CBFD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CBFD4: 4BCF4295  bl 0x822c0268
	ctx.lr = 0x825CBFD8;
	sub_822C0268(ctx, base);
	// 825CBFD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CBFDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CBFE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CBFE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CBFE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CBFEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CBFF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CBFF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CBFF8 size=408
    let mut pc: u32 = 0x825CBFF8;
    'dispatch: loop {
        match pc {
            0x825CBFF8 => {
    //   block [0x825CBFF8..0x825CC190)
	// 825CBFF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CBFFC: 48BDC169  bl 0x831a8164
	ctx.lr = 0x825CC000;
	sub_831A8130(ctx, base);
	// 825CC000: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CC004: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CC008: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825CC00C: 3BFE00A0  addi r31, r30, 0xa0
	ctx.r[31].s64 = ctx.r[30].s64 + 160;
	// 825CC010: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CC014: 4BD22D15  bl 0x822eed28
	ctx.lr = 0x825CC018;
	sub_822EED28(ctx, base);
	// 825CC018: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CC01C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825CC020: 388BD710  addi r4, r11, -0x28f0
	ctx.r[4].s64 = ctx.r[11].s64 + -10480;
	// 825CC024: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825CC028: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825CC02C: 38A00079  li r5, 0x79
	ctx.r[5].s64 = 121;
	// 825CC030: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 825CC034: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 825CC038: 4BCF43A1  bl 0x822c03d8
	ctx.lr = 0x825CC03C;
	sub_822C03D8(ctx, base);
	// 825CC03C: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825CC040: 418200AC  beq 0x825cc0ec
	if ctx.cr[0].eq {
	pc = 0x825CC0EC; continue 'dispatch;
	}
	// 825CC044: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CC048: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CC04C: 409A000C  bne cr6, 0x825cc058
	if !ctx.cr[6].eq {
	pc = 0x825CC058; continue 'dispatch;
	}
	// 825CC050: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 825CC054: 48000010  b 0x825cc064
	pc = 0x825CC064; continue 'dispatch;
	// 825CC058: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CC05C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825CC060: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825CC064: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 825CC068: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825CC06C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 825CC070: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825CC074: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 825CC078: 396AD6E0  addi r11, r10, -0x2920
	ctx.r[11].s64 = ctx.r[10].s64 + -10528;
	// 825CC07C: FD200018  frsp f9, f0
	ctx.f[9].f64 = (ctx.f[0].f64 as f32) as f64;
	// 825CC080: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 825CC084: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 825CC088: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825CC08C: C14B0010  lfs f10, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825CC090: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825CC094: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825CC098: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825CC09C: C16AD6E0  lfs f11, -0x2920(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10528 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825CC0A0: C189E4E4  lfs f12, -0x1b1c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-6940 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825CC0A4: C00808A4  lfs f0, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CC0A8: D1810060  stfs f12, 0x60(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825CC0AC: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825CC0B0: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825CC0B4: EDA96ABA  fmadds f13, f9, f10, f13
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64);
	// 825CC0B8: D1610074  stfs f11, 0x74(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825CC0BC: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825CC0C0: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 825CC0C4: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825CC0C8: 4BFFEF99  bl 0x825cb060
	ctx.lr = 0x825CC0CC;
	sub_825CB060(ctx, base);
	// 825CC0CC: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 825CC0D0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 825CC0D4: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825CC0D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CC0DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825CC0E0: 48AFC089  bl 0x830c8168
	ctx.lr = 0x825CC0E4;
	sub_830C8168(ctx, base);
	// 825CC0E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CC0E8: 48000008  b 0x825cc0f0
	pc = 0x825CC0F0; continue 'dispatch;
	// 825CC0EC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825CC0F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CC0F4: 4BD028ED  bl 0x822ce9e0
	ctx.lr = 0x825CC0F8;
	sub_822CE9E0(ctx, base);
	// 825CC0F8: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825CC0FC: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CC100: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825CC104: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825CC108: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 825CC10C: 419A0024  beq cr6, 0x825cc130
	if ctx.cr[6].eq {
	pc = 0x825CC130; continue 'dispatch;
	}
	// 825CC110: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825CC114: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825CC118: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CC11C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825CC120: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825CC124: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825CC128: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CC12C: 4082FFE8  bne 0x825cc114
	if !ctx.cr[0].eq {
	pc = 0x825CC114; continue 'dispatch;
	}
	// 825CC130: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825CC134: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CC138: 48AF77E1  bl 0x830c3918
	ctx.lr = 0x825CC13C;
	sub_830C3918(ctx, base);
	// 825CC13C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825CC140: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825CC144: 4BFFEF1D  bl 0x825cb060
	ctx.lr = 0x825CC148;
	sub_825CB060(ctx, base);
	// 825CC148: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CC14C: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 825CC150: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825CC154: 387D0090  addi r3, r29, 0x90
	ctx.r[3].s64 = ctx.r[29].s64 + 144;
	// 825CC158: 4BCFCFD9  bl 0x822c9130
	ctx.lr = 0x825CC15C;
	sub_822C9130(ctx, base);
	// 825CC15C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825CC160: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825CC164: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825CC168: 4BCFCCC9  bl 0x822c8e30
	ctx.lr = 0x825CC16C;
	sub_822C8E30(ctx, base);
	// 825CC16C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825CC170: 387E00B0  addi r3, r30, 0xb0
	ctx.r[3].s64 = ctx.r[30].s64 + 176;
	// 825CC174: 485E6F95  bl 0x82bb3108
	ctx.lr = 0x825CC178;
	sub_82BB3108(ctx, base);
	// 825CC178: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825CC17C: 419A000C  beq cr6, 0x825cc188
	if ctx.cr[6].eq {
	pc = 0x825CC188; continue 'dispatch;
	}
	// 825CC180: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CC184: 4BCF470D  bl 0x822c0890
	ctx.lr = 0x825CC188;
	sub_822C0890(ctx, base);
	// 825CC188: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825CC18C: 48BDC028  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CC190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CC190 size=716
    let mut pc: u32 = 0x825CC190;
    'dispatch: loop {
        match pc {
            0x825CC190 => {
    //   block [0x825CC190..0x825CC45C)
	// 825CC190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CC194: 48BDBFD1  bl 0x831a8164
	ctx.lr = 0x825CC198;
	sub_831A8130(ctx, base);
	// 825CC198: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CC19C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CC1A0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825CC1A4: 3BFE0134  addi r31, r30, 0x134
	ctx.r[31].s64 = ctx.r[30].s64 + 308;
	// 825CC1A8: 817E0138  lwz r11, 0x138(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(312 as u32) ) } as u64;
	// 825CC1AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CC1B0: 409A000C  bne cr6, 0x825cc1bc
	if !ctx.cr[6].eq {
	pc = 0x825CC1BC; continue 'dispatch;
	}
	// 825CC1B4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825CC1B8: 48000010  b 0x825cc1c8
	pc = 0x825CC1C8; continue 'dispatch;
	// 825CC1BC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CC1C0: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825CC1C4: 7D7B1E70  srawi r27, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825CC1C8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CC1CC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825CC1D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CC1D4: 936B00C8  stw r27, 0xc8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(200 as u32), ctx.r[27].u32 ) };
	// 825CC1D8: 485E6F31  bl 0x82bb3108
	ctx.lr = 0x825CC1DC;
	sub_82BB3108(ctx, base);
	// 825CC1DC: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CC1E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CC1E4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CC1E8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825CC1EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CC1F0: 4E800421  bctrl
	ctx.lr = 0x825CC1F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CC1F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CC1F8: 387E00A0  addi r3, r30, 0xa0
	ctx.r[3].s64 = ctx.r[30].s64 + 160;
	// 825CC1FC: 4BD22B2D  bl 0x822eed28
	ctx.lr = 0x825CC200;
	sub_822EED28(ctx, base);
	// 825CC200: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CC204: 48827225  bl 0x82df3428
	ctx.lr = 0x825CC208;
	sub_82DF3428(ctx, base);
	// 825CC208: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CC20C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825CC210: 388BD710  addi r4, r11, -0x28f0
	ctx.r[4].s64 = ctx.r[11].s64 + -10480;
	// 825CC214: 38A0017F  li r5, 0x17f
	ctx.r[5].s64 = 383;
	// 825CC218: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 825CC21C: 4BCF41BD  bl 0x822c03d8
	ctx.lr = 0x825CC220;
	sub_822C03D8(ctx, base);
	// 825CC220: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 825CC224: 418200AC  beq 0x825cc2d0
	if ctx.cr[0].eq {
	pc = 0x825CC2D0; continue 'dispatch;
	}
	// 825CC228: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CC22C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CC230: 419A0010  beq cr6, 0x825cc240
	if ctx.cr[6].eq {
	pc = 0x825CC240; continue 'dispatch;
	}
	// 825CC234: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CC238: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825CC23C: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825CC240: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 825CC244: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825CC248: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 825CC24C: C8010060  lfd f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825CC250: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 825CC254: 396AD6F0  addi r11, r10, -0x2910
	ctx.r[11].s64 = ctx.r[10].s64 + -10512;
	// 825CC258: FD200018  frsp f9, f0
	ctx.f[9].f64 = (ctx.f[0].f64 as f32) as f64;
	// 825CC25C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 825CC260: C16AD6F0  lfs f11, -0x2910(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10512 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825CC264: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 825CC268: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 825CC26C: C14BFFF8  lfs f10, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825CC270: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CC274: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825CC278: C189E4E4  lfs f12, -0x1b1c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-6940 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825CC27C: 388BBEE8  addi r4, r11, -0x4118
	ctx.r[4].s64 = ctx.r[11].s64 + -16664;
	// 825CC280: D1810070  stfs f12, 0x70(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825CC284: C00808A4  lfs f0, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CC288: C1AA6218  lfs f13, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825CC28C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825CC290: ED8952FA  fmadds f12, f9, f11, f10
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[11].f64 + ctx.f[10].f64) as f32) as f64);
	// 825CC294: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 825CC298: D1A10080  stfs f13, 0x80(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 825CC29C: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 825CC2A0: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 825CC2A4: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 825CC2A8: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825CC2AC: 4BCFD045  bl 0x822c92f0
	ctx.lr = 0x825CC2B0;
	sub_822C92F0(ctx, base);
	// 825CC2B0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 825CC2B4: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 825CC2B8: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 825CC2BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CC2C0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825CC2C4: 48AFBEA5  bl 0x830c8168
	ctx.lr = 0x825CC2C8;
	sub_830C8168(ctx, base);
	// 825CC2C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CC2CC: 48000008  b 0x825cc2d4
	pc = 0x825CC2D4; continue 'dispatch;
	// 825CC2D0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825CC2D4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825CC2D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CC2DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825CC2E0: 4BCFD359  bl 0x822c9638
	ctx.lr = 0x825CC2E4;
	sub_822C9638(ctx, base);
	// 825CC2E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825CC2E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CC2EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825CC2F0: 4BCF3D11  bl 0x822c0000
	ctx.lr = 0x825CC2F4;
	sub_822C0000(ctx, base);
	// 825CC2F4: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825CC2F8: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CC2FC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825CC300: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 825CC304: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 825CC308: 419A0024  beq cr6, 0x825cc32c
	if ctx.cr[6].eq {
	pc = 0x825CC32C; continue 'dispatch;
	}
	// 825CC30C: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825CC310: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825CC314: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CC318: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825CC31C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825CC320: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825CC324: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CC328: 4082FFE8  bne 0x825cc310
	if !ctx.cr[0].eq {
	pc = 0x825CC310; continue 'dispatch;
	}
	// 825CC32C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825CC330: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CC334: 48AF75E5  bl 0x830c3918
	ctx.lr = 0x825CC338;
	sub_830C3918(ctx, base);
	// 825CC338: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825CC33C: 387E0144  addi r3, r30, 0x144
	ctx.r[3].s64 = ctx.r[30].s64 + 324;
	// 825CC340: 485E6DC9  bl 0x82bb3108
	ctx.lr = 0x825CC344;
	sub_82BB3108(ctx, base);
	// 825CC344: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CC348: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825CC34C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CC350: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825CC354: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CC358: 4E800421  bctrl
	ctx.lr = 0x825CC35C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CC35C: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CC360: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CC364: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CC368: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825CC36C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CC370: 4E800421  bctrl
	ctx.lr = 0x825CC374;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CC374: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CC378: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825CC37C: 4BFFECE5  bl 0x825cb060
	ctx.lr = 0x825CC380;
	sub_825CB060(ctx, base);
	// 825CC380: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CC384: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 825CC388: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825CC38C: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 825CC390: 4BCFCDA1  bl 0x822c9130
	ctx.lr = 0x825CC394;
	sub_822C9130(ctx, base);
	// 825CC394: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825CC398: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825CC39C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825CC3A0: 4BCFCA91  bl 0x822c8e30
	ctx.lr = 0x825CC3A4;
	sub_822C8E30(ctx, base);
	// 825CC3A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CC3A8: 48827081  bl 0x82df3428
	ctx.lr = 0x825CC3AC;
	sub_82DF3428(ctx, base);
	// 825CC3AC: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 825CC3B0: 4857ADF1  bl 0x82b471a0
	ctx.lr = 0x825CC3B4;
	sub_82B471A0(ctx, base);
	// 825CC3B4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CC3B8: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 825CC3BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CC3C0: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 825CC3C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CC3C8: 4E800421  bctrl
	ctx.lr = 0x825CC3CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CC3CC: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CC3D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825CC3D4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CC3D8: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 825CC3DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CC3E0: 4E800421  bctrl
	ctx.lr = 0x825CC3E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CC3E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825CC3E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CC3EC: 388B9BC9  addi r4, r11, -0x6437
	ctx.r[4].s64 = ctx.r[11].s64 + -25655;
	// 825CC3F0: 48827619  bl 0x82df3a08
	ctx.lr = 0x825CC3F4;
	sub_82DF3A08(ctx, base);
	// 825CC3F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825CC3F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825CC3FC: 48826EA5  bl 0x82df32a0
	ctx.lr = 0x825CC400;
	sub_82DF32A0(ctx, base);
	// 825CC400: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CC404: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CC408: 48827021  bl 0x82df3428
	ctx.lr = 0x825CC40C;
	sub_82DF3428(ctx, base);
	// 825CC40C: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CC410: 41820014  beq 0x825cc424
	if ctx.cr[0].eq {
	pc = 0x825CC424; continue 'dispatch;
	}
	// 825CC414: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825CC418: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825CC41C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CC420: 4BFFED29  bl 0x825cb148
	ctx.lr = 0x825CC424;
	sub_825CB148(ctx, base);
	// 825CC424: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825CC428: 48827001  bl 0x82df3428
	ctx.lr = 0x825CC42C;
	sub_82DF3428(ctx, base);
	// 825CC42C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825CC430: 48826FF9  bl 0x82df3428
	ctx.lr = 0x825CC434;
	sub_82DF3428(ctx, base);
	// 825CC434: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825CC438: 419A000C  beq cr6, 0x825cc444
	if ctx.cr[6].eq {
	pc = 0x825CC444; continue 'dispatch;
	}
	// 825CC43C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825CC440: 4BCF4451  bl 0x822c0890
	ctx.lr = 0x825CC444;
	sub_822C0890(ctx, base);
	// 825CC444: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CC448: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CC44C: 419A0008  beq cr6, 0x825cc454
	if ctx.cr[6].eq {
	pc = 0x825CC454; continue 'dispatch;
	}
	// 825CC450: 4BCF4441  bl 0x822c0890
	ctx.lr = 0x825CC454;
	sub_822C0890(ctx, base);
	// 825CC454: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 825CC458: 48BDBD5C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CC460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CC460 size=348
    let mut pc: u32 = 0x825CC460;
    'dispatch: loop {
        match pc {
            0x825CC460 => {
    //   block [0x825CC460..0x825CC5BC)
	// 825CC460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CC464: 48BDBD09  bl 0x831a816c
	ctx.lr = 0x825CC468;
	sub_831A8130(ctx, base);
	// 825CC468: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CC46C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CC470: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CC474: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825CC478: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825CC47C: 388BD710  addi r4, r11, -0x28f0
	ctx.r[4].s64 = ctx.r[11].s64 + -10480;
	// 825CC480: 38A0025D  li r5, 0x25d
	ctx.r[5].s64 = 605;
	// 825CC484: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 825CC488: 4BCF3F51  bl 0x822c03d8
	ctx.lr = 0x825CC48C;
	sub_822C03D8(ctx, base);
	// 825CC48C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825CC490: 418200A0  beq 0x825cc530
	if ctx.cr[0].eq {
	pc = 0x825CC530; continue 'dispatch;
	}
	// 825CC494: 817E00A4  lwz r11, 0xa4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(164 as u32) ) } as u64;
	// 825CC498: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CC49C: 419A0010  beq cr6, 0x825cc4ac
	if ctx.cr[6].eq {
	pc = 0x825CC4AC; continue 'dispatch;
	}
	// 825CC4A0: 815E00A8  lwz r10, 0xa8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(168 as u32) ) } as u64;
	// 825CC4A4: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825CC4A8: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825CC4AC: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 825CC4B0: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825CC4B4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 825CC4B8: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825CC4BC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 825CC4C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CC4C4: FD400018  frsp f10, f0
	ctx.f[10].f64 = (ctx.f[0].f64 as f32) as f64;
	// 825CC4C8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825CC4CC: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825CC4D0: C1AAD7BC  lfs f13, -0x2844(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825CC4D4: C16BD6F0  lfs f11, -0x2910(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10512 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825CC4D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825CC4DC: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825CC4E0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825CC4E4: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CC4E8: C188D7B8  lfs f12, -0x2848(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-10312 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825CC4EC: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825CC4F0: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825CC4F4: D1810070  stfs f12, 0x70(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825CC4F8: EDAA6AFA  fmadds f13, f10, f11, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 825CC4FC: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825CC500: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825CC504: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 825CC508: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825CC50C: 4BFFEB55  bl 0x825cb060
	ctx.lr = 0x825CC510;
	sub_825CB060(ctx, base);
	// 825CC510: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 825CC514: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 825CC518: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825CC51C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CC520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CC524: 48AFBC45  bl 0x830c8168
	ctx.lr = 0x825CC528;
	sub_830C8168(ctx, base);
	// 825CC528: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CC52C: 48000008  b 0x825cc534
	pc = 0x825CC534; continue 'dispatch;
	// 825CC530: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825CC534: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825CC538: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CC53C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825CC540: 4BCFD0F9  bl 0x822c9638
	ctx.lr = 0x825CC544;
	sub_822C9638(ctx, base);
	// 825CC544: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825CC548: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CC54C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825CC550: 4BCF3AB1  bl 0x822c0000
	ctx.lr = 0x825CC554;
	sub_822C0000(ctx, base);
	// 825CC554: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825CC558: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CC55C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825CC560: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825CC564: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825CC568: 419A0024  beq cr6, 0x825cc58c
	if ctx.cr[6].eq {
	pc = 0x825CC58C; continue 'dispatch;
	}
	// 825CC56C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825CC570: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825CC574: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CC578: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825CC57C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825CC580: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825CC584: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CC588: 4082FFE8  bne 0x825cc570
	if !ctx.cr[0].eq {
	pc = 0x825CC570; continue 'dispatch;
	}
	// 825CC58C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825CC590: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CC594: 48AF7385  bl 0x830c3918
	ctx.lr = 0x825CC598;
	sub_830C3918(ctx, base);
	// 825CC598: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825CC59C: 387E00A0  addi r3, r30, 0xa0
	ctx.r[3].s64 = ctx.r[30].s64 + 160;
	// 825CC5A0: 485E6B69  bl 0x82bb3108
	ctx.lr = 0x825CC5A4;
	sub_82BB3108(ctx, base);
	// 825CC5A4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825CC5A8: 419A000C  beq cr6, 0x825cc5b4
	if ctx.cr[6].eq {
	pc = 0x825CC5B4; continue 'dispatch;
	}
	// 825CC5AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CC5B0: 4BCF42E1  bl 0x822c0890
	ctx.lr = 0x825CC5B4;
	sub_822C0890(ctx, base);
	// 825CC5B4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825CC5B8: 48BDBC04  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CC5C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CC5C0 size=408
    let mut pc: u32 = 0x825CC5C0;
    'dispatch: loop {
        match pc {
            0x825CC5C0 => {
    //   block [0x825CC5C0..0x825CC758)
	// 825CC5C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CC5C4: 48BDBBA1  bl 0x831a8164
	ctx.lr = 0x825CC5C8;
	sub_831A8130(ctx, base);
	// 825CC5C8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CC5CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CC5D0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825CC5D4: 3BFE00A0  addi r31, r30, 0xa0
	ctx.r[31].s64 = ctx.r[30].s64 + 160;
	// 825CC5D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CC5DC: 4BD2274D  bl 0x822eed28
	ctx.lr = 0x825CC5E0;
	sub_822EED28(ctx, base);
	// 825CC5E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CC5E4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825CC5E8: 388BD710  addi r4, r11, -0x28f0
	ctx.r[4].s64 = ctx.r[11].s64 + -10480;
	// 825CC5EC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825CC5F0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825CC5F4: 38A00299  li r5, 0x299
	ctx.r[5].s64 = 665;
	// 825CC5F8: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 825CC5FC: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 825CC600: 4BCF3DD9  bl 0x822c03d8
	ctx.lr = 0x825CC604;
	sub_822C03D8(ctx, base);
	// 825CC604: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825CC608: 418200AC  beq 0x825cc6b4
	if ctx.cr[0].eq {
	pc = 0x825CC6B4; continue 'dispatch;
	}
	// 825CC60C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CC610: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CC614: 409A000C  bne cr6, 0x825cc620
	if !ctx.cr[6].eq {
	pc = 0x825CC620; continue 'dispatch;
	}
	// 825CC618: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 825CC61C: 48000010  b 0x825cc62c
	pc = 0x825CC62C; continue 'dispatch;
	// 825CC620: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CC624: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825CC628: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825CC62C: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 825CC630: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825CC634: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 825CC638: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825CC63C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 825CC640: 396AD6E0  addi r11, r10, -0x2920
	ctx.r[11].s64 = ctx.r[10].s64 + -10528;
	// 825CC644: FD200018  frsp f9, f0
	ctx.f[9].f64 = (ctx.f[0].f64 as f32) as f64;
	// 825CC648: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 825CC64C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 825CC650: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825CC654: C14B0010  lfs f10, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825CC658: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825CC65C: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825CC660: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825CC664: C16AD6E0  lfs f11, -0x2920(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10528 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825CC668: C189E4E4  lfs f12, -0x1b1c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-6940 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825CC66C: C00808A4  lfs f0, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CC670: D1810060  stfs f12, 0x60(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825CC674: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825CC678: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825CC67C: EDA96ABA  fmadds f13, f9, f10, f13
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64);
	// 825CC680: D1610074  stfs f11, 0x74(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825CC684: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825CC688: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 825CC68C: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825CC690: 4BFFE9D1  bl 0x825cb060
	ctx.lr = 0x825CC694;
	sub_825CB060(ctx, base);
	// 825CC694: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 825CC698: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 825CC69C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825CC6A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CC6A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825CC6A8: 48AFBAC1  bl 0x830c8168
	ctx.lr = 0x825CC6AC;
	sub_830C8168(ctx, base);
	// 825CC6AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CC6B0: 48000008  b 0x825cc6b8
	pc = 0x825CC6B8; continue 'dispatch;
	// 825CC6B4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825CC6B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CC6BC: 4BD02325  bl 0x822ce9e0
	ctx.lr = 0x825CC6C0;
	sub_822CE9E0(ctx, base);
	// 825CC6C0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825CC6C4: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CC6C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825CC6CC: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825CC6D0: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 825CC6D4: 419A0024  beq cr6, 0x825cc6f8
	if ctx.cr[6].eq {
	pc = 0x825CC6F8; continue 'dispatch;
	}
	// 825CC6D8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825CC6DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825CC6E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CC6E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825CC6E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825CC6EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825CC6F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CC6F4: 4082FFE8  bne 0x825cc6dc
	if !ctx.cr[0].eq {
	pc = 0x825CC6DC; continue 'dispatch;
	}
	// 825CC6F8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825CC6FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CC700: 48AF7219  bl 0x830c3918
	ctx.lr = 0x825CC704;
	sub_830C3918(ctx, base);
	// 825CC704: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825CC708: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825CC70C: 4BFFE955  bl 0x825cb060
	ctx.lr = 0x825CC710;
	sub_825CB060(ctx, base);
	// 825CC710: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CC714: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 825CC718: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825CC71C: 387D0090  addi r3, r29, 0x90
	ctx.r[3].s64 = ctx.r[29].s64 + 144;
	// 825CC720: 4BCFCA11  bl 0x822c9130
	ctx.lr = 0x825CC724;
	sub_822C9130(ctx, base);
	// 825CC724: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825CC728: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825CC72C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825CC730: 4BCFC701  bl 0x822c8e30
	ctx.lr = 0x825CC734;
	sub_822C8E30(ctx, base);
	// 825CC734: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825CC738: 387E00B0  addi r3, r30, 0xb0
	ctx.r[3].s64 = ctx.r[30].s64 + 176;
	// 825CC73C: 485E69CD  bl 0x82bb3108
	ctx.lr = 0x825CC740;
	sub_82BB3108(ctx, base);
	// 825CC740: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825CC744: 419A000C  beq cr6, 0x825cc750
	if ctx.cr[6].eq {
	pc = 0x825CC750; continue 'dispatch;
	}
	// 825CC748: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CC74C: 4BCF4145  bl 0x822c0890
	ctx.lr = 0x825CC750;
	sub_822C0890(ctx, base);
	// 825CC750: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825CC754: 48BDBA60  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CC758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CC758 size=140
    let mut pc: u32 = 0x825CC758;
    'dispatch: loop {
        match pc {
            0x825CC758 => {
    //   block [0x825CC758..0x825CC7E4)
	// 825CC758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CC75C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CC760: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CC764: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CC768: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CC76C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CC770: 396BD7C4  addi r11, r11, -0x283c
	ctx.r[11].s64 = ctx.r[11].s64 + -10300;
	// 825CC774: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CC778: 807F011C  lwz r3, 0x11c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 825CC77C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CC780: 419A0008  beq cr6, 0x825cc788
	if ctx.cr[6].eq {
	pc = 0x825CC788; continue 'dispatch;
	}
	// 825CC784: 4BCF410D  bl 0x822c0890
	ctx.lr = 0x825CC788;
	sub_822C0890(ctx, base);
	// 825CC788: 807F0110  lwz r3, 0x110(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 825CC78C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CC790: 419A0008  beq cr6, 0x825cc798
	if ctx.cr[6].eq {
	pc = 0x825CC798; continue 'dispatch;
	}
	// 825CC794: 4BCF40FD  bl 0x822c0890
	ctx.lr = 0x825CC798;
	sub_822C0890(ctx, base);
	// 825CC798: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 825CC79C: 4BCFC51D  bl 0x822c8cb8
	ctx.lr = 0x825CC7A0;
	sub_822C8CB8(ctx, base);
	// 825CC7A0: 387F00D8  addi r3, r31, 0xd8
	ctx.r[3].s64 = ctx.r[31].s64 + 216;
	// 825CC7A4: 4BFFF71D  bl 0x825cbec0
	ctx.lr = 0x825CC7A8;
	sub_825CBEC0(ctx, base);
	// 825CC7A8: 387F00CC  addi r3, r31, 0xcc
	ctx.r[3].s64 = ctx.r[31].s64 + 204;
	// 825CC7AC: 4BFFF715  bl 0x825cbec0
	ctx.lr = 0x825CC7B0;
	sub_825CBEC0(ctx, base);
	// 825CC7B0: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 825CC7B4: 4BFFF70D  bl 0x825cbec0
	ctx.lr = 0x825CC7B8;
	sub_825CBEC0(ctx, base);
	// 825CC7B8: 387F00B0  addi r3, r31, 0xb0
	ctx.r[3].s64 = ctx.r[31].s64 + 176;
	// 825CC7BC: 4BEE4AE5  bl 0x824b12a0
	ctx.lr = 0x825CC7C0;
	sub_824B12A0(ctx, base);
	// 825CC7C0: 387F00A0  addi r3, r31, 0xa0
	ctx.r[3].s64 = ctx.r[31].s64 + 160;
	// 825CC7C4: 4BE05C25  bl 0x823d23e8
	ctx.lr = 0x825CC7C8;
	sub_823D23E8(ctx, base);
	// 825CC7C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CC7CC: 48AF631D  bl 0x830c2ae8
	ctx.lr = 0x825CC7D0;
	sub_830C2AE8(ctx, base);
	// 825CC7D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825CC7D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CC7D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CC7DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CC7E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CC7E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CC7E8 size=376
    let mut pc: u32 = 0x825CC7E8;
    'dispatch: loop {
        match pc {
            0x825CC7E8 => {
    //   block [0x825CC7E8..0x825CC960)
	// 825CC7E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CC7EC: 48BDB979  bl 0x831a8164
	ctx.lr = 0x825CC7F0;
	sub_831A8130(ctx, base);
	// 825CC7F0: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CC7F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CC7F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CC7FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CC800: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825CC804: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825CC808: 4BFFE7D1  bl 0x825cafd8
	ctx.lr = 0x825CC80C;
	sub_825CAFD8(ctx, base);
	// 825CC80C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CC810: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CC814: 4BFFF7E5  bl 0x825cbff8
	ctx.lr = 0x825CC818;
	sub_825CBFF8(ctx, base);
	// 825CC818: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CC81C: 48826C0D  bl 0x82df3428
	ctx.lr = 0x825CC820;
	sub_82DF3428(ctx, base);
	// 825CC820: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825CC824: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 825CC828: 837F00C8  lwz r27, 0xc8(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 825CC82C: 4BFBF6E5  bl 0x8258bf10
	ctx.lr = 0x825CC830;
	sub_8258BF10(ctx, base);
	// 825CC830: 936100C0  stw r27, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[27].u32 ) };
	// 825CC834: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825CC838: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 825CC83C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825CC840: 4BFBF6D1  bl 0x8258bf10
	ctx.lr = 0x825CC844;
	sub_8258BF10(ctx, base);
	// 825CC844: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825CC848: 4BCFC471  bl 0x822c8cb8
	ctx.lr = 0x825CC84C;
	sub_822C8CB8(ctx, base);
	// 825CC84C: 816100C0  lwz r11, 0xc0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 825CC850: 388100C8  addi r4, r1, 0xc8
	ctx.r[4].s64 = ctx.r[1].s64 + 200;
	// 825CC854: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 825CC858: 916100F0  stw r11, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 825CC85C: 4BFBF6B5  bl 0x8258bf10
	ctx.lr = 0x825CC860;
	sub_8258BF10(ctx, base);
	// 825CC860: 38A100F0  addi r5, r1, 0xf0
	ctx.r[5].s64 = ctx.r[1].s64 + 240;
	// 825CC864: 389F00C0  addi r4, r31, 0xc0
	ctx.r[4].s64 = ctx.r[31].s64 + 192;
	// 825CC868: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CC86C: 4BFFECC5  bl 0x825cb530
	ctx.lr = 0x825CC870;
	sub_825CB530(ctx, base);
	// 825CC870: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 825CC874: 4BCFC445  bl 0x822c8cb8
	ctx.lr = 0x825CC878;
	sub_822C8CB8(ctx, base);
	// 825CC878: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 825CC87C: 4BCFC43D  bl 0x822c8cb8
	ctx.lr = 0x825CC880;
	sub_822C8CB8(ctx, base);
	// 825CC880: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825CC884: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 825CC888: 837F00D4  lwz r27, 0xd4(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 825CC88C: 4BFBF685  bl 0x8258bf10
	ctx.lr = 0x825CC890;
	sub_8258BF10(ctx, base);
	// 825CC890: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 825CC894: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825CC898: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825CC89C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825CC8A0: 4BFBF671  bl 0x8258bf10
	ctx.lr = 0x825CC8A4;
	sub_8258BF10(ctx, base);
	// 825CC8A4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825CC8A8: 4BCFC411  bl 0x822c8cb8
	ctx.lr = 0x825CC8AC;
	sub_822C8CB8(ctx, base);
	// 825CC8AC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825CC8B0: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825CC8B4: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 825CC8B8: 91610120  stw r11, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 825CC8BC: 4BFBF655  bl 0x8258bf10
	ctx.lr = 0x825CC8C0;
	sub_8258BF10(ctx, base);
	// 825CC8C0: 38A10120  addi r5, r1, 0x120
	ctx.r[5].s64 = ctx.r[1].s64 + 288;
	// 825CC8C4: 389F00CC  addi r4, r31, 0xcc
	ctx.r[4].s64 = ctx.r[31].s64 + 204;
	// 825CC8C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CC8CC: 4BFFEC65  bl 0x825cb530
	ctx.lr = 0x825CC8D0;
	sub_825CB530(ctx, base);
	// 825CC8D0: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 825CC8D4: 4BCFC3E5  bl 0x822c8cb8
	ctx.lr = 0x825CC8D8;
	sub_822C8CB8(ctx, base);
	// 825CC8D8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825CC8DC: 4BCFC3DD  bl 0x822c8cb8
	ctx.lr = 0x825CC8E0;
	sub_822C8CB8(ctx, base);
	// 825CC8E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CC8E4: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 825CC8E8: 837F00E0  lwz r27, 0xe0(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 825CC8EC: 4BFBF625  bl 0x8258bf10
	ctx.lr = 0x825CC8F0;
	sub_8258BF10(ctx, base);
	// 825CC8F0: 93610090  stw r27, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[27].u32 ) };
	// 825CC8F4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825CC8F8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825CC8FC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825CC900: 4BFBF611  bl 0x8258bf10
	ctx.lr = 0x825CC904;
	sub_8258BF10(ctx, base);
	// 825CC904: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825CC908: 4BCFC3B1  bl 0x822c8cb8
	ctx.lr = 0x825CC90C;
	sub_822C8CB8(ctx, base);
	// 825CC90C: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 825CC910: 38810098  addi r4, r1, 0x98
	ctx.r[4].s64 = ctx.r[1].s64 + 152;
	// 825CC914: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 825CC918: 91610150  stw r11, 0x150(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 825CC91C: 4BFBF5F5  bl 0x8258bf10
	ctx.lr = 0x825CC920;
	sub_8258BF10(ctx, base);
	// 825CC920: 38A10150  addi r5, r1, 0x150
	ctx.r[5].s64 = ctx.r[1].s64 + 336;
	// 825CC924: 389F00D8  addi r4, r31, 0xd8
	ctx.r[4].s64 = ctx.r[31].s64 + 216;
	// 825CC928: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CC92C: 4BFFEC05  bl 0x825cb530
	ctx.lr = 0x825CC930;
	sub_825CB530(ctx, base);
	// 825CC930: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 825CC934: 4BCFC385  bl 0x822c8cb8
	ctx.lr = 0x825CC938;
	sub_822C8CB8(ctx, base);
	// 825CC938: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825CC93C: 4BCFC37D  bl 0x822c8cb8
	ctx.lr = 0x825CC940;
	sub_822C8CB8(ctx, base);
	// 825CC940: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CC944: 4BCFC375  bl 0x822c8cb8
	ctx.lr = 0x825CC948;
	sub_822C8CB8(ctx, base);
	// 825CC948: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825CC94C: 4BCFC36D  bl 0x822c8cb8
	ctx.lr = 0x825CC950;
	sub_822C8CB8(ctx, base);
	// 825CC950: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825CC954: 4BCFC365  bl 0x822c8cb8
	ctx.lr = 0x825CC958;
	sub_822C8CB8(ctx, base);
	// 825CC958: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 825CC95C: 48BDB858  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CC960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CC960 size=132
    let mut pc: u32 = 0x825CC960;
    'dispatch: loop {
        match pc {
            0x825CC960 => {
    //   block [0x825CC960..0x825CC9E4)
	// 825CC960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CC964: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CC968: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CC96C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CC970: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CC974: 3D40825C  lis r10, -0x7da4
	ctx.r[10].s64 = -2107899904;
	// 825CC978: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CC97C: 394A26F8  addi r10, r10, 0x26f8
	ctx.r[10].s64 = ctx.r[10].s64 + 9976;
	// 825CC980: 396BC02C  addi r11, r11, -0x3fd4
	ctx.r[11].s64 = ctx.r[11].s64 + -16340;
	// 825CC984: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825CC988: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825CC98C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825CC990: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825CC994: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CC998: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825CC99C: F941005C  std r10, 0x5c(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u64 ) };
	// 825CC9A0: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825CC9A4: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825CC9A8: 794507E6  rldicr r5, r10, 0x20, 0x3f
	ctx.r[5].u64 = (ctx.r[10].u64).rotate_left(32) & 0xFFFFFFFFFFFFFFFF;
	// 825CC9AC: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 825CC9B0: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 825CC9B4: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825CC9B8: 4BFFEEA1  bl 0x825cb858
	ctx.lr = 0x825CC9BC;
	sub_825CB858(ctx, base);
	// 825CC9BC: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 825CC9C0: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 825CC9C4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825CC9C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CC9CC: 4BFFFE1D  bl 0x825cc7e8
	ctx.lr = 0x825CC9D0;
	sub_825CC7E8(ctx, base);
	// 825CC9D0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825CC9D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CC9D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CC9DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CC9E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CC9E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CC9E8 size=108
    let mut pc: u32 = 0x825CC9E8;
    'dispatch: loop {
        match pc {
            0x825CC9E8 => {
    //   block [0x825CC9E8..0x825CCA54)
	// 825CC9E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CC9EC: 48BDB781  bl 0x831a816c
	ctx.lr = 0x825CC9F0;
	sub_831A8130(ctx, base);
	// 825CC9F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CC9F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825CC9F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CC9FC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825CCA00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CCA04: 93DD0130  stw r30, 0x130(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(304 as u32), ctx.r[30].u32 ) };
	// 825CCA08: 4BFDE6C1  bl 0x825ab0c8
	ctx.lr = 0x825CCA0C;
	sub_825AB0C8(ctx, base);
	// 825CCA0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825CCA10: 4182003C  beq 0x825cca4c
	if ctx.cr[0].eq {
	pc = 0x825CCA4C; continue 'dispatch;
	}
	// 825CCA14: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825CCA18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CCA1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CCA20: 4BFDE791  bl 0x825ab1b0
	ctx.lr = 0x825CCA24;
	sub_825AB1B0(ctx, base);
	// 825CCA24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825CCA28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825CCA2C: 4BFFFB95  bl 0x825cc5c0
	ctx.lr = 0x825CCA30;
	sub_825CC5C0(ctx, base);
	// 825CCA30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CCA34: 488269F5  bl 0x82df3428
	ctx.lr = 0x825CCA38;
	sub_82DF3428(ctx, base);
	// 825CCA38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CCA3C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825CCA40: 4BFDE689  bl 0x825ab0c8
	ctx.lr = 0x825CCA44;
	sub_825AB0C8(ctx, base);
	// 825CCA44: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 825CCA48: 4198FFCC  blt cr6, 0x825cca14
	if ctx.cr[6].lt {
	pc = 0x825CCA14; continue 'dispatch;
	}
	// 825CCA4C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825CCA50: 48BDB76C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CCA58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CCA58 size=676
    let mut pc: u32 = 0x825CCA58;
    'dispatch: loop {
        match pc {
            0x825CCA58 => {
    //   block [0x825CCA58..0x825CCCFC)
	// 825CCA58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CCA5C: 48BDB701  bl 0x831a815c
	ctx.lr = 0x825CCA60;
	sub_831A8130(ctx, base);
	// 825CCA60: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 825CCA64: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CCA68: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 825CCA6C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825CCA70: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825CCA74: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 825CCA78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CCA7C: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 825CCA80: 48AF6109  bl 0x830c2b88
	ctx.lr = 0x825CCA84;
	sub_830C2B88(ctx, base);
	// 825CCA84: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CCA88: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 825CCA8C: 396BD7C4  addi r11, r11, -0x283c
	ctx.r[11].s64 = ctx.r[11].s64 + -10300;
	// 825CCA90: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CCA94: 93DF00A4  stw r30, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[30].u32 ) };
	// 825CCA98: 93DF00A8  stw r30, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[30].u32 ) };
	// 825CCA9C: 93DF00AC  stw r30, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[30].u32 ) };
	// 825CCAA0: 93DF00B4  stw r30, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[30].u32 ) };
	// 825CCAA4: 93DF00B8  stw r30, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[30].u32 ) };
	// 825CCAA8: 93DF00BC  stw r30, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[30].u32 ) };
	// 825CCAAC: 485E2EA5  bl 0x82baf950
	ctx.lr = 0x825CCAB0;
	sub_82BAF950(ctx, base);
	// 825CCAB0: 387F00CC  addi r3, r31, 0xcc
	ctx.r[3].s64 = ctx.r[31].s64 + 204;
	// 825CCAB4: 485E2E9D  bl 0x82baf950
	ctx.lr = 0x825CCAB8;
	sub_82BAF950(ctx, base);
	// 825CCAB8: 387F00D8  addi r3, r31, 0xd8
	ctx.r[3].s64 = ctx.r[31].s64 + 216;
	// 825CCABC: 485E2E95  bl 0x82baf950
	ctx.lr = 0x825CCAC0;
	sub_82BAF950(ctx, base);
	// 825CCAC0: 93DF00E8  stw r30, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[30].u32 ) };
	// 825CCAC4: 93DF0108  stw r30, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[30].u32 ) };
	// 825CCAC8: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 825CCACC: 93DF010C  stw r30, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[30].u32 ) };
	// 825CCAD0: 394000C8  li r10, 0xc8
	ctx.r[10].s64 = 200;
	// 825CCAD4: 93DF0110  stw r30, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[30].u32 ) };
	// 825CCAD8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825CCADC: 93DF0114  stw r30, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[30].u32 ) };
	// 825CCAE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CCAE4: 93DF0118  stw r30, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[30].u32 ) };
	// 825CCAE8: 3B7F010C  addi r27, r31, 0x10c
	ctx.r[27].s64 = ctx.r[31].s64 + 268;
	// 825CCAEC: 93DF011C  stw r30, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[30].u32 ) };
	// 825CCAF0: 93DF0124  stw r30, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[30].u32 ) };
	// 825CCAF4: 9BDF0128  stb r30, 0x128(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[30].u8 ) };
	// 825CCAF8: 9BDF0090  stb r30, 0x90(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[30].u8 ) };
	// 825CCAFC: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 825CCB00: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 825CCB04: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 825CCB08: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 825CCB0C: 48AF6595  bl 0x830c30a0
	ctx.lr = 0x825CCB10;
	sub_830C30A0(ctx, base);
	// 825CCB10: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CCB14: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825CCB18: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 825CCB1C: 3B2BD710  addi r25, r11, -0x28f0
	ctx.r[25].s64 = ctx.r[11].s64 + -10480;
	// 825CCB20: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 825CCB24: 38A00043  li r5, 0x43
	ctx.r[5].s64 = 67;
	// 825CCB28: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825CCB2C: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 825CCB30: 4BCF38A9  bl 0x822c03d8
	ctx.lr = 0x825CCB34;
	sub_822C03D8(ctx, base);
	// 825CCB34: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825CCB38: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CCB3C: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825CCB40: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825CCB44: 3B8BD6E0  addi r28, r11, -0x2920
	ctx.r[28].s64 = ctx.r[11].s64 + -10528;
	// 825CCB48: 41820058  beq 0x825ccba0
	if ctx.cr[0].eq {
	pc = 0x825CCBA0; continue 'dispatch;
	}
	// 825CCB4C: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CCB50: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825CCB54: C1BC0000  lfs f13, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825CCB58: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825CCB5C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825CCB60: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825CCB64: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825CCB68: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825CCB6C: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825CCB70: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825CCB74: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825CCB78: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 825CCB7C: 4BFFE4E5  bl 0x825cb060
	ctx.lr = 0x825CCB80;
	sub_825CB060(ctx, base);
	// 825CCB80: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 825CCB84: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 825CCB88: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825CCB8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CCB90: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825CCB94: 48AFB5D5  bl 0x830c8168
	ctx.lr = 0x825CCB98;
	sub_830C8168(ctx, base);
	// 825CCB98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CCB9C: 48000008  b 0x825ccba4
	pc = 0x825CCBA4; continue 'dispatch;
	// 825CCBA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CCBA4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825CCBA8: 4BD01E39  bl 0x822ce9e0
	ctx.lr = 0x825CCBAC;
	sub_822CE9E0(ctx, base);
	// 825CCBAC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825CCBB0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825CCBB4: 8341005C  lwz r26, 0x5c(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825CCBB8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 825CCBBC: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 825CCBC0: 419A0024  beq cr6, 0x825ccbe4
	if ctx.cr[6].eq {
	pc = 0x825CCBE4; continue 'dispatch;
	}
	// 825CCBC4: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 825CCBC8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825CCBCC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CCBD0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825CCBD4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825CCBD8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825CCBDC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CCBE0: 4082FFE8  bne 0x825ccbc8
	if !ctx.cr[0].eq {
	pc = 0x825CCBC8; continue 'dispatch;
	}
	// 825CCBE4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825CCBE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CCBEC: 48AF6D2D  bl 0x830c3918
	ctx.lr = 0x825CCBF0;
	sub_830C3918(ctx, base);
	// 825CCBF0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825CCBF4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825CCBF8: 38A00047  li r5, 0x47
	ctx.r[5].s64 = 71;
	// 825CCBFC: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 825CCC00: 4BCF37D9  bl 0x822c03d8
	ctx.lr = 0x825CCC04;
	sub_822C03D8(ctx, base);
	// 825CCC04: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825CCC08: 41820074  beq 0x825ccc7c
	if ctx.cr[0].eq {
	pc = 0x825CCC7C; continue 'dispatch;
	}
	// 825CCC0C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CCC10: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825CCC14: 388BD89C  addi r4, r11, -0x2764
	ctx.r[4].s64 = ctx.r[11].s64 + -10084;
	// 825CCC18: 48826DF1  bl 0x82df3a08
	ctx.lr = 0x825CCC1C;
	sub_82DF3A08(ctx, base);
	// 825CCC1C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825CCC20: C01C0008  lfs f0, 8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CCC24: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825CCC28: C19C0000  lfs f12, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825CCC2C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825CCC30: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 825CCC34: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 825CCC38: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 825CCC3C: C1AB9684  lfs f13, -0x697c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27004 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825CCC40: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 825CCC44: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 825CCC48: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 825CCC4C: D1810094  stfs f12, 0x94(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 825CCC50: D3E10098  stfs f31, 0x98(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 825CCC54: D3E1009C  stfs f31, 0x9c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 825CCC58: 4BFFE409  bl 0x825cb060
	ctx.lr = 0x825CCC5C;
	sub_825CB060(ctx, base);
	// 825CCC5C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 825CCC60: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 825CCC64: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 825CCC68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CCC6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825CCC70: 48AFB4F9  bl 0x830c8168
	ctx.lr = 0x825CCC74;
	sub_830C8168(ctx, base);
	// 825CCC74: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CCC78: 48000008  b 0x825ccc80
	pc = 0x825CCC80; continue 'dispatch;
	// 825CCC7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CCC80: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825CCC84: 4BD01D5D  bl 0x822ce9e0
	ctx.lr = 0x825CCC88;
	sub_822CE9E0(ctx, base);
	// 825CCC88: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CCC8C: 4182000C  beq 0x825ccc98
	if ctx.cr[0].eq {
	pc = 0x825CCC98; continue 'dispatch;
	}
	// 825CCC90: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825CCC94: 48826795  bl 0x82df3428
	ctx.lr = 0x825CCC98;
	sub_82DF3428(ctx, base);
	// 825CCC98: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CCC9C: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CCCA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CCCA4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825CCCA8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825CCCAC: 419A0024  beq cr6, 0x825cccd0
	if ctx.cr[6].eq {
	pc = 0x825CCCD0; continue 'dispatch;
	}
	// 825CCCB0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825CCCB4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825CCCB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CCCBC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825CCCC0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825CCCC4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825CCCC8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CCCCC: 4082FFE8  bne 0x825cccb4
	if !ctx.cr[0].eq {
	pc = 0x825CCCB4; continue 'dispatch;
	}
	// 825CCCD0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825CCCD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CCCD8: 48AF6C41  bl 0x830c3918
	ctx.lr = 0x825CCCDC;
	sub_830C3918(ctx, base);
	// 825CCCDC: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 825CCCE0: 419A000C  beq cr6, 0x825cccec
	if ctx.cr[6].eq {
	pc = 0x825CCCEC; continue 'dispatch;
	}
	// 825CCCE4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825CCCE8: 4BCF3BA9  bl 0x822c0890
	ctx.lr = 0x825CCCEC;
	sub_822C0890(ctx, base);
	// 825CCCEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CCCF0: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 825CCCF4: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 825CCCF8: 48BDB4B4  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CCD00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CCD00 size=76
    let mut pc: u32 = 0x825CCD00;
    'dispatch: loop {
        match pc {
            0x825CCD00 => {
    //   block [0x825CCD00..0x825CCD4C)
	// 825CCD00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CCD04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CCD08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CCD0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CCD10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CCD14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CCD18: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CCD1C: 4BFFFA3D  bl 0x825cc758
	ctx.lr = 0x825CCD20;
	sub_825CC758(ctx, base);
	// 825CCD20: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CCD24: 4182000C  beq 0x825ccd30
	if ctx.cr[0].eq {
	pc = 0x825CCD30; continue 'dispatch;
	}
	// 825CCD28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CCD2C: 4BCF353D  bl 0x822c0268
	ctx.lr = 0x825CCD30;
	sub_822C0268(ctx, base);
	// 825CCD30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CCD34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CCD38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CCD3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CCD40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CCD44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CCD48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CCD50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CCD50 size=180
    let mut pc: u32 = 0x825CCD50;
    'dispatch: loop {
        match pc {
            0x825CCD50 => {
    //   block [0x825CCD50..0x825CCE04)
	// 825CCD50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CCD54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CCD58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CCD5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CCD60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CCD64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CCD68: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 825CCD6C: 4BFFFCED  bl 0x825cca58
	ctx.lr = 0x825CCD70;
	sub_825CCA58(ctx, base);
	// 825CCD70: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825CCD74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CCD78: 394AD8A4  addi r10, r10, -0x275c
	ctx.r[10].s64 = ctx.r[10].s64 + -10076;
	// 825CCD7C: 917F0130  stw r11, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 825CCD80: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825CCD84: 917F0138  stw r11, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[11].u32 ) };
	// 825CCD88: 917F013C  stw r11, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[11].u32 ) };
	// 825CCD8C: 917F0140  stw r11, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 825CCD90: 917F0148  stw r11, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[11].u32 ) };
	// 825CCD94: 917F014C  stw r11, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[11].u32 ) };
	// 825CCD98: 917F0150  stw r11, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 825CCD9C: 397F0154  addi r11, r31, 0x154
	ctx.r[11].s64 = ctx.r[31].s64 + 340;
	// 825CCDA0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CCDA4: 917F0154  stw r11, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[11].u32 ) };
	// 825CCDA8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CCDAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CCDB0: 917F0158  stw r11, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 825CCDB4: 419A0024  beq cr6, 0x825ccdd8
	if ctx.cr[6].eq {
	pc = 0x825CCDD8; continue 'dispatch;
	}
	// 825CCDB8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825CCDBC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825CCDC0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CCDC4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825CCDC8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825CCDCC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825CCDD0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CCDD4: 4082FFE8  bne 0x825ccdbc
	if !ctx.cr[0].eq {
	pc = 0x825CCDBC; continue 'dispatch;
	}
	// 825CCDD8: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CCDDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CCDE0: 419A0008  beq cr6, 0x825ccde8
	if ctx.cr[6].eq {
	pc = 0x825CCDE8; continue 'dispatch;
	}
	// 825CCDE4: 4BCF3AAD  bl 0x822c0890
	ctx.lr = 0x825CCDE8;
	sub_822C0890(ctx, base);
	// 825CCDE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CCDEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CCDF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CCDF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CCDF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CCDFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CCE00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CCE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CCE08 size=112
    let mut pc: u32 = 0x825CCE08;
    'dispatch: loop {
        match pc {
            0x825CCE08 => {
    //   block [0x825CCE08..0x825CCE78)
	// 825CCE08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CCE0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CCE10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CCE14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CCE18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CCE1C: 38640134  addi r3, r4, 0x134
	ctx.r[3].s64 = ctx.r[4].s64 + 308;
	// 825CCE20: 80840108  lwz r4, 0x108(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(264 as u32) ) } as u64;
	// 825CCE24: 4BFD46AD  bl 0x825a14d0
	ctx.lr = 0x825CCE28;
	sub_825A14D0(ctx, base);
	// 825CCE28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CCE2C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CCE30: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CCE34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CCE38: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825CCE3C: 419A0024  beq cr6, 0x825cce60
	if ctx.cr[6].eq {
	pc = 0x825CCE60; continue 'dispatch;
	}
	// 825CCE40: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825CCE44: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825CCE48: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CCE4C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825CCE50: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825CCE54: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825CCE58: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CCE5C: 4082FFE8  bne 0x825cce44
	if !ctx.cr[0].eq {
	pc = 0x825CCE44; continue 'dispatch;
	}
	// 825CCE60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CCE64: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825CCE68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CCE6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CCE70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CCE74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CCE78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CCE78 size=80
    let mut pc: u32 = 0x825CCE78;
    'dispatch: loop {
        match pc {
            0x825CCE78 => {
    //   block [0x825CCE78..0x825CCEC8)
	// 825CCE78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CCE7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CCE80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CCE84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CCE88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CCE8C: 807F0158  lwz r3, 0x158(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 825CCE90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CCE94: 419A0008  beq cr6, 0x825cce9c
	if ctx.cr[6].eq {
	pc = 0x825CCE9C; continue 'dispatch;
	}
	// 825CCE98: 4BCF39F9  bl 0x822c0890
	ctx.lr = 0x825CCE9C;
	sub_822C0890(ctx, base);
	// 825CCE9C: 387F0144  addi r3, r31, 0x144
	ctx.r[3].s64 = ctx.r[31].s64 + 324;
	// 825CCEA0: 4BEE4401  bl 0x824b12a0
	ctx.lr = 0x825CCEA4;
	sub_824B12A0(ctx, base);
	// 825CCEA4: 387F0134  addi r3, r31, 0x134
	ctx.r[3].s64 = ctx.r[31].s64 + 308;
	// 825CCEA8: 4BEE43F9  bl 0x824b12a0
	ctx.lr = 0x825CCEAC;
	sub_824B12A0(ctx, base);
	// 825CCEAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CCEB0: 4BFFF8A9  bl 0x825cc758
	ctx.lr = 0x825CCEB4;
	sub_825CC758(ctx, base);
	// 825CCEB4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825CCEB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CCEBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CCEC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CCEC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CCEC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CCEC8 size=76
    let mut pc: u32 = 0x825CCEC8;
    'dispatch: loop {
        match pc {
            0x825CCEC8 => {
    //   block [0x825CCEC8..0x825CCF14)
	// 825CCEC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CCECC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CCED0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CCED4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CCED8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CCEDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CCEE0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CCEE4: 4BFFFF95  bl 0x825cce78
	ctx.lr = 0x825CCEE8;
	sub_825CCE78(ctx, base);
	// 825CCEE8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CCEEC: 4182000C  beq 0x825ccef8
	if ctx.cr[0].eq {
	pc = 0x825CCEF8; continue 'dispatch;
	}
	// 825CCEF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CCEF4: 4BCF3375  bl 0x822c0268
	ctx.lr = 0x825CCEF8;
	sub_822C0268(ctx, base);
	// 825CCEF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CCEFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CCF00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CCF04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CCF08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CCF0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CCF10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CCF18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CCF18 size=60
    let mut pc: u32 = 0x825CCF18;
    'dispatch: loop {
        match pc {
            0x825CCF18 => {
    //   block [0x825CCF18..0x825CCF54)
	// 825CCF18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CCF1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CCF20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CCF24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CCF28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CCF2C: 4BFFFB2D  bl 0x825cca58
	ctx.lr = 0x825CCF30;
	sub_825CCA58(ctx, base);
	// 825CCF30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CCF34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CCF38: 396BD834  addi r11, r11, -0x27cc
	ctx.r[11].s64 = ctx.r[11].s64 + -10188;
	// 825CCF3C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CCF40: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825CCF44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CCF48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CCF4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CCF50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CCF58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CCF58 size=88
    let mut pc: u32 = 0x825CCF58;
    'dispatch: loop {
        match pc {
            0x825CCF58 => {
    //   block [0x825CCF58..0x825CCFB0)
	// 825CCF58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CCF5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CCF60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CCF64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CCF68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CCF6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CCF70: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CCF74: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CCF78: 396BD834  addi r11, r11, -0x27cc
	ctx.r[11].s64 = ctx.r[11].s64 + -10188;
	// 825CCF7C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CCF80: 4BFFF7D9  bl 0x825cc758
	ctx.lr = 0x825CCF84;
	sub_825CC758(ctx, base);
	// 825CCF84: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CCF88: 4182000C  beq 0x825ccf94
	if ctx.cr[0].eq {
	pc = 0x825CCF94; continue 'dispatch;
	}
	// 825CCF8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CCF90: 4BCF32D9  bl 0x822c0268
	ctx.lr = 0x825CCF94;
	sub_822C0268(ctx, base);
	// 825CCF94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CCF98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CCF9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CCFA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CCFA4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CCFA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CCFAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CCFB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CCFB0 size=96
    let mut pc: u32 = 0x825CCFB0;
    'dispatch: loop {
        match pc {
            0x825CCFB0 => {
    //   block [0x825CCFB0..0x825CD010)
	// 825CCFB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CCFB4: 48BDB1B5  bl 0x831a8168
	ctx.lr = 0x825CCFB8;
	sub_831A8130(ctx, base);
	// 825CCFB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CCFBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CCFC0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CCFC4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825CCFC8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825CCFCC: 4BF44125  bl 0x825110f0
	ctx.lr = 0x825CCFD0;
	sub_825110F0(ctx, base);
	// 825CCFD0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CCFD4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825CCFD8: 396BD92C  addi r11, r11, -0x26d4
	ctx.r[11].s64 = ctx.r[11].s64 + -9940;
	// 825CCFDC: 394AD914  addi r10, r10, -0x26ec
	ctx.r[10].s64 = ctx.r[10].s64 + -9964;
	// 825CCFE0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CCFE4: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 825CCFE8: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825CCFEC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825CCFF0: 48826C11  bl 0x82df3c00
	ctx.lr = 0x825CCFF4;
	sub_82DF3C00(ctx, base);
	// 825CCFF4: 387F00C4  addi r3, r31, 0xc4
	ctx.r[3].s64 = ctx.r[31].s64 + 196;
	// 825CCFF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CCFFC: 48826C05  bl 0x82df3c00
	ctx.lr = 0x825CD000;
	sub_82DF3C00(ctx, base);
	// 825CD000: 939F00C8  stw r28, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[28].u32 ) };
	// 825CD004: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CD008: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825CD00C: 48BDB1AC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CD010 size=88
    let mut pc: u32 = 0x825CD010;
    'dispatch: loop {
        match pc {
            0x825CD010 => {
    //   block [0x825CD010..0x825CD068)
	// 825CD010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CD014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CD018: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CD01C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CD020: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CD024: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CD028: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825CD02C: 396BD92C  addi r11, r11, -0x26d4
	ctx.r[11].s64 = ctx.r[11].s64 + -9940;
	// 825CD030: 394AD914  addi r10, r10, -0x26ec
	ctx.r[10].s64 = ctx.r[10].s64 + -9964;
	// 825CD034: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CD038: 387F00C4  addi r3, r31, 0xc4
	ctx.r[3].s64 = ctx.r[31].s64 + 196;
	// 825CD03C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825CD040: 488263E9  bl 0x82df3428
	ctx.lr = 0x825CD044;
	sub_82DF3428(ctx, base);
	// 825CD044: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 825CD048: 488263E1  bl 0x82df3428
	ctx.lr = 0x825CD04C;
	sub_82DF3428(ctx, base);
	// 825CD04C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CD050: 4BF44149  bl 0x82511198
	ctx.lr = 0x825CD054;
	sub_82511198(ctx, base);
	// 825CD054: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825CD058: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CD05C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CD060: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CD064: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CD068 size=52
    let mut pc: u32 = 0x825CD068;
    'dispatch: loop {
        match pc {
            0x825CD068 => {
    //   block [0x825CD068..0x825CD09C)
	// 825CD068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CD06C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CD070: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CD074: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CD078: 388400C0  addi r4, r4, 0xc0
	ctx.r[4].s64 = ctx.r[4].s64 + 192;
	// 825CD07C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CD080: 48826B81  bl 0x82df3c00
	ctx.lr = 0x825CD084;
	sub_82DF3C00(ctx, base);
	// 825CD084: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CD088: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825CD08C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CD090: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CD094: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CD098: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD0A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CD0A0 size=76
    let mut pc: u32 = 0x825CD0A0;
    'dispatch: loop {
        match pc {
            0x825CD0A0 => {
    //   block [0x825CD0A0..0x825CD0EC)
	// 825CD0A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CD0A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CD0A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CD0AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CD0B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CD0B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CD0B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CD0BC: 4BFFFF55  bl 0x825cd010
	ctx.lr = 0x825CD0C0;
	sub_825CD010(ctx, base);
	// 825CD0C0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CD0C4: 4182000C  beq 0x825cd0d0
	if ctx.cr[0].eq {
	pc = 0x825CD0D0; continue 'dispatch;
	}
	// 825CD0C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CD0CC: 4882530D  bl 0x82df23d8
	ctx.lr = 0x825CD0D0;
	sub_82DF23D8(ctx, base);
	// 825CD0D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CD0D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CD0D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CD0DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CD0E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CD0E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CD0E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CD0F0 size=8
    let mut pc: u32 = 0x825CD0F0;
    'dispatch: loop {
        match pc {
            0x825CD0F0 => {
    //   block [0x825CD0F0..0x825CD0F8)
	// 825CD0F0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 825CD0F4: 4BFFFFAC  b 0x825cd0a0
	sub_825CD0A0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD0F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CD0F8 size=12
    let mut pc: u32 = 0x825CD0F8;
    'dispatch: loop {
        match pc {
            0x825CD0F8 => {
    //   block [0x825CD0F8..0x825CD104)
	// 825CD0F8: 808300C8  lwz r4, 0xc8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) } as u64;
	// 825CD0FC: 806300D0  lwz r3, 0xd0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(208 as u32) ) } as u64;
	// 825CD100: 4BFD39C8  b 0x825a0ac8
	sub_825A0AC8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CD108 size=164
    let mut pc: u32 = 0x825CD108;
    'dispatch: loop {
        match pc {
            0x825CD108 => {
    //   block [0x825CD108..0x825CD1AC)
	// 825CD108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CD10C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CD110: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CD114: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CD118: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CD11C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825CD120: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 825CD124: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CD128: 4BFFFE89  bl 0x825ccfb0
	ctx.lr = 0x825CD12C;
	sub_825CCFB0(ctx, base);
	// 825CD12C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CD130: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825CD134: 396BD994  addi r11, r11, -0x266c
	ctx.r[11].s64 = ctx.r[11].s64 + -9836;
	// 825CD138: 394AD97C  addi r10, r10, -0x2684
	ctx.r[10].s64 = ctx.r[10].s64 + -9860;
	// 825CD13C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CD140: 397F00D0  addi r11, r31, 0xd0
	ctx.r[11].s64 = ctx.r[31].s64 + 208;
	// 825CD144: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825CD148: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CD14C: 917F00D0  stw r11, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 825CD150: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CD154: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CD158: 917F00D4  stw r11, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 825CD15C: 419A0024  beq cr6, 0x825cd180
	if ctx.cr[6].eq {
	pc = 0x825CD180; continue 'dispatch;
	}
	// 825CD160: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825CD164: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825CD168: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CD16C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825CD170: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825CD174: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825CD178: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CD17C: 4082FFE8  bne 0x825cd164
	if !ctx.cr[0].eq {
	pc = 0x825CD164; continue 'dispatch;
	}
	// 825CD180: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CD184: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CD188: 419A0008  beq cr6, 0x825cd190
	if ctx.cr[6].eq {
	pc = 0x825CD190; continue 'dispatch;
	}
	// 825CD18C: 4BCF3705  bl 0x822c0890
	ctx.lr = 0x825CD190;
	sub_822C0890(ctx, base);
	// 825CD190: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CD194: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CD198: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CD19C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CD1A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CD1A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CD1A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD1B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CD1B0 size=8
    let mut pc: u32 = 0x825CD1B0;
    'dispatch: loop {
        match pc {
            0x825CD1B0 => {
    //   block [0x825CD1B0..0x825CD1B8)
	// 825CD1B0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 825CD1B4: 48000094  b 0x825cd248
	sub_825CD248(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD1B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CD1B8 size=56
    let mut pc: u32 = 0x825CD1B8;
    'dispatch: loop {
        match pc {
            0x825CD1B8 => {
    //   block [0x825CD1B8..0x825CD1F0)
	// 825CD1B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CD1BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CD1C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CD1C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CD1C8: 80A400C8  lwz r5, 0xc8(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(200 as u32) ) } as u64;
	// 825CD1CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CD1D0: 808400D0  lwz r4, 0xd0(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(208 as u32) ) } as u64;
	// 825CD1D4: 4BFD3AA5  bl 0x825a0c78
	ctx.lr = 0x825CD1D8;
	sub_825A0C78(ctx, base);
	// 825CD1D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CD1DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825CD1E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CD1E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CD1E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CD1EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CD1F0 size=88
    let mut pc: u32 = 0x825CD1F0;
    'dispatch: loop {
        match pc {
            0x825CD1F0 => {
    //   block [0x825CD1F0..0x825CD248)
	// 825CD1F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CD1F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CD1F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CD1FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CD200: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CD204: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CD208: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825CD20C: 396BD994  addi r11, r11, -0x266c
	ctx.r[11].s64 = ctx.r[11].s64 + -9836;
	// 825CD210: 394AD97C  addi r10, r10, -0x2684
	ctx.r[10].s64 = ctx.r[10].s64 + -9860;
	// 825CD214: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CD218: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825CD21C: 807F00D4  lwz r3, 0xd4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 825CD220: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CD224: 419A0008  beq cr6, 0x825cd22c
	if ctx.cr[6].eq {
	pc = 0x825CD22C; continue 'dispatch;
	}
	// 825CD228: 4BCF3669  bl 0x822c0890
	ctx.lr = 0x825CD22C;
	sub_822C0890(ctx, base);
	// 825CD22C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CD230: 4BFFFDE1  bl 0x825cd010
	ctx.lr = 0x825CD234;
	sub_825CD010(ctx, base);
	// 825CD234: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825CD238: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CD23C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CD240: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CD244: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CD248 size=76
    let mut pc: u32 = 0x825CD248;
    'dispatch: loop {
        match pc {
            0x825CD248 => {
    //   block [0x825CD248..0x825CD294)
	// 825CD248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CD24C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CD250: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CD254: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CD258: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CD25C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CD260: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CD264: 4BFFFF8D  bl 0x825cd1f0
	ctx.lr = 0x825CD268;
	sub_825CD1F0(ctx, base);
	// 825CD268: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CD26C: 4182000C  beq 0x825cd278
	if ctx.cr[0].eq {
	pc = 0x825CD278; continue 'dispatch;
	}
	// 825CD270: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CD274: 48825165  bl 0x82df23d8
	ctx.lr = 0x825CD278;
	sub_82DF23D8(ctx, base);
	// 825CD278: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CD27C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CD280: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CD284: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CD288: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CD28C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CD290: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CD298 size=188
    let mut pc: u32 = 0x825CD298;
    'dispatch: loop {
        match pc {
            0x825CD298 => {
    //   block [0x825CD298..0x825CD354)
	// 825CD298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CD29C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CD2A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CD2A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CD2A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CD2AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CD2B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CD2B4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825CD2B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825CD2BC: 388BD9E0  addi r4, r11, -0x2620
	ctx.r[4].s64 = ctx.r[11].s64 + -9760;
	// 825CD2C0: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 825CD2C4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825CD2C8: 4BCF3111  bl 0x822c03d8
	ctx.lr = 0x825CD2CC;
	sub_822C03D8(ctx, base);
	// 825CD2CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825CD2D0: 4182001C  beq 0x825cd2ec
	if ctx.cr[0].eq {
	pc = 0x825CD2EC; continue 'dispatch;
	}
	// 825CD2D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825CD2D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CD2DC: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825CD2E0: 480002C9  bl 0x825cd5a8
	ctx.lr = 0x825CD2E4;
	sub_825CD5A8(ctx, base);
	// 825CD2E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CD2E8: 48000008  b 0x825cd2f0
	pc = 0x825CD2F0; continue 'dispatch;
	// 825CD2EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825CD2F0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825CD2F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CD2F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825CD2FC: 4BFEB17D  bl 0x825b8478
	ctx.lr = 0x825CD300;
	sub_825B8478(ctx, base);
	// 825CD300: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825CD304: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CD308: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825CD30C: 4BCF2CF5  bl 0x822c0000
	ctx.lr = 0x825CD310;
	sub_822C0000(ctx, base);
	// 825CD310: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CD314: 809E00C8  lwz r4, 0xc8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(200 as u32) ) } as u64;
	// 825CD318: 807E00D0  lwz r3, 0xd0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) } as u64;
	// 825CD31C: 4BFD376D  bl 0x825a0a88
	ctx.lr = 0x825CD320;
	sub_825A0A88(ctx, base);
	// 825CD320: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825CD324: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CD328: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CD32C: 419A000C  beq cr6, 0x825cd338
	if ctx.cr[6].eq {
	pc = 0x825CD338; continue 'dispatch;
	}
	// 825CD330: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825CD334: 4BCF355D  bl 0x822c0890
	ctx.lr = 0x825CD338;
	sub_822C0890(ctx, base);
	// 825CD338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CD33C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CD340: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CD344: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CD348: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CD34C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CD350: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CD358 size=208
    let mut pc: u32 = 0x825CD358;
    'dispatch: loop {
        match pc {
            0x825CD358 => {
    //   block [0x825CD358..0x825CD428)
	// 825CD358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CD35C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CD360: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CD364: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CD368: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 825CD36C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CD370: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825CD374: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CD378: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 825CD37C: 4BFF56D5  bl 0x825c2a50
	ctx.lr = 0x825CD380;
	sub_825C2A50(ctx, base);
	// 825CD380: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 825CD384: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825CD388: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825CD38C: 388AD9E0  addi r4, r10, -0x2620
	ctx.r[4].s64 = ctx.r[10].s64 + -9760;
	// 825CD390: 38A0002E  li r5, 0x2e
	ctx.r[5].s64 = 46;
	// 825CD394: C00B89AC  lfs f0, -0x7654(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CD398: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825CD39C: EFE10032  fmuls f31, f1, f0
	ctx.f[31].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 825CD3A0: 4BCF3039  bl 0x822c03d8
	ctx.lr = 0x825CD3A4;
	sub_822C03D8(ctx, base);
	// 825CD3A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825CD3A8: 41820020  beq 0x825cd3c8
	if ctx.cr[0].eq {
	pc = 0x825CD3C8; continue 'dispatch;
	}
	// 825CD3AC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825CD3B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CD3B4: C00B964C  lfs f0, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CD3B8: EC3F0032  fmuls f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 825CD3BC: 480001ED  bl 0x825cd5a8
	ctx.lr = 0x825CD3C0;
	sub_825CD5A8(ctx, base);
	// 825CD3C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CD3C4: 48000008  b 0x825cd3cc
	pc = 0x825CD3CC; continue 'dispatch;
	// 825CD3C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825CD3CC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825CD3D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CD3D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825CD3D8: 4BFEB0A1  bl 0x825b8478
	ctx.lr = 0x825CD3DC;
	sub_825B8478(ctx, base);
	// 825CD3DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825CD3E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CD3E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825CD3E8: 4BCF2C19  bl 0x822c0000
	ctx.lr = 0x825CD3EC;
	sub_822C0000(ctx, base);
	// 825CD3EC: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CD3F0: 809E00C8  lwz r4, 0xc8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(200 as u32) ) } as u64;
	// 825CD3F4: 807E00D0  lwz r3, 0xd0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) } as u64;
	// 825CD3F8: 4BFD36B1  bl 0x825a0aa8
	ctx.lr = 0x825CD3FC;
	sub_825A0AA8(ctx, base);
	// 825CD3FC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825CD400: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CD404: 419A0008  beq cr6, 0x825cd40c
	if ctx.cr[6].eq {
	pc = 0x825CD40C; continue 'dispatch;
	}
	// 825CD408: 4BCF3489  bl 0x822c0890
	ctx.lr = 0x825CD40C;
	sub_822C0890(ctx, base);
	// 825CD40C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825CD410: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CD414: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CD418: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 825CD41C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CD420: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CD424: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CD428 size=176
    let mut pc: u32 = 0x825CD428;
    'dispatch: loop {
        match pc {
            0x825CD428 => {
    //   block [0x825CD428..0x825CD4D8)
	// 825CD428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CD42C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CD430: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CD434: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CD438: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CD43C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CD440: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CD444: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825CD448: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825CD44C: 388BD9E0  addi r4, r11, -0x2620
	ctx.r[4].s64 = ctx.r[11].s64 + -9760;
	// 825CD450: 38A00048  li r5, 0x48
	ctx.r[5].s64 = 72;
	// 825CD454: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825CD458: 4BCF2F81  bl 0x822c03d8
	ctx.lr = 0x825CD45C;
	sub_822C03D8(ctx, base);
	// 825CD45C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825CD460: 4182001C  beq 0x825cd47c
	if ctx.cr[0].eq {
	pc = 0x825CD47C; continue 'dispatch;
	}
	// 825CD464: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825CD468: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CD46C: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825CD470: 48000139  bl 0x825cd5a8
	ctx.lr = 0x825CD474;
	sub_825CD5A8(ctx, base);
	// 825CD474: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CD478: 48000008  b 0x825cd480
	pc = 0x825CD480; continue 'dispatch;
	// 825CD47C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825CD480: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825CD484: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CD488: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825CD48C: 4BFEAFED  bl 0x825b8478
	ctx.lr = 0x825CD490;
	sub_825B8478(ctx, base);
	// 825CD490: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825CD494: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CD498: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825CD49C: 4BCF2B65  bl 0x822c0000
	ctx.lr = 0x825CD4A0;
	sub_822C0000(ctx, base);
	// 825CD4A0: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CD4A4: 809E00C8  lwz r4, 0xc8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(200 as u32) ) } as u64;
	// 825CD4A8: 807E00D0  lwz r3, 0xd0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) } as u64;
	// 825CD4AC: 4BFD35BD  bl 0x825a0a68
	ctx.lr = 0x825CD4B0;
	sub_825A0A68(ctx, base);
	// 825CD4B0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825CD4B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CD4B8: 419A0008  beq cr6, 0x825cd4c0
	if ctx.cr[6].eq {
	pc = 0x825CD4C0; continue 'dispatch;
	}
	// 825CD4BC: 4BCF33D5  bl 0x822c0890
	ctx.lr = 0x825CD4C0;
	sub_822C0890(ctx, base);
	// 825CD4C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CD4C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CD4C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CD4CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CD4D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CD4D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CD4D8 size=16
    let mut pc: u32 = 0x825CD4D8;
    'dispatch: loop {
        match pc {
            0x825CD4D8 => {
    //   block [0x825CD4D8..0x825CD4E8)
	// 825CD4D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CD4DC: 396BDA4C  addi r11, r11, -0x25b4
	ctx.r[11].s64 = ctx.r[11].s64 + -9652;
	// 825CD4E0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CD4E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD4E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825CD4E8 size=12
    let mut pc: u32 = 0x825CD4E8;
    'dispatch: loop {
        match pc {
            0x825CD4E8 => {
    //   block [0x825CD4E8..0x825CD4F4)
	// 825CD4E8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825CD4EC: C02BC0AC  lfs f1, -0x3f54(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825CD4F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD4F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825CD4F8 size=8
    let mut pc: u32 = 0x825CD4F8;
    'dispatch: loop {
        match pc {
            0x825CD4F8 => {
    //   block [0x825CD4F8..0x825CD500)
	// 825CD4F8: C0230008  lfs f1, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825CD4FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CD500 size=8
    let mut pc: u32 = 0x825CD500;
    'dispatch: loop {
        match pc {
            0x825CD500 => {
    //   block [0x825CD500..0x825CD508)
	// 825CD500: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825CD504: 48825F24  b 0x82df3428
	sub_82DF3428(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CD508 size=16
    let mut pc: u32 = 0x825CD508;
    'dispatch: loop {
        match pc {
            0x825CD508 => {
    //   block [0x825CD508..0x825CD518)
	// 825CD508: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CD50C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CD510: 5563B7FE  rlwinm r3, r11, 0x16, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000003FFu64;
	// 825CD514: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CD518 size=16
    let mut pc: u32 = 0x825CD518;
    'dispatch: loop {
        match pc {
            0x825CD518 => {
    //   block [0x825CD518..0x825CD528)
	// 825CD518: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CD51C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CD520: 5563D7FE  rlwinm r3, r11, 0x1a, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 825CD524: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CD528 size=16
    let mut pc: u32 = 0x825CD528;
    'dispatch: loop {
        match pc {
            0x825CD528 => {
    //   block [0x825CD528..0x825CD538)
	// 825CD528: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CD52C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CD530: 5563CFFE  rlwinm r3, r11, 0x19, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 825CD534: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CD538 size=16
    let mut pc: u32 = 0x825CD538;
    'dispatch: loop {
        match pc {
            0x825CD538 => {
    //   block [0x825CD538..0x825CD548)
	// 825CD538: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CD53C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CD540: 5563BFFE  rlwinm r3, r11, 0x17, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000001FFu64;
	// 825CD544: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CD548 size=16
    let mut pc: u32 = 0x825CD548;
    'dispatch: loop {
        match pc {
            0x825CD548 => {
    //   block [0x825CD548..0x825CD558)
	// 825CD548: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CD54C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CD550: 5563C7FE  rlwinm r3, r11, 0x18, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825CD554: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CD558 size=16
    let mut pc: u32 = 0x825CD558;
    'dispatch: loop {
        match pc {
            0x825CD558 => {
    //   block [0x825CD558..0x825CD568)
	// 825CD558: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CD55C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CD560: 556307FE  clrlwi r3, r11, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 825CD564: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CD568 size=16
    let mut pc: u32 = 0x825CD568;
    'dispatch: loop {
        match pc {
            0x825CD568 => {
    //   block [0x825CD568..0x825CD578)
	// 825CD568: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CD56C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CD570: 5563FFFE  rlwinm r3, r11, 0x1f, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 825CD574: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CD578 size=16
    let mut pc: u32 = 0x825CD578;
    'dispatch: loop {
        match pc {
            0x825CD578 => {
    //   block [0x825CD578..0x825CD588)
	// 825CD578: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CD57C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CD580: 5563EFFE  rlwinm r3, r11, 0x1d, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 825CD584: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CD588 size=16
    let mut pc: u32 = 0x825CD588;
    'dispatch: loop {
        match pc {
            0x825CD588 => {
    //   block [0x825CD588..0x825CD598)
	// 825CD588: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CD58C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CD590: 5563E7FE  rlwinm r3, r11, 0x1c, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 825CD594: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CD598 size=16
    let mut pc: u32 = 0x825CD598;
    'dispatch: loop {
        match pc {
            0x825CD598 => {
    //   block [0x825CD598..0x825CD5A8)
	// 825CD598: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CD59C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825CD5A0: 806B0038  lwz r3, 0x38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 825CD5A4: 4BFE4774  b 0x825b1d18
	sub_825B1D18(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD5A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825CD5A8 size=24
    let mut pc: u32 = 0x825CD5A8;
    'dispatch: loop {
        match pc {
            0x825CD5A8 => {
    //   block [0x825CD5A8..0x825CD5C0)
	// 825CD5A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CD5AC: D0230008  stfs f1, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 825CD5B0: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 825CD5B4: 396BDA4C  addi r11, r11, -0x25b4
	ctx.r[11].s64 = ctx.r[11].s64 + -9652;
	// 825CD5B8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CD5BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD5C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CD5C0 size=196
    let mut pc: u32 = 0x825CD5C0;
    'dispatch: loop {
        match pc {
            0x825CD5C0 => {
    //   block [0x825CD5C0..0x825CD684)
	// 825CD5C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CD5C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CD5C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CD5CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CD5D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CD5D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CD5D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CD5DC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825CD5E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825CD5E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CD5E8: 4BCF3351  bl 0x822c0938
	ctx.lr = 0x825CD5EC;
	sub_822C0938(ctx, base);
	// 825CD5EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825CD5F0: 41820028  beq 0x825cd618
	if ctx.cr[0].eq {
	pc = 0x825CD618; continue 'dispatch;
	}
	// 825CD5F4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CD5F8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825CD5FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825CD600: 392BDAD0  addi r9, r11, -0x2530
	ctx.r[9].s64 = ctx.r[11].s64 + -9520;
	// 825CD604: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825CD608: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825CD60C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825CD610: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825CD614: 48000008  b 0x825cd61c
	pc = 0x825CD61C; continue 'dispatch;
	// 825CD618: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CD61C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CD620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CD624: 409A0044  bne cr6, 0x825cd668
	if !ctx.cr[6].eq {
	pc = 0x825CD668; continue 'dispatch;
	}
	// 825CD628: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825CD62C: 419A001C  beq cr6, 0x825cd648
	if ctx.cr[6].eq {
	pc = 0x825CD648; continue 'dispatch;
	}
	// 825CD630: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CD634: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825CD638: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CD63C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CD640: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CD644: 4E800421  bctrl
	ctx.lr = 0x825CD648;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CD648: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825CD64C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825CD650: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CD654: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825CD658: 816BB324  lwz r11, -0x4cdc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19676 as u32) ) } as u64;
	// 825CD65C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825CD660: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825CD664: 4BCF299D  bl 0x822c0000
	ctx.lr = 0x825CD668;
	sub_822C0000(ctx, base);
	// 825CD668: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CD66C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CD670: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CD674: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CD678: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CD67C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CD680: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CD688 size=352
    let mut pc: u32 = 0x825CD688;
    'dispatch: loop {
        match pc {
            0x825CD688 => {
    //   block [0x825CD688..0x825CD7E8)
	// 825CD688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CD68C: 48BDAADD  bl 0x831a8168
	ctx.lr = 0x825CD690;
	sub_831A8130(ctx, base);
	// 825CD690: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CD694: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825CD698: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CD69C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825CD6A0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825CD6A4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825CD6A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825CD6AC: 388BDAE0  addi r4, r11, -0x2520
	ctx.r[4].s64 = ctx.r[11].s64 + -9504;
	// 825CD6B0: 38A0008F  li r5, 0x8f
	ctx.r[5].s64 = 143;
	// 825CD6B4: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 825CD6B8: 4BCF2D21  bl 0x822c03d8
	ctx.lr = 0x825CD6BC;
	sub_822C03D8(ctx, base);
	// 825CD6BC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825CD6C0: 4182007C  beq 0x825cd73c
	if ctx.cr[0].eq {
	pc = 0x825CD73C; continue 'dispatch;
	}
	// 825CD6C4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825CD6C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CD6CC: 388B9BC9  addi r4, r11, -0x6437
	ctx.r[4].s64 = ctx.r[11].s64 + -25655;
	// 825CD6D0: 48826339  bl 0x82df3a08
	ctx.lr = 0x825CD6D4;
	sub_82DF3A08(ctx, base);
	// 825CD6D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825CD6D8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825CD6DC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825CD6E0: 3D008203  lis r8, -0x7dfd
	ctx.r[8].s64 = -2113732608;
	// 825CD6E4: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 825CD6E8: C1AB9688  lfs f13, -0x6978(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27000 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825CD6EC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 825CD6F0: C18AD72C  lfs f12, -0x28d4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10452 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825CD6F4: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825CD6F8: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CD6FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825CD700: C1686974  lfs f11, 0x6974(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(26996 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825CD704: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CD708: C1479664  lfs f10, -0x699c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27036 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825CD70C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 825CD710: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825CD714: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825CD718: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825CD71C: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825CD720: D1610070  stfs f11, 0x70(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825CD724: D1410074  stfs f10, 0x74(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825CD728: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825CD72C: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 825CD730: 4BFFF7E9  bl 0x825ccf18
	ctx.lr = 0x825CD734;
	sub_825CCF18(ctx, base);
	// 825CD734: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CD738: 48000008  b 0x825cd740
	pc = 0x825CD740; continue 'dispatch;
	// 825CD73C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825CD740: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825CD744: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CD748: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825CD74C: 4BFFFE75  bl 0x825cd5c0
	ctx.lr = 0x825CD750;
	sub_825CD5C0(ctx, base);
	// 825CD750: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825CD754: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CD758: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825CD75C: 4BCF28A5  bl 0x822c0000
	ctx.lr = 0x825CD760;
	sub_822C0000(ctx, base);
	// 825CD760: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CD764: 4182000C  beq 0x825cd770
	if ctx.cr[0].eq {
	pc = 0x825CD770; continue 'dispatch;
	}
	// 825CD768: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CD76C: 48825CBD  bl 0x82df3428
	ctx.lr = 0x825CD770;
	sub_82DF3428(ctx, base);
	// 825CD770: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825CD774: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825CD778: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CD77C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CD780: 816B0060  lwz r11, 0x60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 825CD784: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CD788: 4E800421  bctrl
	ctx.lr = 0x825CD78C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CD78C: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825CD790: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 825CD794: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825CD798: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825CD79C: 419A0024  beq cr6, 0x825cd7c0
	if ctx.cr[6].eq {
	pc = 0x825CD7C0; continue 'dispatch;
	}
	// 825CD7A0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825CD7A4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825CD7A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CD7AC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825CD7B0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825CD7B4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825CD7B8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CD7BC: 4082FFE8  bne 0x825cd7a4
	if !ctx.cr[0].eq {
	pc = 0x825CD7A4; continue 'dispatch;
	}
	// 825CD7C0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CD7C4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825CD7C8: 806B0034  lwz r3, 0x34(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 825CD7CC: 4BFF8D75  bl 0x825c6540
	ctx.lr = 0x825CD7D0;
	sub_825C6540(ctx, base);
	// 825CD7D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825CD7D4: 419A000C  beq cr6, 0x825cd7e0
	if ctx.cr[6].eq {
	pc = 0x825CD7E0; continue 'dispatch;
	}
	// 825CD7D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CD7DC: 4BCF30B5  bl 0x822c0890
	ctx.lr = 0x825CD7E0;
	sub_822C0890(ctx, base);
	// 825CD7E0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825CD7E4: 48BDA9D4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD7E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CD7E8 size=20
    let mut pc: u32 = 0x825CD7E8;
    'dispatch: loop {
        match pc {
            0x825CD7E8 => {
    //   block [0x825CD7E8..0x825CD7FC)
	// 825CD7E8: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CD7EC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CD7F0: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 825CD7F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825CD7F8: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD7FC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CD7FC size=40
    let mut pc: u32 = 0x825CD7FC;
    'dispatch: loop {
        match pc {
            0x825CD7FC => {
    //   block [0x825CD7FC..0x825CD824)
	// 825CD7FC: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CD800: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825CD804: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825CD808: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825CD80C: 41980008  blt cr6, 0x825cd814
	if ctx.cr[6].lt {
	pc = 0x825CD814; continue 'dispatch;
	}
	// 825CD810: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825CD814: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825CD818: 4182000C  beq 0x825cd824
	if ctx.cr[0].eq {
		sub_825CD824(ctx, base);
		return;
	}
	// 825CD81C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CD820: 4800000C  b 0x825cd82c
	sub_825CD824(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD824(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CD824 size=24
    let mut pc: u32 = 0x825CD824;
    'dispatch: loop {
        match pc {
            0x825CD824 => {
    //   block [0x825CD824..0x825CD83C)
	// 825CD824: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825CD828: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CD82C: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 825CD830: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825CD834: 419AFFCC  beq cr6, 0x825cd800
	if ctx.cr[6].eq {
		sub_825CD7FC(ctx, base);
		return;
	}
	// 825CD838: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CD840 size=120
    let mut pc: u32 = 0x825CD840;
    'dispatch: loop {
        match pc {
            0x825CD840 => {
    //   block [0x825CD840..0x825CD8B8)
	// 825CD840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CD844: 48BDA929  bl 0x831a816c
	ctx.lr = 0x825CD848;
	sub_831A8130(ctx, base);
	// 825CD848: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CD84C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825CD850: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825CD854: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CD858: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CD85C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825CD860: 4BFFFF89  bl 0x825cd7e8
	ctx.lr = 0x825CD864;
	sub_825CD7E8(ctx, base);
	// 825CD864: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CD868: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 825CD86C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CD870: 419A002C  beq cr6, 0x825cd89c
	if ctx.cr[6].eq {
	pc = 0x825CD89C; continue 'dispatch;
	}
	// 825CD874: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CD878: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825CD87C: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825CD880: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825CD884: 41980008  blt cr6, 0x825cd88c
	if ctx.cr[6].lt {
	pc = 0x825CD88C; continue 'dispatch;
	}
	// 825CD888: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825CD88C: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825CD890: 4082000C  bne 0x825cd89c
	if !ctx.cr[0].eq {
	pc = 0x825CD89C; continue 'dispatch;
	}
	// 825CD894: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825CD898: 4800000C  b 0x825cd8a4
	pc = 0x825CD8A4; continue 'dispatch;
	// 825CD89C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825CD8A0: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 825CD8A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CD8A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CD8AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CD8B0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825CD8B4: 48BDA908  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD8B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CD8B8 size=152
    let mut pc: u32 = 0x825CD8B8;
    'dispatch: loop {
        match pc {
            0x825CD8B8 => {
    //   block [0x825CD8B8..0x825CD950)
	// 825CD8B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CD8BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CD8C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CD8C4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CD8C8: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 825CD8CC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825CD8D0: 38A10084  addi r5, r1, 0x84
	ctx.r[5].s64 = ctx.r[1].s64 + 132;
	// 825CD8D4: 3BEB7D40  addi r31, r11, 0x7d40
	ctx.r[31].s64 = ctx.r[11].s64 + 32064;
	// 825CD8D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CD8DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CD8E0: 4BFFFF61  bl 0x825cd840
	ctx.lr = 0x825CD8E4;
	sub_825CD840(ctx, base);
	// 825CD8E4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CD8E8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CD8EC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CD8F0: 419A000C  beq cr6, 0x825cd8fc
	if ctx.cr[6].eq {
	pc = 0x825CD8FC; continue 'dispatch;
	}
	// 825CD8F4: 386A0010  addi r3, r10, 0x10
	ctx.r[3].s64 = ctx.r[10].s64 + 16;
	// 825CD8F8: 48000044  b 0x825cd93c
	pc = 0x825CD93C; continue 'dispatch;
	// 825CD8FC: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825CD900: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825CD904: 3BEB7D38  addi r31, r11, 0x7d38
	ctx.r[31].s64 = ctx.r[11].s64 + 32056;
	// 825CD908: 816A7D3C  lwz r11, 0x7d3c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32060 as u32) ) } as u64;
	// 825CD90C: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825CD910: 40820028  bne 0x825cd938
	if !ctx.cr[0].eq {
	pc = 0x825CD938; continue 'dispatch;
	}
	// 825CD914: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825CD918: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825CD91C: 916A7D3C  stw r11, 0x7d3c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32060 as u32), ctx.r[11].u32 ) };
	// 825CD920: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CD924: 3889CE44  addi r4, r9, -0x31bc
	ctx.r[4].s64 = ctx.r[9].s64 + -12732;
	// 825CD928: 488260E1  bl 0x82df3a08
	ctx.lr = 0x825CD92C;
	sub_82DF3A08(ctx, base);
	// 825CD92C: 3D608324  lis r11, -0x7cdc
	ctx.r[11].s64 = -2094792704;
	// 825CD930: 386BF770  addi r3, r11, -0x890
	ctx.r[3].s64 = ctx.r[11].s64 + -2192;
	// 825CD934: 48BDABA5  bl 0x831a84d8
	ctx.lr = 0x825CD938;
	sub_831A84D8(ctx, base);
	// 825CD938: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CD93C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CD940: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CD944: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CD948: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CD94C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CD950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CD950 size=568
    let mut pc: u32 = 0x825CD950;
    'dispatch: loop {
        match pc {
            0x825CD950 => {
    //   block [0x825CD950..0x825CDB88)
	// 825CD950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CD954: 48BDA809  bl 0x831a815c
	ctx.lr = 0x825CD958;
	sub_831A8130(ctx, base);
	// 825CD958: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CD95C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CD960: 3D601FFF  lis r11, 0x1fff
	ctx.r[11].s64 = 536805376;
	// 825CD964: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825CD968: 616BFFFE  ori r11, r11, 0xfffe
	ctx.r[11].u64 = ctx.r[11].u64 | 65534;
	// 825CD96C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 825CD970: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CD974: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 825CD978: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 825CD97C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CD980: 41980048  blt cr6, 0x825cd9c8
	if ctx.cr[6].lt {
	pc = 0x825CD9C8; continue 'dispatch;
	}
	// 825CD984: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825CD988: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CD98C: 388B9BCC  addi r4, r11, -0x6434
	ctx.r[4].s64 = ctx.r[11].s64 + -25652;
	// 825CD990: 4BCF7F39  bl 0x822c58c8
	ctx.lr = 0x825CD994;
	sub_822C58C8(ctx, base);
	// 825CD994: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825CD998: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825CD99C: 4BCF7E7D  bl 0x822c5818
	ctx.lr = 0x825CD9A0;
	sub_822C5818(ctx, base);
	// 825CD9A0: 4BCF6911  bl 0x822c42b0
	ctx.lr = 0x825CD9A4;
	sub_822C42B0(ctx, base);
	// 825CD9A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825CD9A8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825CD9AC: 396B94A0  addi r11, r11, -0x6b60
	ctx.r[11].s64 = ctx.r[11].s64 + -27488;
	// 825CD9B0: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825CD9B4: 4BCF7ABD  bl 0x822c5470
	ctx.lr = 0x825CD9B8;
	sub_822C5470(ctx, base);
	// 825CD9B8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825CD9BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825CD9C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CD9C4: 4BCF731D  bl 0x822c4ce0
	ctx.lr = 0x825CD9C8;
	sub_822C4CE0(ctx, base);
	// 825CD9C8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825CD9CC: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CD9D0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825CD9D4: 4829D5BD  bl 0x8286af90
	ctx.lr = 0x825CD9D8;
	sub_8286AF90(ctx, base);
	// 825CD9D8: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 825CD9DC: 41820020  beq 0x825cd9fc
	if ctx.cr[0].eq {
	pc = 0x825CD9FC; continue 'dispatch;
	}
	// 825CD9E0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825CD9E4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825CD9E8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825CD9EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825CD9F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825CD9F4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825CD9F8: 4BEC4839  bl 0x82492230
	ctx.lr = 0x825CD9FC;
	sub_82492230(ctx, base);
	// 825CD9FC: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CDA00: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDA04: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825CDA08: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CDA0C: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825CDA10: 409A0018  bne cr6, 0x825cda28
	if !ctx.cr[6].eq {
	pc = 0x825CDA28; continue 'dispatch;
	}
	// 825CDA14: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 825CDA18: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDA1C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825CDA20: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDA24: 4800003C  b 0x825cda60
	pc = 0x825CDA60; continue 'dispatch;
	// 825CDA28: 574B063F  clrlwi. r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CDA2C: 41820020  beq 0x825cda4c
	if ctx.cr[0].eq {
	pc = 0x825CDA4C; continue 'dispatch;
	}
	// 825CDA30: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825CDA34: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDA38: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CDA3C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825CDA40: 409A0024  bne cr6, 0x825cda64
	if !ctx.cr[6].eq {
	pc = 0x825CDA64; continue 'dispatch;
	}
	// 825CDA44: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825CDA48: 4800001C  b 0x825cda64
	pc = 0x825CDA64; continue 'dispatch;
	// 825CDA4C: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 825CDA50: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDA54: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CDA58: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825CDA5C: 409A0008  bne cr6, 0x825cda64
	if !ctx.cr[6].eq {
	pc = 0x825CDA64; continue 'dispatch;
	}
	// 825CDA60: 938B0008  stw r28, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 825CDA64: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDA68: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825CDA6C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 825CDA70: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 825CDA74: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 825CDA78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825CDA7C: 409A00F0  bne cr6, 0x825cdb6c
	if !ctx.cr[6].eq {
	pc = 0x825CDB6C; continue 'dispatch;
	}
	// 825CDA80: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825CDA84: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CDA88: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDA8C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CDA90: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825CDA94: 409A0054  bne cr6, 0x825cdae8
	if !ctx.cr[6].eq {
	pc = 0x825CDAE8; continue 'dispatch;
	}
	// 825CDA98: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CDA9C: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 825CDAA0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825CDAA4: 419A0054  beq cr6, 0x825cdaf8
	if ctx.cr[6].eq {
	pc = 0x825CDAF8; continue 'dispatch;
	}
	// 825CDAA8: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CDAAC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CDAB0: 409A0010  bne cr6, 0x825cdac0
	if !ctx.cr[6].eq {
	pc = 0x825CDAC0; continue 'dispatch;
	}
	// 825CDAB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CDAB8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825CDABC: 485E9115  bl 0x82bb6bd0
	ctx.lr = 0x825CDAC0;
	sub_82BB6BD0(ctx, base);
	// 825CDAC0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDAC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CDAC8: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 825CDACC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDAD0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDAD4: 9B6B0014  stb r27, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[27].u8 ) };
	// 825CDAD8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDADC: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDAE0: 4BD20A31  bl 0x822ee510
	ctx.lr = 0x825CDAE4;
	sub_822EE510(ctx, base);
	// 825CDAE4: 48000074  b 0x825cdb58
	pc = 0x825CDB58; continue 'dispatch;
	// 825CDAE8: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CDAEC: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 825CDAF0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825CDAF4: 409A0028  bne cr6, 0x825cdb1c
	if !ctx.cr[6].eq {
	pc = 0x825CDB1C; continue 'dispatch;
	}
	// 825CDAF8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CDAFC: 9BA90014  stb r29, 0x14(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 825CDB00: 9BAA0014  stb r29, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 825CDB04: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CDB08: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDB0C: 9B6A0014  stb r27, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[27].u8 ) };
	// 825CDB10: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CDB14: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDB18: 48000040  b 0x825cdb58
	pc = 0x825CDB58; continue 'dispatch;
	// 825CDB1C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CDB20: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CDB24: 409A0010  bne cr6, 0x825cdb34
	if !ctx.cr[6].eq {
	pc = 0x825CDB34; continue 'dispatch;
	}
	// 825CDB28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CDB2C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825CDB30: 4BD209E1  bl 0x822ee510
	ctx.lr = 0x825CDB34;
	sub_822EE510(ctx, base);
	// 825CDB34: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDB38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CDB3C: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 825CDB40: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDB44: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDB48: 9B6B0014  stb r27, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[27].u8 ) };
	// 825CDB4C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDB50: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDB54: 485E907D  bl 0x82bb6bd0
	ctx.lr = 0x825CDB58;
	sub_82BB6BD0(ctx, base);
	// 825CDB58: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDB5C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825CDB60: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 825CDB64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825CDB68: 419AFF1C  beq cr6, 0x825cda84
	if ctx.cr[6].eq {
	pc = 0x825CDA84; continue 'dispatch;
	}
	// 825CDB6C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDB70: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825CDB74: 93990000  stw r28, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825CDB78: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDB7C: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 825CDB80: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825CDB84: 48BDA628  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CDB88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CDB88 size=1016
    let mut pc: u32 = 0x825CDB88;
    'dispatch: loop {
        match pc {
            0x825CDB88 => {
    //   block [0x825CDB88..0x825CDF80)
	// 825CDB88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CDB8C: 48BDA5CD  bl 0x831a8158
	ctx.lr = 0x825CDB90;
	sub_831A8130(ctx, base);
	// 825CDB90: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CDB94: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825CDB98: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 825CDB9C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825CDBA0: 93E10104  stw r31, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[31].u32 ) };
	// 825CDBA4: 897F0015  lbz r11, 0x15(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 825CDBA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CDBAC: 419A0048  beq cr6, 0x825cdbf4
	if ctx.cr[6].eq {
	pc = 0x825CDBF4; continue 'dispatch;
	}
	// 825CDBB0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825CDBB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CDBB8: 388B9620  addi r4, r11, -0x69e0
	ctx.r[4].s64 = ctx.r[11].s64 + -27104;
	// 825CDBBC: 4BCF7D0D  bl 0x822c58c8
	ctx.lr = 0x825CDBC0;
	sub_822C58C8(ctx, base);
	// 825CDBC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825CDBC4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825CDBC8: 4BCFC2E9  bl 0x822c9eb0
	ctx.lr = 0x825CDBCC;
	sub_822C9EB0(ctx, base);
	// 825CDBCC: 4BCF66E5  bl 0x822c42b0
	ctx.lr = 0x825CDBD0;
	sub_822C42B0(ctx, base);
	// 825CDBD0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825CDBD4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825CDBD8: 396B9600  addi r11, r11, -0x6a00
	ctx.r[11].s64 = ctx.r[11].s64 + -27136;
	// 825CDBDC: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825CDBE0: 4BCF7891  bl 0x822c5470
	ctx.lr = 0x825CDBE4;
	sub_822C5470(ctx, base);
	// 825CDBE4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825CDBE8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825CDBEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CDBF0: 4BCF70F1  bl 0x822c4ce0
	ctx.lr = 0x825CDBF4;
	sub_822C4CE0(ctx, base);
	// 825CDBF4: 38610104  addi r3, r1, 0x104
	ctx.r[3].s64 = ctx.r[1].s64 + 260;
	// 825CDBF8: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 825CDBFC: 4BF1B495  bl 0x824e9090
	ctx.lr = 0x825CDC00;
	sub_824E9090(ctx, base);
	// 825CDC00: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CDC04: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 825CDC08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825CDC0C: 83210104  lwz r25, 0x104(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 825CDC10: 419A000C  beq cr6, 0x825cdc1c
	if ctx.cr[6].eq {
	pc = 0x825CDC1C; continue 'dispatch;
	}
	// 825CDC14: 839A0008  lwz r28, 8(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CDC18: 48000028  b 0x825cdc40
	pc = 0x825CDC40; continue 'dispatch;
	// 825CDC1C: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CDC20: 894A0015  lbz r10, 0x15(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 825CDC24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825CDC28: 419A000C  beq cr6, 0x825cdc34
	if ctx.cr[6].eq {
	pc = 0x825CDC34; continue 'dispatch;
	}
	// 825CDC2C: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 825CDC30: 48000010  b 0x825cdc40
	pc = 0x825CDC40; continue 'dispatch;
	// 825CDC34: 83990008  lwz r28, 8(r25)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CDC38: 7F19D040  cmplw cr6, r25, r26
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825CDC3C: 409A00DC  bne cr6, 0x825cdd18
	if !ctx.cr[6].eq {
	pc = 0x825CDD18; continue 'dispatch;
	}
	// 825CDC40: 897C0015  lbz r11, 0x15(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(21 as u32) ) } as u64;
	// 825CDC44: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDC48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CDC4C: 409A0008  bne cr6, 0x825cdc54
	if !ctx.cr[6].eq {
	pc = 0x825CDC54; continue 'dispatch;
	}
	// 825CDC50: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825CDC54: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDC58: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDC5C: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825CDC60: 409A000C  bne cr6, 0x825cdc6c
	if !ctx.cr[6].eq {
	pc = 0x825CDC6C; continue 'dispatch;
	}
	// 825CDC64: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 825CDC68: 4800001C  b 0x825cdc84
	pc = 0x825CDC84; continue 'dispatch;
	// 825CDC6C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CDC70: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825CDC74: 409A000C  bne cr6, 0x825cdc80
	if !ctx.cr[6].eq {
	pc = 0x825CDC80; continue 'dispatch;
	}
	// 825CDC78: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825CDC7C: 48000008  b 0x825cdc84
	pc = 0x825CDC84; continue 'dispatch;
	// 825CDC80: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 825CDC84: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDC88: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CDC8C: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825CDC90: 409A003C  bne cr6, 0x825cdccc
	if !ctx.cr[6].eq {
	pc = 0x825CDCCC; continue 'dispatch;
	}
	// 825CDC94: 897C0015  lbz r11, 0x15(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(21 as u32) ) } as u64;
	// 825CDC98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CDC9C: 419A000C  beq cr6, 0x825cdca8
	if ctx.cr[6].eq {
	pc = 0x825CDCA8; continue 'dispatch;
	}
	// 825CDCA0: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 825CDCA4: 48000024  b 0x825cdcc8
	pc = 0x825CDCC8; continue 'dispatch;
	// 825CDCA8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CDCAC: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 825CDCB0: 4800000C  b 0x825cdcbc
	pc = 0x825CDCBC; continue 'dispatch;
	// 825CDCB4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825CDCB8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CDCBC: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 825CDCC0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825CDCC4: 419AFFF0  beq cr6, 0x825cdcb4
	if ctx.cr[6].eq {
	pc = 0x825CDCB4; continue 'dispatch;
	}
	// 825CDCC8: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825CDCCC: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDCD0: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CDCD4: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825CDCD8: 409A00D4  bne cr6, 0x825cddac
	if !ctx.cr[6].eq {
	pc = 0x825CDDAC; continue 'dispatch;
	}
	// 825CDCDC: 897C0015  lbz r11, 0x15(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(21 as u32) ) } as u64;
	// 825CDCE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CDCE4: 419A000C  beq cr6, 0x825cdcf0
	if ctx.cr[6].eq {
	pc = 0x825CDCF0; continue 'dispatch;
	}
	// 825CDCE8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 825CDCEC: 48000024  b 0x825cdd10
	pc = 0x825CDD10; continue 'dispatch;
	// 825CDCF0: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CDCF4: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 825CDCF8: 4800000C  b 0x825cdd04
	pc = 0x825CDD04; continue 'dispatch;
	// 825CDCFC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825CDD00: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CDD04: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 825CDD08: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825CDD0C: 419AFFF0  beq cr6, 0x825cdcfc
	if ctx.cr[6].eq {
	pc = 0x825CDCFC; continue 'dispatch;
	}
	// 825CDD10: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825CDD14: 48000098  b 0x825cddac
	pc = 0x825CDDAC; continue 'dispatch;
	// 825CDD18: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 825CDD1C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CDD20: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CDD24: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CDD28: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CDD2C: 409A000C  bne cr6, 0x825cdd38
	if !ctx.cr[6].eq {
	pc = 0x825CDD38; continue 'dispatch;
	}
	// 825CDD30: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 825CDD34: 4800002C  b 0x825cdd60
	pc = 0x825CDD60; continue 'dispatch;
	// 825CDD38: 897C0015  lbz r11, 0x15(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(21 as u32) ) } as u64;
	// 825CDD3C: 83F90004  lwz r31, 4(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDD40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CDD44: 409A0008  bne cr6, 0x825cdd4c
	if !ctx.cr[6].eq {
	pc = 0x825CDD4C; continue 'dispatch;
	}
	// 825CDD48: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825CDD4C: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825CDD50: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CDD54: 91790008  stw r11, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825CDD58: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CDD5C: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 825CDD60: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDD64: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDD68: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825CDD6C: 409A000C  bne cr6, 0x825cdd78
	if !ctx.cr[6].eq {
	pc = 0x825CDD78; continue 'dispatch;
	}
	// 825CDD70: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 825CDD74: 48000020  b 0x825cdd94
	pc = 0x825CDD94; continue 'dispatch;
	// 825CDD78: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDD7C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CDD80: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825CDD84: 409A000C  bne cr6, 0x825cdd90
	if !ctx.cr[6].eq {
	pc = 0x825CDD90; continue 'dispatch;
	}
	// 825CDD88: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 825CDD8C: 48000008  b 0x825cdd94
	pc = 0x825CDD94; continue 'dispatch;
	// 825CDD90: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 825CDD94: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDD98: 91790004  stw r11, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825CDD9C: 897A0014  lbz r11, 0x14(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 825CDDA0: 89590014  lbz r10, 0x14(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) } as u64;
	// 825CDDA4: 99790014  stb r11, 0x14(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 825CDDA8: 995A0014  stb r10, 0x14(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 825CDDAC: 897A0014  lbz r11, 0x14(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 825CDDB0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825CDDB4: 409A0198  bne cr6, 0x825cdf4c
	if !ctx.cr[6].eq {
	pc = 0x825CDF4C; continue 'dispatch;
	}
	// 825CDDB8: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDDBC: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 825CDDC0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDDC4: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CDDC8: 419A0180  beq cr6, 0x825cdf48
	if ctx.cr[6].eq {
	pc = 0x825CDF48; continue 'dispatch;
	}
	// 825CDDCC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825CDDD0: 897C0014  lbz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 825CDDD4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825CDDD8: 409A0170  bne cr6, 0x825cdf48
	if !ctx.cr[6].eq {
	pc = 0x825CDF48; continue 'dispatch;
	}
	// 825CDDDC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CDDE0: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CDDE4: 409A00A8  bne cr6, 0x825cde8c
	if !ctx.cr[6].eq {
	pc = 0x825CDE8C; continue 'dispatch;
	}
	// 825CDDE8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CDDEC: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825CDDF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825CDDF4: 409A001C  bne cr6, 0x825cde10
	if !ctx.cr[6].eq {
	pc = 0x825CDE10; continue 'dispatch;
	}
	// 825CDDF8: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 825CDDFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CDE00: 9BBF0014  stb r29, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 825CDE04: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825CDE08: 485E8DC9  bl 0x82bb6bd0
	ctx.lr = 0x825CDE0C;
	sub_82BB6BD0(ctx, base);
	// 825CDE0C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CDE10: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 825CDE14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825CDE18: 409A00C8  bne cr6, 0x825cdee0
	if !ctx.cr[6].eq {
	pc = 0x825CDEE0; continue 'dispatch;
	}
	// 825CDE1C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CDE20: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 825CDE24: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 825CDE28: 409A0014  bne cr6, 0x825cde3c
	if !ctx.cr[6].eq {
	pc = 0x825CDE3C; continue 'dispatch;
	}
	// 825CDE2C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CDE30: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 825CDE34: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 825CDE38: 419A00A4  beq cr6, 0x825cdedc
	if ctx.cr[6].eq {
	pc = 0x825CDEDC; continue 'dispatch;
	}
	// 825CDE3C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CDE40: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 825CDE44: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 825CDE48: 409A0020  bne cr6, 0x825cde68
	if !ctx.cr[6].eq {
	pc = 0x825CDE68; continue 'dispatch;
	}
	// 825CDE4C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CDE50: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 825CDE54: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825CDE58: 9BCA0014  stb r30, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 825CDE5C: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 825CDE60: 4BD206B1  bl 0x822ee510
	ctx.lr = 0x825CDE64;
	sub_822EE510(ctx, base);
	// 825CDE64: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CDE68: 895F0014  lbz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 825CDE6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CDE70: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825CDE74: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 825CDE78: 9BDF0014  stb r30, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 825CDE7C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CDE80: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 825CDE84: 485E8D4D  bl 0x82bb6bd0
	ctx.lr = 0x825CDE88;
	sub_82BB6BD0(ctx, base);
	// 825CDE88: 480000C0  b 0x825cdf48
	pc = 0x825CDF48; continue 'dispatch;
	// 825CDE8C: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825CDE90: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825CDE94: 409A001C  bne cr6, 0x825cdeb0
	if !ctx.cr[6].eq {
	pc = 0x825CDEB0; continue 'dispatch;
	}
	// 825CDE98: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 825CDE9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CDEA0: 9BBF0014  stb r29, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 825CDEA4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825CDEA8: 4BD20669  bl 0x822ee510
	ctx.lr = 0x825CDEAC;
	sub_822EE510(ctx, base);
	// 825CDEAC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CDEB0: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 825CDEB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825CDEB8: 409A0028  bne cr6, 0x825cdee0
	if !ctx.cr[6].eq {
	pc = 0x825CDEE0; continue 'dispatch;
	}
	// 825CDEBC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CDEC0: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 825CDEC4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 825CDEC8: 409A0034  bne cr6, 0x825cdefc
	if !ctx.cr[6].eq {
	pc = 0x825CDEFC; continue 'dispatch;
	}
	// 825CDECC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CDED0: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 825CDED4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 825CDED8: 409A0024  bne cr6, 0x825cdefc
	if !ctx.cr[6].eq {
	pc = 0x825CDEFC; continue 'dispatch;
	}
	// 825CDEDC: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 825CDEE0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDEE4: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 825CDEE8: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDEEC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDEF0: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CDEF4: 409AFEDC  bne cr6, 0x825cddd0
	if !ctx.cr[6].eq {
	pc = 0x825CDDD0; continue 'dispatch;
	}
	// 825CDEF8: 48000050  b 0x825cdf48
	pc = 0x825CDF48; continue 'dispatch;
	// 825CDEFC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CDF00: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 825CDF04: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 825CDF08: 409A0020  bne cr6, 0x825cdf28
	if !ctx.cr[6].eq {
	pc = 0x825CDF28; continue 'dispatch;
	}
	// 825CDF0C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CDF10: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 825CDF14: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825CDF18: 9BCA0014  stb r30, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 825CDF1C: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 825CDF20: 485E8CB1  bl 0x82bb6bd0
	ctx.lr = 0x825CDF24;
	sub_82BB6BD0(ctx, base);
	// 825CDF24: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CDF28: 895F0014  lbz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 825CDF2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CDF30: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825CDF34: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 825CDF38: 9BDF0014  stb r30, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 825CDF3C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CDF40: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 825CDF44: 4BD205CD  bl 0x822ee510
	ctx.lr = 0x825CDF48;
	sub_822EE510(ctx, base);
	// 825CDF48: 9BDC0014  stb r30, 0x14(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 825CDF4C: 387A0010  addi r3, r26, 0x10
	ctx.r[3].s64 = ctx.r[26].s64 + 16;
	// 825CDF50: 488254D9  bl 0x82df3428
	ctx.lr = 0x825CDF54;
	sub_82DF3428(ctx, base);
	// 825CDF54: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825CDF58: 4BCF2311  bl 0x822c0268
	ctx.lr = 0x825CDF5C;
	sub_822C0268(ctx, base);
	// 825CDF5C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CDF60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CDF64: 419A000C  beq cr6, 0x825cdf70
	if ctx.cr[6].eq {
	pc = 0x825CDF70; continue 'dispatch;
	}
	// 825CDF68: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825CDF6C: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825CDF70: 93380000  stw r25, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 825CDF74: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825CDF78: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825CDF7C: 48BDA22C  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CDF80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CDF80 size=264
    let mut pc: u32 = 0x825CDF80;
    'dispatch: loop {
        match pc {
            0x825CDF80 => {
    //   block [0x825CDF80..0x825CE088)
	// 825CDF80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CDF84: 48BDA1DD  bl 0x831a8160
	ctx.lr = 0x825CDF88;
	sub_831A8130(ctx, base);
	// 825CDF88: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CDF8C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825CDF90: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 825CDF94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CDF98: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 825CDF9C: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 825CDFA0: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDFA4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CDFA8: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 825CDFAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825CDFB0: 409A0040  bne cr6, 0x825cdff0
	if !ctx.cr[6].eq {
	pc = 0x825CDFF0; continue 'dispatch;
	}
	// 825CDFB4: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CDFB8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825CDFBC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 825CDFC0: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825CDFC4: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 825CDFC8: 41980008  blt cr6, 0x825cdfd0
	if ctx.cr[6].lt {
	pc = 0x825CDFD0; continue 'dispatch;
	}
	// 825CDFCC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825CDFD0: 555D063F  clrlwi. r29, r10, 0x18
	ctx.r[29].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825CDFD4: 4182000C  beq 0x825cdfe0
	if ctx.cr[0].eq {
	pc = 0x825CDFE0; continue 'dispatch;
	}
	// 825CDFD8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CDFDC: 48000008  b 0x825cdfe4
	pc = 0x825CDFE4; continue 'dispatch;
	// 825CDFE0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CDFE4: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 825CDFE8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825CDFEC: 419AFFCC  beq cr6, 0x825cdfb8
	if ctx.cr[6].eq {
	pc = 0x825CDFB8; continue 'dispatch;
	}
	// 825CDFF0: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 825CDFF4: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CDFF8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825CDFFC: 41820048  beq 0x825ce044
	if ctx.cr[0].eq {
	pc = 0x825CE044; continue 'dispatch;
	}
	// 825CE000: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CE004: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CE008: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CE00C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CE010: 409A002C  bne cr6, 0x825ce03c
	if !ctx.cr[6].eq {
	pc = 0x825CE03C; continue 'dispatch;
	}
	// 825CE014: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825CE018: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825CE01C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825CE020: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825CE024: 4BFFF92D  bl 0x825cd950
	ctx.lr = 0x825CE028;
	sub_825CD950(ctx, base);
	// 825CE028: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825CE02C: 9B5F0004  stb r26, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u8 ) };
	// 825CE030: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CE034: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CE038: 48000044  b 0x825ce07c
	pc = 0x825CE07C; continue 'dispatch;
	// 825CE03C: 485E8BFD  bl 0x82bb6c38
	ctx.lr = 0x825CE040;
	sub_82BB6C38(ctx, base);
	// 825CE040: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CE044: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825CE048: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CE04C: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825CE050: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 825CE054: 41980008  blt cr6, 0x825ce05c
	if ctx.cr[6].lt {
	pc = 0x825CE05C; continue 'dispatch;
	}
	// 825CE058: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CE05C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CE060: 41820010  beq 0x825ce070
	if ctx.cr[0].eq {
	pc = 0x825CE070; continue 'dispatch;
	}
	// 825CE064: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825CE068: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CE06C: 4BFFFFAC  b 0x825ce018
	pc = 0x825CE018; continue 'dispatch;
	// 825CE070: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CE074: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825CE078: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 825CE07C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CE080: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825CE084: 48BDA12C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CE088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CE088 size=132
    let mut pc: u32 = 0x825CE088;
    'dispatch: loop {
        match pc {
            0x825CE088 => {
    //   block [0x825CE088..0x825CE10C)
	// 825CE088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CE08C: 48BDA0DD  bl 0x831a8168
	ctx.lr = 0x825CE090;
	sub_831A8130(ctx, base);
	// 825CE090: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CE094: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825CE098: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 825CE09C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825CE0A0: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825CE0A4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CE0A8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CE0AC: 7F055040  cmplw cr6, r5, r10
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825CE0B0: 409A0044  bne cr6, 0x825ce0f4
	if !ctx.cr[6].eq {
	pc = 0x825CE0F4; continue 'dispatch;
	}
	// 825CE0B4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CE0B8: 409A003C  bne cr6, 0x825ce0f4
	if !ctx.cr[6].eq {
	pc = 0x825CE0F4; continue 'dispatch;
	}
	// 825CE0BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CE0C0: 4BEBC761  bl 0x8248a820
	ctx.lr = 0x825CE0C4;
	sub_8248A820(ctx, base);
	// 825CE0C4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CE0C8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CE0CC: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CE0D0: 48000030  b 0x825ce100
	pc = 0x825CE100; continue 'dispatch;
	// 825CE0D4: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 825CE0D8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825CE0DC: 4BF1AFB5  bl 0x824e9090
	ctx.lr = 0x825CE0E0;
	sub_824E9090(ctx, base);
	// 825CE0E0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825CE0E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CE0E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CE0EC: 4BFFFA9D  bl 0x825cdb88
	ctx.lr = 0x825CE0F0;
	sub_825CDB88(ctx, base);
	// 825CE0F0: 80A100A4  lwz r5, 0xa4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 825CE0F4: 7F05F040  cmplw cr6, r5, r30
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825CE0F8: 409AFFDC  bne cr6, 0x825ce0d4
	if !ctx.cr[6].eq {
	pc = 0x825CE0D4; continue 'dispatch;
	}
	// 825CE0FC: 90BD0000  stw r5, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 825CE100: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825CE104: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825CE108: 48BDA0B0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CE110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CE110 size=452
    let mut pc: u32 = 0x825CE110;
    'dispatch: loop {
        match pc {
            0x825CE110 => {
    //   block [0x825CE110..0x825CE2D4)
	// 825CE110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CE114: 48BDA049  bl 0x831a815c
	ctx.lr = 0x825CE118;
	sub_831A8130(ctx, base);
	// 825CE118: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CE11C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 825CE120: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CE124: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825CE128: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825CE12C: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CE130: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CE134: 409A0020  bne cr6, 0x825ce154
	if !ctx.cr[6].eq {
	pc = 0x825CE154; continue 'dispatch;
	}
	// 825CE138: 80DA0004  lwz r6, 4(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CE13C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825CE140: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 825CE144: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825CE148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CE14C: 4BFFF805  bl 0x825cd950
	ctx.lr = 0x825CE150;
	sub_825CD950(ctx, base);
	// 825CE150: 48000178  b 0x825ce2c8
	pc = 0x825CE2C8; continue 'dispatch;
	// 825CE154: 833A0004  lwz r25, 4(r26)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CE158: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CE15C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CE160: 409A002C  bne cr6, 0x825ce18c
	if !ctx.cr[6].eq {
	pc = 0x825CE18C; continue 'dispatch;
	}
	// 825CE164: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CE168: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825CE16C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825CE170: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825CE174: 41980008  blt cr6, 0x825ce17c
	if ctx.cr[6].lt {
	pc = 0x825CE17C; continue 'dispatch;
	}
	// 825CE178: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CE17C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CE180: 4182012C  beq 0x825ce2ac
	if ctx.cr[0].eq {
	pc = 0x825CE2AC; continue 'dispatch;
	}
	// 825CE184: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825CE188: 4BFFFFB4  b 0x825ce13c
	pc = 0x825CE13C; continue 'dispatch;
	// 825CE18C: 7F1EC840  cmplw cr6, r30, r25
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[25].u32, &mut ctx.xer);
	// 825CE190: 409A0030  bne cr6, 0x825ce1c0
	if !ctx.cr[6].eq {
	pc = 0x825CE1C0; continue 'dispatch;
	}
	// 825CE194: 80D90008  lwz r6, 8(r25)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CE198: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CE19C: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 825CE1A0: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825CE1A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825CE1A8: 41980008  blt cr6, 0x825ce1b0
	if ctx.cr[6].lt {
	pc = 0x825CE1B0; continue 'dispatch;
	}
	// 825CE1AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CE1B0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CE1B4: 418200F8  beq 0x825ce2ac
	if ctx.cr[0].eq {
	pc = 0x825CE2AC; continue 'dispatch;
	}
	// 825CE1B8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825CE1BC: 4BFFFF84  b 0x825ce140
	pc = 0x825CE140; continue 'dispatch;
	// 825CE1C0: 839D0000  lwz r28, 0(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CE1C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825CE1C8: 837E000C  lwz r27, 0xc(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825CE1CC: 7F1CD800  cmpw cr6, r28, r27
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[27].s32, &mut ctx.xer);
	// 825CE1D0: 41980008  blt cr6, 0x825ce1d8
	if ctx.cr[6].lt {
	pc = 0x825CE1D8; continue 'dispatch;
	}
	// 825CE1D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CE1D8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CE1DC: 41820060  beq 0x825ce23c
	if ctx.cr[0].eq {
	pc = 0x825CE23C; continue 'dispatch;
	}
	// 825CE1E0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825CE1E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CE1E8: 485E8A51  bl 0x82bb6c38
	ctx.lr = 0x825CE1EC;
	sub_82BB6C38(ctx, base);
	// 825CE1EC: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CE1F0: 8166000C  lwz r11, 0xc(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 825CE1F4: 7F0BE000  cmpw cr6, r11, r28
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[28].s32, &mut ctx.xer);
	// 825CE1F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825CE1FC: 41980008  blt cr6, 0x825ce204
	if ctx.cr[6].lt {
	pc = 0x825CE204; continue 'dispatch;
	}
	// 825CE200: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CE204: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CE208: 41820034  beq 0x825ce23c
	if ctx.cr[0].eq {
	pc = 0x825CE23C; continue 'dispatch;
	}
	// 825CE20C: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CE210: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 825CE214: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825CE218: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CE21C: 896B0015  lbz r11, 0x15(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 825CE220: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CE224: 419A000C  beq cr6, 0x825ce230
	if ctx.cr[6].eq {
	pc = 0x825CE230; continue 'dispatch;
	}
	// 825CE228: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825CE22C: 4BFFFF20  b 0x825ce14c
	pc = 0x825CE14C; continue 'dispatch;
	// 825CE230: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825CE234: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825CE238: 4BFFFF14  b 0x825ce14c
	pc = 0x825CE14C; continue 'dispatch;
	// 825CE23C: 7F1BE000  cmpw cr6, r27, r28
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[28].s32, &mut ctx.xer);
	// 825CE240: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825CE244: 41980008  blt cr6, 0x825ce24c
	if ctx.cr[6].lt {
	pc = 0x825CE24C; continue 'dispatch;
	}
	// 825CE248: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CE24C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CE250: 4182005C  beq 0x825ce2ac
	if ctx.cr[0].eq {
	pc = 0x825CE2AC; continue 'dispatch;
	}
	// 825CE254: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825CE258: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CE25C: 4BF1AE35  bl 0x824e9090
	ctx.lr = 0x825CE260;
	sub_824E9090(ctx, base);
	// 825CE260: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CE264: 7F06C840  cmplw cr6, r6, r25
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[25].u32, &mut ctx.xer);
	// 825CE268: 419A0020  beq cr6, 0x825ce288
	if ctx.cr[6].eq {
	pc = 0x825CE288; continue 'dispatch;
	}
	// 825CE26C: 8166000C  lwz r11, 0xc(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 825CE270: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825CE274: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825CE278: 41980008  blt cr6, 0x825ce280
	if ctx.cr[6].lt {
	pc = 0x825CE280; continue 'dispatch;
	}
	// 825CE27C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CE280: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CE284: 41820028  beq 0x825ce2ac
	if ctx.cr[0].eq {
	pc = 0x825CE2AC; continue 'dispatch;
	}
	// 825CE288: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CE28C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 825CE290: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825CE294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CE298: 896B0015  lbz r11, 0x15(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 825CE29C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CE2A0: 419AFF94  beq cr6, 0x825ce234
	if ctx.cr[6].eq {
	pc = 0x825CE234; continue 'dispatch;
	}
	// 825CE2A4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825CE2A8: 4BFFFF80  b 0x825ce228
	pc = 0x825CE228; continue 'dispatch;
	// 825CE2AC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825CE2B0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825CE2B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CE2B8: 4BFFFCC9  bl 0x825cdf80
	ctx.lr = 0x825CE2BC;
	sub_825CDF80(ctx, base);
	// 825CE2BC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825CE2C0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CE2C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CE2C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CE2CC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825CE2D0: 48BD9EDC  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CE2D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CE2D8 size=80
    let mut pc: u32 = 0x825CE2D8;
    'dispatch: loop {
        match pc {
            0x825CE2D8 => {
    //   block [0x825CE2D8..0x825CE328)
	// 825CE2D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CE2DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CE2E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CE2E4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CE2E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CE2EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CE2F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CE2F4: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CE2F8: 80A60000  lwz r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CE2FC: 4BFFFD8D  bl 0x825ce088
	ctx.lr = 0x825CE300;
	sub_825CE088(ctx, base);
	// 825CE300: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CE304: 4BCF1F65  bl 0x822c0268
	ctx.lr = 0x825CE308;
	sub_822C0268(ctx, base);
	// 825CE308: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CE30C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825CE310: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825CE314: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CE318: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CE31C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CE320: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CE324: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CE328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CE328 size=156
    let mut pc: u32 = 0x825CE328;
    'dispatch: loop {
        match pc {
            0x825CE328 => {
    //   block [0x825CE328..0x825CE3C4)
	// 825CE328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CE32C: 48BD9E41  bl 0x831a816c
	ctx.lr = 0x825CE330;
	sub_831A8130(ctx, base);
	// 825CE330: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CE334: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825CE338: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CE33C: 4BFFF4AD  bl 0x825cd7e8
	ctx.lr = 0x825CE340;
	sub_825CD7E8(ctx, base);
	// 825CE340: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CE344: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CE348: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825CE34C: 419A0024  beq cr6, 0x825ce370
	if ctx.cr[6].eq {
	pc = 0x825CE370; continue 'dispatch;
	}
	// 825CE350: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CE354: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825CE358: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825CE35C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825CE360: 41980008  blt cr6, 0x825ce368
	if ctx.cr[6].lt {
	pc = 0x825CE368; continue 'dispatch;
	}
	// 825CE364: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CE368: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CE36C: 4182004C  beq 0x825ce3b8
	if ctx.cr[0].eq {
	pc = 0x825CE3B8; continue 'dispatch;
	}
	// 825CE370: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CE374: 48824D7D  bl 0x82df30f0
	ctx.lr = 0x825CE378;
	sub_82DF30F0(ctx, base);
	// 825CE378: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CE37C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CE380: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825CE384: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825CE388: 48825879  bl 0x82df3c00
	ctx.lr = 0x825CE38C;
	sub_82DF3C00(ctx, base);
	// 825CE38C: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 825CE390: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825CE394: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825CE398: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825CE39C: 4BFFFD75  bl 0x825ce110
	ctx.lr = 0x825CE3A0;
	sub_825CE110(ctx, base);
	// 825CE3A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825CE3A4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825CE3A8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CE3AC: 4882507D  bl 0x82df3428
	ctx.lr = 0x825CE3B0;
	sub_82DF3428(ctx, base);
	// 825CE3B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CE3B4: 48825075  bl 0x82df3428
	ctx.lr = 0x825CE3B8;
	sub_82DF3428(ctx, base);
	// 825CE3B8: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 825CE3BC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825CE3C0: 48BD9DFC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CE3C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CE3C8 size=68
    let mut pc: u32 = 0x825CE3C8;
    'dispatch: loop {
        match pc {
            0x825CE3C8 => {
    //   block [0x825CE3C8..0x825CE40C)
	// 825CE3C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CE3CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CE3D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CE3D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CE3D8: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 825CE3DC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825CE3E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825CE3E4: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 825CE3E8: 386B7D40  addi r3, r11, 0x7d40
	ctx.r[3].s64 = ctx.r[11].s64 + 32064;
	// 825CE3EC: 4BFFFF3D  bl 0x825ce328
	ctx.lr = 0x825CE3F0;
	sub_825CE328(ctx, base);
	// 825CE3F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CE3F4: 488257DD  bl 0x82df3bd0
	ctx.lr = 0x825CE3F8;
	sub_82DF3BD0(ctx, base);
	// 825CE3F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825CE3FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CE400: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CE404: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CE408: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CE410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825CE410 size=140
    let mut pc: u32 = 0x825CE410;
    'dispatch: loop {
        match pc {
            0x825CE410 => {
    //   block [0x825CE410..0x825CE49C)
	// 825CE410: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825CE414: 90830010  stw r4, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 825CE418: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825CE41C: 392B6910  addi r9, r11, 0x6910
	ctx.r[9].s64 = ctx.r[11].s64 + 26896;
	// 825CE420: 396ADC00  addi r11, r10, -0x2400
	ctx.r[11].s64 = ctx.r[10].s64 + -9216;
	// 825CE424: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 825CE428: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CE42C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 825CE430: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 825CE434: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825CE438: 38C00040  li r6, 0x40
	ctx.r[6].s64 = 64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CE4A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825CE4A0 size=60
    let mut pc: u32 = 0x825CE4A0;
    'dispatch: loop {
        match pc {
            0x825CE4A0 => {
    //   block [0x825CE4A0..0x825CE4DC)
	// 825CE4A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825CE4A4: C1A60008  lfs f13, 8(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825CE4A8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825CE4AC: C1860000  lfs f12, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825CE4B0: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 825CE4B4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825CE4B8: C00B0024  lfs f0, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CE4BC: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825CE4C0: C00A08A8  lfs f0, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CE4C4: D1840000  stfs f12, 0(r4)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825CE4C8: D1A40008  stfs f13, 8(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 825CE4CC: D004000C  stfs f0, 0xc(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825CE4D0: 13EB48C7  vcmpequd (lvx128) v31, v11, v9
	tmp.u32 = ctx.r[11].u32 + ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CE4E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CE4E0 size=196
    let mut pc: u32 = 0x825CE4E0;
    'dispatch: loop {
        match pc {
            0x825CE4E0 => {
    //   block [0x825CE4E0..0x825CE5A4)
	// 825CE4E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CE4E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CE4E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CE4EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CE4F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CE4F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CE4F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CE4FC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825CE500: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825CE504: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CE508: 4BCF2431  bl 0x822c0938
	ctx.lr = 0x825CE50C;
	sub_822C0938(ctx, base);
	// 825CE50C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825CE510: 41820028  beq 0x825ce538
	if ctx.cr[0].eq {
	pc = 0x825CE538; continue 'dispatch;
	}
	// 825CE514: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CE518: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825CE51C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825CE520: 392BDB88  addi r9, r11, -0x2478
	ctx.r[9].s64 = ctx.r[11].s64 + -9336;
	// 825CE524: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825CE528: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825CE52C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825CE530: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825CE534: 48000008  b 0x825ce53c
	pc = 0x825CE53C; continue 'dispatch;
	// 825CE538: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CE53C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CE540: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CE544: 409A0044  bne cr6, 0x825ce588
	if !ctx.cr[6].eq {
	pc = 0x825CE588; continue 'dispatch;
	}
	// 825CE548: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825CE54C: 419A001C  beq cr6, 0x825ce568
	if ctx.cr[6].eq {
	pc = 0x825CE568; continue 'dispatch;
	}
	// 825CE550: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CE554: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825CE558: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CE55C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CE560: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CE564: 4E800421  bctrl
	ctx.lr = 0x825CE568;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CE568: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825CE56C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825CE570: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CE574: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825CE578: 816BB3C0  lwz r11, -0x4c40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19520 as u32) ) } as u64;
	// 825CE57C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825CE580: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825CE584: 4BCF1A7D  bl 0x822c0000
	ctx.lr = 0x825CE588;
	sub_822C0000(ctx, base);
	// 825CE588: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CE58C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CE590: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CE594: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CE598: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CE59C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CE5A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CE5A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CE5A8 size=196
    let mut pc: u32 = 0x825CE5A8;
    'dispatch: loop {
        match pc {
            0x825CE5A8 => {
    //   block [0x825CE5A8..0x825CE66C)
	// 825CE5A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CE5AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CE5B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CE5B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CE5B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CE5BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CE5C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CE5C4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825CE5C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825CE5CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CE5D0: 4BCF2369  bl 0x822c0938
	ctx.lr = 0x825CE5D4;
	sub_822C0938(ctx, base);
	// 825CE5D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825CE5D8: 41820028  beq 0x825ce600
	if ctx.cr[0].eq {
	pc = 0x825CE600; continue 'dispatch;
	}
	// 825CE5DC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CE5E0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825CE5E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825CE5E8: 392BDB9C  addi r9, r11, -0x2464
	ctx.r[9].s64 = ctx.r[11].s64 + -9316;
	// 825CE5EC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825CE5F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825CE5F4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825CE5F8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825CE5FC: 48000008  b 0x825ce604
	pc = 0x825CE604; continue 'dispatch;
	// 825CE600: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CE604: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CE608: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CE60C: 409A0044  bne cr6, 0x825ce650
	if !ctx.cr[6].eq {
	pc = 0x825CE650; continue 'dispatch;
	}
	// 825CE610: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825CE614: 419A001C  beq cr6, 0x825ce630
	if ctx.cr[6].eq {
	pc = 0x825CE630; continue 'dispatch;
	}
	// 825CE618: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CE61C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825CE620: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CE624: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CE628: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CE62C: 4E800421  bctrl
	ctx.lr = 0x825CE630;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CE630: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825CE634: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825CE638: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CE63C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825CE640: 816BB3C0  lwz r11, -0x4c40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19520 as u32) ) } as u64;
	// 825CE644: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825CE648: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825CE64C: 4BCF19B5  bl 0x822c0000
	ctx.lr = 0x825CE650;
	sub_822C0000(ctx, base);
	// 825CE650: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CE654: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CE658: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CE65C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CE660: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CE664: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CE668: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CE670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CE670 size=196
    let mut pc: u32 = 0x825CE670;
    'dispatch: loop {
        match pc {
            0x825CE670 => {
    //   block [0x825CE670..0x825CE734)
	// 825CE670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CE674: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CE678: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CE67C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CE680: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CE684: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CE688: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CE68C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825CE690: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825CE694: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CE698: 4BCF22A1  bl 0x822c0938
	ctx.lr = 0x825CE69C;
	sub_822C0938(ctx, base);
	// 825CE69C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825CE6A0: 41820028  beq 0x825ce6c8
	if ctx.cr[0].eq {
	pc = 0x825CE6C8; continue 'dispatch;
	}
	// 825CE6A4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CE6A8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825CE6AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825CE6B0: 392BDBB0  addi r9, r11, -0x2450
	ctx.r[9].s64 = ctx.r[11].s64 + -9296;
	// 825CE6B4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825CE6B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825CE6BC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825CE6C0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825CE6C4: 48000008  b 0x825ce6cc
	pc = 0x825CE6CC; continue 'dispatch;
	// 825CE6C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CE6CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CE6D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CE6D4: 409A0044  bne cr6, 0x825ce718
	if !ctx.cr[6].eq {
	pc = 0x825CE718; continue 'dispatch;
	}
	// 825CE6D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825CE6DC: 419A001C  beq cr6, 0x825ce6f8
	if ctx.cr[6].eq {
	pc = 0x825CE6F8; continue 'dispatch;
	}
	// 825CE6E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CE6E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825CE6E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CE6EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CE6F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CE6F4: 4E800421  bctrl
	ctx.lr = 0x825CE6F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CE6F8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825CE6FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825CE700: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CE704: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825CE708: 816BB3C0  lwz r11, -0x4c40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19520 as u32) ) } as u64;
	// 825CE70C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825CE710: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825CE714: 4BCF18ED  bl 0x822c0000
	ctx.lr = 0x825CE718;
	sub_822C0000(ctx, base);
	// 825CE718: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CE71C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CE720: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CE724: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CE728: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CE72C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CE730: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CE738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CE738 size=196
    let mut pc: u32 = 0x825CE738;
    'dispatch: loop {
        match pc {
            0x825CE738 => {
    //   block [0x825CE738..0x825CE7FC)
	// 825CE738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CE73C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CE740: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CE744: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CE748: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CE74C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CE750: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CE754: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825CE758: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825CE75C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CE760: 4BCF21D9  bl 0x822c0938
	ctx.lr = 0x825CE764;
	sub_822C0938(ctx, base);
	// 825CE764: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825CE768: 41820028  beq 0x825ce790
	if ctx.cr[0].eq {
	pc = 0x825CE790; continue 'dispatch;
	}
	// 825CE76C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CE770: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825CE774: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825CE778: 392BDBC4  addi r9, r11, -0x243c
	ctx.r[9].s64 = ctx.r[11].s64 + -9276;
	// 825CE77C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825CE780: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825CE784: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825CE788: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825CE78C: 48000008  b 0x825ce794
	pc = 0x825CE794; continue 'dispatch;
	// 825CE790: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CE794: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CE798: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CE79C: 409A0044  bne cr6, 0x825ce7e0
	if !ctx.cr[6].eq {
	pc = 0x825CE7E0; continue 'dispatch;
	}
	// 825CE7A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825CE7A4: 419A001C  beq cr6, 0x825ce7c0
	if ctx.cr[6].eq {
	pc = 0x825CE7C0; continue 'dispatch;
	}
	// 825CE7A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CE7AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825CE7B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CE7B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CE7B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CE7BC: 4E800421  bctrl
	ctx.lr = 0x825CE7C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CE7C0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825CE7C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825CE7C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CE7CC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825CE7D0: 816BB3C0  lwz r11, -0x4c40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19520 as u32) ) } as u64;
	// 825CE7D4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825CE7D8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825CE7DC: 4BCF1825  bl 0x822c0000
	ctx.lr = 0x825CE7E0;
	sub_822C0000(ctx, base);
	// 825CE7E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CE7E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CE7E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CE7EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CE7F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CE7F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CE7F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CE800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CE800 size=196
    let mut pc: u32 = 0x825CE800;
    'dispatch: loop {
        match pc {
            0x825CE800 => {
    //   block [0x825CE800..0x825CE8C4)
	// 825CE800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CE804: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CE808: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CE80C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CE810: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CE814: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CE818: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CE81C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825CE820: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825CE824: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CE828: 4BCF2111  bl 0x822c0938
	ctx.lr = 0x825CE82C;
	sub_822C0938(ctx, base);
	// 825CE82C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825CE830: 41820028  beq 0x825ce858
	if ctx.cr[0].eq {
	pc = 0x825CE858; continue 'dispatch;
	}
	// 825CE834: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CE838: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825CE83C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825CE840: 392BDBD8  addi r9, r11, -0x2428
	ctx.r[9].s64 = ctx.r[11].s64 + -9256;
	// 825CE844: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825CE848: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825CE84C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825CE850: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825CE854: 48000008  b 0x825ce85c
	pc = 0x825CE85C; continue 'dispatch;
	// 825CE858: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CE85C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CE860: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CE864: 409A0044  bne cr6, 0x825ce8a8
	if !ctx.cr[6].eq {
	pc = 0x825CE8A8; continue 'dispatch;
	}
	// 825CE868: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825CE86C: 419A001C  beq cr6, 0x825ce888
	if ctx.cr[6].eq {
	pc = 0x825CE888; continue 'dispatch;
	}
	// 825CE870: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CE874: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825CE878: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CE87C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CE880: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CE884: 4E800421  bctrl
	ctx.lr = 0x825CE888;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CE888: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825CE88C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825CE890: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CE894: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825CE898: 816BB3C0  lwz r11, -0x4c40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19520 as u32) ) } as u64;
	// 825CE89C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825CE8A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825CE8A4: 4BCF175D  bl 0x822c0000
	ctx.lr = 0x825CE8A8;
	sub_822C0000(ctx, base);
	// 825CE8A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CE8AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CE8B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CE8B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CE8B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CE8BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CE8C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CE8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CE8C8 size=196
    let mut pc: u32 = 0x825CE8C8;
    'dispatch: loop {
        match pc {
            0x825CE8C8 => {
    //   block [0x825CE8C8..0x825CE98C)
	// 825CE8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CE8CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CE8D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CE8D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CE8D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CE8DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CE8E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CE8E4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825CE8E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825CE8EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CE8F0: 4BCF2049  bl 0x822c0938
	ctx.lr = 0x825CE8F4;
	sub_822C0938(ctx, base);
	// 825CE8F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825CE8F8: 41820028  beq 0x825ce920
	if ctx.cr[0].eq {
	pc = 0x825CE920; continue 'dispatch;
	}
	// 825CE8FC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CE900: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825CE904: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825CE908: 392BDBEC  addi r9, r11, -0x2414
	ctx.r[9].s64 = ctx.r[11].s64 + -9236;
	// 825CE90C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825CE910: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825CE914: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825CE918: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825CE91C: 48000008  b 0x825ce924
	pc = 0x825CE924; continue 'dispatch;
	// 825CE920: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CE924: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CE928: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CE92C: 409A0044  bne cr6, 0x825ce970
	if !ctx.cr[6].eq {
	pc = 0x825CE970; continue 'dispatch;
	}
	// 825CE930: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825CE934: 419A001C  beq cr6, 0x825ce950
	if ctx.cr[6].eq {
	pc = 0x825CE950; continue 'dispatch;
	}
	// 825CE938: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CE93C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825CE940: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CE944: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CE948: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CE94C: 4E800421  bctrl
	ctx.lr = 0x825CE950;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CE950: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825CE954: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825CE958: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CE95C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825CE960: 816BB3C0  lwz r11, -0x4c40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19520 as u32) ) } as u64;
	// 825CE964: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825CE968: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825CE96C: 4BCF1695  bl 0x822c0000
	ctx.lr = 0x825CE970;
	sub_822C0000(ctx, base);
	// 825CE970: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CE974: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CE978: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CE97C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CE980: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CE984: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CE988: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CE990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CE990 size=68
    let mut pc: u32 = 0x825CE990;
    'dispatch: loop {
        match pc {
            0x825CE990 => {
    //   block [0x825CE990..0x825CE9D4)
	// 825CE990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CE994: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CE998: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CE99C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CE9A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CE9A4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CE9A8: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825CE9AC: 396BDC78  addi r11, r11, -0x2388
	ctx.r[11].s64 = ctx.r[11].s64 + -9096;
	// 825CE9B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CE9B4: 41820008  beq 0x825ce9bc
	if ctx.cr[0].eq {
	pc = 0x825CE9BC; continue 'dispatch;
	}
	// 825CE9B8: 4BCF18B1  bl 0x822c0268
	ctx.lr = 0x825CE9BC;
	sub_822C0268(ctx, base);
	// 825CE9BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CE9C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825CE9C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CE9C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CE9CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CE9D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CE9D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CE9D8 size=136
    let mut pc: u32 = 0x825CE9D8;
    'dispatch: loop {
        match pc {
            0x825CE9D8 => {
    //   block [0x825CE9D8..0x825CEA60)
	// 825CE9D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CE9DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CE9E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CE9E4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CE9E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CE9EC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CE9F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CE9F4: 419A0010  beq cr6, 0x825cea04
	if ctx.cr[6].eq {
	pc = 0x825CEA04; continue 'dispatch;
	}
	// 825CE9F8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CE9FC: 7D6B5051  subf. r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CEA00: 4082000C  bne 0x825cea0c
	if !ctx.cr[0].eq {
	pc = 0x825CEA0C; continue 'dispatch;
	}
	// 825CEA04: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825CEA08: 48000044  b 0x825cea4c
	pc = 0x825CEA4C; continue 'dispatch;
	// 825CEA0C: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 825CEA10: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825CEA14: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825CEA18: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825CEA1C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 825CEA20: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 825CEA24: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 825CEA28: C00BDFB0  lfs f0, -0x2050(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CEA2C: C02A08A4  lfs f1, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825CEA30: EC4D0028  fsubs f2, f13, f0
	ctx.f[2].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 825CEA34: 485AA4CD  bl 0x82b78f00
	ctx.lr = 0x825CEA38;
	sub_82B78F00(ctx, base);
	// 825CEA38: FC000E5E  fctidz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[1].f64.trunc() as i64 };
	// 825CEA3C: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 825CEA40: 89610057  lbz r11, 0x57(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 825CEA44: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CEA48: 7C6B50AE  lbzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825CEA4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CEA50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CEA54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CEA58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CEA5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CEA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CEA60 size=180
    let mut pc: u32 = 0x825CEA60;
    'dispatch: loop {
        match pc {
            0x825CEA60 => {
    //   block [0x825CEA60..0x825CEB14)
	// 825CEA60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CEA64: 48BD9705  bl 0x831a8168
	ctx.lr = 0x825CEA68;
	sub_831A8130(ctx, base);
	// 825CEA68: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 825CEA6C: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825CEA70: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CEA74: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825CEA78: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 825CEA7C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825CEA80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CEA84: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825CEA88: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825CEA8C: C04B08A8  lfs f2, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825CEA90: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825CEA94: 485AA46D  bl 0x82b78f00
	ctx.lr = 0x825CEA98;
	sub_82B78F00(ctx, base);
	// 825CEA98: ED80082C  fsqrts f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = ((ctx.f[1].f64).sqrt() as f32) as f64;
	// 825CEA9C: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 825CEAA0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825CEAA4: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 825CEAA8: 3B810054  addi r28, r1, 0x54
	ctx.r[28].s64 = ctx.r[1].s64 + 84;
	// 825CEAAC: C00BDFAC  lfs f0, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CEAB0: C1AA9524  lfs f13, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825CEAB4: EFCC07B2  fmuls f30, f12, f30
	ctx.f[30].f64 = (((ctx.f[12].f64 * ctx.f[30].f64) as f32) as f64);
	// 825CEAB8: EC400372  fmuls f2, f0, f13
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 825CEABC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825CEAC0: 485AA441  bl 0x82b78f00
	ctx.lr = 0x825CEAC4;
	sub_82B78F00(ctx, base);
	// 825CEAC4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825CEAC8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825CEACC: 4BE8225D  bl 0x82450d28
	ctx.lr = 0x825CEAD0;
	sub_82450D28(ctx, base);
	// 825CEAD0: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CEAD4: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825CEAD8: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 825CEADC: EDAD07B2  fmuls f13, f13, f30
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 825CEAE0: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825CEAE4: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825CEAE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CEAEC: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825CEAF0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825CEAF4: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825CEAF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CEAFC: 488AD24D  bl 0x82e7bd48
	ctx.lr = 0x825CEB00;
	sub_82E7BD48(ctx, base);
	// 825CEB00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CEB04: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825CEB08: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825CEB0C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 825CEB10: 48BD96A8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CEB18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CEB18 size=72
    let mut pc: u32 = 0x825CEB18;
    'dispatch: loop {
        match pc {
            0x825CEB18 => {
    //   block [0x825CEB18..0x825CEB60)
	// 825CEB18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CEB1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CEB20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CEB24: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825CEB28: 816A7D58  lwz r11, 0x7d58(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32088 as u32) ) } as u64;
	// 825CEB2C: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825CEB30: 40820018  bne 0x825ceb48
	if !ctx.cr[0].eq {
	pc = 0x825CEB48; continue 'dispatch;
	}
	// 825CEB34: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825CEB38: 3D208324  lis r9, -0x7cdc
	ctx.r[9].s64 = -2094792704;
	// 825CEB3C: 916A7D58  stw r11, 0x7d58(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32088 as u32), ctx.r[11].u32 ) };
	// 825CEB40: 3869F790  addi r3, r9, -0x870
	ctx.r[3].s64 = ctx.r[9].s64 + -2160;
	// 825CEB44: 48BD9995  bl 0x831a84d8
	ctx.lr = 0x825CEB48;
	sub_831A84D8(ctx, base);
	// 825CEB48: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825CEB4C: 386B7D54  addi r3, r11, 0x7d54
	ctx.r[3].s64 = ctx.r[11].s64 + 32084;
	// 825CEB50: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825CEB54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CEB58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CEB5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CEB60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CEB60 size=240
    let mut pc: u32 = 0x825CEB60;
    'dispatch: loop {
        match pc {
            0x825CEB60 => {
    //   block [0x825CEB60..0x825CEC50)
	// 825CEB60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CEB64: 48BD9609  bl 0x831a816c
	ctx.lr = 0x825CEB68;
	sub_831A8130(ctx, base);
	// 825CEB68: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CEB6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CEB70: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 825CEB74: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825CEB78: 897F0050  lbz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CEB7C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825CEB80: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825CEB84: 40820038  bne 0x825cebbc
	if !ctx.cr[0].eq {
	pc = 0x825CEBBC; continue 'dispatch;
	}
	// 825CEB88: 9BBF0050  stb r29, 0x50(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 825CEB8C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CEB90: 808B0134  lwz r4, 0x134(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(308 as u32) ) } as u64;
	// 825CEB94: 4BEB2195  bl 0x82480d28
	ctx.lr = 0x825CEB98;
	sub_82480D28(ctx, base);
	// 825CEB98: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825CEB9C: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 825CEBA0: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825CEBA4: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 825CEBA8: 39200040  li r9, 0x40
	ctx.r[9].s64 = 64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CEC50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CEC50 size=188
    let mut pc: u32 = 0x825CEC50;
    'dispatch: loop {
        match pc {
            0x825CEC50 => {
    //   block [0x825CEC50..0x825CED0C)
	// 825CEC50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CEC54: 48BD9519  bl 0x831a816c
	ctx.lr = 0x825CEC58;
	sub_831A8130(ctx, base);
	// 825CEC58: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 825CEC5C: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CEC60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825CEC64: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825CEC68: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CEC6C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825CEC70: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825CEC74: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825CEC78: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 825CEC7C: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825CEC80: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 825CEC84: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CEC88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CEC8C: 13C0F0C7  vcmpequd (lvx128) v30, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825CEC90: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825CEC94: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 825CEC98: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825CEC9C: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CED10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CED10 size=120
    let mut pc: u32 = 0x825CED10;
    'dispatch: loop {
        match pc {
            0x825CED10 => {
    //   block [0x825CED10..0x825CED88)
	// 825CED10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CED14: 48BD9459  bl 0x831a816c
	ctx.lr = 0x825CED18;
	sub_831A8130(ctx, base);
	// 825CED18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CED1C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825CED20: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825CED24: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825CED28: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825CED2C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825CED30: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 825CED34: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 825CED38: 488236B1  bl 0x82df23e8
	ctx.lr = 0x825CED3C;
	sub_82DF23E8(ctx, base);
	// 825CED3C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825CED40: 41820014  beq 0x825ced54
	if ctx.cr[0].eq {
	pc = 0x825CED54; continue 'dispatch;
	}
	// 825CED44: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CED48: 485837E1  bl 0x82b52528
	ctx.lr = 0x825CED4C;
	sub_82B52528(ctx, base);
	// 825CED4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CED50: 48000008  b 0x825ced58
	pc = 0x825CED58; continue 'dispatch;
	// 825CED54: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825CED58: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825CED5C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825CED60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CED64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CED68: 4BFFF779  bl 0x825ce4e0
	ctx.lr = 0x825CED6C;
	sub_825CE4E0(ctx, base);
	// 825CED6C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825CED70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CED74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CED78: 4BCF1289  bl 0x822c0000
	ctx.lr = 0x825CED7C;
	sub_822C0000(ctx, base);
	// 825CED7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825CED80: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CED84: 48BD9438  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CED88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CED88 size=124
    let mut pc: u32 = 0x825CED88;
    'dispatch: loop {
        match pc {
            0x825CED88 => {
    //   block [0x825CED88..0x825CEE04)
	// 825CED88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CED8C: 48BD93E1  bl 0x831a816c
	ctx.lr = 0x825CED90;
	sub_831A8130(ctx, base);
	// 825CED90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CED94: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825CED98: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825CED9C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825CEDA0: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825CEDA4: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 825CEDA8: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 825CEDAC: 4882363D  bl 0x82df23e8
	ctx.lr = 0x825CEDB0;
	sub_82DF23E8(ctx, base);
	// 825CEDB0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825CEDB4: 4182001C  beq 0x825cedd0
	if ctx.cr[0].eq {
	pc = 0x825CEDD0; continue 'dispatch;
	}
	// 825CEDB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CEDBC: 4888A8C5  bl 0x82e59680
	ctx.lr = 0x825CEDC0;
	sub_82E59680(ctx, base);
	// 825CEDC0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CEDC4: 396BDC18  addi r11, r11, -0x23e8
	ctx.r[11].s64 = ctx.r[11].s64 + -9192;
	// 825CEDC8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CEDCC: 48000008  b 0x825cedd4
	pc = 0x825CEDD4; continue 'dispatch;
	// 825CEDD0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825CEDD4: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825CEDD8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825CEDDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CEDE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CEDE4: 4BFFF7C5  bl 0x825ce5a8
	ctx.lr = 0x825CEDE8;
	sub_825CE5A8(ctx, base);
	// 825CEDE8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825CEDEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CEDF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CEDF4: 4BCF120D  bl 0x822c0000
	ctx.lr = 0x825CEDF8;
	sub_822C0000(ctx, base);
	// 825CEDF8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825CEDFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CEE00: 48BD93BC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CEE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CEE08 size=132
    let mut pc: u32 = 0x825CEE08;
    'dispatch: loop {
        match pc {
            0x825CEE08 => {
    //   block [0x825CEE08..0x825CEE8C)
	// 825CEE08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CEE0C: 48BD9361  bl 0x831a816c
	ctx.lr = 0x825CEE10;
	sub_831A8130(ctx, base);
	// 825CEE10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CEE14: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825CEE18: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825CEE1C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825CEE20: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825CEE24: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 825CEE28: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 825CEE2C: 488235BD  bl 0x82df23e8
	ctx.lr = 0x825CEE30;
	sub_82DF23E8(ctx, base);
	// 825CEE30: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825CEE34: 41820024  beq 0x825cee58
	if ctx.cr[0].eq {
	pc = 0x825CEE58; continue 'dispatch;
	}
	// 825CEE38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CEE3C: 4888A865  bl 0x82e596a0
	ctx.lr = 0x825CEE40;
	sub_82E596A0(ctx, base);
	// 825CEE40: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CEE44: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825CEE48: 396BDC20  addi r11, r11, -0x23e0
	ctx.r[11].s64 = ctx.r[11].s64 + -9184;
	// 825CEE4C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CEE50: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 825CEE54: 48000008  b 0x825cee5c
	pc = 0x825CEE5C; continue 'dispatch;
	// 825CEE58: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825CEE5C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825CEE60: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825CEE64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CEE68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CEE6C: 4BFFF805  bl 0x825ce670
	ctx.lr = 0x825CEE70;
	sub_825CE670(ctx, base);
	// 825CEE70: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825CEE74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CEE78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CEE7C: 4BCF1185  bl 0x822c0000
	ctx.lr = 0x825CEE80;
	sub_822C0000(ctx, base);
	// 825CEE80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825CEE84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CEE88: 48BD9334  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CEE90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CEE90 size=124
    let mut pc: u32 = 0x825CEE90;
    'dispatch: loop {
        match pc {
            0x825CEE90 => {
    //   block [0x825CEE90..0x825CEF0C)
	// 825CEE90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CEE94: 48BD92D9  bl 0x831a816c
	ctx.lr = 0x825CEE98;
	sub_831A8130(ctx, base);
	// 825CEE98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CEE9C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825CEEA0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825CEEA4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825CEEA8: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 825CEEAC: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 825CEEB0: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 825CEEB4: 48823535  bl 0x82df23e8
	ctx.lr = 0x825CEEB8;
	sub_82DF23E8(ctx, base);
	// 825CEEB8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825CEEBC: 4182001C  beq 0x825ceed8
	if ctx.cr[0].eq {
	pc = 0x825CEED8; continue 'dispatch;
	}
	// 825CEEC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CEEC4: 4888DA65  bl 0x82e5c928
	ctx.lr = 0x825CEEC8;
	sub_82E5C928(ctx, base);
	// 825CEEC8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CEECC: 396BDC28  addi r11, r11, -0x23d8
	ctx.r[11].s64 = ctx.r[11].s64 + -9176;
	// 825CEED0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CEED4: 48000008  b 0x825ceedc
	pc = 0x825CEEDC; continue 'dispatch;
	// 825CEED8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825CEEDC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825CEEE0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825CEEE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CEEE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CEEEC: 4BFFF84D  bl 0x825ce738
	ctx.lr = 0x825CEEF0;
	sub_825CE738(ctx, base);
	// 825CEEF0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825CEEF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CEEF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CEEFC: 4BCF1105  bl 0x822c0000
	ctx.lr = 0x825CEF00;
	sub_822C0000(ctx, base);
	// 825CEF00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825CEF04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CEF08: 48BD92B4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CEF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CEF10 size=124
    let mut pc: u32 = 0x825CEF10;
    'dispatch: loop {
        match pc {
            0x825CEF10 => {
    //   block [0x825CEF10..0x825CEF8C)
	// 825CEF10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CEF14: 48BD9259  bl 0x831a816c
	ctx.lr = 0x825CEF18;
	sub_831A8130(ctx, base);
	// 825CEF18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CEF1C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825CEF20: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825CEF24: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825CEF28: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 825CEF2C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 825CEF30: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 825CEF34: 488234B5  bl 0x82df23e8
	ctx.lr = 0x825CEF38;
	sub_82DF23E8(ctx, base);
	// 825CEF38: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825CEF3C: 4182001C  beq 0x825cef58
	if ctx.cr[0].eq {
	pc = 0x825CEF58; continue 'dispatch;
	}
	// 825CEF40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CEF44: 4888D9E5  bl 0x82e5c928
	ctx.lr = 0x825CEF48;
	sub_82E5C928(ctx, base);
	// 825CEF48: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CEF4C: 396BDC50  addi r11, r11, -0x23b0
	ctx.r[11].s64 = ctx.r[11].s64 + -9136;
	// 825CEF50: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CEF54: 48000008  b 0x825cef5c
	pc = 0x825CEF5C; continue 'dispatch;
	// 825CEF58: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825CEF5C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825CEF60: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825CEF64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CEF68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CEF6C: 4BFFF895  bl 0x825ce800
	ctx.lr = 0x825CEF70;
	sub_825CE800(ctx, base);
	// 825CEF70: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825CEF74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CEF78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CEF7C: 4BCF1085  bl 0x822c0000
	ctx.lr = 0x825CEF80;
	sub_822C0000(ctx, base);
	// 825CEF80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825CEF84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CEF88: 48BD9234  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CEF90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CEF90 size=124
    let mut pc: u32 = 0x825CEF90;
    'dispatch: loop {
        match pc {
            0x825CEF90 => {
    //   block [0x825CEF90..0x825CF00C)
	// 825CEF90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CEF94: 48BD91D9  bl 0x831a816c
	ctx.lr = 0x825CEF98;
	sub_831A8130(ctx, base);
	// 825CEF98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CEF9C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825CEFA0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825CEFA4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825CEFA8: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 825CEFAC: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 825CEFB0: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 825CEFB4: 48823435  bl 0x82df23e8
	ctx.lr = 0x825CEFB8;
	sub_82DF23E8(ctx, base);
	// 825CEFB8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825CEFBC: 4182001C  beq 0x825cefd8
	if ctx.cr[0].eq {
	pc = 0x825CEFD8; continue 'dispatch;
	}
	// 825CEFC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CEFC4: 4888D965  bl 0x82e5c928
	ctx.lr = 0x825CEFC8;
	sub_82E5C928(ctx, base);
	// 825CEFC8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CEFCC: 396BDC84  addi r11, r11, -0x237c
	ctx.r[11].s64 = ctx.r[11].s64 + -9084;
	// 825CEFD0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CEFD4: 48000008  b 0x825cefdc
	pc = 0x825CEFDC; continue 'dispatch;
	// 825CEFD8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825CEFDC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825CEFE0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825CEFE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CEFE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CEFEC: 4BFFF8DD  bl 0x825ce8c8
	ctx.lr = 0x825CEFF0;
	sub_825CE8C8(ctx, base);
	// 825CEFF0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825CEFF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CEFF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CEFFC: 4BCF1005  bl 0x822c0000
	ctx.lr = 0x825CF000;
	sub_822C0000(ctx, base);
	// 825CF000: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825CF004: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CF008: 48BD91B4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CF010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CF010 size=392
    let mut pc: u32 = 0x825CF010;
    'dispatch: loop {
        match pc {
            0x825CF010 => {
    //   block [0x825CF010..0x825CF198)
	// 825CF010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CF014: 48BD9155  bl 0x831a8168
	ctx.lr = 0x825CF018;
	sub_831A8130(ctx, base);
	// 825CF018: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825CF01C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CF020: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825CF024: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825CF028: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825CF02C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825CF030: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825CF034: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825CF038: 4BFE3431  bl 0x825b2468
	ctx.lr = 0x825CF03C;
	sub_825B2468(ctx, base);
	// 825CF03C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CF040: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825CF044: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CF048: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CF04C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825CF050: 419A0024  beq cr6, 0x825cf074
	if ctx.cr[6].eq {
	pc = 0x825CF074; continue 'dispatch;
	}
	// 825CF054: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825CF058: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825CF05C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CF060: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825CF064: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825CF068: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825CF06C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CF070: 4082FFE8  bne 0x825cf058
	if !ctx.cr[0].eq {
	pc = 0x825CF058; continue 'dispatch;
	}
	// 825CF074: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825CF078: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825CF07C: 4BF4049D  bl 0x8250f518
	ctx.lr = 0x825CF080;
	sub_8250F518(ctx, base);
	// 825CF080: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CF084: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CF088: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 825CF08C: 409A0008  bne cr6, 0x825cf094
	if !ctx.cr[6].eq {
	pc = 0x825CF094; continue 'dispatch;
	}
	// 825CF090: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825CF094: 3BFD0028  addi r31, r29, 0x28
	ctx.r[31].s64 = ctx.r[29].s64 + 40;
	// 825CF098: 3B810058  addi r28, r1, 0x58
	ctx.r[28].s64 = ctx.r[1].s64 + 88;
	// 825CF09C: 4BF58FB5  bl 0x82528050
	ctx.lr = 0x825CF0A0;
	sub_82528050(ctx, base);
	// 825CF0A0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CF0A4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825CF0A8: 3BCBDCB8  addi r30, r11, -0x2348
	ctx.r[30].s64 = ctx.r[11].s64 + -9032;
	// 825CF0AC: 38A0086F  li r5, 0x86f
	ctx.r[5].s64 = 2159;
	// 825CF0B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CF0B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CF0B8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 825CF0BC: 48887F2D  bl 0x82e56fe8
	ctx.lr = 0x825CF0C0;
	sub_82E56FE8(ctx, base);
	// 825CF0C0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825CF0C4: 48822BCD  bl 0x82df1c90
	ctx.lr = 0x825CF0C8;
	sub_82DF1C90(ctx, base);
	// 825CF0C8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825CF0CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CF0D0: 419A0008  beq cr6, 0x825cf0d8
	if ctx.cr[6].eq {
	pc = 0x825CF0D8; continue 'dispatch;
	}
	// 825CF0D4: 4BCF17BD  bl 0x822c0890
	ctx.lr = 0x825CF0D8;
	sub_822C0890(ctx, base);
	// 825CF0D8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825CF0DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CF0E0: 419A0008  beq cr6, 0x825cf0e8
	if ctx.cr[6].eq {
	pc = 0x825CF0E8; continue 'dispatch;
	}
	// 825CF0E4: 4BCF17AD  bl 0x822c0890
	ctx.lr = 0x825CF0E8;
	sub_822C0890(ctx, base);
	// 825CF0E8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825CF0EC: 4BFFFC9D  bl 0x825ced88
	ctx.lr = 0x825CF0F0;
	sub_825CED88(ctx, base);
	// 825CF0F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CF0F4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825CF0F8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CF0FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CF100: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825CF104: 419A0024  beq cr6, 0x825cf128
	if ctx.cr[6].eq {
	pc = 0x825CF128; continue 'dispatch;
	}
	// 825CF108: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825CF10C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825CF110: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CF114: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825CF118: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825CF11C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825CF120: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CF124: 4082FFE8  bne 0x825cf10c
	if !ctx.cr[0].eq {
	pc = 0x825CF10C; continue 'dispatch;
	}
	// 825CF128: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825CF12C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825CF130: 4BF40201  bl 0x8250f330
	ctx.lr = 0x825CF134;
	sub_8250F330(ctx, base);
	// 825CF134: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CF138: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 825CF13C: 4BF1A725  bl 0x824e9860
	ctx.lr = 0x825CF140;
	sub_824E9860(ctx, base);
	// 825CF140: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825CF144: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825CF148: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CF14C: 38A00872  li r5, 0x872
	ctx.r[5].s64 = 2162;
	// 825CF150: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CF154: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 825CF158: 488898E9  bl 0x82e58a40
	ctx.lr = 0x825CF15C;
	sub_82E58A40(ctx, base);
	// 825CF15C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825CF160: 48822B31  bl 0x82df1c90
	ctx.lr = 0x825CF164;
	sub_82DF1C90(ctx, base);
	// 825CF164: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825CF168: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CF16C: 419A0008  beq cr6, 0x825cf174
	if ctx.cr[6].eq {
	pc = 0x825CF174; continue 'dispatch;
	}
	// 825CF170: 4BCF1721  bl 0x822c0890
	ctx.lr = 0x825CF174;
	sub_822C0890(ctx, base);
	// 825CF174: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825CF178: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CF17C: 419A0008  beq cr6, 0x825cf184
	if ctx.cr[6].eq {
	pc = 0x825CF184; continue 'dispatch;
	}
	// 825CF180: 4BCF1711  bl 0x822c0890
	ctx.lr = 0x825CF184;
	sub_822C0890(ctx, base);
	// 825CF184: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825CF188: 4BF41449  bl 0x825105d0
	ctx.lr = 0x825CF18C;
	sub_825105D0(ctx, base);
	// 825CF18C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825CF190: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 825CF194: 48BD9024  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CF198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CF198 size=204
    let mut pc: u32 = 0x825CF198;
    'dispatch: loop {
        match pc {
            0x825CF198 => {
    //   block [0x825CF198..0x825CF264)
	// 825CF198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CF19C: 48BD8FCD  bl 0x831a8168
	ctx.lr = 0x825CF1A0;
	sub_831A8130(ctx, base);
	// 825CF1A0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CF1A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CF1A8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825CF1AC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825CF1B0: 419A00A8  beq cr6, 0x825cf258
	if ctx.cr[6].eq {
	pc = 0x825CF258; continue 'dispatch;
	}
	// 825CF1B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825CF1B8: 4BFFFC51  bl 0x825cee08
	ctx.lr = 0x825CF1BC;
	sub_825CEE08(ctx, base);
	// 825CF1BC: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825CF1C0: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825CF1C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825CF1C8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 825CF1CC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825CF1D0: 419A0024  beq cr6, 0x825cf1f4
	if ctx.cr[6].eq {
	pc = 0x825CF1F4; continue 'dispatch;
	}
	// 825CF1D4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825CF1D8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825CF1DC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CF1E0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825CF1E4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825CF1E8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825CF1EC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825CF1F0: 4082FFE8  bne 0x825cf1d8
	if !ctx.cr[0].eq {
	pc = 0x825CF1D8; continue 'dispatch;
	}
	// 825CF1F4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CF1F8: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825CF1FC: 388BDCB8  addi r4, r11, -0x2348
	ctx.r[4].s64 = ctx.r[11].s64 + -9032;
	// 825CF200: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825CF204: 38A0087A  li r5, 0x87a
	ctx.r[5].s64 = 2170;
	// 825CF208: 387D0028  addi r3, r29, 0x28
	ctx.r[3].s64 = ctx.r[29].s64 + 40;
	// 825CF20C: 48887DDD  bl 0x82e56fe8
	ctx.lr = 0x825CF210;
	sub_82E56FE8(ctx, base);
	// 825CF210: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825CF214: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CF218: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CF21C: 419A000C  beq cr6, 0x825cf228
	if ctx.cr[6].eq {
	pc = 0x825CF228; continue 'dispatch;
	}
	// 825CF220: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825CF224: 4BCF166D  bl 0x822c0890
	ctx.lr = 0x825CF228;
	sub_822C0890(ctx, base);
	// 825CF228: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CF22C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825CF230: 4182001C  beq 0x825cf24c
	if ctx.cr[0].eq {
	pc = 0x825CF24C; continue 'dispatch;
	}
	// 825CF234: 83DC0018  lwz r30, 0x18(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 825CF238: 419A000C  beq cr6, 0x825cf244
	if ctx.cr[6].eq {
	pc = 0x825CF244; continue 'dispatch;
	}
	// 825CF23C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CF240: 4BCF1651  bl 0x822c0890
	ctx.lr = 0x825CF244;
	sub_822C0890(ctx, base);
	// 825CF244: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CF248: 48000014  b 0x825cf25c
	pc = 0x825CF25C; continue 'dispatch;
	// 825CF24C: 419A000C  beq cr6, 0x825cf258
	if ctx.cr[6].eq {
	pc = 0x825CF258; continue 'dispatch;
	}
	// 825CF250: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CF254: 4BCF163D  bl 0x822c0890
	ctx.lr = 0x825CF258;
	sub_822C0890(ctx, base);
	// 825CF258: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825CF25C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825CF260: 48BD8F58  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CF268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CF268 size=264
    let mut pc: u32 = 0x825CF268;
    'dispatch: loop {
        match pc {
            0x825CF268 => {
    //   block [0x825CF268..0x825CF370)
	// 825CF268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CF26C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CF270: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CF274: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CF278: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CF370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CF370 size=160
    let mut pc: u32 = 0x825CF370;
    'dispatch: loop {
        match pc {
            0x825CF370 => {
    //   block [0x825CF370..0x825CF410)
	// 825CF370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CF374: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CF378: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CF37C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CF380: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CF384: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CF388: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CF38C: 48AF8755  bl 0x830c7ae0
	ctx.lr = 0x825CF390;
	sub_830C7AE0(ctx, base);
	// 825CF390: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 825CF394: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CF398: 4888DCF9  bl 0x82e5d090
	ctx.lr = 0x825CF39C;
	sub_82E5D090(ctx, base);
	// 825CF39C: 807F0130  lwz r3, 0x130(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 825CF3A0: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825CF3A4: 4BFE27C5  bl 0x825b1b68
	ctx.lr = 0x825CF3A8;
	sub_825B1B68(ctx, base);
	// 825CF3A8: 4BFFF771  bl 0x825ceb18
	ctx.lr = 0x825CF3AC;
	sub_825CEB18(ctx, base);
	// 825CF3AC: 807F0130  lwz r3, 0x130(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 825CF3B0: 4BFE2731  bl 0x825b1ae0
	ctx.lr = 0x825CF3B4;
	sub_825B1AE0(ctx, base);
	// 825CF3B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CF3B8: 41820010  beq 0x825cf3c8
	if ctx.cr[0].eq {
	pc = 0x825CF3C8; continue 'dispatch;
	}
	// 825CF3BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CF3C0: 4BFFFC51  bl 0x825cf010
	ctx.lr = 0x825CF3C4;
	sub_825CF010(ctx, base);
	// 825CF3C4: 48000034  b 0x825cf3f8
	pc = 0x825CF3F8; continue 'dispatch;
	// 825CF3C8: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 825CF3CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CF3D0: 419A0028  beq cr6, 0x825cf3f8
	if ctx.cr[6].eq {
	pc = 0x825CF3F8; continue 'dispatch;
	}
	// 825CF3D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CF3D8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CF3DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CF3E0: 4E800421  bctrl
	ctx.lr = 0x825CF3E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CF3E4: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 825CF3E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CF3EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CF3F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825CF3F4: 4E800421  bctrl
	ctx.lr = 0x825CF3F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825CF3F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CF3FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CF400: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CF404: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CF408: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CF40C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CF410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CF410 size=92
    let mut pc: u32 = 0x825CF410;
    'dispatch: loop {
        match pc {
            0x825CF410 => {
    //   block [0x825CF410..0x825CF46C)
	// 825CF410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CF414: 48BD8D59  bl 0x831a816c
	ctx.lr = 0x825CF418;
	sub_831A8130(ctx, base);
	// 825CF418: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CF41C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CF420: 3D40825D  lis r10, -0x7da3
	ctx.r[10].s64 = -2107834368;
	// 825CF424: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825CF428: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CF42C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CF430: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825CF434: 388AEE90  addi r4, r10, -0x1170
	ctx.r[4].s64 = ctx.r[10].s64 + -4464;
	// 825CF438: 4BD90639  bl 0x8235fa70
	ctx.lr = 0x825CF43C;
	sub_8235FA70(ctx, base);
	// 825CF43C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CF440: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CF444: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 825CF448: 488247B9  bl 0x82df3c00
	ctx.lr = 0x825CF44C;
	sub_82DF3C00(ctx, base);
	// 825CF44C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CF450: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CF454: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825CF458: 4888CD01  bl 0x82e5c158
	ctx.lr = 0x825CF45C;
	sub_82E5C158(ctx, base);
	// 825CF45C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CF460: 48823FC9  bl 0x82df3428
	ctx.lr = 0x825CF464;
	sub_82DF3428(ctx, base);
	// 825CF464: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825CF468: 48BD8D54  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CF470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CF470 size=92
    let mut pc: u32 = 0x825CF470;
    'dispatch: loop {
        match pc {
            0x825CF470 => {
    //   block [0x825CF470..0x825CF4CC)
	// 825CF470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CF474: 48BD8CF9  bl 0x831a816c
	ctx.lr = 0x825CF478;
	sub_831A8130(ctx, base);
	// 825CF478: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CF47C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CF480: 3D40825D  lis r10, -0x7da3
	ctx.r[10].s64 = -2107834368;
	// 825CF484: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825CF488: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CF48C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CF490: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825CF494: 388AEF10  addi r4, r10, -0x10f0
	ctx.r[4].s64 = ctx.r[10].s64 + -4336;
	// 825CF498: 4BD905D9  bl 0x8235fa70
	ctx.lr = 0x825CF49C;
	sub_8235FA70(ctx, base);
	// 825CF49C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CF4A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CF4A4: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 825CF4A8: 48824759  bl 0x82df3c00
	ctx.lr = 0x825CF4AC;
	sub_82DF3C00(ctx, base);
	// 825CF4AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CF4B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CF4B4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825CF4B8: 4888CCA1  bl 0x82e5c158
	ctx.lr = 0x825CF4BC;
	sub_82E5C158(ctx, base);
	// 825CF4BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CF4C0: 48823F69  bl 0x82df3428
	ctx.lr = 0x825CF4C4;
	sub_82DF3428(ctx, base);
	// 825CF4C4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825CF4C8: 48BD8CF4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CF4D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CF4D0 size=92
    let mut pc: u32 = 0x825CF4D0;
    'dispatch: loop {
        match pc {
            0x825CF4D0 => {
    //   block [0x825CF4D0..0x825CF52C)
	// 825CF4D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CF4D4: 48BD8C99  bl 0x831a816c
	ctx.lr = 0x825CF4D8;
	sub_831A8130(ctx, base);
	// 825CF4D8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CF4DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CF4E0: 3D40825D  lis r10, -0x7da3
	ctx.r[10].s64 = -2107834368;
	// 825CF4E4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825CF4E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CF4EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CF4F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825CF4F4: 388AEF90  addi r4, r10, -0x1070
	ctx.r[4].s64 = ctx.r[10].s64 + -4208;
	// 825CF4F8: 4BD90579  bl 0x8235fa70
	ctx.lr = 0x825CF4FC;
	sub_8235FA70(ctx, base);
	// 825CF4FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825CF500: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CF504: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 825CF508: 488246F9  bl 0x82df3c00
	ctx.lr = 0x825CF50C;
	sub_82DF3C00(ctx, base);
	// 825CF50C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825CF510: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CF514: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825CF518: 4888CC41  bl 0x82e5c158
	ctx.lr = 0x825CF51C;
	sub_82E5C158(ctx, base);
	// 825CF51C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CF520: 48823F09  bl 0x82df3428
	ctx.lr = 0x825CF524;
	sub_82DF3428(ctx, base);
	// 825CF524: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825CF528: 48BD8C94  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CF530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CF530 size=252
    let mut pc: u32 = 0x825CF530;
    'dispatch: loop {
        match pc {
            0x825CF530 => {
    //   block [0x825CF530..0x825CF62C)
	// 825CF530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CF534: 48BD8C35  bl 0x831a8168
	ctx.lr = 0x825CF538;
	sub_831A8130(ctx, base);
	// 825CF538: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CF53C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CF540: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CF544: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825CF548: 396BDD38  addi r11, r11, -0x22c8
	ctx.r[11].s64 = ctx.r[11].s64 + -8904;
	// 825CF54C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825CF550: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825CF554: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CF558: 394ADD24  addi r10, r10, -0x22dc
	ctx.r[10].s64 = ctx.r[10].s64 + -8924;
	// 825CF55C: 3929DD14  addi r9, r9, -0x22ec
	ctx.r[9].s64 = ctx.r[9].s64 + -8940;
	// 825CF560: 3968DD04  addi r11, r8, -0x22fc
	ctx.r[11].s64 = ctx.r[8].s64 + -8956;
	// 825CF564: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825CF568: 913F00C0  stw r9, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[9].u32 ) };
	// 825CF56C: 3BBF00C0  addi r29, r31, 0xc0
	ctx.r[29].s64 = ctx.r[31].s64 + 192;
	// 825CF570: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 825CF574: 3B9F0124  addi r28, r31, 0x124
	ctx.r[28].s64 = ctx.r[31].s64 + 292;
	// 825CF578: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 825CF57C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CF580: 419A0008  beq cr6, 0x825cf588
	if ctx.cr[6].eq {
	pc = 0x825CF588; continue 'dispatch;
	}
	// 825CF584: 4BCF130D  bl 0x822c0890
	ctx.lr = 0x825CF588;
	sub_822C0890(ctx, base);
	// 825CF588: 807F015C  lwz r3, 0x15c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 825CF58C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CF590: 419A0008  beq cr6, 0x825cf598
	if ctx.cr[6].eq {
	pc = 0x825CF598; continue 'dispatch;
	}
	// 825CF594: 4BCF12FD  bl 0x822c0890
	ctx.lr = 0x825CF598;
	sub_822C0890(ctx, base);
	// 825CF598: 387F0144  addi r3, r31, 0x144
	ctx.r[3].s64 = ctx.r[31].s64 + 324;
	// 825CF59C: 4BE9AA65  bl 0x8246a000
	ctx.lr = 0x825CF5A0;
	sub_8246A000(ctx, base);
	// 825CF5A0: 83DF0140  lwz r30, 0x140(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 825CF5A4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825CF5A8: 419A0014  beq cr6, 0x825cf5bc
	if ctx.cr[6].eq {
	pc = 0x825CF5BC; continue 'dispatch;
	}
	// 825CF5AC: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CF5B0: 48822E29  bl 0x82df23d8
	ctx.lr = 0x825CF5B4;
	sub_82DF23D8(ctx, base);
	// 825CF5B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CF5B8: 48822E21  bl 0x82df23d8
	ctx.lr = 0x825CF5BC;
	sub_82DF23D8(ctx, base);
	// 825CF5BC: 83DF013C  lwz r30, 0x13c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 825CF5C0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825CF5C4: 419A0014  beq cr6, 0x825cf5d8
	if ctx.cr[6].eq {
	pc = 0x825CF5D8; continue 'dispatch;
	}
	// 825CF5C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CF5CC: 4BE9AA35  bl 0x8246a000
	ctx.lr = 0x825CF5D0;
	sub_8246A000(ctx, base);
	// 825CF5D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CF5D4: 48822E05  bl 0x82df23d8
	ctx.lr = 0x825CF5D8;
	sub_82DF23D8(ctx, base);
	// 825CF5D8: 807F0138  lwz r3, 0x138(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 825CF5DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825CF5E0: 419A0008  beq cr6, 0x825cf5e8
	if ctx.cr[6].eq {
	pc = 0x825CF5E8; continue 'dispatch;
	}
	// 825CF5E4: 4BCF12AD  bl 0x822c0890
	ctx.lr = 0x825CF5E8;
	sub_822C0890(ctx, base);
	// 825CF5E8: 807F0130  lwz r3, 0x130(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 825CF5EC: 4BCF0C7D  bl 0x822c0268
	ctx.lr = 0x825CF5F0;
	sub_822C0268(ctx, base);
	// 825CF5F0: 83DF012C  lwz r30, 0x12c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 825CF5F4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825CF5F8: 419A0014  beq cr6, 0x825cf60c
	if ctx.cr[6].eq {
	pc = 0x825CF60C; continue 'dispatch;
	}
	// 825CF5FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CF600: 4BEC1BC9  bl 0x824911c8
	ctx.lr = 0x825CF604;
	sub_824911C8(ctx, base);
	// 825CF604: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825CF608: 4BCF0C61  bl 0x822c0268
	ctx.lr = 0x825CF60C;
	sub_822C0268(ctx, base);
	// 825CF60C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825CF610: 488428E1  bl 0x82e11ef0
	ctx.lr = 0x825CF614;
	sub_82E11EF0(ctx, base);
	// 825CF614: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825CF618: 4888E231  bl 0x82e5d848
	ctx.lr = 0x825CF61C;
	sub_82E5D848(ctx, base);
	// 825CF61C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CF620: 4BF41B79  bl 0x82511198
	ctx.lr = 0x825CF624;
	sub_82511198(ctx, base);
	// 825CF624: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825CF628: 48BD8B90  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CF630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CF630 size=8
    let mut pc: u32 = 0x825CF630;
    'dispatch: loop {
        match pc {
            0x825CF630 => {
    //   block [0x825CF630..0x825CF638)
	// 825CF630: 3863FF40  addi r3, r3, -0xc0
	ctx.r[3].s64 = ctx.r[3].s64 + -192;
	// 825CF634: 48000014  b 0x825cf648
	sub_825CF648(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CF638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CF638 size=8
    let mut pc: u32 = 0x825CF638;
    'dispatch: loop {
        match pc {
            0x825CF638 => {
    //   block [0x825CF638..0x825CF640)
	// 825CF638: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 825CF63C: 4800000C  b 0x825cf648
	sub_825CF648(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CF640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CF640 size=8
    let mut pc: u32 = 0x825CF640;
    'dispatch: loop {
        match pc {
            0x825CF640 => {
    //   block [0x825CF640..0x825CF648)
	// 825CF640: 3863FEDC  addi r3, r3, -0x124
	ctx.r[3].s64 = ctx.r[3].s64 + -292;
	// 825CF644: 48000004  b 0x825cf648
	sub_825CF648(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CF648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CF648 size=76
    let mut pc: u32 = 0x825CF648;
    'dispatch: loop {
        match pc {
            0x825CF648 => {
    //   block [0x825CF648..0x825CF694)
	// 825CF648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CF64C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CF650: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CF654: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CF658: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CF65C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CF660: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CF664: 4BFFFECD  bl 0x825cf530
	ctx.lr = 0x825CF668;
	sub_825CF530(ctx, base);
	// 825CF668: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CF66C: 4182000C  beq 0x825cf678
	if ctx.cr[0].eq {
	pc = 0x825CF678; continue 'dispatch;
	}
	// 825CF670: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CF674: 48822D65  bl 0x82df23d8
	ctx.lr = 0x825CF678;
	sub_82DF23D8(ctx, base);
	// 825CF678: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825CF67C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825CF680: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CF684: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CF688: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825CF68C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CF690: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CF698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CF698 size=192
    let mut pc: u32 = 0x825CF698;
    'dispatch: loop {
        match pc {
            0x825CF698 => {
    //   block [0x825CF698..0x825CF758)
	// 825CF698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CF69C: 48BD8AC9  bl 0x831a8164
	ctx.lr = 0x825CF6A0;
	sub_831A8130(ctx, base);
	// 825CF6A0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CF6A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825CF6A8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825CF6AC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 825CF6B0: 419A00A0  beq cr6, 0x825cf750
	if ctx.cr[6].eq {
	pc = 0x825CF750; continue 'dispatch;
	}
	// 825CF6B4: 3B9E0010  addi r28, r30, 0x10
	ctx.r[28].s64 = ctx.r[30].s64 + 16;
	// 825CF6B8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825CF6BC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825CF6C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CF6C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825CF6C8: 41980018  blt cr6, 0x825cf6e0
	if ctx.cr[6].lt {
	pc = 0x825CF6E0; continue 'dispatch;
	}
	// 825CF6CC: 813B000C  lwz r9, 0xc(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 825CF6D0: 556A2834  slwi r10, r11, 5
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825CF6D4: 81690064  lwz r11, 0x64(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 825CF6D8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825CF6DC: 48000008  b 0x825cf6e4
	pc = 0x825CF6E4; continue 'dispatch;
	// 825CF6E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CF6E4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825CF6E8: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825CF6EC: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 825CF6F0: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825CF6F4: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825CF6F8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825CF6FC: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825CF700: 13E0E0C7  vcmpequd (lvx128) v31, v0, v28
	tmp.u32 = ctx.r[28].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825CF704: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825CF708: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CF758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CF758 size=224
    let mut pc: u32 = 0x825CF758;
    'dispatch: loop {
        match pc {
            0x825CF758 => {
    //   block [0x825CF758..0x825CF838)
	// 825CF758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CF75C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CF760: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825CF764: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CF768: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CF76C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825CF770: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825CF774: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CF778: 392B6910  addi r9, r11, 0x6910
	ctx.r[9].s64 = ctx.r[11].s64 + 26896;
	// 825CF77C: 396ADC00  addi r11, r10, -0x2400
	ctx.r[11].s64 = ctx.r[10].s64 + -9216;
	// 825CF780: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 825CF784: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 825CF788: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825CF78C: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 825CF790: 909F0010  stw r4, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 825CF794: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825CF798: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CF838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CF838 size=24
    let mut pc: u32 = 0x825CF838;
    'dispatch: loop {
        match pc {
            0x825CF838 => {
    //   block [0x825CF838..0x825CF850)
	// 825CF838: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 825CF83C: 81030060  lwz r8, 0x60(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 825CF840: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CF844: 816B012C  lwz r11, 0x12c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(300 as u32) ) } as u64;
	// 825CF848: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825CF84C: 4BD1BD64  b 0x822eb5b0
	sub_822EB5B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CF850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CF850 size=240
    let mut pc: u32 = 0x825CF850;
    'dispatch: loop {
        match pc {
            0x825CF850 => {
    //   block [0x825CF850..0x825CF940)
	// 825CF850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CF854: 48BD8915  bl 0x831a8168
	ctx.lr = 0x825CF858;
	sub_831A8130(ctx, base);
	// 825CF858: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CF85C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825CF860: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 825CF864: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 825CF868: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825CF86C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825CF870: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825CF874: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 825CF878: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825CF87C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 825CF880: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CF940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825CF940 size=396
    let mut pc: u32 = 0x825CF940;
    'dispatch: loop {
        match pc {
            0x825CF940 => {
    //   block [0x825CF940..0x825CFACC)
	// 825CF940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CF944: 48BD8821  bl 0x831a8164
	ctx.lr = 0x825CF948;
	sub_831A8130(ctx, base);
	// 825CF948: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CF94C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CF950: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825CF954: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825CF958: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825CF95C: 4BF3FBBD  bl 0x8250f518
	ctx.lr = 0x825CF960;
	sub_8250F518(ctx, base);
	// 825CF960: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CF964: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825CF968: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 825CF96C: 409A0008  bne cr6, 0x825cf974
	if !ctx.cr[6].eq {
	pc = 0x825CF974; continue 'dispatch;
	}
	// 825CF970: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825CF974: 4BF58BBD  bl 0x82528530
	ctx.lr = 0x825CF978;
	sub_82528530(ctx, base);
	// 825CF978: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 825CF97C: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 825CF980: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825CF984: 3BC00030  li r30, 0x30
	ctx.r[30].s64 = 48;
	// 825CF988: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825CF98C: 394100D0  addi r10, r1, 0xd0
	ctx.r[10].s64 = ctx.r[1].s64 + 208;
	// 825CF990: 392100E0  addi r9, r1, 0xe0
	ctx.r[9].s64 = ctx.r[1].s64 + 224;
	// 825CF994: 390100F0  addi r8, r1, 0xf0
	ctx.r[8].s64 = ctx.r[1].s64 + 240;
	// 825CF998: 13DC1C07  vcmpneb. (lvlx128) v30, v28, v3
	tmp.u32 = ctx.r[28].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825CF99C: 38E10100  addi r7, r1, 0x100
	ctx.r[7].s64 = ctx.r[1].s64 + 256;
	// 825CF9A0: 13BD1C07  vcmpneb. (lvlx128) v29, v29, v3
	tmp.u32 = ctx.r[29].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825CF9A4: 139E1C07  vcmpneb. (lvlx128) v28, v30, v3
	tmp.u32 = ctx.r[30].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825CF9A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CFAD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825CFAD0 size=152
    let mut pc: u32 = 0x825CFAD0;
    'dispatch: loop {
        match pc {
            0x825CFAD0 => {
    //   block [0x825CFAD0..0x825CFB68)
	// 825CFAD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CFAD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825CFAD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825CFADC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825CFAE0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825CFAE4: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 825CFAE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825CFAEC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825CFAF0: 908B7D50  stw r4, 0x7d50(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32080 as u32), ctx.r[4].u32 ) };
	// 825CFAF4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825CFAF8: 388BDCB8  addi r4, r11, -0x2348
	ctx.r[4].s64 = ctx.r[11].s64 + -9032;
	// 825CFAFC: 409A0024  bne cr6, 0x825cfb20
	if !ctx.cr[6].eq {
	pc = 0x825CFB20; continue 'dispatch;
	}
	// 825CFB00: 38A002EF  li r5, 0x2ef
	ctx.r[5].s64 = 751;
	// 825CFB04: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 825CFB08: 488228E1  bl 0x82df23e8
	ctx.lr = 0x825CFB0C;
	sub_82DF23E8(ctx, base);
	// 825CFB0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825CFB10: 41820034  beq 0x825cfb44
	if ctx.cr[0].eq {
	pc = 0x825CFB44; continue 'dispatch;
	}
	// 825CFB14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CFB18: 4BFFE8F9  bl 0x825ce410
	ctx.lr = 0x825CFB1C;
	sub_825CE410(ctx, base);
	// 825CFB1C: 48000020  b 0x825cfb3c
	pc = 0x825CFB3C; continue 'dispatch;
	// 825CFB20: 38A002EC  li r5, 0x2ec
	ctx.r[5].s64 = 748;
	// 825CFB24: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 825CFB28: 488228C1  bl 0x82df23e8
	ctx.lr = 0x825CFB2C;
	sub_82DF23E8(ctx, base);
	// 825CFB2C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825CFB30: 41820014  beq 0x825cfb44
	if ctx.cr[0].eq {
	pc = 0x825CFB44; continue 'dispatch;
	}
	// 825CFB34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825CFB38: 4BFFFC21  bl 0x825cf758
	ctx.lr = 0x825CFB3C;
	sub_825CF758(ctx, base);
	// 825CFB3C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825CFB40: 48000008  b 0x825cfb48
	pc = 0x825CFB48; continue 'dispatch;
	// 825CFB44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825CFB48: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825CFB4C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825CFB50: 48822889  bl 0x82df23d8
	ctx.lr = 0x825CFB54;
	sub_82DF23D8(ctx, base);
	// 825CFB54: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825CFB58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825CFB5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825CFB60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825CFB64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825CFB68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825CFB68 size=1768
    let mut pc: u32 = 0x825CFB68;
    'dispatch: loop {
        match pc {
            0x825CFB68 => {
    //   block [0x825CFB68..0x825D0250)
	// 825CFB68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825CFB6C: 48BD85E5  bl 0x831a8150
	ctx.lr = 0x825CFB70;
	sub_831A8130(ctx, base);
	// 825CFB70: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 825CFB74: 48BD8F05  bl 0x831a8a78
	ctx.lr = 0x825CFB78;
	sub_831A8A40(ctx, base);
	// 825CFB78: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D0250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D0250 size=456
    let mut pc: u32 = 0x825D0250;
    'dispatch: loop {
        match pc {
            0x825D0250 => {
    //   block [0x825D0250..0x825D0418)
	// 825D0250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D0254: 48BD7F11  bl 0x831a8164
	ctx.lr = 0x825D0258;
	sub_831A8130(ctx, base);
	// 825D0258: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 825D025C: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 825D0260: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D0264: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D0268: 48B84399  bl 0x83154600
	ctx.lr = 0x825D026C;
	sub_83154600(ctx, base);
	// 825D026C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D0270: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D0274: 816B0140  lwz r11, 0x140(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(320 as u32) ) } as u64;
	// 825D0278: 83EB0008  lwz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D027C: 48B84385  bl 0x83154600
	ctx.lr = 0x825D0280;
	sub_83154600(ctx, base);
	// 825D0280: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D0284: 48B8437D  bl 0x83154600
	ctx.lr = 0x825D0288;
	sub_83154600(ctx, base);
	// 825D0288: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D028C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D0290: C3EBB3B4  lfs f31, -0x4c4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19532 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825D0294: 48B8436D  bl 0x83154600
	ctx.lr = 0x825D0298;
	sub_83154600(ctx, base);
	// 825D0298: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D029C: 48B84365  bl 0x83154600
	ctx.lr = 0x825D02A0;
	sub_83154600(ctx, base);
	// 825D02A0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D02A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D02A8: C3CBB3BC  lfs f30, -0x4c44(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19524 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825D02AC: 48B84355  bl 0x83154600
	ctx.lr = 0x825D02B0;
	sub_83154600(ctx, base);
	// 825D02B0: 80830154  lwz r4, 0x154(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(340 as u32) ) } as u64;
	// 825D02B4: 4BFFEEE5  bl 0x825cf198
	ctx.lr = 0x825D02B8;
	sub_825CF198(ctx, base);
	// 825D02B8: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 825D02BC: 4182014C  beq 0x825d0408
	if ctx.cr[0].eq {
	pc = 0x825D0408; continue 'dispatch;
	}
	// 825D02C0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825D02C4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825D02C8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 825D02CC: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 825D02D0: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 825D02D4: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 825D02D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825D02DC: 9361006C  stw r27, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[27].u32 ) };
	// 825D02E0: 4BFFE971  bl 0x825cec50
	ctx.lr = 0x825D02E4;
	sub_825CEC50(ctx, base);
	// 825D02E4: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D02E8: 81210068  lwz r9, 0x68(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825D02EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825D02F0: 409A000C  bne cr6, 0x825d02fc
	if !ctx.cr[6].eq {
	pc = 0x825D02FC; continue 'dispatch;
	}
	// 825D02F4: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 825D02F8: 4800000C  b 0x825d0304
	pc = 0x825D0304; continue 'dispatch;
	// 825D02FC: 7D6A4850  subf r11, r10, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 825D0300: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825D0304: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825D0308: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825D030C: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825D0310: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 825D0314: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 825D0318: EDA007B2  fmuls f13, f0, f30
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 825D031C: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 825D0320: D9A10050  stfd f13, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[13].u64 ) };
	// 825D0324: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D0328: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825D032C: 409A001C  bne cr6, 0x825d0348
	if !ctx.cr[6].eq {
	pc = 0x825D0348; continue 'dispatch;
	}
	// 825D0330: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825D0334: 419A0014  beq cr6, 0x825d0348
	if ctx.cr[6].eq {
	pc = 0x825D0348; continue 'dispatch;
	}
	// 825D0338: 7D6A4850  subf r11, r10, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 825D033C: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D0340: 41820008  beq 0x825d0348
	if ctx.cr[0].eq {
	pc = 0x825D0348; continue 'dispatch;
	}
	// 825D0344: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 825D0348: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 825D034C: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825D0350: C1ABDFB0  lfs f13, -0x2050(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D0354: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825D0358: 419A00A8  beq cr6, 0x825d0400
	if ctx.cr[6].eq {
	pc = 0x825D0400; continue 'dispatch;
	}
	// 825D035C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D0360: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825D0364: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 825D0368: C3CB08A4  lfs f30, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825D036C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825D0370: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825D0374: 485A8B8D  bl 0x82b78f00
	ctx.lr = 0x825D0378;
	sub_82B78F00(ctx, base);
	// 825D0378: FC000E5E  fctidz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[1].f64.trunc() as i64 };
	// 825D037C: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 825D0380: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D0384: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825D0388: 7D5F582E  lwzx r10, r31, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825D038C: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D0390: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825D0394: 7D09582E  lwzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825D0398: 7D1F592E  stwx r8, r31, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), ctx.r[8].u32) };
	// 825D039C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825D03A0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D03A4: 7D49592E  stwx r10, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 825D03A8: 4082FFC4  bne 0x825d036c
	if !ctx.cr[0].eq {
	pc = 0x825D036C; continue 'dispatch;
	}
	// 825D03AC: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D03B0: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825D03B4: 419A004C  beq cr6, 0x825d0400
	if ctx.cr[6].eq {
	pc = 0x825D0400; continue 'dispatch;
	}
	// 825D03B8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825D03BC: 48000008  b 0x825d03c4
	pc = 0x825D03C4; continue 'dispatch;
	// 825D03C0: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D03C4: 7D7F502E  lwzx r11, r31, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825D03C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D03CC: 41980018  blt cr6, 0x825d03e4
	if ctx.cr[6].lt {
	pc = 0x825D03E4; continue 'dispatch;
	}
	// 825D03D0: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 825D03D4: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825D03D8: 814A0064  lwz r10, 0x64(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D03DC: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825D03E0: 48000008  b 0x825d03e8
	pc = 0x825D03E8; continue 'dispatch;
	// 825D03E4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825D03E8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825D03EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825D03F0: 485A9EB1  bl 0x82b7a2a0
	ctx.lr = 0x825D03F4;
	sub_82B7A2A0(ctx, base);
	// 825D03F4: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825D03F8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825D03FC: 4082FFC4  bne 0x825d03c0
	if !ctx.cr[0].eq {
	pc = 0x825D03C0; continue 'dispatch;
	}
	// 825D0400: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D0404: 4BE99BFD  bl 0x8246a000
	ctx.lr = 0x825D0408;
	sub_8246A000(ctx, base);
	// 825D0408: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825D040C: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 825D0410: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825D0414: 48BD7DA0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D0418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D0418 size=184
    let mut pc: u32 = 0x825D0418;
    'dispatch: loop {
        match pc {
            0x825D0418 => {
    //   block [0x825D0418..0x825D04D0)
	// 825D0418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D041C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D0420: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D0424: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D0428: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D042C: 4BF40CC5  bl 0x825110f0
	ctx.lr = 0x825D0430;
	sub_825110F0(ctx, base);
	// 825D0430: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 825D0434: 4888D49D  bl 0x82e5d8d0
	ctx.lr = 0x825D0438;
	sub_82E5D8D0(ctx, base);
	// 825D0438: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D043C: 387F0124  addi r3, r31, 0x124
	ctx.r[3].s64 = ctx.r[31].s64 + 292;
	// 825D0440: 396BDB78  addi r11, r11, -0x2488
	ctx.r[11].s64 = ctx.r[11].s64 + -9352;
	// 825D0444: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 825D0448: 48841A91  bl 0x82e11ed8
	ctx.lr = 0x825D044C;
	sub_82E11ED8(ctx, base);
	// 825D044C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D0450: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825D0454: 396BDD38  addi r11, r11, -0x22c8
	ctx.r[11].s64 = ctx.r[11].s64 + -8904;
	// 825D0458: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825D045C: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825D0460: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D0464: 394ADD24  addi r10, r10, -0x22dc
	ctx.r[10].s64 = ctx.r[10].s64 + -8924;
	// 825D0468: 3929DD14  addi r9, r9, -0x22ec
	ctx.r[9].s64 = ctx.r[9].s64 + -8940;
	// 825D046C: 3908DD04  addi r8, r8, -0x22fc
	ctx.r[8].s64 = ctx.r[8].s64 + -8956;
	// 825D0470: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825D0474: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D0478: 913F00C0  stw r9, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[9].u32 ) };
	// 825D047C: 911F0124  stw r8, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[8].u32 ) };
	// 825D0480: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D0484: 917F012C  stw r11, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[11].u32 ) };
	// 825D0488: 917F0130  stw r11, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 825D048C: 917F0134  stw r11, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[11].u32 ) };
	// 825D0490: 917F0138  stw r11, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[11].u32 ) };
	// 825D0494: 917F013C  stw r11, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[11].u32 ) };
	// 825D0498: 917F0140  stw r11, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 825D049C: 917F0148  stw r11, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[11].u32 ) };
	// 825D04A0: 917F014C  stw r11, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[11].u32 ) };
	// 825D04A4: 917F0150  stw r11, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 825D04A8: 917F0154  stw r11, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[11].u32 ) };
	// 825D04AC: 917F0158  stw r11, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 825D04B0: 917F015C  stw r11, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[11].u32 ) };
	// 825D04B4: 917F0160  stw r11, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 825D04B8: 917F0164  stw r11, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[11].u32 ) };
	// 825D04BC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D04C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D04C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D04C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D04CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D04D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D04D0 size=80
    let mut pc: u32 = 0x825D04D0;
    'dispatch: loop {
        match pc {
            0x825D04D0 => {
    //   block [0x825D04D0..0x825D0520)
	// 825D04D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D04D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D04D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D04DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D04E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D04E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D04E8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825D04EC: 396BDD74  addi r11, r11, -0x228c
	ctx.r[11].s64 = ctx.r[11].s64 + -8844;
	// 825D04F0: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 825D04F4: 909F0004  stw r4, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 825D04F8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D04FC: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825D0500: 80897D50  lwz r4, 0x7d50(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32080 as u32) ) } as u64;
	// 825D0504: 4BFFF5CD  bl 0x825cfad0
	ctx.lr = 0x825D0508;
	sub_825CFAD0(ctx, base);
	// 825D0508: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D050C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D0510: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D0514: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D0518: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D051C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D0520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D0520 size=44
    let mut pc: u32 = 0x825D0520;
    'dispatch: loop {
        match pc {
            0x825D0520 => {
    //   block [0x825D0520..0x825D054C)
	// 825D0520: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D0524: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825D0528: 994B0051  stb r10, 0x51(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 825D052C: 994B0052  stb r10, 0x52(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(82 as u32), ctx.r[10].u8 ) };
	// 825D0530: 994B0053  stb r10, 0x53(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(83 as u32), ctx.r[10].u8 ) };
	// 825D0534: 994B0054  stb r10, 0x54(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(84 as u32), ctx.r[10].u8 ) };
	// 825D0538: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D053C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D0540: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D0544: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D0548: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D0550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D0550 size=732
    let mut pc: u32 = 0x825D0550;
    'dispatch: loop {
        match pc {
            0x825D0550 => {
    //   block [0x825D0550..0x825D082C)
	// 825D0550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D0554: 48BD7C15  bl 0x831a8168
	ctx.lr = 0x825D0558;
	sub_831A8130(ctx, base);
	// 825D0558: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 825D055C: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825D0560: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D0564: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825D0568: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D056C: 896B0050  lbz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D0570: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D0574: 418202A8  beq 0x825d081c
	if ctx.cr[0].eq {
	pc = 0x825D081C; continue 'dispatch;
	}
	// 825D0578: 83FC0008  lwz r31, 8(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D057C: 3FC08212  lis r30, -0x7dee
	ctx.r[30].s64 = -2112749568;
	// 825D0580: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D0584: 3BBF0020  addi r29, r31, 0x20
	ctx.r[29].s64 = ctx.r[31].s64 + 32;
	// 825D0588: C01F0030  lfs f0, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D058C: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 825D0590: C01EDFB0  lfs f0, -0x2050(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D0594: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825D0598: C03F0034  lfs f1, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825D059C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825D05A0: 40980054  bge cr6, 0x825d05f4
	if !ctx.cr[6].lt {
	pc = 0x825D05F4; continue 'dispatch;
	}
	// 825D05A4: 4BD4331D  bl 0x823138c0
	ctx.lr = 0x825D05A8;
	sub_823138C0(ctx, base);
	// 825D05A8: C01F0038  lfs f0, 0x38(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D05AC: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 825D05B0: C1BEDFB0  lfs f13, -0x2050(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D05B4: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 825D05B8: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 825D05BC: 4098000C  bge cr6, 0x825d05c8
	if !ctx.cr[6].lt {
	pc = 0x825D05C8; continue 'dispatch;
	}
	// 825D05C0: FDA0F890  fmr f13, f31
	ctx.f[13].f64 = ctx.f[31].f64;
	// 825D05C4: 48000020  b 0x825d05e4
	pc = 0x825D05E4; continue 'dispatch;
	// 825D05C8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825D05CC: 40990010  ble cr6, 0x825d05dc
	if !ctx.cr[6].gt {
	pc = 0x825D05DC; continue 'dispatch;
	}
	// 825D05D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D05D4: C1AB08A8  lfs f13, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D05D8: 4800000C  b 0x825d05e4
	pc = 0x825D05E4; continue 'dispatch;
	// 825D05DC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825D05E0: C1AB9534  lfs f13, -0x6acc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825D05E4: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 825D05E8: C00BDFAC  lfs f0, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D05EC: FC2D07EE  fsel f1, f13, f31, f0
	ctx.f[1].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[31].f64 } else { ctx.f[0].f64 };
	// 825D05F0: 4800001C  b 0x825d060c
	pc = 0x825D060C; continue 'dispatch;
	// 825D05F4: 4BD432CD  bl 0x823138c0
	ctx.lr = 0x825D05F8;
	sub_823138C0(ctx, base);
	// 825D05F8: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 825D05FC: C05F0038  lfs f2, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825D0600: C03F0030  lfs f1, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825D0604: 48BDA9B5  bl 0x831aafb8
	ctx.lr = 0x825D0608;
	sub_831AAFB8(ctx, base);
	// 825D0608: FC200818  frsp f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (ctx.f[1].f64 as f32) as f64;
	// 825D060C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825D0610: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 825D0614: 396B6880  addi r11, r11, 0x6880
	ctx.r[11].s64 = ctx.r[11].s64 + 26752;
	// 825D0618: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 825D061C: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 825D0620: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 825D0624: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 825D0628: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 825D062C: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825D0630: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 825D0634: 13CA5C07  vcmpneb. (lvlx128) v30, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825D0638: 13A95C07  vcmpneb. (lvlx128) v29, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825D063C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825D0640: 13885C07  vcmpneb. (lvlx128) v28, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D0830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D0830 size=128
    let mut pc: u32 = 0x825D0830;
    'dispatch: loop {
        match pc {
            0x825D0830 => {
    //   block [0x825D0830..0x825D08B0)
	// 825D0830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D0834: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D0838: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D083C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D0840: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D0844: 48B83DBD  bl 0x83154600
	ctx.lr = 0x825D0848;
	sub_83154600(ctx, base);
	// 825D0848: 81630140  lwz r11, 0x140(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(320 as u32) ) } as u64;
	// 825D084C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D0850: 419A004C  beq cr6, 0x825d089c
	if ctx.cr[6].eq {
	pc = 0x825D089C; continue 'dispatch;
	}
	// 825D0854: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D0858: 48B83DA9  bl 0x83154600
	ctx.lr = 0x825D085C;
	sub_83154600(ctx, base);
	// 825D085C: 81630140  lwz r11, 0x140(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(320 as u32) ) } as u64;
	// 825D0860: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D0864: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D0868: 896B0051  lbz r11, 0x51(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(81 as u32) ) } as u64;
	// 825D086C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D0870: 4182000C  beq 0x825d087c
	if ctx.cr[0].eq {
	pc = 0x825D087C; continue 'dispatch;
	}
	// 825D0874: 4BFFF2F5  bl 0x825cfb68
	ctx.lr = 0x825D0878;
	sub_825CFB68(ctx, base);
	// 825D0878: 48000024  b 0x825d089c
	pc = 0x825D089C; continue 'dispatch;
	// 825D087C: 48B83D85  bl 0x83154600
	ctx.lr = 0x825D0880;
	sub_83154600(ctx, base);
	// 825D0880: 81630140  lwz r11, 0x140(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(320 as u32) ) } as u64;
	// 825D0884: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D0888: 896B0052  lbz r11, 0x52(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(82 as u32) ) } as u64;
	// 825D088C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D0890: 4182000C  beq 0x825d089c
	if ctx.cr[0].eq {
	pc = 0x825D089C; continue 'dispatch;
	}
	// 825D0894: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D0898: 4BFFF9B9  bl 0x825d0250
	ctx.lr = 0x825D089C;
	sub_825D0250(ctx, base);
	// 825D089C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D08A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D08A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D08A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D08AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D08B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D08B0 size=1048
    let mut pc: u32 = 0x825D08B0;
    'dispatch: loop {
        match pc {
            0x825D08B0 => {
    //   block [0x825D08B0..0x825D0CC8)
	// 825D08B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D08B4: 48BD78AD  bl 0x831a8160
	ctx.lr = 0x825D08B8;
	sub_831A8130(ctx, base);
	// 825D08B8: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 825D08BC: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D08C0: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825D08C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D08C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D08CC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825D08D0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825D08D4: 808BE268  lwz r4, -0x1d98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7576 as u32) ) } as u64;
	// 825D08D8: 48823131  bl 0x82df3a08
	ctx.lr = 0x825D08DC;
	sub_82DF3A08(ctx, base);
	// 825D08DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D08E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D08E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D08E8: 4BF37E99  bl 0x82508780
	ctx.lr = 0x825D08EC;
	sub_82508780(ctx, base);
	// 825D08EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D08F0: 48822B39  bl 0x82df3428
	ctx.lr = 0x825D08F4;
	sub_82DF3428(ctx, base);
	// 825D08F4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 825D08F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D08FC: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 825D0900: 409A0008  bne cr6, 0x825d0908
	if !ctx.cr[6].eq {
	pc = 0x825D0908; continue 'dispatch;
	}
	// 825D0904: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825D0908: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D090C: 4BF37E95  bl 0x825087a0
	ctx.lr = 0x825D0910;
	sub_825087A0(ctx, base);
	// 825D0910: 3FC08330  lis r30, -0x7cd0
	ctx.r[30].s64 = -2094006272;
	// 825D0914: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D0918: 809E94CC  lwz r4, -0x6b34(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-27444 as u32) ) } as u64;
	// 825D091C: 488230ED  bl 0x82df3a08
	ctx.lr = 0x825D0920;
	sub_82DF3A08(ctx, base);
	// 825D0920: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D0924: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825D0928: 4BF3EA09  bl 0x8250f330
	ctx.lr = 0x825D092C;
	sub_8250F330(ctx, base);
	// 825D092C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D0930: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D0934: 4BF18FC5  bl 0x824e98f8
	ctx.lr = 0x825D0938;
	sub_824E98F8(ctx, base);
	// 825D0938: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825D093C: 48821355  bl 0x82df1c90
	ctx.lr = 0x825D0940;
	sub_82DF1C90(ctx, base);
	// 825D0940: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D0944: 48822AE5  bl 0x82df3428
	ctx.lr = 0x825D0948;
	sub_82DF3428(ctx, base);
	// 825D0948: 397F0144  addi r11, r31, 0x144
	ctx.r[11].s64 = ctx.r[31].s64 + 324;
	// 825D094C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825D0950: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D0954: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825D0958: 4BFFE3B9  bl 0x825ced10
	ctx.lr = 0x825D095C;
	sub_825CED10(ctx, base);
	// 825D095C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D0960: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825D0964: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D0968: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D096C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825D0970: 419A0024  beq cr6, 0x825d0994
	if ctx.cr[6].eq {
	pc = 0x825D0994; continue 'dispatch;
	}
	// 825D0974: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D0978: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D097C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D0980: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D0984: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D0988: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D098C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D0990: 4082FFE8  bne 0x825d0978
	if !ctx.cr[0].eq {
	pc = 0x825D0978; continue 'dispatch;
	}
	// 825D0994: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D0998: 809E94CC  lwz r4, -0x6b34(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-27444 as u32) ) } as u64;
	// 825D099C: 4882306D  bl 0x82df3a08
	ctx.lr = 0x825D09A0;
	sub_82DF3A08(ctx, base);
	// 825D09A0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D09A4: 3B7F0028  addi r27, r31, 0x28
	ctx.r[27].s64 = ctx.r[31].s64 + 40;
	// 825D09A8: 3BABDCB8  addi r29, r11, -0x2348
	ctx.r[29].s64 = ctx.r[11].s64 + -9032;
	// 825D09AC: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 825D09B0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D09B4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825D09B8: 38A00815  li r5, 0x815
	ctx.r[5].s64 = 2069;
	// 825D09BC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825D09C0: 48888761  bl 0x82e59120
	ctx.lr = 0x825D09C4;
	sub_82E59120(ctx, base);
	// 825D09C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D09C8: 48822A61  bl 0x82df3428
	ctx.lr = 0x825D09CC;
	sub_82DF3428(ctx, base);
	// 825D09CC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825D09D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D09D4: 419A0008  beq cr6, 0x825d09dc
	if ctx.cr[6].eq {
	pc = 0x825D09DC; continue 'dispatch;
	}
	// 825D09D8: 4BCEFEB9  bl 0x822c0890
	ctx.lr = 0x825D09DC;
	sub_822C0890(ctx, base);
	// 825D09DC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825D09E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D09E4: 419A0008  beq cr6, 0x825d09ec
	if ctx.cr[6].eq {
	pc = 0x825D09EC; continue 'dispatch;
	}
	// 825D09E8: 4BCEFEA9  bl 0x822c0890
	ctx.lr = 0x825D09EC;
	sub_822C0890(ctx, base);
	// 825D09EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D09F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D09F4: 38A00818  li r5, 0x818
	ctx.r[5].s64 = 2072;
	// 825D09F8: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 825D09FC: 4BCEF9DD  bl 0x822c03d8
	ctx.lr = 0x825D0A00;
	sub_822C03D8(ctx, base);
	// 825D0A00: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D0A04: 41820010  beq 0x825d0a14
	if ctx.cr[0].eq {
	pc = 0x825D0A14; continue 'dispatch;
	}
	// 825D0A08: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825D0A0C: 4BEC06E5  bl 0x824910f0
	ctx.lr = 0x825D0A10;
	sub_824910F0(ctx, base);
	// 825D0A10: 48000008  b 0x825d0a18
	pc = 0x825D0A18; continue 'dispatch;
	// 825D0A14: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825D0A18: 83DF012C  lwz r30, 0x12c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 825D0A1C: 907F012C  stw r3, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[3].u32 ) };
	// 825D0A20: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825D0A24: 419A0014  beq cr6, 0x825d0a38
	if ctx.cr[6].eq {
	pc = 0x825D0A38; continue 'dispatch;
	}
	// 825D0A28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D0A2C: 4BEC079D  bl 0x824911c8
	ctx.lr = 0x825D0A30;
	sub_824911C8(ctx, base);
	// 825D0A30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D0A34: 4BCEF835  bl 0x822c0268
	ctx.lr = 0x825D0A38;
	sub_822C0268(ctx, base);
	// 825D0A38: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D0A3C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D0A40: 38A0081A  li r5, 0x81a
	ctx.r[5].s64 = 2074;
	// 825D0A44: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 825D0A48: 4BCEF991  bl 0x822c03d8
	ctx.lr = 0x825D0A4C;
	sub_822C03D8(ctx, base);
	// 825D0A4C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D0A50: 41820010  beq 0x825d0a60
	if ctx.cr[0].eq {
	pc = 0x825D0A60; continue 'dispatch;
	}
	// 825D0A54: 4BFE1025  bl 0x825b1a78
	ctx.lr = 0x825D0A58;
	sub_825B1A78(ctx, base);
	// 825D0A58: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D0A5C: 48000008  b 0x825d0a64
	pc = 0x825D0A64; continue 'dispatch;
	// 825D0A60: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 825D0A64: 807F0130  lwz r3, 0x130(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 825D0A68: 917F0130  stw r11, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 825D0A6C: 4BCEF7FD  bl 0x822c0268
	ctx.lr = 0x825D0A70;
	sub_822C0268(ctx, base);
	// 825D0A70: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D0A74: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D0A78: 38A0081E  li r5, 0x81e
	ctx.r[5].s64 = 2078;
	// 825D0A7C: 38600130  li r3, 0x130
	ctx.r[3].s64 = 304;
	// 825D0A80: 48821969  bl 0x82df23e8
	ctx.lr = 0x825D0A84;
	sub_82DF23E8(ctx, base);
	// 825D0A84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D0A88: 41820010  beq 0x825d0a98
	if ctx.cr[0].eq {
	pc = 0x825D0A98; continue 'dispatch;
	}
	// 825D0A8C: 4BFE22B5  bl 0x825b2d40
	ctx.lr = 0x825D0A90;
	sub_825B2D40(ctx, base);
	// 825D0A90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D0A94: 48000008  b 0x825d0a9c
	pc = 0x825D0A9C; continue 'dispatch;
	// 825D0A98: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825D0A9C: 3BDF0134  addi r30, r31, 0x134
	ctx.r[30].s64 = ctx.r[31].s64 + 308;
	// 825D0AA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D0AA4: 4BFE1875  bl 0x825b2318
	ctx.lr = 0x825D0AA8;
	sub_825B2318(ctx, base);
	// 825D0AA8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D0AAC: 39400BBA  li r10, 0xbba
	ctx.r[10].s64 = 3002;
	// 825D0AB0: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825D0AB4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825D0AB8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825D0ABC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D0AC0: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825D0AC4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D0AC8: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825D0ACC: 4859B9AD  bl 0x82b6c478
	ctx.lr = 0x825D0AD0;
	sub_82B6C478(ctx, base);
	// 825D0AD0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D0AD4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825D0AD8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D0ADC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D0AE0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825D0AE4: 419A0024  beq cr6, 0x825d0b08
	if ctx.cr[6].eq {
	pc = 0x825D0B08; continue 'dispatch;
	}
	// 825D0AE8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D0AEC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D0AF0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D0AF4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D0AF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D0AFC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D0B00: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D0B04: 4082FFE8  bne 0x825d0aec
	if !ctx.cr[0].eq {
	pc = 0x825D0AEC; continue 'dispatch;
	}
	// 825D0B08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D0B0C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825D0B10: 4BF3EA09  bl 0x8250f518
	ctx.lr = 0x825D0B14;
	sub_8250F518(ctx, base);
	// 825D0B14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D0B18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D0B1C: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 825D0B20: 409A0008  bne cr6, 0x825d0b28
	if !ctx.cr[6].eq {
	pc = 0x825D0B28; continue 'dispatch;
	}
	// 825D0B24: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825D0B28: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 825D0B2C: 4BF57525  bl 0x82528050
	ctx.lr = 0x825D0B30;
	sub_82528050(ctx, base);
	// 825D0B30: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825D0B34: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D0B38: 38A00820  li r5, 0x820
	ctx.r[5].s64 = 2080;
	// 825D0B3C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825D0B40: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 825D0B44: 488864A5  bl 0x82e56fe8
	ctx.lr = 0x825D0B48;
	sub_82E56FE8(ctx, base);
	// 825D0B48: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825D0B4C: 48821145  bl 0x82df1c90
	ctx.lr = 0x825D0B50;
	sub_82DF1C90(ctx, base);
	// 825D0B50: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D0B54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D0B58: 419A0008  beq cr6, 0x825d0b60
	if ctx.cr[6].eq {
	pc = 0x825D0B60; continue 'dispatch;
	}
	// 825D0B5C: 4BCEFD35  bl 0x822c0890
	ctx.lr = 0x825D0B60;
	sub_822C0890(ctx, base);
	// 825D0B60: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825D0B64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D0B68: 419A0008  beq cr6, 0x825d0b70
	if ctx.cr[6].eq {
	pc = 0x825D0B70; continue 'dispatch;
	}
	// 825D0B6C: 4BCEFD25  bl 0x822c0890
	ctx.lr = 0x825D0B70;
	sub_822C0890(ctx, base);
	// 825D0B70: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D0B74: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D0B78: 38A00823  li r5, 0x823
	ctx.r[5].s64 = 2083;
	// 825D0B7C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825D0B80: 48821869  bl 0x82df23e8
	ctx.lr = 0x825D0B84;
	sub_82DF23E8(ctx, base);
	// 825D0B84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D0B88: 41820018  beq 0x825d0ba0
	if ctx.cr[0].eq {
	pc = 0x825D0BA0; continue 'dispatch;
	}
	// 825D0B8C: 93430004  stw r26, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 825D0B90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D0B94: 93430008  stw r26, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 825D0B98: 9343000C  stw r26, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 825D0B9C: 48000008  b 0x825d0ba4
	pc = 0x825D0BA4; continue 'dispatch;
	// 825D0BA0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 825D0BA4: 83DF013C  lwz r30, 0x13c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 825D0BA8: 917F013C  stw r11, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[11].u32 ) };
	// 825D0BAC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825D0BB0: 419A0014  beq cr6, 0x825d0bc4
	if ctx.cr[6].eq {
	pc = 0x825D0BC4; continue 'dispatch;
	}
	// 825D0BB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D0BB8: 4BE99449  bl 0x8246a000
	ctx.lr = 0x825D0BBC;
	sub_8246A000(ctx, base);
	// 825D0BBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D0BC0: 48821819  bl 0x82df23d8
	ctx.lr = 0x825D0BC4;
	sub_82DF23D8(ctx, base);
	// 825D0BC4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D0BC8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D0BCC: 38A00827  li r5, 0x827
	ctx.r[5].s64 = 2087;
	// 825D0BD0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825D0BD4: 48821815  bl 0x82df23e8
	ctx.lr = 0x825D0BD8;
	sub_82DF23E8(ctx, base);
	// 825D0BD8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D0BDC: 41820010  beq 0x825d0bec
	if ctx.cr[0].eq {
	pc = 0x825D0BEC; continue 'dispatch;
	}
	// 825D0BE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D0BE4: 4BFFF8ED  bl 0x825d04d0
	ctx.lr = 0x825D0BE8;
	sub_825D04D0(ctx, base);
	// 825D0BE8: 48000008  b 0x825d0bf0
	pc = 0x825D0BF0; continue 'dispatch;
	// 825D0BEC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825D0BF0: 83DF0140  lwz r30, 0x140(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 825D0BF4: 907F0140  stw r3, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[3].u32 ) };
	// 825D0BF8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825D0BFC: 419A0014  beq cr6, 0x825d0c10
	if ctx.cr[6].eq {
	pc = 0x825D0C10; continue 'dispatch;
	}
	// 825D0C00: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D0C04: 488217D5  bl 0x82df23d8
	ctx.lr = 0x825D0C08;
	sub_82DF23D8(ctx, base);
	// 825D0C08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D0C0C: 488217CD  bl 0x82df23d8
	ctx.lr = 0x825D0C10;
	sub_82DF23D8(ctx, base);
	// 825D0C10: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 825D0C14: 3BDF00C0  addi r30, r31, 0xc0
	ctx.r[30].s64 = ctx.r[31].s64 + 192;
	// 825D0C18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D0C1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D0C20: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D0C24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D0C28: 4E800421  bctrl
	ctx.lr = 0x825D0C2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D0C2C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 825D0C30: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D0C34: 3BEBCFB0  addi r31, r11, -0x3050
	ctx.r[31].s64 = ctx.r[11].s64 + -12368;
	// 825D0C38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D0C3C: 48822DCD  bl 0x82df3a08
	ctx.lr = 0x825D0C40;
	sub_82DF3A08(ctx, base);
	// 825D0C40: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D0C44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D0C48: 4BFFE7C9  bl 0x825cf410
	ctx.lr = 0x825D0C4C;
	sub_825CF410(ctx, base);
	// 825D0C4C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D0C50: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D0C54: 388BDD7C  addi r4, r11, -0x2284
	ctx.r[4].s64 = ctx.r[11].s64 + -8836;
	// 825D0C58: 48822DB1  bl 0x82df3a08
	ctx.lr = 0x825D0C5C;
	sub_82DF3A08(ctx, base);
	// 825D0C5C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D0C60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D0C64: 4BFFE80D  bl 0x825cf470
	ctx.lr = 0x825D0C68;
	sub_825CF470(ctx, base);
	// 825D0C68: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 825D0C6C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D0C70: 388BA224  addi r4, r11, -0x5ddc
	ctx.r[4].s64 = ctx.r[11].s64 + -24028;
	// 825D0C74: 48822D95  bl 0x82df3a08
	ctx.lr = 0x825D0C78;
	sub_82DF3A08(ctx, base);
	// 825D0C78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D0C7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D0C80: 4BFFE851  bl 0x825cf4d0
	ctx.lr = 0x825D0C84;
	sub_825CF4D0(ctx, base);
	// 825D0C84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D0C88: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D0C8C: 48822D7D  bl 0x82df3a08
	ctx.lr = 0x825D0C90;
	sub_82DF3A08(ctx, base);
	// 825D0C90: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825D0C94: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D0C98: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825D0C9C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825D0CA0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D0CA4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825D0CA8: 4888DCB9  bl 0x82e5e960
	ctx.lr = 0x825D0CAC;
	sub_82E5E960(ctx, base);
	// 825D0CAC: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 825D0CB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D0CB4: 419A0008  beq cr6, 0x825d0cbc
	if ctx.cr[6].eq {
	pc = 0x825D0CBC; continue 'dispatch;
	}
	// 825D0CB8: 4BCEFBD9  bl 0x822c0890
	ctx.lr = 0x825D0CBC;
	sub_822C0890(ctx, base);
	// 825D0CBC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 825D0CC0: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 825D0CC4: 48BD74EC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D0CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D0CC8 size=24
    let mut pc: u32 = 0x825D0CC8;
    'dispatch: loop {
        match pc {
            0x825D0CC8 => {
    //   block [0x825D0CC8..0x825D0CE0)
	// 825D0CC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D0CCC: 99630041  stb r11, 0x41(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(65 as u32), ctx.r[11].u8 ) };
	// 825D0CD0: 99630042  stb r11, 0x42(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(66 as u32), ctx.r[11].u8 ) };
	// 825D0CD4: 99630043  stb r11, 0x43(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(67 as u32), ctx.r[11].u8 ) };
	// 825D0CD8: 99630044  stb r11, 0x44(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[11].u8 ) };
	// 825D0CDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D0CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D0CE0 size=160
    let mut pc: u32 = 0x825D0CE0;
    'dispatch: loop {
        match pc {
            0x825D0CE0 => {
    //   block [0x825D0CE0..0x825D0D80)
	// 825D0CE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D0CE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D0CE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D0CEC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D0CF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D0CF4: 897F0040  lbz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 825D0CF8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D0CFC: 41820070  beq 0x825d0d6c
	if ctx.cr[0].eq {
	pc = 0x825D0D6C; continue 'dispatch;
	}
	// 825D0D00: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D0D04: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825D0D08: 4BF3E7C1  bl 0x8250f4c8
	ctx.lr = 0x825D0D0C;
	sub_8250F4C8(ctx, base);
	// 825D0D0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D0D10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D0D14: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 825D0D18: 409A0008  bne cr6, 0x825d0d20
	if !ctx.cr[6].eq {
	pc = 0x825D0D20; continue 'dispatch;
	}
	// 825D0D1C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D0D20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D0D24: 4BF37C8D  bl 0x825089b0
	ctx.lr = 0x825D0D28;
	sub_825089B0(ctx, base);
	// 825D0D28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D0D2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D0D30: 386BFF34  addi r3, r11, -0xcc
	ctx.r[3].s64 = ctx.r[11].s64 + -204;
	// 825D0D34: 409A0008  bne cr6, 0x825d0d3c
	if !ctx.cr[6].eq {
	pc = 0x825D0D3C; continue 'dispatch;
	}
	// 825D0D38: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825D0D3C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D0D40: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825D0D44: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 825D0D48: 38EABA80  addi r7, r10, -0x4580
	ctx.r[7].s64 = ctx.r[10].s64 + -17792;
	// 825D0D4C: 38C99FBC  addi r6, r9, -0x6044
	ctx.r[6].s64 = ctx.r[9].s64 + -24644;
	// 825D0D50: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 825D0D54: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825D0D58: 4BCF6D11  bl 0x822c7a68
	ctx.lr = 0x825D0D5C;
	sub_822C7A68(ctx, base);
	// 825D0D5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D0D60: 48820F31  bl 0x82df1c90
	ctx.lr = 0x825D0D64;
	sub_82DF1C90(ctx, base);
	// 825D0D64: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D0D68: 48820F29  bl 0x82df1c90
	ctx.lr = 0x825D0D6C;
	sub_82DF1C90(ctx, base);
	// 825D0D6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D0D70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D0D74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D0D78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D0D7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D0D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D0D80 size=88
    let mut pc: u32 = 0x825D0D80;
    'dispatch: loop {
        match pc {
            0x825D0D80 => {
    //   block [0x825D0D80..0x825D0DD8)
	// 825D0D80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D0D84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D0D88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D0D8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D0D90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D0D94: 48B8386D  bl 0x83154600
	ctx.lr = 0x825D0D98;
	sub_83154600(ctx, base);
	// 825D0D98: 8163013C  lwz r11, 0x13c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(316 as u32) ) } as u64;
	// 825D0D9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D0DA0: 419A0024  beq cr6, 0x825d0dc4
	if ctx.cr[6].eq {
	pc = 0x825D0DC4; continue 'dispatch;
	}
	// 825D0DA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D0DA8: 48B83859  bl 0x83154600
	ctx.lr = 0x825D0DAC;
	sub_83154600(ctx, base);
	// 825D0DAC: 8163013C  lwz r11, 0x13c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(316 as u32) ) } as u64;
	// 825D0DB0: 896B0041  lbz r11, 0x41(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(65 as u32) ) } as u64;
	// 825D0DB4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D0DB8: 4082000C  bne 0x825d0dc4
	if !ctx.cr[0].eq {
	pc = 0x825D0DC4; continue 'dispatch;
	}
	// 825D0DBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D0DC0: 48B83841  bl 0x83154600
	ctx.lr = 0x825D0DC4;
	sub_83154600(ctx, base);
	// 825D0DC4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D0DC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D0DCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D0DD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D0DD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D0DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D0DD8 size=172
    let mut pc: u32 = 0x825D0DD8;
    'dispatch: loop {
        match pc {
            0x825D0DD8 => {
    //   block [0x825D0DD8..0x825D0E84)
	// 825D0DD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D0DDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D0DE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D0DE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D0DE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D0DEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D0DF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D0DF4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825D0DF8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D0DFC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D0E00: 4BCEFB39  bl 0x822c0938
	ctx.lr = 0x825D0E04;
	sub_822C0938(ctx, base);
	// 825D0E04: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D0E08: 41820028  beq 0x825d0e30
	if ctx.cr[0].eq {
	pc = 0x825D0E30; continue 'dispatch;
	}
	// 825D0E0C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D0E10: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825D0E14: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D0E18: 392BDDE0  addi r9, r11, -0x2220
	ctx.r[9].s64 = ctx.r[11].s64 + -8736;
	// 825D0E1C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D0E20: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D0E24: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D0E28: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825D0E2C: 48000008  b 0x825d0e34
	pc = 0x825D0E34; continue 'dispatch;
	// 825D0E30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D0E34: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D0E38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D0E3C: 409A002C  bne cr6, 0x825d0e68
	if !ctx.cr[6].eq {
	pc = 0x825D0E68; continue 'dispatch;
	}
	// 825D0E40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D0E44: 48821595  bl 0x82df23d8
	ctx.lr = 0x825D0E48;
	sub_82DF23D8(ctx, base);
	// 825D0E48: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D0E4C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825D0E50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D0E54: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825D0E58: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825D0E5C: 816BB910  lwz r11, -0x46f0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18160 as u32) ) } as u64;
	// 825D0E60: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D0E64: 4BCEF19D  bl 0x822c0000
	ctx.lr = 0x825D0E68;
	sub_822C0000(ctx, base);
	// 825D0E68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D0E6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D0E70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D0E74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D0E78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D0E7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D0E80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D0E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D0E88 size=196
    let mut pc: u32 = 0x825D0E88;
    'dispatch: loop {
        match pc {
            0x825D0E88 => {
    //   block [0x825D0E88..0x825D0F4C)
	// 825D0E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D0E8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D0E90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D0E94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D0E98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D0E9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D0EA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D0EA4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825D0EA8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D0EAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D0EB0: 4BCEFA89  bl 0x822c0938
	ctx.lr = 0x825D0EB4;
	sub_822C0938(ctx, base);
	// 825D0EB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D0EB8: 41820028  beq 0x825d0ee0
	if ctx.cr[0].eq {
	pc = 0x825D0EE0; continue 'dispatch;
	}
	// 825D0EBC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D0EC0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825D0EC4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D0EC8: 392BDDF4  addi r9, r11, -0x220c
	ctx.r[9].s64 = ctx.r[11].s64 + -8716;
	// 825D0ECC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D0ED0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D0ED4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D0ED8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825D0EDC: 48000008  b 0x825d0ee4
	pc = 0x825D0EE4; continue 'dispatch;
	// 825D0EE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D0EE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D0EE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D0EEC: 409A0044  bne cr6, 0x825d0f30
	if !ctx.cr[6].eq {
	pc = 0x825D0F30; continue 'dispatch;
	}
	// 825D0EF0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D0EF4: 419A001C  beq cr6, 0x825d0f10
	if ctx.cr[6].eq {
	pc = 0x825D0F10; continue 'dispatch;
	}
	// 825D0EF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D0EFC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D0F00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D0F04: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D0F08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D0F0C: 4E800421  bctrl
	ctx.lr = 0x825D0F10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D0F10: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D0F14: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825D0F18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D0F1C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825D0F20: 816BB910  lwz r11, -0x46f0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18160 as u32) ) } as u64;
	// 825D0F24: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825D0F28: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D0F2C: 4BCEF0D5  bl 0x822c0000
	ctx.lr = 0x825D0F30;
	sub_822C0000(ctx, base);
	// 825D0F30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D0F34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D0F38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D0F3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D0F40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D0F44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D0F48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D0F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D0F50 size=196
    let mut pc: u32 = 0x825D0F50;
    'dispatch: loop {
        match pc {
            0x825D0F50 => {
    //   block [0x825D0F50..0x825D1014)
	// 825D0F50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D0F54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D0F58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D0F5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D0F60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D0F64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D0F68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D0F6C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825D0F70: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D0F74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D0F78: 4BCEF9C1  bl 0x822c0938
	ctx.lr = 0x825D0F7C;
	sub_822C0938(ctx, base);
	// 825D0F7C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D0F80: 41820028  beq 0x825d0fa8
	if ctx.cr[0].eq {
	pc = 0x825D0FA8; continue 'dispatch;
	}
	// 825D0F84: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D0F88: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825D0F8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D0F90: 392BDE08  addi r9, r11, -0x21f8
	ctx.r[9].s64 = ctx.r[11].s64 + -8696;
	// 825D0F94: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D0F98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D0F9C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D0FA0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825D0FA4: 48000008  b 0x825d0fac
	pc = 0x825D0FAC; continue 'dispatch;
	// 825D0FA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D0FAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D0FB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D0FB4: 409A0044  bne cr6, 0x825d0ff8
	if !ctx.cr[6].eq {
	pc = 0x825D0FF8; continue 'dispatch;
	}
	// 825D0FB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D0FBC: 419A001C  beq cr6, 0x825d0fd8
	if ctx.cr[6].eq {
	pc = 0x825D0FD8; continue 'dispatch;
	}
	// 825D0FC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D0FC4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D0FC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D0FCC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D0FD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D0FD4: 4E800421  bctrl
	ctx.lr = 0x825D0FD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D0FD8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D0FDC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825D0FE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D0FE4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825D0FE8: 816BB910  lwz r11, -0x46f0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18160 as u32) ) } as u64;
	// 825D0FEC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825D0FF0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D0FF4: 4BCEF00D  bl 0x822c0000
	ctx.lr = 0x825D0FF8;
	sub_822C0000(ctx, base);
	// 825D0FF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D0FFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D1000: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D1004: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D1008: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D100C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D1010: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D1018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D1018 size=196
    let mut pc: u32 = 0x825D1018;
    'dispatch: loop {
        match pc {
            0x825D1018 => {
    //   block [0x825D1018..0x825D10DC)
	// 825D1018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D101C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D1020: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D1024: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D1028: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D102C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D1030: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D1034: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825D1038: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D103C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D1040: 4BCEF8F9  bl 0x822c0938
	ctx.lr = 0x825D1044;
	sub_822C0938(ctx, base);
	// 825D1044: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D1048: 41820028  beq 0x825d1070
	if ctx.cr[0].eq {
	pc = 0x825D1070; continue 'dispatch;
	}
	// 825D104C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D1050: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825D1054: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D1058: 392BDE1C  addi r9, r11, -0x21e4
	ctx.r[9].s64 = ctx.r[11].s64 + -8676;
	// 825D105C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D1060: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D1064: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D1068: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825D106C: 48000008  b 0x825d1074
	pc = 0x825D1074; continue 'dispatch;
	// 825D1070: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D1074: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D1078: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D107C: 409A0044  bne cr6, 0x825d10c0
	if !ctx.cr[6].eq {
	pc = 0x825D10C0; continue 'dispatch;
	}
	// 825D1080: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D1084: 419A001C  beq cr6, 0x825d10a0
	if ctx.cr[6].eq {
	pc = 0x825D10A0; continue 'dispatch;
	}
	// 825D1088: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D108C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D1090: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D1094: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D1098: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D109C: 4E800421  bctrl
	ctx.lr = 0x825D10A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D10A0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D10A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825D10A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D10AC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825D10B0: 816BB910  lwz r11, -0x46f0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18160 as u32) ) } as u64;
	// 825D10B4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825D10B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D10BC: 4BCEEF45  bl 0x822c0000
	ctx.lr = 0x825D10C0;
	sub_822C0000(ctx, base);
	// 825D10C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D10C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D10C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D10CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D10D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D10D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D10D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D10E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D10E0 size=72
    let mut pc: u32 = 0x825D10E0;
    'dispatch: loop {
        match pc {
            0x825D10E0 => {
    //   block [0x825D10E0..0x825D1128)
	// 825D10E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D10E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D10E8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D10EC: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825D10F0: 816A7D60  lwz r11, 0x7d60(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32096 as u32) ) } as u64;
	// 825D10F4: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D10F8: 40820018  bne 0x825d1110
	if !ctx.cr[0].eq {
	pc = 0x825D1110; continue 'dispatch;
	}
	// 825D10FC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825D1100: 3D208324  lis r9, -0x7cdc
	ctx.r[9].s64 = -2094792704;
	// 825D1104: 916A7D60  stw r11, 0x7d60(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32096 as u32), ctx.r[11].u32 ) };
	// 825D1108: 3869F798  addi r3, r9, -0x868
	ctx.r[3].s64 = ctx.r[9].s64 + -2152;
	// 825D110C: 48BD73CD  bl 0x831a84d8
	ctx.lr = 0x825D1110;
	sub_831A84D8(ctx, base);
	// 825D1110: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825D1114: 386B7D5C  addi r3, r11, 0x7d5c
	ctx.r[3].s64 = ctx.r[11].s64 + 32092;
	// 825D1118: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D111C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D1120: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D1124: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D1128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D1128 size=60
    let mut pc: u32 = 0x825D1128;
    'dispatch: loop {
        match pc {
            0x825D1128 => {
    //   block [0x825D1128..0x825D1164)
	// 825D1128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D112C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D1130: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D1134: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D1138: 99630041  stb r11, 0x41(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(65 as u32), ctx.r[11].u8 ) };
	// 825D113C: 99630042  stb r11, 0x42(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(66 as u32), ctx.r[11].u8 ) };
	// 825D1140: 99630043  stb r11, 0x43(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(67 as u32), ctx.r[11].u8 ) };
	// 825D1144: 99630044  stb r11, 0x44(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[11].u8 ) };
	// 825D1148: 4BFFFF99  bl 0x825d10e0
	ctx.lr = 0x825D114C;
	sub_825D10E0(ctx, base);
	// 825D114C: 4BFFFF95  bl 0x825d10e0
	ctx.lr = 0x825D1150;
	sub_825D10E0(ctx, base);
	// 825D1150: 4BFFFF91  bl 0x825d10e0
	ctx.lr = 0x825D1154;
	sub_825D10E0(ctx, base);
	// 825D1154: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D1158: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D115C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D1160: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D1168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D1168 size=156
    let mut pc: u32 = 0x825D1168;
    'dispatch: loop {
        match pc {
            0x825D1168 => {
    //   block [0x825D1168..0x825D1204)
	// 825D1168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D116C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D1170: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D1174: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D1178: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D117C: 4BF3FF75  bl 0x825110f0
	ctx.lr = 0x825D1180;
	sub_825110F0(ctx, base);
	// 825D1180: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 825D1184: 4888C74D  bl 0x82e5d8d0
	ctx.lr = 0x825D1188;
	sub_82E5D8D0(ctx, base);
	// 825D1188: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D118C: 387F0124  addi r3, r31, 0x124
	ctx.r[3].s64 = ctx.r[31].s64 + 292;
	// 825D1190: 396BDD88  addi r11, r11, -0x2278
	ctx.r[11].s64 = ctx.r[11].s64 + -8824;
	// 825D1194: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 825D1198: 48840D41  bl 0x82e11ed8
	ctx.lr = 0x825D119C;
	sub_82E11ED8(ctx, base);
	// 825D119C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D11A0: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825D11A4: 396BDE94  addi r11, r11, -0x216c
	ctx.r[11].s64 = ctx.r[11].s64 + -8556;
	// 825D11A8: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825D11AC: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825D11B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D11B4: 394ADE80  addi r10, r10, -0x2180
	ctx.r[10].s64 = ctx.r[10].s64 + -8576;
	// 825D11B8: 3929DE70  addi r9, r9, -0x2190
	ctx.r[9].s64 = ctx.r[9].s64 + -8592;
	// 825D11BC: 3908DE60  addi r8, r8, -0x21a0
	ctx.r[8].s64 = ctx.r[8].s64 + -8608;
	// 825D11C0: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825D11C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D11C8: 913F00C0  stw r9, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[9].u32 ) };
	// 825D11CC: 911F0124  stw r8, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[8].u32 ) };
	// 825D11D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D11D4: 917F012C  stw r11, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[11].u32 ) };
	// 825D11D8: 917F0130  stw r11, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 825D11DC: 917F0134  stw r11, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[11].u32 ) };
	// 825D11E0: 917F0138  stw r11, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[11].u32 ) };
	// 825D11E4: 917F013C  stw r11, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[11].u32 ) };
	// 825D11E8: 917F0140  stw r11, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 825D11EC: 917F0144  stw r11, 0x144(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), ctx.r[11].u32 ) };
	// 825D11F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D11F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D11F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D11FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D1200: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D1208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D1208 size=8
    let mut pc: u32 = 0x825D1208;
    'dispatch: loop {
        match pc {
            0x825D1208 => {
    //   block [0x825D1208..0x825D1210)
	// 825D1208: 3863FF40  addi r3, r3, -0xc0
	ctx.r[3].s64 = ctx.r[3].s64 + -192;
	// 825D120C: 480002B4  b 0x825d14c0
	sub_825D14C0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D1210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D1210 size=8
    let mut pc: u32 = 0x825D1210;
    'dispatch: loop {
        match pc {
            0x825D1210 => {
    //   block [0x825D1210..0x825D1218)
	// 825D1210: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 825D1214: 480002AC  b 0x825d14c0
	sub_825D14C0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D1218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D1218 size=8
    let mut pc: u32 = 0x825D1218;
    'dispatch: loop {
        match pc {
            0x825D1218 => {
    //   block [0x825D1218..0x825D1220)
	// 825D1218: 3863FEDC  addi r3, r3, -0x124
	ctx.r[3].s64 = ctx.r[3].s64 + -292;
	// 825D121C: 480002A4  b 0x825d14c0
	sub_825D14C0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D1220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D1220 size=172
    let mut pc: u32 = 0x825D1220;
    'dispatch: loop {
        match pc {
            0x825D1220 => {
    //   block [0x825D1220..0x825D12CC)
	// 825D1220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D1224: 48BD6F45  bl 0x831a8168
	ctx.lr = 0x825D1228;
	sub_831A8130(ctx, base);
	// 825D1228: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D122C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D1230: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D1234: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825D1238: 396BDE94  addi r11, r11, -0x216c
	ctx.r[11].s64 = ctx.r[11].s64 + -8556;
	// 825D123C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825D1240: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825D1244: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D1248: 394ADE80  addi r10, r10, -0x2180
	ctx.r[10].s64 = ctx.r[10].s64 + -8576;
	// 825D124C: 3929DE70  addi r9, r9, -0x2190
	ctx.r[9].s64 = ctx.r[9].s64 + -8592;
	// 825D1250: 3968DE60  addi r11, r8, -0x21a0
	ctx.r[11].s64 = ctx.r[8].s64 + -8608;
	// 825D1254: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825D1258: 913F00C0  stw r9, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[9].u32 ) };
	// 825D125C: 3BBF00C0  addi r29, r31, 0xc0
	ctx.r[29].s64 = ctx.r[31].s64 + 192;
	// 825D1260: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 825D1264: 3B9F0124  addi r28, r31, 0x124
	ctx.r[28].s64 = ctx.r[31].s64 + 292;
	// 825D1268: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 825D126C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D1270: 419A0008  beq cr6, 0x825d1278
	if ctx.cr[6].eq {
	pc = 0x825D1278; continue 'dispatch;
	}
	// 825D1274: 4BCEF61D  bl 0x822c0890
	ctx.lr = 0x825D1278;
	sub_822C0890(ctx, base);
	// 825D1278: 83DF0138  lwz r30, 0x138(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 825D127C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825D1280: 419A0014  beq cr6, 0x825d1294
	if ctx.cr[6].eq {
	pc = 0x825D1294; continue 'dispatch;
	}
	// 825D1284: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D1288: 488221A1  bl 0x82df3428
	ctx.lr = 0x825D128C;
	sub_82DF3428(ctx, base);
	// 825D128C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D1290: 48821149  bl 0x82df23d8
	ctx.lr = 0x825D1294;
	sub_82DF23D8(ctx, base);
	// 825D1294: 807F0134  lwz r3, 0x134(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 825D1298: 4BCEEFD1  bl 0x822c0268
	ctx.lr = 0x825D129C;
	sub_822C0268(ctx, base);
	// 825D129C: 807F0130  lwz r3, 0x130(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 825D12A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D12A4: 419A0008  beq cr6, 0x825d12ac
	if ctx.cr[6].eq {
	pc = 0x825D12AC; continue 'dispatch;
	}
	// 825D12A8: 4BCEF5E9  bl 0x822c0890
	ctx.lr = 0x825D12AC;
	sub_822C0890(ctx, base);
	// 825D12AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825D12B0: 48840C41  bl 0x82e11ef0
	ctx.lr = 0x825D12B4;
	sub_82E11EF0(ctx, base);
	// 825D12B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D12B8: 4888C591  bl 0x82e5d848
	ctx.lr = 0x825D12BC;
	sub_82E5D848(ctx, base);
	// 825D12BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D12C0: 4BF3FED9  bl 0x82511198
	ctx.lr = 0x825D12C4;
	sub_82511198(ctx, base);
	// 825D12C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825D12C8: 48BD6EF0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D12D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D12D0 size=112
    let mut pc: u32 = 0x825D12D0;
    'dispatch: loop {
        match pc {
            0x825D12D0 => {
    //   block [0x825D12D0..0x825D1340)
	// 825D12D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D12D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D12D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D12DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D12E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D12E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D12E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D12EC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825D12F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D12F4: 4BFFFAE5  bl 0x825d0dd8
	ctx.lr = 0x825D12F8;
	sub_825D0DD8(ctx, base);
	// 825D12F8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825D12FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D1300: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D1304: 4BCEECFD  bl 0x822c0000
	ctx.lr = 0x825D1308;
	sub_822C0000(ctx, base);
	// 825D1308: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D130C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D1310: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D1314: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D1318: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D131C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D1320: 419A0008  beq cr6, 0x825d1328
	if ctx.cr[6].eq {
	pc = 0x825D1328; continue 'dispatch;
	}
	// 825D1324: 4BCEF56D  bl 0x822c0890
	ctx.lr = 0x825D1328;
	sub_822C0890(ctx, base);
	// 825D1328: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D132C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D1330: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D1334: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D1338: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D133C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D1340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D1340 size=124
    let mut pc: u32 = 0x825D1340;
    'dispatch: loop {
        match pc {
            0x825D1340 => {
    //   block [0x825D1340..0x825D13BC)
	// 825D1340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D1344: 48BD6E29  bl 0x831a816c
	ctx.lr = 0x825D1348;
	sub_831A8130(ctx, base);
	// 825D1348: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D134C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825D1350: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825D1354: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D1358: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825D135C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 825D1360: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 825D1364: 48821085  bl 0x82df23e8
	ctx.lr = 0x825D1368;
	sub_82DF23E8(ctx, base);
	// 825D1368: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D136C: 4182001C  beq 0x825d1388
	if ctx.cr[0].eq {
	pc = 0x825D1388; continue 'dispatch;
	}
	// 825D1370: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D1374: 4888830D  bl 0x82e59680
	ctx.lr = 0x825D1378;
	sub_82E59680(ctx, base);
	// 825D1378: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D137C: 396BDDB0  addi r11, r11, -0x2250
	ctx.r[11].s64 = ctx.r[11].s64 + -8784;
	// 825D1380: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D1384: 48000008  b 0x825d138c
	pc = 0x825D138C; continue 'dispatch;
	// 825D1388: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D138C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D1390: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825D1394: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D1398: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D139C: 4BFFFAED  bl 0x825d0e88
	ctx.lr = 0x825D13A0;
	sub_825D0E88(ctx, base);
	// 825D13A0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D13A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D13A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D13AC: 4BCEEC55  bl 0x822c0000
	ctx.lr = 0x825D13B0;
	sub_822C0000(ctx, base);
	// 825D13B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D13B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D13B8: 48BD6E04  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D13C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D13C0 size=124
    let mut pc: u32 = 0x825D13C0;
    'dispatch: loop {
        match pc {
            0x825D13C0 => {
    //   block [0x825D13C0..0x825D143C)
	// 825D13C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D13C4: 48BD6DA9  bl 0x831a816c
	ctx.lr = 0x825D13C8;
	sub_831A8130(ctx, base);
	// 825D13C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D13CC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825D13D0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825D13D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D13D8: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 825D13DC: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 825D13E0: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 825D13E4: 48821005  bl 0x82df23e8
	ctx.lr = 0x825D13E8;
	sub_82DF23E8(ctx, base);
	// 825D13E8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D13EC: 4182001C  beq 0x825d1408
	if ctx.cr[0].eq {
	pc = 0x825D1408; continue 'dispatch;
	}
	// 825D13F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D13F4: 4888B535  bl 0x82e5c928
	ctx.lr = 0x825D13F8;
	sub_82E5C928(ctx, base);
	// 825D13F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D13FC: 396BDDB8  addi r11, r11, -0x2248
	ctx.r[11].s64 = ctx.r[11].s64 + -8776;
	// 825D1400: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D1404: 48000008  b 0x825d140c
	pc = 0x825D140C; continue 'dispatch;
	// 825D1408: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D140C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D1410: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825D1414: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D1418: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D141C: 4BFFFB35  bl 0x825d0f50
	ctx.lr = 0x825D1420;
	sub_825D0F50(ctx, base);
	// 825D1420: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D1424: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D1428: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D142C: 4BCEEBD5  bl 0x822c0000
	ctx.lr = 0x825D1430;
	sub_822C0000(ctx, base);
	// 825D1430: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D1434: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D1438: 48BD6D84  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D1440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D1440 size=124
    let mut pc: u32 = 0x825D1440;
    'dispatch: loop {
        match pc {
            0x825D1440 => {
    //   block [0x825D1440..0x825D14BC)
	// 825D1440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D1444: 48BD6D29  bl 0x831a816c
	ctx.lr = 0x825D1448;
	sub_831A8130(ctx, base);
	// 825D1448: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D144C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825D1450: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825D1454: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D1458: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 825D145C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 825D1460: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 825D1464: 48820F85  bl 0x82df23e8
	ctx.lr = 0x825D1468;
	sub_82DF23E8(ctx, base);
	// 825D1468: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D146C: 4182001C  beq 0x825d1488
	if ctx.cr[0].eq {
	pc = 0x825D1488; continue 'dispatch;
	}
	// 825D1470: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D1474: 4888B4B5  bl 0x82e5c928
	ctx.lr = 0x825D1478;
	sub_82E5C928(ctx, base);
	// 825D1478: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D147C: 396BDE30  addi r11, r11, -0x21d0
	ctx.r[11].s64 = ctx.r[11].s64 + -8656;
	// 825D1480: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D1484: 48000008  b 0x825d148c
	pc = 0x825D148C; continue 'dispatch;
	// 825D1488: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D148C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D1490: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825D1494: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D1498: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D149C: 4BFFFB7D  bl 0x825d1018
	ctx.lr = 0x825D14A0;
	sub_825D1018(ctx, base);
	// 825D14A0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D14A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D14A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D14AC: 4BCEEB55  bl 0x822c0000
	ctx.lr = 0x825D14B0;
	sub_822C0000(ctx, base);
	// 825D14B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D14B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D14B8: 48BD6D04  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D14C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D14C0 size=76
    let mut pc: u32 = 0x825D14C0;
    'dispatch: loop {
        match pc {
            0x825D14C0 => {
    //   block [0x825D14C0..0x825D150C)
	// 825D14C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D14C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D14C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D14CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D14D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D14D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D14D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D14DC: 4BFFFD45  bl 0x825d1220
	ctx.lr = 0x825D14E0;
	sub_825D1220(ctx, base);
	// 825D14E0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D14E4: 4182000C  beq 0x825d14f0
	if ctx.cr[0].eq {
	pc = 0x825D14F0; continue 'dispatch;
	}
	// 825D14E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D14EC: 48820EED  bl 0x82df23d8
	ctx.lr = 0x825D14F0;
	sub_82DF23D8(ctx, base);
	// 825D14F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D14F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D14F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D14FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D1500: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D1504: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D1508: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D1510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D1510 size=220
    let mut pc: u32 = 0x825D1510;
    'dispatch: loop {
        match pc {
            0x825D1510 => {
    //   block [0x825D1510..0x825D15EC)
	// 825D1510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D1514: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D1518: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D151C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D1520: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D1524: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D1528: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D152C: 4BFFFE15  bl 0x825d1340
	ctx.lr = 0x825D1530;
	sub_825D1340(ctx, base);
	// 825D1530: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1534: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825D1538: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D153C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D1540: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D1544: 419A0024  beq cr6, 0x825d1568
	if ctx.cr[6].eq {
	pc = 0x825D1568; continue 'dispatch;
	}
	// 825D1548: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D154C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D1550: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D1554: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D1558: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D155C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D1560: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D1564: 4082FFE8  bne 0x825d154c
	if !ctx.cr[0].eq {
	pc = 0x825D154C; continue 'dispatch;
	}
	// 825D1568: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D156C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D1570: 4BF3DDC1  bl 0x8250f330
	ctx.lr = 0x825D1574;
	sub_8250F330(ctx, base);
	// 825D1574: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1578: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825D157C: 4BF182E5  bl 0x824e9860
	ctx.lr = 0x825D1580;
	sub_824E9860(ctx, base);
	// 825D1580: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D1584: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825D1588: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825D158C: 388ADEC0  addi r4, r10, -0x2140
	ctx.r[4].s64 = ctx.r[10].s64 + -8512;
	// 825D1590: 38A003DE  li r5, 0x3de
	ctx.r[5].s64 = 990;
	// 825D1594: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825D1598: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825D159C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 825D15A0: 488874A1  bl 0x82e58a40
	ctx.lr = 0x825D15A4;
	sub_82E58A40(ctx, base);
	// 825D15A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D15A8: 488206E9  bl 0x82df1c90
	ctx.lr = 0x825D15AC;
	sub_82DF1C90(ctx, base);
	// 825D15AC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D15B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D15B4: 419A0008  beq cr6, 0x825d15bc
	if ctx.cr[6].eq {
	pc = 0x825D15BC; continue 'dispatch;
	}
	// 825D15B8: 4BCEF2D9  bl 0x822c0890
	ctx.lr = 0x825D15BC;
	sub_822C0890(ctx, base);
	// 825D15BC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D15C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D15C4: 419A0008  beq cr6, 0x825d15cc
	if ctx.cr[6].eq {
	pc = 0x825D15CC; continue 'dispatch;
	}
	// 825D15C8: 4BCEF2C9  bl 0x822c0890
	ctx.lr = 0x825D15CC;
	sub_822C0890(ctx, base);
	// 825D15CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D15D0: 4BF3F001  bl 0x825105d0
	ctx.lr = 0x825D15D4;
	sub_825105D0(ctx, base);
	// 825D15D4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825D15D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D15DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D15E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D15E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D15E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D15F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D15F0 size=160
    let mut pc: u32 = 0x825D15F0;
    'dispatch: loop {
        match pc {
            0x825D15F0 => {
    //   block [0x825D15F0..0x825D1690)
	// 825D15F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D15F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D15F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D15FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D1600: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D1604: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D1608: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D160C: 48AF64D5  bl 0x830c7ae0
	ctx.lr = 0x825D1610;
	sub_830C7AE0(ctx, base);
	// 825D1610: 387F00C0  addi r3, r31, 0xc0
	ctx.r[3].s64 = ctx.r[31].s64 + 192;
	// 825D1614: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D1618: 4888BA79  bl 0x82e5d090
	ctx.lr = 0x825D161C;
	sub_82E5D090(ctx, base);
	// 825D161C: 807F0134  lwz r3, 0x134(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 825D1620: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825D1624: 4BFE0545  bl 0x825b1b68
	ctx.lr = 0x825D1628;
	sub_825B1B68(ctx, base);
	// 825D1628: 4BFFFAB9  bl 0x825d10e0
	ctx.lr = 0x825D162C;
	sub_825D10E0(ctx, base);
	// 825D162C: 807F0134  lwz r3, 0x134(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 825D1630: 4BFE04B1  bl 0x825b1ae0
	ctx.lr = 0x825D1634;
	sub_825B1AE0(ctx, base);
	// 825D1634: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D1638: 41820010  beq 0x825d1648
	if ctx.cr[0].eq {
	pc = 0x825D1648; continue 'dispatch;
	}
	// 825D163C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D1640: 4BFFFED1  bl 0x825d1510
	ctx.lr = 0x825D1644;
	sub_825D1510(ctx, base);
	// 825D1644: 48000034  b 0x825d1678
	pc = 0x825D1678; continue 'dispatch;
	// 825D1648: 807F013C  lwz r3, 0x13c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 825D164C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D1650: 419A0028  beq cr6, 0x825d1678
	if ctx.cr[6].eq {
	pc = 0x825D1678; continue 'dispatch;
	}
	// 825D1654: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1658: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D165C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D1660: 4E800421  bctrl
	ctx.lr = 0x825D1664;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D1664: 807F013C  lwz r3, 0x13c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 825D1668: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D166C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D1670: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D1674: 4E800421  bctrl
	ctx.lr = 0x825D1678;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D1678: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D167C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D1680: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D1684: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D1688: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D168C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D1690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D1690 size=92
    let mut pc: u32 = 0x825D1690;
    'dispatch: loop {
        match pc {
            0x825D1690 => {
    //   block [0x825D1690..0x825D16EC)
	// 825D1690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D1694: 48BD6AD9  bl 0x831a816c
	ctx.lr = 0x825D1698;
	sub_831A8130(ctx, base);
	// 825D1698: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D169C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D16A0: 3D40825D  lis r10, -0x7da3
	ctx.r[10].s64 = -2107834368;
	// 825D16A4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825D16A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D16AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D16B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D16B4: 388A13C0  addi r4, r10, 0x13c0
	ctx.r[4].s64 = ctx.r[10].s64 + 5056;
	// 825D16B8: 4BD8E3B9  bl 0x8235fa70
	ctx.lr = 0x825D16BC;
	sub_8235FA70(ctx, base);
	// 825D16BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D16C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D16C4: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 825D16C8: 48822539  bl 0x82df3c00
	ctx.lr = 0x825D16CC;
	sub_82DF3C00(ctx, base);
	// 825D16CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D16D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D16D4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825D16D8: 4888AA81  bl 0x82e5c158
	ctx.lr = 0x825D16DC;
	sub_82E5C158(ctx, base);
	// 825D16DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D16E0: 48821D49  bl 0x82df3428
	ctx.lr = 0x825D16E4;
	sub_82DF3428(ctx, base);
	// 825D16E4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825D16E8: 48BD6AD4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D16F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D16F0 size=92
    let mut pc: u32 = 0x825D16F0;
    'dispatch: loop {
        match pc {
            0x825D16F0 => {
    //   block [0x825D16F0..0x825D174C)
	// 825D16F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D16F4: 48BD6A79  bl 0x831a816c
	ctx.lr = 0x825D16F8;
	sub_831A8130(ctx, base);
	// 825D16F8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D16FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D1700: 3D40825D  lis r10, -0x7da3
	ctx.r[10].s64 = -2107834368;
	// 825D1704: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825D1708: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D170C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D1710: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D1714: 388A1440  addi r4, r10, 0x1440
	ctx.r[4].s64 = ctx.r[10].s64 + 5184;
	// 825D1718: 4BD8E359  bl 0x8235fa70
	ctx.lr = 0x825D171C;
	sub_8235FA70(ctx, base);
	// 825D171C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D1720: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D1724: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 825D1728: 488224D9  bl 0x82df3c00
	ctx.lr = 0x825D172C;
	sub_82DF3C00(ctx, base);
	// 825D172C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D1730: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D1734: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825D1738: 4888AA21  bl 0x82e5c158
	ctx.lr = 0x825D173C;
	sub_82E5C158(ctx, base);
	// 825D173C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D1740: 48821CE9  bl 0x82df3428
	ctx.lr = 0x825D1744;
	sub_82DF3428(ctx, base);
	// 825D1744: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825D1748: 48BD6A74  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D1750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D1750 size=596
    let mut pc: u32 = 0x825D1750;
    'dispatch: loop {
        match pc {
            0x825D1750 => {
    //   block [0x825D1750..0x825D19A4)
	// 825D1750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D1754: 48BD6A11  bl 0x831a8164
	ctx.lr = 0x825D1758;
	sub_831A8130(ctx, base);
	// 825D1758: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 825D175C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D1760: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825D1764: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D1768: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D176C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825D1770: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825D1774: 808BE268  lwz r4, -0x1d98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7576 as u32) ) } as u64;
	// 825D1778: 48822291  bl 0x82df3a08
	ctx.lr = 0x825D177C;
	sub_82DF3A08(ctx, base);
	// 825D177C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D1780: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D1784: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D1788: 4BF36FF9  bl 0x82508780
	ctx.lr = 0x825D178C;
	sub_82508780(ctx, base);
	// 825D178C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D1790: 48821C99  bl 0x82df3428
	ctx.lr = 0x825D1794;
	sub_82DF3428(ctx, base);
	// 825D1794: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825D1798: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D179C: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 825D17A0: 409A0008  bne cr6, 0x825d17a8
	if !ctx.cr[6].eq {
	pc = 0x825D17A8; continue 'dispatch;
	}
	// 825D17A4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825D17A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D17AC: 4BF36FF5  bl 0x825087a0
	ctx.lr = 0x825D17B0;
	sub_825087A0(ctx, base);
	// 825D17B0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D17B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D17B8: 3B8BDEC0  addi r28, r11, -0x2140
	ctx.r[28].s64 = ctx.r[11].s64 + -8512;
	// 825D17BC: 38A0039F  li r5, 0x39f
	ctx.r[5].s64 = 927;
	// 825D17C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825D17C4: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 825D17C8: 4BCEEC11  bl 0x822c03d8
	ctx.lr = 0x825D17CC;
	sub_822C03D8(ctx, base);
	// 825D17CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D17D0: 41820014  beq 0x825d17e4
	if ctx.cr[0].eq {
	pc = 0x825D17E4; continue 'dispatch;
	}
	// 825D17D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D17D8: 4BEBF919  bl 0x824910f0
	ctx.lr = 0x825D17DC;
	sub_824910F0(ctx, base);
	// 825D17DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D17E0: 48000008  b 0x825d17e8
	pc = 0x825D17E8; continue 'dispatch;
	// 825D17E4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825D17E8: 387F012C  addi r3, r31, 0x12c
	ctx.r[3].s64 = ctx.r[31].s64 + 300;
	// 825D17EC: 4BD38EF5  bl 0x8230a6e0
	ctx.lr = 0x825D17F0;
	sub_8230A6E0(ctx, base);
	// 825D17F0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825D17F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D17F8: 38A003A1  li r5, 0x3a1
	ctx.r[5].s64 = 929;
	// 825D17FC: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 825D1800: 4BCEEBD9  bl 0x822c03d8
	ctx.lr = 0x825D1804;
	sub_822C03D8(ctx, base);
	// 825D1804: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D1808: 41820010  beq 0x825d1818
	if ctx.cr[0].eq {
	pc = 0x825D1818; continue 'dispatch;
	}
	// 825D180C: 4BFE026D  bl 0x825b1a78
	ctx.lr = 0x825D1810;
	sub_825B1A78(ctx, base);
	// 825D1810: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D1814: 48000008  b 0x825d181c
	pc = 0x825D181C; continue 'dispatch;
	// 825D1818: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 825D181C: 807F0134  lwz r3, 0x134(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 825D1820: 917F0134  stw r11, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[11].u32 ) };
	// 825D1824: 4BCEEA45  bl 0x822c0268
	ctx.lr = 0x825D1828;
	sub_822C0268(ctx, base);
	// 825D1828: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825D182C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D1830: 38A003A5  li r5, 0x3a5
	ctx.r[5].s64 = 933;
	// 825D1834: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 825D1838: 48820BB1  bl 0x82df23e8
	ctx.lr = 0x825D183C;
	sub_82DF23E8(ctx, base);
	// 825D183C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825D1840: 41820010  beq 0x825d1850
	if ctx.cr[0].eq {
	pc = 0x825D1850; continue 'dispatch;
	}
	// 825D1844: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D1848: 488218A9  bl 0x82df30f0
	ctx.lr = 0x825D184C;
	sub_82DF30F0(ctx, base);
	// 825D184C: 48000008  b 0x825d1854
	pc = 0x825D1854; continue 'dispatch;
	// 825D1850: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 825D1854: 83BF0138  lwz r29, 0x138(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 825D1858: 93DF0138  stw r30, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[30].u32 ) };
	// 825D185C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825D1860: 419A0014  beq cr6, 0x825d1874
	if ctx.cr[6].eq {
	pc = 0x825D1874; continue 'dispatch;
	}
	// 825D1864: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D1868: 48821BC1  bl 0x82df3428
	ctx.lr = 0x825D186C;
	sub_82DF3428(ctx, base);
	// 825D186C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D1870: 48820B69  bl 0x82df23d8
	ctx.lr = 0x825D1874;
	sub_82DF23D8(ctx, base);
	// 825D1874: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825D1878: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D187C: 38A003A9  li r5, 0x3a9
	ctx.r[5].s64 = 937;
	// 825D1880: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 825D1884: 48820B65  bl 0x82df23e8
	ctx.lr = 0x825D1888;
	sub_82DF23E8(ctx, base);
	// 825D1888: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D188C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D1890: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825D1894: 41820068  beq 0x825d18fc
	if ctx.cr[0].eq {
	pc = 0x825D18FC; continue 'dispatch;
	}
	// 825D1898: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825D189C: 93E30010  stw r31, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 825D18A0: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825D18A4: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 825D18A8: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 825D18AC: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 825D18B0: 394ADD98  addi r10, r10, -0x2268
	ctx.r[10].s64 = ctx.r[10].s64 + -8808;
	// 825D18B4: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 825D18B8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825D18BC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D19A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D19A8 size=196
    let mut pc: u32 = 0x825D19A8;
    'dispatch: loop {
        match pc {
            0x825D19A8 => {
    //   block [0x825D19A8..0x825D1A6C)
	// 825D19A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D19AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D19B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D19B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D19B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D19BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D19C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D19C4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825D19C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D19CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D19D0: 4BCEEF69  bl 0x822c0938
	ctx.lr = 0x825D19D4;
	sub_822C0938(ctx, base);
	// 825D19D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D19D8: 41820028  beq 0x825d1a00
	if ctx.cr[0].eq {
	pc = 0x825D1A00; continue 'dispatch;
	}
	// 825D19DC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D19E0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825D19E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D19E8: 392BDF18  addi r9, r11, -0x20e8
	ctx.r[9].s64 = ctx.r[11].s64 + -8424;
	// 825D19EC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D19F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D19F4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D19F8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825D19FC: 48000008  b 0x825d1a04
	pc = 0x825D1A04; continue 'dispatch;
	// 825D1A00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D1A04: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D1A08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D1A0C: 409A0044  bne cr6, 0x825d1a50
	if !ctx.cr[6].eq {
	pc = 0x825D1A50; continue 'dispatch;
	}
	// 825D1A10: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D1A14: 419A001C  beq cr6, 0x825d1a30
	if ctx.cr[6].eq {
	pc = 0x825D1A30; continue 'dispatch;
	}
	// 825D1A18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1A1C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D1A20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D1A24: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1A28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D1A2C: 4E800421  bctrl
	ctx.lr = 0x825D1A30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D1A30: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D1A34: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825D1A38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D1A3C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825D1A40: 816BBC20  lwz r11, -0x43e0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17376 as u32) ) } as u64;
	// 825D1A44: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825D1A48: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D1A4C: 4BCEE5B5  bl 0x822c0000
	ctx.lr = 0x825D1A50;
	sub_822C0000(ctx, base);
	// 825D1A50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D1A54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D1A58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D1A5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D1A60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D1A64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D1A68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D1A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D1A70 size=112
    let mut pc: u32 = 0x825D1A70;
    'dispatch: loop {
        match pc {
            0x825D1A70 => {
    //   block [0x825D1A70..0x825D1AE0)
	// 825D1A70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D1A74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D1A78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D1A7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D1A80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D1A84: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D1A88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D1A8C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825D1A90: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D1A94: 4BE9354D  bl 0x82464fe0
	ctx.lr = 0x825D1A98;
	sub_82464FE0(ctx, base);
	// 825D1A98: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825D1A9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D1AA0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D1AA4: 4BCEE55D  bl 0x822c0000
	ctx.lr = 0x825D1AA8;
	sub_822C0000(ctx, base);
	// 825D1AA8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D1AAC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D1AB0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D1AB4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D1AB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D1ABC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D1AC0: 419A0008  beq cr6, 0x825d1ac8
	if ctx.cr[6].eq {
	pc = 0x825D1AC8; continue 'dispatch;
	}
	// 825D1AC4: 4BCEEDCD  bl 0x822c0890
	ctx.lr = 0x825D1AC8;
	sub_822C0890(ctx, base);
	// 825D1AC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D1ACC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D1AD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D1AD4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D1AD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D1ADC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D1AE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D1AE0 size=124
    let mut pc: u32 = 0x825D1AE0;
    'dispatch: loop {
        match pc {
            0x825D1AE0 => {
    //   block [0x825D1AE0..0x825D1B5C)
	// 825D1AE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D1AE4: 48BD6689  bl 0x831a816c
	ctx.lr = 0x825D1AE8;
	sub_831A8130(ctx, base);
	// 825D1AE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D1AEC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825D1AF0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825D1AF4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D1AF8: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825D1AFC: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 825D1B00: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 825D1B04: 488208E5  bl 0x82df23e8
	ctx.lr = 0x825D1B08;
	sub_82DF23E8(ctx, base);
	// 825D1B08: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825D1B0C: 4182001C  beq 0x825d1b28
	if ctx.cr[0].eq {
	pc = 0x825D1B28; continue 'dispatch;
	}
	// 825D1B10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D1B14: 48887B6D  bl 0x82e59680
	ctx.lr = 0x825D1B18;
	sub_82E59680(ctx, base);
	// 825D1B18: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D1B1C: 396BDF10  addi r11, r11, -0x20f0
	ctx.r[11].s64 = ctx.r[11].s64 + -8432;
	// 825D1B20: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D1B24: 48000008  b 0x825d1b2c
	pc = 0x825D1B2C; continue 'dispatch;
	// 825D1B28: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825D1B2C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D1B30: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825D1B34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D1B38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D1B3C: 4BFFFE6D  bl 0x825d19a8
	ctx.lr = 0x825D1B40;
	sub_825D19A8(ctx, base);
	// 825D1B40: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825D1B44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D1B48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D1B4C: 4BCEE4B5  bl 0x822c0000
	ctx.lr = 0x825D1B50;
	sub_822C0000(ctx, base);
	// 825D1B50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D1B54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D1B58: 48BD6664  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D1B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D1B60 size=736
    let mut pc: u32 = 0x825D1B60;
    'dispatch: loop {
        match pc {
            0x825D1B60 => {
    //   block [0x825D1B60..0x825D1E40)
	// 825D1B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D1B64: 48BD6605  bl 0x831a8168
	ctx.lr = 0x825D1B68;
	sub_831A8130(ctx, base);
	// 825D1B68: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825D1B6C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D1B70: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D1B74: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825D1B78: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825D1B7C: 389E0028  addi r4, r30, 0x28
	ctx.r[4].s64 = ctx.r[30].s64 + 40;
	// 825D1B80: 409A0008  bne cr6, 0x825d1b88
	if !ctx.cr[6].eq {
	pc = 0x825D1B88; continue 'dispatch;
	}
	// 825D1B84: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D1B88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D1B8C: 4BF36C15  bl 0x825087a0
	ctx.lr = 0x825D1B90;
	sub_825087A0(ctx, base);
	// 825D1B90: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825D1B94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D1B98: 808BE254  lwz r4, -0x1dac(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7596 as u32) ) } as u64;
	// 825D1B9C: 48821E6D  bl 0x82df3a08
	ctx.lr = 0x825D1BA0;
	sub_82DF3A08(ctx, base);
	// 825D1BA0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825D1BA4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825D1BA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D1BAC: 4BF36BD5  bl 0x82508780
	ctx.lr = 0x825D1BB0;
	sub_82508780(ctx, base);
	// 825D1BB0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D1BB4: 48821875  bl 0x82df3428
	ctx.lr = 0x825D1BB8;
	sub_82DF3428(ctx, base);
	// 825D1BB8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D1BBC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D1BC0: 3BABDF28  addi r29, r11, -0x20d8
	ctx.r[29].s64 = ctx.r[11].s64 + -8408;
	// 825D1BC4: 38A0001A  li r5, 0x1a
	ctx.r[5].s64 = 26;
	// 825D1BC8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D1BCC: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 825D1BD0: 48820819  bl 0x82df23e8
	ctx.lr = 0x825D1BD4;
	sub_82DF23E8(ctx, base);
	// 825D1BD4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D1BD8: 41820010  beq 0x825d1be8
	if ctx.cr[0].eq {
	pc = 0x825D1BE8; continue 'dispatch;
	}
	// 825D1BDC: 4BE9DDB5  bl 0x8246f990
	ctx.lr = 0x825D1BE0;
	sub_8246F990(ctx, base);
	// 825D1BE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D1BE4: 48000008  b 0x825d1bec
	pc = 0x825D1BEC; continue 'dispatch;
	// 825D1BE8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D1BEC: 3BFE00C0  addi r31, r30, 0xc0
	ctx.r[31].s64 = ctx.r[30].s64 + 192;
	// 825D1BF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D1BF4: 4BFFFE7D  bl 0x825d1a70
	ctx.lr = 0x825D1BF8;
	sub_825D1A70(ctx, base);
	// 825D1BF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D1BFC: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 825D1C00: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825D1C04: 614AC350  ori r10, r10, 0xc350
	ctx.r[10].u64 = ctx.r[10].u64 | 50000;
	// 825D1C08: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825D1C0C: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825D1C10: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825D1C14: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825D1C18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D1C1C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D1C20: 48097B39  bl 0x82669758
	ctx.lr = 0x825D1C24;
	sub_82669758(ctx, base);
	// 825D1C24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1C28: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825D1C2C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D1C30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D1C34: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825D1C38: 419A0024  beq cr6, 0x825d1c5c
	if ctx.cr[6].eq {
	pc = 0x825D1C5C; continue 'dispatch;
	}
	// 825D1C3C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D1C40: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D1C44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D1C48: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D1C4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D1C50: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D1C54: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D1C58: 4082FFE8  bne 0x825d1c40
	if !ctx.cr[0].eq {
	pc = 0x825D1C40; continue 'dispatch;
	}
	// 825D1C5C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D1C60: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825D1C64: 4BF3D8B5  bl 0x8250f518
	ctx.lr = 0x825D1C68;
	sub_8250F518(ctx, base);
	// 825D1C68: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1C6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D1C70: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 825D1C74: 409A0008  bne cr6, 0x825d1c7c
	if !ctx.cr[6].eq {
	pc = 0x825D1C7C; continue 'dispatch;
	}
	// 825D1C78: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825D1C7C: 3BFE0028  addi r31, r30, 0x28
	ctx.r[31].s64 = ctx.r[30].s64 + 40;
	// 825D1C80: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 825D1C84: 4BF563CD  bl 0x82528050
	ctx.lr = 0x825D1C88;
	sub_82528050(ctx, base);
	// 825D1C88: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825D1C8C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825D1C90: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D1C94: 38A0001B  li r5, 0x1b
	ctx.r[5].s64 = 27;
	// 825D1C98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D1C9C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 825D1CA0: 48886DA1  bl 0x82e58a40
	ctx.lr = 0x825D1CA4;
	sub_82E58A40(ctx, base);
	// 825D1CA4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825D1CA8: 4881FFE9  bl 0x82df1c90
	ctx.lr = 0x825D1CAC;
	sub_82DF1C90(ctx, base);
	// 825D1CAC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D1CB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D1CB4: 419A0008  beq cr6, 0x825d1cbc
	if ctx.cr[6].eq {
	pc = 0x825D1CBC; continue 'dispatch;
	}
	// 825D1CB8: 4BCEEBD9  bl 0x822c0890
	ctx.lr = 0x825D1CBC;
	sub_822C0890(ctx, base);
	// 825D1CBC: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825D1CC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D1CC4: 419A0008  beq cr6, 0x825d1ccc
	if ctx.cr[6].eq {
	pc = 0x825D1CCC; continue 'dispatch;
	}
	// 825D1CC8: 4BCEEBC9  bl 0x822c0890
	ctx.lr = 0x825D1CCC;
	sub_822C0890(ctx, base);
	// 825D1CCC: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 825D1CD0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825D1CD4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825D1CD8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825D1CDC: 4BD37815  bl 0x823094f0
	ctx.lr = 0x825D1CE0;
	sub_823094F0(ctx, base);
	// 825D1CE0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1CE4: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825D1CE8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D1CEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D1CF0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825D1CF4: 419A0024  beq cr6, 0x825d1d18
	if ctx.cr[6].eq {
	pc = 0x825D1D18; continue 'dispatch;
	}
	// 825D1CF8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D1CFC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D1D00: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D1D04: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D1D08: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D1D0C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D1D10: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D1D14: 4082FFE8  bne 0x825d1cfc
	if !ctx.cr[0].eq {
	pc = 0x825D1CFC; continue 'dispatch;
	}
	// 825D1D18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D1D1C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825D1D20: 4BF3D611  bl 0x8250f330
	ctx.lr = 0x825D1D24;
	sub_8250F330(ctx, base);
	// 825D1D24: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1D28: 3B810068  addi r28, r1, 0x68
	ctx.r[28].s64 = ctx.r[1].s64 + 104;
	// 825D1D2C: 4BF17B35  bl 0x824e9860
	ctx.lr = 0x825D1D30;
	sub_824E9860(ctx, base);
	// 825D1D30: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825D1D34: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825D1D38: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D1D3C: 38A0001E  li r5, 0x1e
	ctx.r[5].s64 = 30;
	// 825D1D40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D1D44: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 825D1D48: 48886CF9  bl 0x82e58a40
	ctx.lr = 0x825D1D4C;
	sub_82E58A40(ctx, base);
	// 825D1D4C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825D1D50: 4881FF41  bl 0x82df1c90
	ctx.lr = 0x825D1D54;
	sub_82DF1C90(ctx, base);
	// 825D1D54: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825D1D58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D1D5C: 419A0008  beq cr6, 0x825d1d64
	if ctx.cr[6].eq {
	pc = 0x825D1D64; continue 'dispatch;
	}
	// 825D1D60: 4BCEEB31  bl 0x822c0890
	ctx.lr = 0x825D1D64;
	sub_822C0890(ctx, base);
	// 825D1D64: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 825D1D68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D1D6C: 419A0008  beq cr6, 0x825d1d74
	if ctx.cr[6].eq {
	pc = 0x825D1D74; continue 'dispatch;
	}
	// 825D1D70: 4BCEEB21  bl 0x822c0890
	ctx.lr = 0x825D1D74;
	sub_822C0890(ctx, base);
	// 825D1D74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825D1D78: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D1D7C: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 825D1D80: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825D1D84: 4BE81AED  bl 0x82453870
	ctx.lr = 0x825D1D88;
	sub_82453870(ctx, base);
	// 825D1D88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1D8C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825D1D90: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D1D94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D1D98: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825D1D9C: 419A0024  beq cr6, 0x825d1dc0
	if ctx.cr[6].eq {
	pc = 0x825D1DC0; continue 'dispatch;
	}
	// 825D1DA0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D1DA4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D1DA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D1DAC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D1DB0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D1DB4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D1DB8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D1DBC: 4082FFE8  bne 0x825d1da4
	if !ctx.cr[0].eq {
	pc = 0x825D1DA4; continue 'dispatch;
	}
	// 825D1DC0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D1DC4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825D1DC8: 4BF3D751  bl 0x8250f518
	ctx.lr = 0x825D1DCC;
	sub_8250F518(ctx, base);
	// 825D1DCC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1DD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D1DD4: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 825D1DD8: 409A0008  bne cr6, 0x825d1de0
	if !ctx.cr[6].eq {
	pc = 0x825D1DE0; continue 'dispatch;
	}
	// 825D1DDC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825D1DE0: 3B810070  addi r28, r1, 0x70
	ctx.r[28].s64 = ctx.r[1].s64 + 112;
	// 825D1DE4: 4BF5626D  bl 0x82528050
	ctx.lr = 0x825D1DE8;
	sub_82528050(ctx, base);
	// 825D1DE8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825D1DEC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825D1DF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D1DF4: 38A00021  li r5, 0x21
	ctx.r[5].s64 = 33;
	// 825D1DF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D1DFC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 825D1E00: 48886C41  bl 0x82e58a40
	ctx.lr = 0x825D1E04;
	sub_82E58A40(ctx, base);
	// 825D1E04: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825D1E08: 4881FE89  bl 0x82df1c90
	ctx.lr = 0x825D1E0C;
	sub_82DF1C90(ctx, base);
	// 825D1E0C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825D1E10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D1E14: 419A0008  beq cr6, 0x825d1e1c
	if ctx.cr[6].eq {
	pc = 0x825D1E1C; continue 'dispatch;
	}
	// 825D1E18: 4BCEEA79  bl 0x822c0890
	ctx.lr = 0x825D1E1C;
	sub_822C0890(ctx, base);
	// 825D1E1C: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 825D1E20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D1E24: 419A0008  beq cr6, 0x825d1e2c
	if ctx.cr[6].eq {
	pc = 0x825D1E2C; continue 'dispatch;
	}
	// 825D1E28: 4BCEEA69  bl 0x822c0890
	ctx.lr = 0x825D1E2C;
	sub_822C0890(ctx, base);
	// 825D1E2C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D1E30: 997E00C8  stb r11, 0xc8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(200 as u32), ctx.r[11].u8 ) };
	// 825D1E34: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825D1E38: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 825D1E3C: 48BD637C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D1E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D1E40 size=760
    let mut pc: u32 = 0x825D1E40;
    'dispatch: loop {
        match pc {
            0x825D1E40 => {
    //   block [0x825D1E40..0x825D2138)
	// 825D1E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D1E44: 48BD6325  bl 0x831a8168
	ctx.lr = 0x825D1E48;
	sub_831A8130(ctx, base);
	// 825D1E48: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825D1E4C: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D1E50: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825D1E54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D1E58: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825D1E5C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825D1E60: 808B167C  lwz r4, 0x167c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5756 as u32) ) } as u64;
	// 825D1E64: 4881FD95  bl 0x82df1bf8
	ctx.lr = 0x825D1E68;
	sub_82DF1BF8(ctx, base);
	// 825D1E68: 80610078  lwz r3, 0x78(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 825D1E6C: 485753D5  bl 0x82b47240
	ctx.lr = 0x825D1E70;
	sub_82B47240(ctx, base);
	// 825D1E70: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D1E74: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825D1E78: 4881FE19  bl 0x82df1c90
	ctx.lr = 0x825D1E7C;
	sub_82DF1C90(ctx, base);
	// 825D1E7C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825D1E80: 556A039D  rlwinm. r10, r11, 0, 0xe, 0xe
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825D1E84: 41820230  beq 0x825d20b4
	if ctx.cr[0].eq {
	pc = 0x825D20B4; continue 'dispatch;
	}
	// 825D1E88: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D1E8C: 815F00C0  lwz r10, 0xc0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 825D1E90: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825D1E94: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825D1E98: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825D1E9C: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825D1EA0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825D1EA4: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825D1EA8: 48274769  bl 0x82846610
	ctx.lr = 0x825D1EAC;
	sub_82846610(ctx, base);
	// 825D1EAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1EB0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825D1EB4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D1EB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D1EBC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825D1EC0: 419A0024  beq cr6, 0x825d1ee4
	if ctx.cr[6].eq {
	pc = 0x825D1EE4; continue 'dispatch;
	}
	// 825D1EC4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D1EC8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D1ECC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D1ED0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D1ED4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D1ED8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D1EDC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D1EE0: 4082FFE8  bne 0x825d1ec8
	if !ctx.cr[0].eq {
	pc = 0x825D1EC8; continue 'dispatch;
	}
	// 825D1EE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D1EE8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D1EEC: 4BF3D62D  bl 0x8250f518
	ctx.lr = 0x825D1EF0;
	sub_8250F518(ctx, base);
	// 825D1EF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1EF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D1EF8: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 825D1EFC: 409A0008  bne cr6, 0x825d1f04
	if !ctx.cr[6].eq {
	pc = 0x825D1F04; continue 'dispatch;
	}
	// 825D1F00: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825D1F04: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 825D1F08: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 825D1F0C: 4BF56145  bl 0x82528050
	ctx.lr = 0x825D1F10;
	sub_82528050(ctx, base);
	// 825D1F10: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D1F14: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825D1F18: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825D1F1C: 3BABDF28  addi r29, r11, -0x20d8
	ctx.r[29].s64 = ctx.r[11].s64 + -8408;
	// 825D1F20: 38A00032  li r5, 0x32
	ctx.r[5].s64 = 50;
	// 825D1F24: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D1F28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D1F2C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 825D1F30: 48886B11  bl 0x82e58a40
	ctx.lr = 0x825D1F34;
	sub_82E58A40(ctx, base);
	// 825D1F34: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D1F38: 4881FD59  bl 0x82df1c90
	ctx.lr = 0x825D1F3C;
	sub_82DF1C90(ctx, base);
	// 825D1F3C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D1F40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D1F44: 419A0008  beq cr6, 0x825d1f4c
	if ctx.cr[6].eq {
	pc = 0x825D1F4C; continue 'dispatch;
	}
	// 825D1F48: 4BCEE949  bl 0x822c0890
	ctx.lr = 0x825D1F4C;
	sub_822C0890(ctx, base);
	// 825D1F4C: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 825D1F50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D1F54: 419A0008  beq cr6, 0x825d1f5c
	if ctx.cr[6].eq {
	pc = 0x825D1F5C; continue 'dispatch;
	}
	// 825D1F58: 4BCEE939  bl 0x822c0890
	ctx.lr = 0x825D1F5C;
	sub_822C0890(ctx, base);
	// 825D1F5C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825D1F60: 4BFFFB81  bl 0x825d1ae0
	ctx.lr = 0x825D1F64;
	sub_825D1AE0(ctx, base);
	// 825D1F64: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1F68: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825D1F6C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D1F70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D1F74: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825D1F78: 419A0024  beq cr6, 0x825d1f9c
	if ctx.cr[6].eq {
	pc = 0x825D1F9C; continue 'dispatch;
	}
	// 825D1F7C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D1F80: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D1F84: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D1F88: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D1F8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D1F90: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D1F94: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D1F98: 4082FFE8  bne 0x825d1f80
	if !ctx.cr[0].eq {
	pc = 0x825D1F80; continue 'dispatch;
	}
	// 825D1F9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D1FA0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825D1FA4: 4BF3D38D  bl 0x8250f330
	ctx.lr = 0x825D1FA8;
	sub_8250F330(ctx, base);
	// 825D1FA8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D1FAC: 3B810068  addi r28, r1, 0x68
	ctx.r[28].s64 = ctx.r[1].s64 + 104;
	// 825D1FB0: 4BF178B1  bl 0x824e9860
	ctx.lr = 0x825D1FB4;
	sub_824E9860(ctx, base);
	// 825D1FB4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825D1FB8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825D1FBC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D1FC0: 38A00033  li r5, 0x33
	ctx.r[5].s64 = 51;
	// 825D1FC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D1FC8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 825D1FCC: 48886A75  bl 0x82e58a40
	ctx.lr = 0x825D1FD0;
	sub_82E58A40(ctx, base);
	// 825D1FD0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825D1FD4: 4881FCBD  bl 0x82df1c90
	ctx.lr = 0x825D1FD8;
	sub_82DF1C90(ctx, base);
	// 825D1FD8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825D1FDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D1FE0: 419A0008  beq cr6, 0x825d1fe8
	if ctx.cr[6].eq {
	pc = 0x825D1FE8; continue 'dispatch;
	}
	// 825D1FE4: 4BCEE8AD  bl 0x822c0890
	ctx.lr = 0x825D1FE8;
	sub_822C0890(ctx, base);
	// 825D1FE8: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 825D1FEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D1FF0: 419A0008  beq cr6, 0x825d1ff8
	if ctx.cr[6].eq {
	pc = 0x825D1FF8; continue 'dispatch;
	}
	// 825D1FF4: 4BCEE89D  bl 0x822c0890
	ctx.lr = 0x825D1FF8;
	sub_822C0890(ctx, base);
	// 825D1FF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D1FFC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D2000: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 825D2004: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 825D2008: 4BE81869  bl 0x82453870
	ctx.lr = 0x825D200C;
	sub_82453870(ctx, base);
	// 825D200C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2010: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825D2014: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D2018: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D201C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825D2020: 419A0024  beq cr6, 0x825d2044
	if ctx.cr[6].eq {
	pc = 0x825D2044; continue 'dispatch;
	}
	// 825D2024: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D2028: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D202C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D2030: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D2034: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D2038: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D203C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D2040: 4082FFE8  bne 0x825d2028
	if !ctx.cr[0].eq {
	pc = 0x825D2028; continue 'dispatch;
	}
	// 825D2044: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D2048: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825D204C: 4BF3D4CD  bl 0x8250f518
	ctx.lr = 0x825D2050;
	sub_8250F518(ctx, base);
	// 825D2050: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2054: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D2058: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 825D205C: 409A0008  bne cr6, 0x825d2064
	if !ctx.cr[6].eq {
	pc = 0x825D2064; continue 'dispatch;
	}
	// 825D2060: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825D2064: 3BE10070  addi r31, r1, 0x70
	ctx.r[31].s64 = ctx.r[1].s64 + 112;
	// 825D2068: 4BF55FE9  bl 0x82528050
	ctx.lr = 0x825D206C;
	sub_82528050(ctx, base);
	// 825D206C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825D2070: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825D2074: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D2078: 38A00034  li r5, 0x34
	ctx.r[5].s64 = 52;
	// 825D207C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D2080: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 825D2084: 488869BD  bl 0x82e58a40
	ctx.lr = 0x825D2088;
	sub_82E58A40(ctx, base);
	// 825D2088: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825D208C: 4881FC05  bl 0x82df1c90
	ctx.lr = 0x825D2090;
	sub_82DF1C90(ctx, base);
	// 825D2090: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825D2094: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D2098: 419A0008  beq cr6, 0x825d20a0
	if ctx.cr[6].eq {
	pc = 0x825D20A0; continue 'dispatch;
	}
	// 825D209C: 4BCEE7F5  bl 0x822c0890
	ctx.lr = 0x825D20A0;
	sub_822C0890(ctx, base);
	// 825D20A0: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 825D20A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D20A8: 419A0084  beq cr6, 0x825d212c
	if ctx.cr[6].eq {
	pc = 0x825D212C; continue 'dispatch;
	}
	// 825D20AC: 4BCEE7E5  bl 0x822c0890
	ctx.lr = 0x825D20B0;
	sub_822C0890(ctx, base);
	// 825D20B0: 4800007C  b 0x825d212c
	pc = 0x825D212C; continue 'dispatch;
	// 825D20B4: 556B03DF  rlwinm. r11, r11, 0, 0xf, 0xf
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D20B8: 41820074  beq 0x825d212c
	if ctx.cr[0].eq {
	pc = 0x825D212C; continue 'dispatch;
	}
	// 825D20BC: 897F00C8  lbz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 825D20C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D20C4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D20C8: 41820034  beq 0x825d20fc
	if ctx.cr[0].eq {
	pc = 0x825D20FC; continue 'dispatch;
	}
	// 825D20CC: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825D20D0: 4BF3D3F9  bl 0x8250f4c8
	ctx.lr = 0x825D20D4;
	sub_8250F4C8(ctx, base);
	// 825D20D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D20D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D20DC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825D20E0: 409A0008  bne cr6, 0x825d20e8
	if !ctx.cr[6].eq {
	pc = 0x825D20E8; continue 'dispatch;
	}
	// 825D20E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825D20E8: 4BF36A59  bl 0x82508b40
	ctx.lr = 0x825D20EC;
	sub_82508B40(ctx, base);
	// 825D20EC: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825D20F0: 4881FBA1  bl 0x82df1c90
	ctx.lr = 0x825D20F4;
	sub_82DF1C90(ctx, base);
	// 825D20F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D20F8: 48000030  b 0x825d2128
	pc = 0x825D2128; continue 'dispatch;
	// 825D20FC: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 825D2100: 4BF3D3C9  bl 0x8250f4c8
	ctx.lr = 0x825D2104;
	sub_8250F4C8(ctx, base);
	// 825D2104: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2108: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D210C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825D2110: 409A0008  bne cr6, 0x825d2118
	if !ctx.cr[6].eq {
	pc = 0x825D2118; continue 'dispatch;
	}
	// 825D2114: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825D2118: 4BF36A19  bl 0x82508b30
	ctx.lr = 0x825D211C;
	sub_82508B30(ctx, base);
	// 825D211C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 825D2120: 4881FB71  bl 0x82df1c90
	ctx.lr = 0x825D2124;
	sub_82DF1C90(ctx, base);
	// 825D2124: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825D2128: 997F00C8  stb r11, 0xc8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u8 ) };
	// 825D212C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825D2130: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 825D2134: 48BD6084  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D2138 size=140
    let mut pc: u32 = 0x825D2138;
    'dispatch: loop {
        match pc {
            0x825D2138 => {
    //   block [0x825D2138..0x825D21C4)
	// 825D2138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D213C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D2140: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D2144: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 825D2148: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 825D214C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D2150: 13E028C7  vcmpequd (lvx128) v31, v0, v5
	tmp.u32 = ctx.r[5].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825D2154: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825D2158: 13C020C7  vcmpequd (lvx128) v30, v0, v4
	tmp.u32 = ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825D215C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D21C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D21C8 size=108
    let mut pc: u32 = 0x825D21C8;
    'dispatch: loop {
        match pc {
            0x825D21C8 => {
    //   block [0x825D21C8..0x825D2234)
	// 825D21C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D21CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D21D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D21D4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D21D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D21DC: 4BE9F4FD  bl 0x824716d8
	ctx.lr = 0x825D21E0;
	sub_824716D8(ctx, base);
	// 825D21E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D21E4: 482231ED  bl 0x827f53d0
	ctx.lr = 0x825D21E8;
	sub_827F53D0(ctx, base);
	// 825D21E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D21EC: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 825D21F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D21F4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D2238 size=716
    let mut pc: u32 = 0x825D2238;
    'dispatch: loop {
        match pc {
            0x825D2238 => {
    //   block [0x825D2238..0x825D2504)
	// 825D2238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D223C: 48BD5F2D  bl 0x831a8168
	ctx.lr = 0x825D2240;
	sub_831A8130(ctx, base);
	// 825D2240: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 825D2244: 48BD6831  bl 0x831a8a74
	ctx.lr = 0x825D2248;
	sub_831A8A40(ctx, base);
	// 825D2248: 9421FD60  stwu r1, -0x2a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-672 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D224C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D2250: 4BE9F501  bl 0x82471750
	ctx.lr = 0x825D2254;
	sub_82471750(ctx, base);
	// 825D2254: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D2258: 48223179  bl 0x827f53d0
	ctx.lr = 0x825D225C;
	sub_827F53D0(ctx, base);
	// 825D225C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D2260: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 825D2264: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D2268: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D2508 size=112
    let mut pc: u32 = 0x825D2508;
    'dispatch: loop {
        match pc {
            0x825D2508 => {
    //   block [0x825D2508..0x825D2578)
	// 825D2508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D250C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D2510: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D2514: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D2518: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D251C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D2520: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D2524: 4BE9ECED  bl 0x82471210
	ctx.lr = 0x825D2528;
	sub_82471210(ctx, base);
	// 825D2528: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D252C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825D2530: 394ADF80  addi r10, r10, -0x2080
	ctx.r[10].s64 = ctx.r[10].s64 + -8320;
	// 825D2534: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D2538: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825D253C: D01F0160  stfs f0, 0x160(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 825D2540: D01F0164  stfs f0, 0x164(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 825D2544: D01F0168  stfs f0, 0x168(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 825D2548: D01F016C  stfs f0, 0x16c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 825D254C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D2550: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D2554: 419A0008  beq cr6, 0x825d255c
	if ctx.cr[6].eq {
	pc = 0x825D255C; continue 'dispatch;
	}
	// 825D2558: 4BCEE339  bl 0x822c0890
	ctx.lr = 0x825D255C;
	sub_822C0890(ctx, base);
	// 825D255C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D2560: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D2564: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D2568: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D256C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D2570: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D2574: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D2578 size=76
    let mut pc: u32 = 0x825D2578;
    'dispatch: loop {
        match pc {
            0x825D2578 => {
    //   block [0x825D2578..0x825D25C4)
	// 825D2578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D257C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D2580: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D2584: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D2588: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D258C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D2590: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D2594: 4BE9EC15  bl 0x824711a8
	ctx.lr = 0x825D2598;
	sub_824711A8(ctx, base);
	// 825D2598: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D259C: 4182000C  beq 0x825d25a8
	if ctx.cr[0].eq {
	pc = 0x825D25A8; continue 'dispatch;
	}
	// 825D25A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D25A4: 4881FE35  bl 0x82df23d8
	ctx.lr = 0x825D25A8;
	sub_82DF23D8(ctx, base);
	// 825D25A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D25AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D25B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D25B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D25B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D25BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D25C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D25C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D25C8 size=96
    let mut pc: u32 = 0x825D25C8;
    'dispatch: loop {
        match pc {
            0x825D25C8 => {
    //   block [0x825D25C8..0x825D2628)
	// 825D25C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D25CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D25D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D25D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D25D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D25DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D25E0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825D25E4: 4BFE5CD5  bl 0x825b82b8
	ctx.lr = 0x825D25E8;
	sub_825B82B8(ctx, base);
	// 825D25E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D25EC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825D25F0: 396BDFCC  addi r11, r11, -0x2034
	ctx.r[11].s64 = ctx.r[11].s64 + -8244;
	// 825D25F4: 394ADFB4  addi r10, r10, -0x204c
	ctx.r[10].s64 = ctx.r[10].s64 + -8268;
	// 825D25F8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D25FC: 387F00D0  addi r3, r31, 0xd0
	ctx.r[3].s64 = ctx.r[31].s64 + 208;
	// 825D2600: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825D2604: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D2608: 4BFB9909  bl 0x8258bf10
	ctx.lr = 0x825D260C;
	sub_8258BF10(ctx, base);
	// 825D260C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D2610: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D2614: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D2618: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D261C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D2620: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D2624: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D2628 size=40
    let mut pc: u32 = 0x825D2628;
    'dispatch: loop {
        match pc {
            0x825D2628 => {
    //   block [0x825D2628..0x825D2650)
	// 825D2628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D262C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D2630: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D2634: 386300D0  addi r3, r3, 0xd0
	ctx.r[3].s64 = ctx.r[3].s64 + 208;
	// 825D2638: 4BE81049  bl 0x82453680
	ctx.lr = 0x825D263C;
	sub_82453680(ctx, base);
	// 825D263C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825D2640: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D2644: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D2648: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D264C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D2650 size=136
    let mut pc: u32 = 0x825D2650;
    'dispatch: loop {
        match pc {
            0x825D2650 => {
    //   block [0x825D2650..0x825D26D8)
	// 825D2650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D2654: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D2658: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D265C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D2660: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D2664: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D2668: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D266C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 825D2670: 409A0020  bne cr6, 0x825d2690
	if !ctx.cr[6].eq {
	pc = 0x825D2690; continue 'dispatch;
	}
	// 825D2674: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D2678: 419A0048  beq cr6, 0x825d26c0
	if ctx.cr[6].eq {
	pc = 0x825D26C0; continue 'dispatch;
	}
	// 825D267C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2680: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D2684: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D2688: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825D268C: 48000034  b 0x825d26c0
	pc = 0x825D26C0; continue 'dispatch;
	// 825D2690: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 825D2694: 419A002C  beq cr6, 0x825d26c0
	if ctx.cr[6].eq {
	pc = 0x825D26C0; continue 'dispatch;
	}
	// 825D2698: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D269C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D26A0: 388BBD78  addi r4, r11, -0x4288
	ctx.r[4].s64 = ctx.r[11].s64 + -17032;
	// 825D26A4: 48BD5A55  bl 0x831a80f8
	ctx.lr = 0x825D26A8;
	sub_831A80F8(ctx, base);
	// 825D26A8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D26AC: 4182000C  beq 0x825d26b8
	if ctx.cr[0].eq {
	pc = 0x825D26B8; continue 'dispatch;
	}
	// 825D26B0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825D26B4: 4800000C  b 0x825d26c0
	pc = 0x825D26C0; continue 'dispatch;
	// 825D26B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D26BC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D26C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D26C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D26C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D26CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D26D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D26D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D26D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D26D8 size=184
    let mut pc: u32 = 0x825D26D8;
    'dispatch: loop {
        match pc {
            0x825D26D8 => {
    //   block [0x825D26D8..0x825D2790)
	// 825D26D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D26DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D26E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D26E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D26E8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 825D26EC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D26F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D26F4: 817F0134  lwz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 825D26F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D26FC: 419A0078  beq cr6, 0x825d2774
	if ctx.cr[6].eq {
	pc = 0x825D2774; continue 'dispatch;
	}
	// 825D2700: 815F0138  lwz r10, 0x138(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 825D2704: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825D2708: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D270C: 41820068  beq 0x825d2774
	if ctx.cr[0].eq {
	pc = 0x825D2774; continue 'dispatch;
	}
	// 825D2710: 83DF0140  lwz r30, 0x140(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 825D2714: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825D2718: 419A005C  beq cr6, 0x825d2774
	if ctx.cr[6].eq {
	pc = 0x825D2774; continue 'dispatch;
	}
	// 825D271C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D2720: 4BE9E8A9  bl 0x82470fc8
	ctx.lr = 0x825D2724;
	sub_82470FC8(ctx, base);
	// 825D2724: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D2728: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825D272C: 4BE9E895  bl 0x82470fc0
	ctx.lr = 0x825D2730;
	sub_82470FC0(ctx, base);
	// 825D2730: C01F0148  lfs f0, 0x148(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D2734: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 825D2738: 40980008  bge cr6, 0x825d2740
	if !ctx.cr[6].lt {
	pc = 0x825D2740; continue 'dispatch;
	}
	// 825D273C: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 825D2740: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 825D2744: 40990008  ble cr6, 0x825d274c
	if !ctx.cr[6].gt {
	pc = 0x825D274C; continue 'dispatch;
	}
	// 825D2748: FC000890  fmr f0, f1
	ctx.f[0].f64 = ctx.f[1].f64;
	// 825D274C: D01F0148  stfs f0, 0x148(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 825D2750: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 825D2754: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 825D2758: 4BE9F131  bl 0x82471888
	ctx.lr = 0x825D275C;
	sub_82471888(ctx, base);
	// 825D275C: C03F0154  lfs f1, 0x154(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825D2760: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 825D2764: 4813183D  bl 0x82703fa0
	ctx.lr = 0x825D2768;
	sub_82703FA0(ctx, base);
	// 825D2768: 889F0158  lbz r4, 0x158(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 825D276C: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 825D2770: 4BE9E861  bl 0x82470fd0
	ctx.lr = 0x825D2774;
	sub_82470FD0(ctx, base);
	// 825D2774: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D2778: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D277C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D2780: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 825D2784: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D2788: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D278C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D2790 size=196
    let mut pc: u32 = 0x825D2790;
    'dispatch: loop {
        match pc {
            0x825D2790 => {
    //   block [0x825D2790..0x825D2854)
	// 825D2790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D2794: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D2798: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D279C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D27A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D27A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D27A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D27AC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825D27B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D27B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D27B8: 4BCEE181  bl 0x822c0938
	ctx.lr = 0x825D27BC;
	sub_822C0938(ctx, base);
	// 825D27BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D27C0: 41820028  beq 0x825d27e8
	if ctx.cr[0].eq {
	pc = 0x825D27E8; continue 'dispatch;
	}
	// 825D27C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D27C8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825D27CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D27D0: 392BE03C  addi r9, r11, -0x1fc4
	ctx.r[9].s64 = ctx.r[11].s64 + -8132;
	// 825D27D4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D27D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D27DC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D27E0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825D27E4: 48000008  b 0x825d27ec
	pc = 0x825D27EC; continue 'dispatch;
	// 825D27E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D27EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D27F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D27F4: 409A0044  bne cr6, 0x825d2838
	if !ctx.cr[6].eq {
	pc = 0x825D2838; continue 'dispatch;
	}
	// 825D27F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D27FC: 419A001C  beq cr6, 0x825d2818
	if ctx.cr[6].eq {
	pc = 0x825D2818; continue 'dispatch;
	}
	// 825D2800: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2804: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D2808: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D280C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2810: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D2814: 4E800421  bctrl
	ctx.lr = 0x825D2818;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D2818: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D281C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825D2820: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D2824: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825D2828: 816BBCD8  lwz r11, -0x4328(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17192 as u32) ) } as u64;
	// 825D282C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825D2830: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D2834: 4BCED7CD  bl 0x822c0000
	ctx.lr = 0x825D2838;
	sub_822C0000(ctx, base);
	// 825D2838: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D283C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D2840: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D2844: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D2848: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D284C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D2850: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D2858 size=196
    let mut pc: u32 = 0x825D2858;
    'dispatch: loop {
        match pc {
            0x825D2858 => {
    //   block [0x825D2858..0x825D291C)
	// 825D2858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D285C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D2860: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D2864: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D2868: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D286C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D2870: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D2874: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825D2878: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D287C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D2880: 4BCEE0B9  bl 0x822c0938
	ctx.lr = 0x825D2884;
	sub_822C0938(ctx, base);
	// 825D2884: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D2888: 41820028  beq 0x825d28b0
	if ctx.cr[0].eq {
	pc = 0x825D28B0; continue 'dispatch;
	}
	// 825D288C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D2890: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825D2894: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825D2898: 392BE050  addi r9, r11, -0x1fb0
	ctx.r[9].s64 = ctx.r[11].s64 + -8112;
	// 825D289C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D28A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D28A4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825D28A8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825D28AC: 48000008  b 0x825d28b4
	pc = 0x825D28B4; continue 'dispatch;
	// 825D28B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D28B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D28B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D28BC: 409A0044  bne cr6, 0x825d2900
	if !ctx.cr[6].eq {
	pc = 0x825D2900; continue 'dispatch;
	}
	// 825D28C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D28C4: 419A001C  beq cr6, 0x825d28e0
	if ctx.cr[6].eq {
	pc = 0x825D28E0; continue 'dispatch;
	}
	// 825D28C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D28CC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D28D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D28D4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D28D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825D28DC: 4E800421  bctrl
	ctx.lr = 0x825D28E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825D28E0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D28E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825D28E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D28EC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825D28F0: 816BBCD8  lwz r11, -0x4328(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17192 as u32) ) } as u64;
	// 825D28F4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825D28F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D28FC: 4BCED705  bl 0x822c0000
	ctx.lr = 0x825D2900;
	sub_822C0000(ctx, base);
	// 825D2900: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D2904: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D2908: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D290C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D2910: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D2914: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D2918: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D2920 size=88
    let mut pc: u32 = 0x825D2920;
    'dispatch: loop {
        match pc {
            0x825D2920 => {
    //   block [0x825D2920..0x825D2978)
	// 825D2920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D2924: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D2928: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D292C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D2930: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825D2934: F8810078  std r4, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[4].u64 ) };
	// 825D2938: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825D293C: 481FC89D  bl 0x827cf1d8
	ctx.lr = 0x825D2940;
	sub_827CF1D8(ctx, base);
	// 825D2940: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D2944: 4082001C  bne 0x825d2960
	if !ctx.cr[0].eq {
	pc = 0x825D2960; continue 'dispatch;
	}
	// 825D2948: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825D294C: 419A000C  beq cr6, 0x825d2958
	if ctx.cr[6].eq {
	pc = 0x825D2958; continue 'dispatch;
	}
	// 825D2950: E9610078  ld r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 825D2954: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 825D2958: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825D295C: 48000008  b 0x825d2964
	pc = 0x825D2964; continue 'dispatch;
	// 825D2960: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825D2964: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D2968: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D296C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D2970: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D2974: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D2978 size=72
    let mut pc: u32 = 0x825D2978;
    'dispatch: loop {
        match pc {
            0x825D2978 => {
    //   block [0x825D2978..0x825D29C0)
	// 825D2978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D297C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D2980: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D2984: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 825D2988: 419A001C  beq cr6, 0x825d29a4
	if ctx.cr[6].eq {
	pc = 0x825D29A4; continue 'dispatch;
	}
	// 825D298C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825D2990: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825D2994: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 825D2998: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D299C: 4BFFFCB5  bl 0x825d2650
	ctx.lr = 0x825D29A0;
	sub_825D2650(ctx, base);
	// 825D29A0: 48000010  b 0x825d29b0
	pc = 0x825D29B0; continue 'dispatch;
	// 825D29A4: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825D29A8: 396BBD78  addi r11, r11, -0x4288
	ctx.r[11].s64 = ctx.r[11].s64 + -17032;
	// 825D29AC: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D29B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825D29B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D29B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D29BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D29C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D29C0 size=172
    let mut pc: u32 = 0x825D29C0;
    'dispatch: loop {
        match pc {
            0x825D29C0 => {
    //   block [0x825D29C0..0x825D2A6C)
	// 825D29C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D29C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D29C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D29CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D29D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D29D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D29D8: 897F012C  lbz r11, 0x12c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 825D29DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D29E0: 41820064  beq 0x825d2a44
	if ctx.cr[0].eq {
	pc = 0x825D2A44; continue 'dispatch;
	}
	// 825D29E4: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D29E8: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D29EC: 41820060  beq 0x825d2a4c
	if ctx.cr[0].eq {
	pc = 0x825D2A4C; continue 'dispatch;
	}
	// 825D29F0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D29F4: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 825D29F8: 4BE9E5E1  bl 0x82470fd8
	ctx.lr = 0x825D29FC;
	sub_82470FD8(ctx, base);
	// 825D29FC: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 825D2A00: 484FFF39  bl 0x82ad2938
	ctx.lr = 0x825D2A04;
	sub_82AD2938(ctx, base);
	// 825D2A04: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825D2A08: D03F0148  stfs f1, 0x148(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 825D2A0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D2A10: 9BDF012C  stb r30, 0x12c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[30].u8 ) };
	// 825D2A14: 9BDF0014  stb r30, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 825D2A18: 4BCF6301  bl 0x822c8d18
	ctx.lr = 0x825D2A1C;
	sub_822C8D18(ctx, base);
	// 825D2A1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2A20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D2A24: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825D2A28: 409A0008  bne cr6, 0x825d2a30
	if !ctx.cr[6].eq {
	pc = 0x825D2A30; continue 'dispatch;
	}
	// 825D2A2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D2A30: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D2A34: 48AECD85  bl 0x830bf7b8
	ctx.lr = 0x825D2A38;
	sub_830BF7B8(ctx, base);
	// 825D2A38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D2A3C: 4881F255  bl 0x82df1c90
	ctx.lr = 0x825D2A40;
	sub_82DF1C90(ctx, base);
	// 825D2A40: 4800000C  b 0x825d2a4c
	pc = 0x825D2A4C; continue 'dispatch;
	// 825D2A44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D2A48: 4BFE21B1  bl 0x825b4bf8
	ctx.lr = 0x825D2A4C;
	sub_825B4BF8(ctx, base);
	// 825D2A4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D2A50: 4BFE3B91  bl 0x825b65e0
	ctx.lr = 0x825D2A54;
	sub_825B65E0(ctx, base);
	// 825D2A54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D2A58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D2A5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D2A60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D2A64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D2A68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D2A70 size=148
    let mut pc: u32 = 0x825D2A70;
    'dispatch: loop {
        match pc {
            0x825D2A70 => {
    //   block [0x825D2A70..0x825D2B04)
	// 825D2A70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D2A74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D2A78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D2A7C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D2A80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D2A84: 817F0134  lwz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 825D2A88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D2A8C: 419A0064  beq cr6, 0x825d2af0
	if ctx.cr[6].eq {
	pc = 0x825D2AF0; continue 'dispatch;
	}
	// 825D2A90: 815F0138  lwz r10, 0x138(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 825D2A94: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825D2A98: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D2A9C: 41820054  beq 0x825d2af0
	if ctx.cr[0].eq {
	pc = 0x825D2AF0; continue 'dispatch;
	}
	// 825D2AA0: 897F012C  lbz r11, 0x12c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 825D2AA4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D2AA8: 40820048  bne 0x825d2af0
	if !ctx.cr[0].eq {
	pc = 0x825D2AF0; continue 'dispatch;
	}
	// 825D2AAC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D2AB0: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 825D2AB4: 4BE9E525  bl 0x82470fd8
	ctx.lr = 0x825D2AB8;
	sub_82470FD8(ctx, base);
	// 825D2AB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825D2ABC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D2AC0: 997F012C  stb r11, 0x12c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[11].u8 ) };
	// 825D2AC4: 997F0014  stb r11, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 825D2AC8: 4BCF6251  bl 0x822c8d18
	ctx.lr = 0x825D2ACC;
	sub_822C8D18(ctx, base);
	// 825D2ACC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2AD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D2AD4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825D2AD8: 409A0008  bne cr6, 0x825d2ae0
	if !ctx.cr[6].eq {
	pc = 0x825D2AE0; continue 'dispatch;
	}
	// 825D2ADC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825D2AE0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825D2AE4: 48AECCD5  bl 0x830bf7b8
	ctx.lr = 0x825D2AE8;
	sub_830BF7B8(ctx, base);
	// 825D2AE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D2AEC: 4881F1A5  bl 0x82df1c90
	ctx.lr = 0x825D2AF0;
	sub_82DF1C90(ctx, base);
	// 825D2AF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D2AF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D2AF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D2AFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D2B00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D2B08 size=112
    let mut pc: u32 = 0x825D2B08;
    'dispatch: loop {
        match pc {
            0x825D2B08 => {
    //   block [0x825D2B08..0x825D2B78)
	// 825D2B08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D2B0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825D2B10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825D2B14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825D2B18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D2B1C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825D2B20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D2B24: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825D2B28: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D2B2C: 4BFFFD2D  bl 0x825d2858
	ctx.lr = 0x825D2B30;
	sub_825D2858(ctx, base);
	// 825D2B30: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825D2B34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D2B38: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825D2B3C: 4BCED4C5  bl 0x822c0000
	ctx.lr = 0x825D2B40;
	sub_822C0000(ctx, base);
	// 825D2B40: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D2B44: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825D2B48: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D2B4C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D2B50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D2B54: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825D2B58: 419A0008  beq cr6, 0x825d2b60
	if ctx.cr[6].eq {
	pc = 0x825D2B60; continue 'dispatch;
	}
	// 825D2B5C: 4BCEDD35  bl 0x822c0890
	ctx.lr = 0x825D2B60;
	sub_822C0890(ctx, base);
	// 825D2B60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825D2B64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825D2B68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825D2B6C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825D2B70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825D2B74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2B78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D2B78 size=400
    let mut pc: u32 = 0x825D2B78;
    'dispatch: loop {
        match pc {
            0x825D2B78 => {
    //   block [0x825D2B78..0x825D2D08)
	// 825D2B78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D2B7C: 48BD55F1  bl 0x831a816c
	ctx.lr = 0x825D2B80;
	sub_831A8130(ctx, base);
	// 825D2B80: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D2B84: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825D2B88: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825D2B8C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825D2B90: 809F0120  lwz r4, 0x120(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 825D2B94: 4BF3C935  bl 0x8250f4c8
	ctx.lr = 0x825D2B98;
	sub_8250F4C8(ctx, base);
	// 825D2B98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2B9C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825D2BA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D2BA4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825D2BA8: 409A0008  bne cr6, 0x825d2bb0
	if !ctx.cr[6].eq {
	pc = 0x825D2BB0; continue 'dispatch;
	}
	// 825D2BAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D2BB0: 4BF35979  bl 0x82508528
	ctx.lr = 0x825D2BB4;
	sub_82508528(ctx, base);
	// 825D2BB4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D2BB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825D2BBC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2BC0: 4886D349  bl 0x82e3ff08
	ctx.lr = 0x825D2BC4;
	sub_82E3FF08(ctx, base);
	// 825D2BC4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825D2BC8: 4881F0C9  bl 0x82df1c90
	ctx.lr = 0x825D2BCC;
	sub_82DF1C90(ctx, base);
	// 825D2BCC: 815F014C  lwz r10, 0x14c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 825D2BD0: 817F0134  lwz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 825D2BD4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D2BD8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825D2BDC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D2BE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825D2BE4: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825D2BE8: 4886E551  bl 0x82e41138
	ctx.lr = 0x825D2BEC;
	sub_82E41138(ctx, base);
	// 825D2BEC: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825D2BF0: 48A35539  bl 0x83008128
	ctx.lr = 0x825D2BF4;
	sub_83008128(ctx, base);
	// 825D2BF4: 817F0150  lwz r11, 0x150(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 825D2BF8: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825D2BFC: 4199000C  bgt cr6, 0x825d2c08
	if ctx.cr[6].gt {
	pc = 0x825D2C08; continue 'dispatch;
	}
	// 825D2C00: 3963FFFF  addi r11, r3, -1
	ctx.r[11].s64 = ctx.r[3].s64 + -1;
	// 825D2C04: 917F0150  stw r11, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 825D2C08: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825D2C0C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825D2C10: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825D2C14: 897F0159  lbz r11, 0x159(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(345 as u32) ) } as u64;
	// 825D2C18: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D2C1C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D2C20: 388BE060  addi r4, r11, -0x1fa0
	ctx.r[4].s64 = ctx.r[11].s64 + -8096;
	// 825D2C24: 41820084  beq 0x825d2ca8
	if ctx.cr[0].eq {
	pc = 0x825D2CA8; continue 'dispatch;
	}
	// 825D2C28: 38A0008F  li r5, 0x8f
	ctx.r[5].s64 = 143;
	// 825D2C2C: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 825D2C30: 4881F7B9  bl 0x82df23e8
	ctx.lr = 0x825D2C34;
	sub_82DF23E8(ctx, base);
	// 825D2C34: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D2C38: 41820060  beq 0x825d2c98
	if ctx.cr[0].eq {
	pc = 0x825D2C98; continue 'dispatch;
	}
	// 825D2C3C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825D2C40: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825D2C44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D2C48: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825D2C4C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825D2C50: 419A0024  beq cr6, 0x825d2c74
	if ctx.cr[6].eq {
	pc = 0x825D2C74; continue 'dispatch;
	}
	// 825D2C54: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D2C58: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D2C5C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D2C60: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D2C64: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D2C68: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D2C6C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D2C70: 4082FFE8  bne 0x825d2c58
	if !ctx.cr[0].eq {
	pc = 0x825D2C58; continue 'dispatch;
	}
	// 825D2C74: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825D2C78: 88FF0158  lbz r7, 0x158(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 825D2C7C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825D2C80: C03F0154  lfs f1, 0x154(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825D2C84: 390B6910  addi r8, r11, 0x6910
	ctx.r[8].s64 = ctx.r[11].s64 + 26896;
	// 825D2C88: 80BF0150  lwz r5, 0x150(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 825D2C8C: 4BFFF87D  bl 0x825d2508
	ctx.lr = 0x825D2C90;
	sub_825D2508(ctx, base);
	// 825D2C90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D2C94: 48000008  b 0x825d2c9c
	pc = 0x825D2C9C; continue 'dispatch;
	// 825D2C98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D2C9C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D2CA0: 4BFFFE69  bl 0x825d2b08
	ctx.lr = 0x825D2CA4;
	sub_825D2B08(ctx, base);
	// 825D2CA4: 48000048  b 0x825d2cec
	pc = 0x825D2CEC; continue 'dispatch;
	// 825D2CA8: 38A00093  li r5, 0x93
	ctx.r[5].s64 = 147;
	// 825D2CAC: 38600160  li r3, 0x160
	ctx.r[3].s64 = 352;
	// 825D2CB0: 4881F739  bl 0x82df23e8
	ctx.lr = 0x825D2CB4;
	sub_82DF23E8(ctx, base);
	// 825D2CB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825D2CB8: 41820028  beq 0x825d2ce0
	if ctx.cr[0].eq {
	pc = 0x825D2CE0; continue 'dispatch;
	}
	// 825D2CBC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825D2CC0: 88FF0158  lbz r7, 0x158(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 825D2CC4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825D2CC8: C03F0154  lfs f1, 0x154(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825D2CCC: 390B6910  addi r8, r11, 0x6910
	ctx.r[8].s64 = ctx.r[11].s64 + 26896;
	// 825D2CD0: 80BF0150  lwz r5, 0x150(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 825D2CD4: 4BE9E53D  bl 0x82471210
	ctx.lr = 0x825D2CD8;
	sub_82471210(ctx, base);
	// 825D2CD8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825D2CDC: 48000008  b 0x825d2ce4
	pc = 0x825D2CE4; continue 'dispatch;
	// 825D2CE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D2CE4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D2CE8: 4BDC6289  bl 0x82398f70
	ctx.lr = 0x825D2CEC;
	sub_82398F70(ctx, base);
	// 825D2CEC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825D2CF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D2CF4: 419A0008  beq cr6, 0x825d2cfc
	if ctx.cr[6].eq {
	pc = 0x825D2CFC; continue 'dispatch;
	}
	// 825D2CF8: 4BCEDB99  bl 0x822c0890
	ctx.lr = 0x825D2CFC;
	sub_822C0890(ctx, base);
	// 825D2CFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825D2D00: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825D2D04: 48BD54B8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D2D08 size=556
    let mut pc: u32 = 0x825D2D08;
    'dispatch: loop {
        match pc {
            0x825D2D08 => {
    //   block [0x825D2D08..0x825D2F34)
	// 825D2D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D2D0C: 48BD5459  bl 0x831a8164
	ctx.lr = 0x825D2D10;
	sub_831A8130(ctx, base);
	// 825D2D10: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 825D2D14: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D2D18: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D2D1C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825D2D20: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825D2D24: 3BABE060  addi r29, r11, -0x1fa0
	ctx.r[29].s64 = ctx.r[11].s64 + -8096;
	// 825D2D28: 3BFE0140  addi r31, r30, 0x140
	ctx.r[31].s64 = ctx.r[30].s64 + 320;
	// 825D2D2C: 817E0140  lwz r11, 0x140(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(320 as u32) ) } as u64;
	// 825D2D30: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825D2D34: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825D2D38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D2D3C: 419A00DC  beq cr6, 0x825d2e18
	if ctx.cr[6].eq {
	pc = 0x825D2E18; continue 'dispatch;
	}
	// 825D2D40: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825D2D44: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D2D48: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825D2D4C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825D2D50: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825D2D54: 482738BD  bl 0x82846610
	ctx.lr = 0x825D2D58;
	sub_82846610(ctx, base);
	// 825D2D58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2D5C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825D2D60: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D2D64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D2D68: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825D2D6C: 419A0024  beq cr6, 0x825d2d90
	if ctx.cr[6].eq {
	pc = 0x825D2D90; continue 'dispatch;
	}
	// 825D2D70: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D2D74: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D2D78: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D2D7C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D2D80: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D2D84: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D2D88: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D2D8C: 4082FFE8  bne 0x825d2d74
	if !ctx.cr[0].eq {
	pc = 0x825D2D74; continue 'dispatch;
	}
	// 825D2D90: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825D2D94: 809E0120  lwz r4, 0x120(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(288 as u32) ) } as u64;
	// 825D2D98: 4BF3C781  bl 0x8250f518
	ctx.lr = 0x825D2D9C;
	sub_8250F518(ctx, base);
	// 825D2D9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2DA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D2DA4: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 825D2DA8: 409A0008  bne cr6, 0x825d2db0
	if !ctx.cr[6].eq {
	pc = 0x825D2DB0; continue 'dispatch;
	}
	// 825D2DAC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825D2DB0: 3B610058  addi r27, r1, 0x58
	ctx.r[27].s64 = ctx.r[1].s64 + 88;
	// 825D2DB4: 4BF5529D  bl 0x82528050
	ctx.lr = 0x825D2DB8;
	sub_82528050(ctx, base);
	// 825D2DB8: 817E0120  lwz r11, 0x120(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(288 as u32) ) } as u64;
	// 825D2DBC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825D2DC0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D2DC4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825D2DC8: 38A0009D  li r5, 0x9d
	ctx.r[5].s64 = 157;
	// 825D2DCC: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 825D2DD0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825D2DD4: 48885C6D  bl 0x82e58a40
	ctx.lr = 0x825D2DD8;
	sub_82E58A40(ctx, base);
	// 825D2DD8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825D2DDC: 4881EEB5  bl 0x82df1c90
	ctx.lr = 0x825D2DE0;
	sub_82DF1C90(ctx, base);
	// 825D2DE0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825D2DE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D2DE8: 419A0008  beq cr6, 0x825d2df0
	if ctx.cr[6].eq {
	pc = 0x825D2DF0; continue 'dispatch;
	}
	// 825D2DEC: 4BCEDAA5  bl 0x822c0890
	ctx.lr = 0x825D2DF0;
	sub_822C0890(ctx, base);
	// 825D2DF0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825D2DF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D2DF8: 419A0008  beq cr6, 0x825d2e00
	if ctx.cr[6].eq {
	pc = 0x825D2E00; continue 'dispatch;
	}
	// 825D2DFC: 4BCEDA95  bl 0x822c0890
	ctx.lr = 0x825D2E00;
	sub_822C0890(ctx, base);
	// 825D2E00: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825D2E04: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D2E08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D2E0C: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 825D2E10: 419A0008  beq cr6, 0x825d2e18
	if ctx.cr[6].eq {
	pc = 0x825D2E18; continue 'dispatch;
	}
	// 825D2E14: 4BCEDA7D  bl 0x822c0890
	ctx.lr = 0x825D2E18;
	sub_822C0890(ctx, base);
	// 825D2E18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825D2E1C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825D2E20: 4BFFFD59  bl 0x825d2b78
	ctx.lr = 0x825D2E24;
	sub_825D2B78(ctx, base);
	// 825D2E24: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825D2E28: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825D2E2C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 825D2E30: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2E34: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825D2E38: 4BCF1629  bl 0x822c4460
	ctx.lr = 0x825D2E3C;
	sub_822C4460(ctx, base);
	// 825D2E3C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825D2E40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D2E44: 419A0008  beq cr6, 0x825d2e4c
	if ctx.cr[6].eq {
	pc = 0x825D2E4C; continue 'dispatch;
	}
	// 825D2E48: 4BCEDA49  bl 0x822c0890
	ctx.lr = 0x825D2E4C;
	sub_822C0890(ctx, base);
	// 825D2E4C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825D2E50: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2E54: 4BE9E185  bl 0x82470fd8
	ctx.lr = 0x825D2E58;
	sub_82470FD8(ctx, base);
	// 825D2E58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D2E5C: 4BFFF87D  bl 0x825d26d8
	ctx.lr = 0x825D2E60;
	sub_825D26D8(ctx, base);
	// 825D2E60: 39600BBB  li r11, 0xbbb
	ctx.r[11].s64 = 3003;
	// 825D2E64: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825D2E68: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825D2E6C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825D2E70: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825D2E74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825D2E78: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825D2E7C: 485995FD  bl 0x82b6c478
	ctx.lr = 0x825D2E80;
	sub_82B6C478(ctx, base);
	// 825D2E80: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2E84: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825D2E88: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D2E8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D2E90: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825D2E94: 419A0024  beq cr6, 0x825d2eb8
	if ctx.cr[6].eq {
	pc = 0x825D2EB8; continue 'dispatch;
	}
	// 825D2E98: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D2E9C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D2EA0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D2EA4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D2EA8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D2EAC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D2EB0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D2EB4: 4082FFE8  bne 0x825d2e9c
	if !ctx.cr[0].eq {
	pc = 0x825D2E9C; continue 'dispatch;
	}
	// 825D2EB8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D2EBC: 809E0120  lwz r4, 0x120(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(288 as u32) ) } as u64;
	// 825D2EC0: 4BF3C659  bl 0x8250f518
	ctx.lr = 0x825D2EC4;
	sub_8250F518(ctx, base);
	// 825D2EC4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D2EC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D2ECC: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 825D2ED0: 409A0008  bne cr6, 0x825d2ed8
	if !ctx.cr[6].eq {
	pc = 0x825D2ED8; continue 'dispatch;
	}
	// 825D2ED4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825D2ED8: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 825D2EDC: 4BF55175  bl 0x82528050
	ctx.lr = 0x825D2EE0;
	sub_82528050(ctx, base);
	// 825D2EE0: 817E0120  lwz r11, 0x120(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(288 as u32) ) } as u64;
	// 825D2EE4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825D2EE8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825D2EEC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825D2EF0: 38A000A5  li r5, 0xa5
	ctx.r[5].s64 = 165;
	// 825D2EF4: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 825D2EF8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 825D2EFC: 48885B45  bl 0x82e58a40
	ctx.lr = 0x825D2F00;
	sub_82E58A40(ctx, base);
	// 825D2F00: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825D2F04: 4881ED8D  bl 0x82df1c90
	ctx.lr = 0x825D2F08;
	sub_82DF1C90(ctx, base);
	// 825D2F08: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825D2F0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D2F10: 419A0008  beq cr6, 0x825d2f18
	if ctx.cr[6].eq {
	pc = 0x825D2F18; continue 'dispatch;
	}
	// 825D2F14: 4BCED97D  bl 0x822c0890
	ctx.lr = 0x825D2F18;
	sub_822C0890(ctx, base);
	// 825D2F18: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 825D2F1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D2F20: 419A0008  beq cr6, 0x825d2f28
	if ctx.cr[6].eq {
	pc = 0x825D2F28; continue 'dispatch;
	}
	// 825D2F24: 4BCED96D  bl 0x822c0890
	ctx.lr = 0x825D2F28;
	sub_822C0890(ctx, base);
	// 825D2F28: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 825D2F2C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825D2F30: 48BD5284  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D2F38 size=12
    let mut pc: u32 = 0x825D2F38;
    'dispatch: loop {
        match pc {
            0x825D2F38 => {
    //   block [0x825D2F38..0x825D2F44)
	// 825D2F38: 81630134  lwz r11, 0x134(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(308 as u32) ) } as u64;
	// 825D2F3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D2F40: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2F44(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D2F44 size=16
    let mut pc: u32 = 0x825D2F44;
    'dispatch: loop {
        match pc {
            0x825D2F44 => {
    //   block [0x825D2F44..0x825D2F54)
	// 825D2F44: 81430138  lwz r10, 0x138(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(312 as u32) ) } as u64;
	// 825D2F48: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825D2F4C: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D2F50: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2F54(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825D2F54 size=16
    let mut pc: u32 = 0x825D2F54;
    'dispatch: loop {
        match pc {
            0x825D2F54 => {
    //   block [0x825D2F54..0x825D2F64)
	// 825D2F54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D2F58: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D2F5C: D0030148  stfs f0, 0x148(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 825D2F60: 4BFFFDA8  b 0x825d2d08
	sub_825D2D08(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2F64(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D2F64 size=4
    let mut pc: u32 = 0x825D2F64;
    'dispatch: loop {
        match pc {
            0x825D2F64 => {
    //   block [0x825D2F64..0x825D2F68)
	// 825D2F64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D2F68 size=12
    let mut pc: u32 = 0x825D2F68;
    'dispatch: loop {
        match pc {
            0x825D2F68 => {
    //   block [0x825D2F68..0x825D2F74)
	// 825D2F68: 81630134  lwz r11, 0x134(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(308 as u32) ) } as u64;
	// 825D2F6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D2F70: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2F74(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D2F74 size=16
    let mut pc: u32 = 0x825D2F74;
    'dispatch: loop {
        match pc {
            0x825D2F74 => {
    //   block [0x825D2F74..0x825D2F84)
	// 825D2F74: 81430138  lwz r10, 0x138(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(312 as u32) ) } as u64;
	// 825D2F78: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825D2F7C: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D2F80: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2F84(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D2F84 size=8
    let mut pc: u32 = 0x825D2F84;
    'dispatch: loop {
        match pc {
            0x825D2F84 => {
    //   block [0x825D2F84..0x825D2F8C)
	// 825D2F84: 4BFFFD84  b 0x825d2d08
	sub_825D2D08(ctx, base);
	return;
	// 825D2F88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D2F90 size=20
    let mut pc: u32 = 0x825D2F90;
    'dispatch: loop {
        match pc {
            0x825D2F90 => {
    //   block [0x825D2F90..0x825D2FA4)
	// 825D2F90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825D2F94: 91630150  stw r11, 0x150(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 825D2F98: 81630134  lwz r11, 0x134(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(308 as u32) ) } as u64;
	// 825D2F9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D2FA0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2FA4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D2FA4 size=16
    let mut pc: u32 = 0x825D2FA4;
    'dispatch: loop {
        match pc {
            0x825D2FA4 => {
    //   block [0x825D2FA4..0x825D2FB4)
	// 825D2FA4: 81430138  lwz r10, 0x138(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(312 as u32) ) } as u64;
	// 825D2FA8: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825D2FAC: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D2FB0: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2FB4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825D2FB4 size=16
    let mut pc: u32 = 0x825D2FB4;
    'dispatch: loop {
        match pc {
            0x825D2FB4 => {
    //   block [0x825D2FB4..0x825D2FC4)
	// 825D2FB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825D2FB8: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825D2FBC: D0030148  stfs f0, 0x148(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 825D2FC0: 4BFFFD48  b 0x825d2d08
	sub_825D2D08(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2FC4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825D2FC4 size=4
    let mut pc: u32 = 0x825D2FC4;
    'dispatch: loop {
        match pc {
            0x825D2FC4 => {
    //   block [0x825D2FC4..0x825D2FC8)
	// 825D2FC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D2FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D2FC8 size=128
    let mut pc: u32 = 0x825D2FC8;
    'dispatch: loop {
        match pc {
            0x825D2FC8 => {
    //   block [0x825D2FC8..0x825D3048)
	// 825D2FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D2FCC: 48BD51A1  bl 0x831a816c
	ctx.lr = 0x825D2FD0;
	sub_831A8130(ctx, base);
	// 825D2FD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D2FD4: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825D2FD8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825D2FDC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D2FE0: 3BEB7D6C  addi r31, r11, 0x7d6c
	ctx.r[31].s64 = ctx.r[11].s64 + 32108;
	// 825D2FE4: 816A7D74  lwz r11, 0x7d74(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32116 as u32) ) } as u64;
	// 825D2FE8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D2FEC: 40820024  bne 0x825d3010
	if !ctx.cr[0].eq {
	pc = 0x825D3010; continue 'dispatch;
	}
	// 825D2FF0: 3D208256  lis r9, -0x7daa
	ctx.r[9].s64 = -2108293120;
	// 825D2FF4: 3D00825D  lis r8, -0x7da3
	ctx.r[8].s64 = -2107834368;
	// 825D2FF8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825D2FFC: 3929DA70  addi r9, r9, -0x2590
	ctx.r[9].s64 = ctx.r[9].s64 + -9616;
	// 825D3000: 39082978  addi r8, r8, 0x2978
	ctx.r[8].s64 = ctx.r[8].s64 + 10616;
	// 825D3004: 916A7D74  stw r11, 0x7d74(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32116 as u32), ctx.r[11].u32 ) };
	// 825D3008: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825D300C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825D3010: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825D3014: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825D3018: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D301C: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 825D3020: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825D3024: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D3028: 4BFFF8F9  bl 0x825d2920
	ctx.lr = 0x825D302C;
	sub_825D2920(ctx, base);
	// 825D302C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D3030: 4182000C  beq 0x825d303c
	if ctx.cr[0].eq {
	pc = 0x825D303C; continue 'dispatch;
	}
	// 825D3034: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D3038: 48000008  b 0x825d3040
	pc = 0x825D3040; continue 'dispatch;
	// 825D303C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825D3040: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825D3044: 48BD5178  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D3048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D3048 size=128
    let mut pc: u32 = 0x825D3048;
    'dispatch: loop {
        match pc {
            0x825D3048 => {
    //   block [0x825D3048..0x825D30C8)
	// 825D3048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D304C: 48BD5121  bl 0x831a816c
	ctx.lr = 0x825D3050;
	sub_831A8130(ctx, base);
	// 825D3050: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D3054: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825D3058: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825D305C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D3060: 3BEB7D78  addi r31, r11, 0x7d78
	ctx.r[31].s64 = ctx.r[11].s64 + 32120;
	// 825D3064: 816A7D80  lwz r11, 0x7d80(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32128 as u32) ) } as u64;
	// 825D3068: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D306C: 40820024  bne 0x825d3090
	if !ctx.cr[0].eq {
	pc = 0x825D3090; continue 'dispatch;
	}
	// 825D3070: 3D208256  lis r9, -0x7daa
	ctx.r[9].s64 = -2108293120;
	// 825D3074: 3D00825D  lis r8, -0x7da3
	ctx.r[8].s64 = -2107834368;
	// 825D3078: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825D307C: 3929DA70  addi r9, r9, -0x2590
	ctx.r[9].s64 = ctx.r[9].s64 + -9616;
	// 825D3080: 39082978  addi r8, r8, 0x2978
	ctx.r[8].s64 = ctx.r[8].s64 + 10616;
	// 825D3084: 916A7D80  stw r11, 0x7d80(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32128 as u32), ctx.r[11].u32 ) };
	// 825D3088: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825D308C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825D3090: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825D3094: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825D3098: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D309C: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 825D30A0: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825D30A4: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D30A8: 4BFFF879  bl 0x825d2920
	ctx.lr = 0x825D30AC;
	sub_825D2920(ctx, base);
	// 825D30AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D30B0: 4182000C  beq 0x825d30bc
	if ctx.cr[0].eq {
	pc = 0x825D30BC; continue 'dispatch;
	}
	// 825D30B4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D30B8: 48000008  b 0x825d30c0
	pc = 0x825D30C0; continue 'dispatch;
	// 825D30BC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825D30C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825D30C4: 48BD50F8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D30C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D30C8 size=128
    let mut pc: u32 = 0x825D30C8;
    'dispatch: loop {
        match pc {
            0x825D30C8 => {
    //   block [0x825D30C8..0x825D3148)
	// 825D30C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D30CC: 48BD50A1  bl 0x831a816c
	ctx.lr = 0x825D30D0;
	sub_831A8130(ctx, base);
	// 825D30D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D30D4: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825D30D8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825D30DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D30E0: 3BEB7D84  addi r31, r11, 0x7d84
	ctx.r[31].s64 = ctx.r[11].s64 + 32132;
	// 825D30E4: 816A7D8C  lwz r11, 0x7d8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32140 as u32) ) } as u64;
	// 825D30E8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D30EC: 40820024  bne 0x825d3110
	if !ctx.cr[0].eq {
	pc = 0x825D3110; continue 'dispatch;
	}
	// 825D30F0: 3D208256  lis r9, -0x7daa
	ctx.r[9].s64 = -2108293120;
	// 825D30F4: 3D00825D  lis r8, -0x7da3
	ctx.r[8].s64 = -2107834368;
	// 825D30F8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825D30FC: 3929DA70  addi r9, r9, -0x2590
	ctx.r[9].s64 = ctx.r[9].s64 + -9616;
	// 825D3100: 39082978  addi r8, r8, 0x2978
	ctx.r[8].s64 = ctx.r[8].s64 + 10616;
	// 825D3104: 916A7D8C  stw r11, 0x7d8c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32140 as u32), ctx.r[11].u32 ) };
	// 825D3108: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825D310C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825D3110: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825D3114: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825D3118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D311C: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 825D3120: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825D3124: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D3128: 4BFFF7F9  bl 0x825d2920
	ctx.lr = 0x825D312C;
	sub_825D2920(ctx, base);
	// 825D312C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D3130: 4182000C  beq 0x825d313c
	if ctx.cr[0].eq {
	pc = 0x825D313C; continue 'dispatch;
	}
	// 825D3134: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D3138: 48000008  b 0x825d3140
	pc = 0x825D3140; continue 'dispatch;
	// 825D313C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825D3140: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825D3144: 48BD5078  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D3148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825D3148 size=128
    let mut pc: u32 = 0x825D3148;
    'dispatch: loop {
        match pc {
            0x825D3148 => {
    //   block [0x825D3148..0x825D31C8)
	// 825D3148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D314C: 48BD5021  bl 0x831a816c
	ctx.lr = 0x825D3150;
	sub_831A8130(ctx, base);
	// 825D3150: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D3154: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825D3158: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825D315C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825D3160: 3BEB7D90  addi r31, r11, 0x7d90
	ctx.r[31].s64 = ctx.r[11].s64 + 32144;
	// 825D3164: 816A7D98  lwz r11, 0x7d98(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32152 as u32) ) } as u64;
	// 825D3168: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825D316C: 40820024  bne 0x825d3190
	if !ctx.cr[0].eq {
	pc = 0x825D3190; continue 'dispatch;
	}
	// 825D3170: 3D208256  lis r9, -0x7daa
	ctx.r[9].s64 = -2108293120;
	// 825D3174: 3D00825D  lis r8, -0x7da3
	ctx.r[8].s64 = -2107834368;
	// 825D3178: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825D317C: 3929DA70  addi r9, r9, -0x2590
	ctx.r[9].s64 = ctx.r[9].s64 + -9616;
	// 825D3180: 39082978  addi r8, r8, 0x2978
	ctx.r[8].s64 = ctx.r[8].s64 + 10616;
	// 825D3184: 916A7D98  stw r11, 0x7d98(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32152 as u32), ctx.r[11].u32 ) };
	// 825D3188: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825D318C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825D3190: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825D3194: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825D3198: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D319C: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 825D31A0: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825D31A4: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825D31A8: 4BFFF779  bl 0x825d2920
	ctx.lr = 0x825D31AC;
	sub_825D2920(ctx, base);
	// 825D31AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825D31B0: 4182000C  beq 0x825d31bc
	if ctx.cr[0].eq {
	pc = 0x825D31BC; continue 'dispatch;
	}
	// 825D31B4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825D31B8: 48000008  b 0x825d31c0
	pc = 0x825D31C0; continue 'dispatch;
	// 825D31BC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825D31C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825D31C4: 48BD4FF8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825D31C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825D31C8 size=336
    let mut pc: u32 = 0x825D31C8;
    'dispatch: loop {
        match pc {
            0x825D31C8 => {
    //   block [0x825D31C8..0x825D3318)
	// 825D31C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825D31CC: 48BD4FA1  bl 0x831a816c
	ctx.lr = 0x825D31D0;
	sub_831A8130(ctx, base);
	// 825D31D0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 825D31D4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825D31D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825D31DC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825D31E0: 394AE0B4  addi r10, r10, -0x1f4c
	ctx.r[10].s64 = ctx.r[10].s64 + -8012;
	// 825D31E4: 817F0140  lwz r11, 0x140(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 825D31E8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825D31EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D31F0: 419A00EC  beq cr6, 0x825d32dc
	if ctx.cr[6].eq {
	pc = 0x825D32DC; continue 'dispatch;
	}
	// 825D31F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825D31F8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825D31FC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 825D3200: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825D3204: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825D3208: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825D320C: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825D3210: 48273401  bl 0x82846610
	ctx.lr = 0x825D3214;
	sub_82846610(ctx, base);
	// 825D3214: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D3218: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825D321C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825D3220: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D3224: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825D3228: 419A0024  beq cr6, 0x825d324c
	if ctx.cr[6].eq {
	pc = 0x825D324C; continue 'dispatch;
	}
	// 825D322C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825D3230: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825D3234: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D3238: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825D323C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825D3240: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825D3244: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825D3248: 4082FFE8  bne 0x825d3230
	if !ctx.cr[0].eq {
	pc = 0x825D3230; continue 'dispatch;
	}
	// 825D324C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D3250: 809F0120  lwz r4, 0x120(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 825D3254: 4BF3C2C5  bl 0x8250f518
	ctx.lr = 0x825D3258;
	sub_8250F518(ctx, base);
	// 825D3258: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825D325C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825D3260: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825D3264: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 825D3268: 409A0008  bne cr6, 0x825d3270
	if !ctx.cr[6].eq {
	pc = 0x825D3270; continue 'dispatch;
	}
	// 825D326C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825D3270: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 825D3274: 4BF54DDD  bl 0x82528050
	ctx.lr = 0x825D3278;
	sub_82528050(ctx, base);
	// 825D3278: 817F0120  lwz r11, 0x120(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 825D327C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825D3280: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825D3284: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825D3288: 388AE060  addi r4, r10, -0x1fa0
	ctx.r[4].s64 = ctx.r[10].s64 + -8096;
	// 825D328C: 38A0003D  li r5, 0x3d
	ctx.r[5].s64 = 61;
	// 825D3290: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 825D3294: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 825D3298: 488857A9  bl 0x82e58a40
	ctx.lr = 0x825D329C;
	sub_82E58A40(ctx, base);
	// 825D329C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825D32A0: 4881E9F1  bl 0x82df1c90
	ctx.lr = 0x825D32A4;
	sub_82DF1C90(ctx, base);
	// 825D32A4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825D32A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D32AC: 419A0008  beq cr6, 0x825d32b4
	if ctx.cr[6].eq {
	pc = 0x825D32B4; continue 'dispatch;
	}
	// 825D32B0: 4BCED5E1  bl 0x822c0890
	ctx.lr = 0x825D32B4;
	sub_822C0890(ctx, base);
	// 825D32B4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825D32B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D32BC: 419A0008  beq cr6, 0x825d32c4
	if ctx.cr[6].eq {
	pc = 0x825D32C4; continue 'dispatch;
	}
	// 825D32C0: 4BCED5D1  bl 0x822c0890
	ctx.lr = 0x825D32C4;
	sub_822C0890(ctx, base);
	// 825D32C4: 93DF0140  stw r30, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[30].u32 ) };
	// 825D32C8: 807F0144  lwz r3, 0x144(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 825D32CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D32D0: 93DF0144  stw r30, 0x144(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), ctx.r[30].u32 ) };
	// 825D32D4: 419A0008  beq cr6, 0x825d32dc
	if ctx.cr[6].eq {
	pc = 0x825D32DC; continue 'dispatch;
	}
	// 825D32D8: 4BCED5B9  bl 0x822c0890
	ctx.lr = 0x825D32DC;
	sub_822C0890(ctx, base);
	// 825D32DC: 807F0144  lwz r3, 0x144(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 825D32E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D32E4: 419A0008  beq cr6, 0x825d32ec
	if ctx.cr[6].eq {
	pc = 0x825D32EC; continue 'dispatch;
	}
	// 825D32E8: 4BCED5A9  bl 0x822c0890
	ctx.lr = 0x825D32EC;
	sub_822C0890(ctx, base);
	// 825D32EC: 387F0130  addi r3, r31, 0x130
	ctx.r[3].s64 = ctx.r[31].s64 + 304;
	// 825D32F0: 4BDFF0F9  bl 0x823d23e8
	ctx.lr = 0x825D32F4;
	sub_823D23E8(ctx, base);
	// 825D32F4: 807F0128  lwz r3, 0x128(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 825D32F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825D32FC: 419A0008  beq cr6, 0x825d3304
	if ctx.cr[6].eq {
	pc = 0x825D3304; continue 'dispatch;
	}
	// 825D3300: 4BCED591  bl 0x822c0890
	ctx.lr = 0x825D3304;
	sub_822C0890(ctx, base);
	// 825D3304: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825D3308: 4BFE1099  bl 0x825b43a0
	ctx.lr = 0x825D330C;
	sub_825B43A0(ctx, base);
	// 825D330C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825D3310: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 825D3314: 48BD4EA8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


