pub fn sub_82A634B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A634B0 size=44
    let mut pc: u32 = 0x82A634B0;
    'dispatch: loop {
        match pc {
            0x82A634B0 => {
    //   block [0x82A634B0..0x82A634DC)
	// 82A634B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A634B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A634B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A634BC: 4BAAEBAD  bl 0x82512068
	ctx.lr = 0x82A634C0;
	sub_82512068(ctx, base);
	// 82A634C0: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A634C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A634C8: 916ADFD4  stw r11, -0x202c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8236 as u32), ctx.r[11].u32 ) };
	// 82A634CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A634D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A634D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A634D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A634E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A634E0 size=72
    let mut pc: u32 = 0x82A634E0;
    'dispatch: loop {
        match pc {
            0x82A634E0 => {
    //   block [0x82A634E0..0x82A63528)
	// 82A634E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A634E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A634E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A634EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A634F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A634F4: 897F00E4  lbz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A634F8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A634FC: 40820018  bne 0x82a63514
	if !ctx.cr[0].eq {
	pc = 0x82A63514; continue 'dispatch;
	}
	// 82A63500: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A63504: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82A63508: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A6350C: 4E800421  bctrl
	ctx.lr = 0x82A63510;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A63510: 987F00E4  stb r3, 0xe4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[3].u8 ) };
	// 82A63514: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A63518: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6351C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A63520: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A63524: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A63528 size=12
    let mut pc: u32 = 0x82A63528;
    'dispatch: loop {
        match pc {
            0x82A63528 => {
    //   block [0x82A63528..0x82A63534)
	// 82A63528: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A6352C: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A63530: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63534(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A63534 size=8
    let mut pc: u32 = 0x82A63534;
    'dispatch: loop {
        match pc {
            0x82A63534 => {
    //   block [0x82A63534..0x82A6353C)
	// 82A63534: 4BAAD09C  b 0x825105d0
	sub_825105D0(ctx, base);
	return;
	// 82A63538: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A63540 size=4
    let mut pc: u32 = 0x82A63540;
    'dispatch: loop {
        match pc {
            0x82A63540 => {
    //   block [0x82A63540..0x82A63544)
	// 82A63540: 4BFFFFA0  b 0x82a634e0
	sub_82A634E0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A63548 size=196
    let mut pc: u32 = 0x82A63548;
    'dispatch: loop {
        match pc {
            0x82A63548 => {
    //   block [0x82A63548..0x82A6360C)
	// 82A63548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6354C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A63550: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A63554: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A63558: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6355C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A63560: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A63564: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A63568: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A6356C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A63570: 4B85D3C9  bl 0x822c0938
	ctx.lr = 0x82A63574;
	sub_822C0938(ctx, base);
	// 82A63574: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A63578: 41820028  beq 0x82a635a0
	if ctx.cr[0].eq {
	pc = 0x82A635A0; continue 'dispatch;
	}
	// 82A6357C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A63580: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A63584: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A63588: 392BF514  addi r9, r11, -0xaec
	ctx.r[9].s64 = ctx.r[11].s64 + -2796;
	// 82A6358C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A63590: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A63594: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A63598: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A6359C: 48000008  b 0x82a635a4
	pc = 0x82A635A4; continue 'dispatch;
	// 82A635A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A635A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A635A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A635AC: 409A0044  bne cr6, 0x82a635f0
	if !ctx.cr[6].eq {
	pc = 0x82A635F0; continue 'dispatch;
	}
	// 82A635B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A635B4: 419A001C  beq cr6, 0x82a635d0
	if ctx.cr[6].eq {
	pc = 0x82A635D0; continue 'dispatch;
	}
	// 82A635B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A635BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A635C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A635C4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A635C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A635CC: 4E800421  bctrl
	ctx.lr = 0x82A635D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A635D0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A635D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A635D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A635DC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A635E0: 816B650C  lwz r11, 0x650c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25868 as u32) ) } as u64;
	// 82A635E4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A635E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A635EC: 4B85CA15  bl 0x822c0000
	ctx.lr = 0x82A635F0;
	sub_822C0000(ctx, base);
	// 82A635F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A635F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A635F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A635FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A63600: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A63604: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A63608: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A63610 size=368
    let mut pc: u32 = 0x82A63610;
    'dispatch: loop {
        match pc {
            0x82A63610 => {
    //   block [0x82A63610..0x82A63780)
	// 82A63610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A63614: 48744B59  bl 0x831a816c
	ctx.lr = 0x82A63618;
	sub_831A8130(ctx, base);
	// 82A63618: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6361C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A63620: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A63624: 396B6500  addi r11, r11, 0x6500
	ctx.r[11].s64 = ctx.r[11].s64 + 25856;
	// 82A63628: 2B050002  cmplwi cr6, r5, 2
	ctx.cr[6].compare_u32(ctx.r[5].u32, 2 as u32, &mut ctx.xer);
	// 82A6362C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A63630: 7CAA582E  lwzx r5, r10, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A63634: 419800A0  blt cr6, 0x82a636d4
	if ctx.cr[6].lt {
	pc = 0x82A636D4; continue 'dispatch;
	}
	// 82A63638: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6363C: 4801BA9D  bl 0x82a7f0d8
	ctx.lr = 0x82A63640;
	sub_82A7F0D8(ctx, base);
	// 82A63640: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A63644: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A63648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6364C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A63650: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82A63654: 419A0024  beq cr6, 0x82a63678
	if ctx.cr[6].eq {
	pc = 0x82A63678; continue 'dispatch;
	}
	// 82A63658: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6365C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A63660: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A63664: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A63668: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6366C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A63670: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A63674: 4082FFE8  bne 0x82a6365c
	if !ctx.cr[0].eq {
	pc = 0x82A6365C; continue 'dispatch;
	}
	// 82A63678: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A6367C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A63680: 4BAABE49  bl 0x8250f4c8
	ctx.lr = 0x82A63684;
	sub_8250F4C8(ctx, base);
	// 82A63684: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A63688: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6368C: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82A63690: 409A0008  bne cr6, 0x82a63698
	if !ctx.cr[6].eq {
	pc = 0x82A63698; continue 'dispatch;
	}
	// 82A63694: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A63698: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A6369C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A636A0: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A636A4: 4BAABE75  bl 0x8250f518
	ctx.lr = 0x82A636A8;
	sub_8250F518(ctx, base);
	// 82A636A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A636AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A636B0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A636B4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A636B8: 4BAA9E51  bl 0x8250d508
	ctx.lr = 0x82A636BC;
	sub_8250D508(ctx, base);
	// 82A636BC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A636C0: 4838E5D1  bl 0x82df1c90
	ctx.lr = 0x82A636C4;
	sub_82DF1C90(ctx, base);
	// 82A636C4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A636C8: 4838E5C9  bl 0x82df1c90
	ctx.lr = 0x82A636CC;
	sub_82DF1C90(ctx, base);
	// 82A636CC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A636D0: 4800009C  b 0x82a6376c
	pc = 0x82A6376C; continue 'dispatch;
	// 82A636D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A636D8: 4801C3A1  bl 0x82a7fa78
	ctx.lr = 0x82A636DC;
	sub_82A7FA78(ctx, base);
	// 82A636DC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A636E0: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A636E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A636E8: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A636EC: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82A636F0: 419A0024  beq cr6, 0x82a63714
	if ctx.cr[6].eq {
	pc = 0x82A63714; continue 'dispatch;
	}
	// 82A636F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A636F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A636FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A63700: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A63704: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A63708: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6370C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A63710: 4082FFE8  bne 0x82a636f8
	if !ctx.cr[0].eq {
	pc = 0x82A636F8; continue 'dispatch;
	}
	// 82A63714: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A63718: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A6371C: 4BAABDAD  bl 0x8250f4c8
	ctx.lr = 0x82A63720;
	sub_8250F4C8(ctx, base);
	// 82A63720: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A63724: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A63728: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82A6372C: 409A0008  bne cr6, 0x82a63734
	if !ctx.cr[6].eq {
	pc = 0x82A63734; continue 'dispatch;
	}
	// 82A63730: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A63734: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A63738: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A6373C: 3BA10068  addi r29, r1, 0x68
	ctx.r[29].s64 = ctx.r[1].s64 + 104;
	// 82A63740: 4BAABDD9  bl 0x8250f518
	ctx.lr = 0x82A63744;
	sub_8250F518(ctx, base);
	// 82A63744: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A63748: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6374C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A63750: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A63754: 4BAA9DB5  bl 0x8250d508
	ctx.lr = 0x82A63758;
	sub_8250D508(ctx, base);
	// 82A63758: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A6375C: 4838E535  bl 0x82df1c90
	ctx.lr = 0x82A63760;
	sub_82DF1C90(ctx, base);
	// 82A63760: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A63764: 4838E52D  bl 0x82df1c90
	ctx.lr = 0x82A63768;
	sub_82DF1C90(ctx, base);
	// 82A63768: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6376C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A63770: 419A0008  beq cr6, 0x82a63778
	if ctx.cr[6].eq {
	pc = 0x82A63778; continue 'dispatch;
	}
	// 82A63774: 4B85D11D  bl 0x822c0890
	ctx.lr = 0x82A63778;
	sub_822C0890(ctx, base);
	// 82A63778: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A6377C: 48744A40  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A63780 size=564
    let mut pc: u32 = 0x82A63780;
    'dispatch: loop {
        match pc {
            0x82A63780 => {
    //   block [0x82A63780..0x82A639B4)
	// 82A63780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A63784: 487449D5  bl 0x831a8158
	ctx.lr = 0x82A63788;
	sub_831A8130(ctx, base);
	// 82A63788: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6378C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A63790: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82A63794: 396B6510  addi r11, r11, 0x6510
	ctx.r[11].s64 = ctx.r[11].s64 + 25872;
	// 82A63798: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A6379C: 3BEB0030  addi r31, r11, 0x30
	ctx.r[31].s64 = ctx.r[11].s64 + 48;
	// 82A637A0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A637A4: 3B000003  li r24, 3
	ctx.r[24].s64 = 3;
	// 82A637A8: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 82A637AC: 817FFFD4  lwz r11, -0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-44 as u32) ) } as u64;
	// 82A637B0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82A637B4: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82A637B8: 419A0008  beq cr6, 0x82a637c0
	if ctx.cr[6].eq {
	pc = 0x82A637C0; continue 'dispatch;
	}
	// 82A637BC: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 82A637C0: 3B7FFFF0  addi r27, r31, -0x10
	ctx.r[27].s64 = ctx.r[31].s64 + -16;
	// 82A637C4: 3B5FFFE0  addi r26, r31, -0x20
	ctx.r[26].s64 = ctx.r[31].s64 + -32;
	// 82A637C8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A637CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A637D0: 4804AC49  bl 0x82aae418
	ctx.lr = 0x82A637D4;
	sub_82AAE418(ctx, base);
	// 82A637D4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A637D8: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A637DC: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82A637E0: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A637E4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A637E8: C19D0008  lfs f12, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A637EC: C17D000C  lfs f11, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A637F0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A637F4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A637F8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A637FC: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82A63800: D1A100A4  stfs f13, 0xa4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82A63804: D18100A8  stfs f12, 0xa8(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82A63808: D16100AC  stfs f11, 0xac(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82A6380C: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 82A63810: 91210094  stw r9, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 82A63814: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82A63818: 4804AB29  bl 0x82aae340
	ctx.lr = 0x82A6381C;
	sub_82AAE340(ctx, base);
	// 82A6381C: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 82A63820: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82A63824: C03F0000  lfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A63828: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A6382C: 80BFFFD4  lwz r5, -0x2c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-44 as u32) ) } as u64;
	// 82A63830: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A63834: 4BFFFDDD  bl 0x82a63610
	ctx.lr = 0x82A63838;
	sub_82A63610(ctx, base);
	// 82A63838: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A6383C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82A63840: 4082FF88  bne 0x82a637c8
	if !ctx.cr[0].eq {
	pc = 0x82A637C8; continue 'dispatch;
	}
	// 82A63844: 3718FFFF  addic. r24, r24, -1
	ctx.xer.ca = (ctx.r[24].u32 > (!(-1 as u32)));
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 82A63848: 3BFF0040  addi r31, r31, 0x40
	ctx.r[31].s64 = ctx.r[31].s64 + 64;
	// 82A6384C: 4082FF60  bne 0x82a637ac
	if !ctx.cr[0].eq {
	pc = 0x82A637AC; continue 'dispatch;
	}
	// 82A63850: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A63854: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A63858: C02BF50C  lfs f1, -0xaf4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2804 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A6385C: 48001A35  bl 0x82a65290
	ctx.lr = 0x82A63860;
	sub_82A65290(ctx, base);
	// 82A63860: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A63864: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A63868: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6386C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A63870: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82A63874: 419A0024  beq cr6, 0x82a63898
	if ctx.cr[6].eq {
	pc = 0x82A63898; continue 'dispatch;
	}
	// 82A63878: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6387C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A63880: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A63884: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A63888: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6388C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A63890: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A63894: 4082FFE8  bne 0x82a6387c
	if !ctx.cr[0].eq {
	pc = 0x82A6387C; continue 'dispatch;
	}
	// 82A63898: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A6389C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A638A0: 4BAABC29  bl 0x8250f4c8
	ctx.lr = 0x82A638A4;
	sub_8250F4C8(ctx, base);
	// 82A638A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A638A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A638AC: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82A638B0: 409A0008  bne cr6, 0x82a638b8
	if !ctx.cr[6].eq {
	pc = 0x82A638B8; continue 'dispatch;
	}
	// 82A638B4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A638B8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A638BC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A638C0: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 82A638C4: 4BAABC55  bl 0x8250f518
	ctx.lr = 0x82A638C8;
	sub_8250F518(ctx, base);
	// 82A638C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A638CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A638D0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A638D4: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 82A638D8: 4BAA9C31  bl 0x8250d508
	ctx.lr = 0x82A638DC;
	sub_8250D508(ctx, base);
	// 82A638DC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A638E0: 4838E3B1  bl 0x82df1c90
	ctx.lr = 0x82A638E4;
	sub_82DF1C90(ctx, base);
	// 82A638E4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A638E8: 4838E3A9  bl 0x82df1c90
	ctx.lr = 0x82A638EC;
	sub_82DF1C90(ctx, base);
	// 82A638EC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A638F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A638F4: 419A0008  beq cr6, 0x82a638fc
	if ctx.cr[6].eq {
	pc = 0x82A638FC; continue 'dispatch;
	}
	// 82A638F8: 4B85CF99  bl 0x822c0890
	ctx.lr = 0x82A638FC;
	sub_822C0890(ctx, base);
	// 82A638FC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A63900: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A63904: C02BF524  lfs f1, -0xadc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2780 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A63908: 48001989  bl 0x82a65290
	ctx.lr = 0x82A6390C;
	sub_82A65290(ctx, base);
	// 82A6390C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A63910: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A63914: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A63918: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A6391C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82A63920: 419A0024  beq cr6, 0x82a63944
	if ctx.cr[6].eq {
	pc = 0x82A63944; continue 'dispatch;
	}
	// 82A63924: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A63928: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6392C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A63930: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A63934: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A63938: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6393C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A63940: 4082FFE8  bne 0x82a63928
	if !ctx.cr[0].eq {
	pc = 0x82A63928; continue 'dispatch;
	}
	// 82A63944: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A63948: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A6394C: 4BAABB7D  bl 0x8250f4c8
	ctx.lr = 0x82A63950;
	sub_8250F4C8(ctx, base);
	// 82A63950: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A63954: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A63958: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82A6395C: 409A0008  bne cr6, 0x82a63964
	if !ctx.cr[6].eq {
	pc = 0x82A63964; continue 'dispatch;
	}
	// 82A63960: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A63964: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A63968: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A6396C: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 82A63970: 4BAABBA9  bl 0x8250f518
	ctx.lr = 0x82A63974;
	sub_8250F518(ctx, base);
	// 82A63974: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A63978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6397C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A63980: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 82A63984: 4BAA9B85  bl 0x8250d508
	ctx.lr = 0x82A63988;
	sub_8250D508(ctx, base);
	// 82A63988: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A6398C: 4838E305  bl 0x82df1c90
	ctx.lr = 0x82A63990;
	sub_82DF1C90(ctx, base);
	// 82A63990: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A63994: 4838E2FD  bl 0x82df1c90
	ctx.lr = 0x82A63998;
	sub_82DF1C90(ctx, base);
	// 82A63998: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6399C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A639A0: 419A0008  beq cr6, 0x82a639a8
	if ctx.cr[6].eq {
	pc = 0x82A639A8; continue 'dispatch;
	}
	// 82A639A4: 4B85CEED  bl 0x822c0890
	ctx.lr = 0x82A639A8;
	sub_822C0890(ctx, base);
	// 82A639A8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A639AC: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82A639B0: 487447F8  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A639B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A639B8 size=100
    let mut pc: u32 = 0x82A639B8;
    'dispatch: loop {
        match pc {
            0x82A639B8 => {
    //   block [0x82A639B8..0x82A63A1C)
	// 82A639B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A639BC: 487447B1  bl 0x831a816c
	ctx.lr = 0x82A639C0;
	sub_831A8130(ctx, base);
	// 82A639C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A639C4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A639C8: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82A639CC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A639D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A639D4: 4BE54B1D  bl 0x828b84f0
	ctx.lr = 0x82A639D8;
	sub_828B84F0(ctx, base);
	// 82A639D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A639DC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82A639E0: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A639E4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A639E8: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A639EC: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A639F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A639F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A639F8: 4B9F6D21  bl 0x8245a718
	ctx.lr = 0x82A639FC;
	sub_8245A718(ctx, base);
	// 82A639FC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82A63A00: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A63A04: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A63A08: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A63A0C: 4BAB926D  bl 0x8251cc78
	ctx.lr = 0x82A63A10;
	sub_8251CC78(ctx, base);
	// 82A63A10: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A63A14: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A63A18: 487447A4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A63A20 size=12
    let mut pc: u32 = 0x82A63A20;
    'dispatch: loop {
        match pc {
            0x82A63A20 => {
    //   block [0x82A63A20..0x82A63A2C)
	// 82A63A20: 38840018  addi r4, r4, 0x18
	ctx.r[4].s64 = ctx.r[4].s64 + 24;
	// 82A63A24: 386300E8  addi r3, r3, 0xe8
	ctx.r[3].s64 = ctx.r[3].s64 + 232;
	// 82A63A28: 4BFFFF90  b 0x82a639b8
	sub_82A639B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A63A30 size=276
    let mut pc: u32 = 0x82A63A30;
    'dispatch: loop {
        match pc {
            0x82A63A30 => {
    //   block [0x82A63A30..0x82A63B44)
	// 82A63A30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A63A34: 48744735  bl 0x831a8168
	ctx.lr = 0x82A63A38;
	sub_831A8130(ctx, base);
	// 82A63A38: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A63A3C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A63A40: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A63A44: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A63A48: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A63A4C: 41820038  beq 0x82a63a84
	if ctx.cr[0].eq {
	pc = 0x82A63A84; continue 'dispatch;
	}
	// 82A63A50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A63A54: 48745F35  bl 0x831a9988
	ctx.lr = 0x82A63A58;
	sub_831A9988(ctx, base);
	// 82A63A58: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A63A5C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A63A60: 386B6698  addi r3, r11, 0x6698
	ctx.r[3].s64 = ctx.r[11].s64 + 26264;
	// 82A63A64: 48744695  bl 0x831a80f8
	ctx.lr = 0x82A63A68;
	sub_831A80F8(ctx, base);
	// 82A63A68: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A63A6C: 41820018  beq 0x82a63a84
	if ctx.cr[0].eq {
	pc = 0x82A63A84; continue 'dispatch;
	}
	// 82A63A70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A63A74: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A63A78: 480598C9  bl 0x82abd340
	ctx.lr = 0x82A63A7C;
	sub_82ABD340(ctx, base);
	// 82A63A7C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A63A80: 480000BC  b 0x82a63b3c
	pc = 0x82A63B3C; continue 'dispatch;
	// 82A63A84: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A63A88: 419A0074  beq cr6, 0x82a63afc
	if ctx.cr[6].eq {
	pc = 0x82A63AFC; continue 'dispatch;
	}
	// 82A63A8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A63A90: 48745EF9  bl 0x831a9988
	ctx.lr = 0x82A63A94;
	sub_831A9988(ctx, base);
	// 82A63A94: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A63A98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A63A9C: 386B6668  addi r3, r11, 0x6668
	ctx.r[3].s64 = ctx.r[11].s64 + 26216;
	// 82A63AA0: 48744659  bl 0x831a80f8
	ctx.lr = 0x82A63AA4;
	sub_831A80F8(ctx, base);
	// 82A63AA4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A63AA8: 41820014  beq 0x82a63abc
	if ctx.cr[0].eq {
	pc = 0x82A63ABC; continue 'dispatch;
	}
	// 82A63AAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A63AB0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A63AB4: 4BFFFF6D  bl 0x82a63a20
	ctx.lr = 0x82A63AB8;
	sub_82A63A20(ctx, base);
	// 82A63AB8: 4BFFFFC4  b 0x82a63a7c
	pc = 0x82A63A7C; continue 'dispatch;
	// 82A63ABC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A63AC0: 419A003C  beq cr6, 0x82a63afc
	if ctx.cr[6].eq {
	pc = 0x82A63AFC; continue 'dispatch;
	}
	// 82A63AC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A63AC8: 48745EC1  bl 0x831a9988
	ctx.lr = 0x82A63ACC;
	sub_831A9988(ctx, base);
	// 82A63ACC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A63AD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A63AD4: 386B6630  addi r3, r11, 0x6630
	ctx.r[3].s64 = ctx.r[11].s64 + 26160;
	// 82A63AD8: 48744621  bl 0x831a80f8
	ctx.lr = 0x82A63ADC;
	sub_831A80F8(ctx, base);
	// 82A63ADC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A63AE0: 41820014  beq 0x82a63af4
	if ctx.cr[0].eq {
	pc = 0x82A63AF4; continue 'dispatch;
	}
	// 82A63AE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A63AE8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A63AEC: 480A8CB5  bl 0x82b0c7a0
	ctx.lr = 0x82A63AF0;
	sub_82B0C7A0(ctx, base);
	// 82A63AF0: 4BFFFF8C  b 0x82a63a7c
	pc = 0x82A63A7C; continue 'dispatch;
	// 82A63AF4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A63AF8: 409A0034  bne cr6, 0x82a63b2c
	if !ctx.cr[6].eq {
	pc = 0x82A63B2C; continue 'dispatch;
	}
	// 82A63AFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A63B00: 48745E89  bl 0x831a9988
	ctx.lr = 0x82A63B04;
	sub_831A9988(ctx, base);
	// 82A63B04: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A63B08: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A63B0C: 386B5A88  addi r3, r11, 0x5a88
	ctx.r[3].s64 = ctx.r[11].s64 + 23176;
	// 82A63B10: 487445E9  bl 0x831a80f8
	ctx.lr = 0x82A63B14;
	sub_831A80F8(ctx, base);
	// 82A63B14: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A63B18: 41820014  beq 0x82a63b2c
	if ctx.cr[0].eq {
	pc = 0x82A63B2C; continue 'dispatch;
	}
	// 82A63B1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A63B20: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A63B24: 4BFFFA05  bl 0x82a63528
	ctx.lr = 0x82A63B28;
	sub_82A63528(ctx, base);
	// 82A63B28: 4BFFFF54  b 0x82a63a7c
	pc = 0x82A63A7C; continue 'dispatch;
	// 82A63B2C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A63B30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A63B34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A63B38: 4BAAEAE1  bl 0x82512618
	ctx.lr = 0x82A63B3C;
	sub_82512618(ctx, base);
	// 82A63B3C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A63B40: 48744678  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A63B48 size=92
    let mut pc: u32 = 0x82A63B48;
    'dispatch: loop {
        match pc {
            0x82A63B48 => {
    //   block [0x82A63B48..0x82A63BA4)
	// 82A63B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A63B4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A63B50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A63B54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A63B58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A63B5C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A63B60: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A63B64: 3D208338  lis r9, -0x7cc8
	ctx.r[9].s64 = -2093481984;
	// 82A63B68: 390BF544  addi r8, r11, -0xabc
	ctx.r[8].s64 = ctx.r[11].s64 + -2748;
	// 82A63B6C: 394AF52C  addi r10, r10, -0xad4
	ctx.r[10].s64 = ctx.r[10].s64 + -2772;
	// 82A63B70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A63B74: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A63B78: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82A63B7C: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 82A63B80: 9169DFD4  stw r11, -0x202c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-8236 as u32), ctx.r[11].u32 ) };
	// 82A63B84: 4BD49665  bl 0x827ad1e8
	ctx.lr = 0x82A63B88;
	sub_827AD1E8(ctx, base);
	// 82A63B88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A63B8C: 4B8EB7C5  bl 0x8234f350
	ctx.lr = 0x82A63B90;
	sub_8234F350(ctx, base);
	// 82A63B90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A63B94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A63B98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A63B9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A63BA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A63BA8 size=8
    let mut pc: u32 = 0x82A63BA8;
    'dispatch: loop {
        match pc {
            0x82A63BA8 => {
    //   block [0x82A63BA8..0x82A63BB0)
	// 82A63BA8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82A63BAC: 4800005C  b 0x82a63c08
	sub_82A63C08(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63BB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A63BB0 size=88
    let mut pc: u32 = 0x82A63BB0;
    'dispatch: loop {
        match pc {
            0x82A63BB0 => {
    //   block [0x82A63BB0..0x82A63C08)
	// 82A63BB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A63BB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A63BB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A63BBC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A63BC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A63BC4: 4BAAE76D  bl 0x82512330
	ctx.lr = 0x82A63BC8;
	sub_82512330(ctx, base);
	// 82A63BC8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A63BCC: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A63BD0: 396BF544  addi r11, r11, -0xabc
	ctx.r[11].s64 = ctx.r[11].s64 + -2748;
	// 82A63BD4: 394AF52C  addi r10, r10, -0xad4
	ctx.r[10].s64 = ctx.r[10].s64 + -2772;
	// 82A63BD8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A63BDC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A63BE0: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82A63BE4: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 82A63BE8: 993F00E4  stb r9, 0xe4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u8 ) };
	// 82A63BEC: 4B8A583D  bl 0x82309428
	ctx.lr = 0x82A63BF0;
	sub_82309428(ctx, base);
	// 82A63BF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A63BF4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A63BF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A63BFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A63C00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A63C04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A63C08 size=76
    let mut pc: u32 = 0x82A63C08;
    'dispatch: loop {
        match pc {
            0x82A63C08 => {
    //   block [0x82A63C08..0x82A63C54)
	// 82A63C08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A63C0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A63C10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A63C14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A63C18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A63C1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A63C20: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A63C24: 4BFFFF25  bl 0x82a63b48
	ctx.lr = 0x82A63C28;
	sub_82A63B48(ctx, base);
	// 82A63C28: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A63C2C: 4182000C  beq 0x82a63c38
	if ctx.cr[0].eq {
	pc = 0x82A63C38; continue 'dispatch;
	}
	// 82A63C30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A63C34: 4838E7A5  bl 0x82df23d8
	ctx.lr = 0x82A63C38;
	sub_82DF23D8(ctx, base);
	// 82A63C38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A63C3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A63C40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A63C44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A63C48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A63C4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A63C50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63C58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A63C58 size=112
    let mut pc: u32 = 0x82A63C58;
    'dispatch: loop {
        match pc {
            0x82A63C58 => {
    //   block [0x82A63C58..0x82A63CC8)
	// 82A63C58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A63C5C: 48744511  bl 0x831a816c
	ctx.lr = 0x82A63C60;
	sub_831A8130(ctx, base);
	// 82A63C60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A63C64: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A63C68: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A63C6C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A63C70: 388BF588  addi r4, r11, -0xa78
	ctx.r[4].s64 = ctx.r[11].s64 + -2680;
	// 82A63C74: 38A00053  li r5, 0x53
	ctx.r[5].s64 = 83;
	// 82A63C78: 386000F4  li r3, 0xf4
	ctx.r[3].s64 = 244;
	// 82A63C7C: 4838E76D  bl 0x82df23e8
	ctx.lr = 0x82A63C80;
	sub_82DF23E8(ctx, base);
	// 82A63C80: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A63C84: 41820010  beq 0x82a63c94
	if ctx.cr[0].eq {
	pc = 0x82A63C94; continue 'dispatch;
	}
	// 82A63C88: 4BFFFF29  bl 0x82a63bb0
	ctx.lr = 0x82A63C8C;
	sub_82A63BB0(ctx, base);
	// 82A63C8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A63C90: 48000008  b 0x82a63c98
	pc = 0x82A63C98; continue 'dispatch;
	// 82A63C94: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A63C98: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A63C9C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A63CA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A63CA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A63CA8: 4BFFF8A1  bl 0x82a63548
	ctx.lr = 0x82A63CAC;
	sub_82A63548(ctx, base);
	// 82A63CAC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A63CB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A63CB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A63CB8: 4B85C349  bl 0x822c0000
	ctx.lr = 0x82A63CBC;
	sub_822C0000(ctx, base);
	// 82A63CBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A63CC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A63CC4: 487444F8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A63CC8 size=4
    let mut pc: u32 = 0x82A63CC8;
    'dispatch: loop {
        match pc {
            0x82A63CC8 => {
    //   block [0x82A63CC8..0x82A63CCC)
	// 82A63CC8: 483F93C8  b 0x82e5d090
	sub_82E5D090(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A63CD0 size=12
    let mut pc: u32 = 0x82A63CD0;
    'dispatch: loop {
        match pc {
            0x82A63CD0 => {
    //   block [0x82A63CD0..0x82A63CDC)
	// 82A63CD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A63CD4: 99630060  stb r11, 0x60(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 82A63CD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A63CE0 size=12
    let mut pc: u32 = 0x82A63CE0;
    'dispatch: loop {
        match pc {
            0x82A63CE0 => {
    //   block [0x82A63CE0..0x82A63CEC)
	// 82A63CE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A63CE4: 99630060  stb r11, 0x60(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 82A63CE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A63CF0 size=8
    let mut pc: u32 = 0x82A63CF0;
    'dispatch: loop {
        match pc {
            0x82A63CF0 => {
    //   block [0x82A63CF0..0x82A63CF8)
	// 82A63CF0: 88630060  lbz r3, 0x60(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A63CF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A63CF8 size=88
    let mut pc: u32 = 0x82A63CF8;
    'dispatch: loop {
        match pc {
            0x82A63CF8 => {
    //   block [0x82A63CF8..0x82A63D50)
	// 82A63CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A63CFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A63D00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A63D04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A63D08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A63D0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A63D10: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A63D14: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A63D18: 396BF5DC  addi r11, r11, -0xa24
	ctx.r[11].s64 = ctx.r[11].s64 + -2596;
	// 82A63D1C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A63D20: 483F9B29  bl 0x82e5d848
	ctx.lr = 0x82A63D24;
	sub_82E5D848(ctx, base);
	// 82A63D24: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A63D28: 4182000C  beq 0x82a63d34
	if ctx.cr[0].eq {
	pc = 0x82A63D34; continue 'dispatch;
	}
	// 82A63D2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A63D30: 4838E6A9  bl 0x82df23d8
	ctx.lr = 0x82A63D34;
	sub_82DF23D8(ctx, base);
	// 82A63D34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A63D38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A63D3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A63D40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A63D44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A63D48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A63D4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63D50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A63D50 size=196
    let mut pc: u32 = 0x82A63D50;
    'dispatch: loop {
        match pc {
            0x82A63D50 => {
    //   block [0x82A63D50..0x82A63E14)
	// 82A63D50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A63D54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A63D58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A63D5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A63D60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A63D64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A63D68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A63D6C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A63D70: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A63D74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A63D78: 4B85CBC1  bl 0x822c0938
	ctx.lr = 0x82A63D7C;
	sub_822C0938(ctx, base);
	// 82A63D7C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A63D80: 41820028  beq 0x82a63da8
	if ctx.cr[0].eq {
	pc = 0x82A63DA8; continue 'dispatch;
	}
	// 82A63D84: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A63D88: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A63D8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A63D90: 392BF5EC  addi r9, r11, -0xa14
	ctx.r[9].s64 = ctx.r[11].s64 + -2580;
	// 82A63D94: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A63D98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A63D9C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A63DA0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A63DA4: 48000008  b 0x82a63dac
	pc = 0x82A63DAC; continue 'dispatch;
	// 82A63DA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A63DAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A63DB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A63DB4: 409A0044  bne cr6, 0x82a63df8
	if !ctx.cr[6].eq {
	pc = 0x82A63DF8; continue 'dispatch;
	}
	// 82A63DB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A63DBC: 419A001C  beq cr6, 0x82a63dd8
	if ctx.cr[6].eq {
	pc = 0x82A63DD8; continue 'dispatch;
	}
	// 82A63DC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A63DC4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A63DC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A63DCC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A63DD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A63DD4: 4E800421  bctrl
	ctx.lr = 0x82A63DD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A63DD8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A63DDC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A63DE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A63DE4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A63DE8: 816B6708  lwz r11, 0x6708(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26376 as u32) ) } as u64;
	// 82A63DEC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A63DF0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A63DF4: 4B85C20D  bl 0x822c0000
	ctx.lr = 0x82A63DF8;
	sub_822C0000(ctx, base);
	// 82A63DF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A63DFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A63E00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A63E04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A63E08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A63E0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A63E10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A63E18 size=196
    let mut pc: u32 = 0x82A63E18;
    'dispatch: loop {
        match pc {
            0x82A63E18 => {
    //   block [0x82A63E18..0x82A63EDC)
	// 82A63E18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A63E1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A63E20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A63E24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A63E28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A63E2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A63E30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A63E34: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A63E38: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A63E3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A63E40: 4B85CAF9  bl 0x822c0938
	ctx.lr = 0x82A63E44;
	sub_822C0938(ctx, base);
	// 82A63E44: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A63E48: 41820028  beq 0x82a63e70
	if ctx.cr[0].eq {
	pc = 0x82A63E70; continue 'dispatch;
	}
	// 82A63E4C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A63E50: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A63E54: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A63E58: 392BF600  addi r9, r11, -0xa00
	ctx.r[9].s64 = ctx.r[11].s64 + -2560;
	// 82A63E5C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A63E60: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A63E64: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A63E68: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A63E6C: 48000008  b 0x82a63e74
	pc = 0x82A63E74; continue 'dispatch;
	// 82A63E70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A63E74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A63E78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A63E7C: 409A0044  bne cr6, 0x82a63ec0
	if !ctx.cr[6].eq {
	pc = 0x82A63EC0; continue 'dispatch;
	}
	// 82A63E80: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A63E84: 419A001C  beq cr6, 0x82a63ea0
	if ctx.cr[6].eq {
	pc = 0x82A63EA0; continue 'dispatch;
	}
	// 82A63E88: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A63E8C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A63E90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A63E94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A63E98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A63E9C: 4E800421  bctrl
	ctx.lr = 0x82A63EA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A63EA0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A63EA4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A63EA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A63EAC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A63EB0: 816B6708  lwz r11, 0x6708(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26376 as u32) ) } as u64;
	// 82A63EB4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A63EB8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A63EBC: 4B85C145  bl 0x822c0000
	ctx.lr = 0x82A63EC0;
	sub_822C0000(ctx, base);
	// 82A63EC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A63EC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A63EC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A63ECC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A63ED0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A63ED4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A63ED8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A63EE0 size=196
    let mut pc: u32 = 0x82A63EE0;
    'dispatch: loop {
        match pc {
            0x82A63EE0 => {
    //   block [0x82A63EE0..0x82A63FA4)
	// 82A63EE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A63EE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A63EE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A63EEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A63EF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A63EF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A63EF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A63EFC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A63F00: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A63F04: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A63F08: 4B85CA31  bl 0x822c0938
	ctx.lr = 0x82A63F0C;
	sub_822C0938(ctx, base);
	// 82A63F0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A63F10: 41820028  beq 0x82a63f38
	if ctx.cr[0].eq {
	pc = 0x82A63F38; continue 'dispatch;
	}
	// 82A63F14: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A63F18: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A63F1C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A63F20: 392BF614  addi r9, r11, -0x9ec
	ctx.r[9].s64 = ctx.r[11].s64 + -2540;
	// 82A63F24: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A63F28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A63F2C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A63F30: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A63F34: 48000008  b 0x82a63f3c
	pc = 0x82A63F3C; continue 'dispatch;
	// 82A63F38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A63F3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A63F40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A63F44: 409A0044  bne cr6, 0x82a63f88
	if !ctx.cr[6].eq {
	pc = 0x82A63F88; continue 'dispatch;
	}
	// 82A63F48: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A63F4C: 419A001C  beq cr6, 0x82a63f68
	if ctx.cr[6].eq {
	pc = 0x82A63F68; continue 'dispatch;
	}
	// 82A63F50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A63F54: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A63F58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A63F5C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A63F60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A63F64: 4E800421  bctrl
	ctx.lr = 0x82A63F68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A63F68: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A63F6C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A63F70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A63F74: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A63F78: 816B6708  lwz r11, 0x6708(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26376 as u32) ) } as u64;
	// 82A63F7C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A63F80: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A63F84: 4B85C07D  bl 0x822c0000
	ctx.lr = 0x82A63F88;
	sub_822C0000(ctx, base);
	// 82A63F88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A63F8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A63F90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A63F94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A63F98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A63F9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A63FA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A63FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A63FA8 size=196
    let mut pc: u32 = 0x82A63FA8;
    'dispatch: loop {
        match pc {
            0x82A63FA8 => {
    //   block [0x82A63FA8..0x82A6406C)
	// 82A63FA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A63FAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A63FB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A63FB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A63FB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A63FBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A63FC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A63FC4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A63FC8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A63FCC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A63FD0: 4B85C969  bl 0x822c0938
	ctx.lr = 0x82A63FD4;
	sub_822C0938(ctx, base);
	// 82A63FD4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A63FD8: 41820028  beq 0x82a64000
	if ctx.cr[0].eq {
	pc = 0x82A64000; continue 'dispatch;
	}
	// 82A63FDC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A63FE0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A63FE4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A63FE8: 392BF628  addi r9, r11, -0x9d8
	ctx.r[9].s64 = ctx.r[11].s64 + -2520;
	// 82A63FEC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A63FF0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A63FF4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A63FF8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A63FFC: 48000008  b 0x82a64004
	pc = 0x82A64004; continue 'dispatch;
	// 82A64000: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A64004: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A64008: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6400C: 409A0044  bne cr6, 0x82a64050
	if !ctx.cr[6].eq {
	pc = 0x82A64050; continue 'dispatch;
	}
	// 82A64010: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A64014: 419A001C  beq cr6, 0x82a64030
	if ctx.cr[6].eq {
	pc = 0x82A64030; continue 'dispatch;
	}
	// 82A64018: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6401C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A64020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A64024: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A64028: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A6402C: 4E800421  bctrl
	ctx.lr = 0x82A64030;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A64030: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A64034: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A64038: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6403C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A64040: 816B6708  lwz r11, 0x6708(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26376 as u32) ) } as u64;
	// 82A64044: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A64048: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A6404C: 4B85BFB5  bl 0x822c0000
	ctx.lr = 0x82A64050;
	sub_822C0000(ctx, base);
	// 82A64050: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A64054: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A64058: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6405C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A64060: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A64064: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A64068: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A64070 size=196
    let mut pc: u32 = 0x82A64070;
    'dispatch: loop {
        match pc {
            0x82A64070 => {
    //   block [0x82A64070..0x82A64134)
	// 82A64070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A64074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A64078: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6407C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A64080: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A64084: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A64088: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A6408C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A64090: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A64094: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A64098: 4B85C8A1  bl 0x822c0938
	ctx.lr = 0x82A6409C;
	sub_822C0938(ctx, base);
	// 82A6409C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A640A0: 41820028  beq 0x82a640c8
	if ctx.cr[0].eq {
	pc = 0x82A640C8; continue 'dispatch;
	}
	// 82A640A4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A640A8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A640AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A640B0: 392BF63C  addi r9, r11, -0x9c4
	ctx.r[9].s64 = ctx.r[11].s64 + -2500;
	// 82A640B4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A640B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A640BC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A640C0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A640C4: 48000008  b 0x82a640cc
	pc = 0x82A640CC; continue 'dispatch;
	// 82A640C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A640CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A640D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A640D4: 409A0044  bne cr6, 0x82a64118
	if !ctx.cr[6].eq {
	pc = 0x82A64118; continue 'dispatch;
	}
	// 82A640D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A640DC: 419A001C  beq cr6, 0x82a640f8
	if ctx.cr[6].eq {
	pc = 0x82A640F8; continue 'dispatch;
	}
	// 82A640E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A640E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A640E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A640EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A640F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A640F4: 4E800421  bctrl
	ctx.lr = 0x82A640F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A640F8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A640FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A64100: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A64104: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A64108: 816B6708  lwz r11, 0x6708(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26376 as u32) ) } as u64;
	// 82A6410C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A64110: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A64114: 4B85BEED  bl 0x822c0000
	ctx.lr = 0x82A64118;
	sub_822C0000(ctx, base);
	// 82A64118: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6411C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A64120: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A64124: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A64128: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6412C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A64130: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A64138 size=196
    let mut pc: u32 = 0x82A64138;
    'dispatch: loop {
        match pc {
            0x82A64138 => {
    //   block [0x82A64138..0x82A641FC)
	// 82A64138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6413C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A64140: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A64144: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A64148: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6414C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A64150: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A64154: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A64158: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A6415C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A64160: 4B85C7D9  bl 0x822c0938
	ctx.lr = 0x82A64164;
	sub_822C0938(ctx, base);
	// 82A64164: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A64168: 41820028  beq 0x82a64190
	if ctx.cr[0].eq {
	pc = 0x82A64190; continue 'dispatch;
	}
	// 82A6416C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A64170: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A64174: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A64178: 392BF650  addi r9, r11, -0x9b0
	ctx.r[9].s64 = ctx.r[11].s64 + -2480;
	// 82A6417C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A64180: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A64184: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A64188: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A6418C: 48000008  b 0x82a64194
	pc = 0x82A64194; continue 'dispatch;
	// 82A64190: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A64194: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A64198: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6419C: 409A0044  bne cr6, 0x82a641e0
	if !ctx.cr[6].eq {
	pc = 0x82A641E0; continue 'dispatch;
	}
	// 82A641A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A641A4: 419A001C  beq cr6, 0x82a641c0
	if ctx.cr[6].eq {
	pc = 0x82A641C0; continue 'dispatch;
	}
	// 82A641A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A641AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A641B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A641B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A641B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A641BC: 4E800421  bctrl
	ctx.lr = 0x82A641C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A641C0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A641C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A641C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A641CC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A641D0: 816B6708  lwz r11, 0x6708(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26376 as u32) ) } as u64;
	// 82A641D4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A641D8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A641DC: 4B85BE25  bl 0x822c0000
	ctx.lr = 0x82A641E0;
	sub_822C0000(ctx, base);
	// 82A641E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A641E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A641E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A641EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A641F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A641F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A641F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A64200 size=196
    let mut pc: u32 = 0x82A64200;
    'dispatch: loop {
        match pc {
            0x82A64200 => {
    //   block [0x82A64200..0x82A642C4)
	// 82A64200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A64204: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A64208: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6420C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A64210: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A64214: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A64218: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A6421C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A64220: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A64224: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A64228: 4B85C711  bl 0x822c0938
	ctx.lr = 0x82A6422C;
	sub_822C0938(ctx, base);
	// 82A6422C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A64230: 41820028  beq 0x82a64258
	if ctx.cr[0].eq {
	pc = 0x82A64258; continue 'dispatch;
	}
	// 82A64234: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A64238: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A6423C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A64240: 392BF664  addi r9, r11, -0x99c
	ctx.r[9].s64 = ctx.r[11].s64 + -2460;
	// 82A64244: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A64248: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A6424C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A64250: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A64254: 48000008  b 0x82a6425c
	pc = 0x82A6425C; continue 'dispatch;
	// 82A64258: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A6425C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A64260: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A64264: 409A0044  bne cr6, 0x82a642a8
	if !ctx.cr[6].eq {
	pc = 0x82A642A8; continue 'dispatch;
	}
	// 82A64268: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A6426C: 419A001C  beq cr6, 0x82a64288
	if ctx.cr[6].eq {
	pc = 0x82A64288; continue 'dispatch;
	}
	// 82A64270: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64274: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A64278: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6427C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A64280: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A64284: 4E800421  bctrl
	ctx.lr = 0x82A64288;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A64288: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6428C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A64290: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A64294: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A64298: 816B6708  lwz r11, 0x6708(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26376 as u32) ) } as u64;
	// 82A6429C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A642A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A642A4: 4B85BD5D  bl 0x822c0000
	ctx.lr = 0x82A642A8;
	sub_822C0000(ctx, base);
	// 82A642A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A642AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A642B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A642B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A642B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A642BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A642C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A642C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A642C8 size=112
    let mut pc: u32 = 0x82A642C8;
    'dispatch: loop {
        match pc {
            0x82A642C8 => {
    //   block [0x82A642C8..0x82A64338)
	// 82A642C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A642CC: 48743EA1  bl 0x831a816c
	ctx.lr = 0x82A642D0;
	sub_831A8130(ctx, base);
	// 82A642D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A642D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A642D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A642DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A642E0: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82A642E4: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82A642E8: 38600084  li r3, 0x84
	ctx.r[3].s64 = 132;
	// 82A642EC: 4838E0FD  bl 0x82df23e8
	ctx.lr = 0x82A642F0;
	sub_82DF23E8(ctx, base);
	// 82A642F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A642F4: 41820010  beq 0x82a64304
	if ctx.cr[0].eq {
	pc = 0x82A64304; continue 'dispatch;
	}
	// 82A642F8: 48011939  bl 0x82a75c30
	ctx.lr = 0x82A642FC;
	sub_82A75C30(ctx, base);
	// 82A642FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A64300: 48000008  b 0x82a64308
	pc = 0x82A64308; continue 'dispatch;
	// 82A64304: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A64308: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A6430C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A64310: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A64314: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A64318: 4BFFFA39  bl 0x82a63d50
	ctx.lr = 0x82A6431C;
	sub_82A63D50(ctx, base);
	// 82A6431C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A64320: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A64324: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A64328: 4B85BCD9  bl 0x822c0000
	ctx.lr = 0x82A6432C;
	sub_822C0000(ctx, base);
	// 82A6432C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A64330: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A64334: 48743E88  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A64338 size=112
    let mut pc: u32 = 0x82A64338;
    'dispatch: loop {
        match pc {
            0x82A64338 => {
    //   block [0x82A64338..0x82A643A8)
	// 82A64338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6433C: 48743E31  bl 0x831a816c
	ctx.lr = 0x82A64340;
	sub_831A8130(ctx, base);
	// 82A64340: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A64344: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A64348: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A6434C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A64350: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82A64354: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82A64358: 386000BC  li r3, 0xbc
	ctx.r[3].s64 = 188;
	// 82A6435C: 4838E08D  bl 0x82df23e8
	ctx.lr = 0x82A64360;
	sub_82DF23E8(ctx, base);
	// 82A64360: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A64364: 41820010  beq 0x82a64374
	if ctx.cr[0].eq {
	pc = 0x82A64374; continue 'dispatch;
	}
	// 82A64368: 480124B9  bl 0x82a76820
	ctx.lr = 0x82A6436C;
	sub_82A76820(ctx, base);
	// 82A6436C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A64370: 48000008  b 0x82a64378
	pc = 0x82A64378; continue 'dispatch;
	// 82A64374: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A64378: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A6437C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A64380: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A64384: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A64388: 4BFFFA91  bl 0x82a63e18
	ctx.lr = 0x82A6438C;
	sub_82A63E18(ctx, base);
	// 82A6438C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A64390: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A64394: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A64398: 4B85BC69  bl 0x822c0000
	ctx.lr = 0x82A6439C;
	sub_822C0000(ctx, base);
	// 82A6439C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A643A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A643A4: 48743E18  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A643A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A643A8 size=112
    let mut pc: u32 = 0x82A643A8;
    'dispatch: loop {
        match pc {
            0x82A643A8 => {
    //   block [0x82A643A8..0x82A64418)
	// 82A643A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A643AC: 48743DC1  bl 0x831a816c
	ctx.lr = 0x82A643B0;
	sub_831A8130(ctx, base);
	// 82A643B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A643B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A643B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A643BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A643C0: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82A643C4: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82A643C8: 38600094  li r3, 0x94
	ctx.r[3].s64 = 148;
	// 82A643CC: 4838E01D  bl 0x82df23e8
	ctx.lr = 0x82A643D0;
	sub_82DF23E8(ctx, base);
	// 82A643D0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A643D4: 41820010  beq 0x82a643e4
	if ctx.cr[0].eq {
	pc = 0x82A643E4; continue 'dispatch;
	}
	// 82A643D8: 48013A29  bl 0x82a77e00
	ctx.lr = 0x82A643DC;
	sub_82A77E00(ctx, base);
	// 82A643DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A643E0: 48000008  b 0x82a643e8
	pc = 0x82A643E8; continue 'dispatch;
	// 82A643E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A643E8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A643EC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A643F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A643F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A643F8: 4BFFFAE9  bl 0x82a63ee0
	ctx.lr = 0x82A643FC;
	sub_82A63EE0(ctx, base);
	// 82A643FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A64400: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A64404: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A64408: 4B85BBF9  bl 0x822c0000
	ctx.lr = 0x82A6440C;
	sub_822C0000(ctx, base);
	// 82A6440C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A64410: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A64414: 48743DA8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A64418 size=112
    let mut pc: u32 = 0x82A64418;
    'dispatch: loop {
        match pc {
            0x82A64418 => {
    //   block [0x82A64418..0x82A64488)
	// 82A64418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6441C: 48743D51  bl 0x831a816c
	ctx.lr = 0x82A64420;
	sub_831A8130(ctx, base);
	// 82A64420: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A64424: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A64428: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A6442C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A64430: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82A64434: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82A64438: 386000AC  li r3, 0xac
	ctx.r[3].s64 = 172;
	// 82A6443C: 4838DFAD  bl 0x82df23e8
	ctx.lr = 0x82A64440;
	sub_82DF23E8(ctx, base);
	// 82A64440: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A64444: 41820010  beq 0x82a64454
	if ctx.cr[0].eq {
	pc = 0x82A64454; continue 'dispatch;
	}
	// 82A64448: 48016779  bl 0x82a7abc0
	ctx.lr = 0x82A6444C;
	sub_82A7ABC0(ctx, base);
	// 82A6444C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A64450: 48000008  b 0x82a64458
	pc = 0x82A64458; continue 'dispatch;
	// 82A64454: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A64458: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A6445C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A64460: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A64464: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A64468: 4BFFFB41  bl 0x82a63fa8
	ctx.lr = 0x82A6446C;
	sub_82A63FA8(ctx, base);
	// 82A6446C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A64470: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A64474: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A64478: 4B85BB89  bl 0x822c0000
	ctx.lr = 0x82A6447C;
	sub_822C0000(ctx, base);
	// 82A6447C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A64480: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A64484: 48743D38  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A64488 size=112
    let mut pc: u32 = 0x82A64488;
    'dispatch: loop {
        match pc {
            0x82A64488 => {
    //   block [0x82A64488..0x82A644F8)
	// 82A64488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6448C: 48743CE1  bl 0x831a816c
	ctx.lr = 0x82A64490;
	sub_831A8130(ctx, base);
	// 82A64490: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A64494: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A64498: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A6449C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A644A0: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82A644A4: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82A644A8: 386000C4  li r3, 0xc4
	ctx.r[3].s64 = 196;
	// 82A644AC: 4838DF3D  bl 0x82df23e8
	ctx.lr = 0x82A644B0;
	sub_82DF23E8(ctx, base);
	// 82A644B0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A644B4: 41820010  beq 0x82a644c4
	if ctx.cr[0].eq {
	pc = 0x82A644C4; continue 'dispatch;
	}
	// 82A644B8: 48012149  bl 0x82a76600
	ctx.lr = 0x82A644BC;
	sub_82A76600(ctx, base);
	// 82A644BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A644C0: 48000008  b 0x82a644c8
	pc = 0x82A644C8; continue 'dispatch;
	// 82A644C4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A644C8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A644CC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A644D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A644D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A644D8: 4BFFFB99  bl 0x82a64070
	ctx.lr = 0x82A644DC;
	sub_82A64070(ctx, base);
	// 82A644DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A644E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A644E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A644E8: 4B85BB19  bl 0x822c0000
	ctx.lr = 0x82A644EC;
	sub_822C0000(ctx, base);
	// 82A644EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A644F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A644F4: 48743CC8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A644F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A644F8 size=112
    let mut pc: u32 = 0x82A644F8;
    'dispatch: loop {
        match pc {
            0x82A644F8 => {
    //   block [0x82A644F8..0x82A64568)
	// 82A644F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A644FC: 48743C71  bl 0x831a816c
	ctx.lr = 0x82A64500;
	sub_831A8130(ctx, base);
	// 82A64500: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A64504: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A64508: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A6450C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A64510: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82A64514: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82A64518: 386000B0  li r3, 0xb0
	ctx.r[3].s64 = 176;
	// 82A6451C: 4838DECD  bl 0x82df23e8
	ctx.lr = 0x82A64520;
	sub_82DF23E8(ctx, base);
	// 82A64520: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A64524: 41820010  beq 0x82a64534
	if ctx.cr[0].eq {
	pc = 0x82A64534; continue 'dispatch;
	}
	// 82A64528: 48014C61  bl 0x82a79188
	ctx.lr = 0x82A6452C;
	sub_82A79188(ctx, base);
	// 82A6452C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A64530: 48000008  b 0x82a64538
	pc = 0x82A64538; continue 'dispatch;
	// 82A64534: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A64538: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A6453C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A64540: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A64544: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A64548: 4BFFFBF1  bl 0x82a64138
	ctx.lr = 0x82A6454C;
	sub_82A64138(ctx, base);
	// 82A6454C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A64550: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A64554: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A64558: 4B85BAA9  bl 0x822c0000
	ctx.lr = 0x82A6455C;
	sub_822C0000(ctx, base);
	// 82A6455C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A64560: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A64564: 48743C58  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A64568 size=112
    let mut pc: u32 = 0x82A64568;
    'dispatch: loop {
        match pc {
            0x82A64568 => {
    //   block [0x82A64568..0x82A645D8)
	// 82A64568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6456C: 48743C01  bl 0x831a816c
	ctx.lr = 0x82A64570;
	sub_831A8130(ctx, base);
	// 82A64570: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A64574: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A64578: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A6457C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A64580: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82A64584: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82A64588: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 82A6458C: 4838DE5D  bl 0x82df23e8
	ctx.lr = 0x82A64590;
	sub_82DF23E8(ctx, base);
	// 82A64590: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A64594: 41820010  beq 0x82a645a4
	if ctx.cr[0].eq {
	pc = 0x82A645A4; continue 'dispatch;
	}
	// 82A64598: 48016911  bl 0x82a7aea8
	ctx.lr = 0x82A6459C;
	sub_82A7AEA8(ctx, base);
	// 82A6459C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A645A0: 48000008  b 0x82a645a8
	pc = 0x82A645A8; continue 'dispatch;
	// 82A645A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A645A8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A645AC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A645B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A645B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A645B8: 4BFFFC49  bl 0x82a64200
	ctx.lr = 0x82A645BC;
	sub_82A64200(ctx, base);
	// 82A645BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A645C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A645C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A645C8: 4B85BA39  bl 0x822c0000
	ctx.lr = 0x82A645CC;
	sub_822C0000(ctx, base);
	// 82A645CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A645D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A645D4: 48743BE8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A645D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A645D8 size=92
    let mut pc: u32 = 0x82A645D8;
    'dispatch: loop {
        match pc {
            0x82A645D8 => {
    //   block [0x82A645D8..0x82A64634)
	// 82A645D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A645DC: 48743B91  bl 0x831a816c
	ctx.lr = 0x82A645E0;
	sub_831A8130(ctx, base);
	// 82A645E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A645E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A645E8: 3D4082A6  lis r10, -0x7d5a
	ctx.r[10].s64 = -2103050240;
	// 82A645EC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A645F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A645F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A645F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A645FC: 388A42C8  addi r4, r10, 0x42c8
	ctx.r[4].s64 = ctx.r[10].s64 + 17096;
	// 82A64600: 4B8FB471  bl 0x8235fa70
	ctx.lr = 0x82A64604;
	sub_8235FA70(ctx, base);
	// 82A64604: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A64608: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6460C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A64610: 4838F5F1  bl 0x82df3c00
	ctx.lr = 0x82A64614;
	sub_82DF3C00(ctx, base);
	// 82A64614: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A64618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6461C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A64620: 483F7B39  bl 0x82e5c158
	ctx.lr = 0x82A64624;
	sub_82E5C158(ctx, base);
	// 82A64624: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A64628: 4838EE01  bl 0x82df3428
	ctx.lr = 0x82A6462C;
	sub_82DF3428(ctx, base);
	// 82A6462C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A64630: 48743B8C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A64638 size=92
    let mut pc: u32 = 0x82A64638;
    'dispatch: loop {
        match pc {
            0x82A64638 => {
    //   block [0x82A64638..0x82A64694)
	// 82A64638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6463C: 48743B31  bl 0x831a816c
	ctx.lr = 0x82A64640;
	sub_831A8130(ctx, base);
	// 82A64640: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A64644: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A64648: 3D4082A6  lis r10, -0x7d5a
	ctx.r[10].s64 = -2103050240;
	// 82A6464C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A64650: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A64654: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A64658: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A6465C: 388A4338  addi r4, r10, 0x4338
	ctx.r[4].s64 = ctx.r[10].s64 + 17208;
	// 82A64660: 4B8FB411  bl 0x8235fa70
	ctx.lr = 0x82A64664;
	sub_8235FA70(ctx, base);
	// 82A64664: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A64668: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6466C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A64670: 4838F591  bl 0x82df3c00
	ctx.lr = 0x82A64674;
	sub_82DF3C00(ctx, base);
	// 82A64674: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A64678: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6467C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A64680: 483F7AD9  bl 0x82e5c158
	ctx.lr = 0x82A64684;
	sub_82E5C158(ctx, base);
	// 82A64684: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A64688: 4838EDA1  bl 0x82df3428
	ctx.lr = 0x82A6468C;
	sub_82DF3428(ctx, base);
	// 82A6468C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A64690: 48743B2C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A64698 size=92
    let mut pc: u32 = 0x82A64698;
    'dispatch: loop {
        match pc {
            0x82A64698 => {
    //   block [0x82A64698..0x82A646F4)
	// 82A64698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6469C: 48743AD1  bl 0x831a816c
	ctx.lr = 0x82A646A0;
	sub_831A8130(ctx, base);
	// 82A646A0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A646A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A646A8: 3D4082A6  lis r10, -0x7d5a
	ctx.r[10].s64 = -2103050240;
	// 82A646AC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A646B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A646B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A646B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A646BC: 388A43A8  addi r4, r10, 0x43a8
	ctx.r[4].s64 = ctx.r[10].s64 + 17320;
	// 82A646C0: 4B8FB3B1  bl 0x8235fa70
	ctx.lr = 0x82A646C4;
	sub_8235FA70(ctx, base);
	// 82A646C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A646C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A646CC: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A646D0: 4838F531  bl 0x82df3c00
	ctx.lr = 0x82A646D4;
	sub_82DF3C00(ctx, base);
	// 82A646D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A646D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A646DC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A646E0: 483F7A79  bl 0x82e5c158
	ctx.lr = 0x82A646E4;
	sub_82E5C158(ctx, base);
	// 82A646E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A646E8: 4838ED41  bl 0x82df3428
	ctx.lr = 0x82A646EC;
	sub_82DF3428(ctx, base);
	// 82A646EC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A646F0: 48743ACC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A646F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A646F8 size=92
    let mut pc: u32 = 0x82A646F8;
    'dispatch: loop {
        match pc {
            0x82A646F8 => {
    //   block [0x82A646F8..0x82A64754)
	// 82A646F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A646FC: 48743A71  bl 0x831a816c
	ctx.lr = 0x82A64700;
	sub_831A8130(ctx, base);
	// 82A64700: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A64704: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A64708: 3D4082A6  lis r10, -0x7d5a
	ctx.r[10].s64 = -2103050240;
	// 82A6470C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A64710: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A64714: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A64718: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A6471C: 388A4418  addi r4, r10, 0x4418
	ctx.r[4].s64 = ctx.r[10].s64 + 17432;
	// 82A64720: 4B8FB351  bl 0x8235fa70
	ctx.lr = 0x82A64724;
	sub_8235FA70(ctx, base);
	// 82A64724: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A64728: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6472C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A64730: 4838F4D1  bl 0x82df3c00
	ctx.lr = 0x82A64734;
	sub_82DF3C00(ctx, base);
	// 82A64734: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A64738: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6473C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A64740: 483F7A19  bl 0x82e5c158
	ctx.lr = 0x82A64744;
	sub_82E5C158(ctx, base);
	// 82A64744: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A64748: 4838ECE1  bl 0x82df3428
	ctx.lr = 0x82A6474C;
	sub_82DF3428(ctx, base);
	// 82A6474C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A64750: 48743A6C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A64758 size=92
    let mut pc: u32 = 0x82A64758;
    'dispatch: loop {
        match pc {
            0x82A64758 => {
    //   block [0x82A64758..0x82A647B4)
	// 82A64758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6475C: 48743A11  bl 0x831a816c
	ctx.lr = 0x82A64760;
	sub_831A8130(ctx, base);
	// 82A64760: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A64764: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A64768: 3D4082A6  lis r10, -0x7d5a
	ctx.r[10].s64 = -2103050240;
	// 82A6476C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A64770: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A64774: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A64778: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A6477C: 388A4488  addi r4, r10, 0x4488
	ctx.r[4].s64 = ctx.r[10].s64 + 17544;
	// 82A64780: 4B8FB2F1  bl 0x8235fa70
	ctx.lr = 0x82A64784;
	sub_8235FA70(ctx, base);
	// 82A64784: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A64788: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6478C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A64790: 4838F471  bl 0x82df3c00
	ctx.lr = 0x82A64794;
	sub_82DF3C00(ctx, base);
	// 82A64794: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A64798: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6479C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A647A0: 483F79B9  bl 0x82e5c158
	ctx.lr = 0x82A647A4;
	sub_82E5C158(ctx, base);
	// 82A647A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A647A8: 4838EC81  bl 0x82df3428
	ctx.lr = 0x82A647AC;
	sub_82DF3428(ctx, base);
	// 82A647AC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A647B0: 48743A0C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A647B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A647B8 size=92
    let mut pc: u32 = 0x82A647B8;
    'dispatch: loop {
        match pc {
            0x82A647B8 => {
    //   block [0x82A647B8..0x82A64814)
	// 82A647B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A647BC: 487439B1  bl 0x831a816c
	ctx.lr = 0x82A647C0;
	sub_831A8130(ctx, base);
	// 82A647C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A647C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A647C8: 3D4082A6  lis r10, -0x7d5a
	ctx.r[10].s64 = -2103050240;
	// 82A647CC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A647D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A647D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A647D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A647DC: 388A44F8  addi r4, r10, 0x44f8
	ctx.r[4].s64 = ctx.r[10].s64 + 17656;
	// 82A647E0: 4B8FB291  bl 0x8235fa70
	ctx.lr = 0x82A647E4;
	sub_8235FA70(ctx, base);
	// 82A647E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A647E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A647EC: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A647F0: 4838F411  bl 0x82df3c00
	ctx.lr = 0x82A647F4;
	sub_82DF3C00(ctx, base);
	// 82A647F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A647F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A647FC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A64800: 483F7959  bl 0x82e5c158
	ctx.lr = 0x82A64804;
	sub_82E5C158(ctx, base);
	// 82A64804: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A64808: 4838EC21  bl 0x82df3428
	ctx.lr = 0x82A6480C;
	sub_82DF3428(ctx, base);
	// 82A6480C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A64810: 487439AC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A64818 size=92
    let mut pc: u32 = 0x82A64818;
    'dispatch: loop {
        match pc {
            0x82A64818 => {
    //   block [0x82A64818..0x82A64874)
	// 82A64818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6481C: 48743951  bl 0x831a816c
	ctx.lr = 0x82A64820;
	sub_831A8130(ctx, base);
	// 82A64820: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A64824: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A64828: 3D4082A6  lis r10, -0x7d5a
	ctx.r[10].s64 = -2103050240;
	// 82A6482C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A64830: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A64834: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A64838: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A6483C: 388A4568  addi r4, r10, 0x4568
	ctx.r[4].s64 = ctx.r[10].s64 + 17768;
	// 82A64840: 4B8FB231  bl 0x8235fa70
	ctx.lr = 0x82A64844;
	sub_8235FA70(ctx, base);
	// 82A64844: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A64848: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6484C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A64850: 4838F3B1  bl 0x82df3c00
	ctx.lr = 0x82A64854;
	sub_82DF3C00(ctx, base);
	// 82A64854: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A64858: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6485C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A64860: 483F78F9  bl 0x82e5c158
	ctx.lr = 0x82A64864;
	sub_82E5C158(ctx, base);
	// 82A64864: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A64868: 4838EBC1  bl 0x82df3428
	ctx.lr = 0x82A6486C;
	sub_82DF3428(ctx, base);
	// 82A6486C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A64870: 4874394C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A64878 size=352
    let mut pc: u32 = 0x82A64878;
    'dispatch: loop {
        match pc {
            0x82A64878 => {
    //   block [0x82A64878..0x82A649D8)
	// 82A64878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6487C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A64880: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A64884: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A64888: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6488C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A64890: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A64894: 483F903D  bl 0x82e5d8d0
	ctx.lr = 0x82A64898;
	sub_82E5D8D0(ctx, base);
	// 82A64898: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6489C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A648A0: 396BF5DC  addi r11, r11, -0xa24
	ctx.r[11].s64 = ctx.r[11].s64 + -2596;
	// 82A648A4: 995F0060  stb r10, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u8 ) };
	// 82A648A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A648AC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A648B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A648B4: 485EEA5D  bl 0x83053310
	ctx.lr = 0x82A648B8;
	sub_83053310(ctx, base);
	// 82A648B8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A648BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A648C0: 3BCB893C  addi r30, r11, -0x76c4
	ctx.r[30].s64 = ctx.r[11].s64 + -30404;
	// 82A648C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A648C8: 4838F141  bl 0x82df3a08
	ctx.lr = 0x82A648CC;
	sub_82DF3A08(ctx, base);
	// 82A648CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A648D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A648D4: 4BFFFD05  bl 0x82a645d8
	ctx.lr = 0x82A648D8;
	sub_82A645D8(ctx, base);
	// 82A648D8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A648DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A648E0: 388B6C90  addi r4, r11, 0x6c90
	ctx.r[4].s64 = ctx.r[11].s64 + 27792;
	// 82A648E4: 4838F125  bl 0x82df3a08
	ctx.lr = 0x82A648E8;
	sub_82DF3A08(ctx, base);
	// 82A648E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A648EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A648F0: 4BFFFD49  bl 0x82a64638
	ctx.lr = 0x82A648F4;
	sub_82A64638(ctx, base);
	// 82A648F4: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82A648F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A648FC: 388BECC4  addi r4, r11, -0x133c
	ctx.r[4].s64 = ctx.r[11].s64 + -4924;
	// 82A64900: 4838F109  bl 0x82df3a08
	ctx.lr = 0x82A64904;
	sub_82DF3A08(ctx, base);
	// 82A64904: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A64908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6490C: 4BFFFD8D  bl 0x82a64698
	ctx.lr = 0x82A64910;
	sub_82A64698(ctx, base);
	// 82A64910: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82A64914: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A64918: 388BC880  addi r4, r11, -0x3780
	ctx.r[4].s64 = ctx.r[11].s64 + -14208;
	// 82A6491C: 4838F0ED  bl 0x82df3a08
	ctx.lr = 0x82A64920;
	sub_82DF3A08(ctx, base);
	// 82A64920: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A64924: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A64928: 4BFFFDD1  bl 0x82a646f8
	ctx.lr = 0x82A6492C;
	sub_82A646F8(ctx, base);
	// 82A6492C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A64930: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A64934: 388BE848  addi r4, r11, -0x17b8
	ctx.r[4].s64 = ctx.r[11].s64 + -6072;
	// 82A64938: 4838F0D1  bl 0x82df3a08
	ctx.lr = 0x82A6493C;
	sub_82DF3A08(ctx, base);
	// 82A6493C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A64940: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A64944: 4BFFFE15  bl 0x82a64758
	ctx.lr = 0x82A64948;
	sub_82A64758(ctx, base);
	// 82A64948: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6494C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A64950: 388BF674  addi r4, r11, -0x98c
	ctx.r[4].s64 = ctx.r[11].s64 + -2444;
	// 82A64954: 4838F0B5  bl 0x82df3a08
	ctx.lr = 0x82A64958;
	sub_82DF3A08(ctx, base);
	// 82A64958: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6495C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A64960: 4BFFFE59  bl 0x82a647b8
	ctx.lr = 0x82A64964;
	sub_82A647B8(ctx, base);
	// 82A64964: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82A64968: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6496C: 388B6564  addi r4, r11, 0x6564
	ctx.r[4].s64 = ctx.r[11].s64 + 25956;
	// 82A64970: 4838F099  bl 0x82df3a08
	ctx.lr = 0x82A64974;
	sub_82DF3A08(ctx, base);
	// 82A64974: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A64978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6497C: 4BFFFE9D  bl 0x82a64818
	ctx.lr = 0x82A64980;
	sub_82A64818(ctx, base);
	// 82A64980: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A64984: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A64988: 4838F081  bl 0x82df3a08
	ctx.lr = 0x82A6498C;
	sub_82DF3A08(ctx, base);
	// 82A6498C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A64990: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A64994: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A64998: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6499C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A649A0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A649A4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A649A8: 483F9FB9  bl 0x82e5e960
	ctx.lr = 0x82A649AC;
	sub_82E5E960(ctx, base);
	// 82A649AC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A649B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A649B4: 419A0008  beq cr6, 0x82a649bc
	if ctx.cr[6].eq {
	pc = 0x82A649BC; continue 'dispatch;
	}
	// 82A649B8: 4B85BED9  bl 0x822c0890
	ctx.lr = 0x82A649BC;
	sub_822C0890(ctx, base);
	// 82A649BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A649C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A649C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A649C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A649CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A649D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A649D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A649D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A649D8 size=108
    let mut pc: u32 = 0x82A649D8;
    'dispatch: loop {
        match pc {
            0x82A649D8 => {
    //   block [0x82A649D8..0x82A64A44)
	// 82A649D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A649DC: 48743791  bl 0x831a816c
	ctx.lr = 0x82A649E0;
	sub_831A8130(ctx, base);
	// 82A649E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A649E4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A649E8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A649EC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A649F0: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A649F4: 40820038  bne 0x82a64a2c
	if !ctx.cr[0].eq {
	pc = 0x82A64A2C; continue 'dispatch;
	}
	// 82A649F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A649FC: 48744F8D  bl 0x831a9988
	ctx.lr = 0x82A64A00;
	sub_831A9988(ctx, base);
	// 82A64A00: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A64A04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A64A08: 386B5A88  addi r3, r11, 0x5a88
	ctx.r[3].s64 = ctx.r[11].s64 + 23176;
	// 82A64A0C: 487436ED  bl 0x831a80f8
	ctx.lr = 0x82A64A10;
	sub_831A80F8(ctx, base);
	// 82A64A10: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A64A14: 41820018  beq 0x82a64a2c
	if ctx.cr[0].eq {
	pc = 0x82A64A2C; continue 'dispatch;
	}
	// 82A64A18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A64A1C: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 82A64A20: 480A7D81  bl 0x82b0c7a0
	ctx.lr = 0x82A64A24;
	sub_82B0C7A0(ctx, base);
	// 82A64A24: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A64A28: 48000014  b 0x82a64a3c
	pc = 0x82A64A3C; continue 'dispatch;
	// 82A64A2C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A64A30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A64A34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A64A38: 4BAADBE1  bl 0x82512618
	ctx.lr = 0x82A64A3C;
	sub_82512618(ctx, base);
	// 82A64A3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A64A40: 4874377C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A64A48 size=196
    let mut pc: u32 = 0x82A64A48;
    'dispatch: loop {
        match pc {
            0x82A64A48 => {
    //   block [0x82A64A48..0x82A64B0C)
	// 82A64A48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A64A4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A64A50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A64A54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A64A58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A64A5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A64A60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A64A64: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A64A68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A64A6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A64A70: 4B85BEC9  bl 0x822c0938
	ctx.lr = 0x82A64A74;
	sub_822C0938(ctx, base);
	// 82A64A74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A64A78: 41820028  beq 0x82a64aa0
	if ctx.cr[0].eq {
	pc = 0x82A64AA0; continue 'dispatch;
	}
	// 82A64A7C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A64A80: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A64A84: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A64A88: 392BF708  addi r9, r11, -0x8f8
	ctx.r[9].s64 = ctx.r[11].s64 + -2296;
	// 82A64A8C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A64A90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A64A94: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A64A98: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A64A9C: 48000008  b 0x82a64aa4
	pc = 0x82A64AA4; continue 'dispatch;
	// 82A64AA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A64AA4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A64AA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A64AAC: 409A0044  bne cr6, 0x82a64af0
	if !ctx.cr[6].eq {
	pc = 0x82A64AF0; continue 'dispatch;
	}
	// 82A64AB0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A64AB4: 419A001C  beq cr6, 0x82a64ad0
	if ctx.cr[6].eq {
	pc = 0x82A64AD0; continue 'dispatch;
	}
	// 82A64AB8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64ABC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A64AC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A64AC4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64AC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A64ACC: 4E800421  bctrl
	ctx.lr = 0x82A64AD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A64AD0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A64AD4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A64AD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A64ADC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A64AE0: 816B6A30  lwz r11, 0x6a30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27184 as u32) ) } as u64;
	// 82A64AE4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A64AE8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A64AEC: 4B85B515  bl 0x822c0000
	ctx.lr = 0x82A64AF0;
	sub_822C0000(ctx, base);
	// 82A64AF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A64AF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A64AF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A64AFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A64B00: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A64B04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A64B08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A64B10 size=112
    let mut pc: u32 = 0x82A64B10;
    'dispatch: loop {
        match pc {
            0x82A64B10 => {
    //   block [0x82A64B10..0x82A64B80)
	// 82A64B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A64B14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A64B18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A64B1C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A64B20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A64B24: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A64B28: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A64B2C: 396BF734  addi r11, r11, -0x8cc
	ctx.r[11].s64 = ctx.r[11].s64 + -2252;
	// 82A64B30: 394AF71C  addi r10, r10, -0x8e4
	ctx.r[10].s64 = ctx.r[10].s64 + -2276;
	// 82A64B34: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A64B38: 387F0130  addi r3, r31, 0x130
	ctx.r[3].s64 = ctx.r[31].s64 + 304;
	// 82A64B3C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82A64B40: 4BFC83A9  bl 0x82a2cee8
	ctx.lr = 0x82A64B44;
	sub_82A2CEE8(ctx, base);
	// 82A64B44: 807F012C  lwz r3, 0x12c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 82A64B48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A64B4C: 419A0008  beq cr6, 0x82a64b54
	if ctx.cr[6].eq {
	pc = 0x82A64B54; continue 'dispatch;
	}
	// 82A64B50: 4B85BD41  bl 0x822c0890
	ctx.lr = 0x82A64B54;
	sub_822C0890(ctx, base);
	// 82A64B54: 807F0124  lwz r3, 0x124(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 82A64B58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A64B5C: 419A0008  beq cr6, 0x82a64b64
	if ctx.cr[6].eq {
	pc = 0x82A64B64; continue 'dispatch;
	}
	// 82A64B60: 4B85BD31  bl 0x822c0890
	ctx.lr = 0x82A64B64;
	sub_822C0890(ctx, base);
	// 82A64B64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A64B68: 4B8EA7E9  bl 0x8234f350
	ctx.lr = 0x82A64B6C;
	sub_8234F350(ctx, base);
	// 82A64B6C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A64B70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A64B74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A64B78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A64B7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A64B80 size=8
    let mut pc: u32 = 0x82A64B80;
    'dispatch: loop {
        match pc {
            0x82A64B80 => {
    //   block [0x82A64B80..0x82A64B88)
	// 82A64B80: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82A64B84: 480004BC  b 0x82a65040
	sub_82A65040(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A64B88 size=392
    let mut pc: u32 = 0x82A64B88;
    'dispatch: loop {
        match pc {
            0x82A64B88 => {
    //   block [0x82A64B88..0x82A64D10)
	// 82A64B88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A64B8C: 487435E1  bl 0x831a816c
	ctx.lr = 0x82A64B90;
	sub_831A8130(ctx, base);
	// 82A64B90: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82A64B94: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A64B98: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A64B9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A64BA0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A64BA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A64BA8: 4BAAA971  bl 0x8250f518
	ctx.lr = 0x82A64BAC;
	sub_8250F518(ctx, base);
	// 82A64BAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64BB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A64BB4: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 82A64BB8: 409A0008  bne cr6, 0x82a64bc0
	if !ctx.cr[6].eq {
	pc = 0x82A64BC0; continue 'dispatch;
	}
	// 82A64BBC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A64BC0: 4BAC3A11  bl 0x825285d0
	ctx.lr = 0x82A64BC4;
	sub_825285D0(ctx, base);
	// 82A64BC4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A64BC8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82A64BCC: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82A64BD0: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 82A64BD4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A64BD8: C00B9534  lfs f0, -0x6acc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A64BDC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A64BE0: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A64D10 size=404
    let mut pc: u32 = 0x82A64D10;
    'dispatch: loop {
        match pc {
            0x82A64D10 => {
    //   block [0x82A64D10..0x82A64EA4)
	// 82A64D10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A64D14: 48743459  bl 0x831a816c
	ctx.lr = 0x82A64D18;
	sub_831A8130(ctx, base);
	// 82A64D18: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A64D1C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A64D20: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A64D24: 397F0026  addi r11, r31, 0x26
	ctx.r[11].s64 = ctx.r[31].s64 + 38;
	// 82A64D28: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A64D2C: 7FABF214  add r29, r11, r30
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A64D30: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82A64D34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A64D38: 419A0018  beq cr6, 0x82a64d50
	if ctx.cr[6].eq {
	pc = 0x82A64D50; continue 'dispatch;
	}
	// 82A64D3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64D40: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A64D44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A64D48: 4E800421  bctrl
	ctx.lr = 0x82A64D4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A64D4C: 48000150  b 0x82a64e9c
	pc = 0x82A64E9C; continue 'dispatch;
	// 82A64D50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A64D54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A64D58: 4BAAA771  bl 0x8250f4c8
	ctx.lr = 0x82A64D5C;
	sub_8250F4C8(ctx, base);
	// 82A64D5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64D60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A64D64: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A64D68: 409A0008  bne cr6, 0x82a64d70
	if !ctx.cr[6].eq {
	pc = 0x82A64D70; continue 'dispatch;
	}
	// 82A64D6C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A64D70: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A64D74: 4BAA5BDD  bl 0x8250a950
	ctx.lr = 0x82A64D78;
	sub_8250A950(ctx, base);
	// 82A64D78: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A64D7C: 4838CF15  bl 0x82df1c90
	ctx.lr = 0x82A64D80;
	sub_82DF1C90(ctx, base);
	// 82A64D80: 2F1F0002  cmpwi cr6, r31, 2
	ctx.cr[6].compare_i32(ctx.r[31].s32, 2, &mut ctx.xer);
	// 82A64D84: 419A0098  beq cr6, 0x82a64e1c
	if ctx.cr[6].eq {
	pc = 0x82A64E1C; continue 'dispatch;
	}
	// 82A64D88: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A64D8C: 57EA103A  slwi r10, r31, 2
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A64D90: 396B6A24  addi r11, r11, 0x6a24
	ctx.r[11].s64 = ctx.r[11].s64 + 27172;
	// 82A64D94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A64D98: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A64D9C: 4838EC6D  bl 0x82df3a08
	ctx.lr = 0x82A64DA0;
	sub_82DF3A08(ctx, base);
	// 82A64DA0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A64DA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A64DA8: 3BEBFF40  addi r31, r11, -0xc0
	ctx.r[31].s64 = ctx.r[11].s64 + -192;
	// 82A64DAC: 409A0008  bne cr6, 0x82a64db4
	if !ctx.cr[6].eq {
	pc = 0x82A64DB4; continue 'dispatch;
	}
	// 82A64DB0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A64DB4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A64DB8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A64DBC: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82A64DC0: 4BAAD359  bl 0x82512118
	ctx.lr = 0x82A64DC4;
	sub_82512118(ctx, base);
	// 82A64DC4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A64DC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A64DCC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A64DD0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A64DD4: 38E0000B  li r7, 0xb
	ctx.r[7].s64 = 11;
	// 82A64DD8: 4BD6FED9  bl 0x827d4cb0
	ctx.lr = 0x82A64DDC;
	sub_827D4CB0(ctx, base);
	// 82A64DDC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A64DE0: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 82A64DE4: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A64DE8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A64DEC: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A64DF0: 4B85F671  bl 0x822c4460
	ctx.lr = 0x82A64DF4;
	sub_822C4460(ctx, base);
	// 82A64DF4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A64DF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A64DFC: 419A0008  beq cr6, 0x82a64e04
	if ctx.cr[6].eq {
	pc = 0x82A64E04; continue 'dispatch;
	}
	// 82A64E00: 4B85BA91  bl 0x822c0890
	ctx.lr = 0x82A64E04;
	sub_822C0890(ctx, base);
	// 82A64E04: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A64E08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A64E0C: 419A0008  beq cr6, 0x82a64e14
	if ctx.cr[6].eq {
	pc = 0x82A64E14; continue 'dispatch;
	}
	// 82A64E10: 4B85BA81  bl 0x822c0890
	ctx.lr = 0x82A64E14;
	sub_822C0890(ctx, base);
	// 82A64E14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A64E18: 48000078  b 0x82a64e90
	pc = 0x82A64E90; continue 'dispatch;
	// 82A64E1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A64E20: 4BAACCC9  bl 0x82511ae8
	ctx.lr = 0x82A64E24;
	sub_82511AE8(ctx, base);
	// 82A64E24: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A64E28: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82A64E2C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A64E30: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82A64E34: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A64E38: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A64EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A64EA8 size=404
    let mut pc: u32 = 0x82A64EA8;
    'dispatch: loop {
        match pc {
            0x82A64EA8 => {
    //   block [0x82A64EA8..0x82A6503C)
	// 82A64EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A64EAC: 487432C1  bl 0x831a816c
	ctx.lr = 0x82A64EB0;
	sub_831A8130(ctx, base);
	// 82A64EB0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A64EB4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A64EB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A64EBC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A64EC0: 4BAAD471  bl 0x82512330
	ctx.lr = 0x82A64EC4;
	sub_82512330(ctx, base);
	// 82A64EC4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A64EC8: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A64ECC: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A64ED0: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A64ED4: 3BABF6DC  addi r29, r11, -0x924
	ctx.r[29].s64 = ctx.r[11].s64 + -2340;
	// 82A64ED8: 394A6910  addi r10, r10, 0x6910
	ctx.r[10].s64 = ctx.r[10].s64 + 26896;
	// 82A64EDC: 396000F0  li r11, 0xf0
	ctx.r[11].s64 = 240;
	// 82A64EE0: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82A64EE4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A64EE8: 3929F734  addi r9, r9, -0x8cc
	ctx.r[9].s64 = ctx.r[9].s64 + -2252;
	// 82A64EEC: C1BD0010  lfs f13, 0x10(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A64EF0: 3908F71C  addi r8, r8, -0x8e4
	ctx.r[8].s64 = ctx.r[8].s64 + -2276;
	// 82A64EF4: 93DF00E4  stw r30, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[30].u32 ) };
	// 82A64EF8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A64EFC: C19D0008  lfs f12, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A64F00: 911F0028  stw r8, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[8].u32 ) };
	// 82A64F04: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A65040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A65040 size=76
    let mut pc: u32 = 0x82A65040;
    'dispatch: loop {
        match pc {
            0x82A65040 => {
    //   block [0x82A65040..0x82A6508C)
	// 82A65040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A65044: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A65048: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6504C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A65050: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A65054: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A65058: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A6505C: 4BFFFAB5  bl 0x82a64b10
	ctx.lr = 0x82A65060;
	sub_82A64B10(ctx, base);
	// 82A65060: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A65064: 4182000C  beq 0x82a65070
	if ctx.cr[0].eq {
	pc = 0x82A65070; continue 'dispatch;
	}
	// 82A65068: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6506C: 4838D36D  bl 0x82df23d8
	ctx.lr = 0x82A65070;
	sub_82DF23D8(ctx, base);
	// 82A65070: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A65074: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A65078: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6507C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A65080: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A65084: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A65088: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A65090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A65090 size=508
    let mut pc: u32 = 0x82A65090;
    'dispatch: loop {
        match pc {
            0x82A65090 => {
    //   block [0x82A65090..0x82A6528C)
	// 82A65090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A65094: 487430D9  bl 0x831a816c
	ctx.lr = 0x82A65098;
	sub_831A8130(ctx, base);
	// 82A65098: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6509C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A650A0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A650A4: 4BAAB665  bl 0x82510708
	ctx.lr = 0x82A650A8;
	sub_82510708(ctx, base);
	// 82A650A8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A650AC: 3BABF6E8  addi r29, r11, -0x918
	ctx.r[29].s64 = ctx.r[11].s64 + -2328;
	// 82A650B0: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A650B4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A650B8: 41980110  blt cr6, 0x82a651c8
	if ctx.cr[6].lt {
	pc = 0x82A651C8; continue 'dispatch;
	}
	// 82A650BC: 419A00D0  beq cr6, 0x82a6518c
	if ctx.cr[6].eq {
	pc = 0x82A6518C; continue 'dispatch;
	}
	// 82A650C0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A650C4: 41980058  blt cr6, 0x82a6511c
	if ctx.cr[6].lt {
	pc = 0x82A6511C; continue 'dispatch;
	}
	// 82A650C8: 409A0138  bne cr6, 0x82a65200
	if !ctx.cr[6].eq {
	pc = 0x82A65200; continue 'dispatch;
	}
	// 82A650CC: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A650D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A650D4: C19F0104  lfs f12, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A650D8: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A650DC: C17F00F4  lfs f11, 0xf4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A650E0: EC0D603A  fmadds f0, f13, f0, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82A650E4: EDAC5B7A  fmadds f13, f12, f13, f11
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 82A650E8: C19F0108  lfs f12, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A650EC: D1BF00F4  stfs f13, 0xf4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82A650F0: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82A650F4: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A650F8: EDAC0028  fsubs f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A650FC: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A65100: D1BF0108  stfs f13, 0x108(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82A65104: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A65108: 419900F8  bgt cr6, 0x82a65200
	if ctx.cr[6].gt {
	pc = 0x82A65200; continue 'dispatch;
	}
	// 82A6510C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A65110: 48068BA9  bl 0x82acdcb8
	ctx.lr = 0x82A65114;
	sub_82ACDCB8(ctx, base);
	// 82A65114: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A65118: 480000E4  b 0x82a651fc
	pc = 0x82A651FC; continue 'dispatch;
	// 82A6511C: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A65120: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A65124: C19F0104  lfs f12, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A65128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6512C: C17F00F4  lfs f11, 0xf4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A65130: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A65134: ED6C5B7A  fmadds f11, f12, f13, f11
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 82A65138: EC0D603A  fmadds f0, f13, f0, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82A6513C: D17F00F4  stfs f11, 0xf4(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82A65140: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82A65144: 4BFFFBCD  bl 0x82a64d10
	ctx.lr = 0x82A65148;
	sub_82A64D10(ctx, base);
	// 82A65148: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A6514C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A65150: 480687F1  bl 0x82acd940
	ctx.lr = 0x82A65154;
	sub_82ACD940(ctx, base);
	// 82A65154: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A65158: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6515C: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A65160: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82A65164: 4BA85925  bl 0x824eaa88
	ctx.lr = 0x82A65168;
	sub_824EAA88(ctx, base);
	// 82A65168: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6516C: 4BA846E5  bl 0x824e9850
	ctx.lr = 0x82A65170;
	sub_824E9850(ctx, base);
	// 82A65170: C01F0108  lfs f0, 0x108(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A65174: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A65178: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82A6517C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A65180: 4838CB11  bl 0x82df1c90
	ctx.lr = 0x82A65184;
	sub_82DF1C90(ctx, base);
	// 82A65184: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82A65188: 48000074  b 0x82a651fc
	pc = 0x82A651FC; continue 'dispatch;
	// 82A6518C: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A65190: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A65194: C19F0104  lfs f12, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A65198: C17F00F4  lfs f11, 0xf4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A6519C: ED6C5B7A  fmadds f11, f12, f13, f11
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 82A651A0: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A651A4: EC0D603A  fmadds f0, f13, f0, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82A651A8: D17F00F4  stfs f11, 0xf4(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82A651AC: C1AB08A4  lfs f13, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A651B0: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82A651B4: FD805890  fmr f12, f11
	ctx.f[12].f64 = ctx.f[11].f64;
	// 82A651B8: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82A651BC: 41990044  bgt cr6, 0x82a65200
	if ctx.cr[6].gt {
	pc = 0x82A65200; continue 'dispatch;
	}
	// 82A651C0: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A651C4: 48000038  b 0x82a651fc
	pc = 0x82A651FC; continue 'dispatch;
	// 82A651C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A651CC: 4BFFF9BD  bl 0x82a64b88
	ctx.lr = 0x82A651D0;
	sub_82A64B88(ctx, base);
	// 82A651D0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A651D4: 4182002C  beq 0x82a65200
	if ctx.cr[0].eq {
	pc = 0x82A65200; continue 'dispatch;
	}
	// 82A651D8: C01DFFFC  lfs f0, -4(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A651DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A651E0: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82A651E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A651E8: 4BFFFB29  bl 0x82a64d10
	ctx.lr = 0x82A651EC;
	sub_82A64D10(ctx, base);
	// 82A651EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A651F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A651F4: 4BFFFB1D  bl 0x82a64d10
	ctx.lr = 0x82A651F8;
	sub_82A64D10(ctx, base);
	// 82A651F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A651FC: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82A65200: 817F010C  lwz r11, 0x10c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 82A65204: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A65208: C1BD0014  lfs f13, 0x14(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A6520C: 389F010C  addi r4, r31, 0x10c
	ctx.r[4].s64 = ctx.r[31].s64 + 268;
	// 82A65210: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82A65214: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 82A65218: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A6521C: FD80069C  fcfid f12, f0
	ctx.f[12].f64 = (ctx.f[0].s64 as f64);
	// 82A65220: C00AF770  lfs f0, -0x890(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-2192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A65224: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A65228: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6522C: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82A65230: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A65234: 40980030  bge cr6, 0x82a65264
	if !ctx.cr[6].lt {
	pc = 0x82A65264; continue 'dispatch;
	}
	// 82A65238: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6523C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A65240: C1BF0118  lfs f13, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A65244: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A65248: C00AF778  lfs f0, -0x888(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-2184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6524C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A65250: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82A65254: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 82A65258: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6525C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A65260: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A65264: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A65268: 480490D9  bl 0x82aae340
	ctx.lr = 0x82A6526C;
	sub_82AAE340(ctx, base);
	// 82A6526C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A65270: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A65274: 4BAAC87D  bl 0x82511af0
	ctx.lr = 0x82A65278;
	sub_82511AF0(ctx, base);
	// 82A65278: 389F00F0  addi r4, r31, 0xf0
	ctx.r[4].s64 = ctx.r[31].s64 + 240;
	// 82A6527C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A65280: 4BAAC801  bl 0x82511a80
	ctx.lr = 0x82A65284;
	sub_82511A80(ctx, base);
	// 82A65284: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A65288: 48742F34  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A65290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A65290 size=128
    let mut pc: u32 = 0x82A65290;
    'dispatch: loop {
        match pc {
            0x82A65290 => {
    //   block [0x82A65290..0x82A65310)
	// 82A65290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A65294: 48742ED9  bl 0x831a816c
	ctx.lr = 0x82A65298;
	sub_831A8130(ctx, base);
	// 82A65298: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A6529C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A652A0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A652A4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A652A8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A652AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A652B0: 388BF780  addi r4, r11, -0x880
	ctx.r[4].s64 = ctx.r[11].s64 + -2176;
	// 82A652B4: 38A00041  li r5, 0x41
	ctx.r[5].s64 = 65;
	// 82A652B8: 38600150  li r3, 0x150
	ctx.r[3].s64 = 336;
	// 82A652BC: 4838D12D  bl 0x82df23e8
	ctx.lr = 0x82A652C0;
	sub_82DF23E8(ctx, base);
	// 82A652C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A652C4: 41820014  beq 0x82a652d8
	if ctx.cr[0].eq {
	pc = 0x82A652D8; continue 'dispatch;
	}
	// 82A652C8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A652CC: 4BFFFBDD  bl 0x82a64ea8
	ctx.lr = 0x82A652D0;
	sub_82A64EA8(ctx, base);
	// 82A652D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A652D4: 48000008  b 0x82a652dc
	pc = 0x82A652DC; continue 'dispatch;
	// 82A652D8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A652DC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A652E0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A652E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A652E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A652EC: 4BFFF75D  bl 0x82a64a48
	ctx.lr = 0x82A652F0;
	sub_82A64A48(ctx, base);
	// 82A652F0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A652F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A652F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A652FC: 4B85AD05  bl 0x822c0000
	ctx.lr = 0x82A65300;
	sub_822C0000(ctx, base);
	// 82A65300: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A65304: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A65308: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A6530C: 48742EB0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A65310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A65310 size=228
    let mut pc: u32 = 0x82A65310;
    'dispatch: loop {
        match pc {
            0x82A65310 => {
    //   block [0x82A65310..0x82A653F4)
	// 82A65310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A65314: 48742E59  bl 0x831a816c
	ctx.lr = 0x82A65318;
	sub_831A8130(ctx, base);
	// 82A65318: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6531C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A65320: 809F0128  lwz r4, 0x128(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 82A65324: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82A65328: 419A00C4  beq cr6, 0x82a653ec
	if ctx.cr[6].eq {
	pc = 0x82A653EC; continue 'dispatch;
	}
	// 82A6532C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A65330: 483C57B9  bl 0x82e2aae8
	ctx.lr = 0x82A65334;
	sub_82E2AAE8(ctx, base);
	// 82A65334: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A65338: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6533C: 808B6A20  lwz r4, 0x6a20(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27168 as u32) ) } as u64;
	// 82A65340: 4838E6C9  bl 0x82df3a08
	ctx.lr = 0x82A65344;
	sub_82DF3A08(ctx, base);
	// 82A65344: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A65348: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A6534C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A65350: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A65354: 483C9B1D  bl 0x82e2ee70
	ctx.lr = 0x82A65358;
	sub_82E2EE70(ctx, base);
	// 82A65358: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6535C: 4838E0CD  bl 0x82df3428
	ctx.lr = 0x82A65360;
	sub_82DF3428(ctx, base);
	// 82A65360: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A65364: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A65368: 388BF780  addi r4, r11, -0x880
	ctx.r[4].s64 = ctx.r[11].s64 + -2176;
	// 82A6536C: 38A0007D  li r5, 0x7d
	ctx.r[5].s64 = 125;
	// 82A65370: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82A65374: 4838D075  bl 0x82df23e8
	ctx.lr = 0x82A65378;
	sub_82DF23E8(ctx, base);
	// 82A65378: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A6537C: 41820014  beq 0x82a65390
	if ctx.cr[0].eq {
	pc = 0x82A65390; continue 'dispatch;
	}
	// 82A65380: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A65384: 483B150D  bl 0x82e16890
	ctx.lr = 0x82A65388;
	sub_82E16890(ctx, base);
	// 82A65388: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6538C: 48000008  b 0x82a65394
	pc = 0x82A65394; continue 'dispatch;
	// 82A65390: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A65394: 3BDF0120  addi r30, r31, 0x120
	ctx.r[30].s64 = ctx.r[31].s64 + 288;
	// 82A65398: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6539C: 4B8F7FD5  bl 0x8235d370
	ctx.lr = 0x82A653A0;
	sub_8235D370(ctx, base);
	// 82A653A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A653A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A653A8: 83BF0120  lwz r29, 0x120(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 82A653AC: 4BAACD6D  bl 0x82512118
	ctx.lr = 0x82A653B0;
	sub_82512118(ctx, base);
	// 82A653B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A653B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A653B8: 483AFCF9  bl 0x82e150b0
	ctx.lr = 0x82A653BC;
	sub_82E150B0(ctx, base);
	// 82A653BC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A653C0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A653C4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A653C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A653CC: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A653D0: 4BAAB789  bl 0x82510b58
	ctx.lr = 0x82A653D4;
	sub_82510B58(ctx, base);
	// 82A653D4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A653D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A653DC: 419A0008  beq cr6, 0x82a653e4
	if ctx.cr[6].eq {
	pc = 0x82A653E4; continue 'dispatch;
	}
	// 82A653E0: 4B85B4B1  bl 0x822c0890
	ctx.lr = 0x82A653E4;
	sub_822C0890(ctx, base);
	// 82A653E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A653E8: 483C5719  bl 0x82e2ab00
	ctx.lr = 0x82A653EC;
	sub_82E2AB00(ctx, base);
	// 82A653EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A653F0: 48742DCC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A653F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A653F8 size=132
    let mut pc: u32 = 0x82A653F8;
    'dispatch: loop {
        match pc {
            0x82A653F8 => {
    //   block [0x82A653F8..0x82A6547C)
	// 82A653F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A653FC: 48742D71  bl 0x831a816c
	ctx.lr = 0x82A65400;
	sub_831A8130(ctx, base);
	// 82A65400: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A65404: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A65408: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A6540C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82A65410: 4BAAC5C9  bl 0x825119d8
	ctx.lr = 0x82A65414;
	sub_825119D8(ctx, base);
	// 82A65414: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82A65418: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6541C: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82A65420: 4838E5E9  bl 0x82df3a08
	ctx.lr = 0x82A65424;
	sub_82DF3A08(ctx, base);
	// 82A65424: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A65428: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6542C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A65430: 4BAA3351  bl 0x82508780
	ctx.lr = 0x82A65434;
	sub_82508780(ctx, base);
	// 82A65434: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A65438: 4838DFF1  bl 0x82df3428
	ctx.lr = 0x82A6543C;
	sub_82DF3428(ctx, base);
	// 82A6543C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A65440: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82A65444: 409A0008  bne cr6, 0x82a6544c
	if !ctx.cr[6].eq {
	pc = 0x82A6544C; continue 'dispatch;
	}
	// 82A65448: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A6544C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A65450: 4BAA3351  bl 0x825087a0
	ctx.lr = 0x82A65454;
	sub_825087A0(ctx, base);
	// 82A65454: 397F0128  addi r11, r31, 0x128
	ctx.r[11].s64 = ctx.r[31].s64 + 296;
	// 82A65458: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 82A6545C: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82A65460: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A65464: 917F0128  stw r11, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 82A65468: 4B85EFF9  bl 0x822c4460
	ctx.lr = 0x82A6546C;
	sub_822C4460(ctx, base);
	// 82A6546C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A65470: 4BFFFEA1  bl 0x82a65310
	ctx.lr = 0x82A65474;
	sub_82A65310(ctx, base);
	// 82A65474: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A65478: 48742D44  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A65480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A65480 size=136
    let mut pc: u32 = 0x82A65480;
    'dispatch: loop {
        match pc {
            0x82A65480 => {
    //   block [0x82A65480..0x82A65508)
	// 82A65480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A65484: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A65488: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6548C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A65490: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A65494: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A65498: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A6549C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82A654A0: 409A0020  bne cr6, 0x82a654c0
	if !ctx.cr[6].eq {
	pc = 0x82A654C0; continue 'dispatch;
	}
	// 82A654A4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A654A8: 419A0048  beq cr6, 0x82a654f0
	if ctx.cr[6].eq {
	pc = 0x82A654F0; continue 'dispatch;
	}
	// 82A654AC: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82A654B0: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82A654B4: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 82A654B8: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82A654BC: 48000034  b 0x82a654f0
	pc = 0x82A654F0; continue 'dispatch;
	// 82A654C0: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82A654C4: 419A002C  beq cr6, 0x82a654f0
	if ctx.cr[6].eq {
	pc = 0x82A654F0; continue 'dispatch;
	}
	// 82A654C8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A654CC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A654D0: 388B6AD0  addi r4, r11, 0x6ad0
	ctx.r[4].s64 = ctx.r[11].s64 + 27344;
	// 82A654D4: 48742C25  bl 0x831a80f8
	ctx.lr = 0x82A654D8;
	sub_831A80F8(ctx, base);
	// 82A654D8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A654DC: 4182000C  beq 0x82a654e8
	if ctx.cr[0].eq {
	pc = 0x82A654E8; continue 'dispatch;
	}
	// 82A654E0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A654E4: 4800000C  b 0x82a654f0
	pc = 0x82A654F0; continue 'dispatch;
	// 82A654E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A654EC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A654F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A654F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A654F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A654FC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A65500: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A65504: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A65508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A65508 size=164
    let mut pc: u32 = 0x82A65508;
    'dispatch: loop {
        match pc {
            0x82A65508 => {
    //   block [0x82A65508..0x82A655AC)
	// 82A65508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6550C: 48742C5D  bl 0x831a8168
	ctx.lr = 0x82A65510;
	sub_831A8130(ctx, base);
	// 82A65510: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A65514: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A65518: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A6551C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A65520: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82A65524: 41820038  beq 0x82a6555c
	if ctx.cr[0].eq {
	pc = 0x82A6555C; continue 'dispatch;
	}
	// 82A65528: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6552C: 4874445D  bl 0x831a9988
	ctx.lr = 0x82A65530;
	sub_831A9988(ctx, base);
	// 82A65530: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A65534: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A65538: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 82A6553C: 48742BBD  bl 0x831a80f8
	ctx.lr = 0x82A65540;
	sub_831A80F8(ctx, base);
	// 82A65540: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A65544: 41820018  beq 0x82a6555c
	if ctx.cr[0].eq {
	pc = 0x82A6555C; continue 'dispatch;
	}
	// 82A65548: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6554C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A65550: 4BBFC199  bl 0x826616e8
	ctx.lr = 0x82A65554;
	sub_826616E8(ctx, base);
	// 82A65554: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A65558: 4800004C  b 0x82a655a4
	pc = 0x82A655A4; continue 'dispatch;
	// 82A6555C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A65560: 419A0034  beq cr6, 0x82a65594
	if ctx.cr[6].eq {
	pc = 0x82A65594; continue 'dispatch;
	}
	// 82A65564: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A65568: 48744421  bl 0x831a9988
	ctx.lr = 0x82A6556C;
	sub_831A9988(ctx, base);
	// 82A6556C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82A65570: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A65574: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 82A65578: 48742B81  bl 0x831a80f8
	ctx.lr = 0x82A6557C;
	sub_831A80F8(ctx, base);
	// 82A6557C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A65580: 41820014  beq 0x82a65594
	if ctx.cr[0].eq {
	pc = 0x82A65594; continue 'dispatch;
	}
	// 82A65584: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A65588: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A6558C: 4BC3BDCD  bl 0x826a1358
	ctx.lr = 0x82A65590;
	sub_826A1358(ctx, base);
	// 82A65590: 4BFFFFC4  b 0x82a65554
	pc = 0x82A65554; continue 'dispatch;
	// 82A65594: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A65598: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6559C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A655A0: 4BAAD079  bl 0x82512618
	ctx.lr = 0x82A655A4;
	sub_82512618(ctx, base);
	// 82A655A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A655A8: 48742C10  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A655B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A655B0 size=204
    let mut pc: u32 = 0x82A655B0;
    'dispatch: loop {
        match pc {
            0x82A655B0 => {
    //   block [0x82A655B0..0x82A6567C)
	// 82A655B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A655B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A655B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A655BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A655C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A655C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A655C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A655CC: 4BAAB13D  bl 0x82510708
	ctx.lr = 0x82A655D0;
	sub_82510708(ctx, base);
	// 82A655D0: C01F0110  lfs f0, 0x110(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A655D4: 389F0100  addi r4, r31, 0x100
	ctx.r[4].s64 = ctx.r[31].s64 + 256;
	// 82A655D8: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A655DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A655E0: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82A655E4: 4841765D  bl 0x82e7cc40
	ctx.lr = 0x82A655E8;
	sub_82E7CC40(ctx, base);
	// 82A655E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A655EC: 4BAAC56D  bl 0x82511b58
	ctx.lr = 0x82A655F0;
	sub_82511B58(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A65680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A65680 size=196
    let mut pc: u32 = 0x82A65680;
    'dispatch: loop {
        match pc {
            0x82A65680 => {
    //   block [0x82A65680..0x82A65744)
	// 82A65680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A65684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A65688: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6568C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A65690: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A65694: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A65698: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A6569C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A656A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A656A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A656A8: 4B85B291  bl 0x822c0938
	ctx.lr = 0x82A656AC;
	sub_822C0938(ctx, base);
	// 82A656AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A656B0: 41820028  beq 0x82a656d8
	if ctx.cr[0].eq {
	pc = 0x82A656D8; continue 'dispatch;
	}
	// 82A656B4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A656B8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A656BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A656C0: 392BF894  addi r9, r11, -0x76c
	ctx.r[9].s64 = ctx.r[11].s64 + -1900;
	// 82A656C4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A656C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A656CC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A656D0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A656D4: 48000008  b 0x82a656dc
	pc = 0x82A656DC; continue 'dispatch;
	// 82A656D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A656DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A656E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A656E4: 409A0044  bne cr6, 0x82a65728
	if !ctx.cr[6].eq {
	pc = 0x82A65728; continue 'dispatch;
	}
	// 82A656E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A656EC: 419A001C  beq cr6, 0x82a65708
	if ctx.cr[6].eq {
	pc = 0x82A65708; continue 'dispatch;
	}
	// 82A656F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A656F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A656F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A656FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A65700: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A65704: 4E800421  bctrl
	ctx.lr = 0x82A65708;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A65708: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6570C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A65710: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A65714: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A65718: 816B6ACC  lwz r11, 0x6acc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27340 as u32) ) } as u64;
	// 82A6571C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A65720: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A65724: 4B85A8DD  bl 0x822c0000
	ctx.lr = 0x82A65728;
	sub_822C0000(ctx, base);
	// 82A65728: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6572C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A65730: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A65734: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A65738: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6573C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A65740: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A65748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A65748 size=72
    let mut pc: u32 = 0x82A65748;
    'dispatch: loop {
        match pc {
            0x82A65748 => {
    //   block [0x82A65748..0x82A65790)
	// 82A65748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6574C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A65750: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A65754: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82A65758: 419A001C  beq cr6, 0x82a65774
	if ctx.cr[6].eq {
	pc = 0x82A65774; continue 'dispatch;
	}
	// 82A6575C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A65760: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A65764: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82A65768: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A6576C: 4BFFFD15  bl 0x82a65480
	ctx.lr = 0x82A65770;
	sub_82A65480(ctx, base);
	// 82A65770: 48000010  b 0x82a65780
	pc = 0x82A65780; continue 'dispatch;
	// 82A65774: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A65778: 396B6AD0  addi r11, r11, 0x6ad0
	ctx.r[11].s64 = ctx.r[11].s64 + 27344;
	// 82A6577C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A65780: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A65784: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A65788: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6578C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A65790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A65790 size=212
    let mut pc: u32 = 0x82A65790;
    'dispatch: loop {
        match pc {
            0x82A65790 => {
    //   block [0x82A65790..0x82A65864)
	// 82A65790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A65794: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A65798: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6579C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82A657A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A657A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A657A8: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82A657AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A657B0: 38AABA80  addi r5, r10, -0x4580
	ctx.r[5].s64 = ctx.r[10].s64 + -17792;
	// 82A657B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A657B8: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A657BC: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A657C0: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A657C4: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82A657C8: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82A657CC: 4BAACA95  bl 0x82512260
	ctx.lr = 0x82A657D0;
	sub_82512260(ctx, base);
	// 82A657D0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82A657D4: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A657D8: 38EBA214  addi r7, r11, -0x5dec
	ctx.r[7].s64 = ctx.r[11].s64 + -24044;
	// 82A657DC: 394AF90C  addi r10, r10, -0x6f4
	ctx.r[10].s64 = ctx.r[10].s64 + -1780;
	// 82A657E0: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A657E4: 90FF00E4  stw r7, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[7].u32 ) };
	// 82A657E8: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A657EC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A657F0: 3929F8F8  addi r9, r9, -0x708
	ctx.r[9].s64 = ctx.r[9].s64 + -1800;
	// 82A657F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A657F8: 3908F8AC  addi r8, r8, -0x754
	ctx.r[8].s64 = ctx.r[8].s64 + -1876;
	// 82A657FC: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82A65800: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A65804: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82A65808: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 82A6580C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A65810: 394A6910  addi r10, r10, 0x6910
	ctx.r[10].s64 = ctx.r[10].s64 + 26896;
	// 82A65814: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 82A65818: 39000100  li r8, 0x100
	ctx.r[8].s64 = 256;
	// 82A6581C: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 82A65820: 913F00F4  stw r9, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[9].u32 ) };
	// 82A65824: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82A65828: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 82A6582C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A65830: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 82A65834: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A65868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A65868 size=8
    let mut pc: u32 = 0x82A65868;
    'dispatch: loop {
        match pc {
            0x82A65868 => {
    //   block [0x82A65868..0x82A65870)
	// 82A65868: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82A6586C: 48000094  b 0x82a65900
	sub_82A65900(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A65870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A65870 size=8
    let mut pc: u32 = 0x82A65870;
    'dispatch: loop {
        match pc {
            0x82A65870 => {
    //   block [0x82A65870..0x82A65878)
	// 82A65870: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 82A65874: 4800008C  b 0x82a65900
	sub_82A65900(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A65878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A65878 size=136
    let mut pc: u32 = 0x82A65878;
    'dispatch: loop {
        match pc {
            0x82A65878 => {
    //   block [0x82A65878..0x82A65900)
	// 82A65878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6587C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A65880: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A65884: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A65888: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6588C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A65890: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A65894: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A65898: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A6589C: 396BF90C  addi r11, r11, -0x6f4
	ctx.r[11].s64 = ctx.r[11].s64 + -1780;
	// 82A658A0: 394AF8F8  addi r10, r10, -0x708
	ctx.r[10].s64 = ctx.r[10].s64 + -1800;
	// 82A658A4: 3929F8AC  addi r9, r9, -0x754
	ctx.r[9].s64 = ctx.r[9].s64 + -1876;
	// 82A658A8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A658AC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82A658B0: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 82A658B4: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 82A658B8: 807F00FC  lwz r3, 0xfc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82A658BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A658C0: 419A0008  beq cr6, 0x82a658c8
	if ctx.cr[6].eq {
	pc = 0x82A658C8; continue 'dispatch;
	}
	// 82A658C4: 4B85AFCD  bl 0x822c0890
	ctx.lr = 0x82A658C8;
	sub_822C0890(ctx, base);
	// 82A658C8: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82A658CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A658D0: 419A0008  beq cr6, 0x82a658d8
	if ctx.cr[6].eq {
	pc = 0x82A658D8; continue 'dispatch;
	}
	// 82A658D4: 4B85AFBD  bl 0x822c0890
	ctx.lr = 0x82A658D8;
	sub_822C0890(ctx, base);
	// 82A658D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A658DC: 4BD41D7D  bl 0x827a7658
	ctx.lr = 0x82A658E0;
	sub_827A7658(ctx, base);
	// 82A658E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A658E4: 4B8E9A6D  bl 0x8234f350
	ctx.lr = 0x82A658E8;
	sub_8234F350(ctx, base);
	// 82A658E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A658EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A658F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A658F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A658F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A658FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A65900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A65900 size=76
    let mut pc: u32 = 0x82A65900;
    'dispatch: loop {
        match pc {
            0x82A65900 => {
    //   block [0x82A65900..0x82A6594C)
	// 82A65900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A65904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A65908: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6590C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A65910: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A65914: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A65918: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A6591C: 4BFFFF5D  bl 0x82a65878
	ctx.lr = 0x82A65920;
	sub_82A65878(ctx, base);
	// 82A65920: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A65924: 4182000C  beq 0x82a65930
	if ctx.cr[0].eq {
	pc = 0x82A65930; continue 'dispatch;
	}
	// 82A65928: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6592C: 4838CAAD  bl 0x82df23d8
	ctx.lr = 0x82A65930;
	sub_82DF23D8(ctx, base);
	// 82A65930: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A65934: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A65938: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6593C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A65940: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A65944: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A65948: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A65950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A65950 size=240
    let mut pc: u32 = 0x82A65950;
    'dispatch: loop {
        match pc {
            0x82A65950 => {
    //   block [0x82A65950..0x82A65A40)
	// 82A65950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A65954: 48742819  bl 0x831a816c
	ctx.lr = 0x82A65958;
	sub_831A8130(ctx, base);
	// 82A65958: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6595C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A65960: 809F00F8  lwz r4, 0xf8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82A65964: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82A65968: 419A00D0  beq cr6, 0x82a65a38
	if ctx.cr[6].eq {
	pc = 0x82A65A38; continue 'dispatch;
	}
	// 82A6596C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A65970: 483C5179  bl 0x82e2aae8
	ctx.lr = 0x82A65974;
	sub_82E2AAE8(ctx, base);
	// 82A65974: 815F00F4  lwz r10, 0xf4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A65978: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6597C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A65980: 396BF870  addi r11, r11, -0x790
	ctx.r[11].s64 = ctx.r[11].s64 + -1936;
	// 82A65984: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A65988: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A6598C: 4838E07D  bl 0x82df3a08
	ctx.lr = 0x82A65990;
	sub_82DF3A08(ctx, base);
	// 82A65990: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A65994: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A65998: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A6599C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A659A0: 483C94D1  bl 0x82e2ee70
	ctx.lr = 0x82A659A4;
	sub_82E2EE70(ctx, base);
	// 82A659A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A659A8: 4838DA81  bl 0x82df3428
	ctx.lr = 0x82A659AC;
	sub_82DF3428(ctx, base);
	// 82A659AC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A659B0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A659B4: 388BF950  addi r4, r11, -0x6b0
	ctx.r[4].s64 = ctx.r[11].s64 + -1712;
	// 82A659B8: 38A000BB  li r5, 0xbb
	ctx.r[5].s64 = 187;
	// 82A659BC: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82A659C0: 4838CA29  bl 0x82df23e8
	ctx.lr = 0x82A659C4;
	sub_82DF23E8(ctx, base);
	// 82A659C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A659C8: 41820014  beq 0x82a659dc
	if ctx.cr[0].eq {
	pc = 0x82A659DC; continue 'dispatch;
	}
	// 82A659CC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A659D0: 483B0EC1  bl 0x82e16890
	ctx.lr = 0x82A659D4;
	sub_82E16890(ctx, base);
	// 82A659D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A659D8: 48000008  b 0x82a659e0
	pc = 0x82A659E0; continue 'dispatch;
	// 82A659DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A659E0: 3BDF00EC  addi r30, r31, 0xec
	ctx.r[30].s64 = ctx.r[31].s64 + 236;
	// 82A659E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A659E8: 4B8F7989  bl 0x8235d370
	ctx.lr = 0x82A659EC;
	sub_8235D370(ctx, base);
	// 82A659EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A659F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A659F4: 83BF00EC  lwz r29, 0xec(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A659F8: 4BAAC721  bl 0x82512118
	ctx.lr = 0x82A659FC;
	sub_82512118(ctx, base);
	// 82A659FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A65A00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A65A04: 483AF6AD  bl 0x82e150b0
	ctx.lr = 0x82A65A08;
	sub_82E150B0(ctx, base);
	// 82A65A08: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A65A0C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A65A10: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A65A14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A65A18: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A65A1C: 4BAAB13D  bl 0x82510b58
	ctx.lr = 0x82A65A20;
	sub_82510B58(ctx, base);
	// 82A65A20: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A65A24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A65A28: 419A0008  beq cr6, 0x82a65a30
	if ctx.cr[6].eq {
	pc = 0x82A65A30; continue 'dispatch;
	}
	// 82A65A2C: 4B85AE65  bl 0x822c0890
	ctx.lr = 0x82A65A30;
	sub_822C0890(ctx, base);
	// 82A65A30: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A65A34: 483C50CD  bl 0x82e2ab00
	ctx.lr = 0x82A65A38;
	sub_82E2AB00(ctx, base);
	// 82A65A38: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A65A3C: 48742780  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A65A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A65A40 size=816
    let mut pc: u32 = 0x82A65A40;
    'dispatch: loop {
        match pc {
            0x82A65A40 => {
    //   block [0x82A65A40..0x82A65D70)
	// 82A65A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A65A44: 48742725  bl 0x831a8168
	ctx.lr = 0x82A65A48;
	sub_831A8130(ctx, base);
	// 82A65A48: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A65A4C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A65A50: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A65A54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A65A58: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A65A5C: 816BDFE4  lwz r11, -0x201c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8220 as u32) ) } as u64;
	// 82A65A60: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A65A64: 409A0304  bne cr6, 0x82a65d68
	if !ctx.cr[6].eq {
	pc = 0x82A65D68; continue 'dispatch;
	}
	// 82A65A68: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A65A6C: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 82A65A70: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82A65A74: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 82A65A78: 3BA100B0  addi r29, r1, 0xb0
	ctx.r[29].s64 = ctx.r[1].s64 + 176;
	// 82A65A7C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A65A80: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A65D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A65D70 size=764
    let mut pc: u32 = 0x82A65D70;
    'dispatch: loop {
        match pc {
            0x82A65D70 => {
    //   block [0x82A65D70..0x82A6606C)
	// 82A65D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A65D74: 487423F1  bl 0x831a8164
	ctx.lr = 0x82A65D78;
	sub_831A8130(ctx, base);
	// 82A65D78: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A65D7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A65D80: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A65D84: 4BAABD65  bl 0x82511ae8
	ctx.lr = 0x82A65D88;
	sub_82511AE8(ctx, base);
	// 82A65D88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A65D8C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A65D90: 4BB818A1  bl 0x825e7630
	ctx.lr = 0x82A65D94;
	sub_825E7630(ctx, base);
	// 82A65D94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A65D98: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A65D9C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A65DA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65DA4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A65DA8: 419A0024  beq cr6, 0x82a65dcc
	if ctx.cr[6].eq {
	pc = 0x82A65DCC; continue 'dispatch;
	}
	// 82A65DAC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A65DB0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A65DB4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65DB8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A65DBC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A65DC0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A65DC4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65DC8: 4082FFE8  bne 0x82a65db0
	if !ctx.cr[0].eq {
	pc = 0x82A65DB0; continue 'dispatch;
	}
	// 82A65DCC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A65DD0: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 82A65DD4: 485A2355  bl 0x83008128
	ctx.lr = 0x82A65DD8;
	sub_83008128(ctx, base);
	// 82A65DD8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A65DDC: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A65DE0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A65DE4: 388AF950  addi r4, r10, -0x6b0
	ctx.r[4].s64 = ctx.r[10].s64 + -1712;
	// 82A65DE8: 38A0011B  li r5, 0x11b
	ctx.r[5].s64 = 283;
	// 82A65DEC: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A65DF0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A65DF4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A65DF8: 483F2C49  bl 0x82e58a40
	ctx.lr = 0x82A65DFC;
	sub_82E58A40(ctx, base);
	// 82A65DFC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A65E00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A65E04: 419A0008  beq cr6, 0x82a65e0c
	if ctx.cr[6].eq {
	pc = 0x82A65E0C; continue 'dispatch;
	}
	// 82A65E08: 4B85AA89  bl 0x822c0890
	ctx.lr = 0x82A65E0C;
	sub_822C0890(ctx, base);
	// 82A65E0C: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A65E10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A65E14: 419A0008  beq cr6, 0x82a65e1c
	if ctx.cr[6].eq {
	pc = 0x82A65E1C; continue 'dispatch;
	}
	// 82A65E18: 4B85AA79  bl 0x822c0890
	ctx.lr = 0x82A65E1C;
	sub_822C0890(ctx, base);
	// 82A65E1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A65E20: 4BAABE69  bl 0x82511c88
	ctx.lr = 0x82A65E24;
	sub_82511C88(ctx, base);
	// 82A65E24: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A65E28: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A65E2C: 38BF00EC  addi r5, r31, 0xec
	ctx.r[5].s64 = ctx.r[31].s64 + 236;
	// 82A65E30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A65E34: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A65E38: 4BAAA3B9  bl 0x825101f0
	ctx.lr = 0x82A65E3C;
	sub_825101F0(ctx, base);
	// 82A65E3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A65E40: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A65E44: 4BAA9685  bl 0x8250f4c8
	ctx.lr = 0x82A65E48;
	sub_8250F4C8(ctx, base);
	// 82A65E48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A65E4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65E50: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A65E54: 409A0008  bne cr6, 0x82a65e5c
	if !ctx.cr[6].eq {
	pc = 0x82A65E5C; continue 'dispatch;
	}
	// 82A65E58: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A65E5C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A65E60: 4BAA47D9  bl 0x8250a638
	ctx.lr = 0x82A65E64;
	sub_8250A638(ctx, base);
	// 82A65E64: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A65E68: 4838BE29  bl 0x82df1c90
	ctx.lr = 0x82A65E6C;
	sub_82DF1C90(ctx, base);
	// 82A65E6C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A65E70: 3BABF878  addi r29, r11, -0x788
	ctx.r[29].s64 = ctx.r[11].s64 + -1928;
	// 82A65E74: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A65E78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65E7C: 419A0120  beq cr6, 0x82a65f9c
	if ctx.cr[6].eq {
	pc = 0x82A65F9C; continue 'dispatch;
	}
	// 82A65E80: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A65E84: 395D0008  addi r10, r29, 8
	ctx.r[10].s64 = ctx.r[29].s64 + 8;
	// 82A65E88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A65E8C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A65E90: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A65E94: 4838DB75  bl 0x82df3a08
	ctx.lr = 0x82A65E98;
	sub_82DF3A08(ctx, base);
	// 82A65E98: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A65E9C: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A65EA0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A65EA4: 4BD5B165  bl 0x827c1008
	ctx.lr = 0x82A65EA8;
	sub_827C1008(ctx, base);
	// 82A65EA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A65EAC: 4838D57D  bl 0x82df3428
	ctx.lr = 0x82A65EB0;
	sub_82DF3428(ctx, base);
	// 82A65EB0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A65EB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65EB8: 419A00D4  beq cr6, 0x82a65f8c
	if ctx.cr[6].eq {
	pc = 0x82A65F8C; continue 'dispatch;
	}
	// 82A65EBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A65EC0: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82A65EC4: 4BAABC25  bl 0x82511ae8
	ctx.lr = 0x82A65EC8;
	sub_82511AE8(ctx, base);
	// 82A65EC8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A65ECC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A65ED0: 4BAABC89  bl 0x82511b58
	ctx.lr = 0x82A65ED4;
	sub_82511B58(ctx, base);
	// 82A65ED4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A65ED8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A65EDC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A65EE0: 4B8A1899  bl 0x82307778
	ctx.lr = 0x82A65EE4;
	sub_82307778(ctx, base);
	// 82A65EE4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A65EE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A65EEC: 4BD55DE5  bl 0x827bbcd0
	ctx.lr = 0x82A65EF0;
	sub_827BBCD0(ctx, base);
	// 82A65EF0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A65EF4: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A65EF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65EFC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A65F00: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A65F04: 419A0024  beq cr6, 0x82a65f28
	if ctx.cr[6].eq {
	pc = 0x82A65F28; continue 'dispatch;
	}
	// 82A65F08: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A65F0C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A65F10: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65F14: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A65F18: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A65F1C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A65F20: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A65F24: 4082FFE8  bne 0x82a65f0c
	if !ctx.cr[0].eq {
	pc = 0x82A65F0C; continue 'dispatch;
	}
	// 82A65F28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A65F2C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A65F30: 4BAA9599  bl 0x8250f4c8
	ctx.lr = 0x82A65F34;
	sub_8250F4C8(ctx, base);
	// 82A65F34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A65F38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65F3C: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 82A65F40: 409A0008  bne cr6, 0x82a65f48
	if !ctx.cr[6].eq {
	pc = 0x82A65F48; continue 'dispatch;
	}
	// 82A65F44: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A65F48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A65F4C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A65F50: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 82A65F54: 4BAA95C5  bl 0x8250f518
	ctx.lr = 0x82A65F58;
	sub_8250F518(ctx, base);
	// 82A65F58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A65F5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A65F60: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A65F64: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A65F68: 4BAA75A1  bl 0x8250d508
	ctx.lr = 0x82A65F6C;
	sub_8250D508(ctx, base);
	// 82A65F6C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A65F70: 4838BD21  bl 0x82df1c90
	ctx.lr = 0x82A65F74;
	sub_82DF1C90(ctx, base);
	// 82A65F74: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A65F78: 4838BD19  bl 0x82df1c90
	ctx.lr = 0x82A65F7C;
	sub_82DF1C90(ctx, base);
	// 82A65F7C: 38BC0050  addi r5, r28, 0x50
	ctx.r[5].s64 = ctx.r[28].s64 + 80;
	// 82A65F80: 389C0030  addi r4, r28, 0x30
	ctx.r[4].s64 = ctx.r[28].s64 + 48;
	// 82A65F84: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A65F88: 4BD571D9  bl 0x827bd160
	ctx.lr = 0x82A65F8C;
	sub_827BD160(ctx, base);
	// 82A65F8C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A65F90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A65F94: 419A0008  beq cr6, 0x82a65f9c
	if ctx.cr[6].eq {
	pc = 0x82A65F9C; continue 'dispatch;
	}
	// 82A65F98: 4B85A8F9  bl 0x822c0890
	ctx.lr = 0x82A65F9C;
	sub_822C0890(ctx, base);
	// 82A65F9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A65FA0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A65FA4: 4BAA9525  bl 0x8250f4c8
	ctx.lr = 0x82A65FA8;
	sub_8250F4C8(ctx, base);
	// 82A65FA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A65FAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65FB0: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A65FB4: 409A0008  bne cr6, 0x82a65fbc
	if !ctx.cr[6].eq {
	pc = 0x82A65FBC; continue 'dispatch;
	}
	// 82A65FB8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A65FBC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A65FC0: 4BAA4991  bl 0x8250a950
	ctx.lr = 0x82A65FC4;
	sub_8250A950(ctx, base);
	// 82A65FC4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A65FC8: 4838BCC9  bl 0x82df1c90
	ctx.lr = 0x82A65FCC;
	sub_82DF1C90(ctx, base);
	// 82A65FCC: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A65FD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A65FD4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A65FD8: 7C8BE82E  lwzx r4, r11, r29
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82A65FDC: 4838DA2D  bl 0x82df3a08
	ctx.lr = 0x82A65FE0;
	sub_82DF3A08(ctx, base);
	// 82A65FE0: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A65FE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A65FE8: 3BCBFF40  addi r30, r11, -0xc0
	ctx.r[30].s64 = ctx.r[11].s64 + -192;
	// 82A65FEC: 409A0008  bne cr6, 0x82a65ff4
	if !ctx.cr[6].eq {
	pc = 0x82A65FF4; continue 'dispatch;
	}
	// 82A65FF0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A65FF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A65FF8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A65FFC: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 82A66000: 4BAAC119  bl 0x82512118
	ctx.lr = 0x82A66004;
	sub_82512118(ctx, base);
	// 82A66004: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A66008: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A6600C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A66010: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A66014: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A66018: 4BD6EC99  bl 0x827d4cb0
	ctx.lr = 0x82A6601C;
	sub_827D4CB0(ctx, base);
	// 82A6601C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A66020: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A66024: 419A0008  beq cr6, 0x82a6602c
	if ctx.cr[6].eq {
	pc = 0x82A6602C; continue 'dispatch;
	}
	// 82A66028: 4B85A869  bl 0x822c0890
	ctx.lr = 0x82A6602C;
	sub_822C0890(ctx, base);
	// 82A6602C: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A66030: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A66034: 419A0008  beq cr6, 0x82a6603c
	if ctx.cr[6].eq {
	pc = 0x82A6603C; continue 'dispatch;
	}
	// 82A66038: 4B85A859  bl 0x822c0890
	ctx.lr = 0x82A6603C;
	sub_822C0890(ctx, base);
	// 82A6603C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A66040: 4838D3E9  bl 0x82df3428
	ctx.lr = 0x82A66044;
	sub_82DF3428(ctx, base);
	// 82A66044: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A66048: 4838BC49  bl 0x82df1c90
	ctx.lr = 0x82A6604C;
	sub_82DF1C90(ctx, base);
	// 82A6604C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A66050: 4BAAA581  bl 0x825105d0
	ctx.lr = 0x82A66054;
	sub_825105D0(ctx, base);
	// 82A66054: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A66058: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6605C: 419A0008  beq cr6, 0x82a66064
	if ctx.cr[6].eq {
	pc = 0x82A66064; continue 'dispatch;
	}
	// 82A66060: 4B85A831  bl 0x822c0890
	ctx.lr = 0x82A66064;
	sub_822C0890(ctx, base);
	// 82A66064: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 82A66068: 4874214C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A66070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A66070 size=68
    let mut pc: u32 = 0x82A66070;
    'dispatch: loop {
        match pc {
            0x82A66070 => {
    //   block [0x82A66070..0x82A660B4)
	// 82A66070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A66074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A66078: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6607C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A66080: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A66084: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A66088: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A6608C: 38BF00EC  addi r5, r31, 0xec
	ctx.r[5].s64 = ctx.r[31].s64 + 236;
	// 82A66090: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A66094: 4BAAA15D  bl 0x825101f0
	ctx.lr = 0x82A66098;
	sub_825101F0(ctx, base);
	// 82A66098: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6609C: 4BFFF8B5  bl 0x82a65950
	ctx.lr = 0x82A660A0;
	sub_82A65950(ctx, base);
	// 82A660A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A660A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A660A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A660AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A660B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A660B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A660B8 size=424
    let mut pc: u32 = 0x82A660B8;
    'dispatch: loop {
        match pc {
            0x82A660B8 => {
    //   block [0x82A660B8..0x82A66260)
	// 82A660B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A660BC: 487420AD  bl 0x831a8168
	ctx.lr = 0x82A660C0;
	sub_831A8130(ctx, base);
	// 82A660C0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A660C4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A660C8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A660CC: 3BCBF950  addi r30, r11, -0x6b0
	ctx.r[30].s64 = ctx.r[11].s64 + -1712;
	// 82A660D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A660D4: 38A00057  li r5, 0x57
	ctx.r[5].s64 = 87;
	// 82A660D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A660DC: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 82A660E0: 4838C309  bl 0x82df23e8
	ctx.lr = 0x82A660E4;
	sub_82DF23E8(ctx, base);
	// 82A660E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A660E8: 41820010  beq 0x82a660f8
	if ctx.cr[0].eq {
	pc = 0x82A660F8; continue 'dispatch;
	}
	// 82A660EC: 4BFFF6A5  bl 0x82a65790
	ctx.lr = 0x82A660F0;
	sub_82A65790(ctx, base);
	// 82A660F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A660F4: 48000008  b 0x82a660fc
	pc = 0x82A660FC; continue 'dispatch;
	// 82A660F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A660FC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A66100: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A66104: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A66108: 4BFFF579  bl 0x82a65680
	ctx.lr = 0x82A6610C;
	sub_82A65680(ctx, base);
	// 82A6610C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A66110: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A66114: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A66118: 4B859EE9  bl 0x822c0000
	ctx.lr = 0x82A6611C;
	sub_822C0000(ctx, base);
	// 82A6611C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A66120: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A66124: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 82A66128: 409A0008  bne cr6, 0x82a66130
	if !ctx.cr[6].eq {
	pc = 0x82A66130; continue 'dispatch;
	}
	// 82A6612C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A66130: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A66134: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A66138: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6613C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82A66140: 419A0024  beq cr6, 0x82a66164
	if ctx.cr[6].eq {
	pc = 0x82A66164; continue 'dispatch;
	}
	// 82A66144: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82A66148: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82A6614C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A66150: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82A66154: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A66158: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6615C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A66160: 4082FFE8  bne 0x82a66148
	if !ctx.cr[0].eq {
	pc = 0x82A66148; continue 'dispatch;
	}
	// 82A66164: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A66168: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6616C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82A66170: 419A0024  beq cr6, 0x82a66194
	if ctx.cr[6].eq {
	pc = 0x82A66194; continue 'dispatch;
	}
	// 82A66174: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82A66178: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6617C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A66180: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A66184: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A66188: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6618C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A66190: 4082FFE8  bne 0x82a66178
	if !ctx.cr[0].eq {
	pc = 0x82A66178; continue 'dispatch;
	}
	// 82A66194: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A66198: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82A6619C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A661A0: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 82A661A4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A661A8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A661AC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A661B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A661B4: 4BD32D7D  bl 0x82798f30
	ctx.lr = 0x82A661B8;
	sub_82798F30(ctx, base);
	// 82A661B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82A661BC: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 82A661C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A661C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A661C8: 38A0005C  li r5, 0x5c
	ctx.r[5].s64 = 92;
	// 82A661CC: C00B9A8C  lfs f0, -0x6574(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25972 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A661D0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82A661D4: C1AAC350  lfs f13, -0x3cb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-15536 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A661D8: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82A661DC: D1A10094  stfs f13, 0x94(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82A661E0: 4B85A1F9  bl 0x822c03d8
	ctx.lr = 0x82A661E4;
	sub_822C03D8(ctx, base);
	// 82A661E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A661E8: 41820014  beq 0x82a661fc
	if ctx.cr[0].eq {
	pc = 0x82A661FC; continue 'dispatch;
	}
	// 82A661EC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A661F0: 4BD35479  bl 0x8279b668
	ctx.lr = 0x82A661F4;
	sub_8279B668(ctx, base);
	// 82A661F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A661F8: 48000008  b 0x82a66200
	pc = 0x82A66200; continue 'dispatch;
	// 82A661FC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A66200: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A66204: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82A66208: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6620C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A66210: 4BB31A41  bl 0x82597c50
	ctx.lr = 0x82A66214;
	sub_82597C50(ctx, base);
	// 82A66214: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A66218: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6621C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A66220: 4B859DE1  bl 0x822c0000
	ctx.lr = 0x82A66224;
	sub_822C0000(ctx, base);
	// 82A66224: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A66228: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6622C: 419A0008  beq cr6, 0x82a66234
	if ctx.cr[6].eq {
	pc = 0x82A66234; continue 'dispatch;
	}
	// 82A66230: 4B85A661  bl 0x822c0890
	ctx.lr = 0x82A66234;
	sub_822C0890(ctx, base);
	// 82A66234: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A66238: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6623C: 419A0008  beq cr6, 0x82a66244
	if ctx.cr[6].eq {
	pc = 0x82A66244; continue 'dispatch;
	}
	// 82A66240: 4B85A651  bl 0x822c0890
	ctx.lr = 0x82A66244;
	sub_822C0890(ctx, base);
	// 82A66244: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A66248: 419A000C  beq cr6, 0x82a66254
	if ctx.cr[6].eq {
	pc = 0x82A66254; continue 'dispatch;
	}
	// 82A6624C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A66250: 4B85A641  bl 0x822c0890
	ctx.lr = 0x82A66254;
	sub_822C0890(ctx, base);
	// 82A66254: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A66258: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A6625C: 48741F5C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A66260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A66260 size=128
    let mut pc: u32 = 0x82A66260;
    'dispatch: loop {
        match pc {
            0x82A66260 => {
    //   block [0x82A66260..0x82A662E0)
	// 82A66260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A66264: 48741F09  bl 0x831a816c
	ctx.lr = 0x82A66268;
	sub_831A8130(ctx, base);
	// 82A66268: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6626C: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A66270: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A66274: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A66278: 3BEBDFD8  addi r31, r11, -0x2028
	ctx.r[31].s64 = ctx.r[11].s64 + -8232;
	// 82A6627C: 816ADFE0  lwz r11, -0x2020(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8224 as u32) ) } as u64;
	// 82A66280: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A66284: 40820024  bne 0x82a662a8
	if !ctx.cr[0].eq {
	pc = 0x82A662A8; continue 'dispatch;
	}
	// 82A66288: 3D208289  lis r9, -0x7d77
	ctx.r[9].s64 = -2104950784;
	// 82A6628C: 3D0082A6  lis r8, -0x7d5a
	ctx.r[8].s64 = -2103050240;
	// 82A66290: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82A66294: 392990C8  addi r9, r9, -0x6f38
	ctx.r[9].s64 = ctx.r[9].s64 + -28472;
	// 82A66298: 39085748  addi r8, r8, 0x5748
	ctx.r[8].s64 = ctx.r[8].s64 + 22344;
	// 82A6629C: 916ADFE0  stw r11, -0x2020(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8224 as u32), ctx.r[11].u32 ) };
	// 82A662A0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A662A4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A662A8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A662AC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A662B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A662B4: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82A662B8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82A662BC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A662C0: 4BBEE301  bl 0x826545c0
	ctx.lr = 0x82A662C4;
	sub_826545C0(ctx, base);
	// 82A662C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A662C8: 4182000C  beq 0x82a662d4
	if ctx.cr[0].eq {
	pc = 0x82A662D4; continue 'dispatch;
	}
	// 82A662CC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A662D0: 48000008  b 0x82a662d8
	pc = 0x82A662D8; continue 'dispatch;
	// 82A662D4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A662D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A662DC: 48741EE0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A662E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A662E0 size=428
    let mut pc: u32 = 0x82A662E0;
    'dispatch: loop {
        match pc {
            0x82A662E0 => {
    //   block [0x82A662E0..0x82A6648C)
	// 82A662E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A662E4: 48741E81  bl 0x831a8164
	ctx.lr = 0x82A662E8;
	sub_831A8130(ctx, base);
	// 82A662E8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A662EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A662F0: 3D6082A6  lis r11, -0x7d5a
	ctx.r[11].s64 = -2103050240;
	// 82A662F4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A662F8: 396B6070  addi r11, r11, 0x6070
	ctx.r[11].s64 = ctx.r[11].s64 + 24688;
	// 82A662FC: 395EFF1C  addi r10, r30, -0xe4
	ctx.r[10].s64 = ctx.r[30].s64 + -228;
	// 82A66300: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82A66304: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82A66308: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A6630C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A66310: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82A66314: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A66318: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6631C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A66320: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A66324: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82A66328: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 82A6632C: 4BFFFF35  bl 0x82a66260
	ctx.lr = 0x82A66330;
	sub_82A66260(ctx, base);
	// 82A66330: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A66334: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A66338: 388BF950  addi r4, r11, -0x6b0
	ctx.r[4].s64 = ctx.r[11].s64 + -1712;
	// 82A6633C: 38A00096  li r5, 0x96
	ctx.r[5].s64 = 150;
	// 82A66340: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82A66344: 4B85A095  bl 0x822c03d8
	ctx.lr = 0x82A66348;
	sub_822C03D8(ctx, base);
	// 82A66348: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A6634C: 41820040  beq 0x82a6638c
	if ctx.cr[0].eq {
	pc = 0x82A6638C; continue 'dispatch;
	}
	// 82A66350: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82A66354: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A66358: 388BCAD4  addi r4, r11, -0x352c
	ctx.r[4].s64 = ctx.r[11].s64 + -13612;
	// 82A6635C: 4838D6AD  bl 0x82df3a08
	ctx.lr = 0x82A66360;
	sub_82DF3A08(ctx, base);
	// 82A66360: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A66364: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A66368: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82A6636C: 4BB25BA5  bl 0x8258bf10
	ctx.lr = 0x82A66370;
	sub_8258BF10(ctx, base);
	// 82A66370: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A66374: 38BE0010  addi r5, r30, 0x10
	ctx.r[5].s64 = ctx.r[30].s64 + 16;
	// 82A66378: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6637C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A66380: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A66384: 4BB45E0D  bl 0x825ac190
	ctx.lr = 0x82A66388;
	sub_825AC190(ctx, base);
	// 82A66388: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6638C: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82A66390: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A66394: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A66398: 4BA8D021  bl 0x824f33b8
	ctx.lr = 0x82A6639C;
	sub_824F33B8(ctx, base);
	// 82A6639C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A663A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A663A4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A663A8: 4B859C59  bl 0x822c0000
	ctx.lr = 0x82A663AC;
	sub_822C0000(ctx, base);
	// 82A663AC: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A663B0: 4182000C  beq 0x82a663bc
	if ctx.cr[0].eq {
	pc = 0x82A663BC; continue 'dispatch;
	}
	// 82A663B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A663B8: 4838D071  bl 0x82df3428
	ctx.lr = 0x82A663BC;
	sub_82DF3428(ctx, base);
	// 82A663BC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A663C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A663C4: 388BF9A8  addi r4, r11, -0x658
	ctx.r[4].s64 = ctx.r[11].s64 + -1624;
	// 82A663C8: 4838D641  bl 0x82df3a08
	ctx.lr = 0x82A663CC;
	sub_82DF3A08(ctx, base);
	// 82A663CC: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A663D0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A663D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A663D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A663DC: 4BB459E5  bl 0x825abdc0
	ctx.lr = 0x82A663E0;
	sub_825ABDC0(ctx, base);
	// 82A663E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A663E4: 4838D045  bl 0x82df3428
	ctx.lr = 0x82A663E8;
	sub_82DF3428(ctx, base);
	// 82A663E8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A663EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A663F0: 388BF9A0  addi r4, r11, -0x660
	ctx.r[4].s64 = ctx.r[11].s64 + -1632;
	// 82A663F4: 4838D615  bl 0x82df3a08
	ctx.lr = 0x82A663F8;
	sub_82DF3A08(ctx, base);
	// 82A663F8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A663FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A66400: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A66404: 4BB459BD  bl 0x825abdc0
	ctx.lr = 0x82A66408;
	sub_825ABDC0(ctx, base);
	// 82A66408: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6640C: 4838D01D  bl 0x82df3428
	ctx.lr = 0x82A66410;
	sub_82DF3428(ctx, base);
	// 82A66410: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82A66414: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A66418: 388B1614  addi r4, r11, 0x1614
	ctx.r[4].s64 = ctx.r[11].s64 + 5652;
	// 82A6641C: 4838D5ED  bl 0x82df3a08
	ctx.lr = 0x82A66420;
	sub_82DF3A08(ctx, base);
	// 82A66420: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A66424: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82A66428: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A6642C: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82A66430: 419A0024  beq cr6, 0x82a66454
	if ctx.cr[6].eq {
	pc = 0x82A66454; continue 'dispatch;
	}
	// 82A66434: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A66438: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6643C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A66440: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A66444: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A66448: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6644C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A66450: 4082FFE8  bne 0x82a66438
	if !ctx.cr[0].eq {
	pc = 0x82A66438; continue 'dispatch;
	}
	// 82A66454: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A66458: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6645C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A66460: 4BB3BCB1  bl 0x825a2110
	ctx.lr = 0x82A66464;
	sub_825A2110(ctx, base);
	// 82A66464: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A66468: 4838CFC1  bl 0x82df3428
	ctx.lr = 0x82A6646C;
	sub_82DF3428(ctx, base);
	// 82A6646C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A66470: 419A000C  beq cr6, 0x82a6647c
	if ctx.cr[6].eq {
	pc = 0x82A6647C; continue 'dispatch;
	}
	// 82A66474: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A66478: 4B85A419  bl 0x822c0890
	ctx.lr = 0x82A6647C;
	sub_822C0890(ctx, base);
	// 82A6647C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A66480: 4B862839  bl 0x822c8cb8
	ctx.lr = 0x82A66484;
	sub_822C8CB8(ctx, base);
	// 82A66484: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A66488: 48741D2C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A66490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A66490 size=248
    let mut pc: u32 = 0x82A66490;
    'dispatch: loop {
        match pc {
            0x82A66490 => {
    //   block [0x82A66490..0x82A66588)
	// 82A66490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A66494: 48741CD9  bl 0x831a816c
	ctx.lr = 0x82A66498;
	sub_831A8130(ctx, base);
	// 82A66498: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6649C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A664A0: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82A664A4: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82A664A8: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82A664AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A664B0: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A664B4: 4843A27D  bl 0x82ea0730
	ctx.lr = 0x82A664B8;
	sub_82EA0730(ctx, base);
	// 82A664B8: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 82A664BC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A664C0: B1430004  sth r10, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	// 82A664C4: 815E00F4  lwz r10, 0xf4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A664C8: 396BF888  addi r11, r11, -0x778
	ctx.r[11].s64 = ctx.r[11].s64 + -1912;
	// 82A664CC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A664D0: 7C2A5C2E  lfsx f1, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A664D4: 484B3D1D  bl 0x82f1a1f0
	ctx.lr = 0x82A664D8;
	sub_82F1A1F0(ctx, base);
	// 82A664D8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A664DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A664E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A664E4: 808B6784  lwz r4, 0x6784(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26500 as u32) ) } as u64;
	// 82A664E8: 4B87EA49  bl 0x822e4f30
	ctx.lr = 0x82A664EC;
	sub_822E4F30(ctx, base);
	// 82A664EC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A664F0: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82A664F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A664F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A664FC: 80AB67D4  lwz r5, 0x67d4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26580 as u32) ) } as u64;
	// 82A66500: 808A6790  lwz r4, 0x6790(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26512 as u32) ) } as u64;
	// 82A66504: 4B89129D  bl 0x822f77a0
	ctx.lr = 0x82A66508;
	sub_822F77A0(ctx, base);
	// 82A66508: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A6650C: E89D0000  ld r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 82A66510: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A66514: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82A66518: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A6651C: 4BA25D6D  bl 0x8248c288
	ctx.lr = 0x82A66520;
	sub_8248C288(ctx, base);
	// 82A66520: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A66524: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A66528: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A6652C: 419A000C  beq cr6, 0x82a66538
	if ctx.cr[6].eq {
	pc = 0x82A66538; continue 'dispatch;
	}
	// 82A66530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A66534: 4B881D15  bl 0x822e8248
	ctx.lr = 0x82A66538;
	sub_822E8248(ctx, base);
	// 82A66538: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A6653C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A66540: 4BAABBD9  bl 0x82512118
	ctx.lr = 0x82A66544;
	sub_82512118(ctx, base);
	// 82A66544: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A66548: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82A6654C: 388BDFE4  addi r4, r11, -0x201c
	ctx.r[4].s64 = ctx.r[11].s64 + -8220;
	// 82A66550: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A66554: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A66558: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6655C: 4BAACB9D  bl 0x825130f8
	ctx.lr = 0x82A66560;
	sub_825130F8(ctx, base);
	// 82A66560: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A66564: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A66568: 419A0008  beq cr6, 0x82a66570
	if ctx.cr[6].eq {
	pc = 0x82A66570; continue 'dispatch;
	}
	// 82A6656C: 4B881CFD  bl 0x822e8268
	ctx.lr = 0x82A66570;
	sub_822E8268(ctx, base);
	// 82A66570: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A66574: 419A000C  beq cr6, 0x82a66580
	if ctx.cr[6].eq {
	pc = 0x82A66580; continue 'dispatch;
	}
	// 82A66578: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6657C: 4B881CED  bl 0x822e8268
	ctx.lr = 0x82A66580;
	sub_822E8268(ctx, base);
	// 82A66580: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A66584: 48741C38  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A66588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A66588 size=448
    let mut pc: u32 = 0x82A66588;
    'dispatch: loop {
        match pc {
            0x82A66588 => {
    //   block [0x82A66588..0x82A66748)
	// 82A66588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6658C: 48741BE1  bl 0x831a816c
	ctx.lr = 0x82A66590;
	sub_831A8130(ctx, base);
	// 82A66590: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 82A66594: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82A66598: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A6659C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A665A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A665A4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A665A8: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82A665AC: 4BAAB42D  bl 0x825119d8
	ctx.lr = 0x82A665B0;
	sub_825119D8(ctx, base);
	// 82A665B0: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82A665B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A665B8: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82A665BC: 4838D44D  bl 0x82df3a08
	ctx.lr = 0x82A665C0;
	sub_82DF3A08(ctx, base);
	// 82A665C0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A665C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A665C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A665CC: 4BAA21B5  bl 0x82508780
	ctx.lr = 0x82A665D0;
	sub_82508780(ctx, base);
	// 82A665D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A665D4: 4838CE55  bl 0x82df3428
	ctx.lr = 0x82A665D8;
	sub_82DF3428(ctx, base);
	// 82A665D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A665DC: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82A665E0: 409A0008  bne cr6, 0x82a665e8
	if !ctx.cr[6].eq {
	pc = 0x82A665E8; continue 'dispatch;
	}
	// 82A665E4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A665E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A665EC: 4BAA21B5  bl 0x825087a0
	ctx.lr = 0x82A665F0;
	sub_825087A0(ctx, base);
	// 82A665F0: 397F00F8  addi r11, r31, 0xf8
	ctx.r[11].s64 = ctx.r[31].s64 + 248;
	// 82A665F4: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 82A665F8: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82A665FC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A66600: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 82A66604: 4B85DE5D  bl 0x822c4460
	ctx.lr = 0x82A66608;
	sub_822C4460(ctx, base);
	// 82A66608: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6660C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A66610: 4BAA8D21  bl 0x8250f330
	ctx.lr = 0x82A66614;
	sub_8250F330(ctx, base);
	// 82A66614: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A66618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6661C: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A66620: 4BAA8DA9  bl 0x8250f3c8
	ctx.lr = 0x82A66624;
	sub_8250F3C8(ctx, base);
	// 82A66624: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A66628: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6662C: 4BA849E5  bl 0x824eb010
	ctx.lr = 0x82A66630;
	sub_824EB010(ctx, base);
	// 82A66630: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A66634: FFE00850  fneg f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = ctx.f[1].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A66638: 4838B659  bl 0x82df1c90
	ctx.lr = 0x82A6663C;
	sub_82DF1C90(ctx, base);
	// 82A6663C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A66640: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A66644: 4BAA8CED  bl 0x8250f330
	ctx.lr = 0x82A66648;
	sub_8250F330(ctx, base);
	// 82A66648: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A6664C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A66650: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A66654: 4BAA8D75  bl 0x8250f3c8
	ctx.lr = 0x82A66658;
	sub_8250F3C8(ctx, base);
	// 82A66658: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6665C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A66660: 4BA849B1  bl 0x824eb010
	ctx.lr = 0x82A66664;
	sub_824EB010(ctx, base);
	// 82A66664: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A66668: FFC00850  fneg f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = ctx.f[1].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A6666C: 4838B625  bl 0x82df1c90
	ctx.lr = 0x82A66670;
	sub_82DF1C90(ctx, base);
	// 82A66670: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A66674: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A66678: 4BAA8CB9  bl 0x8250f330
	ctx.lr = 0x82A6667C;
	sub_8250F330(ctx, base);
	// 82A6667C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A66680: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A66684: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A66688: 4BAA8D41  bl 0x8250f3c8
	ctx.lr = 0x82A6668C;
	sub_8250F3C8(ctx, base);
	// 82A6668C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A66690: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A66694: 4BA8497D  bl 0x824eb010
	ctx.lr = 0x82A66698;
	sub_824EB010(ctx, base);
	// 82A66698: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A6669C: FFA00850  fneg f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = ctx.f[1].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A666A0: 4838B5F1  bl 0x82df1c90
	ctx.lr = 0x82A666A4;
	sub_82DF1C90(ctx, base);
	// 82A666A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A666A8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A666AC: D3E10080  stfs f31, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82A666B0: D3A10088  stfs f29, 0x88(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82A666B4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82A666B8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A666BC: C00B964C  lfs f0, -0x69b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A666C0: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A666C4: EC1E0028  fsubs f0, f30, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A666C8: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82A666CC: D1A1008C  stfs f13, 0x8c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82A666D0: 48416D81  bl 0x82e7d450
	ctx.lr = 0x82A666D4;
	sub_82E7D450(ctx, base);
	// 82A666D4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A666D8: 39400100  li r10, 0x100
	ctx.r[10].s64 = 256;
	// 82A666DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A666E0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A666E4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A66748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A66748 size=136
    let mut pc: u32 = 0x82A66748;
    'dispatch: loop {
        match pc {
            0x82A66748 => {
    //   block [0x82A66748..0x82A667D0)
	// 82A66748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6674C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A66750: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A66754: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A66758: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6675C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A66760: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A66764: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82A66768: 409A0020  bne cr6, 0x82a66788
	if !ctx.cr[6].eq {
	pc = 0x82A66788; continue 'dispatch;
	}
	// 82A6676C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A66770: 419A0048  beq cr6, 0x82a667b8
	if ctx.cr[6].eq {
	pc = 0x82A667B8; continue 'dispatch;
	}
	// 82A66774: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82A66778: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82A6677C: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 82A66780: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82A66784: 48000034  b 0x82a667b8
	pc = 0x82A667B8; continue 'dispatch;
	// 82A66788: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82A6678C: 419A002C  beq cr6, 0x82a667b8
	if ctx.cr[6].eq {
	pc = 0x82A667B8; continue 'dispatch;
	}
	// 82A66790: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A66794: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A66798: 388B6C28  addi r4, r11, 0x6c28
	ctx.r[4].s64 = ctx.r[11].s64 + 27688;
	// 82A6679C: 4874195D  bl 0x831a80f8
	ctx.lr = 0x82A667A0;
	sub_831A80F8(ctx, base);
	// 82A667A0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A667A4: 4182000C  beq 0x82a667b0
	if ctx.cr[0].eq {
	pc = 0x82A667B0; continue 'dispatch;
	}
	// 82A667A8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A667AC: 4800000C  b 0x82a667b8
	pc = 0x82A667B8; continue 'dispatch;
	// 82A667B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A667B4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A667B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A667BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A667C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A667C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A667C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A667CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A667D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A667D0 size=136
    let mut pc: u32 = 0x82A667D0;
    'dispatch: loop {
        match pc {
            0x82A667D0 => {
    //   block [0x82A667D0..0x82A66858)
	// 82A667D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A667D4: 48741995  bl 0x831a8168
	ctx.lr = 0x82A667D8;
	sub_831A8130(ctx, base);
	// 82A667D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A667DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A667E0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A667E4: 4BAA9F25  bl 0x82510708
	ctx.lr = 0x82A667E8;
	sub_82510708(ctx, base);
	// 82A667E8: 3BDF0108  addi r30, r31, 0x108
	ctx.r[30].s64 = ctx.r[31].s64 + 264;
	// 82A667EC: 3BFF0118  addi r31, r31, 0x118
	ctx.r[31].s64 = ctx.r[31].s64 + 280;
	// 82A667F0: 3B800002  li r28, 2
	ctx.r[28].s64 = 2;
	// 82A667F4: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A667F8: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A667FC: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82A66800: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A66804: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A66808: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6680C: 419A0034  beq cr6, 0x82a66840
	if ctx.cr[6].eq {
	pc = 0x82A66840; continue 'dispatch;
	}
	// 82A66810: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A66814: C1BF0000  lfs f13, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A66818: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A6681C: 4198000C  blt cr6, 0x82a66828
	if ctx.cr[6].lt {
	pc = 0x82A66828; continue 'dispatch;
	}
	// 82A66820: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A66824: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A66828: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6682C: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A66830: 807EFFF0  lwz r3, -0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82A66834: C1A4001C  lfs f13, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A66838: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6683C: 483D7FFD  bl 0x82e3e838
	ctx.lr = 0x82A66840;
	sub_82E3E838(ctx, base);
	// 82A66840: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82A66844: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82A66848: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82A6684C: 4082FFA8  bne 0x82a667f4
	if !ctx.cr[0].eq {
	pc = 0x82A667F4; continue 'dispatch;
	}
	// 82A66850: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A66854: 48741964  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A66858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A66858 size=196
    let mut pc: u32 = 0x82A66858;
    'dispatch: loop {
        match pc {
            0x82A66858 => {
    //   block [0x82A66858..0x82A6691C)
	// 82A66858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6685C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A66860: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A66864: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A66868: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6686C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A66870: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A66874: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A66878: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A6687C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A66880: 4B85A0B9  bl 0x822c0938
	ctx.lr = 0x82A66884;
	sub_822C0938(ctx, base);
	// 82A66884: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A66888: 41820028  beq 0x82a668b0
	if ctx.cr[0].eq {
	pc = 0x82A668B0; continue 'dispatch;
	}
	// 82A6688C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A66890: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A66894: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A66898: 392BF9E8  addi r9, r11, -0x618
	ctx.r[9].s64 = ctx.r[11].s64 + -1560;
	// 82A6689C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A668A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A668A4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A668A8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A668AC: 48000008  b 0x82a668b4
	pc = 0x82A668B4; continue 'dispatch;
	// 82A668B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A668B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A668B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A668BC: 409A0044  bne cr6, 0x82a66900
	if !ctx.cr[6].eq {
	pc = 0x82A66900; continue 'dispatch;
	}
	// 82A668C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A668C4: 419A001C  beq cr6, 0x82a668e0
	if ctx.cr[6].eq {
	pc = 0x82A668E0; continue 'dispatch;
	}
	// 82A668C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A668CC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A668D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A668D4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A668D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A668DC: 4E800421  bctrl
	ctx.lr = 0x82A668E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A668E0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A668E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A668E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A668EC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A668F0: 816B6C24  lwz r11, 0x6c24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27684 as u32) ) } as u64;
	// 82A668F4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A668F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A668FC: 4B859705  bl 0x822c0000
	ctx.lr = 0x82A66900;
	sub_822C0000(ctx, base);
	// 82A66900: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A66904: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A66908: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6690C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A66910: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A66914: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A66918: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A66920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A66920 size=72
    let mut pc: u32 = 0x82A66920;
    'dispatch: loop {
        match pc {
            0x82A66920 => {
    //   block [0x82A66920..0x82A66968)
	// 82A66920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A66924: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A66928: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6692C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82A66930: 419A001C  beq cr6, 0x82a6694c
	if ctx.cr[6].eq {
	pc = 0x82A6694C; continue 'dispatch;
	}
	// 82A66934: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A66938: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A6693C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82A66940: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A66944: 4BFFFE05  bl 0x82a66748
	ctx.lr = 0x82A66948;
	sub_82A66748(ctx, base);
	// 82A66948: 48000010  b 0x82a66958
	pc = 0x82A66958; continue 'dispatch;
	// 82A6694C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A66950: 396B6C28  addi r11, r11, 0x6c28
	ctx.r[11].s64 = ctx.r[11].s64 + 27688;
	// 82A66954: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A66958: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A6695C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A66960: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A66964: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A66968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A66968 size=84
    let mut pc: u32 = 0x82A66968;
    'dispatch: loop {
        match pc {
            0x82A66968 => {
    //   block [0x82A66968..0x82A669BC)
	// 82A66968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6696C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A66970: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A66974: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A66978: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6697C: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 82A66980: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82A66984: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 82A66988: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 82A6698C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A66990: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A66994: 419A0008  beq cr6, 0x82a6699c
	if ctx.cr[6].eq {
	pc = 0x82A6699C; continue 'dispatch;
	}
	// 82A66998: 4B859EF9  bl 0x822c0890
	ctx.lr = 0x82A6699C;
	sub_822C0890(ctx, base);
	// 82A6699C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A669A0: 4080FFE8  bge 0x82a66988
	if !ctx.cr[0].lt {
	pc = 0x82A66988; continue 'dispatch;
	}
	// 82A669A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A669A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A669AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A669B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A669B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A669B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A669C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A669C0 size=128
    let mut pc: u32 = 0x82A669C0;
    'dispatch: loop {
        match pc {
            0x82A669C0 => {
    //   block [0x82A669C0..0x82A66A40)
	// 82A669C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A669C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A669C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A669CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A669D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A669D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A669D8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A669DC: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A669E0: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A669E4: 396BFA5C  addi r11, r11, -0x5a4
	ctx.r[11].s64 = ctx.r[11].s64 + -1444;
	// 82A669E8: 394AFA48  addi r10, r10, -0x5b8
	ctx.r[10].s64 = ctx.r[10].s64 + -1464;
	// 82A669EC: 3929F9FC  addi r9, r9, -0x604
	ctx.r[9].s64 = ctx.r[9].s64 + -1540;
	// 82A669F0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A669F4: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82A669F8: 387F0108  addi r3, r31, 0x108
	ctx.r[3].s64 = ctx.r[31].s64 + 264;
	// 82A669FC: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 82A66A00: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 82A66A04: 4BFFFF65  bl 0x82a66968
	ctx.lr = 0x82A66A08;
	sub_82A66968(ctx, base);
	// 82A66A08: 387F00F8  addi r3, r31, 0xf8
	ctx.r[3].s64 = ctx.r[31].s64 + 248;
	// 82A66A0C: 4BFFFF5D  bl 0x82a66968
	ctx.lr = 0x82A66A10;
	sub_82A66968(ctx, base);
	// 82A66A10: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 82A66A14: 4BFFFF55  bl 0x82a66968
	ctx.lr = 0x82A66A18;
	sub_82A66968(ctx, base);
	// 82A66A18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A66A1C: 4BD40C3D  bl 0x827a7658
	ctx.lr = 0x82A66A20;
	sub_827A7658(ctx, base);
	// 82A66A20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A66A24: 4B8E892D  bl 0x8234f350
	ctx.lr = 0x82A66A28;
	sub_8234F350(ctx, base);
	// 82A66A28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A66A2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A66A30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A66A34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A66A38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A66A3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A66A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A66A40 size=8
    let mut pc: u32 = 0x82A66A40;
    'dispatch: loop {
        match pc {
            0x82A66A40 => {
    //   block [0x82A66A40..0x82A66A48)
	// 82A66A40: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82A66A44: 480000D4  b 0x82a66b18
	sub_82A66B18(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A66A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A66A48 size=8
    let mut pc: u32 = 0x82A66A48;
    'dispatch: loop {
        match pc {
            0x82A66A48 => {
    //   block [0x82A66A48..0x82A66A50)
	// 82A66A48: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 82A66A4C: 480000CC  b 0x82a66b18
	sub_82A66B18(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A66A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A66A50 size=200
    let mut pc: u32 = 0x82A66A50;
    'dispatch: loop {
        match pc {
            0x82A66A50 => {
    //   block [0x82A66A50..0x82A66B18)
	// 82A66A50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A66A54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A66A58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A66A5C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A66A60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A66A64: 4BAAB8CD  bl 0x82512330
	ctx.lr = 0x82A66A68;
	sub_82512330(ctx, base);
	// 82A66A68: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82A66A6C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A66A70: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A66A74: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A66A78: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 82A66A7C: 394AFA5C  addi r10, r10, -0x5a4
	ctx.r[10].s64 = ctx.r[10].s64 + -1444;
	// 82A66A80: 3929FA48  addi r9, r9, -0x5b8
	ctx.r[9].s64 = ctx.r[9].s64 + -1464;
	// 82A66A84: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82A66A88: 3908F9FC  addi r8, r8, -0x604
	ctx.r[8].s64 = ctx.r[8].s64 + -1540;
	// 82A66A8C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A66A90: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82A66A94: 397F00E8  addi r11, r31, 0xe8
	ctx.r[11].s64 = ctx.r[31].s64 + 232;
	// 82A66A98: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 82A66A9C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A66AA0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A66AA4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A66AA8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A66AAC: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A66AB0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A66AB4: 4080FFF0  bge 0x82a66aa4
	if !ctx.cr[0].lt {
	pc = 0x82A66AA4; continue 'dispatch;
	}
	// 82A66AB8: 397F00F8  addi r11, r31, 0xf8
	ctx.r[11].s64 = ctx.r[31].s64 + 248;
	// 82A66ABC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A66AC0: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A66AC4: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A66AC8: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A66ACC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A66AD0: 4080FFF0  bge 0x82a66ac0
	if !ctx.cr[0].lt {
	pc = 0x82A66AC0; continue 'dispatch;
	}
	// 82A66AD4: 397F0108  addi r11, r31, 0x108
	ctx.r[11].s64 = ctx.r[31].s64 + 264;
	// 82A66AD8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A66ADC: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A66AE0: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A66AE4: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A66AE8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A66AEC: 4080FFF0  bge 0x82a66adc
	if !ctx.cr[0].lt {
	pc = 0x82A66ADC; continue 'dispatch;
	}
	// 82A66AF0: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82A66AF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A66AF8: C02B3290  lfs f1, 0x3290(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12944 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A66AFC: 4BAAADB5  bl 0x825118b0
	ctx.lr = 0x82A66B00;
	sub_825118B0(ctx, base);
	// 82A66B00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A66B04: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A66B08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A66B0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A66B10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A66B14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A66B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A66B18 size=76
    let mut pc: u32 = 0x82A66B18;
    'dispatch: loop {
        match pc {
            0x82A66B18 => {
    //   block [0x82A66B18..0x82A66B64)
	// 82A66B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A66B1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A66B20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A66B24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A66B28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A66B2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A66B30: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A66B34: 4BFFFE8D  bl 0x82a669c0
	ctx.lr = 0x82A66B38;
	sub_82A669C0(ctx, base);
	// 82A66B38: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A66B3C: 4182000C  beq 0x82a66b48
	if ctx.cr[0].eq {
	pc = 0x82A66B48; continue 'dispatch;
	}
	// 82A66B40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A66B44: 4838B895  bl 0x82df23d8
	ctx.lr = 0x82A66B48;
	sub_82DF23D8(ctx, base);
	// 82A66B48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A66B4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A66B50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A66B54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A66B58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A66B5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A66B60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A66B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A66B68 size=424
    let mut pc: u32 = 0x82A66B68;
    'dispatch: loop {
        match pc {
            0x82A66B68 => {
    //   block [0x82A66B68..0x82A66D10)
	// 82A66B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A66B6C: 487415FD  bl 0x831a8168
	ctx.lr = 0x82A66B70;
	sub_831A8130(ctx, base);
	// 82A66B70: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A66B74: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A66B78: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A66B7C: 3BCBFA98  addi r30, r11, -0x568
	ctx.r[30].s64 = ctx.r[11].s64 + -1384;
	// 82A66B80: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A66B84: 38A00024  li r5, 0x24
	ctx.r[5].s64 = 36;
	// 82A66B88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A66B8C: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 82A66B90: 4838B859  bl 0x82df23e8
	ctx.lr = 0x82A66B94;
	sub_82DF23E8(ctx, base);
	// 82A66B94: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A66B98: 41820010  beq 0x82a66ba8
	if ctx.cr[0].eq {
	pc = 0x82A66BA8; continue 'dispatch;
	}
	// 82A66B9C: 4BFFFEB5  bl 0x82a66a50
	ctx.lr = 0x82A66BA0;
	sub_82A66A50(ctx, base);
	// 82A66BA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A66BA4: 48000008  b 0x82a66bac
	pc = 0x82A66BAC; continue 'dispatch;
	// 82A66BA8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A66BAC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A66BB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A66BB4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A66BB8: 4BFFFCA1  bl 0x82a66858
	ctx.lr = 0x82A66BBC;
	sub_82A66858(ctx, base);
	// 82A66BBC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A66BC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A66BC4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A66BC8: 4B859439  bl 0x822c0000
	ctx.lr = 0x82A66BCC;
	sub_822C0000(ctx, base);
	// 82A66BCC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A66BD0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A66BD4: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 82A66BD8: 409A0008  bne cr6, 0x82a66be0
	if !ctx.cr[6].eq {
	pc = 0x82A66BE0; continue 'dispatch;
	}
	// 82A66BDC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A66BE0: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A66BE4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A66BE8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A66BEC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82A66BF0: 419A0024  beq cr6, 0x82a66c14
	if ctx.cr[6].eq {
	pc = 0x82A66C14; continue 'dispatch;
	}
	// 82A66BF4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82A66BF8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82A66BFC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A66C00: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82A66C04: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A66C08: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A66C0C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A66C10: 4082FFE8  bne 0x82a66bf8
	if !ctx.cr[0].eq {
	pc = 0x82A66BF8; continue 'dispatch;
	}
	// 82A66C14: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A66C18: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A66C1C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82A66C20: 419A0024  beq cr6, 0x82a66c44
	if ctx.cr[6].eq {
	pc = 0x82A66C44; continue 'dispatch;
	}
	// 82A66C24: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82A66C28: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A66C2C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A66C30: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A66C34: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A66C38: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A66C3C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A66C40: 4082FFE8  bne 0x82a66c28
	if !ctx.cr[0].eq {
	pc = 0x82A66C28; continue 'dispatch;
	}
	// 82A66C44: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A66C48: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82A66C4C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82A66C50: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 82A66C54: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A66C58: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A66C5C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A66C60: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A66C64: 4BD322CD  bl 0x82798f30
	ctx.lr = 0x82A66C68;
	sub_82798F30(ctx, base);
	// 82A66C68: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82A66C6C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A66C70: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A66C74: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A66C78: 38A0002A  li r5, 0x2a
	ctx.r[5].s64 = 42;
	// 82A66C7C: C00B3290  lfs f0, 0x3290(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12944 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A66C80: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82A66C84: C1AAA3E0  lfs f13, -0x5c20(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-23584 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A66C88: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82A66C8C: D1A10094  stfs f13, 0x94(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82A66C90: 4B859749  bl 0x822c03d8
	ctx.lr = 0x82A66C94;
	sub_822C03D8(ctx, base);
	// 82A66C94: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A66C98: 41820014  beq 0x82a66cac
	if ctx.cr[0].eq {
	pc = 0x82A66CAC; continue 'dispatch;
	}
	// 82A66C9C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A66CA0: 4BD349C9  bl 0x8279b668
	ctx.lr = 0x82A66CA4;
	sub_8279B668(ctx, base);
	// 82A66CA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A66CA8: 48000008  b 0x82a66cb0
	pc = 0x82A66CB0; continue 'dispatch;
	// 82A66CAC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A66CB0: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A66CB4: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82A66CB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A66CBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A66CC0: 4BB30F91  bl 0x82597c50
	ctx.lr = 0x82A66CC4;
	sub_82597C50(ctx, base);
	// 82A66CC4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A66CC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A66CCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A66CD0: 4B859331  bl 0x822c0000
	ctx.lr = 0x82A66CD4;
	sub_822C0000(ctx, base);
	// 82A66CD4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A66CD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A66CDC: 419A0008  beq cr6, 0x82a66ce4
	if ctx.cr[6].eq {
	pc = 0x82A66CE4; continue 'dispatch;
	}
	// 82A66CE0: 4B859BB1  bl 0x822c0890
	ctx.lr = 0x82A66CE4;
	sub_822C0890(ctx, base);
	// 82A66CE4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A66CE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A66CEC: 419A0008  beq cr6, 0x82a66cf4
	if ctx.cr[6].eq {
	pc = 0x82A66CF4; continue 'dispatch;
	}
	// 82A66CF0: 4B859BA1  bl 0x822c0890
	ctx.lr = 0x82A66CF4;
	sub_822C0890(ctx, base);
	// 82A66CF4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A66CF8: 419A000C  beq cr6, 0x82a66d04
	if ctx.cr[6].eq {
	pc = 0x82A66D04; continue 'dispatch;
	}
	// 82A66CFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A66D00: 4B859B91  bl 0x822c0890
	ctx.lr = 0x82A66D04;
	sub_822C0890(ctx, base);
	// 82A66D04: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A66D08: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A66D0C: 487414AC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A66D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A66D10 size=128
    let mut pc: u32 = 0x82A66D10;
    'dispatch: loop {
        match pc {
            0x82A66D10 => {
    //   block [0x82A66D10..0x82A66D90)
	// 82A66D10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A66D14: 48741459  bl 0x831a816c
	ctx.lr = 0x82A66D18;
	sub_831A8130(ctx, base);
	// 82A66D18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A66D1C: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A66D20: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A66D24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A66D28: 3BEBDFE8  addi r31, r11, -0x2018
	ctx.r[31].s64 = ctx.r[11].s64 + -8216;
	// 82A66D2C: 816ADFF0  lwz r11, -0x2010(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8208 as u32) ) } as u64;
	// 82A66D30: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A66D34: 40820024  bne 0x82a66d58
	if !ctx.cr[0].eq {
	pc = 0x82A66D58; continue 'dispatch;
	}
	// 82A66D38: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 82A66D3C: 3D0082A6  lis r8, -0x7d5a
	ctx.r[8].s64 = -2103050240;
	// 82A66D40: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82A66D44: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 82A66D48: 39086920  addi r8, r8, 0x6920
	ctx.r[8].s64 = ctx.r[8].s64 + 26912;
	// 82A66D4C: 916ADFF0  stw r11, -0x2010(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8208 as u32), ctx.r[11].u32 ) };
	// 82A66D50: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A66D54: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A66D58: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A66D5C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A66D60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A66D64: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82A66D68: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82A66D6C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A66D70: 4BBED851  bl 0x826545c0
	ctx.lr = 0x82A66D74;
	sub_826545C0(ctx, base);
	// 82A66D74: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A66D78: 4182000C  beq 0x82a66d84
	if ctx.cr[0].eq {
	pc = 0x82A66D84; continue 'dispatch;
	}
	// 82A66D7C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A66D80: 48000008  b 0x82a66d88
	pc = 0x82A66D88; continue 'dispatch;
	// 82A66D84: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A66D88: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A66D8C: 48741430  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A66D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A66D90 size=176
    let mut pc: u32 = 0x82A66D90;
    'dispatch: loop {
        match pc {
            0x82A66D90 => {
    //   block [0x82A66D90..0x82A66E40)
	// 82A66D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A66D94: 487413D9  bl 0x831a816c
	ctx.lr = 0x82A66D98;
	sub_831A8130(ctx, base);
	// 82A66D98: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A66D9C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A66DA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A66DA4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A66DA8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A66DAC: 388BFA98  addi r4, r11, -0x568
	ctx.r[4].s64 = ctx.r[11].s64 + -1384;
	// 82A66DB0: 38A00071  li r5, 0x71
	ctx.r[5].s64 = 113;
	// 82A66DB4: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 82A66DB8: 4838B631  bl 0x82df23e8
	ctx.lr = 0x82A66DBC;
	sub_82DF23E8(ctx, base);
	// 82A66DBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A66DC0: 41820010  beq 0x82a66dd0
	if ctx.cr[0].eq {
	pc = 0x82A66DD0; continue 'dispatch;
	}
	// 82A66DC4: 4BB961AD  bl 0x825fcf70
	ctx.lr = 0x82A66DC8;
	sub_825FCF70(ctx, base);
	// 82A66DC8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A66DCC: 48000008  b 0x82a66dd4
	pc = 0x82A66DD4; continue 'dispatch;
	// 82A66DD0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A66DD4: 3BDF0100  addi r30, r31, 0x100
	ctx.r[30].s64 = ctx.r[31].s64 + 256;
	// 82A66DD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A66DDC: 4BB94A1D  bl 0x825fb7f8
	ctx.lr = 0x82A66DE0;
	sub_825FB7F8(ctx, base);
	// 82A66DE0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A66DE4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A66DE8: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82A66DEC: 483AFA55  bl 0x82e16840
	ctx.lr = 0x82A66DF0;
	sub_82E16840(ctx, base);
	// 82A66DF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A66DF4: 807F0100  lwz r3, 0x100(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 82A66DF8: 483B0569  bl 0x82e17360
	ctx.lr = 0x82A66DFC;
	sub_82E17360(ctx, base);
	// 82A66DFC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A66E00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A66E04: 388B51D0  addi r4, r11, 0x51d0
	ctx.r[4].s64 = ctx.r[11].s64 + 20944;
	// 82A66E08: 83DF0100  lwz r30, 0x100(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 82A66E0C: 48392725  bl 0x82df9530
	ctx.lr = 0x82A66E10;
	sub_82DF9530(ctx, base);
	// 82A66E10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A66E14: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A66E18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A66E1C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A66E20: 483B0929  bl 0x82e17748
	ctx.lr = 0x82A66E24;
	sub_82E17748(ctx, base);
	// 82A66E24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A66E28: 809F0110  lwz r4, 0x110(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82A66E2C: 807F0100  lwz r3, 0x100(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 82A66E30: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A66E34: 483D7A05  bl 0x82e3e838
	ctx.lr = 0x82A66E38;
	sub_82E3E838(ctx, base);
	// 82A66E38: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A66E3C: 48741380  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A66E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A66E40 size=176
    let mut pc: u32 = 0x82A66E40;
    'dispatch: loop {
        match pc {
            0x82A66E40 => {
    //   block [0x82A66E40..0x82A66EF0)
	// 82A66E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A66E44: 48741329  bl 0x831a816c
	ctx.lr = 0x82A66E48;
	sub_831A8130(ctx, base);
	// 82A66E48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A66E4C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A66E50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A66E54: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A66E58: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A66E5C: 388BFA98  addi r4, r11, -0x568
	ctx.r[4].s64 = ctx.r[11].s64 + -1384;
	// 82A66E60: 38A00065  li r5, 0x65
	ctx.r[5].s64 = 101;
	// 82A66E64: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 82A66E68: 4838B581  bl 0x82df23e8
	ctx.lr = 0x82A66E6C;
	sub_82DF23E8(ctx, base);
	// 82A66E6C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A66E70: 41820010  beq 0x82a66e80
	if ctx.cr[0].eq {
	pc = 0x82A66E80; continue 'dispatch;
	}
	// 82A66E74: 4BB960FD  bl 0x825fcf70
	ctx.lr = 0x82A66E78;
	sub_825FCF70(ctx, base);
	// 82A66E78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A66E7C: 48000008  b 0x82a66e84
	pc = 0x82A66E84; continue 'dispatch;
	// 82A66E80: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A66E84: 3BDF00F8  addi r30, r31, 0xf8
	ctx.r[30].s64 = ctx.r[31].s64 + 248;
	// 82A66E88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A66E8C: 4BB9496D  bl 0x825fb7f8
	ctx.lr = 0x82A66E90;
	sub_825FB7F8(ctx, base);
	// 82A66E90: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A66E94: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A66E98: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82A66E9C: 483AF9A5  bl 0x82e16840
	ctx.lr = 0x82A66EA0;
	sub_82E16840(ctx, base);
	// 82A66EA0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A66EA4: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82A66EA8: 483B04B9  bl 0x82e17360
	ctx.lr = 0x82A66EAC;
	sub_82E17360(ctx, base);
	// 82A66EAC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A66EB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A66EB4: 388B51D0  addi r4, r11, 0x51d0
	ctx.r[4].s64 = ctx.r[11].s64 + 20944;
	// 82A66EB8: 83DF00F8  lwz r30, 0xf8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82A66EBC: 48392675  bl 0x82df9530
	ctx.lr = 0x82A66EC0;
	sub_82DF9530(ctx, base);
	// 82A66EC0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A66EC4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82A66EC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A66ECC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A66ED0: 483B0879  bl 0x82e17748
	ctx.lr = 0x82A66ED4;
	sub_82E17748(ctx, base);
	// 82A66ED4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A66ED8: 809F0108  lwz r4, 0x108(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 82A66EDC: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82A66EE0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A66EE4: 483D7955  bl 0x82e3e838
	ctx.lr = 0x82A66EE8;
	sub_82E3E838(ctx, base);
	// 82A66EE8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A66EEC: 487412D0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A66EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A66EF0 size=968
    let mut pc: u32 = 0x82A66EF0;
    'dispatch: loop {
        match pc {
            0x82A66EF0 => {
    //   block [0x82A66EF0..0x82A672B8)
	// 82A66EF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A66EF4: 48741261  bl 0x831a8154
	ctx.lr = 0x82A66EF8;
	sub_831A8130(ctx, base);
	// 82A66EF8: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A66EFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A66F00: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A66F04: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82A66F08: 4BAAAAD1  bl 0x825119d8
	ctx.lr = 0x82A66F0C;
	sub_825119D8(ctx, base);
	// 82A66F0C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82A66F10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A66F14: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82A66F18: 4838CAF1  bl 0x82df3a08
	ctx.lr = 0x82A66F1C;
	sub_82DF3A08(ctx, base);
	// 82A66F1C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A66F20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A66F24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A66F28: 4BAA1859  bl 0x82508780
	ctx.lr = 0x82A66F2C;
	sub_82508780(ctx, base);
	// 82A66F2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A66F30: 4838C4F9  bl 0x82df3428
	ctx.lr = 0x82A66F34;
	sub_82DF3428(ctx, base);
	// 82A66F34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A66F38: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A66F3C: 483C3BAD  bl 0x82e2aae8
	ctx.lr = 0x82A66F40;
	sub_82E2AAE8(ctx, base);
	// 82A66F40: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A66F44: 3BDF00E8  addi r30, r31, 0xe8
	ctx.r[30].s64 = ctx.r[31].s64 + 232;
	// 82A66F48: 3B6BF9DC  addi r27, r11, -0x624
	ctx.r[27].s64 = ctx.r[11].s64 + -1572;
	// 82A66F4C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A66F50: 3B800002  li r28, 2
	ctx.r[28].s64 = 2;
	// 82A66F54: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82A66F58: 3F408335  lis r26, -0x7ccb
	ctx.r[26].s64 = -2093678592;
	// 82A66F5C: 3B2BFA98  addi r25, r11, -0x568
	ctx.r[25].s64 = ctx.r[11].s64 + -1384;
	// 82A66F60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A66F64: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A66F68: 4838CAA1  bl 0x82df3a08
	ctx.lr = 0x82A66F6C;
	sub_82DF3A08(ctx, base);
	// 82A66F6C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A66F70: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A66F74: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A66F78: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A66F7C: 483C7EF5  bl 0x82e2ee70
	ctx.lr = 0x82A66F80;
	sub_82E2EE70(ctx, base);
	// 82A66F80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A66F84: 4838C4A5  bl 0x82df3428
	ctx.lr = 0x82A66F88;
	sub_82DF3428(ctx, base);
	// 82A66F88: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A66F8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A66F90: 419A00B4  beq cr6, 0x82a67044
	if ctx.cr[6].eq {
	pc = 0x82A67044; continue 'dispatch;
	}
	// 82A66F94: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A66F98: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A66F9C: 38A00047  li r5, 0x47
	ctx.r[5].s64 = 71;
	// 82A66FA0: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82A66FA4: 4838B445  bl 0x82df23e8
	ctx.lr = 0x82A66FA8;
	sub_82DF23E8(ctx, base);
	// 82A66FA8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A66FAC: 41820014  beq 0x82a66fc0
	if ctx.cr[0].eq {
	pc = 0x82A66FC0; continue 'dispatch;
	}
	// 82A66FB0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A66FB4: 483AF8DD  bl 0x82e16890
	ctx.lr = 0x82A66FB8;
	sub_82E16890(ctx, base);
	// 82A66FB8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A66FBC: 48000008  b 0x82a66fc4
	pc = 0x82A66FC4; continue 'dispatch;
	// 82A66FC0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A66FC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A66FC8: 4B8F63A9  bl 0x8235d370
	ctx.lr = 0x82A66FCC;
	sub_8235D370(ctx, base);
	// 82A66FCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A66FD0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A66FD4: 82FE0000  lwz r23, 0(r30)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A66FD8: 4BAAB141  bl 0x82512118
	ctx.lr = 0x82A66FDC;
	sub_82512118(ctx, base);
	// 82A66FDC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A66FE0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82A66FE4: 483AE0CD  bl 0x82e150b0
	ctx.lr = 0x82A66FE8;
	sub_82E150B0(ctx, base);
	// 82A66FE8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A66FEC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A66FF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A66FF4: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A66FF8: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82A66FFC: 419A0024  beq cr6, 0x82a67020
	if ctx.cr[6].eq {
	pc = 0x82A67020; continue 'dispatch;
	}
	// 82A67000: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A67004: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A67008: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6700C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A67010: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A67014: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A67018: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6701C: 4082FFE8  bne 0x82a67004
	if !ctx.cr[0].eq {
	pc = 0x82A67004; continue 'dispatch;
	}
	// 82A67020: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A67024: 809A7058  lwz r4, 0x7058(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A67028: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82A6702C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A67030: 4BAA99C9  bl 0x825109f8
	ctx.lr = 0x82A67034;
	sub_825109F8(ctx, base);
	// 82A67034: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A67038: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6703C: 419A0008  beq cr6, 0x82a67044
	if ctx.cr[6].eq {
	pc = 0x82A67044; continue 'dispatch;
	}
	// 82A67040: 4B859851  bl 0x822c0890
	ctx.lr = 0x82A67044;
	sub_822C0890(ctx, base);
	// 82A67044: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A67048: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6704C: 419A0008  beq cr6, 0x82a67054
	if ctx.cr[6].eq {
	pc = 0x82A67054; continue 'dispatch;
	}
	// 82A67050: 4B859841  bl 0x822c0890
	ctx.lr = 0x82A67054;
	sub_822C0890(ctx, base);
	// 82A67054: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82A67058: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82A6705C: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82A67060: 4082FF00  bne 0x82a66f60
	if !ctx.cr[0].eq {
	pc = 0x82A66F60; continue 'dispatch;
	}
	// 82A67064: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A67068: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6706C: 483D8E9D  bl 0x82e3ff08
	ctx.lr = 0x82A67070;
	sub_82E3FF08(ctx, base);
	// 82A67070: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A67074: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A67078: 388BFB20  addi r4, r11, -0x4e0
	ctx.r[4].s64 = ctx.r[11].s64 + -1248;
	// 82A6707C: 4838C98D  bl 0x82df3a08
	ctx.lr = 0x82A67080;
	sub_82DF3A08(ctx, base);
	// 82A67080: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A67084: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A67088: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A6708C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A67090: 483C7711  bl 0x82e2e7a0
	ctx.lr = 0x82A67094;
	sub_82E2E7A0(ctx, base);
	// 82A67094: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A67098: 4838C391  bl 0x82df3428
	ctx.lr = 0x82A6709C;
	sub_82DF3428(ctx, base);
	// 82A6709C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A670A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A670A4: 388BFB0C  addi r4, r11, -0x4f4
	ctx.r[4].s64 = ctx.r[11].s64 + -1268;
	// 82A670A8: 4838C961  bl 0x82df3a08
	ctx.lr = 0x82A670AC;
	sub_82DF3A08(ctx, base);
	// 82A670AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A670B0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A670B4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A670B8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A670BC: 483D99AD  bl 0x82e40a68
	ctx.lr = 0x82A670C0;
	sub_82E40A68(ctx, base);
	// 82A670C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A670C4: 395F0108  addi r10, r31, 0x108
	ctx.r[10].s64 = ctx.r[31].s64 + 264;
	// 82A670C8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A670CC: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82A670D0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A670D4: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 82A670D8: 4B85D389  bl 0x822c4460
	ctx.lr = 0x82A670DC;
	sub_822C4460(ctx, base);
	// 82A670DC: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82A670E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A670E4: 419A0008  beq cr6, 0x82a670ec
	if ctx.cr[6].eq {
	pc = 0x82A670EC; continue 'dispatch;
	}
	// 82A670E8: 4B8597A9  bl 0x822c0890
	ctx.lr = 0x82A670EC;
	sub_822C0890(ctx, base);
	// 82A670EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A670F0: 4838C339  bl 0x82df3428
	ctx.lr = 0x82A670F4;
	sub_82DF3428(ctx, base);
	// 82A670F4: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A670F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A670FC: 419A0080  beq cr6, 0x82a6717c
	if ctx.cr[6].eq {
	pc = 0x82A6717C; continue 'dispatch;
	}
	// 82A67100: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A67104: 3D2082A6  lis r9, -0x7d5a
	ctx.r[9].s64 = -2103050240;
	// 82A67108: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 82A6710C: 39496E40  addi r10, r9, 0x6e40
	ctx.r[10].s64 = ctx.r[9].s64 + 28224;
	// 82A67110: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 82A67114: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A67118: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A6711C: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82A67120: 419A0024  beq cr6, 0x82a67144
	if ctx.cr[6].eq {
	pc = 0x82A67144; continue 'dispatch;
	}
	// 82A67124: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A67128: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6712C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67130: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A67134: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A67138: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6713C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67140: 4082FFE8  bne 0x82a67128
	if !ctx.cr[0].eq {
	pc = 0x82A67128; continue 'dispatch;
	}
	// 82A67144: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82A67148: 93E100B8  stw r31, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[31].u32 ) };
	// 82A6714C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A67150: E8A100B8  ld r5, 0xb8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 82A67154: 930100C0  stw r24, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[24].u32 ) };
	// 82A67158: 4BFFFBB9  bl 0x82a66d10
	ctx.lr = 0x82A6715C;
	sub_82A66D10(ctx, base);
	// 82A6715C: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 82A67160: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82A67164: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A67168: 4BAA9CD9  bl 0x82510e40
	ctx.lr = 0x82A6716C;
	sub_82510E40(ctx, base);
	// 82A6716C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A67170: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A67174: 419A0008  beq cr6, 0x82a6717c
	if ctx.cr[6].eq {
	pc = 0x82A6717C; continue 'dispatch;
	}
	// 82A67178: 4B859719  bl 0x822c0890
	ctx.lr = 0x82A6717C;
	sub_822C0890(ctx, base);
	// 82A6717C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A67180: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A67184: 419A0008  beq cr6, 0x82a6718c
	if ctx.cr[6].eq {
	pc = 0x82A6718C; continue 'dispatch;
	}
	// 82A67188: 4B859709  bl 0x822c0890
	ctx.lr = 0x82A6718C;
	sub_822C0890(ctx, base);
	// 82A6718C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A67190: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A67194: 388BFAFC  addi r4, r11, -0x504
	ctx.r[4].s64 = ctx.r[11].s64 + -1284;
	// 82A67198: 4838C871  bl 0x82df3a08
	ctx.lr = 0x82A6719C;
	sub_82DF3A08(ctx, base);
	// 82A6719C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A671A0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A671A4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A671A8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A671AC: 483C75F5  bl 0x82e2e7a0
	ctx.lr = 0x82A671B0;
	sub_82E2E7A0(ctx, base);
	// 82A671B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A671B4: 4838C275  bl 0x82df3428
	ctx.lr = 0x82A671B8;
	sub_82DF3428(ctx, base);
	// 82A671B8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A671BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A671C0: 388BFAE4  addi r4, r11, -0x51c
	ctx.r[4].s64 = ctx.r[11].s64 + -1308;
	// 82A671C4: 4838C845  bl 0x82df3a08
	ctx.lr = 0x82A671C8;
	sub_82DF3A08(ctx, base);
	// 82A671C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A671CC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A671D0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A671D4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A671D8: 483D9891  bl 0x82e40a68
	ctx.lr = 0x82A671DC;
	sub_82E40A68(ctx, base);
	// 82A671DC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A671E0: 395F0110  addi r10, r31, 0x110
	ctx.r[10].s64 = ctx.r[31].s64 + 272;
	// 82A671E4: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A671E8: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82A671EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A671F0: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82A671F4: 4B85D26D  bl 0x822c4460
	ctx.lr = 0x82A671F8;
	sub_822C4460(ctx, base);
	// 82A671F8: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A671FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A67200: 419A0008  beq cr6, 0x82a67208
	if ctx.cr[6].eq {
	pc = 0x82A67208; continue 'dispatch;
	}
	// 82A67204: 4B85968D  bl 0x822c0890
	ctx.lr = 0x82A67208;
	sub_822C0890(ctx, base);
	// 82A67208: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6720C: 4838C21D  bl 0x82df3428
	ctx.lr = 0x82A67210;
	sub_82DF3428(ctx, base);
	// 82A67210: 81410090  lwz r10, 0x90(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82A67214: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A67218: 419A0080  beq cr6, 0x82a67298
	if ctx.cr[6].eq {
	pc = 0x82A67298; continue 'dispatch;
	}
	// 82A6721C: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A67220: 3D2082A6  lis r9, -0x7d5a
	ctx.r[9].s64 = -2103050240;
	// 82A67224: 91410088  stw r10, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 82A67228: 39496D90  addi r10, r9, 0x6d90
	ctx.r[10].s64 = ctx.r[9].s64 + 28048;
	// 82A6722C: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 82A67230: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A67234: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A67238: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82A6723C: 419A0024  beq cr6, 0x82a67260
	if ctx.cr[6].eq {
	pc = 0x82A67260; continue 'dispatch;
	}
	// 82A67240: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A67244: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A67248: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6724C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A67250: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A67254: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A67258: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6725C: 4082FFE8  bne 0x82a67244
	if !ctx.cr[0].eq {
	pc = 0x82A67244; continue 'dispatch;
	}
	// 82A67260: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82A67264: 93E100B8  stw r31, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[31].u32 ) };
	// 82A67268: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A6726C: E8A100B8  ld r5, 0xb8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 82A67270: 930100C0  stw r24, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[24].u32 ) };
	// 82A67274: 4BFFFA9D  bl 0x82a66d10
	ctx.lr = 0x82A67278;
	sub_82A66D10(ctx, base);
	// 82A67278: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 82A6727C: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82A67280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A67284: 4BAA9BBD  bl 0x82510e40
	ctx.lr = 0x82A67288;
	sub_82510E40(ctx, base);
	// 82A67288: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A6728C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A67290: 419A0008  beq cr6, 0x82a67298
	if ctx.cr[6].eq {
	pc = 0x82A67298; continue 'dispatch;
	}
	// 82A67294: 4B8595FD  bl 0x822c0890
	ctx.lr = 0x82A67298;
	sub_822C0890(ctx, base);
	// 82A67298: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A6729C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A672A0: 419A0008  beq cr6, 0x82a672a8
	if ctx.cr[6].eq {
	pc = 0x82A672A8; continue 'dispatch;
	}
	// 82A672A4: 4B8595ED  bl 0x822c0890
	ctx.lr = 0x82A672A8;
	sub_822C0890(ctx, base);
	// 82A672A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A672AC: 483C3855  bl 0x82e2ab00
	ctx.lr = 0x82A672B0;
	sub_82E2AB00(ctx, base);
	// 82A672B0: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82A672B4: 48740EF0  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A672B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A672B8 size=196
    let mut pc: u32 = 0x82A672B8;
    'dispatch: loop {
        match pc {
            0x82A672B8 => {
    //   block [0x82A672B8..0x82A6737C)
	// 82A672B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A672BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A672C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A672C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A672C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A672CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A672D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A672D4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A672D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A672DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A672E0: 4B859659  bl 0x822c0938
	ctx.lr = 0x82A672E4;
	sub_822C0938(ctx, base);
	// 82A672E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A672E8: 41820028  beq 0x82a67310
	if ctx.cr[0].eq {
	pc = 0x82A67310; continue 'dispatch;
	}
	// 82A672EC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A672F0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A672F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A672F8: 392BFC10  addi r9, r11, -0x3f0
	ctx.r[9].s64 = ctx.r[11].s64 + -1008;
	// 82A672FC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A67300: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A67304: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A67308: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A6730C: 48000008  b 0x82a67314
	pc = 0x82A67314; continue 'dispatch;
	// 82A67310: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A67314: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A67318: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6731C: 409A0044  bne cr6, 0x82a67360
	if !ctx.cr[6].eq {
	pc = 0x82A67360; continue 'dispatch;
	}
	// 82A67320: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A67324: 419A001C  beq cr6, 0x82a67340
	if ctx.cr[6].eq {
	pc = 0x82A67340; continue 'dispatch;
	}
	// 82A67328: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6732C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A67330: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A67334: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67338: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A6733C: 4E800421  bctrl
	ctx.lr = 0x82A67340;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A67340: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A67344: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A67348: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6734C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A67350: 816B6DB4  lwz r11, 0x6db4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28084 as u32) ) } as u64;
	// 82A67354: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A67358: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A6735C: 4B858CA5  bl 0x822c0000
	ctx.lr = 0x82A67360;
	sub_822C0000(ctx, base);
	// 82A67360: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A67364: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A67368: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6736C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A67370: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A67374: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A67378: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A67380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A67380 size=196
    let mut pc: u32 = 0x82A67380;
    'dispatch: loop {
        match pc {
            0x82A67380 => {
    //   block [0x82A67380..0x82A67444)
	// 82A67380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A67384: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A67388: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6738C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A67390: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A67394: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A67398: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A6739C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A673A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A673A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A673A8: 4B859591  bl 0x822c0938
	ctx.lr = 0x82A673AC;
	sub_822C0938(ctx, base);
	// 82A673AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A673B0: 41820028  beq 0x82a673d8
	if ctx.cr[0].eq {
	pc = 0x82A673D8; continue 'dispatch;
	}
	// 82A673B4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A673B8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A673BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A673C0: 392BFC24  addi r9, r11, -0x3dc
	ctx.r[9].s64 = ctx.r[11].s64 + -988;
	// 82A673C4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A673C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A673CC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A673D0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A673D4: 48000008  b 0x82a673dc
	pc = 0x82A673DC; continue 'dispatch;
	// 82A673D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A673DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A673E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A673E4: 409A0044  bne cr6, 0x82a67428
	if !ctx.cr[6].eq {
	pc = 0x82A67428; continue 'dispatch;
	}
	// 82A673E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A673EC: 419A001C  beq cr6, 0x82a67408
	if ctx.cr[6].eq {
	pc = 0x82A67408; continue 'dispatch;
	}
	// 82A673F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A673F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A673F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A673FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67400: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A67404: 4E800421  bctrl
	ctx.lr = 0x82A67408;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A67408: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6740C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A67410: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A67414: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A67418: 816B6DB4  lwz r11, 0x6db4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28084 as u32) ) } as u64;
	// 82A6741C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A67420: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A67424: 4B858BDD  bl 0x822c0000
	ctx.lr = 0x82A67428;
	sub_822C0000(ctx, base);
	// 82A67428: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6742C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A67430: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A67434: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A67438: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6743C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A67440: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A67448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A67448 size=196
    let mut pc: u32 = 0x82A67448;
    'dispatch: loop {
        match pc {
            0x82A67448 => {
    //   block [0x82A67448..0x82A6750C)
	// 82A67448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6744C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A67450: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A67454: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A67458: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6745C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A67460: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A67464: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A67468: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A6746C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A67470: 4B8594C9  bl 0x822c0938
	ctx.lr = 0x82A67474;
	sub_822C0938(ctx, base);
	// 82A67474: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A67478: 41820028  beq 0x82a674a0
	if ctx.cr[0].eq {
	pc = 0x82A674A0; continue 'dispatch;
	}
	// 82A6747C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A67480: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A67484: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A67488: 392BFC38  addi r9, r11, -0x3c8
	ctx.r[9].s64 = ctx.r[11].s64 + -968;
	// 82A6748C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A67490: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A67494: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A67498: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A6749C: 48000008  b 0x82a674a4
	pc = 0x82A674A4; continue 'dispatch;
	// 82A674A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A674A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A674A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A674AC: 409A0044  bne cr6, 0x82a674f0
	if !ctx.cr[6].eq {
	pc = 0x82A674F0; continue 'dispatch;
	}
	// 82A674B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A674B4: 419A001C  beq cr6, 0x82a674d0
	if ctx.cr[6].eq {
	pc = 0x82A674D0; continue 'dispatch;
	}
	// 82A674B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A674BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A674C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A674C4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A674C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A674CC: 4E800421  bctrl
	ctx.lr = 0x82A674D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A674D0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A674D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A674D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A674DC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A674E0: 816B6DB4  lwz r11, 0x6db4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28084 as u32) ) } as u64;
	// 82A674E4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A674E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A674EC: 4B858B15  bl 0x822c0000
	ctx.lr = 0x82A674F0;
	sub_822C0000(ctx, base);
	// 82A674F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A674F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A674F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A674FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A67500: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A67504: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A67508: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A67510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A67510 size=196
    let mut pc: u32 = 0x82A67510;
    'dispatch: loop {
        match pc {
            0x82A67510 => {
    //   block [0x82A67510..0x82A675D4)
	// 82A67510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A67514: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A67518: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6751C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A67520: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A67524: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A67528: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A6752C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A67530: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A67534: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A67538: 4B859401  bl 0x822c0938
	ctx.lr = 0x82A6753C;
	sub_822C0938(ctx, base);
	// 82A6753C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A67540: 41820028  beq 0x82a67568
	if ctx.cr[0].eq {
	pc = 0x82A67568; continue 'dispatch;
	}
	// 82A67544: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A67548: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A6754C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A67550: 392BFC4C  addi r9, r11, -0x3b4
	ctx.r[9].s64 = ctx.r[11].s64 + -948;
	// 82A67554: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A67558: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A6755C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A67560: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A67564: 48000008  b 0x82a6756c
	pc = 0x82A6756C; continue 'dispatch;
	// 82A67568: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A6756C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A67570: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A67574: 409A0044  bne cr6, 0x82a675b8
	if !ctx.cr[6].eq {
	pc = 0x82A675B8; continue 'dispatch;
	}
	// 82A67578: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A6757C: 419A001C  beq cr6, 0x82a67598
	if ctx.cr[6].eq {
	pc = 0x82A67598; continue 'dispatch;
	}
	// 82A67580: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67584: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A67588: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6758C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67590: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A67594: 4E800421  bctrl
	ctx.lr = 0x82A67598;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A67598: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6759C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A675A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A675A4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A675A8: 816B6DB4  lwz r11, 0x6db4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28084 as u32) ) } as u64;
	// 82A675AC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A675B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A675B4: 4B858A4D  bl 0x822c0000
	ctx.lr = 0x82A675B8;
	sub_822C0000(ctx, base);
	// 82A675B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A675BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A675C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A675C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A675C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A675CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A675D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A675D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A675D8 size=196
    let mut pc: u32 = 0x82A675D8;
    'dispatch: loop {
        match pc {
            0x82A675D8 => {
    //   block [0x82A675D8..0x82A6769C)
	// 82A675D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A675DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A675E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A675E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A675E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A675EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A675F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A675F4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A675F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A675FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A67600: 4B859339  bl 0x822c0938
	ctx.lr = 0x82A67604;
	sub_822C0938(ctx, base);
	// 82A67604: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A67608: 41820028  beq 0x82a67630
	if ctx.cr[0].eq {
	pc = 0x82A67630; continue 'dispatch;
	}
	// 82A6760C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A67610: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A67614: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A67618: 392BFC60  addi r9, r11, -0x3a0
	ctx.r[9].s64 = ctx.r[11].s64 + -928;
	// 82A6761C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A67620: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A67624: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A67628: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A6762C: 48000008  b 0x82a67634
	pc = 0x82A67634; continue 'dispatch;
	// 82A67630: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A67634: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A67638: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6763C: 409A0044  bne cr6, 0x82a67680
	if !ctx.cr[6].eq {
	pc = 0x82A67680; continue 'dispatch;
	}
	// 82A67640: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A67644: 419A001C  beq cr6, 0x82a67660
	if ctx.cr[6].eq {
	pc = 0x82A67660; continue 'dispatch;
	}
	// 82A67648: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6764C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A67650: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A67654: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67658: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A6765C: 4E800421  bctrl
	ctx.lr = 0x82A67660;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A67660: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A67664: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A67668: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6766C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A67670: 816B6DB4  lwz r11, 0x6db4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28084 as u32) ) } as u64;
	// 82A67674: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A67678: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A6767C: 4B858985  bl 0x822c0000
	ctx.lr = 0x82A67680;
	sub_822C0000(ctx, base);
	// 82A67680: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A67684: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A67688: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6768C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A67690: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A67694: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A67698: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A676A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A676A0 size=196
    let mut pc: u32 = 0x82A676A0;
    'dispatch: loop {
        match pc {
            0x82A676A0 => {
    //   block [0x82A676A0..0x82A67764)
	// 82A676A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A676A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A676A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A676AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A676B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A676B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A676B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A676BC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A676C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A676C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A676C8: 4B859271  bl 0x822c0938
	ctx.lr = 0x82A676CC;
	sub_822C0938(ctx, base);
	// 82A676CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A676D0: 41820028  beq 0x82a676f8
	if ctx.cr[0].eq {
	pc = 0x82A676F8; continue 'dispatch;
	}
	// 82A676D4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A676D8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A676DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A676E0: 392BFC74  addi r9, r11, -0x38c
	ctx.r[9].s64 = ctx.r[11].s64 + -908;
	// 82A676E4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A676E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A676EC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A676F0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A676F4: 48000008  b 0x82a676fc
	pc = 0x82A676FC; continue 'dispatch;
	// 82A676F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A676FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A67700: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A67704: 409A0044  bne cr6, 0x82a67748
	if !ctx.cr[6].eq {
	pc = 0x82A67748; continue 'dispatch;
	}
	// 82A67708: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A6770C: 419A001C  beq cr6, 0x82a67728
	if ctx.cr[6].eq {
	pc = 0x82A67728; continue 'dispatch;
	}
	// 82A67710: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67714: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A67718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6771C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67720: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A67724: 4E800421  bctrl
	ctx.lr = 0x82A67728;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A67728: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6772C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A67730: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A67734: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A67738: 816B6DB4  lwz r11, 0x6db4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28084 as u32) ) } as u64;
	// 82A6773C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A67740: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A67744: 4B8588BD  bl 0x822c0000
	ctx.lr = 0x82A67748;
	sub_822C0000(ctx, base);
	// 82A67748: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6774C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A67750: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A67754: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A67758: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6775C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A67760: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A67768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A67768 size=124
    let mut pc: u32 = 0x82A67768;
    'dispatch: loop {
        match pc {
            0x82A67768 => {
    //   block [0x82A67768..0x82A677E4)
	// 82A67768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6776C: 48740A01  bl 0x831a816c
	ctx.lr = 0x82A67770;
	sub_831A8130(ctx, base);
	// 82A67770: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A67774: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A67778: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A6777C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A67780: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A67784: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82A67788: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82A6778C: 4838AC5D  bl 0x82df23e8
	ctx.lr = 0x82A67790;
	sub_82DF23E8(ctx, base);
	// 82A67790: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A67794: 4182001C  beq 0x82a677b0
	if ctx.cr[0].eq {
	pc = 0x82A677B0; continue 'dispatch;
	}
	// 82A67798: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6779C: 483F1EE5  bl 0x82e59680
	ctx.lr = 0x82A677A0;
	sub_82E59680(ctx, base);
	// 82A677A0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A677A4: 396BFC00  addi r11, r11, -0x400
	ctx.r[11].s64 = ctx.r[11].s64 + -1024;
	// 82A677A8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A677AC: 48000008  b 0x82a677b4
	pc = 0x82A677B4; continue 'dispatch;
	// 82A677B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A677B4: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A677B8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A677BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A677C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A677C4: 4BFFFBBD  bl 0x82a67380
	ctx.lr = 0x82A677C8;
	sub_82A67380(ctx, base);
	// 82A677C8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A677CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A677D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A677D4: 4B85882D  bl 0x822c0000
	ctx.lr = 0x82A677D8;
	sub_822C0000(ctx, base);
	// 82A677D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A677DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A677E0: 487409DC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A677E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A677E8 size=120
    let mut pc: u32 = 0x82A677E8;
    'dispatch: loop {
        match pc {
            0x82A677E8 => {
    //   block [0x82A677E8..0x82A67860)
	// 82A677E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A677EC: 48740981  bl 0x831a816c
	ctx.lr = 0x82A677F0;
	sub_831A8130(ctx, base);
	// 82A677F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A677F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A677F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A677FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A67800: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A67804: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A67808: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82A6780C: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82A67810: 4838ABD9  bl 0x82df23e8
	ctx.lr = 0x82A67814;
	sub_82DF23E8(ctx, base);
	// 82A67814: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A67818: 41820014  beq 0x82a6782c
	if ctx.cr[0].eq {
	pc = 0x82A6782C; continue 'dispatch;
	}
	// 82A6781C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67820: 480F2D59  bl 0x82b5a578
	ctx.lr = 0x82A67824;
	sub_82B5A578(ctx, base);
	// 82A67824: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A67828: 48000008  b 0x82a67830
	pc = 0x82A67830; continue 'dispatch;
	// 82A6782C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A67830: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A67834: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A67838: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6783C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A67840: 4BFFFC09  bl 0x82a67448
	ctx.lr = 0x82A67844;
	sub_82A67448(ctx, base);
	// 82A67844: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A67848: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6784C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A67850: 4B8587B1  bl 0x822c0000
	ctx.lr = 0x82A67854;
	sub_822C0000(ctx, base);
	// 82A67854: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A67858: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6785C: 48740960  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A67860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A67860 size=124
    let mut pc: u32 = 0x82A67860;
    'dispatch: loop {
        match pc {
            0x82A67860 => {
    //   block [0x82A67860..0x82A678DC)
	// 82A67860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A67864: 48740909  bl 0x831a816c
	ctx.lr = 0x82A67868;
	sub_831A8130(ctx, base);
	// 82A67868: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6786C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A67870: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A67874: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A67878: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A6787C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82A67880: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82A67884: 4838AB65  bl 0x82df23e8
	ctx.lr = 0x82A67888;
	sub_82DF23E8(ctx, base);
	// 82A67888: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A6788C: 4182001C  beq 0x82a678a8
	if ctx.cr[0].eq {
	pc = 0x82A678A8; continue 'dispatch;
	}
	// 82A67890: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A67894: 483F1DED  bl 0x82e59680
	ctx.lr = 0x82A67898;
	sub_82E59680(ctx, base);
	// 82A67898: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6789C: 396BFC08  addi r11, r11, -0x3f8
	ctx.r[11].s64 = ctx.r[11].s64 + -1016;
	// 82A678A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A678A4: 48000008  b 0x82a678ac
	pc = 0x82A678AC; continue 'dispatch;
	// 82A678A8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A678AC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A678B0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A678B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A678B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A678BC: 4BFFFC55  bl 0x82a67510
	ctx.lr = 0x82A678C0;
	sub_82A67510(ctx, base);
	// 82A678C0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A678C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A678C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A678CC: 4B858735  bl 0x822c0000
	ctx.lr = 0x82A678D0;
	sub_822C0000(ctx, base);
	// 82A678D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A678D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A678D8: 487408E4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A678E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A678E0 size=112
    let mut pc: u32 = 0x82A678E0;
    'dispatch: loop {
        match pc {
            0x82A678E0 => {
    //   block [0x82A678E0..0x82A67950)
	// 82A678E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A678E4: 48740889  bl 0x831a816c
	ctx.lr = 0x82A678E8;
	sub_831A8130(ctx, base);
	// 82A678E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A678EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A678F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A678F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A678F8: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A678FC: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82A67900: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82A67904: 4838AAE5  bl 0x82df23e8
	ctx.lr = 0x82A67908;
	sub_82DF23E8(ctx, base);
	// 82A67908: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A6790C: 41820010  beq 0x82a6791c
	if ctx.cr[0].eq {
	pc = 0x82A6791C; continue 'dispatch;
	}
	// 82A67910: 480F2E41  bl 0x82b5a750
	ctx.lr = 0x82A67914;
	sub_82B5A750(ctx, base);
	// 82A67914: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A67918: 48000008  b 0x82a67920
	pc = 0x82A67920; continue 'dispatch;
	// 82A6791C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A67920: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A67924: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A67928: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6792C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A67930: 4BFFFCA9  bl 0x82a675d8
	ctx.lr = 0x82A67934;
	sub_82A675D8(ctx, base);
	// 82A67934: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A67938: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6793C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A67940: 4B8586C1  bl 0x822c0000
	ctx.lr = 0x82A67944;
	sub_822C0000(ctx, base);
	// 82A67944: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A67948: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6794C: 48740870  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A67950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A67950 size=120
    let mut pc: u32 = 0x82A67950;
    'dispatch: loop {
        match pc {
            0x82A67950 => {
    //   block [0x82A67950..0x82A679C8)
	// 82A67950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A67954: 48740819  bl 0x831a816c
	ctx.lr = 0x82A67958;
	sub_831A8130(ctx, base);
	// 82A67958: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6795C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A67960: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A67964: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A67968: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A6796C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A67970: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82A67974: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82A67978: 4838AA71  bl 0x82df23e8
	ctx.lr = 0x82A6797C;
	sub_82DF23E8(ctx, base);
	// 82A6797C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A67980: 41820014  beq 0x82a67994
	if ctx.cr[0].eq {
	pc = 0x82A67994; continue 'dispatch;
	}
	// 82A67984: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67988: 480F2C41  bl 0x82b5a5c8
	ctx.lr = 0x82A6798C;
	sub_82B5A5C8(ctx, base);
	// 82A6798C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A67990: 48000008  b 0x82a67998
	pc = 0x82A67998; continue 'dispatch;
	// 82A67994: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A67998: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A6799C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A679A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A679A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A679A8: 4BFFFCF9  bl 0x82a676a0
	ctx.lr = 0x82A679AC;
	sub_82A676A0(ctx, base);
	// 82A679AC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A679B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A679B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A679B8: 4B858649  bl 0x822c0000
	ctx.lr = 0x82A679BC;
	sub_822C0000(ctx, base);
	// 82A679BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A679C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A679C4: 487407F8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A679C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A679C8 size=324
    let mut pc: u32 = 0x82A679C8;
    'dispatch: loop {
        match pc {
            0x82A679C8 => {
    //   block [0x82A679C8..0x82A67B0C)
	// 82A679C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A679CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A679D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A679D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A679D8: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82A679DC: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A679E0: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A679E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A679E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A679EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A679F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A679F4: 388B7B28  addi r4, r11, 0x7b28
	ctx.r[4].s64 = ctx.r[11].s64 + 31528;
	// 82A679F8: 4838C011  bl 0x82df3a08
	ctx.lr = 0x82A679FC;
	sub_82DF3A08(ctx, base);
	// 82A679FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A67A00: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82A67A04: 389F0030  addi r4, r31, 0x30
	ctx.r[4].s64 = ctx.r[31].s64 + 48;
	// 82A67A08: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A67A0C: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A67A10: C3CADD6C  lfs f30, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A67A14: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A67A18: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82A67A1C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A67A20: 4BB3B791  bl 0x825a31b0
	ctx.lr = 0x82A67A24;
	sub_825A31B0(ctx, base);
	// 82A67A24: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A67A28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A67A2C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A67A30: 4BB39D41  bl 0x825a1770
	ctx.lr = 0x82A67A34;
	sub_825A1770(ctx, base);
	// 82A67A34: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A67A38: 4838B9F1  bl 0x82df3428
	ctx.lr = 0x82A67A3C;
	sub_82DF3428(ctx, base);
	// 82A67A3C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A67A40: 4B861279  bl 0x822c8cb8
	ctx.lr = 0x82A67A44;
	sub_822C8CB8(ctx, base);
	// 82A67A44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A67A48: 4838B9E1  bl 0x82df3428
	ctx.lr = 0x82A67A4C;
	sub_82DF3428(ctx, base);
	// 82A67A4C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82A67A50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A67A54: 388B4170  addi r4, r11, 0x4170
	ctx.r[4].s64 = ctx.r[11].s64 + 16752;
	// 82A67A58: 4838BFB1  bl 0x82df3a08
	ctx.lr = 0x82A67A5C;
	sub_82DF3A08(ctx, base);
	// 82A67A5C: 389F0034  addi r4, r31, 0x34
	ctx.r[4].s64 = ctx.r[31].s64 + 52;
	// 82A67A60: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A67A64: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A67A68: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82A67A6C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A67A70: 4BB3B741  bl 0x825a31b0
	ctx.lr = 0x82A67A74;
	sub_825A31B0(ctx, base);
	// 82A67A74: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A67A78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A67A7C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A67A80: 4BB39CF1  bl 0x825a1770
	ctx.lr = 0x82A67A84;
	sub_825A1770(ctx, base);
	// 82A67A84: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82A67A88: 4838B9A1  bl 0x82df3428
	ctx.lr = 0x82A67A8C;
	sub_82DF3428(ctx, base);
	// 82A67A8C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A67A90: 4B861229  bl 0x822c8cb8
	ctx.lr = 0x82A67A94;
	sub_822C8CB8(ctx, base);
	// 82A67A94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A67A98: 4838B991  bl 0x82df3428
	ctx.lr = 0x82A67A9C;
	sub_82DF3428(ctx, base);
	// 82A67A9C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82A67AA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A67AA4: 388B2408  addi r4, r11, 0x2408
	ctx.r[4].s64 = ctx.r[11].s64 + 9224;
	// 82A67AA8: 4838BF61  bl 0x82df3a08
	ctx.lr = 0x82A67AAC;
	sub_82DF3A08(ctx, base);
	// 82A67AAC: 389F0038  addi r4, r31, 0x38
	ctx.r[4].s64 = ctx.r[31].s64 + 56;
	// 82A67AB0: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82A67AB4: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A67AB8: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82A67ABC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A67AC0: 4BB3B6F1  bl 0x825a31b0
	ctx.lr = 0x82A67AC4;
	sub_825A31B0(ctx, base);
	// 82A67AC4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A67AC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A67ACC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A67AD0: 4BB39CA1  bl 0x825a1770
	ctx.lr = 0x82A67AD4;
	sub_825A1770(ctx, base);
	// 82A67AD4: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 82A67AD8: 4838B951  bl 0x82df3428
	ctx.lr = 0x82A67ADC;
	sub_82DF3428(ctx, base);
	// 82A67ADC: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82A67AE0: 4B8611D9  bl 0x822c8cb8
	ctx.lr = 0x82A67AE4;
	sub_822C8CB8(ctx, base);
	// 82A67AE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A67AE8: 4838B941  bl 0x82df3428
	ctx.lr = 0x82A67AEC;
	sub_82DF3428(ctx, base);
	// 82A67AEC: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 82A67AF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A67AF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A67AF8: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A67AFC: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A67B00: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A67B04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A67B08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A67B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A67B10 size=332
    let mut pc: u32 = 0x82A67B10;
    'dispatch: loop {
        match pc {
            0x82A67B10 => {
    //   block [0x82A67B10..0x82A67C5C)
	// 82A67B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A67B14: 48740655  bl 0x831a8168
	ctx.lr = 0x82A67B18;
	sub_831A8130(ctx, base);
	// 82A67B18: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A67B1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A67B20: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A67B24: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82A67B28: 4BFF4711  bl 0x82a5c238
	ctx.lr = 0x82A67B2C;
	sub_82A5C238(ctx, base);
	// 82A67B2C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A67B30: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A67B34: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A67B38: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A67B3C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A67B40: 4BFFFCA9  bl 0x82a677e8
	ctx.lr = 0x82A67B44;
	sub_82A677E8(ctx, base);
	// 82A67B44: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67B48: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A67B4C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A67B50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A67B54: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A67B58: 419A0024  beq cr6, 0x82a67b7c
	if ctx.cr[6].eq {
	pc = 0x82A67B7C; continue 'dispatch;
	}
	// 82A67B5C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A67B60: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A67B64: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67B68: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A67B6C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A67B70: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A67B74: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67B78: 4082FFE8  bne 0x82a67b60
	if !ctx.cr[0].eq {
	pc = 0x82A67B60; continue 'dispatch;
	}
	// 82A67B7C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A67B80: 3BFC0028  addi r31, r28, 0x28
	ctx.r[31].s64 = ctx.r[28].s64 + 40;
	// 82A67B84: 3BCBFC88  addi r30, r11, -0x378
	ctx.r[30].s64 = ctx.r[11].s64 + -888;
	// 82A67B88: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82A67B8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A67B90: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A67B94: 38A0017E  li r5, 0x17e
	ctx.r[5].s64 = 382;
	// 82A67B98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A67B9C: 483EF44D  bl 0x82e56fe8
	ctx.lr = 0x82A67BA0;
	sub_82E56FE8(ctx, base);
	// 82A67BA0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A67BA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A67BA8: 419A0008  beq cr6, 0x82a67bb0
	if ctx.cr[6].eq {
	pc = 0x82A67BB0; continue 'dispatch;
	}
	// 82A67BAC: 4B858CE5  bl 0x822c0890
	ctx.lr = 0x82A67BB0;
	sub_822C0890(ctx, base);
	// 82A67BB0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A67BB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A67BB8: 419A0008  beq cr6, 0x82a67bc0
	if ctx.cr[6].eq {
	pc = 0x82A67BC0; continue 'dispatch;
	}
	// 82A67BBC: 4B858CD5  bl 0x822c0890
	ctx.lr = 0x82A67BC0;
	sub_822C0890(ctx, base);
	// 82A67BC0: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A67BC4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A67BC8: 4082008C  bne 0x82a67c54
	if !ctx.cr[0].eq {
	pc = 0x82A67C54; continue 'dispatch;
	}
	// 82A67BCC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A67BD0: 4BFFFC91  bl 0x82a67860
	ctx.lr = 0x82A67BD4;
	sub_82A67860(ctx, base);
	// 82A67BD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67BD8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A67BDC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A67BE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A67BE4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A67BE8: 419A0024  beq cr6, 0x82a67c0c
	if ctx.cr[6].eq {
	pc = 0x82A67C0C; continue 'dispatch;
	}
	// 82A67BEC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A67BF0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A67BF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67BF8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A67BFC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A67C00: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A67C04: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67C08: 4082FFE8  bne 0x82a67bf0
	if !ctx.cr[0].eq {
	pc = 0x82A67BF0; continue 'dispatch;
	}
	// 82A67C0C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A67C10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A67C14: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82A67C18: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A67C1C: 38A00185  li r5, 0x185
	ctx.r[5].s64 = 389;
	// 82A67C20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A67C24: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A67C28: 483F0E19  bl 0x82e58a40
	ctx.lr = 0x82A67C2C;
	sub_82E58A40(ctx, base);
	// 82A67C2C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A67C30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A67C34: 419A0008  beq cr6, 0x82a67c3c
	if ctx.cr[6].eq {
	pc = 0x82A67C3C; continue 'dispatch;
	}
	// 82A67C38: 4B858C59  bl 0x822c0890
	ctx.lr = 0x82A67C3C;
	sub_822C0890(ctx, base);
	// 82A67C3C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A67C40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A67C44: 419A0008  beq cr6, 0x82a67c4c
	if ctx.cr[6].eq {
	pc = 0x82A67C4C; continue 'dispatch;
	}
	// 82A67C48: 4B858C49  bl 0x822c0890
	ctx.lr = 0x82A67C4C;
	sub_822C0890(ctx, base);
	// 82A67C4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A67C50: 997C0120  stb r11, 0x120(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(288 as u32), ctx.r[11].u8 ) };
	// 82A67C54: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A67C58: 48740560  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A67C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A67C60 size=952
    let mut pc: u32 = 0x82A67C60;
    'dispatch: loop {
        match pc {
            0x82A67C60 => {
    //   block [0x82A67C60..0x82A68018)
	// 82A67C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A67C64: 487404F9  bl 0x831a815c
	ctx.lr = 0x82A67C68;
	sub_831A8130(ctx, base);
	// 82A67C68: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82A67C6C: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A67C70: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A67C74: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A67C78: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82A67C7C: 4BFF45BD  bl 0x82a5c238
	ctx.lr = 0x82A67C80;
	sub_82A5C238(ctx, base);
	// 82A67C80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A67C84: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A67C88: 4BFFFC59  bl 0x82a678e0
	ctx.lr = 0x82A67C8C;
	sub_82A678E0(ctx, base);
	// 82A67C8C: 8321005C  lwz r25, 0x5c(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A67C90: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A67C94: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82A67C98: 93210064  stw r25, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 82A67C9C: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82A67CA0: 419A0024  beq cr6, 0x82a67cc4
	if ctx.cr[6].eq {
	pc = 0x82A67CC4; continue 'dispatch;
	}
	// 82A67CA4: 39790004  addi r11, r25, 4
	ctx.r[11].s64 = ctx.r[25].s64 + 4;
	// 82A67CA8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A67CAC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67CB0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A67CB4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A67CB8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A67CBC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67CC0: 4082FFE8  bne 0x82a67ca8
	if !ctx.cr[0].eq {
	pc = 0x82A67CA8; continue 'dispatch;
	}
	// 82A67CC4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A67CC8: 3B5B0028  addi r26, r27, 0x28
	ctx.r[26].s64 = ctx.r[27].s64 + 40;
	// 82A67CCC: 3B8BFC88  addi r28, r11, -0x378
	ctx.r[28].s64 = ctx.r[11].s64 + -888;
	// 82A67CD0: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82A67CD4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A67CD8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82A67CDC: 38A00194  li r5, 0x194
	ctx.r[5].s64 = 404;
	// 82A67CE0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A67CE4: 483EF305  bl 0x82e56fe8
	ctx.lr = 0x82A67CE8;
	sub_82E56FE8(ctx, base);
	// 82A67CE8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A67CEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A67CF0: 419A0008  beq cr6, 0x82a67cf8
	if ctx.cr[6].eq {
	pc = 0x82A67CF8; continue 'dispatch;
	}
	// 82A67CF4: 4B858B9D  bl 0x822c0890
	ctx.lr = 0x82A67CF8;
	sub_822C0890(ctx, base);
	// 82A67CF8: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A67CFC: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82A67D00: 409A0168  bne cr6, 0x82a67e68
	if !ctx.cr[6].eq {
	pc = 0x82A67E68; continue 'dispatch;
	}
	// 82A67D04: 3960000A  li r11, 0xa
	ctx.r[11].s64 = 10;
	// 82A67D08: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A67D0C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A67D10: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A67D14: 4B8A17DD  bl 0x823094f0
	ctx.lr = 0x82A67D18;
	sub_823094F0(ctx, base);
	// 82A67D18: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67D1C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A67D20: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A67D24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A67D28: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A67D2C: 419A0024  beq cr6, 0x82a67d50
	if ctx.cr[6].eq {
	pc = 0x82A67D50; continue 'dispatch;
	}
	// 82A67D30: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A67D34: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A67D38: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67D3C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A67D40: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A67D44: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A67D48: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67D4C: 4082FFE8  bne 0x82a67d34
	if !ctx.cr[0].eq {
	pc = 0x82A67D34; continue 'dispatch;
	}
	// 82A67D50: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A67D54: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A67D58: 4BAA75D9  bl 0x8250f330
	ctx.lr = 0x82A67D5C;
	sub_8250F330(ctx, base);
	// 82A67D5C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67D60: 3BE10068  addi r31, r1, 0x68
	ctx.r[31].s64 = ctx.r[1].s64 + 104;
	// 82A67D64: 4BA81AFD  bl 0x824e9860
	ctx.lr = 0x82A67D68;
	sub_824E9860(ctx, base);
	// 82A67D68: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A67D6C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A67D70: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A67D74: 38A0019A  li r5, 0x19a
	ctx.r[5].s64 = 410;
	// 82A67D78: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A67D7C: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A67D80: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A67D84: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A67D88: 483F0CB9  bl 0x82e58a40
	ctx.lr = 0x82A67D8C;
	sub_82E58A40(ctx, base);
	// 82A67D8C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A67D90: 48389F01  bl 0x82df1c90
	ctx.lr = 0x82A67D94;
	sub_82DF1C90(ctx, base);
	// 82A67D94: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A67D98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A67D9C: 419A0008  beq cr6, 0x82a67da4
	if ctx.cr[6].eq {
	pc = 0x82A67DA4; continue 'dispatch;
	}
	// 82A67DA0: 4B858AF1  bl 0x822c0890
	ctx.lr = 0x82A67DA4;
	sub_822C0890(ctx, base);
	// 82A67DA4: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A67DA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A67DAC: 419A0008  beq cr6, 0x82a67db4
	if ctx.cr[6].eq {
	pc = 0x82A67DB4; continue 'dispatch;
	}
	// 82A67DB0: 4B858AE1  bl 0x822c0890
	ctx.lr = 0x82A67DB4;
	sub_822C0890(ctx, base);
	// 82A67DB4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A67DB8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A67DBC: 396BFBB0  addi r11, r11, -0x450
	ctx.r[11].s64 = ctx.r[11].s64 + -1104;
	// 82A67DC0: 388B0030  addi r4, r11, 0x30
	ctx.r[4].s64 = ctx.r[11].s64 + 48;
	// 82A67DC4: 4BF231A5  bl 0x8298af68
	ctx.lr = 0x82A67DC8;
	sub_8298AF68(ctx, base);
	// 82A67DC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67DCC: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A67DD0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A67DD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A67DD8: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82A67DDC: 419A0024  beq cr6, 0x82a67e00
	if ctx.cr[6].eq {
	pc = 0x82A67E00; continue 'dispatch;
	}
	// 82A67DE0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A67DE4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A67DE8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67DEC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A67DF0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A67DF4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A67DF8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67DFC: 4082FFE8  bne 0x82a67de4
	if !ctx.cr[0].eq {
	pc = 0x82A67DE4; continue 'dispatch;
	}
	// 82A67E00: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A67E04: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A67E08: 4BAA76C1  bl 0x8250f4c8
	ctx.lr = 0x82A67E0C;
	sub_8250F4C8(ctx, base);
	// 82A67E0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67E10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A67E14: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A67E18: 409A0008  bne cr6, 0x82a67e20
	if !ctx.cr[6].eq {
	pc = 0x82A67E20; continue 'dispatch;
	}
	// 82A67E1C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A67E20: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A67E24: 3BE10070  addi r31, r1, 0x70
	ctx.r[31].s64 = ctx.r[1].s64 + 112;
	// 82A67E28: 4BAA0BF1  bl 0x82508a18
	ctx.lr = 0x82A67E2C;
	sub_82508A18(ctx, base);
	// 82A67E2C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A67E30: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A67E34: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A67E38: 38A0019D  li r5, 0x19d
	ctx.r[5].s64 = 413;
	// 82A67E3C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A67E40: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A67E44: 483F0BFD  bl 0x82e58a40
	ctx.lr = 0x82A67E48;
	sub_82E58A40(ctx, base);
	// 82A67E48: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A67E4C: 48389E45  bl 0x82df1c90
	ctx.lr = 0x82A67E50;
	sub_82DF1C90(ctx, base);
	// 82A67E50: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A67E54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A67E58: 419A0008  beq cr6, 0x82a67e60
	if ctx.cr[6].eq {
	pc = 0x82A67E60; continue 'dispatch;
	}
	// 82A67E5C: 4B858A35  bl 0x822c0890
	ctx.lr = 0x82A67E60;
	sub_822C0890(ctx, base);
	// 82A67E60: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82A67E64: 4800018C  b 0x82a67ff0
	pc = 0x82A67FF0; continue 'dispatch;
	// 82A67E68: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A67E6C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A67E70: 38A001A2  li r5, 0x1a2
	ctx.r[5].s64 = 418;
	// 82A67E74: 38600240  li r3, 0x240
	ctx.r[3].s64 = 576;
	// 82A67E78: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 82A67E7C: 4838A56D  bl 0x82df23e8
	ctx.lr = 0x82A67E80;
	sub_82DF23E8(ctx, base);
	// 82A67E80: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A67E84: 41820050  beq 0x82a67ed4
	if ctx.cr[0].eq {
	pc = 0x82A67ED4; continue 'dispatch;
	}
	// 82A67E88: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A67E8C: 57FD103A  slwi r29, r31, 2
	ctx.r[29].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 82A67E90: 3BEBFBB0  addi r31, r11, -0x450
	ctx.r[31].s64 = ctx.r[11].s64 + -1104;
	// 82A67E94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A67E98: 397F0018  addi r11, r31, 0x18
	ctx.r[11].s64 = ctx.r[31].s64 + 24;
	// 82A67E9C: 7C9D582E  lwzx r4, r29, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A67EA0: 4838BB69  bl 0x82df3a08
	ctx.lr = 0x82A67EA4;
	sub_82DF3A08(ctx, base);
	// 82A67EA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A67EA8: 7C9DF82E  lwzx r4, r29, r31
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82A67EAC: 4838BB5D  bl 0x82df3a08
	ctx.lr = 0x82A67EB0;
	sub_82DF3A08(ctx, base);
	// 82A67EB0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A67EB4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A67EB8: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82A67EBC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A67EC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A67EC4: 3BA00003  li r29, 3
	ctx.r[29].s64 = 3;
	// 82A67EC8: 4BADB361  bl 0x82543228
	ctx.lr = 0x82A67ECC;
	sub_82543228(ctx, base);
	// 82A67ECC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A67ED0: 48000008  b 0x82a67ed8
	pc = 0x82A67ED8; continue 'dispatch;
	// 82A67ED4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A67ED8: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82A67EDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A67EE0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A67EE4: 4BADD2D5  bl 0x825451b8
	ctx.lr = 0x82A67EE8;
	sub_825451B8(ctx, base);
	// 82A67EE8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A67EEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A67EF0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A67EF4: 4B85810D  bl 0x822c0000
	ctx.lr = 0x82A67EF8;
	sub_822C0000(ctx, base);
	// 82A67EF8: 57AB07BD  rlwinm. r11, r29, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A67EFC: 41820010  beq 0x82a67f0c
	if ctx.cr[0].eq {
	pc = 0x82A67F0C; continue 'dispatch;
	}
	// 82A67F00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A67F04: 57BD07FA  rlwinm r29, r29, 0, 0x1f, 0x1d
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 82A67F08: 4838B521  bl 0x82df3428
	ctx.lr = 0x82A67F0C;
	sub_82DF3428(ctx, base);
	// 82A67F0C: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A67F10: 4182000C  beq 0x82a67f1c
	if ctx.cr[0].eq {
	pc = 0x82A67F1C; continue 'dispatch;
	}
	// 82A67F14: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A67F18: 4838B511  bl 0x82df3428
	ctx.lr = 0x82A67F1C;
	sub_82DF3428(ctx, base);
	// 82A67F1C: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A67F20: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A67F24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A67F28: 4BAC7BB9  bl 0x8252fae0
	ctx.lr = 0x82A67F2C;
	sub_8252FAE0(ctx, base);
	// 82A67F2C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A67F30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A67F34: 4BAC7635  bl 0x8252f568
	ctx.lr = 0x82A67F38;
	sub_8252F568(ctx, base);
	// 82A67F38: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A67F3C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A67F40: 4BFF6839  bl 0x82a5e778
	ctx.lr = 0x82A67F44;
	sub_82A5E778(ctx, base);
	// 82A67F44: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67F48: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82A67F4C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A67F50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A67F54: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82A67F58: 419A0024  beq cr6, 0x82a67f7c
	if ctx.cr[6].eq {
	pc = 0x82A67F7C; continue 'dispatch;
	}
	// 82A67F5C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A67F60: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A67F64: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67F68: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A67F6C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A67F70: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A67F74: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A67F78: 4082FFE8  bne 0x82a67f60
	if !ctx.cr[0].eq {
	pc = 0x82A67F60; continue 'dispatch;
	}
	// 82A67F7C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A67F80: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A67F84: 4BAA7545  bl 0x8250f4c8
	ctx.lr = 0x82A67F88;
	sub_8250F4C8(ctx, base);
	// 82A67F88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A67F8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A67F90: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A67F94: 409A0008  bne cr6, 0x82a67f9c
	if !ctx.cr[6].eq {
	pc = 0x82A67F9C; continue 'dispatch;
	}
	// 82A67F98: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A67F9C: 3BE10078  addi r31, r1, 0x78
	ctx.r[31].s64 = ctx.r[1].s64 + 120;
	// 82A67FA0: 4BAA0AE1  bl 0x82508a80
	ctx.lr = 0x82A67FA4;
	sub_82508A80(ctx, base);
	// 82A67FA4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A67FA8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A67FAC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A67FB0: 38A001AA  li r5, 0x1aa
	ctx.r[5].s64 = 426;
	// 82A67FB4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A67FB8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A67FBC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A67FC0: 483F0A81  bl 0x82e58a40
	ctx.lr = 0x82A67FC4;
	sub_82E58A40(ctx, base);
	// 82A67FC4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A67FC8: 48389CC9  bl 0x82df1c90
	ctx.lr = 0x82A67FCC;
	sub_82DF1C90(ctx, base);
	// 82A67FCC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A67FD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A67FD4: 419A0008  beq cr6, 0x82a67fdc
	if ctx.cr[6].eq {
	pc = 0x82A67FDC; continue 'dispatch;
	}
	// 82A67FD8: 4B8588B9  bl 0x822c0890
	ctx.lr = 0x82A67FDC;
	sub_822C0890(ctx, base);
	// 82A67FDC: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A67FE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A67FE4: 419A0008  beq cr6, 0x82a67fec
	if ctx.cr[6].eq {
	pc = 0x82A67FEC; continue 'dispatch;
	}
	// 82A67FE8: 4B8588A9  bl 0x822c0890
	ctx.lr = 0x82A67FEC;
	sub_822C0890(ctx, base);
	// 82A67FEC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A67FF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A67FF4: 419A0008  beq cr6, 0x82a67ffc
	if ctx.cr[6].eq {
	pc = 0x82A67FFC; continue 'dispatch;
	}
	// 82A67FF8: 4B858899  bl 0x822c0890
	ctx.lr = 0x82A67FFC;
	sub_822C0890(ctx, base);
	// 82A67FFC: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82A68000: 419A000C  beq cr6, 0x82a6800c
	if ctx.cr[6].eq {
	pc = 0x82A6800C; continue 'dispatch;
	}
	// 82A68004: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A68008: 4B858889  bl 0x822c0890
	ctx.lr = 0x82A6800C;
	sub_822C0890(ctx, base);
	// 82A6800C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82A68010: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82A68014: 48740198  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A68018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A68018 size=760
    let mut pc: u32 = 0x82A68018;
    'dispatch: loop {
        match pc {
            0x82A68018 => {
    //   block [0x82A68018..0x82A68310)
	// 82A68018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6801C: 48740149  bl 0x831a8164
	ctx.lr = 0x82A68020;
	sub_831A8130(ctx, base);
	// 82A68020: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A68024: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A68028: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6802C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A68030: 4BAA7499  bl 0x8250f4c8
	ctx.lr = 0x82A68034;
	sub_8250F4C8(ctx, base);
	// 82A68034: 817F00F8  lwz r11, 0xf8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82A68038: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A6803C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A68040: 409A000C  bne cr6, 0x82a6804c
	if !ctx.cr[6].eq {
	pc = 0x82A6804C; continue 'dispatch;
	}
	// 82A68044: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82A68048: 48000010  b 0x82a68058
	pc = 0x82A68058; continue 'dispatch;
	// 82A6804C: 815F00FC  lwz r10, 0xfc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82A68050: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A68054: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A68058: 815F010C  lwz r10, 0x10c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 82A6805C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A68060: 419800DC  blt cr6, 0x82a6813c
	if ctx.cr[6].lt {
	pc = 0x82A6813C; continue 'dispatch;
	}
	// 82A68064: 939F00EC  stw r28, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[28].u32 ) };
	// 82A68068: 397F00EC  addi r11, r31, 0xec
	ctx.r[11].s64 = ctx.r[31].s64 + 236;
	// 82A6806C: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82A68070: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A68074: 939F00F0  stw r28, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[28].u32 ) };
	// 82A68078: 419A0008  beq cr6, 0x82a68080
	if ctx.cr[6].eq {
	pc = 0x82A68080; continue 'dispatch;
	}
	// 82A6807C: 4B858815  bl 0x822c0890
	ctx.lr = 0x82A68080;
	sub_822C0890(ctx, base);
	// 82A68080: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A68084: 4BB108C5  bl 0x82578948
	ctx.lr = 0x82A68088;
	sub_82578948(ctx, base);
	// 82A68088: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6808C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A68090: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A68094: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A68098: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A6809C: 419A0024  beq cr6, 0x82a680c0
	if ctx.cr[6].eq {
	pc = 0x82A680C0; continue 'dispatch;
	}
	// 82A680A0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A680A4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A680A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A680AC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A680B0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A680B4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A680B8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A680BC: 4082FFE8  bne 0x82a680a4
	if !ctx.cr[0].eq {
	pc = 0x82A680A4; continue 'dispatch;
	}
	// 82A680C0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A680C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A680C8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A680CC: 409A0008  bne cr6, 0x82a680d4
	if !ctx.cr[6].eq {
	pc = 0x82A680D4; continue 'dispatch;
	}
	// 82A680D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A680D4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A680D8: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 82A680DC: 4BAA093D  bl 0x82508a18
	ctx.lr = 0x82A680E0;
	sub_82508A18(ctx, base);
	// 82A680E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A680E4: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A680E8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A680EC: 388AFC88  addi r4, r10, -0x378
	ctx.r[4].s64 = ctx.r[10].s64 + -888;
	// 82A680F0: 38A001E0  li r5, 0x1e0
	ctx.r[5].s64 = 480;
	// 82A680F4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A680F8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A680FC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A68100: 483F0941  bl 0x82e58a40
	ctx.lr = 0x82A68104;
	sub_82E58A40(ctx, base);
	// 82A68104: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A68108: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6810C: 419A0008  beq cr6, 0x82a68114
	if ctx.cr[6].eq {
	pc = 0x82A68114; continue 'dispatch;
	}
	// 82A68110: 4B858781  bl 0x822c0890
	ctx.lr = 0x82A68114;
	sub_822C0890(ctx, base);
	// 82A68114: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A68118: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6811C: 419A0008  beq cr6, 0x82a68124
	if ctx.cr[6].eq {
	pc = 0x82A68124; continue 'dispatch;
	}
	// 82A68120: 4B858771  bl 0x822c0890
	ctx.lr = 0x82A68124;
	sub_822C0890(ctx, base);
	// 82A68124: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82A68128: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6812C: 48389B65  bl 0x82df1c90
	ctx.lr = 0x82A68130;
	sub_82DF1C90(ctx, base);
	// 82A68130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A68134: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A68138: 4874007C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
	// 82A6813C: 4BFF42FD  bl 0x82a5c438
	ctx.lr = 0x82A68140;
	sub_82A5C438(ctx, base);
	// 82A68140: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A68144: 3BDF00EC  addi r30, r31, 0xec
	ctx.r[30].s64 = ctx.r[31].s64 + 236;
	// 82A68148: 3BABFC88  addi r29, r11, -0x378
	ctx.r[29].s64 = ctx.r[11].s64 + -888;
	// 82A6814C: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A68150: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A68154: 409A00A8  bne cr6, 0x82a681fc
	if !ctx.cr[6].eq {
	pc = 0x82A681FC; continue 'dispatch;
	}
	// 82A68158: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A6815C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A68160: 4BB10661  bl 0x825787c0
	ctx.lr = 0x82A68164;
	sub_825787C0(ctx, base);
	// 82A68164: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A68168: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A6816C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A68170: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A68174: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A68178: 419A0024  beq cr6, 0x82a6819c
	if ctx.cr[6].eq {
	pc = 0x82A6819C; continue 'dispatch;
	}
	// 82A6817C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A68180: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A68184: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68188: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6818C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A68190: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A68194: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68198: 4082FFE8  bne 0x82a68180
	if !ctx.cr[0].eq {
	pc = 0x82A68180; continue 'dispatch;
	}
	// 82A6819C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A681A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A681A4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A681A8: 409A0008  bne cr6, 0x82a681b0
	if !ctx.cr[6].eq {
	pc = 0x82A681B0; continue 'dispatch;
	}
	// 82A681AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A681B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A681B4: 3B610068  addi r27, r1, 0x68
	ctx.r[27].s64 = ctx.r[1].s64 + 104;
	// 82A681B8: 4BAA0861  bl 0x82508a18
	ctx.lr = 0x82A681BC;
	sub_82508A18(ctx, base);
	// 82A681BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A681C0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A681C4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A681C8: 38A001E7  li r5, 0x1e7
	ctx.r[5].s64 = 487;
	// 82A681CC: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A681D0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82A681D4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A681D8: 483F0869  bl 0x82e58a40
	ctx.lr = 0x82A681DC;
	sub_82E58A40(ctx, base);
	// 82A681DC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A681E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A681E4: 419A0008  beq cr6, 0x82a681ec
	if ctx.cr[6].eq {
	pc = 0x82A681EC; continue 'dispatch;
	}
	// 82A681E8: 4B8586A9  bl 0x822c0890
	ctx.lr = 0x82A681EC;
	sub_822C0890(ctx, base);
	// 82A681EC: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A681F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A681F4: 419A0008  beq cr6, 0x82a681fc
	if ctx.cr[6].eq {
	pc = 0x82A681FC; continue 'dispatch;
	}
	// 82A681F8: 4B858699  bl 0x822c0890
	ctx.lr = 0x82A681FC;
	sub_822C0890(ctx, base);
	// 82A681FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A68200: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A68204: 38A001E9  li r5, 0x1e9
	ctx.r[5].s64 = 489;
	// 82A68208: 386000C4  li r3, 0xc4
	ctx.r[3].s64 = 196;
	// 82A6820C: 4838A1DD  bl 0x82df23e8
	ctx.lr = 0x82A68210;
	sub_82DF23E8(ctx, base);
	// 82A68210: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A68214: 41820024  beq 0x82a68238
	if ctx.cr[0].eq {
	pc = 0x82A68238; continue 'dispatch;
	}
	// 82A68218: 815F010C  lwz r10, 0x10c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 82A6821C: 38BF0104  addi r5, r31, 0x104
	ctx.r[5].s64 = ctx.r[31].s64 + 260;
	// 82A68220: 817F00F8  lwz r11, 0xf8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82A68224: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A68228: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A6822C: 48129A65  bl 0x82b91c90
	ctx.lr = 0x82A68230;
	sub_82B91C90(ctx, base);
	// 82A68230: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A68234: 48000008  b 0x82a6823c
	pc = 0x82A6823C; continue 'dispatch;
	// 82A68238: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A6823C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A68240: 4BF53961  bl 0x829bbba0
	ctx.lr = 0x82A68244;
	sub_829BBBA0(ctx, base);
	// 82A68244: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82A68248: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6824C: 388B059C  addi r4, r11, 0x59c
	ctx.r[4].s64 = ctx.r[11].s64 + 1436;
	// 82A68250: 4838B7B9  bl 0x82df3a08
	ctx.lr = 0x82A68254;
	sub_82DF3A08(ctx, base);
	// 82A68254: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A68258: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6825C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A68260: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82A68264: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82A68268: 419A0024  beq cr6, 0x82a6828c
	if ctx.cr[6].eq {
	pc = 0x82A6828C; continue 'dispatch;
	}
	// 82A6826C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A68270: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A68274: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68278: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6827C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A68280: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A68284: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68288: 4082FFE8  bne 0x82a68270
	if !ctx.cr[0].eq {
	pc = 0x82A68270; continue 'dispatch;
	}
	// 82A6828C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A68290: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A68294: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A68298: 409A000C  bne cr6, 0x82a682a4
	if !ctx.cr[6].eq {
	pc = 0x82A682A4; continue 'dispatch;
	}
	// 82A6829C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A682A0: 419A000C  beq cr6, 0x82a682ac
	if ctx.cr[6].eq {
	pc = 0x82A682AC; continue 'dispatch;
	}
	// 82A682A4: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82A682A8: 48000008  b 0x82a682b0
	pc = 0x82A682B0; continue 'dispatch;
	// 82A682AC: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82A682B0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A682B4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A682B8: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82A682BC: 4BAA3395  bl 0x8250b650
	ctx.lr = 0x82A682C0;
	sub_8250B650(ctx, base);
	// 82A682C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A682C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A682C8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A682CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A682D0: 4BAA5239  bl 0x8250d508
	ctx.lr = 0x82A682D4;
	sub_8250D508(ctx, base);
	// 82A682D4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A682D8: 483899B9  bl 0x82df1c90
	ctx.lr = 0x82A682DC;
	sub_82DF1C90(ctx, base);
	// 82A682DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A682E0: 4838B149  bl 0x82df3428
	ctx.lr = 0x82A682E4;
	sub_82DF3428(ctx, base);
	// 82A682E4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A682E8: 48126359  bl 0x82b8e640
	ctx.lr = 0x82A682EC;
	sub_82B8E640(ctx, base);
	// 82A682EC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A682F0: 48126361  bl 0x82b8e650
	ctx.lr = 0x82A682F4;
	sub_82B8E650(ctx, base);
	// 82A682F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A682F8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A682FC: 48126395  bl 0x82b8e690
	ctx.lr = 0x82A68300;
	sub_82B8E690(ctx, base);
	// 82A68300: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A68304: 481272ED  bl 0x82b8f5f0
	ctx.lr = 0x82A68308;
	sub_82B8F5F0(ctx, base);
	// 82A68308: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82A6830C: 4BFFFE1C  b 0x82a68128
	pc = 0x82A68128; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A68310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A68310 size=108
    let mut pc: u32 = 0x82A68310;
    'dispatch: loop {
        match pc {
            0x82A68310 => {
    //   block [0x82A68310..0x82A6837C)
	// 82A68310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A68314: 4873FE59  bl 0x831a816c
	ctx.lr = 0x82A68318;
	sub_831A8130(ctx, base);
	// 82A68318: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6831C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A68320: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A68324: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A68328: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6832C: 41820038  beq 0x82a68364
	if ctx.cr[0].eq {
	pc = 0x82A68364; continue 'dispatch;
	}
	// 82A68330: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A68334: 48741655  bl 0x831a9988
	ctx.lr = 0x82A68338;
	sub_831A9988(ctx, base);
	// 82A68338: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A6833C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A68340: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 82A68344: 4873FDB5  bl 0x831a80f8
	ctx.lr = 0x82A68348;
	sub_831A80F8(ctx, base);
	// 82A68348: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6834C: 41820018  beq 0x82a68364
	if ctx.cr[0].eq {
	pc = 0x82A68364; continue 'dispatch;
	}
	// 82A68350: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A68354: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 82A68358: 4BFFF7B9  bl 0x82a67b10
	ctx.lr = 0x82A6835C;
	sub_82A67B10(ctx, base);
	// 82A6835C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A68360: 48000014  b 0x82a68374
	pc = 0x82A68374; continue 'dispatch;
	// 82A68364: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A68368: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6836C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A68370: 4BAAA2A9  bl 0x82512618
	ctx.lr = 0x82A68374;
	sub_82512618(ctx, base);
	// 82A68374: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A68378: 4873FE44  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A68380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A68380 size=144
    let mut pc: u32 = 0x82A68380;
    'dispatch: loop {
        match pc {
            0x82A68380 => {
    //   block [0x82A68380..0x82A68410)
	// 82A68380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A68384: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A68388: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6838C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A68390: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A68394: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A68398: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6839C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A683A0: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A683A4: 396BFD3C  addi r11, r11, -0x2c4
	ctx.r[11].s64 = ctx.r[11].s64 + -708;
	// 82A683A8: 394AFD28  addi r10, r10, -0x2d8
	ctx.r[10].s64 = ctx.r[10].s64 + -728;
	// 82A683AC: 3929FCDC  addi r9, r9, -0x324
	ctx.r[9].s64 = ctx.r[9].s64 + -804;
	// 82A683B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A683B4: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82A683B8: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 82A683BC: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 82A683C0: 807F0108  lwz r3, 0x108(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 82A683C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A683C8: 419A0008  beq cr6, 0x82a683d0
	if ctx.cr[6].eq {
	pc = 0x82A683D0; continue 'dispatch;
	}
	// 82A683CC: 4B8584C5  bl 0x822c0890
	ctx.lr = 0x82A683D0;
	sub_822C0890(ctx, base);
	// 82A683D0: 387F00F4  addi r3, r31, 0xf4
	ctx.r[3].s64 = ctx.r[31].s64 + 244;
	// 82A683D4: 4BA48ECD  bl 0x824b12a0
	ctx.lr = 0x82A683D8;
	sub_824B12A0(ctx, base);
	// 82A683D8: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82A683DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A683E0: 419A0008  beq cr6, 0x82a683e8
	if ctx.cr[6].eq {
	pc = 0x82A683E8; continue 'dispatch;
	}
	// 82A683E4: 4B8584AD  bl 0x822c0890
	ctx.lr = 0x82A683E8;
	sub_822C0890(ctx, base);
	// 82A683E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A683EC: 4BD3F26D  bl 0x827a7658
	ctx.lr = 0x82A683F0;
	sub_827A7658(ctx, base);
	// 82A683F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A683F4: 4B8E6F5D  bl 0x8234f350
	ctx.lr = 0x82A683F8;
	sub_8234F350(ctx, base);
	// 82A683F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A683FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A68400: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A68404: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A68408: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6840C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A68410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A68410 size=8
    let mut pc: u32 = 0x82A68410;
    'dispatch: loop {
        match pc {
            0x82A68410 => {
    //   block [0x82A68410..0x82A68418)
	// 82A68410: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82A68414: 480000F4  b 0x82a68508
	sub_82A68508(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A68418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A68418 size=8
    let mut pc: u32 = 0x82A68418;
    'dispatch: loop {
        match pc {
            0x82A68418 => {
    //   block [0x82A68418..0x82A68420)
	// 82A68418: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 82A6841C: 480000EC  b 0x82a68508
	sub_82A68508(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A68420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A68420 size=232
    let mut pc: u32 = 0x82A68420;
    'dispatch: loop {
        match pc {
            0x82A68420 => {
    //   block [0x82A68420..0x82A68508)
	// 82A68420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A68424: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A68428: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6842C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82A68430: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A68434: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A68438: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82A6843C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A68440: 38AABA80  addi r5, r10, -0x4580
	ctx.r[5].s64 = ctx.r[10].s64 + -17792;
	// 82A68444: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A68448: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A6844C: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A68450: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A68454: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82A68458: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82A6845C: 4BAA9E05  bl 0x82512260
	ctx.lr = 0x82A68460;
	sub_82512260(ctx, base);
	// 82A68460: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82A68464: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A68468: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A6846C: 38EBA214  addi r7, r11, -0x5dec
	ctx.r[7].s64 = ctx.r[11].s64 + -24044;
	// 82A68470: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A68474: 394AFD3C  addi r10, r10, -0x2c4
	ctx.r[10].s64 = ctx.r[10].s64 + -708;
	// 82A68478: 90FF00E4  stw r7, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[7].u32 ) };
	// 82A6847C: 3929FD28  addi r9, r9, -0x2d8
	ctx.r[9].s64 = ctx.r[9].s64 + -728;
	// 82A68480: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A68484: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A68488: 3908FCDC  addi r8, r8, -0x324
	ctx.r[8].s64 = ctx.r[8].s64 + -804;
	// 82A6848C: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82A68490: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A68494: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82A68498: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82A6849C: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 82A684A0: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 82A684A4: 3D008207  lis r8, -0x7df9
	ctx.r[8].s64 = -2113470464;
	// 82A684A8: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 82A684AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A684B0: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 82A684B4: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 82A684B8: C00AA1C4  lfs f0, -0x5e3c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A684BC: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 82A684C0: C1A99524  lfs f13, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A684C4: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 82A684C8: C0283290  lfs f1, 0x3290(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12944 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A684CC: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 82A684D0: D3FF0110  stfs f31, 0x110(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82A684D4: D01F0114  stfs f0, 0x114(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82A684D8: 917F010C  stw r11, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 82A684DC: D1BF0118  stfs f13, 0x118(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82A684E0: 997F0120  stb r11, 0x120(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u8 ) };
	// 82A684E4: D01F011C  stfs f0, 0x11c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 82A684E8: 4BAA93C9  bl 0x825118b0
	ctx.lr = 0x82A684EC;
	sub_825118B0(ctx, base);
	// 82A684EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A684F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A684F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A684F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A684FC: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A68500: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A68504: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A68508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A68508 size=76
    let mut pc: u32 = 0x82A68508;
    'dispatch: loop {
        match pc {
            0x82A68508 => {
    //   block [0x82A68508..0x82A68554)
	// 82A68508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6850C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A68510: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A68514: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A68518: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6851C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A68520: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A68524: 4BFFFE5D  bl 0x82a68380
	ctx.lr = 0x82A68528;
	sub_82A68380(ctx, base);
	// 82A68528: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6852C: 4182000C  beq 0x82a68538
	if ctx.cr[0].eq {
	pc = 0x82A68538; continue 'dispatch;
	}
	// 82A68530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A68534: 48389EA5  bl 0x82df23d8
	ctx.lr = 0x82A68538;
	sub_82DF23D8(ctx, base);
	// 82A68538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6853C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A68540: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A68544: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A68548: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6854C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A68550: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A68558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A68558 size=296
    let mut pc: u32 = 0x82A68558;
    'dispatch: loop {
        match pc {
            0x82A68558 => {
    //   block [0x82A68558..0x82A68680)
	// 82A68558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6855C: 4873FC11  bl 0x831a816c
	ctx.lr = 0x82A68560;
	sub_831A8130(ctx, base);
	// 82A68560: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A68564: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A68568: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82A6856C: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82A68570: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 82A68574: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A68578: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A6857C: 484381B5  bl 0x82ea0730
	ctx.lr = 0x82A68580;
	sub_82EA0730(ctx, base);
	// 82A68580: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 82A68584: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82A68588: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 82A6858C: C19F0114  lfs f12, 0x114(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A68590: C17F0118  lfs f11, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A68594: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A68598: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82A6859C: C1BF011C  lfs f13, 0x11c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A685A0: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A685A4: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82A685A8: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A685AC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A685B0: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A685B4: D1610064  stfs f11, 0x64(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A685B8: D1810060  stfs f12, 0x60(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A685BC: 13E040C7  vcmpequd (lvx128) v31, v0, v8
	tmp.u32 = ctx.r[8].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A68680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A68680 size=424
    let mut pc: u32 = 0x82A68680;
    'dispatch: loop {
        match pc {
            0x82A68680 => {
    //   block [0x82A68680..0x82A68828)
	// 82A68680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A68684: 4873FAE5  bl 0x831a8168
	ctx.lr = 0x82A68688;
	sub_831A8130(ctx, base);
	// 82A68688: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6868C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A68690: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A68694: 3BCBFC88  addi r30, r11, -0x378
	ctx.r[30].s64 = ctx.r[11].s64 + -888;
	// 82A68698: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A6869C: 38A0009A  li r5, 0x9a
	ctx.r[5].s64 = 154;
	// 82A686A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A686A4: 38600124  li r3, 0x124
	ctx.r[3].s64 = 292;
	// 82A686A8: 48389D41  bl 0x82df23e8
	ctx.lr = 0x82A686AC;
	sub_82DF23E8(ctx, base);
	// 82A686AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A686B0: 41820010  beq 0x82a686c0
	if ctx.cr[0].eq {
	pc = 0x82A686C0; continue 'dispatch;
	}
	// 82A686B4: 4BFFFD6D  bl 0x82a68420
	ctx.lr = 0x82A686B8;
	sub_82A68420(ctx, base);
	// 82A686B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A686BC: 48000008  b 0x82a686c4
	pc = 0x82A686C4; continue 'dispatch;
	// 82A686C0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A686C4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A686C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A686CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A686D0: 4BFFEBE9  bl 0x82a672b8
	ctx.lr = 0x82A686D4;
	sub_82A672B8(ctx, base);
	// 82A686D4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A686D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A686DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A686E0: 4B857921  bl 0x822c0000
	ctx.lr = 0x82A686E4;
	sub_822C0000(ctx, base);
	// 82A686E4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A686E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A686EC: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 82A686F0: 409A0008  bne cr6, 0x82a686f8
	if !ctx.cr[6].eq {
	pc = 0x82A686F8; continue 'dispatch;
	}
	// 82A686F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A686F8: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A686FC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A68700: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A68704: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82A68708: 419A0024  beq cr6, 0x82a6872c
	if ctx.cr[6].eq {
	pc = 0x82A6872C; continue 'dispatch;
	}
	// 82A6870C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82A68710: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82A68714: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68718: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82A6871C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A68720: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A68724: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68728: 4082FFE8  bne 0x82a68710
	if !ctx.cr[0].eq {
	pc = 0x82A68710; continue 'dispatch;
	}
	// 82A6872C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A68730: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A68734: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82A68738: 419A0024  beq cr6, 0x82a6875c
	if ctx.cr[6].eq {
	pc = 0x82A6875C; continue 'dispatch;
	}
	// 82A6873C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82A68740: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A68744: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68748: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6874C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A68750: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A68754: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68758: 4082FFE8  bne 0x82a68740
	if !ctx.cr[0].eq {
	pc = 0x82A68740; continue 'dispatch;
	}
	// 82A6875C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A68760: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82A68764: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A68768: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 82A6876C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A68770: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A68774: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A68778: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A6877C: 4BD307B5  bl 0x82798f30
	ctx.lr = 0x82A68780;
	sub_82798F30(ctx, base);
	// 82A68780: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82A68784: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A68788: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A6878C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A68790: 38A0009F  li r5, 0x9f
	ctx.r[5].s64 = 159;
	// 82A68794: C00B3290  lfs f0, 0x3290(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12944 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A68798: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82A6879C: C1AAA3E0  lfs f13, -0x5c20(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-23584 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A687A0: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82A687A4: D1A10094  stfs f13, 0x94(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82A687A8: 4B857C31  bl 0x822c03d8
	ctx.lr = 0x82A687AC;
	sub_822C03D8(ctx, base);
	// 82A687AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A687B0: 41820014  beq 0x82a687c4
	if ctx.cr[0].eq {
	pc = 0x82A687C4; continue 'dispatch;
	}
	// 82A687B4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A687B8: 4BD32EB1  bl 0x8279b668
	ctx.lr = 0x82A687BC;
	sub_8279B668(ctx, base);
	// 82A687BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A687C0: 48000008  b 0x82a687c8
	pc = 0x82A687C8; continue 'dispatch;
	// 82A687C4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A687C8: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A687CC: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82A687D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A687D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A687D8: 4BB2F479  bl 0x82597c50
	ctx.lr = 0x82A687DC;
	sub_82597C50(ctx, base);
	// 82A687DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A687E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A687E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A687E8: 4B857819  bl 0x822c0000
	ctx.lr = 0x82A687EC;
	sub_822C0000(ctx, base);
	// 82A687EC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A687F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A687F4: 419A0008  beq cr6, 0x82a687fc
	if ctx.cr[6].eq {
	pc = 0x82A687FC; continue 'dispatch;
	}
	// 82A687F8: 4B858099  bl 0x822c0890
	ctx.lr = 0x82A687FC;
	sub_822C0890(ctx, base);
	// 82A687FC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A68800: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A68804: 419A0008  beq cr6, 0x82a6880c
	if ctx.cr[6].eq {
	pc = 0x82A6880C; continue 'dispatch;
	}
	// 82A68808: 4B858089  bl 0x822c0890
	ctx.lr = 0x82A6880C;
	sub_822C0890(ctx, base);
	// 82A6880C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A68810: 419A000C  beq cr6, 0x82a6881c
	if ctx.cr[6].eq {
	pc = 0x82A6881C; continue 'dispatch;
	}
	// 82A68814: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A68818: 4B858079  bl 0x822c0890
	ctx.lr = 0x82A6881C;
	sub_822C0890(ctx, base);
	// 82A6881C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A68820: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A68824: 4873F994  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A68828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A68828 size=132
    let mut pc: u32 = 0x82A68828;
    'dispatch: loop {
        match pc {
            0x82A68828 => {
    //   block [0x82A68828..0x82A688AC)
	// 82A68828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6882C: 4873F941  bl 0x831a816c
	ctx.lr = 0x82A68830;
	sub_831A8130(ctx, base);
	// 82A68830: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A68834: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A68838: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A6883C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82A68840: 4BAA9199  bl 0x825119d8
	ctx.lr = 0x82A68844;
	sub_825119D8(ctx, base);
	// 82A68844: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82A68848: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6884C: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82A68850: 4838B1B9  bl 0x82df3a08
	ctx.lr = 0x82A68854;
	sub_82DF3A08(ctx, base);
	// 82A68854: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A68858: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6885C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A68860: 4BA9FF21  bl 0x82508780
	ctx.lr = 0x82A68864;
	sub_82508780(ctx, base);
	// 82A68864: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A68868: 4838ABC1  bl 0x82df3428
	ctx.lr = 0x82A6886C;
	sub_82DF3428(ctx, base);
	// 82A6886C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A68870: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82A68874: 409A0008  bne cr6, 0x82a6887c
	if !ctx.cr[6].eq {
	pc = 0x82A6887C; continue 'dispatch;
	}
	// 82A68878: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A6887C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A68880: 4BA9FF21  bl 0x825087a0
	ctx.lr = 0x82A68884;
	sub_825087A0(ctx, base);
	// 82A68884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A68888: 4BFFFCD1  bl 0x82a68558
	ctx.lr = 0x82A6888C;
	sub_82A68558(ctx, base);
	// 82A6888C: 397F0104  addi r11, r31, 0x104
	ctx.r[11].s64 = ctx.r[31].s64 + 260;
	// 82A68890: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 82A68894: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82A68898: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6889C: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 82A688A0: 4B85BBC1  bl 0x822c4460
	ctx.lr = 0x82A688A4;
	sub_822C4460(ctx, base);
	// 82A688A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A688A8: 4873F914  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A688B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A688B0 size=424
    let mut pc: u32 = 0x82A688B0;
    'dispatch: loop {
        match pc {
            0x82A688B0 => {
    //   block [0x82A688B0..0x82A68A58)
	// 82A688B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A688B4: 4873F8A5  bl 0x831a8158
	ctx.lr = 0x82A688B8;
	sub_831A8130(ctx, base);
	// 82A688B8: DBC1FFA8  stfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 82A688BC: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82A688C0: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A688C4: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82A688C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A688CC: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 82A688D0: 4BFF3969  bl 0x82a5c238
	ctx.lr = 0x82A688D4;
	sub_82A5C238(ctx, base);
	// 82A688D4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A688D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A688DC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A688E0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A688E4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A688E8: 4BFFF069  bl 0x82a67950
	ctx.lr = 0x82A688EC;
	sub_82A67950(ctx, base);
	// 82A688EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A688F0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A688F4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A688F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A688FC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A68900: 419A0024  beq cr6, 0x82a68924
	if ctx.cr[6].eq {
	pc = 0x82A68924; continue 'dispatch;
	}
	// 82A68904: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A68908: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6890C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68910: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A68914: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A68918: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6891C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68920: 4082FFE8  bne 0x82a68908
	if !ctx.cr[0].eq {
	pc = 0x82A68908; continue 'dispatch;
	}
	// 82A68924: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A68928: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82A6892C: 388BFC88  addi r4, r11, -0x378
	ctx.r[4].s64 = ctx.r[11].s64 + -888;
	// 82A68930: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A68934: 38A001C5  li r5, 0x1c5
	ctx.r[5].s64 = 453;
	// 82A68938: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A6893C: 483EE6AD  bl 0x82e56fe8
	ctx.lr = 0x82A68940;
	sub_82E56FE8(ctx, base);
	// 82A68940: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A68944: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A68948: 419A0008  beq cr6, 0x82a68950
	if ctx.cr[6].eq {
	pc = 0x82A68950; continue 'dispatch;
	}
	// 82A6894C: 4B857F45  bl 0x822c0890
	ctx.lr = 0x82A68950;
	sub_822C0890(ctx, base);
	// 82A68950: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A68954: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A68958: 419A0008  beq cr6, 0x82a68960
	if ctx.cr[6].eq {
	pc = 0x82A68960; continue 'dispatch;
	}
	// 82A6895C: 4B857F35  bl 0x822c0890
	ctx.lr = 0x82A68960;
	sub_822C0890(ctx, base);
	// 82A68960: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A68964: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A68968: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6896C: 809F0104  lwz r4, 0x104(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A68970: 396BFBE4  addi r11, r11, -0x41c
	ctx.r[11].s64 = ctx.r[11].s64 + -1052;
	// 82A68974: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A68978: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A6897C: 4BEAC4F5  bl 0x82914e70
	ctx.lr = 0x82A68980;
	sub_82914E70(ctx, base);
	// 82A68980: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A68984: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A68988: 409900C0  ble cr6, 0x82a68a48
	if !ctx.cr[6].gt {
	pc = 0x82A68A48; continue 'dispatch;
	}
	// 82A6898C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82A68990: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A68994: 3B3F00F4  addi r25, r31, 0xf4
	ctx.r[25].s64 = ctx.r[31].s64 + 244;
	// 82A68998: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 82A6899C: 3B400010  li r26, 0x10
	ctx.r[26].s64 = 16;
	// 82A689A0: C3CBBC10  lfs f30, -0x43f0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17392 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A689A4: 3B600020  li r27, 0x20
	ctx.r[27].s64 = 32;
	// 82A689A8: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A689AC: 3B800030  li r28, 0x30
	ctx.r[28].s64 = 48;
	// 82A689B0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A689B4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A689B8: 7C8BE82E  lwzx r4, r11, r29
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82A689BC: 4838B04D  bl 0x82df3a08
	ctx.lr = 0x82A689C0;
	sub_82DF3A08(ctx, base);
	// 82A689C0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82A689C4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A689C8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A689CC: 48117015  bl 0x82b7f9e0
	ctx.lr = 0x82A689D0;
	sub_82B7F9E0(ctx, base);
	// 82A689D0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A689D4: 4838AA55  bl 0x82df3428
	ctx.lr = 0x82A689D8;
	sub_82DF3428(ctx, base);
	// 82A689D8: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A689DC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A689E0: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A689E4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82A689E8: 3BEB0030  addi r31, r11, 0x30
	ctx.r[31].s64 = ctx.r[11].s64 + 48;
	// 82A689EC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A689F0: 48413629  bl 0x82e7c018
	ctx.lr = 0x82A689F4;
	sub_82E7C018(ctx, base);
	// 82A689F4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A689F8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82A689FC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A68A00: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A68A04: 13DA5C07  vcmpneb. (lvlx128) v30, v26, v11
	tmp.u32 = ctx.r[26].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A68A08: 13BB5C07  vcmpneb. (lvlx128) v29, v27, v11
	tmp.u32 = ctx.r[27].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A68A0C: 139C5C07  vcmpneb. (lvlx128) v28, v28, v11
	tmp.u32 = ctx.r[28].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A68A58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A68A58 size=1808
    let mut pc: u32 = 0x82A68A58;
    'dispatch: loop {
        match pc {
            0x82A68A58 => {
    //   block [0x82A68A58..0x82A69168)
	// 82A68A58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A68A5C: 4873F709  bl 0x831a8164
	ctx.lr = 0x82A68A60;
	sub_831A8130(ctx, base);
	// 82A68A60: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A68A64: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A68A68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A68A6C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A68A70: 4BAA7C99  bl 0x82510708
	ctx.lr = 0x82A68A74;
	sub_82510708(ctx, base);
	// 82A68A74: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82A68A78: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A68A7C: 41980608  blt cr6, 0x82a69084
	if ctx.cr[6].lt {
	pc = 0x82A69084; continue 'dispatch;
	}
	// 82A68A80: 419A060C  beq cr6, 0x82a6908c
	if ctx.cr[6].eq {
	pc = 0x82A6908C; continue 'dispatch;
	}
	// 82A68A84: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A68A88: 41980320  blt cr6, 0x82a68da8
	if ctx.cr[6].lt {
	pc = 0x82A68DA8; continue 'dispatch;
	}
	// 82A68A8C: 409A06D0  bne cr6, 0x82a6915c
	if !ctx.cr[6].eq {
	pc = 0x82A6915C; continue 'dispatch;
	}
	// 82A68A90: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A68A94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A68A98: 419A0014  beq cr6, 0x82a68aac
	if ctx.cr[6].eq {
	pc = 0x82A68AAC; continue 'dispatch;
	}
	// 82A68A9C: 48125AA5  bl 0x82b8e540
	ctx.lr = 0x82A68AA0;
	sub_82B8E540(ctx, base);
	// 82A68AA0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A68AA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A68AA8: 40820008  bne 0x82a68ab0
	if !ctx.cr[0].eq {
	pc = 0x82A68AB0; continue 'dispatch;
	}
	// 82A68AAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A68AB0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A68AB4: 41820158  beq 0x82a68c0c
	if ctx.cr[0].eq {
	pc = 0x82A68C0C; continue 'dispatch;
	}
	// 82A68AB8: 817F00F8  lwz r11, 0xf8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82A68ABC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A68AC0: 419A0010  beq cr6, 0x82a68ad0
	if ctx.cr[6].eq {
	pc = 0x82A68AD0; continue 'dispatch;
	}
	// 82A68AC4: 815F00FC  lwz r10, 0xfc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82A68AC8: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A68ACC: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A68AD0: 815F010C  lwz r10, 0x10c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 82A68AD4: 392A0001  addi r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 1;
	// 82A68AD8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A68ADC: 41980680  blt cr6, 0x82a6915c
	if ctx.cr[6].lt {
	pc = 0x82A6915C; continue 'dispatch;
	}
	// 82A68AE0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A68AE4: C01F0110  lfs f0, 0x110(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A68AE8: 389F0110  addi r4, r31, 0x110
	ctx.r[4].s64 = ctx.r[31].s64 + 272;
	// 82A68AEC: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A68AF0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A68AF4: 4098002C  bge cr6, 0x82a68b20
	if !ctx.cr[6].lt {
	pc = 0x82A68B20; continue 'dispatch;
	}
	// 82A68AF8: 817F00F8  lwz r11, 0xf8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82A68AFC: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A68B00: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A68B04: C1AB001C  lfs f13, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A68B08: C00B0020  lfs f0, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A68B0C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A68B10: C1AB0024  lfs f13, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A68B14: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82A68B18: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A68B1C: 48000640  b 0x82a6915c
	pc = 0x82A6915C; continue 'dispatch;
	// 82A68B20: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A68B24: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A68B28: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A68B2C: D1840000  stfs f12, 0(r4)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A68B30: C1AB64C8  lfs f13, 0x64c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25800 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A68B34: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82A68B38: 41990624  bgt cr6, 0x82a6915c
	if ctx.cr[6].gt {
	pc = 0x82A6915C; continue 'dispatch;
	}
	// 82A68B3C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A68B40: 4098061C  bge cr6, 0x82a6915c
	if !ctx.cr[6].lt {
	pc = 0x82A6915C; continue 'dispatch;
	}
	// 82A68B44: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A68B48: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82A68B4C: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 82A68B50: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 82A68B54: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 82A68B58: 38A99FA0  addi r5, r9, -0x6060
	ctx.r[5].s64 = ctx.r[9].s64 + -24672;
	// 82A68B5C: C00B9534  lfs f0, -0x6acc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A68B60: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82A68B64: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A68B68: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82A68B6C: 4BACBAD5  bl 0x82534640
	ctx.lr = 0x82A68B70;
	sub_82534640(ctx, base);
	// 82A68B70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A68B74: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82A68B78: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A68B7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A68B80: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82A68B84: 419A0024  beq cr6, 0x82a68ba8
	if ctx.cr[6].eq {
	pc = 0x82A68BA8; continue 'dispatch;
	}
	// 82A68B88: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A68B8C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A68B90: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68B94: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A68B98: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A68B9C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A68BA0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68BA4: 4082FFE8  bne 0x82a68b8c
	if !ctx.cr[0].eq {
	pc = 0x82A68B8C; continue 'dispatch;
	}
	// 82A68BA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A68BAC: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A68BB0: 4BAA6781  bl 0x8250f330
	ctx.lr = 0x82A68BB4;
	sub_8250F330(ctx, base);
	// 82A68BB4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A68BB8: 3BC10080  addi r30, r1, 0x80
	ctx.r[30].s64 = ctx.r[1].s64 + 128;
	// 82A68BBC: 4BA80CB5  bl 0x824e9870
	ctx.lr = 0x82A68BC0;
	sub_824E9870(ctx, base);
	// 82A68BC0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A68BC4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A68BC8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A68BCC: 388BFC88  addi r4, r11, -0x378
	ctx.r[4].s64 = ctx.r[11].s64 + -888;
	// 82A68BD0: 38A0014D  li r5, 0x14d
	ctx.r[5].s64 = 333;
	// 82A68BD4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A68BD8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A68BDC: 483EFE65  bl 0x82e58a40
	ctx.lr = 0x82A68BE0;
	sub_82E58A40(ctx, base);
	// 82A68BE0: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A68BE4: 483890AD  bl 0x82df1c90
	ctx.lr = 0x82A68BE8;
	sub_82DF1C90(ctx, base);
	// 82A68BE8: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A68BEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A68BF0: 419A0008  beq cr6, 0x82a68bf8
	if ctx.cr[6].eq {
	pc = 0x82A68BF8; continue 'dispatch;
	}
	// 82A68BF4: 4B857C9D  bl 0x822c0890
	ctx.lr = 0x82A68BF8;
	sub_822C0890(ctx, base);
	// 82A68BF8: 806100FC  lwz r3, 0xfc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 82A68BFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A68C00: 419A055C  beq cr6, 0x82a6915c
	if ctx.cr[6].eq {
	pc = 0x82A6915C; continue 'dispatch;
	}
	// 82A68C04: 4B857C8D  bl 0x822c0890
	ctx.lr = 0x82A68C08;
	sub_822C0890(ctx, base);
	// 82A68C08: 48000554  b 0x82a6915c
	pc = 0x82A6915C; continue 'dispatch;
	// 82A68C0C: 817F010C  lwz r11, 0x10c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 82A68C10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A68C14: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A68C18: 917F010C  stw r11, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 82A68C1C: 4BFFF3FD  bl 0x82a68018
	ctx.lr = 0x82A68C20;
	sub_82A68018(ctx, base);
	// 82A68C20: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A68C24: 40820538  bne 0x82a6915c
	if !ctx.cr[0].eq {
	pc = 0x82A6915C; continue 'dispatch;
	}
	// 82A68C28: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 82A68C2C: 4BB0FD1D  bl 0x82578948
	ctx.lr = 0x82A68C30;
	sub_82578948(ctx, base);
	// 82A68C30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A68C34: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A68C38: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A68C3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A68C40: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82A68C44: 419A0024  beq cr6, 0x82a68c68
	if ctx.cr[6].eq {
	pc = 0x82A68C68; continue 'dispatch;
	}
	// 82A68C48: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A68C4C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A68C50: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68C54: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A68C58: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A68C5C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A68C60: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68C64: 4082FFE8  bne 0x82a68c4c
	if !ctx.cr[0].eq {
	pc = 0x82A68C4C; continue 'dispatch;
	}
	// 82A68C68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A68C6C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A68C70: 4BAA6859  bl 0x8250f4c8
	ctx.lr = 0x82A68C74;
	sub_8250F4C8(ctx, base);
	// 82A68C74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A68C78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A68C7C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A68C80: 409A0008  bne cr6, 0x82a68c88
	if !ctx.cr[6].eq {
	pc = 0x82A68C88; continue 'dispatch;
	}
	// 82A68C84: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A68C88: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 82A68C8C: 3B810070  addi r28, r1, 0x70
	ctx.r[28].s64 = ctx.r[1].s64 + 112;
	// 82A68C90: 4BA9FDF1  bl 0x82508a80
	ctx.lr = 0x82A68C94;
	sub_82508A80(ctx, base);
	// 82A68C94: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A68C98: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A68C9C: 3BABFC88  addi r29, r11, -0x378
	ctx.r[29].s64 = ctx.r[11].s64 + -888;
	// 82A68CA0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A68CA4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A68CA8: 38A00156  li r5, 0x156
	ctx.r[5].s64 = 342;
	// 82A68CAC: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A68CB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A68CB4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A68CB8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A68CBC: 483EFD85  bl 0x82e58a40
	ctx.lr = 0x82A68CC0;
	sub_82E58A40(ctx, base);
	// 82A68CC0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A68CC4: 48388FCD  bl 0x82df1c90
	ctx.lr = 0x82A68CC8;
	sub_82DF1C90(ctx, base);
	// 82A68CC8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A68CCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A68CD0: 419A0008  beq cr6, 0x82a68cd8
	if ctx.cr[6].eq {
	pc = 0x82A68CD8; continue 'dispatch;
	}
	// 82A68CD4: 4B857BBD  bl 0x822c0890
	ctx.lr = 0x82A68CD8;
	sub_822C0890(ctx, base);
	// 82A68CD8: 806100EC  lwz r3, 0xec(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A68CDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A68CE0: 419A0008  beq cr6, 0x82a68ce8
	if ctx.cr[6].eq {
	pc = 0x82A68CE8; continue 'dispatch;
	}
	// 82A68CE4: 4B857BAD  bl 0x822c0890
	ctx.lr = 0x82A68CE8;
	sub_822C0890(ctx, base);
	// 82A68CE8: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 82A68CEC: 4BB0FC5D  bl 0x82578948
	ctx.lr = 0x82A68CF0;
	sub_82578948(ctx, base);
	// 82A68CF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A68CF4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A68CF8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A68CFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A68D00: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A68D04: 419A0024  beq cr6, 0x82a68d28
	if ctx.cr[6].eq {
	pc = 0x82A68D28; continue 'dispatch;
	}
	// 82A68D08: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A68D0C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A68D10: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68D14: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A68D18: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A68D1C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A68D20: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68D24: 4082FFE8  bne 0x82a68d0c
	if !ctx.cr[0].eq {
	pc = 0x82A68D0C; continue 'dispatch;
	}
	// 82A68D28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A68D2C: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82A68D30: 4BAA6799  bl 0x8250f4c8
	ctx.lr = 0x82A68D34;
	sub_8250F4C8(ctx, base);
	// 82A68D34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A68D38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A68D3C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A68D40: 409A0008  bne cr6, 0x82a68d48
	if !ctx.cr[6].eq {
	pc = 0x82A68D48; continue 'dispatch;
	}
	// 82A68D44: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A68D48: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A68D4C: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 82A68D50: 4BA9FCC9  bl 0x82508a18
	ctx.lr = 0x82A68D54;
	sub_82508A18(ctx, base);
	// 82A68D54: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A68D58: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A68D5C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A68D60: 38A00158  li r5, 0x158
	ctx.r[5].s64 = 344;
	// 82A68D64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A68D68: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A68D6C: 483EFCD5  bl 0x82e58a40
	ctx.lr = 0x82A68D70;
	sub_82E58A40(ctx, base);
	// 82A68D70: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82A68D74: 48388F1D  bl 0x82df1c90
	ctx.lr = 0x82A68D78;
	sub_82DF1C90(ctx, base);
	// 82A68D78: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A68D7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A68D80: 419A0008  beq cr6, 0x82a68d88
	if ctx.cr[6].eq {
	pc = 0x82A68D88; continue 'dispatch;
	}
	// 82A68D84: 4B857B0D  bl 0x822c0890
	ctx.lr = 0x82A68D88;
	sub_822C0890(ctx, base);
	// 82A68D88: 8061010C  lwz r3, 0x10c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 82A68D8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A68D90: 419A0008  beq cr6, 0x82a68d98
	if ctx.cr[6].eq {
	pc = 0x82A68D98; continue 'dispatch;
	}
	// 82A68D94: 4B857AFD  bl 0x822c0890
	ctx.lr = 0x82A68D98;
	sub_822C0890(ctx, base);
	// 82A68D98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A68D9C: 4BFFEEC5  bl 0x82a67c60
	ctx.lr = 0x82A68DA0;
	sub_82A67C60(ctx, base);
	// 82A68DA0: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82A68DA4: 480003B4  b 0x82a69158
	pc = 0x82A69158; continue 'dispatch;
	// 82A68DA8: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A68DAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A68DB0: C1BF0110  lfs f13, 0x110(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A68DB4: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A68DB8: D01F0110  stfs f0, 0x110(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82A68DBC: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A68DC0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A68DC4: 40980398  bge cr6, 0x82a6915c
	if !ctx.cr[6].lt {
	pc = 0x82A6915C; continue 'dispatch;
	}
	// 82A68DC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A68DCC: 4BFFFAE5  bl 0x82a688b0
	ctx.lr = 0x82A68DD0;
	sub_82A688B0(ctx, base);
	// 82A68DD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A68DD4: 4BFFF245  bl 0x82a68018
	ctx.lr = 0x82A68DD8;
	sub_82A68018(ctx, base);
	// 82A68DD8: 3B9F00EC  addi r28, r31, 0xec
	ctx.r[28].s64 = ctx.r[31].s64 + 236;
	// 82A68DDC: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A68DE0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A68DE4: 4BB0F9DD  bl 0x825787c0
	ctx.lr = 0x82A68DE8;
	sub_825787C0(ctx, base);
	// 82A68DE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A68DEC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A68DF0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A68DF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A68DF8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A68DFC: 419A0024  beq cr6, 0x82a68e20
	if ctx.cr[6].eq {
	pc = 0x82A68E20; continue 'dispatch;
	}
	// 82A68E00: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A68E04: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A68E08: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68E0C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A68E10: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A68E14: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A68E18: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68E1C: 4082FFE8  bne 0x82a68e04
	if !ctx.cr[0].eq {
	pc = 0x82A68E04; continue 'dispatch;
	}
	// 82A68E20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A68E24: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82A68E28: 4BAA66A1  bl 0x8250f4c8
	ctx.lr = 0x82A68E2C;
	sub_8250F4C8(ctx, base);
	// 82A68E2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A68E30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A68E34: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A68E38: 409A0008  bne cr6, 0x82a68e40
	if !ctx.cr[6].eq {
	pc = 0x82A68E40; continue 'dispatch;
	}
	// 82A68E3C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A68E40: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A68E44: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 82A68E48: 3B610058  addi r27, r1, 0x58
	ctx.r[27].s64 = ctx.r[1].s64 + 88;
	// 82A68E4C: 4BA9FBCD  bl 0x82508a18
	ctx.lr = 0x82A68E50;
	sub_82508A18(ctx, base);
	// 82A68E50: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A68E54: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A68E58: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A68E5C: 3BABFC88  addi r29, r11, -0x378
	ctx.r[29].s64 = ctx.r[11].s64 + -888;
	// 82A68E60: 38A00132  li r5, 0x132
	ctx.r[5].s64 = 306;
	// 82A68E64: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A68E68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A68E6C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82A68E70: 483EFBD1  bl 0x82e58a40
	ctx.lr = 0x82A68E74;
	sub_82E58A40(ctx, base);
	// 82A68E74: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82A68E78: 48388E19  bl 0x82df1c90
	ctx.lr = 0x82A68E7C;
	sub_82DF1C90(ctx, base);
	// 82A68E7C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A68E80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A68E84: 419A0008  beq cr6, 0x82a68e8c
	if ctx.cr[6].eq {
	pc = 0x82A68E8C; continue 'dispatch;
	}
	// 82A68E88: 4B857A09  bl 0x822c0890
	ctx.lr = 0x82A68E8C;
	sub_822C0890(ctx, base);
	// 82A68E8C: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A68E90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A68E94: 419A0008  beq cr6, 0x82a68e9c
	if ctx.cr[6].eq {
	pc = 0x82A68E9C; continue 'dispatch;
	}
	// 82A68E98: 4B8579F9  bl 0x822c0890
	ctx.lr = 0x82A68E9C;
	sub_822C0890(ctx, base);
	// 82A68E9C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A68EA0: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82A68EA4: 4BB0F91D  bl 0x825787c0
	ctx.lr = 0x82A68EA8;
	sub_825787C0(ctx, base);
	// 82A68EA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A68EAC: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A68EB0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A68EB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A68EB8: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A68EBC: 419A0024  beq cr6, 0x82a68ee0
	if ctx.cr[6].eq {
	pc = 0x82A68EE0; continue 'dispatch;
	}
	// 82A68EC0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A68EC4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A68EC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68ECC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A68ED0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A68ED4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A68ED8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68EDC: 4082FFE8  bne 0x82a68ec4
	if !ctx.cr[0].eq {
	pc = 0x82A68EC4; continue 'dispatch;
	}
	// 82A68EE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A68EE4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A68EE8: 4BAA65E1  bl 0x8250f4c8
	ctx.lr = 0x82A68EEC;
	sub_8250F4C8(ctx, base);
	// 82A68EEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A68EF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A68EF4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A68EF8: 409A0008  bne cr6, 0x82a68f00
	if !ctx.cr[6].eq {
	pc = 0x82A68F00; continue 'dispatch;
	}
	// 82A68EFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A68F00: 3B810068  addi r28, r1, 0x68
	ctx.r[28].s64 = ctx.r[1].s64 + 104;
	// 82A68F04: 4BA9FB7D  bl 0x82508a80
	ctx.lr = 0x82A68F08;
	sub_82508A80(ctx, base);
	// 82A68F08: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A68F0C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A68F10: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A68F14: 38A00134  li r5, 0x134
	ctx.r[5].s64 = 308;
	// 82A68F18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A68F1C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A68F20: 483EFB21  bl 0x82e58a40
	ctx.lr = 0x82A68F24;
	sub_82E58A40(ctx, base);
	// 82A68F24: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A68F28: 48388D69  bl 0x82df1c90
	ctx.lr = 0x82A68F2C;
	sub_82DF1C90(ctx, base);
	// 82A68F2C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A68F30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A68F34: 419A0008  beq cr6, 0x82a68f3c
	if ctx.cr[6].eq {
	pc = 0x82A68F3C; continue 'dispatch;
	}
	// 82A68F38: 4B857959  bl 0x822c0890
	ctx.lr = 0x82A68F3C;
	sub_822C0890(ctx, base);
	// 82A68F3C: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A68F40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A68F44: 419A0008  beq cr6, 0x82a68f4c
	if ctx.cr[6].eq {
	pc = 0x82A68F4C; continue 'dispatch;
	}
	// 82A68F48: 4B857949  bl 0x822c0890
	ctx.lr = 0x82A68F4C;
	sub_822C0890(ctx, base);
	// 82A68F4C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82A68F50: 4BFFE819  bl 0x82a67768
	ctx.lr = 0x82A68F54;
	sub_82A67768(ctx, base);
	// 82A68F54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A68F58: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82A68F5C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A68F60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A68F64: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82A68F68: 419A0024  beq cr6, 0x82a68f8c
	if ctx.cr[6].eq {
	pc = 0x82A68F8C; continue 'dispatch;
	}
	// 82A68F6C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A68F70: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A68F74: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68F78: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A68F7C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A68F80: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A68F84: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A68F88: 4082FFE8  bne 0x82a68f70
	if !ctx.cr[0].eq {
	pc = 0x82A68F70; continue 'dispatch;
	}
	// 82A68F8C: 3B810078  addi r28, r1, 0x78
	ctx.r[28].s64 = ctx.r[1].s64 + 120;
	// 82A68F90: 4BFF32A9  bl 0x82a5c238
	ctx.lr = 0x82A68F94;
	sub_82A5C238(ctx, base);
	// 82A68F94: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A68F98: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A68F9C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A68FA0: 38A00136  li r5, 0x136
	ctx.r[5].s64 = 310;
	// 82A68FA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A68FA8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A68FAC: 483EFA95  bl 0x82e58a40
	ctx.lr = 0x82A68FB0;
	sub_82E58A40(ctx, base);
	// 82A68FB0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A68FB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A68FB8: 419A0008  beq cr6, 0x82a68fc0
	if ctx.cr[6].eq {
	pc = 0x82A68FC0; continue 'dispatch;
	}
	// 82A68FBC: 4B8578D5  bl 0x822c0890
	ctx.lr = 0x82A68FC0;
	sub_822C0890(ctx, base);
	// 82A68FC0: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82A68FC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A68FC8: 419A0008  beq cr6, 0x82a68fd0
	if ctx.cr[6].eq {
	pc = 0x82A68FD0; continue 'dispatch;
	}
	// 82A68FCC: 4B8578C5  bl 0x822c0890
	ctx.lr = 0x82A68FD0;
	sub_822C0890(ctx, base);
	// 82A68FD0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A68FD4: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A68FD8: 38AB9FA0  addi r5, r11, -0x6060
	ctx.r[5].s64 = ctx.r[11].s64 + -24672;
	// 82A68FDC: 388A64C8  addi r4, r10, 0x64c8
	ctx.r[4].s64 = ctx.r[10].s64 + 25800;
	// 82A68FE0: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82A68FE4: 4BACBEFD  bl 0x82534ee0
	ctx.lr = 0x82A68FE8;
	sub_82534EE0(ctx, base);
	// 82A68FE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A68FEC: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82A68FF0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A68FF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A68FF8: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82A68FFC: 419A0024  beq cr6, 0x82a69020
	if ctx.cr[6].eq {
	pc = 0x82A69020; continue 'dispatch;
	}
	// 82A69000: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A69004: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A69008: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6900C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A69010: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A69014: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A69018: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6901C: 4082FFE8  bne 0x82a69004
	if !ctx.cr[0].eq {
	pc = 0x82A69004; continue 'dispatch;
	}
	// 82A69020: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A69024: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82A69028: 4BAA6309  bl 0x8250f330
	ctx.lr = 0x82A6902C;
	sub_8250F330(ctx, base);
	// 82A6902C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A69030: 3B810088  addi r28, r1, 0x88
	ctx.r[28].s64 = ctx.r[1].s64 + 136;
	// 82A69034: 4BA8083D  bl 0x824e9870
	ctx.lr = 0x82A69038;
	sub_824E9870(ctx, base);
	// 82A69038: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A6903C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A69040: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A69044: 38A00139  li r5, 0x139
	ctx.r[5].s64 = 313;
	// 82A69048: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6904C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A69050: 483EF9F1  bl 0x82e58a40
	ctx.lr = 0x82A69054;
	sub_82E58A40(ctx, base);
	// 82A69054: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82A69058: 48388C39  bl 0x82df1c90
	ctx.lr = 0x82A6905C;
	sub_82DF1C90(ctx, base);
	// 82A6905C: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A69060: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A69064: 419A0008  beq cr6, 0x82a6906c
	if ctx.cr[6].eq {
	pc = 0x82A6906C; continue 'dispatch;
	}
	// 82A69068: 4B857829  bl 0x822c0890
	ctx.lr = 0x82A6906C;
	sub_822C0890(ctx, base);
	// 82A6906C: 806100F4  lwz r3, 0xf4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A69070: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A69074: 419A0008  beq cr6, 0x82a6907c
	if ctx.cr[6].eq {
	pc = 0x82A6907C; continue 'dispatch;
	}
	// 82A69078: 4B857819  bl 0x822c0890
	ctx.lr = 0x82A6907C;
	sub_822C0890(ctx, base);
	// 82A6907C: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82A69080: 480000D8  b 0x82a69158
	pc = 0x82A69158; continue 'dispatch;
	// 82A69084: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A69088: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82A6908C: 897F0120  lbz r11, 0x120(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 82A69090: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A69094: 418200C8  beq 0x82a6915c
	if ctx.cr[0].eq {
	pc = 0x82A6915C; continue 'dispatch;
	}
	// 82A69098: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6909C: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82A690A0: 389F0110  addi r4, r31, 0x110
	ctx.r[4].s64 = ctx.r[31].s64 + 272;
	// 82A690A4: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82A690A8: 38AA9FA0  addi r5, r10, -0x6060
	ctx.r[5].s64 = ctx.r[10].s64 + -24672;
	// 82A690AC: C00B64C8  lfs f0, 0x64c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25800 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A690B0: D01F0110  stfs f0, 0x110(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82A690B4: 4BACBD25  bl 0x82534dd8
	ctx.lr = 0x82A690B8;
	sub_82534DD8(ctx, base);
	// 82A690B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A690BC: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82A690C0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A690C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A690C8: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 82A690CC: 419A0024  beq cr6, 0x82a690f0
	if ctx.cr[6].eq {
	pc = 0x82A690F0; continue 'dispatch;
	}
	// 82A690D0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A690D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A690D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A690DC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A690E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A690E4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A690E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A690EC: 4082FFE8  bne 0x82a690d4
	if !ctx.cr[0].eq {
	pc = 0x82A690D4; continue 'dispatch;
	}
	// 82A690F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A690F4: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82A690F8: 4BAA6239  bl 0x8250f330
	ctx.lr = 0x82A690FC;
	sub_8250F330(ctx, base);
	// 82A690FC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A69100: 3BC10098  addi r30, r1, 0x98
	ctx.r[30].s64 = ctx.r[1].s64 + 152;
	// 82A69104: 4BA8076D  bl 0x824e9870
	ctx.lr = 0x82A69108;
	sub_824E9870(ctx, base);
	// 82A69108: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A6910C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A69110: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A69114: 388AFC88  addi r4, r10, -0x378
	ctx.r[4].s64 = ctx.r[10].s64 + -888;
	// 82A69118: 38A00124  li r5, 0x124
	ctx.r[5].s64 = 292;
	// 82A6911C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A69120: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A69124: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A69128: 483EF919  bl 0x82e58a40
	ctx.lr = 0x82A6912C;
	sub_82E58A40(ctx, base);
	// 82A6912C: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82A69130: 48388B61  bl 0x82df1c90
	ctx.lr = 0x82A69134;
	sub_82DF1C90(ctx, base);
	// 82A69134: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82A69138: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6913C: 419A0008  beq cr6, 0x82a69144
	if ctx.cr[6].eq {
	pc = 0x82A69144; continue 'dispatch;
	}
	// 82A69140: 4B857751  bl 0x822c0890
	ctx.lr = 0x82A69144;
	sub_822C0890(ctx, base);
	// 82A69144: 80610114  lwz r3, 0x114(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 82A69148: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6914C: 419A0008  beq cr6, 0x82a69154
	if ctx.cr[6].eq {
	pc = 0x82A69154; continue 'dispatch;
	}
	// 82A69150: 4B857741  bl 0x822c0890
	ctx.lr = 0x82A69154;
	sub_822C0890(ctx, base);
	// 82A69154: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A69158: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82A6915C: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 82A69160: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A69164: 4873F050  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69168 size=12
    let mut pc: u32 = 0x82A69168;
    'dispatch: loop {
        match pc {
            0x82A69168 => {
    //   block [0x82A69168..0x82A69174)
	// 82A69168: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A6916C: 806BDFF8  lwz r3, -0x2008(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8200 as u32) ) } as u64;
	// 82A69170: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A69178 size=400
    let mut pc: u32 = 0x82A69178;
    'dispatch: loop {
        match pc {
            0x82A69178 => {
    //   block [0x82A69178..0x82A69308)
	// 82A69178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6917C: 4873EFF1  bl 0x831a816c
	ctx.lr = 0x82A69180;
	sub_831A8130(ctx, base);
	// 82A69180: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A69184: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A69188: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A6918C: 897E0270  lbz r11, 0x270(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(624 as u32) ) } as u64;
	// 82A69190: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A69194: 4182000C  beq 0x82a691a0
	if ctx.cr[0].eq {
	pc = 0x82A691A0; continue 'dispatch;
	}
	// 82A69198: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A6919C: 48000164  b 0x82a69300
	pc = 0x82A69300; continue 'dispatch;
	// 82A691A0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A691A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A691A8: 388B893C  addi r4, r11, -0x76c4
	ctx.r[4].s64 = ctx.r[11].s64 + -30404;
	// 82A691AC: 4838A85D  bl 0x82df3a08
	ctx.lr = 0x82A691B0;
	sub_82DF3A08(ctx, base);
	// 82A691B0: 807E00EC  lwz r3, 0xec(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A691B4: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82A691B8: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A691BC: 483F1515  bl 0x82e5a6d0
	ctx.lr = 0x82A691C0;
	sub_82E5A6D0(ctx, base);
	// 82A691C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A691C4: 4838A0DD  bl 0x82df32a0
	ctx.lr = 0x82A691C8;
	sub_82DF32A0(ctx, base);
	// 82A691C8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A691CC: 418200C8  beq 0x82a69294
	if ctx.cr[0].eq {
	pc = 0x82A69294; continue 'dispatch;
	}
	// 82A691D0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A691D4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A691D8: 388B0740  addi r4, r11, 0x740
	ctx.r[4].s64 = ctx.r[11].s64 + 1856;
	// 82A691DC: 4838A82D  bl 0x82df3a08
	ctx.lr = 0x82A691E0;
	sub_82DF3A08(ctx, base);
	// 82A691E0: 807E00EC  lwz r3, 0xec(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A691E4: 3BE00003  li r31, 3
	ctx.r[31].s64 = 3;
	// 82A691E8: 3BA1005C  addi r29, r1, 0x5c
	ctx.r[29].s64 = ctx.r[1].s64 + 92;
	// 82A691EC: 483F14E5  bl 0x82e5a6d0
	ctx.lr = 0x82A691F0;
	sub_82E5A6D0(ctx, base);
	// 82A691F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A691F4: 4838A0AD  bl 0x82df32a0
	ctx.lr = 0x82A691F8;
	sub_82DF32A0(ctx, base);
	// 82A691F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A691FC: 41820098  beq 0x82a69294
	if ctx.cr[0].eq {
	pc = 0x82A69294; continue 'dispatch;
	}
	// 82A69200: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A69204: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A69208: 388BE848  addi r4, r11, -0x17b8
	ctx.r[4].s64 = ctx.r[11].s64 + -6072;
	// 82A6920C: 4838A7FD  bl 0x82df3a08
	ctx.lr = 0x82A69210;
	sub_82DF3A08(ctx, base);
	// 82A69210: 807E00EC  lwz r3, 0xec(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A69214: 3BE00007  li r31, 7
	ctx.r[31].s64 = 7;
	// 82A69218: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 82A6921C: 483F14B5  bl 0x82e5a6d0
	ctx.lr = 0x82A69220;
	sub_82E5A6D0(ctx, base);
	// 82A69220: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A69224: 4838A07D  bl 0x82df32a0
	ctx.lr = 0x82A69228;
	sub_82DF32A0(ctx, base);
	// 82A69228: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6922C: 41820068  beq 0x82a69294
	if ctx.cr[0].eq {
	pc = 0x82A69294; continue 'dispatch;
	}
	// 82A69230: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A69234: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A69238: 388B6C90  addi r4, r11, 0x6c90
	ctx.r[4].s64 = ctx.r[11].s64 + 27792;
	// 82A6923C: 4838A7CD  bl 0x82df3a08
	ctx.lr = 0x82A69240;
	sub_82DF3A08(ctx, base);
	// 82A69240: 807E00EC  lwz r3, 0xec(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A69244: 3BE0000F  li r31, 0xf
	ctx.r[31].s64 = 15;
	// 82A69248: 3BA10054  addi r29, r1, 0x54
	ctx.r[29].s64 = ctx.r[1].s64 + 84;
	// 82A6924C: 483F1485  bl 0x82e5a6d0
	ctx.lr = 0x82A69250;
	sub_82E5A6D0(ctx, base);
	// 82A69250: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A69254: 4838A04D  bl 0x82df32a0
	ctx.lr = 0x82A69258;
	sub_82DF32A0(ctx, base);
	// 82A69258: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6925C: 41820038  beq 0x82a69294
	if ctx.cr[0].eq {
	pc = 0x82A69294; continue 'dispatch;
	}
	// 82A69260: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82A69264: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A69268: 388B60C8  addi r4, r11, 0x60c8
	ctx.r[4].s64 = ctx.r[11].s64 + 24776;
	// 82A6926C: 4838A79D  bl 0x82df3a08
	ctx.lr = 0x82A69270;
	sub_82DF3A08(ctx, base);
	// 82A69270: 807E00EC  lwz r3, 0xec(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A69274: 3BE0001F  li r31, 0x1f
	ctx.r[31].s64 = 31;
	// 82A69278: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82A6927C: 483F1455  bl 0x82e5a6d0
	ctx.lr = 0x82A69280;
	sub_82E5A6D0(ctx, base);
	// 82A69280: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A69284: 4838A01D  bl 0x82df32a0
	ctx.lr = 0x82A69288;
	sub_82DF32A0(ctx, base);
	// 82A69288: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6928C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A69290: 40820008  bne 0x82a69298
	if !ctx.cr[0].eq {
	pc = 0x82A69298; continue 'dispatch;
	}
	// 82A69294: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A69298: 57EA06F7  rlwinm. r10, r31, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A6929C: 557E063E  clrlwi r30, r11, 0x18
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A692A0: 41820010  beq 0x82a692b0
	if ctx.cr[0].eq {
	pc = 0x82A692B0; continue 'dispatch;
	}
	// 82A692A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A692A8: 57FF0734  rlwinm r31, r31, 0, 0x1c, 0x1a
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 82A692AC: 4838A17D  bl 0x82df3428
	ctx.lr = 0x82A692B0;
	sub_82DF3428(ctx, base);
	// 82A692B0: 57EB0739  rlwinm. r11, r31, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A692B4: 41820010  beq 0x82a692c4
	if ctx.cr[0].eq {
	pc = 0x82A692C4; continue 'dispatch;
	}
	// 82A692B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A692BC: 57FF0776  rlwinm r31, r31, 0, 0x1d, 0x1b
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 82A692C0: 4838A169  bl 0x82df3428
	ctx.lr = 0x82A692C4;
	sub_82DF3428(ctx, base);
	// 82A692C4: 57EB077B  rlwinm. r11, r31, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A692C8: 41820010  beq 0x82a692d8
	if ctx.cr[0].eq {
	pc = 0x82A692D8; continue 'dispatch;
	}
	// 82A692CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A692D0: 57FF07B8  rlwinm r31, r31, 0, 0x1e, 0x1c
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 82A692D4: 4838A155  bl 0x82df3428
	ctx.lr = 0x82A692D8;
	sub_82DF3428(ctx, base);
	// 82A692D8: 57EB07BD  rlwinm. r11, r31, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A692DC: 41820010  beq 0x82a692ec
	if ctx.cr[0].eq {
	pc = 0x82A692EC; continue 'dispatch;
	}
	// 82A692E0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A692E4: 57FF07FA  rlwinm r31, r31, 0, 0x1f, 0x1d
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 82A692E8: 4838A141  bl 0x82df3428
	ctx.lr = 0x82A692EC;
	sub_82DF3428(ctx, base);
	// 82A692EC: 57EB07FF  clrlwi. r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A692F0: 4182000C  beq 0x82a692fc
	if ctx.cr[0].eq {
	pc = 0x82A692FC; continue 'dispatch;
	}
	// 82A692F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A692F8: 4838A131  bl 0x82df3428
	ctx.lr = 0x82A692FC;
	sub_82DF3428(ctx, base);
	// 82A692FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A69300: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A69304: 4873EEB8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69308 size=8
    let mut pc: u32 = 0x82A69308;
    'dispatch: loop {
        match pc {
            0x82A69308 => {
    //   block [0x82A69308..0x82A69310)
	// 82A69308: 88630220  lbz r3, 0x220(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(544 as u32) ) } as u64;
	// 82A6930C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69310 size=8
    let mut pc: u32 = 0x82A69310;
    'dispatch: loop {
        match pc {
            0x82A69310 => {
    //   block [0x82A69310..0x82A69318)
	// 82A69310: 38630140  addi r3, r3, 0x140
	ctx.r[3].s64 = ctx.r[3].s64 + 320;
	// 82A69314: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69318 size=8
    let mut pc: u32 = 0x82A69318;
    'dispatch: loop {
        match pc {
            0x82A69318 => {
    //   block [0x82A69318..0x82A69320)
	// 82A69318: 88630130  lbz r3, 0x130(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(304 as u32) ) } as u64;
	// 82A6931C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69320 size=12
    let mut pc: u32 = 0x82A69320;
    'dispatch: loop {
        match pc {
            0x82A69320 => {
    //   block [0x82A69320..0x82A6932C)
	// 82A69320: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A69324: 99630184  stb r11, 0x184(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(388 as u32), ctx.r[11].u8 ) };
	// 82A69328: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69330 size=8
    let mut pc: u32 = 0x82A69330;
    'dispatch: loop {
        match pc {
            0x82A69330 => {
    //   block [0x82A69330..0x82A69338)
	// 82A69330: 88630184  lbz r3, 0x184(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(388 as u32) ) } as u64;
	// 82A69334: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A69338 size=8
    let mut pc: u32 = 0x82A69338;
    'dispatch: loop {
        match pc {
            0x82A69338 => {
    //   block [0x82A69338..0x82A69340)
	// 82A69338: D0230174  stfs f1, 0x174(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 82A6933C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69340 size=4
    let mut pc: u32 = 0x82A69340;
    'dispatch: loop {
        match pc {
            0x82A69340 => {
    //   block [0x82A69340..0x82A69344)
	// 82A69340: 4BAA8980  b 0x82511cc0
	sub_82511CC0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69348 size=12
    let mut pc: u32 = 0x82A69348;
    'dispatch: loop {
        match pc {
            0x82A69348 => {
    //   block [0x82A69348..0x82A69354)
	// 82A69348: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 82A6934C: 916301F8  stw r11, 0x1f8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(504 as u32), ctx.r[11].u32 ) };
	// 82A69350: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69358 size=12
    let mut pc: u32 = 0x82A69358;
    'dispatch: loop {
        match pc {
            0x82A69358 => {
    //   block [0x82A69358..0x82A69364)
	// 82A69358: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A6935C: 996301FC  stb r11, 0x1fc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(508 as u32), ctx.r[11].u8 ) };
	// 82A69360: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69368 size=12
    let mut pc: u32 = 0x82A69368;
    'dispatch: loop {
        match pc {
            0x82A69368 => {
    //   block [0x82A69368..0x82A69374)
	// 82A69368: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A6936C: 996301FC  stb r11, 0x1fc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(508 as u32), ctx.r[11].u8 ) };
	// 82A69370: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69378 size=8
    let mut pc: u32 = 0x82A69378;
    'dispatch: loop {
        match pc {
            0x82A69378 => {
    //   block [0x82A69378..0x82A69380)
	// 82A69378: 886301FC  lbz r3, 0x1fc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(508 as u32) ) } as u64;
	// 82A6937C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69380 size=8
    let mut pc: u32 = 0x82A69380;
    'dispatch: loop {
        match pc {
            0x82A69380 => {
    //   block [0x82A69380..0x82A69388)
	// 82A69380: 908301F8  stw r4, 0x1f8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(504 as u32), ctx.r[4].u32 ) };
	// 82A69384: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69388 size=8
    let mut pc: u32 = 0x82A69388;
    'dispatch: loop {
        match pc {
            0x82A69388 => {
    //   block [0x82A69388..0x82A69390)
	// 82A69388: 806301F8  lwz r3, 0x1f8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(504 as u32) ) } as u64;
	// 82A6938C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69390 size=16
    let mut pc: u32 = 0x82A69390;
    'dispatch: loop {
        match pc {
            0x82A69390 => {
    //   block [0x82A69390..0x82A693A0)
	// 82A69390: 816301F8  lwz r11, 0x1f8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(504 as u32) ) } as u64;
	// 82A69394: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A69398: 91640018  stw r11, 0x18(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82A6939C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A693A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A693A0 size=124
    let mut pc: u32 = 0x82A693A0;
    'dispatch: loop {
        match pc {
            0x82A693A0 => {
    //   block [0x82A693A0..0x82A6941C)
	// 82A693A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A693A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A693A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A693AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A693B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A693B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A693B8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A693BC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A693C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A693C4: 388BD964  addi r4, r11, -0x269c
	ctx.r[4].s64 = ctx.r[11].s64 + -9884;
	// 82A693C8: 4838A641  bl 0x82df3a08
	ctx.lr = 0x82A693CC;
	sub_82DF3A08(ctx, base);
	// 82A693CC: 807E00EC  lwz r3, 0xec(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A693D0: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82A693D4: 483F12FD  bl 0x82e5a6d0
	ctx.lr = 0x82A693D8;
	sub_82E5A6D0(ctx, base);
	// 82A693D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A693DC: 48389F2D  bl 0x82df3308
	ctx.lr = 0x82A693E0;
	sub_82DF3308(ctx, base);
	// 82A693E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A693E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A693E8: 4838A041  bl 0x82df3428
	ctx.lr = 0x82A693EC;
	sub_82DF3428(ctx, base);
	// 82A693EC: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A693F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A693F4: 40820008  bne 0x82a693fc
	if !ctx.cr[0].eq {
	pc = 0x82A693FC; continue 'dispatch;
	}
	// 82A693F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A693FC: 997F0018  stb r11, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 82A69400: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A69404: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A69408: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6940C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A69410: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A69414: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A69418: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A69420 size=48
    let mut pc: u32 = 0x82A69420;
    'dispatch: loop {
        match pc {
            0x82A69420 => {
    //   block [0x82A69420..0x82A69450)
	// 82A69420: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A69424: 814B01EC  lwz r10, 0x1ec(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(492 as u32) ) } as u64;
	// 82A69428: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A6942C: 40800008  bge 0x82a69434
	if !ctx.cr[0].lt {
	pc = 0x82A69434; continue 'dispatch;
	}
	// 82A69430: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A69434: 91440020  stw r10, 0x20(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 82A69438: C00B01E0  lfs f0, 0x1e0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(480 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6943C: D0040024  stfs f0, 0x24(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82A69440: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A69444: 896B01E8  lbz r11, 0x1e8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(488 as u32) ) } as u64;
	// 82A69448: 99640028  stb r11, 0x28(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(40 as u32), ctx.r[11].u8 ) };
	// 82A6944C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69450 size=32
    let mut pc: u32 = 0x82A69450;
    'dispatch: loop {
        match pc {
            0x82A69450 => {
    //   block [0x82A69450..0x82A69470)
	// 82A69450: 8964001C  lbz r11, 0x1c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A69454: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A69458: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82A6945C: 41820008  beq 0x82a69464
	if ctx.cr[0].eq {
	pc = 0x82A69464; continue 'dispatch;
	}
	// 82A69460: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A69464: 916301E4  stw r11, 0x1e4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(484 as u32), ctx.r[11].u32 ) };
	// 82A69468: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A6946C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A69470 size=52
    let mut pc: u32 = 0x82A69470;
    'dispatch: loop {
        match pc {
            0x82A69470 => {
    //   block [0x82A69470..0x82A694A4)
	// 82A69470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A69474: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A69478: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6947C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A69480: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A69484: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82A69488: 4859ECA1  bl 0x83008128
	ctx.lr = 0x82A6948C;
	sub_83008128(ctx, base);
	// 82A6948C: 907F01F0  stw r3, 0x1f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(496 as u32), ctx.r[3].u32 ) };
	// 82A69490: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A69494: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A69498: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6949C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A694A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A694A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A694A8 size=8
    let mut pc: u32 = 0x82A694A8;
    'dispatch: loop {
        match pc {
            0x82A694A8 => {
    //   block [0x82A694A8..0x82A694B0)
	// 82A694A8: D02301E0  stfs f1, 0x1e0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(480 as u32), tmp.u32 ) };
	// 82A694AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A694B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A694B0 size=12
    let mut pc: u32 = 0x82A694B0;
    'dispatch: loop {
        match pc {
            0x82A694B0 => {
    //   block [0x82A694B0..0x82A694BC)
	// 82A694B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A694B4: 996301E8  stb r11, 0x1e8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(488 as u32), ctx.r[11].u8 ) };
	// 82A694B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A694C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A694C0 size=36
    let mut pc: u32 = 0x82A694C0;
    'dispatch: loop {
        match pc {
            0x82A694C0 => {
    //   block [0x82A694C0..0x82A694E4)
	// 82A694C0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A694C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A694C8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A694CC: 916301E4  stw r11, 0x1e4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(484 as u32), ctx.r[11].u32 ) };
	// 82A694D0: 992301E8  stb r9, 0x1e8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(488 as u32), ctx.r[9].u8 ) };
	// 82A694D4: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A694D8: 916301EC  stw r11, 0x1ec(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(492 as u32), ctx.r[11].u32 ) };
	// 82A694DC: D00301E0  stfs f0, 0x1e0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(480 as u32), tmp.u32 ) };
	// 82A694E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A694E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A694E8 size=8
    let mut pc: u32 = 0x82A694E8;
    'dispatch: loop {
        match pc {
            0x82A694E8 => {
    //   block [0x82A694E8..0x82A694F0)
	// 82A694E8: 806301E4  lwz r3, 0x1e4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(484 as u32) ) } as u64;
	// 82A694EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A694F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A694F0 size=12
    let mut pc: u32 = 0x82A694F0;
    'dispatch: loop {
        match pc {
            0x82A694F0 => {
    //   block [0x82A694F0..0x82A694FC)
	// 82A694F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A694F4: 996301F4  stb r11, 0x1f4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(500 as u32), ctx.r[11].u8 ) };
	// 82A694F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69500 size=12
    let mut pc: u32 = 0x82A69500;
    'dispatch: loop {
        match pc {
            0x82A69500 => {
    //   block [0x82A69500..0x82A6950C)
	// 82A69500: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A69504: 996301F4  stb r11, 0x1f4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(500 as u32), ctx.r[11].u8 ) };
	// 82A69508: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69510 size=12
    let mut pc: u32 = 0x82A69510;
    'dispatch: loop {
        match pc {
            0x82A69510 => {
    //   block [0x82A69510..0x82A6951C)
	// 82A69510: 806300F4  lwz r3, 0xf4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A69514: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A69518: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6951C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A6951C size=8
    let mut pc: u32 = 0x82A6951C;
    'dispatch: loop {
        match pc {
            0x82A6951C => {
    //   block [0x82A6951C..0x82A69524)
	// 82A6951C: 4800625C  b 0x82a6f778
	sub_82A6F778(ctx, base);
	return;
	// 82A69520: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69528 size=12
    let mut pc: u32 = 0x82A69528;
    'dispatch: loop {
        match pc {
            0x82A69528 => {
    //   block [0x82A69528..0x82A69534)
	// 82A69528: 806300F4  lwz r3, 0xf4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A6952C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A69530: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69534(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69534 size=8
    let mut pc: u32 = 0x82A69534;
    'dispatch: loop {
        match pc {
            0x82A69534 => {
    //   block [0x82A69534..0x82A6953C)
	// 82A69534: 48006254  b 0x82a6f788
	sub_82A6F788(ctx, base);
	return;
	// 82A69538: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69540 size=20
    let mut pc: u32 = 0x82A69540;
    'dispatch: loop {
        match pc {
            0x82A69540 => {
    //   block [0x82A69540..0x82A69554)
	// 82A69540: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A69544: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A69548: 916301F8  stw r11, 0x1f8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(504 as u32), ctx.r[11].u32 ) };
	// 82A6954C: 994301F4  stb r10, 0x1f4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(500 as u32), ctx.r[10].u8 ) };
	// 82A69550: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69558 size=8
    let mut pc: u32 = 0x82A69558;
    'dispatch: loop {
        match pc {
            0x82A69558 => {
    //   block [0x82A69558..0x82A69560)
	// 82A69558: 38630210  addi r3, r3, 0x210
	ctx.r[3].s64 = ctx.r[3].s64 + 528;
	// 82A6955C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69560 size=12
    let mut pc: u32 = 0x82A69560;
    'dispatch: loop {
        match pc {
            0x82A69560 => {
    //   block [0x82A69560..0x82A6956C)
	// 82A69560: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A69564: 99630185  stb r11, 0x185(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(389 as u32), ctx.r[11].u8 ) };
	// 82A69568: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69570 size=12
    let mut pc: u32 = 0x82A69570;
    'dispatch: loop {
        match pc {
            0x82A69570 => {
    //   block [0x82A69570..0x82A6957C)
	// 82A69570: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A69574: 99630185  stb r11, 0x185(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(389 as u32), ctx.r[11].u8 ) };
	// 82A69578: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69580 size=8
    let mut pc: u32 = 0x82A69580;
    'dispatch: loop {
        match pc {
            0x82A69580 => {
    //   block [0x82A69580..0x82A69588)
	// 82A69580: 88630185  lbz r3, 0x185(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(389 as u32) ) } as u64;
	// 82A69584: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69588 size=12
    let mut pc: u32 = 0x82A69588;
    'dispatch: loop {
        match pc {
            0x82A69588 => {
    //   block [0x82A69588..0x82A69594)
	// 82A69588: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A6958C: 99630270  stb r11, 0x270(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(624 as u32), ctx.r[11].u8 ) };
	// 82A69590: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A69598 size=12
    let mut pc: u32 = 0x82A69598;
    'dispatch: loop {
        match pc {
            0x82A69598 => {
    //   block [0x82A69598..0x82A695A4)
	// 82A69598: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A6959C: 99630270  stb r11, 0x270(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(624 as u32), ctx.r[11].u8 ) };
	// 82A695A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A695A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A695A8 size=28
    let mut pc: u32 = 0x82A695A8;
    'dispatch: loop {
        match pc {
            0x82A695A8 => {
    //   block [0x82A695A8..0x82A695C4)
	// 82A695A8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A695AC: C0030104  lfs f0, 0x104(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A695B0: D0040018  stfs f0, 0x18(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A695B4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A695B8: C00B7DD8  lfs f0, 0x7dd8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A695BC: D004001C  stfs f0, 0x1c(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82A695C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A695C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A695C8 size=8
    let mut pc: u32 = 0x82A695C8;
    'dispatch: loop {
        match pc {
            0x82A695C8 => {
    //   block [0x82A695C8..0x82A695D0)
	// 82A695C8: D023029C  stfs f1, 0x29c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(668 as u32), tmp.u32 ) };
	// 82A695CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A695D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A695D0 size=12
    let mut pc: u32 = 0x82A695D0;
    'dispatch: loop {
        match pc {
            0x82A695D0 => {
    //   block [0x82A695D0..0x82A695DC)
	// 82A695D0: D023029C  stfs f1, 0x29c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(668 as u32), tmp.u32 ) };
	// 82A695D4: D02302A0  stfs f1, 0x2a0(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(672 as u32), tmp.u32 ) };
	// 82A695D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A695E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A695E0 size=68
    let mut pc: u32 = 0x82A695E0;
    'dispatch: loop {
        match pc {
            0x82A695E0 => {
    //   block [0x82A695E0..0x82A69624)
	// 82A695E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A695E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A695E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A695EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A695F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A695F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A695F8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A695FC: 997F0298  stb r11, 0x298(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), ctx.r[11].u8 ) };
	// 82A69600: 483ECDC9  bl 0x82e563c8
	ctx.lr = 0x82A69604;
	sub_82E563C8(ctx, base);
	// 82A69604: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A69608: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6960C: 4BAA6535  bl 0x8250fb40
	ctx.lr = 0x82A69610;
	sub_8250FB40(ctx, base);
	// 82A69610: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A69614: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A69618: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6961C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A69620: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A69628 size=136
    let mut pc: u32 = 0x82A69628;
    'dispatch: loop {
        match pc {
            0x82A69628 => {
    //   block [0x82A69628..0x82A696B0)
	// 82A69628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6962C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A69630: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A69634: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A69638: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6963C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A69640: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A69644: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82A69648: 409A0020  bne cr6, 0x82a69668
	if !ctx.cr[6].eq {
	pc = 0x82A69668; continue 'dispatch;
	}
	// 82A6964C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A69650: 419A0048  beq cr6, 0x82a69698
	if ctx.cr[6].eq {
	pc = 0x82A69698; continue 'dispatch;
	}
	// 82A69654: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82A69658: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82A6965C: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 82A69660: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82A69664: 48000034  b 0x82a69698
	pc = 0x82A69698; continue 'dispatch;
	// 82A69668: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82A6966C: 419A002C  beq cr6, 0x82a69698
	if ctx.cr[6].eq {
	pc = 0x82A69698; continue 'dispatch;
	}
	// 82A69670: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A69674: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A69678: 388B7290  addi r4, r11, 0x7290
	ctx.r[4].s64 = ctx.r[11].s64 + 29328;
	// 82A6967C: 4873EA7D  bl 0x831a80f8
	ctx.lr = 0x82A69680;
	sub_831A80F8(ctx, base);
	// 82A69680: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A69684: 4182000C  beq 0x82a69690
	if ctx.cr[0].eq {
	pc = 0x82A69690; continue 'dispatch;
	}
	// 82A69688: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A6968C: 4800000C  b 0x82a69698
	pc = 0x82A69698; continue 'dispatch;
	// 82A69690: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A69694: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A69698: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6969C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A696A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A696A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A696A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A696AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A696B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A696B0 size=84
    let mut pc: u32 = 0x82A696B0;
    'dispatch: loop {
        match pc {
            0x82A696B0 => {
    //   block [0x82A696B0..0x82A69704)
	// 82A696B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A696B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A696B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A696BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A696C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A696C4: 4BAA8425  bl 0x82511ae8
	ctx.lr = 0x82A696C8;
	sub_82511AE8(ctx, base);
	// 82A696C8: C01F0218  lfs f0, 0x218(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(536 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A696CC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A696D0: C1A30008  lfs f13, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A696D4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A696D8: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A696DC: C00B7DDC  lfs f0, 0x7ddc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32220 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A696E0: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 82A696E4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A696E8: 40980008  bge cr6, 0x82a696f0
	if !ctx.cr[6].lt {
	pc = 0x82A696F0; continue 'dispatch;
	}
	// 82A696EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A696F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A696F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A696F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A696FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A69700: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A69708 size=60
    let mut pc: u32 = 0x82A69708;
    'dispatch: loop {
        match pc {
            0x82A69708 => {
    //   block [0x82A69708..0x82A69744)
	// 82A69708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6970C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A69710: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A69714: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A69718: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82A6971C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A69720: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A69724: 806B016C  lwz r3, 0x16c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(364 as u32) ) } as u64;
	// 82A69728: 4B8669C1  bl 0x822d00e8
	ctx.lr = 0x82A6972C;
	sub_822D00E8(ctx, base);
	// 82A6972C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A69730: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A69734: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A69738: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6973C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A69740: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A69748 size=16
    let mut pc: u32 = 0x82A69748;
    'dispatch: loop {
        match pc {
            0x82A69748 => {
    //   block [0x82A69748..0x82A69758)
	// 82A69748: 39600150  li r11, 0x150
	ctx.r[11].s64 = 336;
	// 82A6974C: 13E458C7  vcmpequd (lvx128) v31, v4, v11
	tmp.u32 = ctx.r[4].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A69758 size=16
    let mut pc: u32 = 0x82A69758;
    'dispatch: loop {
        match pc {
            0x82A69758 => {
    //   block [0x82A69758..0x82A69768)
	// 82A69758: 39600150  li r11, 0x150
	ctx.r[11].s64 = 336;
	// 82A6975C: 13E020C7  vcmpequd (lvx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A69768 size=72
    let mut pc: u32 = 0x82A69768;
    'dispatch: loop {
        match pc {
            0x82A69768 => {
    //   block [0x82A69768..0x82A697B0)
	// 82A69768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6976C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A69770: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A69774: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A69778: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6977C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A69780: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A69784: 389F0030  addi r4, r31, 0x30
	ctx.r[4].s64 = ctx.r[31].s64 + 48;
	// 82A69788: 4BAA82F9  bl 0x82511a80
	ctx.lr = 0x82A6978C;
	sub_82511A80(ctx, base);
	// 82A6978C: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 82A69790: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A69794: 4BAA835D  bl 0x82511af0
	ctx.lr = 0x82A69798;
	sub_82511AF0(ctx, base);
	// 82A69798: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6979C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A697A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A697A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A697A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A697AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A697B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A697B0 size=256
    let mut pc: u32 = 0x82A697B0;
    'dispatch: loop {
        match pc {
            0x82A697B0 => {
    //   block [0x82A697B0..0x82A698B0)
	// 82A697B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A697B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A697B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A697BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A697C0: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 82A697C4: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82A697C8: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A697CC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A697D0: FFA01090  fmr f29, f2
	ctx.f[29].f64 = ctx.f[2].f64;
	// 82A697D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A697D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A697DC: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82A697E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A697E4: FFE01890  fmr f31, f3
	ctx.f[31].f64 = ctx.f[3].f64;
	// 82A697E8: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A697EC: FF1D0000  fcmpu cr6, f29, f0
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[0].f64);
	// 82A697F0: 41990038  bgt cr6, 0x82a69828
	if ctx.cr[6].gt {
	pc = 0x82A69828; continue 'dispatch;
	}
	// 82A697F4: EDBF07F2  fmuls f13, f31, f31
	ctx.f[13].f64 = (((ctx.f[31].f64 * ctx.f[31].f64) as f32) as f64);
	// 82A697F8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A697FC: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A69800: ED8007F2  fmuls f12, f0, f31
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82A69804: C17E0000  lfs f11, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A69808: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6980C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A69810: EC0067BA  fmadds f0, f0, f30, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[12].f64) as f32) as f64);
	// 82A69814: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82A69818: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A6981C: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A69820: EC1E07FA  fmadds f0, f30, f31, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82A69824: 48000064  b 0x82a69888
	pc = 0x82A69888; continue 'dispatch;
	// 82A69828: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82A6982C: EC5D07F2  fmuls f2, f29, f31
	ctx.f[2].f64 = (((ctx.f[29].f64 * ctx.f[31].f64) as f32) as f64);
	// 82A69830: C82B7360  lfd f1, 0x7360(r11)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(29536 as u32) ) };
	// 82A69834: 48741C75  bl 0x831ab4a8
	ctx.lr = 0x82A69838;
	sub_831AB4A8(ctx, base);
	// 82A69838: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82A6983C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A69840: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A69844: ED80F778  fmsubs f12, f0, f29, f30
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[29].f64 - ctx.f[30].f64) as f32) as f64);
	// 82A69848: C17E0000  lfs f11, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A6984C: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A69850: ED40E824  fdivs f10, f0, f29
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[29].f64) as f32) as f64;
	// 82A69854: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82A69858: ED2A07F2  fmuls f9, f10, f31
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[31].f64) as f32) as f64);
	// 82A6985C: ED0A07B2  fmuls f8, f10, f30
	ctx.f[8].f64 = (((ctx.f[10].f64 * ctx.f[30].f64) as f32) as f64);
	// 82A69860: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A69864: ED2907B2  fmuls f9, f9, f30
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[30].f64) as f32) as f64);
	// 82A69868: EC0002B2  fmuls f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82A6986C: EC0002B2  fmuls f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82A69870: EC004B3A  fmadds f0, f0, f12, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[9].f64) as f32) as f64);
	// 82A69874: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82A69878: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A6987C: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A69880: EC004028  fsubs f0, f0, f8
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[8].f64) as f32) as f64);
	// 82A69884: EC00437A  fmadds f0, f0, f13, f8
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[8].f64) as f32) as f64);
	// 82A69888: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A6988C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A69890: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A69894: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A69898: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A6989C: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A698A0: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A698A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A698A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A698AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A698B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A698B0 size=136
    let mut pc: u32 = 0x82A698B0;
    'dispatch: loop {
        match pc {
            0x82A698B0 => {
    //   block [0x82A698B0..0x82A69938)
	// 82A698B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A698B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A698B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A698BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A698C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A698C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A698C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A698CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A698D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A698D4: 4BAA5BF5  bl 0x8250f4c8
	ctx.lr = 0x82A698D8;
	sub_8250F4C8(ctx, base);
	// 82A698D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A698DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A698E0: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A698E4: 409A0008  bne cr6, 0x82a698ec
	if !ctx.cr[6].eq {
	pc = 0x82A698EC; continue 'dispatch;
	}
	// 82A698E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A698EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A698F0: 4BAA1061  bl 0x8250a950
	ctx.lr = 0x82A698F4;
	sub_8250A950(ctx, base);
	// 82A698F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A698F8: 48388399  bl 0x82df1c90
	ctx.lr = 0x82A698FC;
	sub_82DF1C90(ctx, base);
	// 82A698FC: 397E0034  addi r11, r30, 0x34
	ctx.r[11].s64 = ctx.r[30].s64 + 52;
	// 82A69900: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A69904: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82A69908: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6990C: 419A000C  beq cr6, 0x82a69918
	if ctx.cr[6].eq {
	pc = 0x82A69918; continue 'dispatch;
	}
	// 82A69910: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A69914: 48417E2D  bl 0x82e81740
	ctx.lr = 0x82A69918;
	sub_82E81740(ctx, base);
	// 82A69918: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6991C: 48388375  bl 0x82df1c90
	ctx.lr = 0x82A69920;
	sub_82DF1C90(ctx, base);
	// 82A69920: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A69924: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A69928: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6992C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A69930: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A69934: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A69938 size=132
    let mut pc: u32 = 0x82A69938;
    'dispatch: loop {
        match pc {
            0x82A69938 => {
    //   block [0x82A69938..0x82A699BC)
	// 82A69938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6993C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A69940: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A69944: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A69948: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6994C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A69950: 817F016C  lwz r11, 0x16c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 82A69954: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A69958: 419A004C  beq cr6, 0x82a699a4
	if ctx.cr[6].eq {
	pc = 0x82A699A4; continue 'dispatch;
	}
	// 82A6995C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A69960: 39400150  li r10, 0x150
	ctx.r[10].s64 = 336;
	// 82A69964: 3BCB6910  addi r30, r11, 0x6910
	ctx.r[30].s64 = ctx.r[11].s64 + 26896;
	// 82A69968: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A6996C: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A699C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A699C0 size=72
    let mut pc: u32 = 0x82A699C0;
    'dispatch: loop {
        match pc {
            0x82A699C0 => {
    //   block [0x82A699C0..0x82A69A08)
	// 82A699C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A699C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A699C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A699CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A699D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A699D4: 4BAA8115  bl 0x82511ae8
	ctx.lr = 0x82A699D8;
	sub_82511AE8(ctx, base);
	// 82A699D8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A699DC: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69A08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A69A08 size=68
    let mut pc: u32 = 0x82A69A08;
    'dispatch: loop {
        match pc {
            0x82A69A08 => {
    //   block [0x82A69A08..0x82A69A4C)
	// 82A69A08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A69A0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A69A10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A69A14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A69A18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A69A1C: 809F0248  lwz r4, 0x248(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(584 as u32) ) } as u64;
	// 82A69A20: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82A69A24: 419A0014  beq cr6, 0x82a69a38
	if ctx.cr[6].eq {
	pc = 0x82A69A38; continue 'dispatch;
	}
	// 82A69A28: 807F02AC  lwz r3, 0x2ac(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(684 as u32) ) } as u64;
	// 82A69A2C: 4801768D  bl 0x82a810b8
	ctx.lr = 0x82A69A30;
	sub_82A810B8(ctx, base);
	// 82A69A30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A69A34: 917F0248  stw r11, 0x248(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), ctx.r[11].u32 ) };
	// 82A69A38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A69A3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A69A40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A69A44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A69A48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A69A50 size=112
    let mut pc: u32 = 0x82A69A50;
    'dispatch: loop {
        match pc {
            0x82A69A50 => {
    //   block [0x82A69A50..0x82A69AC0)
	// 82A69A50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A69A54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A69A58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A69A5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A69A60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A69A64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A69A68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A69A6C: 4BA8101D  bl 0x824eaa88
	ctx.lr = 0x82A69A70;
	sub_824EAA88(ctx, base);
	// 82A69A70: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A69A74: 4BA7FDDD  bl 0x824e9850
	ctx.lr = 0x82A69A78;
	sub_824E9850(ctx, base);
	// 82A69A78: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A69A7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A69A80: C00B0A98  lfs f0, 0xa98(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A69A84: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A69A88: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82A69A8C: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 82A69A90: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A69A94: 483881FD  bl 0x82df1c90
	ctx.lr = 0x82A69A98;
	sub_82DF1C90(ctx, base);
	// 82A69A98: 2B1F0008  cmplwi cr6, r31, 8
	ctx.cr[6].compare_u32(ctx.r[31].u32, 8 as u32, &mut ctx.xer);
	// 82A69A9C: 41980008  blt cr6, 0x82a69aa4
	if ctx.cr[6].lt {
	pc = 0x82A69AA4; continue 'dispatch;
	}
	// 82A69AA0: 3BE00007  li r31, 7
	ctx.r[31].s64 = 7;
	// 82A69AA4: 93FE024C  stw r31, 0x24c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(588 as u32), ctx.r[31].u32 ) };
	// 82A69AA8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A69AAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A69AB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A69AB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A69AB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A69ABC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69AC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A69AC0 size=236
    let mut pc: u32 = 0x82A69AC0;
    'dispatch: loop {
        match pc {
            0x82A69AC0 => {
    //   block [0x82A69AC0..0x82A69BAC)
	// 82A69AC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A69AC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A69AC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A69ACC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A69AD0: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82A69AD4: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A69AD8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A69ADC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A69AE0: 3FC0820B  lis r30, -0x7df5
	ctx.r[30].s64 = -2113208320;
	// 82A69AE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A69AE8: 397EFE60  addi r11, r30, -0x1a0
	ctx.r[11].s64 = ctx.r[30].s64 + -416;
	// 82A69AEC: C02BFFFC  lfs f1, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A69AF0: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82A69AF4: 4804490D  bl 0x82aae400
	ctx.lr = 0x82A69AF8;
	sub_82AAE400(ctx, base);
	// 82A69AF8: C01EFE60  lfs f0, -0x1a0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-416 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A69AFC: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82A69B00: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82A69B04: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 82A69B08: 480448F9  bl 0x82aae400
	ctx.lr = 0x82A69B0C;
	sub_82AAE400(ctx, base);
	// 82A69B0C: 387F02A0  addi r3, r31, 0x2a0
	ctx.r[3].s64 = ctx.r[31].s64 + 672;
	// 82A69B10: FC600890  fmr f3, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[1].f64;
	// 82A69B14: C03F029C  lfs f1, 0x29c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(668 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A69B18: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82A69B1C: 48044B55  bl 0x82aae670
	ctx.lr = 0x82A69B20;
	sub_82AAE670(ctx, base);
	// 82A69B20: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 82A69B24: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A69B28: 3909BA80  addi r8, r9, -0x4580
	ctx.r[8].s64 = ctx.r[9].s64 + -17792;
	// 82A69B2C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A69B30: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A69B34: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A69B38: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A69B3C: C00AF774  lfs f0, -0x88c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-2188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A69B40: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A69B44: C1A80004  lfs f13, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A69B48: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82A69B4C: C1880008  lfs f12, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A69B50: C168000C  lfs f11, 0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A69B54: D1810078  stfs f12, 0x78(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82A69B58: D161007C  stfs f11, 0x7c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82A69B5C: C1BF02A0  lfs f13, 0x2a0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(672 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A69B60: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A69B64: C009BA80  lfs f0, -0x4580(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17792 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A69B68: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82A69B6C: FC00681E  fctiwz f0, f13
	ctx.f[0].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 82A69B70: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82A69B74: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A69B78: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A69B7C: 48044705  bl 0x82aae280
	ctx.lr = 0x82A69B80;
	sub_82AAE280(ctx, base);
	// 82A69B80: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A69B84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A69B88: 4BAA7F69  bl 0x82511af0
	ctx.lr = 0x82A69B8C;
	sub_82511AF0(ctx, base);
	// 82A69B8C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A69B90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A69B94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A69B98: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A69B9C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A69BA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A69BA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A69BA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69BB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A69BB0 size=76
    let mut pc: u32 = 0x82A69BB0;
    'dispatch: loop {
        match pc {
            0x82A69BB0 => {
    //   block [0x82A69BB0..0x82A69BFC)
	// 82A69BB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A69BB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A69BB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A69BBC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A69BC0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A69BC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A69BC8: 483EC801  bl 0x82e563c8
	ctx.lr = 0x82A69BCC;
	sub_82E563C8(ctx, base);
	// 82A69BCC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A69BD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A69BD4: 4BAA5F6D  bl 0x8250fb40
	ctx.lr = 0x82A69BD8;
	sub_8250FB40(ctx, base);
	// 82A69BD8: 807F02AC  lwz r3, 0x2ac(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(684 as u32) ) } as u64;
	// 82A69BDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A69BE0: 419A0008  beq cr6, 0x82a69be8
	if ctx.cr[6].eq {
	pc = 0x82A69BE8; continue 'dispatch;
	}
	// 82A69BE4: 4801746D  bl 0x82a81050
	ctx.lr = 0x82A69BE8;
	sub_82A81050(ctx, base);
	// 82A69BE8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A69BEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A69BF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A69BF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A69BF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A69C00 size=236
    let mut pc: u32 = 0x82A69C00;
    'dispatch: loop {
        match pc {
            0x82A69C00 => {
    //   block [0x82A69C00..0x82A69CEC)
	// 82A69C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A69C04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A69C08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A69C0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A69C10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A69C14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A69C18: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A69C1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A69C20: 4BAA5711  bl 0x8250f330
	ctx.lr = 0x82A69C24;
	sub_8250F330(ctx, base);
	// 82A69C24: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A69C28: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A69C2C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A69C30: 4BA81529  bl 0x824eb158
	ctx.lr = 0x82A69C34;
	sub_824EB158(ctx, base);
	// 82A69C34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A69C38: 48388059  bl 0x82df1c90
	ctx.lr = 0x82A69C3C;
	sub_82DF1C90(ctx, base);
	// 82A69C3C: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82A69C40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A69C44: 388B57F4  addi r4, r11, 0x57f4
	ctx.r[4].s64 = ctx.r[11].s64 + 22516;
	// 82A69C48: 48389DC1  bl 0x82df3a08
	ctx.lr = 0x82A69C4C;
	sub_82DF3A08(ctx, base);
	// 82A69C4C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A69C50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A69C54: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A69C58: 409A000C  bne cr6, 0x82a69c64
	if !ctx.cr[6].eq {
	pc = 0x82A69C64; continue 'dispatch;
	}
	// 82A69C5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A69C60: 419A000C  beq cr6, 0x82a69c6c
	if ctx.cr[6].eq {
	pc = 0x82A69C6C; continue 'dispatch;
	}
	// 82A69C64: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82A69C68: 48000008  b 0x82a69c70
	pc = 0x82A69C70; continue 'dispatch;
	// 82A69C6C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A69C70: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A69C74: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A69C78: 4BA97801  bl 0x82501478
	ctx.lr = 0x82A69C7C;
	sub_82501478(ctx, base);
	// 82A69C7C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A69C80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A69C84: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A69C88: 4BA96261  bl 0x824ffee8
	ctx.lr = 0x82A69C8C;
	sub_824FFEE8(ctx, base);
	// 82A69C8C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A69C90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A69C94: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 82A69C98: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82A69C9C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82A69CA0: 697F0001  xori r31, r11, 1
	ctx.r[31].u64 = ctx.r[11].u64 ^ 1;
	// 82A69CA4: 48389785  bl 0x82df3428
	ctx.lr = 0x82A69CA8;
	sub_82DF3428(ctx, base);
	// 82A69CA8: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A69CAC: 41820038  beq 0x82a69ce4
	if ctx.cr[0].eq {
	pc = 0x82A69CE4; continue 'dispatch;
	}
	// 82A69CB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A69CB4: 4BFFFEFD  bl 0x82a69bb0
	ctx.lr = 0x82A69CB8;
	sub_82A69BB0(ctx, base);
	// 82A69CB8: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82A69CBC: 9BFE0298  stb r31, 0x298(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(664 as u32), ctx.r[31].u8 ) };
	// 82A69CC0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A69CC4: 48387FCD  bl 0x82df1c90
	ctx.lr = 0x82A69CC8;
	sub_82DF1C90(ctx, base);
	// 82A69CC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A69CCC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A69CD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A69CD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A69CD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A69CDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A69CE0: 4E800020  blr
	return;
	// 82A69CE4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A69CE8: 4BFFFFD8  b 0x82a69cc0
	pc = 0x82A69CC0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A69CF0 size=196
    let mut pc: u32 = 0x82A69CF0;
    'dispatch: loop {
        match pc {
            0x82A69CF0 => {
    //   block [0x82A69CF0..0x82A69DB4)
	// 82A69CF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A69CF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A69CF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A69CFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A69D00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A69D04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A69D08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A69D0C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A69D10: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A69D14: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A69D18: 4B856C21  bl 0x822c0938
	ctx.lr = 0x82A69D1C;
	sub_822C0938(ctx, base);
	// 82A69D1C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A69D20: 41820028  beq 0x82a69d48
	if ctx.cr[0].eq {
	pc = 0x82A69D48; continue 'dispatch;
	}
	// 82A69D24: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A69D28: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A69D2C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A69D30: 392BFF34  addi r9, r11, -0xcc
	ctx.r[9].s64 = ctx.r[11].s64 + -204;
	// 82A69D34: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A69D38: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A69D3C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A69D40: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A69D44: 48000008  b 0x82a69d4c
	pc = 0x82A69D4C; continue 'dispatch;
	// 82A69D48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A69D4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A69D50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A69D54: 409A0044  bne cr6, 0x82a69d98
	if !ctx.cr[6].eq {
	pc = 0x82A69D98; continue 'dispatch;
	}
	// 82A69D58: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A69D5C: 419A001C  beq cr6, 0x82a69d78
	if ctx.cr[6].eq {
	pc = 0x82A69D78; continue 'dispatch;
	}
	// 82A69D60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A69D64: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A69D68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A69D6C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A69D70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A69D74: 4E800421  bctrl
	ctx.lr = 0x82A69D78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A69D78: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A69D7C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A69D80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A69D84: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A69D88: 816B7034  lwz r11, 0x7034(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28724 as u32) ) } as u64;
	// 82A69D8C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A69D90: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A69D94: 4B85626D  bl 0x822c0000
	ctx.lr = 0x82A69D98;
	sub_822C0000(ctx, base);
	// 82A69D98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A69D9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A69DA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A69DA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A69DA8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A69DAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A69DB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A69DB8 size=196
    let mut pc: u32 = 0x82A69DB8;
    'dispatch: loop {
        match pc {
            0x82A69DB8 => {
    //   block [0x82A69DB8..0x82A69E7C)
	// 82A69DB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A69DBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A69DC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A69DC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A69DC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A69DCC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A69DD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A69DD4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A69DD8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A69DDC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A69DE0: 4B856B59  bl 0x822c0938
	ctx.lr = 0x82A69DE4;
	sub_822C0938(ctx, base);
	// 82A69DE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A69DE8: 41820028  beq 0x82a69e10
	if ctx.cr[0].eq {
	pc = 0x82A69E10; continue 'dispatch;
	}
	// 82A69DEC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A69DF0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A69DF4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A69DF8: 392BFF48  addi r9, r11, -0xb8
	ctx.r[9].s64 = ctx.r[11].s64 + -184;
	// 82A69DFC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A69E00: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A69E04: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A69E08: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A69E0C: 48000008  b 0x82a69e14
	pc = 0x82A69E14; continue 'dispatch;
	// 82A69E10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A69E14: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A69E18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A69E1C: 409A0044  bne cr6, 0x82a69e60
	if !ctx.cr[6].eq {
	pc = 0x82A69E60; continue 'dispatch;
	}
	// 82A69E20: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A69E24: 419A001C  beq cr6, 0x82a69e40
	if ctx.cr[6].eq {
	pc = 0x82A69E40; continue 'dispatch;
	}
	// 82A69E28: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A69E2C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A69E30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A69E34: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A69E38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A69E3C: 4E800421  bctrl
	ctx.lr = 0x82A69E40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A69E40: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A69E44: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A69E48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A69E4C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A69E50: 816B7034  lwz r11, 0x7034(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28724 as u32) ) } as u64;
	// 82A69E54: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A69E58: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A69E5C: 4B8561A5  bl 0x822c0000
	ctx.lr = 0x82A69E60;
	sub_822C0000(ctx, base);
	// 82A69E60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A69E64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A69E68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A69E6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A69E70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A69E74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A69E78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69E80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A69E80 size=196
    let mut pc: u32 = 0x82A69E80;
    'dispatch: loop {
        match pc {
            0x82A69E80 => {
    //   block [0x82A69E80..0x82A69F44)
	// 82A69E80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A69E84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A69E88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A69E8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A69E90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A69E94: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A69E98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A69E9C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A69EA0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A69EA4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A69EA8: 4B856A91  bl 0x822c0938
	ctx.lr = 0x82A69EAC;
	sub_822C0938(ctx, base);
	// 82A69EAC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A69EB0: 41820028  beq 0x82a69ed8
	if ctx.cr[0].eq {
	pc = 0x82A69ED8; continue 'dispatch;
	}
	// 82A69EB4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A69EB8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A69EBC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A69EC0: 392BFF5C  addi r9, r11, -0xa4
	ctx.r[9].s64 = ctx.r[11].s64 + -164;
	// 82A69EC4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A69EC8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A69ECC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A69ED0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A69ED4: 48000008  b 0x82a69edc
	pc = 0x82A69EDC; continue 'dispatch;
	// 82A69ED8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A69EDC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A69EE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A69EE4: 409A0044  bne cr6, 0x82a69f28
	if !ctx.cr[6].eq {
	pc = 0x82A69F28; continue 'dispatch;
	}
	// 82A69EE8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A69EEC: 419A001C  beq cr6, 0x82a69f08
	if ctx.cr[6].eq {
	pc = 0x82A69F08; continue 'dispatch;
	}
	// 82A69EF0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A69EF4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A69EF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A69EFC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A69F00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A69F04: 4E800421  bctrl
	ctx.lr = 0x82A69F08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A69F08: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A69F0C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A69F10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A69F14: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A69F18: 816B7034  lwz r11, 0x7034(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28724 as u32) ) } as u64;
	// 82A69F1C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A69F20: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A69F24: 4B8560DD  bl 0x822c0000
	ctx.lr = 0x82A69F28;
	sub_822C0000(ctx, base);
	// 82A69F28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A69F2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A69F30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A69F34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A69F38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A69F3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A69F40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A69F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A69F48 size=196
    let mut pc: u32 = 0x82A69F48;
    'dispatch: loop {
        match pc {
            0x82A69F48 => {
    //   block [0x82A69F48..0x82A6A00C)
	// 82A69F48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A69F4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A69F50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A69F54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A69F58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A69F5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A69F60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A69F64: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A69F68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A69F6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A69F70: 4B8569C9  bl 0x822c0938
	ctx.lr = 0x82A69F74;
	sub_822C0938(ctx, base);
	// 82A69F74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A69F78: 41820028  beq 0x82a69fa0
	if ctx.cr[0].eq {
	pc = 0x82A69FA0; continue 'dispatch;
	}
	// 82A69F7C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A69F80: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A69F84: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A69F88: 392BFF70  addi r9, r11, -0x90
	ctx.r[9].s64 = ctx.r[11].s64 + -144;
	// 82A69F8C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A69F90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A69F94: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A69F98: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A69F9C: 48000008  b 0x82a69fa4
	pc = 0x82A69FA4; continue 'dispatch;
	// 82A69FA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A69FA4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A69FA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A69FAC: 409A0044  bne cr6, 0x82a69ff0
	if !ctx.cr[6].eq {
	pc = 0x82A69FF0; continue 'dispatch;
	}
	// 82A69FB0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A69FB4: 419A001C  beq cr6, 0x82a69fd0
	if ctx.cr[6].eq {
	pc = 0x82A69FD0; continue 'dispatch;
	}
	// 82A69FB8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A69FBC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A69FC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A69FC4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A69FC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A69FCC: 4E800421  bctrl
	ctx.lr = 0x82A69FD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A69FD0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A69FD4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A69FD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A69FDC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A69FE0: 816B7034  lwz r11, 0x7034(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28724 as u32) ) } as u64;
	// 82A69FE4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A69FE8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A69FEC: 4B856015  bl 0x822c0000
	ctx.lr = 0x82A69FF0;
	sub_822C0000(ctx, base);
	// 82A69FF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A69FF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A69FF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A69FFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6A000: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6A004: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6A008: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6A010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6A010 size=196
    let mut pc: u32 = 0x82A6A010;
    'dispatch: loop {
        match pc {
            0x82A6A010 => {
    //   block [0x82A6A010..0x82A6A0D4)
	// 82A6A010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6A014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6A018: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6A01C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6A020: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6A024: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A6A028: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A6A02C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A6A030: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A6A034: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A6A038: 4B856901  bl 0x822c0938
	ctx.lr = 0x82A6A03C;
	sub_822C0938(ctx, base);
	// 82A6A03C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A6A040: 41820028  beq 0x82a6a068
	if ctx.cr[0].eq {
	pc = 0x82A6A068; continue 'dispatch;
	}
	// 82A6A044: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6A048: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A6A04C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A6A050: 392BFF84  addi r9, r11, -0x7c
	ctx.r[9].s64 = ctx.r[11].s64 + -124;
	// 82A6A054: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A6A058: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A6A05C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A6A060: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A6A064: 48000008  b 0x82a6a06c
	pc = 0x82A6A06C; continue 'dispatch;
	// 82A6A068: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A6A06C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A6A070: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6A074: 409A0044  bne cr6, 0x82a6a0b8
	if !ctx.cr[6].eq {
	pc = 0x82A6A0B8; continue 'dispatch;
	}
	// 82A6A078: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A6A07C: 419A001C  beq cr6, 0x82a6a098
	if ctx.cr[6].eq {
	pc = 0x82A6A098; continue 'dispatch;
	}
	// 82A6A080: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6A084: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A6A088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6A08C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6A090: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A6A094: 4E800421  bctrl
	ctx.lr = 0x82A6A098;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A6A098: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6A09C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A6A0A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6A0A4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A6A0A8: 816B7034  lwz r11, 0x7034(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28724 as u32) ) } as u64;
	// 82A6A0AC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A6A0B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A6A0B4: 4B855F4D  bl 0x822c0000
	ctx.lr = 0x82A6A0B8;
	sub_822C0000(ctx, base);
	// 82A6A0B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6A0BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6A0C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6A0C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6A0C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6A0CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6A0D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6A0D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6A0D8 size=196
    let mut pc: u32 = 0x82A6A0D8;
    'dispatch: loop {
        match pc {
            0x82A6A0D8 => {
    //   block [0x82A6A0D8..0x82A6A19C)
	// 82A6A0D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6A0DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6A0E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6A0E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6A0E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6A0EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A6A0F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A6A0F4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A6A0F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A6A0FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A6A100: 4B856839  bl 0x822c0938
	ctx.lr = 0x82A6A104;
	sub_822C0938(ctx, base);
	// 82A6A104: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A6A108: 41820028  beq 0x82a6a130
	if ctx.cr[0].eq {
	pc = 0x82A6A130; continue 'dispatch;
	}
	// 82A6A10C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6A110: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A6A114: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A6A118: 392BFF98  addi r9, r11, -0x68
	ctx.r[9].s64 = ctx.r[11].s64 + -104;
	// 82A6A11C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A6A120: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A6A124: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A6A128: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A6A12C: 48000008  b 0x82a6a134
	pc = 0x82A6A134; continue 'dispatch;
	// 82A6A130: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A6A134: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A6A138: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6A13C: 409A0044  bne cr6, 0x82a6a180
	if !ctx.cr[6].eq {
	pc = 0x82A6A180; continue 'dispatch;
	}
	// 82A6A140: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A6A144: 419A001C  beq cr6, 0x82a6a160
	if ctx.cr[6].eq {
	pc = 0x82A6A160; continue 'dispatch;
	}
	// 82A6A148: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6A14C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A6A150: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6A154: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6A158: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A6A15C: 4E800421  bctrl
	ctx.lr = 0x82A6A160;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A6A160: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6A164: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A6A168: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6A16C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A6A170: 816B7034  lwz r11, 0x7034(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28724 as u32) ) } as u64;
	// 82A6A174: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A6A178: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A6A17C: 4B855E85  bl 0x822c0000
	ctx.lr = 0x82A6A180;
	sub_822C0000(ctx, base);
	// 82A6A180: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6A184: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6A188: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6A18C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6A190: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6A194: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6A198: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6A1A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6A1A0 size=196
    let mut pc: u32 = 0x82A6A1A0;
    'dispatch: loop {
        match pc {
            0x82A6A1A0 => {
    //   block [0x82A6A1A0..0x82A6A264)
	// 82A6A1A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6A1A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6A1A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6A1AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6A1B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6A1B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A6A1B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A6A1BC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A6A1C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A6A1C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A6A1C8: 4B856771  bl 0x822c0938
	ctx.lr = 0x82A6A1CC;
	sub_822C0938(ctx, base);
	// 82A6A1CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A6A1D0: 41820028  beq 0x82a6a1f8
	if ctx.cr[0].eq {
	pc = 0x82A6A1F8; continue 'dispatch;
	}
	// 82A6A1D4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6A1D8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A6A1DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A6A1E0: 392BFFAC  addi r9, r11, -0x54
	ctx.r[9].s64 = ctx.r[11].s64 + -84;
	// 82A6A1E4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A6A1E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A6A1EC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A6A1F0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A6A1F4: 48000008  b 0x82a6a1fc
	pc = 0x82A6A1FC; continue 'dispatch;
	// 82A6A1F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A6A1FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A6A200: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6A204: 409A0044  bne cr6, 0x82a6a248
	if !ctx.cr[6].eq {
	pc = 0x82A6A248; continue 'dispatch;
	}
	// 82A6A208: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A6A20C: 419A001C  beq cr6, 0x82a6a228
	if ctx.cr[6].eq {
	pc = 0x82A6A228; continue 'dispatch;
	}
	// 82A6A210: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6A214: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A6A218: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6A21C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6A220: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A6A224: 4E800421  bctrl
	ctx.lr = 0x82A6A228;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A6A228: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6A22C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A6A230: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6A234: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A6A238: 816B7034  lwz r11, 0x7034(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28724 as u32) ) } as u64;
	// 82A6A23C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A6A240: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A6A244: 4B855DBD  bl 0x822c0000
	ctx.lr = 0x82A6A248;
	sub_822C0000(ctx, base);
	// 82A6A248: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6A24C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6A250: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6A254: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6A258: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6A25C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6A260: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6A268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6A268 size=112
    let mut pc: u32 = 0x82A6A268;
    'dispatch: loop {
        match pc {
            0x82A6A268 => {
    //   block [0x82A6A268..0x82A6A2D8)
	// 82A6A268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6A26C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6A270: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6A274: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6A278: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A6A27C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6A280: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6A284: 388B6C90  addi r4, r11, 0x6c90
	ctx.r[4].s64 = ctx.r[11].s64 + 27792;
	// 82A6A288: 48389781  bl 0x82df3a08
	ctx.lr = 0x82A6A28C;
	sub_82DF3A08(ctx, base);
	// 82A6A28C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A6A290: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A6A294: 809F00EC  lwz r4, 0xec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A6A298: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6A29C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A6A2A0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A6A2A4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A6A2A8: 483F46B9  bl 0x82e5e960
	ctx.lr = 0x82A6A2AC;
	sub_82E5E960(ctx, base);
	// 82A6A2AC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6A2B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6A2B4: 419A0008  beq cr6, 0x82a6a2bc
	if ctx.cr[6].eq {
	pc = 0x82A6A2BC; continue 'dispatch;
	}
	// 82A6A2B8: 4B8565D9  bl 0x822c0890
	ctx.lr = 0x82A6A2BC;
	sub_822C0890(ctx, base);
	// 82A6A2BC: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82A6A2C0: 917F01F8  stw r11, 0x1f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), ctx.r[11].u32 ) };
	// 82A6A2C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6A2C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6A2CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6A2D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6A2D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6A2D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6A2D8 size=424
    let mut pc: u32 = 0x82A6A2D8;
    'dispatch: loop {
        match pc {
            0x82A6A2D8 => {
    //   block [0x82A6A2D8..0x82A6A480)
	// 82A6A2D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6A2DC: 4873DE89  bl 0x831a8164
	ctx.lr = 0x82A6A2E0;
	sub_831A8130(ctx, base);
	// 82A6A2E0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6A2E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6A2E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A6A2EC: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82A6A2F0: 4BDA8189  bl 0x82812478
	ctx.lr = 0x82A6A2F4;
	sub_82812478(ctx, base);
	// 82A6A2F4: 83830004  lwz r28, 4(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6A2F8: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6A2FC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A6A300: 419A0024  beq cr6, 0x82a6a324
	if ctx.cr[6].eq {
	pc = 0x82A6A324; continue 'dispatch;
	}
	// 82A6A304: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 82A6A308: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6A30C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6A310: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6A314: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6A318: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6A31C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6A320: 4082FFE8  bne 0x82a6a308
	if !ctx.cr[0].eq {
	pc = 0x82A6A308; continue 'dispatch;
	}
	// 82A6A324: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6A328: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6A32C: 388BFFBC  addi r4, r11, -0x44
	ctx.r[4].s64 = ctx.r[11].s64 + -68;
	// 82A6A330: 483896D9  bl 0x82df3a08
	ctx.lr = 0x82A6A334;
	sub_82DF3A08(ctx, base);
	// 82A6A334: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A6A338: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A6A33C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6A340: 483AACF1  bl 0x82e15030
	ctx.lr = 0x82A6A344;
	sub_82E15030(ctx, base);
	// 82A6A344: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6A348: 483890E1  bl 0x82df3428
	ctx.lr = 0x82A6A34C;
	sub_82DF3428(ctx, base);
	// 82A6A34C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6A350: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A6A354: 4BAA7795  bl 0x82511ae8
	ctx.lr = 0x82A6A358;
	sub_82511AE8(ctx, base);
	// 82A6A358: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6A35C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A6A360: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A6A364: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A6A368: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A6A36C: 4E800421  bctrl
	ctx.lr = 0x82A6A370;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A6A370: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A6A374: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82A6A378: 13E0D8C7  vcmpequd (lvx128) v31, v0, v27
	tmp.u32 = ctx.r[27].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A6A37C: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82A6A380: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 82A6A384: 397F0230  addi r11, r31, 0x230
	ctx.r[11].s64 = ctx.r[31].s64 + 560;
	// 82A6A388: C00AFE58  lfs f0, -0x1a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-424 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6A38C: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 82A6A390: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A6A394: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82A6A398: 13C04C07  vcmpneb. (lvlx128) v30, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A6A39C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6A3A0: C0080030  lfs f0, 0x30(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6A3A4: C1A80034  lfs f13, 0x34(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A6A3A8: C1880038  lfs f12, 0x38(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A6A3AC: C168003C  lfs f11, 0x3c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A6A3B0: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82A6A3B4: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82A6A3B8: D1810088  stfs f12, 0x88(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82A6A3BC: D161008C  stfs f11, 0x8c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82A6A3C0: 13A038C7  vcmpequd (lvx128) v29, v0, v7
	tmp.u32 = ctx.r[7].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6A480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6A480 size=96
    let mut pc: u32 = 0x82A6A480;
    'dispatch: loop {
        match pc {
            0x82A6A480 => {
    //   block [0x82A6A480..0x82A6A4E0)
	// 82A6A480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6A484: 4873DCE9  bl 0x831a816c
	ctx.lr = 0x82A6A488;
	sub_831A8130(ctx, base);
	// 82A6A488: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6A48C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A6A490: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82A6A494: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82A6A498: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A6A49C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6A4A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6A4A4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A6A4A8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6A4E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6A4E0 size=132
    let mut pc: u32 = 0x82A6A4E0;
    'dispatch: loop {
        match pc {
            0x82A6A4E0 => {
    //   block [0x82A6A4E0..0x82A6A564)
	// 82A6A4E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6A4E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6A4E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6A4EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6A4F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6A4F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6A4F8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A6A4FC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6A500: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6A504: 388BE848  addi r4, r11, -0x17b8
	ctx.r[4].s64 = ctx.r[11].s64 + -6072;
	// 82A6A508: 9BDF01F4  stb r30, 0x1f4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(500 as u32), ctx.r[30].u8 ) };
	// 82A6A50C: 483894FD  bl 0x82df3a08
	ctx.lr = 0x82A6A510;
	sub_82DF3A08(ctx, base);
	// 82A6A510: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A6A514: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A6A518: 809F00EC  lwz r4, 0xec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A6A51C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6A520: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A6A524: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A6A528: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A6A52C: 483F4435  bl 0x82e5e960
	ctx.lr = 0x82A6A530;
	sub_82E5E960(ctx, base);
	// 82A6A530: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6A534: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6A538: 419A0008  beq cr6, 0x82a6a540
	if ctx.cr[6].eq {
	pc = 0x82A6A540; continue 'dispatch;
	}
	// 82A6A53C: 4B856355  bl 0x822c0890
	ctx.lr = 0x82A6A540;
	sub_822C0890(ctx, base);
	// 82A6A540: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82A6A544: 9BDF0220  stb r30, 0x220(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(544 as u32), ctx.r[30].u8 ) };
	// 82A6A548: 917F01F8  stw r11, 0x1f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), ctx.r[11].u32 ) };
	// 82A6A54C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A6A550: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6A554: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6A558: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6A55C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6A560: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6A568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A6A568 size=160
    let mut pc: u32 = 0x82A6A568;
    'dispatch: loop {
        match pc {
            0x82A6A568 => {
    //   block [0x82A6A568..0x82A6A608)
	// 82A6A568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6A56C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6A570: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6A574: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6A578: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6A608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6A608 size=124
    let mut pc: u32 = 0x82A6A608;
    'dispatch: loop {
        match pc {
            0x82A6A608 => {
    //   block [0x82A6A608..0x82A6A684)
	// 82A6A608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6A60C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6A610: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6A614: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6A618: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6A61C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A6A620: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6A624: 4BA80465  bl 0x824eaa88
	ctx.lr = 0x82A6A628;
	sub_824EAA88(ctx, base);
	// 82A6A628: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6A62C: 4BA7F225  bl 0x824e9850
	ctx.lr = 0x82A6A630;
	sub_824E9850(ctx, base);
	// 82A6A630: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A6A634: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82A6A638: C00B9450  lfs f0, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6A63C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82A6A640: 41990008  bgt cr6, 0x82a6a648
	if ctx.cr[6].gt {
	pc = 0x82A6A648; continue 'dispatch;
	}
	// 82A6A644: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A6A648: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6A64C: 48387645  bl 0x82df1c90
	ctx.lr = 0x82A6A650;
	sub_82DF1C90(ctx, base);
	// 82A6A650: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6A654: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82A6A658: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6A65C: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 82A6A660: 40820008  bne 0x82a6a668
	if !ctx.cr[0].eq {
	pc = 0x82A6A668; continue 'dispatch;
	}
	// 82A6A664: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 82A6A668: 4BFFFE19  bl 0x82a6a480
	ctx.lr = 0x82A6A66C;
	sub_82A6A480(ctx, base);
	// 82A6A66C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6A670: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6A674: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6A678: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6A67C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6A680: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6A688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6A688 size=68
    let mut pc: u32 = 0x82A6A688;
    'dispatch: loop {
        match pc {
            0x82A6A688 => {
    //   block [0x82A6A688..0x82A6A6CC)
	// 82A6A688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6A68C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6A690: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6A694: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6A698: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6A69C: 817F0248  lwz r11, 0x248(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(584 as u32) ) } as u64;
	// 82A6A6A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6A6A4: 409A0014  bne cr6, 0x82a6a6b8
	if !ctx.cr[6].eq {
	pc = 0x82A6A6B8; continue 'dispatch;
	}
	// 82A6A6A8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A6A6AC: 38800016  li r4, 0x16
	ctx.r[4].s64 = 22;
	// 82A6A6B0: 4BFFFDD1  bl 0x82a6a480
	ctx.lr = 0x82A6A6B4;
	sub_82A6A480(ctx, base);
	// 82A6A6B4: 907F0248  stw r3, 0x248(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), ctx.r[3].u32 ) };
	// 82A6A6B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A6A6BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6A6C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6A6C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6A6C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6A6D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A6A6D0 size=12
    let mut pc: u32 = 0x82A6A6D0;
    'dispatch: loop {
        match pc {
            0x82A6A6D0 => {
    //   block [0x82A6A6D0..0x82A6A6DC)
	// 82A6A6D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A6A6D4: 99630298  stb r11, 0x298(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(664 as u32), ctx.r[11].u8 ) };
	// 82A6A6D8: 4BFFF4D8  b 0x82a69bb0
	sub_82A69BB0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6A6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6A6E0 size=72
    let mut pc: u32 = 0x82A6A6E0;
    'dispatch: loop {
        match pc {
            0x82A6A6E0 => {
    //   block [0x82A6A6E0..0x82A6A728)
	// 82A6A6E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6A6E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6A6E8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6A6EC: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82A6A6F0: 419A001C  beq cr6, 0x82a6a70c
	if ctx.cr[6].eq {
	pc = 0x82A6A70C; continue 'dispatch;
	}
	// 82A6A6F4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A6A6F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A6A6FC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82A6A700: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A6A704: 4BFFEF25  bl 0x82a69628
	ctx.lr = 0x82A6A708;
	sub_82A69628(ctx, base);
	// 82A6A708: 48000010  b 0x82a6a718
	pc = 0x82A6A718; continue 'dispatch;
	// 82A6A70C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6A710: 396B7290  addi r11, r11, 0x7290
	ctx.r[11].s64 = ctx.r[11].s64 + 29328;
	// 82A6A714: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A6A718: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A6A71C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6A720: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6A724: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6A728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6A728 size=84
    let mut pc: u32 = 0x82A6A728;
    'dispatch: loop {
        match pc {
            0x82A6A728 => {
    //   block [0x82A6A728..0x82A6A77C)
	// 82A6A728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6A72C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6A730: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6A734: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6A738: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6A73C: 39630040  addi r11, r3, 0x40
	ctx.r[11].s64 = ctx.r[3].s64 + 64;
	// 82A6A740: 3BC00007  li r30, 7
	ctx.r[30].s64 = 7;
	// 82A6A744: 3BEB0004  addi r31, r11, 4
	ctx.r[31].s64 = ctx.r[11].s64 + 4;
	// 82A6A748: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 82A6A74C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6A750: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6A754: 419A0008  beq cr6, 0x82a6a75c
	if ctx.cr[6].eq {
	pc = 0x82A6A75C; continue 'dispatch;
	}
	// 82A6A758: 4B856139  bl 0x822c0890
	ctx.lr = 0x82A6A75C;
	sub_822C0890(ctx, base);
	// 82A6A75C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A6A760: 4080FFE8  bge 0x82a6a748
	if !ctx.cr[0].lt {
	pc = 0x82A6A748; continue 'dispatch;
	}
	// 82A6A764: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6A768: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6A76C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6A770: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6A774: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6A778: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6A780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6A780 size=348
    let mut pc: u32 = 0x82A6A780;
    'dispatch: loop {
        match pc {
            0x82A6A780 => {
    //   block [0x82A6A780..0x82A6A8DC)
	// 82A6A780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6A784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6A788: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6A78C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6A790: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6A794: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6A798: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6A79C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A6A7A0: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A6A7A4: 396B002C  addi r11, r11, 0x2c
	ctx.r[11].s64 = ctx.r[11].s64 + 44;
	// 82A6A7A8: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A6A7AC: 394A0018  addi r10, r10, 0x18
	ctx.r[10].s64 = ctx.r[10].s64 + 24;
	// 82A6A7B0: 3929FFCC  addi r9, r9, -0x34
	ctx.r[9].s64 = ctx.r[9].s64 + -52;
	// 82A6A7B4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A6A7B8: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 82A6A7BC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82A6A7C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6A7C4: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 82A6A7C8: 419A0018  beq cr6, 0x82a6a7e0
	if ctx.cr[6].eq {
	pc = 0x82A6A7E0; continue 'dispatch;
	}
	// 82A6A7CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6A7D0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A6A7D4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6A7D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A6A7DC: 4E800421  bctrl
	ctx.lr = 0x82A6A7E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A6A7E0: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82A6A7E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6A7E8: 419A0018  beq cr6, 0x82a6a800
	if ctx.cr[6].eq {
	pc = 0x82A6A800; continue 'dispatch;
	}
	// 82A6A7EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6A7F0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A6A7F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6A7F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A6A7FC: 4E800421  bctrl
	ctx.lr = 0x82A6A800;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A6A800: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A6A804: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6A808: 419A0018  beq cr6, 0x82a6a820
	if ctx.cr[6].eq {
	pc = 0x82A6A820; continue 'dispatch;
	}
	// 82A6A80C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6A810: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A6A814: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6A818: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A6A81C: 4E800421  bctrl
	ctx.lr = 0x82A6A820;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A6A820: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A6A824: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A6A828: 916ADFF8  stw r11, -0x2008(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8200 as u32), ctx.r[11].u32 ) };
	// 82A6A82C: 807F02B8  lwz r3, 0x2b8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(696 as u32) ) } as u64;
	// 82A6A830: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6A834: 419A0008  beq cr6, 0x82a6a83c
	if ctx.cr[6].eq {
	pc = 0x82A6A83C; continue 'dispatch;
	}
	// 82A6A838: 4B856059  bl 0x822c0890
	ctx.lr = 0x82A6A83C;
	sub_822C0890(ctx, base);
	// 82A6A83C: 807F02B0  lwz r3, 0x2b0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(688 as u32) ) } as u64;
	// 82A6A840: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6A844: 419A0008  beq cr6, 0x82a6a84c
	if ctx.cr[6].eq {
	pc = 0x82A6A84C; continue 'dispatch;
	}
	// 82A6A848: 4B856049  bl 0x822c0890
	ctx.lr = 0x82A6A84C;
	sub_822C0890(ctx, base);
	// 82A6A84C: 807F02A8  lwz r3, 0x2a8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(680 as u32) ) } as u64;
	// 82A6A850: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6A854: 419A0008  beq cr6, 0x82a6a85c
	if ctx.cr[6].eq {
	pc = 0x82A6A85C; continue 'dispatch;
	}
	// 82A6A858: 4B856039  bl 0x822c0890
	ctx.lr = 0x82A6A85C;
	sub_822C0890(ctx, base);
	// 82A6A85C: 387F01A0  addi r3, r31, 0x1a0
	ctx.r[3].s64 = ctx.r[31].s64 + 416;
	// 82A6A860: 4BFFFEC9  bl 0x82a6a728
	ctx.lr = 0x82A6A864;
	sub_82A6A728(ctx, base);
	// 82A6A864: 807F0194  lwz r3, 0x194(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82A6A868: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6A86C: 419A0008  beq cr6, 0x82a6a874
	if ctx.cr[6].eq {
	pc = 0x82A6A874; continue 'dispatch;
	}
	// 82A6A870: 4B856021  bl 0x822c0890
	ctx.lr = 0x82A6A874;
	sub_822C0890(ctx, base);
	// 82A6A874: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82A6A878: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6A87C: 419A0008  beq cr6, 0x82a6a884
	if ctx.cr[6].eq {
	pc = 0x82A6A884; continue 'dispatch;
	}
	// 82A6A880: 4B856011  bl 0x822c0890
	ctx.lr = 0x82A6A884;
	sub_822C0890(ctx, base);
	// 82A6A884: 807F0170  lwz r3, 0x170(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82A6A888: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6A88C: 419A0008  beq cr6, 0x82a6a894
	if ctx.cr[6].eq {
	pc = 0x82A6A894; continue 'dispatch;
	}
	// 82A6A890: 4B856001  bl 0x822c0890
	ctx.lr = 0x82A6A894;
	sub_822C0890(ctx, base);
	// 82A6A894: 807F0168  lwz r3, 0x168(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82A6A898: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6A89C: 419A0008  beq cr6, 0x82a6a8a4
	if ctx.cr[6].eq {
	pc = 0x82A6A8A4; continue 'dispatch;
	}
	// 82A6A8A0: 4B855FF1  bl 0x822c0890
	ctx.lr = 0x82A6A8A4;
	sub_822C0890(ctx, base);
	// 82A6A8A4: 807F00FC  lwz r3, 0xfc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82A6A8A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6A8AC: 419A0008  beq cr6, 0x82a6a8b4
	if ctx.cr[6].eq {
	pc = 0x82A6A8B4; continue 'dispatch;
	}
	// 82A6A8B0: 4B855FE1  bl 0x822c0890
	ctx.lr = 0x82A6A8B4;
	sub_822C0890(ctx, base);
	// 82A6A8B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6A8B8: 4BD3CDA1  bl 0x827a7658
	ctx.lr = 0x82A6A8BC;
	sub_827A7658(ctx, base);
	// 82A6A8BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6A8C0: 4B8E4A91  bl 0x8234f350
	ctx.lr = 0x82A6A8C4;
	sub_8234F350(ctx, base);
	// 82A6A8C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6A8C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6A8CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6A8D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6A8D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6A8D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6A8E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A6A8E0 size=8
    let mut pc: u32 = 0x82A6A8E0;
    'dispatch: loop {
        match pc {
            0x82A6A8E0 => {
    //   block [0x82A6A8E0..0x82A6A8E8)
	// 82A6A8E0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82A6A8E4: 4800170C  b 0x82a6bff0
	sub_82A6BFF0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6A8E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A6A8E8 size=8
    let mut pc: u32 = 0x82A6A8E8;
    'dispatch: loop {
        match pc {
            0x82A6A8E8 => {
    //   block [0x82A6A8E8..0x82A6A8F0)
	// 82A6A8E8: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 82A6A8EC: 48001704  b 0x82a6bff0
	sub_82A6BFF0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6A8F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6A8F0 size=244
    let mut pc: u32 = 0x82A6A8F0;
    'dispatch: loop {
        match pc {
            0x82A6A8F0 => {
    //   block [0x82A6A8F0..0x82A6A9E4)
	// 82A6A8F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6A8F4: 4873D879  bl 0x831a816c
	ctx.lr = 0x82A6A8F8;
	sub_831A8130(ctx, base);
	// 82A6A8F8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6A8FC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6A900: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A6A904: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A6A908: 388B0068  addi r4, r11, 0x68
	ctx.r[4].s64 = ctx.r[11].s64 + 104;
	// 82A6A90C: 38A00139  li r5, 0x139
	ctx.r[5].s64 = 313;
	// 82A6A910: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 82A6A914: 48387AD5  bl 0x82df23e8
	ctx.lr = 0x82A6A918;
	sub_82DF23E8(ctx, base);
	// 82A6A918: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A6A91C: 41820010  beq 0x82a6a92c
	if ctx.cr[0].eq {
	pc = 0x82A6A92C; continue 'dispatch;
	}
	// 82A6A920: 4BEEA3D9  bl 0x82954cf8
	ctx.lr = 0x82A6A924;
	sub_82954CF8(ctx, base);
	// 82A6A924: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6A928: 48000008  b 0x82a6a930
	pc = 0x82A6A930; continue 'dispatch;
	// 82A6A92C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A6A930: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82A6A934: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6A938: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A6A93C: 4B9F32A5  bl 0x8245dbe0
	ctx.lr = 0x82A6A940;
	sub_8245DBE0(ctx, base);
	// 82A6A940: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A6A944: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6A948: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A6A94C: 4B8556B5  bl 0x822c0000
	ctx.lr = 0x82A6A950;
	sub_822C0000(ctx, base);
	// 82A6A950: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A6A954: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A6A958: 4BAA4B71  bl 0x8250f4c8
	ctx.lr = 0x82A6A95C;
	sub_8250F4C8(ctx, base);
	// 82A6A95C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6A960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6A964: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82A6A968: 409A0008  bne cr6, 0x82a6a970
	if !ctx.cr[6].eq {
	pc = 0x82A6A970; continue 'dispatch;
	}
	// 82A6A96C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A6A970: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A6A974: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A6A978: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 82A6A97C: 4BAA4B9D  bl 0x8250f518
	ctx.lr = 0x82A6A980;
	sub_8250F518(ctx, base);
	// 82A6A980: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A6A984: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6A988: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6A98C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A6A990: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A6A994: 4BAA2BFD  bl 0x8250d590
	ctx.lr = 0x82A6A998;
	sub_8250D590(ctx, base);
	// 82A6A998: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A6A99C: 483872F5  bl 0x82df1c90
	ctx.lr = 0x82A6A9A0;
	sub_82DF1C90(ctx, base);
	// 82A6A9A0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A6A9A4: 483872ED  bl 0x82df1c90
	ctx.lr = 0x82A6A9A8;
	sub_82DF1C90(ctx, base);
	// 82A6A9A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A6A9AC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6A9B0: 4BAA4B19  bl 0x8250f4c8
	ctx.lr = 0x82A6A9B4;
	sub_8250F4C8(ctx, base);
	// 82A6A9B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6A9B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6A9BC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A6A9C0: 409A0008  bne cr6, 0x82a6a9c8
	if !ctx.cr[6].eq {
	pc = 0x82A6A9C8; continue 'dispatch;
	}
	// 82A6A9C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A6A9C8: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82A6A9CC: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A6A9D0: 4BA9DC89  bl 0x82508658
	ctx.lr = 0x82A6A9D4;
	sub_82508658(ctx, base);
	// 82A6A9D4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6A9D8: 483872B9  bl 0x82df1c90
	ctx.lr = 0x82A6A9DC;
	sub_82DF1C90(ctx, base);
	// 82A6A9DC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A6A9E0: 4873D7DC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6A9E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6A9E8 size=588
    let mut pc: u32 = 0x82A6A9E8;
    'dispatch: loop {
        match pc {
            0x82A6A9E8 => {
    //   block [0x82A6A9E8..0x82A6AC34)
	// 82A6A9E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6A9EC: 4873D779  bl 0x831a8164
	ctx.lr = 0x82A6A9F0;
	sub_831A8130(ctx, base);
	// 82A6A9F0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A6A9F4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6A9F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6A9FC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A6AA00: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A6AA04: 3B6B6910  addi r27, r11, 0x6910
	ctx.r[27].s64 = ctx.r[11].s64 + 26896;
	// 82A6AA08: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A6AA0C: 39600110  li r11, 0x110
	ctx.r[11].s64 = 272;
	// 82A6AA10: 93DF00E8  stw r30, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[30].u32 ) };
	// 82A6AA14: 39200120  li r9, 0x120
	ctx.r[9].s64 = 288;
	// 82A6AA18: C00A7DD8  lfs f0, 0x7dd8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6AA1C: 39400140  li r10, 0x140
	ctx.r[10].s64 = 320;
	// 82A6AA20: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82A6AA24: 39000150  li r8, 0x150
	ctx.r[8].s64 = 336;
	// 82A6AA28: 13E0D8C7  vcmpequd (lvx128) v31, v0, v27
	tmp.u32 = ctx.r[27].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A6AA2C: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6AC38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6AC38 size=1324
    let mut pc: u32 = 0x82A6AC38;
    'dispatch: loop {
        match pc {
            0x82A6AC38 => {
    //   block [0x82A6AC38..0x82A6B164)
	// 82A6AC38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6AC3C: 4873D525  bl 0x831a8160
	ctx.lr = 0x82A6AC40;
	sub_831A8130(ctx, base);
	// 82A6AC40: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6AC44: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A6AC48: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A6AC4C: 397D0034  addi r11, r29, 0x34
	ctx.r[11].s64 = ctx.r[29].s64 + 52;
	// 82A6AC50: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A6AC54: 7F6BF214  add r27, r11, r30
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A6AC58: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82A6AC5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6AC60: 419A0018  beq cr6, 0x82a6ac78
	if ctx.cr[6].eq {
	pc = 0x82A6AC78; continue 'dispatch;
	}
	// 82A6AC64: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6AC68: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A6AC6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A6AC70: 4E800421  bctrl
	ctx.lr = 0x82A6AC74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A6AC74: 480001F0  b 0x82a6ae64
	pc = 0x82A6AE64; continue 'dispatch;
	// 82A6AC78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A6AC7C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A6AC80: 4BAA4849  bl 0x8250f4c8
	ctx.lr = 0x82A6AC84;
	sub_8250F4C8(ctx, base);
	// 82A6AC84: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6AC88: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A6AC8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6AC90: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A6AC94: 409A0008  bne cr6, 0x82a6ac9c
	if !ctx.cr[6].eq {
	pc = 0x82A6AC9C; continue 'dispatch;
	}
	// 82A6AC98: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A6AC9C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A6ACA0: 4BA9FCB1  bl 0x8250a950
	ctx.lr = 0x82A6ACA4;
	sub_8250A950(ctx, base);
	// 82A6ACA4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A6ACA8: 48386FE9  bl 0x82df1c90
	ctx.lr = 0x82A6ACAC;
	sub_82DF1C90(ctx, base);
	// 82A6ACAC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82A6ACB0: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82A6ACB4: 807E00F0  lwz r3, 0xf0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(240 as u32) ) } as u64;
	// 82A6ACB8: 4BDA77C1  bl 0x82812478
	ctx.lr = 0x82A6ACBC;
	sub_82812478(ctx, base);
	// 82A6ACBC: 83430004  lwz r26, 4(r3)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6ACC0: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6ACC4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82A6ACC8: 419A0024  beq cr6, 0x82a6acec
	if ctx.cr[6].eq {
	pc = 0x82A6ACEC; continue 'dispatch;
	}
	// 82A6ACCC: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 82A6ACD0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6ACD4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6ACD8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6ACDC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6ACE0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6ACE4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6ACE8: 4082FFE8  bne 0x82a6acd0
	if !ctx.cr[0].eq {
	pc = 0x82A6ACD0; continue 'dispatch;
	}
	// 82A6ACEC: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A6ACF0: 409902C8  ble cr6, 0x82a6afb8
	if !ctx.cr[6].gt {
	pc = 0x82A6AFB8; continue 'dispatch;
	}
	// 82A6ACF4: 2F1D0002  cmpwi cr6, r29, 2
	ctx.cr[6].compare_i32(ctx.r[29].s32, 2, &mut ctx.xer);
	// 82A6ACF8: 40990270  ble cr6, 0x82a6af68
	if !ctx.cr[6].gt {
	pc = 0x82A6AF68; continue 'dispatch;
	}
	// 82A6ACFC: 2F1D0004  cmpwi cr6, r29, 4
	ctx.cr[6].compare_i32(ctx.r[29].s32, 4, &mut ctx.xer);
	// 82A6AD00: 419A016C  beq cr6, 0x82a6ae6c
	if ctx.cr[6].eq {
	pc = 0x82A6AE6C; continue 'dispatch;
	}
	// 82A6AD04: 2F1D0005  cmpwi cr6, r29, 5
	ctx.cr[6].compare_i32(ctx.r[29].s32, 5, &mut ctx.xer);
	// 82A6AD08: 419A0074  beq cr6, 0x82a6ad7c
	if ctx.cr[6].eq {
	pc = 0x82A6AD7C; continue 'dispatch;
	}
	// 82A6AD0C: 409902AC  ble cr6, 0x82a6afb8
	if !ctx.cr[6].gt {
	pc = 0x82A6AFB8; continue 'dispatch;
	}
	// 82A6AD10: 2F1D0007  cmpwi cr6, r29, 7
	ctx.cr[6].compare_i32(ctx.r[29].s32, 7, &mut ctx.xer);
	// 82A6AD14: 419902A4  bgt cr6, 0x82a6afb8
	if ctx.cr[6].gt {
	pc = 0x82A6AFB8; continue 'dispatch;
	}
	// 82A6AD18: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6AD1C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6AD20: 388BFFBC  addi r4, r11, -0x44
	ctx.r[4].s64 = ctx.r[11].s64 + -68;
	// 82A6AD24: 48388CE5  bl 0x82df3a08
	ctx.lr = 0x82A6AD28;
	sub_82DF3A08(ctx, base);
	// 82A6AD28: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82A6AD2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6AD30: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82A6AD34: 483AA2FD  bl 0x82e15030
	ctx.lr = 0x82A6AD38;
	sub_82E15030(ctx, base);
	// 82A6AD38: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A6AD3C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A6AD40: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A6AD44: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6AD48: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A6AD4C: 4B859715  bl 0x822c4460
	ctx.lr = 0x82A6AD50;
	sub_822C4460(ctx, base);
	// 82A6AD50: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A6AD54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6AD58: 419A0008  beq cr6, 0x82a6ad60
	if ctx.cr[6].eq {
	pc = 0x82A6AD60; continue 'dispatch;
	}
	// 82A6AD5C: 4B855B35  bl 0x822c0890
	ctx.lr = 0x82A6AD60;
	sub_822C0890(ctx, base);
	// 82A6AD60: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6AD64: 483886C5  bl 0x82df3428
	ctx.lr = 0x82A6AD68;
	sub_82DF3428(ctx, base);
	// 82A6AD68: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82A6AD6C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82A6AD70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6AD74: 4BFFF70D  bl 0x82a6a480
	ctx.lr = 0x82A6AD78;
	sub_82A6A480(ctx, base);
	// 82A6AD78: 48000290  b 0x82a6b008
	pc = 0x82A6B008; continue 'dispatch;
	// 82A6AD7C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6AD80: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A6AD84: 388BFFBC  addi r4, r11, -0x44
	ctx.r[4].s64 = ctx.r[11].s64 + -68;
	// 82A6AD88: 48388C81  bl 0x82df3a08
	ctx.lr = 0x82A6AD8C;
	sub_82DF3A08(ctx, base);
	// 82A6AD8C: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82A6AD90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6AD94: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82A6AD98: 483AA299  bl 0x82e15030
	ctx.lr = 0x82A6AD9C;
	sub_82E15030(ctx, base);
	// 82A6AD9C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A6ADA0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A6ADA4: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A6ADA8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6ADAC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A6ADB0: 4B8596B1  bl 0x822c4460
	ctx.lr = 0x82A6ADB4;
	sub_822C4460(ctx, base);
	// 82A6ADB4: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A6ADB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6ADBC: 419A0008  beq cr6, 0x82a6adc4
	if ctx.cr[6].eq {
	pc = 0x82A6ADC4; continue 'dispatch;
	}
	// 82A6ADC0: 4B855AD1  bl 0x822c0890
	ctx.lr = 0x82A6ADC4;
	sub_822C0890(ctx, base);
	// 82A6ADC4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A6ADC8: 48388661  bl 0x82df3428
	ctx.lr = 0x82A6ADCC;
	sub_82DF3428(ctx, base);
	// 82A6ADCC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6ADD0: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A6ADD4: 396BFE68  addi r11, r11, -0x198
	ctx.r[11].s64 = ctx.r[11].s64 + -408;
	// 82A6ADD8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A6ADDC: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A6ADE0: 48388C29  bl 0x82df3a08
	ctx.lr = 0x82A6ADE4;
	sub_82DF3A08(ctx, base);
	// 82A6ADE4: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82A6ADE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6ADEC: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 82A6ADF0: 409A0008  bne cr6, 0x82a6adf8
	if !ctx.cr[6].eq {
	pc = 0x82A6ADF8; continue 'dispatch;
	}
	// 82A6ADF4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A6ADF8: 38E0000B  li r7, 0xb
	ctx.r[7].s64 = 11;
	// 82A6ADFC: 38C1005C  addi r6, r1, 0x5c
	ctx.r[6].s64 = ctx.r[1].s64 + 92;
	// 82A6AE00: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A6AE04: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A6AE08: 4BD69EA9  bl 0x827d4cb0
	ctx.lr = 0x82A6AE0C;
	sub_827D4CB0(ctx, base);
	// 82A6AE0C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A6AE10: 387B0004  addi r3, r27, 4
	ctx.r[3].s64 = ctx.r[27].s64 + 4;
	// 82A6AE14: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A6AE18: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6AE1C: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A6AE20: 4B859641  bl 0x822c4460
	ctx.lr = 0x82A6AE24;
	sub_822C4460(ctx, base);
	// 82A6AE24: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A6AE28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6AE2C: 419A0008  beq cr6, 0x82a6ae34
	if ctx.cr[6].eq {
	pc = 0x82A6AE34; continue 'dispatch;
	}
	// 82A6AE30: 4B855A61  bl 0x822c0890
	ctx.lr = 0x82A6AE34;
	sub_822C0890(ctx, base);
	// 82A6AE34: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A6AE38: 483885F1  bl 0x82df3428
	ctx.lr = 0x82A6AE3C;
	sub_82DF3428(ctx, base);
	// 82A6AE3C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82A6AE40: 419A000C  beq cr6, 0x82a6ae4c
	if ctx.cr[6].eq {
	pc = 0x82A6AE4C; continue 'dispatch;
	}
	// 82A6AE44: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A6AE48: 4B855A49  bl 0x822c0890
	ctx.lr = 0x82A6AE4C;
	sub_822C0890(ctx, base);
	// 82A6AE4C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6AE50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6AE54: 419A0008  beq cr6, 0x82a6ae5c
	if ctx.cr[6].eq {
	pc = 0x82A6AE5C; continue 'dispatch;
	}
	// 82A6AE58: 4B855A39  bl 0x822c0890
	ctx.lr = 0x82A6AE5C;
	sub_822C0890(ctx, base);
	// 82A6AE5C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A6AE60: 48386E31  bl 0x82df1c90
	ctx.lr = 0x82A6AE64;
	sub_82DF1C90(ctx, base);
	// 82A6AE64: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 82A6AE68: 4873D348  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
	// 82A6AE6C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A6AE70: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82A6AE74: 396B6880  addi r11, r11, 0x6880
	ctx.r[11].s64 = ctx.r[11].s64 + 26752;
	// 82A6AE78: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 82A6AE7C: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 82A6AE80: 38E100E0  addi r7, r1, 0xe0
	ctx.r[7].s64 = ctx.r[1].s64 + 224;
	// 82A6AE84: 38C100F0  addi r6, r1, 0xf0
	ctx.r[6].s64 = ctx.r[1].s64 + 240;
	// 82A6AE88: 38A10100  addi r5, r1, 0x100
	ctx.r[5].s64 = ctx.r[1].s64 + 256;
	// 82A6AE8C: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A6AE90: 3BE10110  addi r31, r1, 0x110
	ctx.r[31].s64 = ctx.r[1].s64 + 272;
	// 82A6AE94: 13CA5C07  vcmpneb. (lvlx128) v30, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A6AE98: 13A95C07  vcmpneb. (lvlx128) v29, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A6AE9C: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 82A6AEA0: 13885C07  vcmpneb. (lvlx128) v28, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A6AEA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6B168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6B168 size=164
    let mut pc: u32 = 0x82A6B168;
    'dispatch: loop {
        match pc {
            0x82A6B168 => {
    //   block [0x82A6B168..0x82A6B20C)
	// 82A6B168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6B16C: 4873D001  bl 0x831a816c
	ctx.lr = 0x82A6B170;
	sub_831A8130(ctx, base);
	// 82A6B170: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6B174: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6B178: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A6B17C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6B180: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6B184: 4BAA4345  bl 0x8250f4c8
	ctx.lr = 0x82A6B188;
	sub_8250F4C8(ctx, base);
	// 82A6B188: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6B18C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A6B190: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6B194: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A6B198: 409A0008  bne cr6, 0x82a6b1a0
	if !ctx.cr[6].eq {
	pc = 0x82A6B1A0; continue 'dispatch;
	}
	// 82A6B19C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A6B1A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6B1A4: 4BA9F7AD  bl 0x8250a950
	ctx.lr = 0x82A6B1A8;
	sub_8250A950(ctx, base);
	// 82A6B1A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6B1AC: 48386AE5  bl 0x82df1c90
	ctx.lr = 0x82A6B1B0;
	sub_82DF1C90(ctx, base);
	// 82A6B1B0: 397E0034  addi r11, r30, 0x34
	ctx.r[11].s64 = ctx.r[30].s64 + 52;
	// 82A6B1B4: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A6B1B8: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A6B1BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6B1C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6B1C4: 419A0038  beq cr6, 0x82a6b1fc
	if ctx.cr[6].eq {
	pc = 0x82A6B1FC; continue 'dispatch;
	}
	// 82A6B1C8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A6B1CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6B1D0: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82A6B1D4: 409A0008  bne cr6, 0x82a6b1dc
	if !ctx.cr[6].eq {
	pc = 0x82A6B1DC; continue 'dispatch;
	}
	// 82A6B1D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A6B1DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6B1E0: 4BD68821  bl 0x827d3a00
	ctx.lr = 0x82A6B1E4;
	sub_827D3A00(ctx, base);
	// 82A6B1E4: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A6B1E8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6B1EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6B1F0: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82A6B1F4: 419A0008  beq cr6, 0x82a6b1fc
	if ctx.cr[6].eq {
	pc = 0x82A6B1FC; continue 'dispatch;
	}
	// 82A6B1F8: 4B855699  bl 0x822c0890
	ctx.lr = 0x82A6B1FC;
	sub_822C0890(ctx, base);
	// 82A6B1FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6B200: 48386A91  bl 0x82df1c90
	ctx.lr = 0x82A6B204;
	sub_82DF1C90(ctx, base);
	// 82A6B204: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A6B208: 4873CFB4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6B210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6B210 size=168
    let mut pc: u32 = 0x82A6B210;
    'dispatch: loop {
        match pc {
            0x82A6B210 => {
    //   block [0x82A6B210..0x82A6B2B8)
	// 82A6B210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6B214: 4873CF59  bl 0x831a816c
	ctx.lr = 0x82A6B218;
	sub_831A8130(ctx, base);
	// 82A6B218: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6B21C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6B220: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6B224: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6B228: 4BAA42A1  bl 0x8250f4c8
	ctx.lr = 0x82A6B22C;
	sub_8250F4C8(ctx, base);
	// 82A6B22C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6B230: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A6B234: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6B238: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A6B23C: 409A0008  bne cr6, 0x82a6b244
	if !ctx.cr[6].eq {
	pc = 0x82A6B244; continue 'dispatch;
	}
	// 82A6B240: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A6B244: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6B248: 4BA9F709  bl 0x8250a950
	ctx.lr = 0x82A6B24C;
	sub_8250A950(ctx, base);
	// 82A6B24C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6B250: 48386A41  bl 0x82df1c90
	ctx.lr = 0x82A6B254;
	sub_82DF1C90(ctx, base);
	// 82A6B254: 3BFF01A0  addi r31, r31, 0x1a0
	ctx.r[31].s64 = ctx.r[31].s64 + 416;
	// 82A6B258: 3BC00008  li r30, 8
	ctx.r[30].s64 = 8;
	// 82A6B25C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6B260: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6B264: 419A0038  beq cr6, 0x82a6b29c
	if ctx.cr[6].eq {
	pc = 0x82A6B29C; continue 'dispatch;
	}
	// 82A6B268: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A6B26C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6B270: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82A6B274: 409A0008  bne cr6, 0x82a6b27c
	if !ctx.cr[6].eq {
	pc = 0x82A6B27C; continue 'dispatch;
	}
	// 82A6B278: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A6B27C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6B280: 4BD68781  bl 0x827d3a00
	ctx.lr = 0x82A6B284;
	sub_827D3A00(ctx, base);
	// 82A6B284: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A6B288: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6B28C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6B290: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82A6B294: 419A0008  beq cr6, 0x82a6b29c
	if ctx.cr[6].eq {
	pc = 0x82A6B29C; continue 'dispatch;
	}
	// 82A6B298: 4B8555F9  bl 0x822c0890
	ctx.lr = 0x82A6B29C;
	sub_822C0890(ctx, base);
	// 82A6B29C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A6B2A0: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82A6B2A4: 4082FFB8  bne 0x82a6b25c
	if !ctx.cr[0].eq {
	pc = 0x82A6B25C; continue 'dispatch;
	}
	// 82A6B2A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6B2AC: 483869E5  bl 0x82df1c90
	ctx.lr = 0x82A6B2B0;
	sub_82DF1C90(ctx, base);
	// 82A6B2B0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A6B2B4: 4873CF08  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6B2B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6B2B8 size=1072
    let mut pc: u32 = 0x82A6B2B8;
    'dispatch: loop {
        match pc {
            0x82A6B2B8 => {
    //   block [0x82A6B2B8..0x82A6B6E8)
	// 82A6B2B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6B2BC: 4873CEA1  bl 0x831a815c
	ctx.lr = 0x82A6B2C0;
	sub_831A8130(ctx, base);
	// 82A6B2C0: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6B2C4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A6B2C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6B2CC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A6B2D0: 816BDFCC  lwz r11, -0x2034(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8244 as u32) ) } as u64;
	// 82A6B2D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6B2D8: 409A0398  bne cr6, 0x82a6b670
	if !ctx.cr[6].eq {
	pc = 0x82A6B670; continue 'dispatch;
	}
	// 82A6B2DC: 817F02B4  lwz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 82A6B2E0: 3BDF02B4  addi r30, r31, 0x2b4
	ctx.r[30].s64 = ctx.r[31].s64 + 692;
	// 82A6B2E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6B2E8: 419A001C  beq cr6, 0x82a6b304
	if ctx.cr[6].eq {
	pc = 0x82A6B304; continue 'dispatch;
	}
	// 82A6B2EC: 935E0000  stw r26, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82A6B2F0: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6B2F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6B2F8: 935E0004  stw r26, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82A6B2FC: 419A0008  beq cr6, 0x82a6b304
	if ctx.cr[6].eq {
	pc = 0x82A6B304; continue 'dispatch;
	}
	// 82A6B300: 4B855591  bl 0x822c0890
	ctx.lr = 0x82A6B304;
	sub_822C0890(ctx, base);
	// 82A6B304: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A6B308: 4BFF8951  bl 0x82a63c58
	ctx.lr = 0x82A6B30C;
	sub_82A63C58(ctx, base);
	// 82A6B30C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A6B310: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82A6B314: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A6B318: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6B31C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A6B320: 4B859141  bl 0x822c4460
	ctx.lr = 0x82A6B324;
	sub_822C4460(ctx, base);
	// 82A6B324: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A6B328: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6B32C: 419A0008  beq cr6, 0x82a6b334
	if ctx.cr[6].eq {
	pc = 0x82A6B334; continue 'dispatch;
	}
	// 82A6B330: 4B855561  bl 0x822c0890
	ctx.lr = 0x82A6B334;
	sub_822C0890(ctx, base);
	// 82A6B334: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6B338: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6B33C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6B340: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A6B344: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A6B348: 419A0024  beq cr6, 0x82a6b36c
	if ctx.cr[6].eq {
	pc = 0x82A6B36C; continue 'dispatch;
	}
	// 82A6B34C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6B350: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6B354: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6B358: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6B35C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6B360: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6B364: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6B368: 4082FFE8  bne 0x82a6b350
	if !ctx.cr[0].eq {
	pc = 0x82A6B350; continue 'dispatch;
	}
	// 82A6B36C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6B370: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6B374: 4BAA4155  bl 0x8250f4c8
	ctx.lr = 0x82A6B378;
	sub_8250F4C8(ctx, base);
	// 82A6B378: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6B37C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6B380: 3BABFFFC  addi r29, r11, -4
	ctx.r[29].s64 = ctx.r[11].s64 + -4;
	// 82A6B384: 409A0008  bne cr6, 0x82a6b38c
	if !ctx.cr[6].eq {
	pc = 0x82A6B38C; continue 'dispatch;
	}
	// 82A6B388: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82A6B38C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6B390: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A6B394: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 82A6B398: 4BAA4181  bl 0x8250f518
	ctx.lr = 0x82A6B39C;
	sub_8250F518(ctx, base);
	// 82A6B39C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6B3A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A6B3A4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A6B3A8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82A6B3AC: 4BAA215D  bl 0x8250d508
	ctx.lr = 0x82A6B3B0;
	sub_8250D508(ctx, base);
	// 82A6B3B0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6B3B4: 483868DD  bl 0x82df1c90
	ctx.lr = 0x82A6B3B8;
	sub_82DF1C90(ctx, base);
	// 82A6B3B8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A6B3BC: 483868D5  bl 0x82df1c90
	ctx.lr = 0x82A6B3C0;
	sub_82DF1C90(ctx, base);
	// 82A6B3C0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6B3C4: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 82A6B3C8: 4859DBF1  bl 0x83008fb8
	ctx.lr = 0x82A6B3CC;
	sub_83008FB8(ctx, base);
	// 82A6B3CC: 907F027C  stw r3, 0x27c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(636 as u32), ctx.r[3].u32 ) };
	// 82A6B3D0: 3BBF0280  addi r29, r31, 0x280
	ctx.r[29].s64 = ctx.r[31].s64 + 640;
	// 82A6B3D4: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82A6B3D8: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 82A6B3DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A6B3E0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A6B3E4: 48014D05  bl 0x82a800e8
	ctx.lr = 0x82A6B3E8;
	sub_82A800E8(ctx, base);
	// 82A6B3E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A6B3EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A6B3F0: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A6B3F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6B3F8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A6B3FC: 4B859065  bl 0x822c4460
	ctx.lr = 0x82A6B400;
	sub_822C4460(ctx, base);
	// 82A6B400: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A6B404: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6B408: 419A0008  beq cr6, 0x82a6b410
	if ctx.cr[6].eq {
	pc = 0x82A6B410; continue 'dispatch;
	}
	// 82A6B40C: 4B855485  bl 0x822c0890
	ctx.lr = 0x82A6B410;
	sub_822C0890(ctx, base);
	// 82A6B410: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6B414: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A6B418: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6B41C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A6B420: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 82A6B424: 419A0024  beq cr6, 0x82a6b448
	if ctx.cr[6].eq {
	pc = 0x82A6B448; continue 'dispatch;
	}
	// 82A6B428: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6B42C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6B430: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6B434: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6B438: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6B43C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6B440: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6B444: 4082FFE8  bne 0x82a6b42c
	if !ctx.cr[0].eq {
	pc = 0x82A6B42C; continue 'dispatch;
	}
	// 82A6B448: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6B44C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82A6B450: 4BAA4079  bl 0x8250f4c8
	ctx.lr = 0x82A6B454;
	sub_8250F4C8(ctx, base);
	// 82A6B454: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6B458: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6B45C: 3B8BFFFC  addi r28, r11, -4
	ctx.r[28].s64 = ctx.r[11].s64 + -4;
	// 82A6B460: 409A0008  bne cr6, 0x82a6b468
	if !ctx.cr[6].eq {
	pc = 0x82A6B468; continue 'dispatch;
	}
	// 82A6B464: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 82A6B468: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6B46C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A6B470: 3B210058  addi r25, r1, 0x58
	ctx.r[25].s64 = ctx.r[1].s64 + 88;
	// 82A6B474: 4BAA40A5  bl 0x8250f518
	ctx.lr = 0x82A6B478;
	sub_8250F518(ctx, base);
	// 82A6B478: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6B47C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A6B480: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82A6B484: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82A6B488: 4BAA2081  bl 0x8250d508
	ctx.lr = 0x82A6B48C;
	sub_8250D508(ctx, base);
	// 82A6B48C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82A6B490: 48386801  bl 0x82df1c90
	ctx.lr = 0x82A6B494;
	sub_82DF1C90(ctx, base);
	// 82A6B494: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A6B498: 483867F9  bl 0x82df1c90
	ctx.lr = 0x82A6B49C;
	sub_82DF1C90(ctx, base);
	// 82A6B49C: 387B0028  addi r3, r27, 0x28
	ctx.r[3].s64 = ctx.r[27].s64 + 40;
	// 82A6B4A0: 4859DB19  bl 0x83008fb8
	ctx.lr = 0x82A6B4A4;
	sub_83008FB8(ctx, base);
	// 82A6B4A4: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82A6B4A8: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A6B4AC: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82A6B4B0: 4082FF2C  bne 0x82a6b3dc
	if !ctx.cr[0].eq {
	pc = 0x82A6B3DC; continue 'dispatch;
	}
	// 82A6B4B4: 3B9F028C  addi r28, r31, 0x28c
	ctx.r[28].s64 = ctx.r[31].s64 + 652;
	// 82A6B4B8: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 82A6B4BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A6B4C0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A6B4C4: 48014C25  bl 0x82a800e8
	ctx.lr = 0x82A6B4C8;
	sub_82A800E8(ctx, base);
	// 82A6B4C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A6B4CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A6B4D0: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A6B4D4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6B4D8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A6B4DC: 4B858F85  bl 0x822c4460
	ctx.lr = 0x82A6B4E0;
	sub_822C4460(ctx, base);
	// 82A6B4E0: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A6B4E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6B4E8: 419A0008  beq cr6, 0x82a6b4f0
	if ctx.cr[6].eq {
	pc = 0x82A6B4F0; continue 'dispatch;
	}
	// 82A6B4EC: 4B8553A5  bl 0x822c0890
	ctx.lr = 0x82A6B4F0;
	sub_822C0890(ctx, base);
	// 82A6B4F0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6B4F4: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A6B4F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6B4FC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A6B500: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 82A6B504: 419A0024  beq cr6, 0x82a6b528
	if ctx.cr[6].eq {
	pc = 0x82A6B528; continue 'dispatch;
	}
	// 82A6B508: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6B50C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6B510: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6B514: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6B518: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6B51C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6B520: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6B524: 4082FFE8  bne 0x82a6b50c
	if !ctx.cr[0].eq {
	pc = 0x82A6B50C; continue 'dispatch;
	}
	// 82A6B528: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6B52C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A6B530: 4BAA3F99  bl 0x8250f4c8
	ctx.lr = 0x82A6B534;
	sub_8250F4C8(ctx, base);
	// 82A6B534: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6B538: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6B53C: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 82A6B540: 409A0008  bne cr6, 0x82a6b548
	if !ctx.cr[6].eq {
	pc = 0x82A6B548; continue 'dispatch;
	}
	// 82A6B544: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 82A6B548: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6B54C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A6B550: 3B210058  addi r25, r1, 0x58
	ctx.r[25].s64 = ctx.r[1].s64 + 88;
	// 82A6B554: 4BAA3FC5  bl 0x8250f518
	ctx.lr = 0x82A6B558;
	sub_8250F518(ctx, base);
	// 82A6B558: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6B55C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6B560: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82A6B564: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82A6B568: 4BAA1FA1  bl 0x8250d508
	ctx.lr = 0x82A6B56C;
	sub_8250D508(ctx, base);
	// 82A6B56C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A6B570: 48386721  bl 0x82df1c90
	ctx.lr = 0x82A6B574;
	sub_82DF1C90(ctx, base);
	// 82A6B574: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A6B578: 48386719  bl 0x82df1c90
	ctx.lr = 0x82A6B57C;
	sub_82DF1C90(ctx, base);
	// 82A6B57C: 387B0028  addi r3, r27, 0x28
	ctx.r[3].s64 = ctx.r[27].s64 + 40;
	// 82A6B580: 4859DA39  bl 0x83008fb8
	ctx.lr = 0x82A6B584;
	sub_83008FB8(ctx, base);
	// 82A6B584: 907C0000  stw r3, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82A6B588: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A6B58C: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82A6B590: 4082FF2C  bne 0x82a6b4bc
	if !ctx.cr[0].eq {
	pc = 0x82A6B4BC; continue 'dispatch;
	}
	// 82A6B594: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A6B598: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A6B59C: 48014B4D  bl 0x82a800e8
	ctx.lr = 0x82A6B5A0;
	sub_82A800E8(ctx, base);
	// 82A6B5A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A6B5A4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A6B5A8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A6B5AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6B5B0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A6B5B4: 4B858EAD  bl 0x822c4460
	ctx.lr = 0x82A6B5B8;
	sub_822C4460(ctx, base);
	// 82A6B5B8: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A6B5BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6B5C0: 419A0008  beq cr6, 0x82a6b5c8
	if ctx.cr[6].eq {
	pc = 0x82A6B5C8; continue 'dispatch;
	}
	// 82A6B5C4: 4B8552CD  bl 0x822c0890
	ctx.lr = 0x82A6B5C8;
	sub_822C0890(ctx, base);
	// 82A6B5C8: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6B5CC: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A6B5D0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6B5D4: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82A6B5D8: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82A6B5DC: 419A0024  beq cr6, 0x82a6b600
	if ctx.cr[6].eq {
	pc = 0x82A6B600; continue 'dispatch;
	}
	// 82A6B5E0: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82A6B5E4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6B5E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6B5EC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6B5F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6B5F4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6B5F8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6B5FC: 4082FFE8  bne 0x82a6b5e4
	if !ctx.cr[0].eq {
	pc = 0x82A6B5E4; continue 'dispatch;
	}
	// 82A6B600: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6B604: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A6B608: 4BAA3EC1  bl 0x8250f4c8
	ctx.lr = 0x82A6B60C;
	sub_8250F4C8(ctx, base);
	// 82A6B60C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6B610: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6B614: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 82A6B618: 409A0008  bne cr6, 0x82a6b620
	if !ctx.cr[6].eq {
	pc = 0x82A6B620; continue 'dispatch;
	}
	// 82A6B61C: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 82A6B620: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6B624: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A6B628: 3B610058  addi r27, r1, 0x58
	ctx.r[27].s64 = ctx.r[1].s64 + 88;
	// 82A6B62C: 4BAA3EED  bl 0x8250f518
	ctx.lr = 0x82A6B630;
	sub_8250F518(ctx, base);
	// 82A6B630: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6B634: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6B638: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A6B63C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82A6B640: 4BAA1EC9  bl 0x8250d508
	ctx.lr = 0x82A6B644;
	sub_8250D508(ctx, base);
	// 82A6B644: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A6B648: 48386649  bl 0x82df1c90
	ctx.lr = 0x82A6B64C;
	sub_82DF1C90(ctx, base);
	// 82A6B64C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A6B650: 48386641  bl 0x82df1c90
	ctx.lr = 0x82A6B654;
	sub_82DF1C90(ctx, base);
	// 82A6B654: 387C0028  addi r3, r28, 0x28
	ctx.r[3].s64 = ctx.r[28].s64 + 40;
	// 82A6B658: 4859D961  bl 0x83008fb8
	ctx.lr = 0x82A6B65C;
	sub_83008FB8(ctx, base);
	// 82A6B65C: 907F0294  stw r3, 0x294(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(660 as u32), ctx.r[3].u32 ) };
	// 82A6B660: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6B664: 419A000C  beq cr6, 0x82a6b670
	if ctx.cr[6].eq {
	pc = 0x82A6B670; continue 'dispatch;
	}
	// 82A6B668: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A6B66C: 4B855225  bl 0x822c0890
	ctx.lr = 0x82A6B670;
	sub_822C0890(ctx, base);
	// 82A6B670: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6B674: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A6B678: 4BAA3EA1  bl 0x8250f518
	ctx.lr = 0x82A6B67C;
	sub_8250F518(ctx, base);
	// 82A6B67C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6B680: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6B684: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 82A6B688: 409A0008  bne cr6, 0x82a6b690
	if !ctx.cr[6].eq {
	pc = 0x82A6B690; continue 'dispatch;
	}
	// 82A6B68C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A6B690: 4BABCEF1  bl 0x82528580
	ctx.lr = 0x82A6B694;
	sub_82528580(ctx, base);
	// 82A6B694: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A6B698: 394100D0  addi r10, r1, 0xd0
	ctx.r[10].s64 = ctx.r[1].s64 + 208;
	// 82A6B69C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A6B6A0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6B6E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6B6E8 size=120
    let mut pc: u32 = 0x82A6B6E8;
    'dispatch: loop {
        match pc {
            0x82A6B6E8 => {
    //   block [0x82A6B6E8..0x82A6B760)
	// 82A6B6E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6B6EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6B6F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6B6F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6B6F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6B6FC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82A6B700: 895F0220  lbz r10, 0x220(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(544 as u32) ) } as u64;
	// 82A6B704: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A6B708: 4082003C  bne 0x82a6b744
	if !ctx.cr[0].eq {
	pc = 0x82A6B744; continue 'dispatch;
	}
	// 82A6B70C: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 82A6B710: 39200230  li r9, 0x230
	ctx.r[9].s64 = 560;
	// 82A6B714: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82A6B718: 13EB50C7  vcmpequd (lvx128) v31, v11, v10
	tmp.u32 = ctx.r[11].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6B760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6B760 size=96
    let mut pc: u32 = 0x82A6B760;
    'dispatch: loop {
        match pc {
            0x82A6B760 => {
    //   block [0x82A6B760..0x82A6B7C0)
	// 82A6B760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6B764: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6B768: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6B76C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6B770: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82A6B774: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6B778: 4BFFF9F1  bl 0x82a6b168
	ctx.lr = 0x82A6B77C;
	sub_82A6B168(ctx, base);
	// 82A6B77C: 809F0240  lwz r4, 0x240(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(576 as u32) ) } as u64;
	// 82A6B780: 807F02AC  lwz r3, 0x2ac(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(684 as u32) ) } as u64;
	// 82A6B784: 48015935  bl 0x82a810b8
	ctx.lr = 0x82A6B788;
	sub_82A810B8(ctx, base);
	// 82A6B788: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A6B78C: 395F02A4  addi r10, r31, 0x2a4
	ctx.r[10].s64 = ctx.r[31].s64 + 676;
	// 82A6B790: 917F0240  stw r11, 0x240(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), ctx.r[11].u32 ) };
	// 82A6B794: 917F02A4  stw r11, 0x2a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(676 as u32), ctx.r[11].u32 ) };
	// 82A6B798: 807F02A8  lwz r3, 0x2a8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(680 as u32) ) } as u64;
	// 82A6B79C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6B7A0: 917F02A8  stw r11, 0x2a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(680 as u32), ctx.r[11].u32 ) };
	// 82A6B7A4: 419A0008  beq cr6, 0x82a6b7ac
	if ctx.cr[6].eq {
	pc = 0x82A6B7AC; continue 'dispatch;
	}
	// 82A6B7A8: 4B8550E9  bl 0x822c0890
	ctx.lr = 0x82A6B7AC;
	sub_822C0890(ctx, base);
	// 82A6B7AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A6B7B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6B7B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6B7B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6B7BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6B7C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6B7C0 size=208
    let mut pc: u32 = 0x82A6B7C0;
    'dispatch: loop {
        match pc {
            0x82A6B7C0 => {
    //   block [0x82A6B7C0..0x82A6B890)
	// 82A6B7C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6B7C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6B7C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6B7CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6B7D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6B7D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A6B7D8: C1BF0104  lfs f13, 0x104(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A6B7DC: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6B7E0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A6B7E4: 4199000C  bgt cr6, 0x82a6b7f0
	if ctx.cr[6].gt {
	pc = 0x82A6B7F0; continue 'dispatch;
	}
	// 82A6B7E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A6B7EC: 48000090  b 0x82a6b87c
	pc = 0x82A6B87C; continue 'dispatch;
	// 82A6B7F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6B7F4: 4BFFDEBD  bl 0x82a696b0
	ctx.lr = 0x82A6B7F8;
	sub_82A696B0(ctx, base);
	// 82A6B7F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6B7FC: 4182FFEC  beq 0x82a6b7e8
	if ctx.cr[0].eq {
	pc = 0x82A6B7E8; continue 'dispatch;
	}
	// 82A6B800: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A6B804: 4BFF84ED  bl 0x82a63cf0
	ctx.lr = 0x82A6B808;
	sub_82A63CF0(ctx, base);
	// 82A6B808: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6B80C: 4082FFDC  bne 0x82a6b7e8
	if !ctx.cr[0].eq {
	pc = 0x82A6B7E8; continue 'dispatch;
	}
	// 82A6B810: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A6B814: 483EEEBD  bl 0x82e5a6d0
	ctx.lr = 0x82A6B818;
	sub_82E5A6D0(ctx, base);
	// 82A6B818: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6B81C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6B820: 386BE848  addi r3, r11, -0x17b8
	ctx.r[3].s64 = ctx.r[11].s64 + -6072;
	// 82A6B824: 48387FA5  bl 0x82df37c8
	ctx.lr = 0x82A6B828;
	sub_82DF37C8(ctx, base);
	// 82A6B828: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6B82C: 4082FFBC  bne 0x82a6b7e8
	if !ctx.cr[0].eq {
	pc = 0x82A6B7E8; continue 'dispatch;
	}
	// 82A6B830: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A6B834: 483EEE9D  bl 0x82e5a6d0
	ctx.lr = 0x82A6B838;
	sub_82E5A6D0(ctx, base);
	// 82A6B838: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6B83C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6B840: 386B00B4  addi r3, r11, 0xb4
	ctx.r[3].s64 = ctx.r[11].s64 + 180;
	// 82A6B844: 48387F85  bl 0x82df37c8
	ctx.lr = 0x82A6B848;
	sub_82DF37C8(ctx, base);
	// 82A6B848: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6B84C: 4082FF9C  bne 0x82a6b7e8
	if !ctx.cr[0].eq {
	pc = 0x82A6B7E8; continue 'dispatch;
	}
	// 82A6B850: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A6B854: 483EEE7D  bl 0x82e5a6d0
	ctx.lr = 0x82A6B858;
	sub_82E5A6D0(ctx, base);
	// 82A6B858: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A6B85C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6B860: 386B6C90  addi r3, r11, 0x6c90
	ctx.r[3].s64 = ctx.r[11].s64 + 27792;
	// 82A6B864: 48387F65  bl 0x82df37c8
	ctx.lr = 0x82A6B868;
	sub_82DF37C8(ctx, base);
	// 82A6B868: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6B86C: 4082FF7C  bne 0x82a6b7e8
	if !ctx.cr[0].eq {
	pc = 0x82A6B7E8; continue 'dispatch;
	}
	// 82A6B870: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6B874: 4BFFEC6D  bl 0x82a6a4e0
	ctx.lr = 0x82A6B878;
	sub_82A6A4E0(ctx, base);
	// 82A6B878: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A6B87C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A6B880: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6B884: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6B888: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6B88C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6B890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6B890 size=108
    let mut pc: u32 = 0x82A6B890;
    'dispatch: loop {
        match pc {
            0x82A6B890 => {
    //   block [0x82A6B890..0x82A6B8FC)
	// 82A6B890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6B894: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6B898: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6B89C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6B8A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6B8A4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A6B8A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6B8AC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A6B8B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6B8B4: 808B167C  lwz r4, 0x167c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5756 as u32) ) } as u64;
	// 82A6B8B8: 48386341  bl 0x82df1bf8
	ctx.lr = 0x82A6B8BC;
	sub_82DF1BF8(ctx, base);
	// 82A6B8BC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A6B8C0: 480DB981  bl 0x82b47240
	ctx.lr = 0x82A6B8C4;
	sub_82B47240(ctx, base);
	// 82A6B8C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A6B8C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6B8CC: 483863C5  bl 0x82df1c90
	ctx.lr = 0x82A6B8D0;
	sub_82DF1C90(ctx, base);
	// 82A6B8D0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A6B8D4: C1BE0010  lfs f13, 0x10(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A6B8D8: C00BC5F0  lfs f0, -0x3a10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6B8DC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6B8E0: D01F029C  stfs f0, 0x29c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(668 as u32), tmp.u32 ) };
	// 82A6B8E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6B8E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6B8EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6B8F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6B8F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6B8F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6B900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6B900 size=584
    let mut pc: u32 = 0x82A6B900;
    'dispatch: loop {
        match pc {
            0x82A6B900 => {
    //   block [0x82A6B900..0x82A6BB48)
	// 82A6B900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6B904: 4873C85D  bl 0x831a8160
	ctx.lr = 0x82A6B908;
	sub_831A8130(ctx, base);
	// 82A6B908: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82A6B90C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6B910: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6B914: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A6B918: 3B6B0068  addi r27, r11, 0x68
	ctx.r[27].s64 = ctx.r[11].s64 + 104;
	// 82A6B91C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A6B920: 38A0086F  li r5, 0x86f
	ctx.r[5].s64 = 2159;
	// 82A6B924: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A6B928: 38600108  li r3, 0x108
	ctx.r[3].s64 = 264;
	// 82A6B92C: 48386ABD  bl 0x82df23e8
	ctx.lr = 0x82A6B930;
	sub_82DF23E8(ctx, base);
	// 82A6B930: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A6B934: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A6B938: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A6B93C: 41820028  beq 0x82a6b964
	if ctx.cr[0].eq {
	pc = 0x82A6B964; continue 'dispatch;
	}
	// 82A6B940: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82A6B944: 4859D675  bl 0x83008fb8
	ctx.lr = 0x82A6B948;
	sub_83008FB8(ctx, base);
	// 82A6B948: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A6B94C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A6B950: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6B954: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6B958: 4BF19221  bl 0x82984b78
	ctx.lr = 0x82A6B95C;
	sub_82984B78(ctx, base);
	// 82A6B95C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6B960: 48000008  b 0x82a6b968
	pc = 0x82A6B968; continue 'dispatch;
	// 82A6B964: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A6B968: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A6B96C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6B970: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A6B974: 4BFFE37D  bl 0x82a69cf0
	ctx.lr = 0x82A6B978;
	sub_82A69CF0(ctx, base);
	// 82A6B978: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A6B97C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6B980: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A6B984: 4B85467D  bl 0x822c0000
	ctx.lr = 0x82A6B988;
	sub_822C0000(ctx, base);
	// 82A6B988: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6B98C: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A6B990: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6B994: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82A6B998: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82A6B99C: 419A0024  beq cr6, 0x82a6b9c0
	if ctx.cr[6].eq {
	pc = 0x82A6B9C0; continue 'dispatch;
	}
	// 82A6B9A0: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82A6B9A4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6B9A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6B9AC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6B9B0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6B9B4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6B9B8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6B9BC: 4082FFE8  bne 0x82a6b9a4
	if !ctx.cr[0].eq {
	pc = 0x82A6B9A4; continue 'dispatch;
	}
	// 82A6B9C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A6B9C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6B9C8: 4BAA3B01  bl 0x8250f4c8
	ctx.lr = 0x82A6B9CC;
	sub_8250F4C8(ctx, base);
	// 82A6B9CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6B9D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6B9D4: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82A6B9D8: 409A0008  bne cr6, 0x82a6b9e0
	if !ctx.cr[6].eq {
	pc = 0x82A6B9E0; continue 'dispatch;
	}
	// 82A6B9DC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A6B9E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A6B9E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A6B9E8: 3B410050  addi r26, r1, 0x50
	ctx.r[26].s64 = ctx.r[1].s64 + 80;
	// 82A6B9EC: 4BAA3B2D  bl 0x8250f518
	ctx.lr = 0x82A6B9F0;
	sub_8250F518(ctx, base);
	// 82A6B9F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6B9F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6B9F8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82A6B9FC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A6BA00: 4BAA1B09  bl 0x8250d508
	ctx.lr = 0x82A6BA04;
	sub_8250D508(ctx, base);
	// 82A6BA04: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6BA08: 48386289  bl 0x82df1c90
	ctx.lr = 0x82A6BA0C;
	sub_82DF1C90(ctx, base);
	// 82A6BA0C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A6BA10: 48386281  bl 0x82df1c90
	ctx.lr = 0x82A6BA14;
	sub_82DF1C90(ctx, base);
	// 82A6BA14: 387C0028  addi r3, r28, 0x28
	ctx.r[3].s64 = ctx.r[28].s64 + 40;
	// 82A6BA18: 4859D5A1  bl 0x83008fb8
	ctx.lr = 0x82A6BA1C;
	sub_83008FB8(ctx, base);
	// 82A6BA1C: 907E0274  stw r3, 0x274(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(628 as u32), ctx.r[3].u32 ) };
	// 82A6BA20: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6BA24: 419A000C  beq cr6, 0x82a6ba30
	if ctx.cr[6].eq {
	pc = 0x82A6BA30; continue 'dispatch;
	}
	// 82A6BA28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A6BA2C: 4B854E65  bl 0x822c0890
	ctx.lr = 0x82A6BA30;
	sub_822C0890(ctx, base);
	// 82A6BA30: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A6BA34: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A6BA38: 38A00875  li r5, 0x875
	ctx.r[5].s64 = 2165;
	// 82A6BA3C: 38600108  li r3, 0x108
	ctx.r[3].s64 = 264;
	// 82A6BA40: 483869A9  bl 0x82df23e8
	ctx.lr = 0x82A6BA44;
	sub_82DF23E8(ctx, base);
	// 82A6BA44: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A6BA48: 41820028  beq 0x82a6ba70
	if ctx.cr[0].eq {
	pc = 0x82A6BA70; continue 'dispatch;
	}
	// 82A6BA4C: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82A6BA50: 4859D569  bl 0x83008fb8
	ctx.lr = 0x82A6BA54;
	sub_83008FB8(ctx, base);
	// 82A6BA54: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A6BA58: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82A6BA5C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6BA60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6BA64: 4BF19115  bl 0x82984b78
	ctx.lr = 0x82A6BA68;
	sub_82984B78(ctx, base);
	// 82A6BA68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6BA6C: 48000008  b 0x82a6ba74
	pc = 0x82A6BA74; continue 'dispatch;
	// 82A6BA70: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A6BA74: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A6BA78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6BA7C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A6BA80: 4BFFE271  bl 0x82a69cf0
	ctx.lr = 0x82A6BA84;
	sub_82A69CF0(ctx, base);
	// 82A6BA84: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A6BA88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6BA8C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A6BA90: 4B854571  bl 0x822c0000
	ctx.lr = 0x82A6BA94;
	sub_822C0000(ctx, base);
	// 82A6BA94: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6BA98: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A6BA9C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6BAA0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82A6BAA4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82A6BAA8: 419A0024  beq cr6, 0x82a6bacc
	if ctx.cr[6].eq {
	pc = 0x82A6BACC; continue 'dispatch;
	}
	// 82A6BAAC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82A6BAB0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6BAB4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6BAB8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6BABC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6BAC0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6BAC4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6BAC8: 4082FFE8  bne 0x82a6bab0
	if !ctx.cr[0].eq {
	pc = 0x82A6BAB0; continue 'dispatch;
	}
	// 82A6BACC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A6BAD0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A6BAD4: 4BAA39F5  bl 0x8250f4c8
	ctx.lr = 0x82A6BAD8;
	sub_8250F4C8(ctx, base);
	// 82A6BAD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6BADC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6BAE0: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82A6BAE4: 409A0008  bne cr6, 0x82a6baec
	if !ctx.cr[6].eq {
	pc = 0x82A6BAEC; continue 'dispatch;
	}
	// 82A6BAE8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A6BAEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A6BAF0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6BAF4: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 82A6BAF8: 4BAA3A21  bl 0x8250f518
	ctx.lr = 0x82A6BAFC;
	sub_8250F518(ctx, base);
	// 82A6BAFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6BB00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6BB04: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A6BB08: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A6BB0C: 4BAA19FD  bl 0x8250d508
	ctx.lr = 0x82A6BB10;
	sub_8250D508(ctx, base);
	// 82A6BB10: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A6BB14: 4838617D  bl 0x82df1c90
	ctx.lr = 0x82A6BB18;
	sub_82DF1C90(ctx, base);
	// 82A6BB18: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6BB1C: 48386175  bl 0x82df1c90
	ctx.lr = 0x82A6BB20;
	sub_82DF1C90(ctx, base);
	// 82A6BB20: 387C0028  addi r3, r28, 0x28
	ctx.r[3].s64 = ctx.r[28].s64 + 40;
	// 82A6BB24: 4859D495  bl 0x83008fb8
	ctx.lr = 0x82A6BB28;
	sub_83008FB8(ctx, base);
	// 82A6BB28: 907E0278  stw r3, 0x278(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(632 as u32), ctx.r[3].u32 ) };
	// 82A6BB2C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6BB30: 419A000C  beq cr6, 0x82a6bb3c
	if ctx.cr[6].eq {
	pc = 0x82A6BB3C; continue 'dispatch;
	}
	// 82A6BB34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A6BB38: 4B854D59  bl 0x822c0890
	ctx.lr = 0x82A6BB3C;
	sub_822C0890(ctx, base);
	// 82A6BB3C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A6BB40: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82A6BB44: 4873C66C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6BB48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6BB48 size=120
    let mut pc: u32 = 0x82A6BB48;
    'dispatch: loop {
        match pc {
            0x82A6BB48 => {
    //   block [0x82A6BB48..0x82A6BBC0)
	// 82A6BB48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6BB4C: 4873C621  bl 0x831a816c
	ctx.lr = 0x82A6BB50;
	sub_831A8130(ctx, base);
	// 82A6BB50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6BB54: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A6BB58: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A6BB5C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A6BB60: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A6BB64: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A6BB68: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82A6BB6C: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82A6BB70: 48386879  bl 0x82df23e8
	ctx.lr = 0x82A6BB74;
	sub_82DF23E8(ctx, base);
	// 82A6BB74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A6BB78: 41820014  beq 0x82a6bb8c
	if ctx.cr[0].eq {
	pc = 0x82A6BB8C; continue 'dispatch;
	}
	// 82A6BB7C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6BB80: 480EE881  bl 0x82b5a400
	ctx.lr = 0x82A6BB84;
	sub_82B5A400(ctx, base);
	// 82A6BB84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6BB88: 48000008  b 0x82a6bb90
	pc = 0x82A6BB90; continue 'dispatch;
	// 82A6BB8C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A6BB90: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A6BB94: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A6BB98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6BB9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6BBA0: 4BFFE219  bl 0x82a69db8
	ctx.lr = 0x82A6BBA4;
	sub_82A69DB8(ctx, base);
	// 82A6BBA4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A6BBA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6BBAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6BBB0: 4B854451  bl 0x822c0000
	ctx.lr = 0x82A6BBB4;
	sub_822C0000(ctx, base);
	// 82A6BBB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A6BBB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6BBBC: 4873C600  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6BBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6BBC0 size=124
    let mut pc: u32 = 0x82A6BBC0;
    'dispatch: loop {
        match pc {
            0x82A6BBC0 => {
    //   block [0x82A6BBC0..0x82A6BC3C)
	// 82A6BBC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6BBC4: 4873C5A9  bl 0x831a816c
	ctx.lr = 0x82A6BBC8;
	sub_831A8130(ctx, base);
	// 82A6BBC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6BBCC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A6BBD0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A6BBD4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A6BBD8: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A6BBDC: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82A6BBE0: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82A6BBE4: 48386805  bl 0x82df23e8
	ctx.lr = 0x82A6BBE8;
	sub_82DF23E8(ctx, base);
	// 82A6BBE8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A6BBEC: 4182001C  beq 0x82a6bc08
	if ctx.cr[0].eq {
	pc = 0x82A6BC08; continue 'dispatch;
	}
	// 82A6BBF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6BBF4: 483EDA8D  bl 0x82e59680
	ctx.lr = 0x82A6BBF8;
	sub_82E59680(ctx, base);
	// 82A6BBF8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6BBFC: 396BFF1C  addi r11, r11, -0xe4
	ctx.r[11].s64 = ctx.r[11].s64 + -228;
	// 82A6BC00: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A6BC04: 48000008  b 0x82a6bc0c
	pc = 0x82A6BC0C; continue 'dispatch;
	// 82A6BC08: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A6BC0C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A6BC10: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A6BC14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6BC18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6BC1C: 4BFFE265  bl 0x82a69e80
	ctx.lr = 0x82A6BC20;
	sub_82A69E80(ctx, base);
	// 82A6BC20: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A6BC24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6BC28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6BC2C: 4B8543D5  bl 0x822c0000
	ctx.lr = 0x82A6BC30;
	sub_822C0000(ctx, base);
	// 82A6BC30: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A6BC34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6BC38: 4873C584  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6BC40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6BC40 size=124
    let mut pc: u32 = 0x82A6BC40;
    'dispatch: loop {
        match pc {
            0x82A6BC40 => {
    //   block [0x82A6BC40..0x82A6BCBC)
	// 82A6BC40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6BC44: 4873C529  bl 0x831a816c
	ctx.lr = 0x82A6BC48;
	sub_831A8130(ctx, base);
	// 82A6BC48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6BC4C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A6BC50: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A6BC54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A6BC58: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A6BC5C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82A6BC60: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82A6BC64: 48386785  bl 0x82df23e8
	ctx.lr = 0x82A6BC68;
	sub_82DF23E8(ctx, base);
	// 82A6BC68: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A6BC6C: 4182001C  beq 0x82a6bc88
	if ctx.cr[0].eq {
	pc = 0x82A6BC88; continue 'dispatch;
	}
	// 82A6BC70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6BC74: 483EDA0D  bl 0x82e59680
	ctx.lr = 0x82A6BC78;
	sub_82E59680(ctx, base);
	// 82A6BC78: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6BC7C: 396BFF24  addi r11, r11, -0xdc
	ctx.r[11].s64 = ctx.r[11].s64 + -220;
	// 82A6BC80: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A6BC84: 48000008  b 0x82a6bc8c
	pc = 0x82A6BC8C; continue 'dispatch;
	// 82A6BC88: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A6BC8C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A6BC90: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A6BC94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6BC98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6BC9C: 4BFFE2AD  bl 0x82a69f48
	ctx.lr = 0x82A6BCA0;
	sub_82A69F48(ctx, base);
	// 82A6BCA0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A6BCA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6BCA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6BCAC: 4B854355  bl 0x822c0000
	ctx.lr = 0x82A6BCB0;
	sub_822C0000(ctx, base);
	// 82A6BCB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A6BCB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6BCB8: 4873C504  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6BCC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6BCC0 size=120
    let mut pc: u32 = 0x82A6BCC0;
    'dispatch: loop {
        match pc {
            0x82A6BCC0 => {
    //   block [0x82A6BCC0..0x82A6BD38)
	// 82A6BCC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6BCC4: 4873C4A9  bl 0x831a816c
	ctx.lr = 0x82A6BCC8;
	sub_831A8130(ctx, base);
	// 82A6BCC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6BCCC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A6BCD0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A6BCD4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A6BCD8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A6BCDC: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A6BCE0: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82A6BCE4: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82A6BCE8: 48386701  bl 0x82df23e8
	ctx.lr = 0x82A6BCEC;
	sub_82DF23E8(ctx, base);
	// 82A6BCEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A6BCF0: 41820014  beq 0x82a6bd04
	if ctx.cr[0].eq {
	pc = 0x82A6BD04; continue 'dispatch;
	}
	// 82A6BCF4: C03F0000  lfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A6BCF8: 480EE759  bl 0x82b5a450
	ctx.lr = 0x82A6BCFC;
	sub_82B5A450(ctx, base);
	// 82A6BCFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6BD00: 48000008  b 0x82a6bd08
	pc = 0x82A6BD08; continue 'dispatch;
	// 82A6BD04: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A6BD08: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A6BD0C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A6BD10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6BD14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6BD18: 4BFFE2F9  bl 0x82a6a010
	ctx.lr = 0x82A6BD1C;
	sub_82A6A010(ctx, base);
	// 82A6BD1C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A6BD20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6BD24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6BD28: 4B8542D9  bl 0x822c0000
	ctx.lr = 0x82A6BD2C;
	sub_822C0000(ctx, base);
	// 82A6BD2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A6BD30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6BD34: 4873C488  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6BD38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6BD38 size=112
    let mut pc: u32 = 0x82A6BD38;
    'dispatch: loop {
        match pc {
            0x82A6BD38 => {
    //   block [0x82A6BD38..0x82A6BDA8)
	// 82A6BD38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6BD3C: 4873C431  bl 0x831a816c
	ctx.lr = 0x82A6BD40;
	sub_831A8130(ctx, base);
	// 82A6BD40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6BD44: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A6BD48: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A6BD4C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A6BD50: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A6BD54: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82A6BD58: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82A6BD5C: 4838668D  bl 0x82df23e8
	ctx.lr = 0x82A6BD60;
	sub_82DF23E8(ctx, base);
	// 82A6BD60: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A6BD64: 41820010  beq 0x82a6bd74
	if ctx.cr[0].eq {
	pc = 0x82A6BD74; continue 'dispatch;
	}
	// 82A6BD68: 480EE739  bl 0x82b5a4a0
	ctx.lr = 0x82A6BD6C;
	sub_82B5A4A0(ctx, base);
	// 82A6BD6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6BD70: 48000008  b 0x82a6bd78
	pc = 0x82A6BD78; continue 'dispatch;
	// 82A6BD74: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A6BD78: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A6BD7C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A6BD80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6BD84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6BD88: 4BFFE351  bl 0x82a6a0d8
	ctx.lr = 0x82A6BD8C;
	sub_82A6A0D8(ctx, base);
	// 82A6BD8C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A6BD90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6BD94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6BD98: 4B854269  bl 0x822c0000
	ctx.lr = 0x82A6BD9C;
	sub_822C0000(ctx, base);
	// 82A6BD9C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A6BDA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6BDA4: 4873C418  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6BDA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6BDA8 size=132
    let mut pc: u32 = 0x82A6BDA8;
    'dispatch: loop {
        match pc {
            0x82A6BDA8 => {
    //   block [0x82A6BDA8..0x82A6BE2C)
	// 82A6BDA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6BDAC: 4873C3C1  bl 0x831a816c
	ctx.lr = 0x82A6BDB0;
	sub_831A8130(ctx, base);
	// 82A6BDB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6BDB4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A6BDB8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A6BDBC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A6BDC0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A6BDC4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A6BDC8: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A6BDCC: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82A6BDD0: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 82A6BDD4: 48386615  bl 0x82df23e8
	ctx.lr = 0x82A6BDD8;
	sub_82DF23E8(ctx, base);
	// 82A6BDD8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A6BDDC: 4182001C  beq 0x82a6bdf8
	if ctx.cr[0].eq {
	pc = 0x82A6BDF8; continue 'dispatch;
	}
	// 82A6BDE0: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 82A6BDE4: 88BE0000  lbz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6BDE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6BDEC: 480EFD05  bl 0x82b5baf0
	ctx.lr = 0x82A6BDF0;
	sub_82B5BAF0(ctx, base);
	// 82A6BDF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6BDF4: 48000008  b 0x82a6bdfc
	pc = 0x82A6BDFC; continue 'dispatch;
	// 82A6BDF8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A6BDFC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A6BE00: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A6BE04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6BE08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6BE0C: 4B9E20B5  bl 0x8244dec0
	ctx.lr = 0x82A6BE10;
	sub_8244DEC0(ctx, base);
	// 82A6BE10: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A6BE14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6BE18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6BE1C: 4B8541E5  bl 0x822c0000
	ctx.lr = 0x82A6BE20;
	sub_822C0000(ctx, base);
	// 82A6BE20: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A6BE24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6BE28: 4873C394  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6BE30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6BE30 size=124
    let mut pc: u32 = 0x82A6BE30;
    'dispatch: loop {
        match pc {
            0x82A6BE30 => {
    //   block [0x82A6BE30..0x82A6BEAC)
	// 82A6BE30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6BE34: 4873C339  bl 0x831a816c
	ctx.lr = 0x82A6BE38;
	sub_831A8130(ctx, base);
	// 82A6BE38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6BE3C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A6BE40: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A6BE44: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A6BE48: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A6BE4C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82A6BE50: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82A6BE54: 48386595  bl 0x82df23e8
	ctx.lr = 0x82A6BE58;
	sub_82DF23E8(ctx, base);
	// 82A6BE58: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A6BE5C: 4182001C  beq 0x82a6be78
	if ctx.cr[0].eq {
	pc = 0x82A6BE78; continue 'dispatch;
	}
	// 82A6BE60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6BE64: 483ED81D  bl 0x82e59680
	ctx.lr = 0x82A6BE68;
	sub_82E59680(ctx, base);
	// 82A6BE68: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6BE6C: 396BFF2C  addi r11, r11, -0xd4
	ctx.r[11].s64 = ctx.r[11].s64 + -212;
	// 82A6BE70: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A6BE74: 48000008  b 0x82a6be7c
	pc = 0x82A6BE7C; continue 'dispatch;
	// 82A6BE78: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A6BE7C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A6BE80: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A6BE84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6BE88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6BE8C: 4BFFE315  bl 0x82a6a1a0
	ctx.lr = 0x82A6BE90;
	sub_82A6A1A0(ctx, base);
	// 82A6BE90: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A6BE94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6BE98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6BE9C: 4B854165  bl 0x822c0000
	ctx.lr = 0x82A6BEA0;
	sub_822C0000(ctx, base);
	// 82A6BEA0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A6BEA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6BEA8: 4873C314  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6BEB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6BEB0 size=316
    let mut pc: u32 = 0x82A6BEB0;
    'dispatch: loop {
        match pc {
            0x82A6BEB0 => {
    //   block [0x82A6BEB0..0x82A6BFEC)
	// 82A6BEB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6BEB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6BEB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6BEBC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6BEC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6BEC4: 4BAA646D  bl 0x82512330
	ctx.lr = 0x82A6BEC8;
	sub_82512330(ctx, base);
	// 82A6BEC8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82A6BECC: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A6BED0: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A6BED4: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A6BED8: 38EBA214  addi r7, r11, -0x5dec
	ctx.r[7].s64 = ctx.r[11].s64 + -24044;
	// 82A6BEDC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A6BEE0: 394A002C  addi r10, r10, 0x2c
	ctx.r[10].s64 = ctx.r[10].s64 + 44;
	// 82A6BEE4: 90FF00E4  stw r7, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[7].u32 ) };
	// 82A6BEE8: 39290018  addi r9, r9, 0x18
	ctx.r[9].s64 = ctx.r[9].s64 + 24;
	// 82A6BEEC: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 82A6BEF0: 3908FFCC  addi r8, r8, -0x34
	ctx.r[8].s64 = ctx.r[8].s64 + -52;
	// 82A6BEF4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A6BEF8: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82A6BEFC: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 82A6BF00: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 82A6BF04: 395F01A0  addi r10, r31, 0x1a0
	ctx.r[10].s64 = ctx.r[31].s64 + 416;
	// 82A6BF08: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 82A6BF0C: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 82A6BF10: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 82A6BF14: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 82A6BF18: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 82A6BF1C: 90FF0100  stw r7, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[7].u32 ) };
	// 82A6BF20: 917F0164  stw r11, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[11].u32 ) };
	// 82A6BF24: 917F0168  stw r11, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[11].u32 ) };
	// 82A6BF28: 917F016C  stw r11, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[11].u32 ) };
	// 82A6BF2C: 917F0170  stw r11, 0x170(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), ctx.r[11].u32 ) };
	// 82A6BF30: 917F0188  stw r11, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[11].u32 ) };
	// 82A6BF34: 917F018C  stw r11, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[11].u32 ) };
	// 82A6BF38: 917F0190  stw r11, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[11].u32 ) };
	// 82A6BF3C: 917F0194  stw r11, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 82A6BF40: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A6BF44: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A6BF48: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A6BF4C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A6BF50: 4080FFF0  bge 0x82a6bf40
	if !ctx.cr[0].lt {
	pc = 0x82A6BF40; continue 'dispatch;
	}
	// 82A6BF54: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A6BF58: 39200200  li r9, 0x200
	ctx.r[9].s64 = 512;
	// 82A6BF5C: 390A6910  addi r8, r10, 0x6910
	ctx.r[8].s64 = ctx.r[10].s64 + 26896;
	// 82A6BF60: 38E00210  li r7, 0x210
	ctx.r[7].s64 = 528;
	// 82A6BF64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6BF68: 395F0280  addi r10, r31, 0x280
	ctx.r[10].s64 = ctx.r[31].s64 + 640;
	// 82A6BF6C: 395F028C  addi r10, r31, 0x28c
	ctx.r[10].s64 = ctx.r[31].s64 + 652;
	// 82A6BF70: 13E040C7  vcmpequd (lvx128) v31, v0, v8
	tmp.u32 = ctx.r[8].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6BFF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6BFF0 size=76
    let mut pc: u32 = 0x82A6BFF0;
    'dispatch: loop {
        match pc {
            0x82A6BFF0 => {
    //   block [0x82A6BFF0..0x82A6C03C)
	// 82A6BFF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6BFF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6BFF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6BFFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6C000: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6C004: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6C008: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A6C00C: 4BFFE775  bl 0x82a6a780
	ctx.lr = 0x82A6C010;
	sub_82A6A780(ctx, base);
	// 82A6C010: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6C014: 4182000C  beq 0x82a6c020
	if ctx.cr[0].eq {
	pc = 0x82A6C020; continue 'dispatch;
	}
	// 82A6C018: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6C01C: 483863BD  bl 0x82df23d8
	ctx.lr = 0x82A6C020;
	sub_82DF23D8(ctx, base);
	// 82A6C020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6C024: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6C028: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6C02C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6C030: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6C034: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6C038: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6C040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6C040 size=428
    let mut pc: u32 = 0x82A6C040;
    'dispatch: loop {
        match pc {
            0x82A6C040 => {
    //   block [0x82A6C040..0x82A6C1EC)
	// 82A6C040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6C044: 4873C129  bl 0x831a816c
	ctx.lr = 0x82A6C048;
	sub_831A8130(ctx, base);
	// 82A6C048: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6C04C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6C050: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6C054: 3BCB00BC  addi r30, r11, 0xbc
	ctx.r[30].s64 = ctx.r[11].s64 + 188;
	// 82A6C058: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A6C05C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A6C060: 483879A9  bl 0x82df3a08
	ctx.lr = 0x82A6C064;
	sub_82DF3A08(ctx, base);
	// 82A6C064: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A6C068: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C06C: 4838799D  bl 0x82df3a08
	ctx.lr = 0x82A6C070;
	sub_82DF3A08(ctx, base);
	// 82A6C070: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A6C074: 809F00F8  lwz r4, 0xf8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82A6C078: 4B865D09  bl 0x822d1d80
	ctx.lr = 0x82A6C07C;
	sub_822D1D80(ctx, base);
	// 82A6C07C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A6C080: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82A6C084: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A6C088: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A6C08C: 4B865E7D  bl 0x822d1f08
	ctx.lr = 0x82A6C090;
	sub_822D1F08(ctx, base);
	// 82A6C090: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A6C094: 3BDF0164  addi r30, r31, 0x164
	ctx.r[30].s64 = ctx.r[31].s64 + 356;
	// 82A6C098: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A6C09C: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82A6C0A0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C0A4: 917F0164  stw r11, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[11].u32 ) };
	// 82A6C0A8: 4B8583B9  bl 0x822c4460
	ctx.lr = 0x82A6C0AC;
	sub_822C4460(ctx, base);
	// 82A6C0AC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A6C0B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6C0B4: 419A0008  beq cr6, 0x82a6c0bc
	if ctx.cr[6].eq {
	pc = 0x82A6C0BC; continue 'dispatch;
	}
	// 82A6C0B8: 4B8547D9  bl 0x822c0890
	ctx.lr = 0x82A6C0BC;
	sub_822C0890(ctx, base);
	// 82A6C0BC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C0C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6C0C4: 419A0070  beq cr6, 0x82a6c134
	if ctx.cr[6].eq {
	pc = 0x82A6C134; continue 'dispatch;
	}
	// 82A6C0C8: 48392719  bl 0x82dfe7e0
	ctx.lr = 0x82A6C0CC;
	sub_82DFE7E0(ctx, base);
	// 82A6C0CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6C0D0: 40820064  bne 0x82a6c134
	if !ctx.cr[0].eq {
	pc = 0x82A6C134; continue 'dispatch;
	}
	// 82A6C0D4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6C0D8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C0DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6C0E0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A6C0E4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A6C0E8: 419A0024  beq cr6, 0x82a6c10c
	if ctx.cr[6].eq {
	pc = 0x82A6C10C; continue 'dispatch;
	}
	// 82A6C0EC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6C0F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6C0F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6C0F8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6C0FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6C100: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6C104: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6C108: 4082FFE8  bne 0x82a6c0f0
	if !ctx.cr[0].eq {
	pc = 0x82A6C0F0; continue 'dispatch;
	}
	// 82A6C10C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6C110: 4BA7E979  bl 0x824eaa88
	ctx.lr = 0x82A6C114;
	sub_824EAA88(ctx, base);
	// 82A6C114: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6C118: 38C00147  li r6, 0x147
	ctx.r[6].s64 = 327;
	// 82A6C11C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C120: 38AB0068  addi r5, r11, 0x68
	ctx.r[5].s64 = ctx.r[11].s64 + 104;
	// 82A6C124: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A6C128: 4814E059  bl 0x82bba180
	ctx.lr = 0x82A6C12C;
	sub_82BBA180(ctx, base);
	// 82A6C12C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6C130: 48385B61  bl 0x82df1c90
	ctx.lr = 0x82A6C134;
	sub_82DF1C90(ctx, base);
	// 82A6C134: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6C138: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C13C: 4B863265  bl 0x822cf3a0
	ctx.lr = 0x82A6C140;
	sub_822CF3A0(ctx, base);
	// 82A6C140: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A6C144: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A6C148: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C14C: 4B8636ED  bl 0x822cf838
	ctx.lr = 0x82A6C150;
	sub_822CF838(ctx, base);
	// 82A6C150: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A6C154: 3BDF016C  addi r30, r31, 0x16c
	ctx.r[30].s64 = ctx.r[31].s64 + 364;
	// 82A6C158: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A6C15C: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82A6C160: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C164: 917F016C  stw r11, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[11].u32 ) };
	// 82A6C168: 4B8582F9  bl 0x822c4460
	ctx.lr = 0x82A6C16C;
	sub_822C4460(ctx, base);
	// 82A6C16C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A6C170: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6C174: 419A0008  beq cr6, 0x82a6c17c
	if ctx.cr[6].eq {
	pc = 0x82A6C17C; continue 'dispatch;
	}
	// 82A6C178: 4B854719  bl 0x822c0890
	ctx.lr = 0x82A6C17C;
	sub_822C0890(ctx, base);
	// 82A6C17C: 3BBF0200  addi r29, r31, 0x200
	ctx.r[29].s64 = ctx.r[31].s64 + 512;
	// 82A6C180: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6C184: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A6C188: 4B863F61  bl 0x822d00e8
	ctx.lr = 0x82A6C18C;
	sub_822D00E8(ctx, base);
	// 82A6C18C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A6C190: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6C194: 4BAA58ED  bl 0x82511a80
	ctx.lr = 0x82A6C198;
	sub_82511A80(ctx, base);
	// 82A6C198: 39600210  li r11, 0x210
	ctx.r[11].s64 = 528;
	// 82A6C19C: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6C1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6C1F0 size=488
    let mut pc: u32 = 0x82A6C1F0;
    'dispatch: loop {
        match pc {
            0x82A6C1F0 => {
    //   block [0x82A6C1F0..0x82A6C3D8)
	// 82A6C1F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6C1F4: 4873BF79  bl 0x831a816c
	ctx.lr = 0x82A6C1F8;
	sub_831A8130(ctx, base);
	// 82A6C1F8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A6C1FC: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6C200: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A6C204: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6C208: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A6C20C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C210: 388B6C90  addi r4, r11, 0x6c90
	ctx.r[4].s64 = ctx.r[11].s64 + 27792;
	// 82A6C214: 483877F5  bl 0x82df3a08
	ctx.lr = 0x82A6C218;
	sub_82DF3A08(ctx, base);
	// 82A6C218: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A6C21C: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 82A6C220: 483EE4B1  bl 0x82e5a6d0
	ctx.lr = 0x82A6C224;
	sub_82E5A6D0(ctx, base);
	// 82A6C224: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A6C228: 48387079  bl 0x82df32a0
	ctx.lr = 0x82A6C22C;
	sub_82DF32A0(ctx, base);
	// 82A6C22C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A6C230: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C234: 483871F5  bl 0x82df3428
	ctx.lr = 0x82A6C238;
	sub_82DF3428(ctx, base);
	// 82A6C238: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6C23C: 41820010  beq 0x82a6c24c
	if ctx.cr[0].eq {
	pc = 0x82A6C24C; continue 'dispatch;
	}
	// 82A6C240: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6C244: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A6C248: 4BFFD879  bl 0x82a69ac0
	ctx.lr = 0x82A6C24C;
	sub_82A69AC0(ctx, base);
	// 82A6C24C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A6C250: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A6C254: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 82A6C258: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6C25C: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A6C260: C00A9534  lfs f0, -0x6acc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6C264: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A6C268: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A6C26C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A6C270: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A6C274: 4BAA5B25  bl 0x82511d98
	ctx.lr = 0x82A6C278;
	sub_82511D98(ctx, base);
	// 82A6C278: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A6C27C: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 82A6C280: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82A6C284: 4840FAC5  bl 0x82e7bd48
	ctx.lr = 0x82A6C288;
	sub_82E7BD48(ctx, base);
	// 82A6C288: 39600110  li r11, 0x110
	ctx.r[11].s64 = 272;
	// 82A6C28C: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6C3D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6C3D8 size=1304
    let mut pc: u32 = 0x82A6C3D8;
    'dispatch: loop {
        match pc {
            0x82A6C3D8 => {
    //   block [0x82A6C3D8..0x82A6C8F0)
	// 82A6C3D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6C3DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6C3E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6C3E4: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82A6C3E8: 4873C689  bl 0x831a8a70
	ctx.lr = 0x82A6C3EC;
	sub_831A8A40(ctx, base);
	// 82A6C3EC: 9421FBE0  stwu r1, -0x420(r1)
	ea = ctx.r[1].u32.wrapping_add(-1056 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6C3F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6C3F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A6C3F8: 419A04DC  beq cr6, 0x82a6c8d4
	if ctx.cr[6].eq {
	pc = 0x82A6C8D4; continue 'dispatch;
	}
	// 82A6C3FC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6C400: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C404: 388B01C8  addi r4, r11, 0x1c8
	ctx.r[4].s64 = ctx.r[11].s64 + 456;
	// 82A6C408: 48387601  bl 0x82df3a08
	ctx.lr = 0x82A6C40C;
	sub_82DF3A08(ctx, base);
	// 82A6C40C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A6C410: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82A6C414: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A6C418: 3D00832E  lis r8, -0x7cd2
	ctx.r[8].s64 = -2094137344;
	// 82A6C41C: 386102E0  addi r3, r1, 0x2e0
	ctx.r[3].s64 = ctx.r[1].s64 + 736;
	// 82A6C420: C36B08A8  lfs f27, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82A6C424: 38887DD8  addi r4, r8, 0x7dd8
	ctx.r[4].s64 = ctx.r[8].s64 + 32216;
	// 82A6C428: C3AADD6C  lfs f29, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82A6C42C: FC60D890  fmr f3, f27
	ctx.f[3].f64 = ctx.f[27].f64;
	// 82A6C430: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A6C434: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82A6C438: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6C43C: 4BB36D75  bl 0x825a31b0
	ctx.lr = 0x82A6C440;
	sub_825A31B0(ctx, base);
	// 82A6C440: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A6C444: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6C448: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6C44C: 4BB35325  bl 0x825a1770
	ctx.lr = 0x82A6C450;
	sub_825A1770(ctx, base);
	// 82A6C450: 38610318  addi r3, r1, 0x318
	ctx.r[3].s64 = ctx.r[1].s64 + 792;
	// 82A6C454: 48386FD5  bl 0x82df3428
	ctx.lr = 0x82A6C458;
	sub_82DF3428(ctx, base);
	// 82A6C458: 386102F8  addi r3, r1, 0x2f8
	ctx.r[3].s64 = ctx.r[1].s64 + 760;
	// 82A6C45C: 4B85C85D  bl 0x822c8cb8
	ctx.lr = 0x82A6C460;
	sub_822C8CB8(ctx, base);
	// 82A6C460: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C464: 48386FC5  bl 0x82df3428
	ctx.lr = 0x82A6C468;
	sub_82DF3428(ctx, base);
	// 82A6C468: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6C46C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C470: 388B01BC  addi r4, r11, 0x1bc
	ctx.r[4].s64 = ctx.r[11].s64 + 444;
	// 82A6C474: 48387595  bl 0x82df3a08
	ctx.lr = 0x82A6C478;
	sub_82DF3A08(ctx, base);
	// 82A6C478: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A6C47C: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A6C480: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6C484: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82A6C488: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82A6C48C: 388A7DDC  addi r4, r10, 0x7ddc
	ctx.r[4].s64 = ctx.r[10].s64 + 32220;
	// 82A6C490: C3CB89AC  lfs f30, -0x7654(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A6C494: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82A6C498: 4BB36D19  bl 0x825a31b0
	ctx.lr = 0x82A6C49C;
	sub_825A31B0(ctx, base);
	// 82A6C49C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A6C4A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6C4A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6C4A8: 4BB352C9  bl 0x825a1770
	ctx.lr = 0x82A6C4AC;
	sub_825A1770(ctx, base);
	// 82A6C4AC: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 82A6C4B0: 48386F79  bl 0x82df3428
	ctx.lr = 0x82A6C4B4;
	sub_82DF3428(ctx, base);
	// 82A6C4B4: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82A6C4B8: 4B85C801  bl 0x822c8cb8
	ctx.lr = 0x82A6C4BC;
	sub_822C8CB8(ctx, base);
	// 82A6C4BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C4C0: 48386F69  bl 0x82df3428
	ctx.lr = 0x82A6C4C4;
	sub_82DF3428(ctx, base);
	// 82A6C4C4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6C4C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C4CC: 388B01AC  addi r4, r11, 0x1ac
	ctx.r[4].s64 = ctx.r[11].s64 + 428;
	// 82A6C4D0: 48387539  bl 0x82df3a08
	ctx.lr = 0x82A6C4D4;
	sub_82DF3A08(ctx, base);
	// 82A6C4D4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82A6C4D8: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A6C4DC: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82A6C4E0: 38610260  addi r3, r1, 0x260
	ctx.r[3].s64 = ctx.r[1].s64 + 608;
	// 82A6C4E4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6C4E8: 388A7DE0  addi r4, r10, 0x7de0
	ctx.r[4].s64 = ctx.r[10].s64 + 32224;
	// 82A6C4EC: C38B69B8  lfs f28, 0x69b8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27064 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82A6C4F0: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 82A6C4F4: 4BB36CBD  bl 0x825a31b0
	ctx.lr = 0x82A6C4F8;
	sub_825A31B0(ctx, base);
	// 82A6C4F8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A6C4FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6C500: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6C504: 4BB3526D  bl 0x825a1770
	ctx.lr = 0x82A6C508;
	sub_825A1770(ctx, base);
	// 82A6C508: 38610298  addi r3, r1, 0x298
	ctx.r[3].s64 = ctx.r[1].s64 + 664;
	// 82A6C50C: 48386F1D  bl 0x82df3428
	ctx.lr = 0x82A6C510;
	sub_82DF3428(ctx, base);
	// 82A6C510: 38610278  addi r3, r1, 0x278
	ctx.r[3].s64 = ctx.r[1].s64 + 632;
	// 82A6C514: 4B85C7A5  bl 0x822c8cb8
	ctx.lr = 0x82A6C518;
	sub_822C8CB8(ctx, base);
	// 82A6C518: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C51C: 48386F0D  bl 0x82df3428
	ctx.lr = 0x82A6C520;
	sub_82DF3428(ctx, base);
	// 82A6C520: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6C524: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C528: 388B0194  addi r4, r11, 0x194
	ctx.r[4].s64 = ctx.r[11].s64 + 404;
	// 82A6C52C: 483874DD  bl 0x82df3a08
	ctx.lr = 0x82A6C530;
	sub_82DF3A08(ctx, base);
	// 82A6C530: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6C534: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 82A6C538: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82A6C53C: 388B7DE4  addi r4, r11, 0x7de4
	ctx.r[4].s64 = ctx.r[11].s64 + 32228;
	// 82A6C540: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6C544: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 82A6C548: 4BB36C69  bl 0x825a31b0
	ctx.lr = 0x82A6C54C;
	sub_825A31B0(ctx, base);
	// 82A6C54C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A6C550: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6C554: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6C558: 4BB35219  bl 0x825a1770
	ctx.lr = 0x82A6C55C;
	sub_825A1770(ctx, base);
	// 82A6C55C: 38610198  addi r3, r1, 0x198
	ctx.r[3].s64 = ctx.r[1].s64 + 408;
	// 82A6C560: 48386EC9  bl 0x82df3428
	ctx.lr = 0x82A6C564;
	sub_82DF3428(ctx, base);
	// 82A6C564: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 82A6C568: 4B85C751  bl 0x822c8cb8
	ctx.lr = 0x82A6C56C;
	sub_822C8CB8(ctx, base);
	// 82A6C56C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C570: 48386EB9  bl 0x82df3428
	ctx.lr = 0x82A6C574;
	sub_82DF3428(ctx, base);
	// 82A6C574: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6C578: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C57C: 388B017C  addi r4, r11, 0x17c
	ctx.r[4].s64 = ctx.r[11].s64 + 380;
	// 82A6C580: 48387489  bl 0x82df3a08
	ctx.lr = 0x82A6C584;
	sub_82DF3A08(ctx, base);
	// 82A6C584: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A6C588: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A6C58C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6C590: 38610360  addi r3, r1, 0x360
	ctx.r[3].s64 = ctx.r[1].s64 + 864;
	// 82A6C594: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82A6C598: 388A7DE8  addi r4, r10, 0x7de8
	ctx.r[4].s64 = ctx.r[10].s64 + 32232;
	// 82A6C59C: C38B964C  lfs f28, -0x69b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82A6C5A0: FC60E090  fmr f3, f28
	ctx.f[3].f64 = ctx.f[28].f64;
	// 82A6C5A4: 4BB36C0D  bl 0x825a31b0
	ctx.lr = 0x82A6C5A8;
	sub_825A31B0(ctx, base);
	// 82A6C5A8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A6C5AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6C5B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6C5B4: 4BB351BD  bl 0x825a1770
	ctx.lr = 0x82A6C5B8;
	sub_825A1770(ctx, base);
	// 82A6C5B8: 38610398  addi r3, r1, 0x398
	ctx.r[3].s64 = ctx.r[1].s64 + 920;
	// 82A6C5BC: 48386E6D  bl 0x82df3428
	ctx.lr = 0x82A6C5C0;
	sub_82DF3428(ctx, base);
	// 82A6C5C0: 38610378  addi r3, r1, 0x378
	ctx.r[3].s64 = ctx.r[1].s64 + 888;
	// 82A6C5C4: 4B85C6F5  bl 0x822c8cb8
	ctx.lr = 0x82A6C5C8;
	sub_822C8CB8(ctx, base);
	// 82A6C5C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C5CC: 48386E5D  bl 0x82df3428
	ctx.lr = 0x82A6C5D0;
	sub_82DF3428(ctx, base);
	// 82A6C5D0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6C5D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C5D8: 388B0168  addi r4, r11, 0x168
	ctx.r[4].s64 = ctx.r[11].s64 + 360;
	// 82A6C5DC: 4838742D  bl 0x82df3a08
	ctx.lr = 0x82A6C5E0;
	sub_82DF3A08(ctx, base);
	// 82A6C5E0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82A6C5E4: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A6C5E8: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 82A6C5EC: 386101E0  addi r3, r1, 0x1e0
	ctx.r[3].s64 = ctx.r[1].s64 + 480;
	// 82A6C5F0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6C5F4: 388A7DEC  addi r4, r10, 0x7dec
	ctx.r[4].s64 = ctx.r[10].s64 + 32236;
	// 82A6C5F8: C34B6218  lfs f26, 0x6218(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82A6C5FC: FC40D090  fmr f2, f26
	ctx.f[2].f64 = ctx.f[26].f64;
	// 82A6C600: 4BB36BB1  bl 0x825a31b0
	ctx.lr = 0x82A6C604;
	sub_825A31B0(ctx, base);
	// 82A6C604: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A6C608: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6C60C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6C610: 4BB35161  bl 0x825a1770
	ctx.lr = 0x82A6C614;
	sub_825A1770(ctx, base);
	// 82A6C614: 38610218  addi r3, r1, 0x218
	ctx.r[3].s64 = ctx.r[1].s64 + 536;
	// 82A6C618: 48386E11  bl 0x82df3428
	ctx.lr = 0x82A6C61C;
	sub_82DF3428(ctx, base);
	// 82A6C61C: 386101F8  addi r3, r1, 0x1f8
	ctx.r[3].s64 = ctx.r[1].s64 + 504;
	// 82A6C620: 4B85C699  bl 0x822c8cb8
	ctx.lr = 0x82A6C624;
	sub_822C8CB8(ctx, base);
	// 82A6C624: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C628: 48386E01  bl 0x82df3428
	ctx.lr = 0x82A6C62C;
	sub_82DF3428(ctx, base);
	// 82A6C62C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6C630: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C634: 388B0154  addi r4, r11, 0x154
	ctx.r[4].s64 = ctx.r[11].s64 + 340;
	// 82A6C638: 483873D1  bl 0x82df3a08
	ctx.lr = 0x82A6C63C;
	sub_82DF3A08(ctx, base);
	// 82A6C63C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6C640: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A6C644: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 82A6C648: 388B7DF0  addi r4, r11, 0x7df0
	ctx.r[4].s64 = ctx.r[11].s64 + 32240;
	// 82A6C64C: FC40D090  fmr f2, f26
	ctx.f[2].f64 = ctx.f[26].f64;
	// 82A6C650: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6C654: 4BB36B5D  bl 0x825a31b0
	ctx.lr = 0x82A6C658;
	sub_825A31B0(ctx, base);
	// 82A6C658: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A6C65C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6C660: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6C664: 4BB3510D  bl 0x825a1770
	ctx.lr = 0x82A6C668;
	sub_825A1770(ctx, base);
	// 82A6C668: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A6C66C: 48386DBD  bl 0x82df3428
	ctx.lr = 0x82A6C670;
	sub_82DF3428(ctx, base);
	// 82A6C670: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A6C674: 4B85C645  bl 0x822c8cb8
	ctx.lr = 0x82A6C678;
	sub_822C8CB8(ctx, base);
	// 82A6C678: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C67C: 48386DAD  bl 0x82df3428
	ctx.lr = 0x82A6C680;
	sub_82DF3428(ctx, base);
	// 82A6C680: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6C684: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C688: 388B0148  addi r4, r11, 0x148
	ctx.r[4].s64 = ctx.r[11].s64 + 328;
	// 82A6C68C: 4838737D  bl 0x82df3a08
	ctx.lr = 0x82A6C690;
	sub_82DF3A08(ctx, base);
	// 82A6C690: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6C694: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A6C698: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82A6C69C: 388B7DF4  addi r4, r11, 0x7df4
	ctx.r[4].s64 = ctx.r[11].s64 + 32244;
	// 82A6C6A0: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82A6C6A4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6C6A8: 4BB36B09  bl 0x825a31b0
	ctx.lr = 0x82A6C6AC;
	sub_825A31B0(ctx, base);
	// 82A6C6AC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A6C6B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6C6B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6C6B8: 4BB350B9  bl 0x825a1770
	ctx.lr = 0x82A6C6BC;
	sub_825A1770(ctx, base);
	// 82A6C6BC: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82A6C6C0: 48386D69  bl 0x82df3428
	ctx.lr = 0x82A6C6C4;
	sub_82DF3428(ctx, base);
	// 82A6C6C4: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A6C6C8: 4B85C5F1  bl 0x822c8cb8
	ctx.lr = 0x82A6C6CC;
	sub_822C8CB8(ctx, base);
	// 82A6C6CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C6D0: 48386D59  bl 0x82df3428
	ctx.lr = 0x82A6C6D4;
	sub_82DF3428(ctx, base);
	// 82A6C6D4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6C6D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C6DC: 388B013C  addi r4, r11, 0x13c
	ctx.r[4].s64 = ctx.r[11].s64 + 316;
	// 82A6C6E0: 48387329  bl 0x82df3a08
	ctx.lr = 0x82A6C6E4;
	sub_82DF3A08(ctx, base);
	// 82A6C6E4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6C6E8: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82A6C6EC: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82A6C6F0: 388B7DF8  addi r4, r11, 0x7df8
	ctx.r[4].s64 = ctx.r[11].s64 + 32248;
	// 82A6C6F4: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82A6C6F8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6C6FC: 4BB36AB5  bl 0x825a31b0
	ctx.lr = 0x82A6C700;
	sub_825A31B0(ctx, base);
	// 82A6C700: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A6C704: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6C708: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6C70C: 4BB35065  bl 0x825a1770
	ctx.lr = 0x82A6C710;
	sub_825A1770(ctx, base);
	// 82A6C710: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 82A6C714: 48386D15  bl 0x82df3428
	ctx.lr = 0x82A6C718;
	sub_82DF3428(ctx, base);
	// 82A6C718: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 82A6C71C: 4B85C59D  bl 0x822c8cb8
	ctx.lr = 0x82A6C720;
	sub_822C8CB8(ctx, base);
	// 82A6C720: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C724: 48386D05  bl 0x82df3428
	ctx.lr = 0x82A6C728;
	sub_82DF3428(ctx, base);
	// 82A6C728: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6C72C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C730: 388B0130  addi r4, r11, 0x130
	ctx.r[4].s64 = ctx.r[11].s64 + 304;
	// 82A6C734: 483872D5  bl 0x82df3a08
	ctx.lr = 0x82A6C738;
	sub_82DF3A08(ctx, base);
	// 82A6C738: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6C73C: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 82A6C740: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6C744: 388B7DFC  addi r4, r11, 0x7dfc
	ctx.r[4].s64 = ctx.r[11].s64 + 32252;
	// 82A6C748: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82A6C74C: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82A6C750: 4BB36A61  bl 0x825a31b0
	ctx.lr = 0x82A6C754;
	sub_825A31B0(ctx, base);
	// 82A6C754: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A6C758: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6C75C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6C760: 4BB35011  bl 0x825a1770
	ctx.lr = 0x82A6C764;
	sub_825A1770(ctx, base);
	// 82A6C764: 386101D8  addi r3, r1, 0x1d8
	ctx.r[3].s64 = ctx.r[1].s64 + 472;
	// 82A6C768: 48386CC1  bl 0x82df3428
	ctx.lr = 0x82A6C76C;
	sub_82DF3428(ctx, base);
	// 82A6C76C: 386101B8  addi r3, r1, 0x1b8
	ctx.r[3].s64 = ctx.r[1].s64 + 440;
	// 82A6C770: 4B85C549  bl 0x822c8cb8
	ctx.lr = 0x82A6C774;
	sub_822C8CB8(ctx, base);
	// 82A6C774: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C778: 48386CB1  bl 0x82df3428
	ctx.lr = 0x82A6C77C;
	sub_82DF3428(ctx, base);
	// 82A6C77C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6C780: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C784: 388B011C  addi r4, r11, 0x11c
	ctx.r[4].s64 = ctx.r[11].s64 + 284;
	// 82A6C788: 48387281  bl 0x82df3a08
	ctx.lr = 0x82A6C78C;
	sub_82DF3A08(ctx, base);
	// 82A6C78C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6C790: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A6C794: FC40D890  fmr f2, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[27].f64;
	// 82A6C798: 38610220  addi r3, r1, 0x220
	ctx.r[3].s64 = ctx.r[1].s64 + 544;
	// 82A6C79C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6C7A0: 388A7E00  addi r4, r10, 0x7e00
	ctx.r[4].s64 = ctx.r[10].s64 + 32256;
	// 82A6C7A4: C06BFE60  lfs f3, -0x1a0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-416 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82A6C7A8: 4BB36A09  bl 0x825a31b0
	ctx.lr = 0x82A6C7AC;
	sub_825A31B0(ctx, base);
	// 82A6C7AC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A6C7B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6C7B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6C7B8: 4BB34FB9  bl 0x825a1770
	ctx.lr = 0x82A6C7BC;
	sub_825A1770(ctx, base);
	// 82A6C7BC: 38610258  addi r3, r1, 0x258
	ctx.r[3].s64 = ctx.r[1].s64 + 600;
	// 82A6C7C0: 48386C69  bl 0x82df3428
	ctx.lr = 0x82A6C7C4;
	sub_82DF3428(ctx, base);
	// 82A6C7C4: 38610238  addi r3, r1, 0x238
	ctx.r[3].s64 = ctx.r[1].s64 + 568;
	// 82A6C7C8: 4B85C4F1  bl 0x822c8cb8
	ctx.lr = 0x82A6C7CC;
	sub_822C8CB8(ctx, base);
	// 82A6C7CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C7D0: 48386C59  bl 0x82df3428
	ctx.lr = 0x82A6C7D4;
	sub_82DF3428(ctx, base);
	// 82A6C7D4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6C7D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C7DC: 388B0104  addi r4, r11, 0x104
	ctx.r[4].s64 = ctx.r[11].s64 + 260;
	// 82A6C7E0: 48387229  bl 0x82df3a08
	ctx.lr = 0x82A6C7E4;
	sub_82DF3A08(ctx, base);
	// 82A6C7E4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6C7E8: 386102A0  addi r3, r1, 0x2a0
	ctx.r[3].s64 = ctx.r[1].s64 + 672;
	// 82A6C7EC: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 82A6C7F0: 388B7E04  addi r4, r11, 0x7e04
	ctx.r[4].s64 = ctx.r[11].s64 + 32260;
	// 82A6C7F4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82A6C7F8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6C7FC: 4BB369B5  bl 0x825a31b0
	ctx.lr = 0x82A6C800;
	sub_825A31B0(ctx, base);
	// 82A6C800: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A6C804: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6C808: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6C80C: 4BB34F65  bl 0x825a1770
	ctx.lr = 0x82A6C810;
	sub_825A1770(ctx, base);
	// 82A6C810: 386102D8  addi r3, r1, 0x2d8
	ctx.r[3].s64 = ctx.r[1].s64 + 728;
	// 82A6C814: 48386C15  bl 0x82df3428
	ctx.lr = 0x82A6C818;
	sub_82DF3428(ctx, base);
	// 82A6C818: 386102B8  addi r3, r1, 0x2b8
	ctx.r[3].s64 = ctx.r[1].s64 + 696;
	// 82A6C81C: 4B85C49D  bl 0x822c8cb8
	ctx.lr = 0x82A6C820;
	sub_822C8CB8(ctx, base);
	// 82A6C820: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C824: 48386C05  bl 0x82df3428
	ctx.lr = 0x82A6C828;
	sub_82DF3428(ctx, base);
	// 82A6C828: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6C82C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C830: 388B00F0  addi r4, r11, 0xf0
	ctx.r[4].s64 = ctx.r[11].s64 + 240;
	// 82A6C834: 483871D5  bl 0x82df3a08
	ctx.lr = 0x82A6C838;
	sub_82DF3A08(ctx, base);
	// 82A6C838: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6C83C: 38610320  addi r3, r1, 0x320
	ctx.r[3].s64 = ctx.r[1].s64 + 800;
	// 82A6C840: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6C844: 388B7E08  addi r4, r11, 0x7e08
	ctx.r[4].s64 = ctx.r[11].s64 + 32264;
	// 82A6C848: FC60E090  fmr f3, f28
	ctx.f[3].f64 = ctx.f[28].f64;
	// 82A6C84C: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 82A6C850: 4BB36961  bl 0x825a31b0
	ctx.lr = 0x82A6C854;
	sub_825A31B0(ctx, base);
	// 82A6C854: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A6C858: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6C85C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6C860: 4BB34F11  bl 0x825a1770
	ctx.lr = 0x82A6C864;
	sub_825A1770(ctx, base);
	// 82A6C864: 38610358  addi r3, r1, 0x358
	ctx.r[3].s64 = ctx.r[1].s64 + 856;
	// 82A6C868: 48386BC1  bl 0x82df3428
	ctx.lr = 0x82A6C86C;
	sub_82DF3428(ctx, base);
	// 82A6C86C: 38610338  addi r3, r1, 0x338
	ctx.r[3].s64 = ctx.r[1].s64 + 824;
	// 82A6C870: 4B85C449  bl 0x822c8cb8
	ctx.lr = 0x82A6C874;
	sub_822C8CB8(ctx, base);
	// 82A6C874: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C878: 48386BB1  bl 0x82df3428
	ctx.lr = 0x82A6C87C;
	sub_82DF3428(ctx, base);
	// 82A6C87C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6C880: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C884: 388B00D0  addi r4, r11, 0xd0
	ctx.r[4].s64 = ctx.r[11].s64 + 208;
	// 82A6C888: 48387181  bl 0x82df3a08
	ctx.lr = 0x82A6C88C;
	sub_82DF3A08(ctx, base);
	// 82A6C88C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A6C890: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A6C894: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82A6C898: 386103A0  addi r3, r1, 0x3a0
	ctx.r[3].s64 = ctx.r[1].s64 + 928;
	// 82A6C89C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6C8A0: 388A7E0C  addi r4, r10, 0x7e0c
	ctx.r[4].s64 = ctx.r[10].s64 + 32268;
	// 82A6C8A4: C04BE0B4  lfs f2, -0x1f4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8012 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A6C8A8: 4BB36909  bl 0x825a31b0
	ctx.lr = 0x82A6C8AC;
	sub_825A31B0(ctx, base);
	// 82A6C8AC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A6C8B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6C8B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6C8B8: 4BB34EB9  bl 0x825a1770
	ctx.lr = 0x82A6C8BC;
	sub_825A1770(ctx, base);
	// 82A6C8BC: 386103D8  addi r3, r1, 0x3d8
	ctx.r[3].s64 = ctx.r[1].s64 + 984;
	// 82A6C8C0: 48386B69  bl 0x82df3428
	ctx.lr = 0x82A6C8C4;
	sub_82DF3428(ctx, base);
	// 82A6C8C4: 386103B8  addi r3, r1, 0x3b8
	ctx.r[3].s64 = ctx.r[1].s64 + 952;
	// 82A6C8C8: 4B85C3F1  bl 0x822c8cb8
	ctx.lr = 0x82A6C8CC;
	sub_822C8CB8(ctx, base);
	// 82A6C8CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C8D0: 48386B59  bl 0x82df3428
	ctx.lr = 0x82A6C8D4;
	sub_82DF3428(ctx, base);
	// 82A6C8D4: 38210420  addi r1, r1, 0x420
	ctx.r[1].s64 = ctx.r[1].s64 + 1056;
	// 82A6C8D8: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82A6C8DC: 4873C1E1  bl 0x831a8abc
	ctx.lr = 0x82A6C8E0;
	sub_831A8A8C(ctx, base);
	// 82A6C8E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6C8E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6C8E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6C8EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6C8F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6C8F0 size=448
    let mut pc: u32 = 0x82A6C8F0;
    'dispatch: loop {
        match pc {
            0x82A6C8F0 => {
    //   block [0x82A6C8F0..0x82A6CAB0)
	// 82A6C8F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6C8F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6C8F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6C8FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6C900: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A6C904: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6C908: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6C90C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A6C910: 4BFFC869  bl 0x82a69178
	ctx.lr = 0x82A6C914;
	sub_82A69178(ctx, base);
	// 82A6C914: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6C918: 4182017C  beq 0x82a6ca94
	if ctx.cr[0].eq {
	pc = 0x82A6CA94; continue 'dispatch;
	}
	// 82A6C91C: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A6C920: 895F0185  lbz r10, 0x185(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(389 as u32) ) } as u64;
	// 82A6C924: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A6C928: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82A6C92C: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A6C930: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82A6C934: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82A6C938: 41820020  beq 0x82a6c958
	if ctx.cr[0].eq {
	pc = 0x82A6C958; continue 'dispatch;
	}
	// 82A6C93C: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A6C940: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A6C944: 995F0184  stb r10, 0x184(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[10].u8 ) };
	// 82A6C948: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82A6C94C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A6C950: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82A6C954: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82A6C958: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6C95C: C19F0104  lfs f12, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A6C960: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A6C964: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6C968: C00B7E08  lfs f0, 0x7e08(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6C96C: EC00637C  fnmsubs f0, f0, f13, f12
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82A6C970: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A6C974: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82A6C978: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A6C97C: 41990038  bgt cr6, 0x82a6c9b4
	if ctx.cr[6].gt {
	pc = 0x82A6C9B4; continue 'dispatch;
	}
	// 82A6C980: D3FF0104  stfs f31, 0x104(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82A6C984: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82A6C988: 388B60C8  addi r4, r11, 0x60c8
	ctx.r[4].s64 = ctx.r[11].s64 + 24776;
	// 82A6C98C: 4838707D  bl 0x82df3a08
	ctx.lr = 0x82A6C990;
	sub_82DF3A08(ctx, base);
	// 82A6C990: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A6C994: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A6C998: 809F00EC  lwz r4, 0xec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A6C99C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A6C9A0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6C9A4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A6C9A8: 483F1FB9  bl 0x82e5e960
	ctx.lr = 0x82A6C9AC;
	sub_82E5E960(ctx, base);
	// 82A6C9AC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A6C9B0: 48000030  b 0x82a6c9e0
	pc = 0x82A6C9E0; continue 'dispatch;
	// 82A6C9B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A6C9B8: 388B0740  addi r4, r11, 0x740
	ctx.r[4].s64 = ctx.r[11].s64 + 1856;
	// 82A6C9BC: 4838704D  bl 0x82df3a08
	ctx.lr = 0x82A6C9C0;
	sub_82DF3A08(ctx, base);
	// 82A6C9C0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A6C9C4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A6C9C8: 809F00EC  lwz r4, 0xec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A6C9CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A6C9D0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6C9D4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A6C9D8: 483F1F89  bl 0x82e5e960
	ctx.lr = 0x82A6C9DC;
	sub_82E5E960(ctx, base);
	// 82A6C9DC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A6C9E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6C9E4: 419A0008  beq cr6, 0x82a6c9ec
	if ctx.cr[6].eq {
	pc = 0x82A6C9EC; continue 'dispatch;
	}
	// 82A6C9E8: 4B853EA9  bl 0x822c0890
	ctx.lr = 0x82A6C9EC;
	sub_822C0890(ctx, base);
	// 82A6C9EC: 389E0030  addi r4, r30, 0x30
	ctx.r[4].s64 = ctx.r[30].s64 + 48;
	// 82A6C9F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6C9F4: 4BFFDB75  bl 0x82a6a568
	ctx.lr = 0x82A6C9F8;
	sub_82A6A568(ctx, base);
	// 82A6C9F8: 987F0130  stb r3, 0x130(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[3].u8 ) };
	// 82A6C9FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6CA00: 4BAA50E9  bl 0x82511ae8
	ctx.lr = 0x82A6CA04;
	sub_82511AE8(ctx, base);
	// 82A6CA04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6CA08: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6CA0C: 4BB7AC25  bl 0x825e7630
	ctx.lr = 0x82A6CA10;
	sub_825E7630(ctx, base);
	// 82A6CA10: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6CA14: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A6CA18: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6CA1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6CA20: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A6CA24: 419A0024  beq cr6, 0x82a6ca48
	if ctx.cr[6].eq {
	pc = 0x82A6CA48; continue 'dispatch;
	}
	// 82A6CA28: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6CA2C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6CA30: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6CA34: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6CA38: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6CA3C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6CA40: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6CA44: 4082FFE8  bne 0x82a6ca2c
	if !ctx.cr[0].eq {
	pc = 0x82A6CA2C; continue 'dispatch;
	}
	// 82A6CA48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6CA4C: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82A6CA50: 4859B6D9  bl 0x83008128
	ctx.lr = 0x82A6CA54;
	sub_83008128(ctx, base);
	// 82A6CA54: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6CA58: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A6CA5C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6CA60: 388B0068  addi r4, r11, 0x68
	ctx.r[4].s64 = ctx.r[11].s64 + 104;
	// 82A6CA64: 38A00340  li r5, 0x340
	ctx.r[5].s64 = 832;
	// 82A6CA68: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A6CA6C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A6CA70: 483EBFD1  bl 0x82e58a40
	ctx.lr = 0x82A6CA74;
	sub_82E58A40(ctx, base);
	// 82A6CA74: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6CA78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6CA7C: 419A0008  beq cr6, 0x82a6ca84
	if ctx.cr[6].eq {
	pc = 0x82A6CA84; continue 'dispatch;
	}
	// 82A6CA80: 4B853E11  bl 0x822c0890
	ctx.lr = 0x82A6CA84;
	sub_822C0890(ctx, base);
	// 82A6CA84: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A6CA88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6CA8C: 419A0008  beq cr6, 0x82a6ca94
	if ctx.cr[6].eq {
	pc = 0x82A6CA94; continue 'dispatch;
	}
	// 82A6CA90: 4B853E01  bl 0x822c0890
	ctx.lr = 0x82A6CA94;
	sub_822C0890(ctx, base);
	// 82A6CA94: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A6CA98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6CA9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6CAA0: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A6CAA4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6CAA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6CAAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6CAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6CAB0 size=456
    let mut pc: u32 = 0x82A6CAB0;
    'dispatch: loop {
        match pc {
            0x82A6CAB0 => {
    //   block [0x82A6CAB0..0x82A6CC78)
	// 82A6CAB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6CAB4: 4873B6B1  bl 0x831a8164
	ctx.lr = 0x82A6CAB8;
	sub_831A8130(ctx, base);
	// 82A6CAB8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A6CABC: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6CAC0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A6CAC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6CAC8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82A6CACC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A6CAD0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A6CAD4: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A6CAD8: 48002CC1  bl 0x82a6f798
	ctx.lr = 0x82A6CADC;
	sub_82A6F798(ctx, base);
	// 82A6CADC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6CAE0: 4182018C  beq 0x82a6cc6c
	if ctx.cr[0].eq {
	pc = 0x82A6CC6C; continue 'dispatch;
	}
	// 82A6CAE4: 3960000A  li r11, 0xa
	ctx.r[11].s64 = 10;
	// 82A6CAE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6CAEC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A6CAF0: 4BAA4FF9  bl 0x82511ae8
	ctx.lr = 0x82A6CAF4;
	sub_82511AE8(ctx, base);
	// 82A6CAF4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A6CAF8: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82A6CAFC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A6CB00: 38EB6910  addi r7, r11, 0x6910
	ctx.r[7].s64 = ctx.r[11].s64 + 26896;
	// 82A6CB04: 388A861C  addi r4, r10, -0x79e4
	ctx.r[4].s64 = ctx.r[10].s64 + -31204;
	// 82A6CB08: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82A6CB0C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6CB10: 4B9AA8B1  bl 0x824173c0
	ctx.lr = 0x82A6CB14;
	sub_824173C0(ctx, base);
	// 82A6CB14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6CB18: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A6CB1C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6CB20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6CB24: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A6CB28: 419A0024  beq cr6, 0x82a6cb4c
	if ctx.cr[6].eq {
	pc = 0x82A6CB4C; continue 'dispatch;
	}
	// 82A6CB2C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6CB30: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6CB34: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6CB38: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6CB3C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6CB40: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6CB44: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6CB48: 4082FFE8  bne 0x82a6cb30
	if !ctx.cr[0].eq {
	pc = 0x82A6CB30; continue 'dispatch;
	}
	// 82A6CB4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6CB50: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 82A6CB54: 3B610058  addi r27, r1, 0x58
	ctx.r[27].s64 = ctx.r[1].s64 + 88;
	// 82A6CB58: 4859B5D1  bl 0x83008128
	ctx.lr = 0x82A6CB5C;
	sub_83008128(ctx, base);
	// 82A6CB5C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6CB60: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A6CB64: 3BAB0068  addi r29, r11, 0x68
	ctx.r[29].s64 = ctx.r[11].s64 + 104;
	// 82A6CB68: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A6CB6C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A6CB70: 38A0034D  li r5, 0x34d
	ctx.r[5].s64 = 845;
	// 82A6CB74: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A6CB78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6CB7C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82A6CB80: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6CB84: 483EBEBD  bl 0x82e58a40
	ctx.lr = 0x82A6CB88;
	sub_82E58A40(ctx, base);
	// 82A6CB88: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6CB8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6CB90: 419A0008  beq cr6, 0x82a6cb98
	if ctx.cr[6].eq {
	pc = 0x82A6CB98; continue 'dispatch;
	}
	// 82A6CB94: 4B853CFD  bl 0x822c0890
	ctx.lr = 0x82A6CB98;
	sub_822C0890(ctx, base);
	// 82A6CB98: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A6CB9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6CBA0: 419A0008  beq cr6, 0x82a6cba8
	if ctx.cr[6].eq {
	pc = 0x82A6CBA8; continue 'dispatch;
	}
	// 82A6CBA4: 4B853CED  bl 0x822c0890
	ctx.lr = 0x82A6CBA8;
	sub_822C0890(ctx, base);
	// 82A6CBA8: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82A6CBAC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A6CBB0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A6CBB4: 4BFFEF95  bl 0x82a6bb48
	ctx.lr = 0x82A6CBB8;
	sub_82A6BB48(ctx, base);
	// 82A6CBB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6CBBC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A6CBC0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6CBC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6CBC8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A6CBCC: 419A0024  beq cr6, 0x82a6cbf0
	if ctx.cr[6].eq {
	pc = 0x82A6CBF0; continue 'dispatch;
	}
	// 82A6CBD0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6CBD4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6CBD8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6CBDC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6CBE0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6CBE4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6CBE8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6CBEC: 4082FFE8  bne 0x82a6cbd4
	if !ctx.cr[0].eq {
	pc = 0x82A6CBD4; continue 'dispatch;
	}
	// 82A6CBF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A6CBF4: 80DF019C  lwz r6, 0x19c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 82A6CBF8: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82A6CBFC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6CC00: 38A00350  li r5, 0x350
	ctx.r[5].s64 = 848;
	// 82A6CC04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6CC08: 483EBE39  bl 0x82e58a40
	ctx.lr = 0x82A6CC0C;
	sub_82E58A40(ctx, base);
	// 82A6CC0C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A6CC10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6CC14: 419A0008  beq cr6, 0x82a6cc1c
	if ctx.cr[6].eq {
	pc = 0x82A6CC1C; continue 'dispatch;
	}
	// 82A6CC18: 4B853C79  bl 0x822c0890
	ctx.lr = 0x82A6CC1C;
	sub_822C0890(ctx, base);
	// 82A6CC1C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A6CC20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6CC24: 419A0008  beq cr6, 0x82a6cc2c
	if ctx.cr[6].eq {
	pc = 0x82A6CC2C; continue 'dispatch;
	}
	// 82A6CC28: 4B853C69  bl 0x822c0890
	ctx.lr = 0x82A6CC2C;
	sub_822C0890(ctx, base);
	// 82A6CC2C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A6CC30: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A6CC34: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A6CC38: 808B1674  lwz r4, 0x1674(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5748 as u32) ) } as u64;
	// 82A6CC3C: 48384FBD  bl 0x82df1bf8
	ctx.lr = 0x82A6CC40;
	sub_82DF1BF8(ctx, base);
	// 82A6CC40: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82A6CC44: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A6CC48: 388B2D6C  addi r4, r11, 0x2d6c
	ctx.r[4].s64 = ctx.r[11].s64 + 11628;
	// 82A6CC4C: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A6CC50: 4838C8E1  bl 0x82df9530
	ctx.lr = 0x82A6CC54;
	sub_82DF9530(ctx, base);
	// 82A6CC54: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A6CC58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6CC5C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6CC60: 4BAB9751  bl 0x825263b0
	ctx.lr = 0x82A6CC64;
	sub_825263B0(ctx, base);
	// 82A6CC64: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A6CC68: 48385029  bl 0x82df1c90
	ctx.lr = 0x82A6CC6C;
	sub_82DF1C90(ctx, base);
	// 82A6CC6C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A6CC70: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A6CC74: 4873B540  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6CC78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6CC78 size=252
    let mut pc: u32 = 0x82A6CC78;
    'dispatch: loop {
        match pc {
            0x82A6CC78 => {
    //   block [0x82A6CC78..0x82A6CD74)
	// 82A6CC78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6CC7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6CC80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6CC84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6CC88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6CC8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6CC90: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6CC94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6CC98: 4BAA2831  bl 0x8250f4c8
	ctx.lr = 0x82A6CC9C;
	sub_8250F4C8(ctx, base);
	// 82A6CC9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6CCA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6CCA4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A6CCA8: 409A0008  bne cr6, 0x82a6ccb0
	if !ctx.cr[6].eq {
	pc = 0x82A6CCB0; continue 'dispatch;
	}
	// 82A6CCAC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A6CCB0: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82A6CCB4: 4BA9B9CD  bl 0x82508680
	ctx.lr = 0x82A6CCB8;
	sub_82508680(ctx, base);
	// 82A6CCB8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A6CCBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6CCC0: 48384FD1  bl 0x82df1c90
	ctx.lr = 0x82A6CCC4;
	sub_82DF1C90(ctx, base);
	// 82A6CCC4: 815F0100  lwz r10, 0x100(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 82A6CCC8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6CCCC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A6CCD0: 396BFE88  addi r11, r11, -0x178
	ctx.r[11].s64 = ctx.r[11].s64 + -376;
	// 82A6CCD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A6CCD8: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A6CCDC: 4BF6AC15  bl 0x829d78f0
	ctx.lr = 0x82A6CCE0;
	sub_829D78F0(ctx, base);
	// 82A6CCE0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6CCE4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A6CCE8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6CCEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6CCF0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A6CCF4: 419A0024  beq cr6, 0x82a6cd18
	if ctx.cr[6].eq {
	pc = 0x82A6CD18; continue 'dispatch;
	}
	// 82A6CCF8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6CCFC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6CD00: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6CD04: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6CD08: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6CD0C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6CD10: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6CD14: 4082FFE8  bne 0x82a6ccfc
	if !ctx.cr[0].eq {
	pc = 0x82A6CCFC; continue 'dispatch;
	}
	// 82A6CD18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A6CD1C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A6CD20: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82A6CD24: 388A0068  addi r4, r10, 0x68
	ctx.r[4].s64 = ctx.r[10].s64 + 104;
	// 82A6CD28: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A6CD2C: 38A00378  li r5, 0x378
	ctx.r[5].s64 = 888;
	// 82A6CD30: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A6CD34: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A6CD38: 483EBD09  bl 0x82e58a40
	ctx.lr = 0x82A6CD3C;
	sub_82E58A40(ctx, base);
	// 82A6CD3C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6CD40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6CD44: 419A0008  beq cr6, 0x82a6cd4c
	if ctx.cr[6].eq {
	pc = 0x82A6CD4C; continue 'dispatch;
	}
	// 82A6CD48: 4B853B49  bl 0x822c0890
	ctx.lr = 0x82A6CD4C;
	sub_822C0890(ctx, base);
	// 82A6CD4C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A6CD50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6CD54: 419A0008  beq cr6, 0x82a6cd5c
	if ctx.cr[6].eq {
	pc = 0x82A6CD5C; continue 'dispatch;
	}
	// 82A6CD58: 4B853B39  bl 0x822c0890
	ctx.lr = 0x82A6CD5C;
	sub_822C0890(ctx, base);
	// 82A6CD5C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A6CD60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6CD64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6CD68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6CD6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6CD70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6CD78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6CD78 size=196
    let mut pc: u32 = 0x82A6CD78;
    'dispatch: loop {
        match pc {
            0x82A6CD78 => {
    //   block [0x82A6CD78..0x82A6CE3C)
	// 82A6CD78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6CD7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6CD80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6CD84: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6CD88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6CD8C: 817F019C  lwz r11, 0x19c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 82A6CD90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6CD94: 409A000C  bne cr6, 0x82a6cda0
	if !ctx.cr[6].eq {
	pc = 0x82A6CDA0; continue 'dispatch;
	}
	// 82A6CD98: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A6CD9C: 4800008C  b 0x82a6ce28
	pc = 0x82A6CE28; continue 'dispatch;
	// 82A6CDA0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6CDA4: 4BFFEE1D  bl 0x82a6bbc0
	ctx.lr = 0x82A6CDA8;
	sub_82A6BBC0(ctx, base);
	// 82A6CDA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6CDAC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A6CDB0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6CDB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6CDB8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A6CDBC: 419A0024  beq cr6, 0x82a6cde0
	if ctx.cr[6].eq {
	pc = 0x82A6CDE0; continue 'dispatch;
	}
	// 82A6CDC0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6CDC4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6CDC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6CDCC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6CDD0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6CDD4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6CDD8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6CDDC: 4082FFE8  bne 0x82a6cdc4
	if !ctx.cr[0].eq {
	pc = 0x82A6CDC4; continue 'dispatch;
	}
	// 82A6CDE0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A6CDE4: 80DF019C  lwz r6, 0x19c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 82A6CDE8: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A6CDEC: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82A6CDF0: 388A0068  addi r4, r10, 0x68
	ctx.r[4].s64 = ctx.r[10].s64 + 104;
	// 82A6CDF4: 38A00411  li r5, 0x411
	ctx.r[5].s64 = 1041;
	// 82A6CDF8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A6CDFC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A6CE00: 483EBC41  bl 0x82e58a40
	ctx.lr = 0x82A6CE04;
	sub_82E58A40(ctx, base);
	// 82A6CE04: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6CE08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6CE0C: 419A0008  beq cr6, 0x82a6ce14
	if ctx.cr[6].eq {
	pc = 0x82A6CE14; continue 'dispatch;
	}
	// 82A6CE10: 4B853A81  bl 0x822c0890
	ctx.lr = 0x82A6CE14;
	sub_822C0890(ctx, base);
	// 82A6CE14: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6CE18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6CE1C: 419A0008  beq cr6, 0x82a6ce24
	if ctx.cr[6].eq {
	pc = 0x82A6CE24; continue 'dispatch;
	}
	// 82A6CE20: 4B853A71  bl 0x822c0890
	ctx.lr = 0x82A6CE24;
	sub_822C0890(ctx, base);
	// 82A6CE24: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A6CE28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6CE2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6CE30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6CE34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6CE38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6CE40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6CE40 size=196
    let mut pc: u32 = 0x82A6CE40;
    'dispatch: loop {
        match pc {
            0x82A6CE40 => {
    //   block [0x82A6CE40..0x82A6CF04)
	// 82A6CE40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6CE44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6CE48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6CE4C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6CE50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6CE54: 817F019C  lwz r11, 0x19c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 82A6CE58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6CE5C: 409A000C  bne cr6, 0x82a6ce68
	if !ctx.cr[6].eq {
	pc = 0x82A6CE68; continue 'dispatch;
	}
	// 82A6CE60: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A6CE64: 4800008C  b 0x82a6cef0
	pc = 0x82A6CEF0; continue 'dispatch;
	// 82A6CE68: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6CE6C: 4BFFEDD5  bl 0x82a6bc40
	ctx.lr = 0x82A6CE70;
	sub_82A6BC40(ctx, base);
	// 82A6CE70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6CE74: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A6CE78: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6CE7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6CE80: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A6CE84: 419A0024  beq cr6, 0x82a6cea8
	if ctx.cr[6].eq {
	pc = 0x82A6CEA8; continue 'dispatch;
	}
	// 82A6CE88: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6CE8C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6CE90: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6CE94: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6CE98: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6CE9C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6CEA0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6CEA4: 4082FFE8  bne 0x82a6ce8c
	if !ctx.cr[0].eq {
	pc = 0x82A6CE8C; continue 'dispatch;
	}
	// 82A6CEA8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A6CEAC: 80DF019C  lwz r6, 0x19c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 82A6CEB0: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A6CEB4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82A6CEB8: 388A0068  addi r4, r10, 0x68
	ctx.r[4].s64 = ctx.r[10].s64 + 104;
	// 82A6CEBC: 38A00420  li r5, 0x420
	ctx.r[5].s64 = 1056;
	// 82A6CEC0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A6CEC4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A6CEC8: 483EBB79  bl 0x82e58a40
	ctx.lr = 0x82A6CECC;
	sub_82E58A40(ctx, base);
	// 82A6CECC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6CED0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6CED4: 419A0008  beq cr6, 0x82a6cedc
	if ctx.cr[6].eq {
	pc = 0x82A6CEDC; continue 'dispatch;
	}
	// 82A6CED8: 4B8539B9  bl 0x822c0890
	ctx.lr = 0x82A6CEDC;
	sub_822C0890(ctx, base);
	// 82A6CEDC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6CEE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6CEE4: 419A0008  beq cr6, 0x82a6ceec
	if ctx.cr[6].eq {
	pc = 0x82A6CEEC; continue 'dispatch;
	}
	// 82A6CEE8: 4B8539A9  bl 0x822c0890
	ctx.lr = 0x82A6CEEC;
	sub_822C0890(ctx, base);
	// 82A6CEEC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A6CEF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6CEF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6CEF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6CEFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6CF00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6CF08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6CF08 size=204
    let mut pc: u32 = 0x82A6CF08;
    'dispatch: loop {
        match pc {
            0x82A6CF08 => {
    //   block [0x82A6CF08..0x82A6CFD4)
	// 82A6CF08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6CF0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6CF10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6CF14: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6CF18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6CF1C: D021008C  stfs f1, 0x8c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82A6CF20: 817F019C  lwz r11, 0x19c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 82A6CF24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6CF28: 409A000C  bne cr6, 0x82a6cf34
	if !ctx.cr[6].eq {
	pc = 0x82A6CF34; continue 'dispatch;
	}
	// 82A6CF2C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A6CF30: 48000090  b 0x82a6cfc0
	pc = 0x82A6CFC0; continue 'dispatch;
	// 82A6CF34: 3881008C  addi r4, r1, 0x8c
	ctx.r[4].s64 = ctx.r[1].s64 + 140;
	// 82A6CF38: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6CF3C: 4BFFED85  bl 0x82a6bcc0
	ctx.lr = 0x82A6CF40;
	sub_82A6BCC0(ctx, base);
	// 82A6CF40: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6CF44: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A6CF48: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6CF4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6CF50: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A6CF54: 419A0024  beq cr6, 0x82a6cf78
	if ctx.cr[6].eq {
	pc = 0x82A6CF78; continue 'dispatch;
	}
	// 82A6CF58: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6CF5C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6CF60: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6CF64: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6CF68: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6CF6C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6CF70: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6CF74: 4082FFE8  bne 0x82a6cf5c
	if !ctx.cr[0].eq {
	pc = 0x82A6CF5C; continue 'dispatch;
	}
	// 82A6CF78: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A6CF7C: 80DF019C  lwz r6, 0x19c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 82A6CF80: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A6CF84: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82A6CF88: 388A0068  addi r4, r10, 0x68
	ctx.r[4].s64 = ctx.r[10].s64 + 104;
	// 82A6CF8C: 38A0042F  li r5, 0x42f
	ctx.r[5].s64 = 1071;
	// 82A6CF90: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A6CF94: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A6CF98: 483EBAA9  bl 0x82e58a40
	ctx.lr = 0x82A6CF9C;
	sub_82E58A40(ctx, base);
	// 82A6CF9C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6CFA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6CFA4: 419A0008  beq cr6, 0x82a6cfac
	if ctx.cr[6].eq {
	pc = 0x82A6CFAC; continue 'dispatch;
	}
	// 82A6CFA8: 4B8538E9  bl 0x822c0890
	ctx.lr = 0x82A6CFAC;
	sub_822C0890(ctx, base);
	// 82A6CFAC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6CFB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6CFB4: 419A0008  beq cr6, 0x82a6cfbc
	if ctx.cr[6].eq {
	pc = 0x82A6CFBC; continue 'dispatch;
	}
	// 82A6CFB8: 4B8538D9  bl 0x822c0890
	ctx.lr = 0x82A6CFBC;
	sub_822C0890(ctx, base);
	// 82A6CFBC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A6CFC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6CFC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6CFC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6CFCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6CFD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6CFD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6CFD8 size=216
    let mut pc: u32 = 0x82A6CFD8;
    'dispatch: loop {
        match pc {
            0x82A6CFD8 => {
    //   block [0x82A6CFD8..0x82A6D0B0)
	// 82A6CFD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6CFDC: 4873B191  bl 0x831a816c
	ctx.lr = 0x82A6CFE0;
	sub_831A8130(ctx, base);
	// 82A6CFE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6CFE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A6CFE8: 817E019C  lwz r11, 0x19c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(412 as u32) ) } as u64;
	// 82A6CFEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6CFF0: 409A000C  bne cr6, 0x82a6cffc
	if !ctx.cr[6].eq {
	pc = 0x82A6CFFC; continue 'dispatch;
	}
	// 82A6CFF4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A6CFF8: 480000B0  b 0x82a6d0a8
	pc = 0x82A6D0A8; continue 'dispatch;
	// 82A6CFFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6D000: 4BFFED39  bl 0x82a6bd38
	ctx.lr = 0x82A6D004;
	sub_82A6BD38(ctx, base);
	// 82A6D004: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6D008: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A6D00C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A6D010: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A6D014: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82A6D018: 419A0024  beq cr6, 0x82a6d03c
	if ctx.cr[6].eq {
	pc = 0x82A6D03C; continue 'dispatch;
	}
	// 82A6D01C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A6D020: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6D024: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6D028: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6D02C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6D030: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6D034: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6D038: 4082FFE8  bne 0x82a6d020
	if !ctx.cr[0].eq {
	pc = 0x82A6D020; continue 'dispatch;
	}
	// 82A6D03C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6D040: 80DE019C  lwz r6, 0x19c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(412 as u32) ) } as u64;
	// 82A6D044: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82A6D048: 388B0068  addi r4, r11, 0x68
	ctx.r[4].s64 = ctx.r[11].s64 + 104;
	// 82A6D04C: 38A00440  li r5, 0x440
	ctx.r[5].s64 = 1088;
	// 82A6D050: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82A6D054: 483E9F95  bl 0x82e56fe8
	ctx.lr = 0x82A6D058;
	sub_82E56FE8(ctx, base);
	// 82A6D058: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A6D05C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6D060: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 82A6D064: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6D068: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82A6D06C: 557EDFFE  rlwinm r30, r11, 0x1b, 0x1f, 0x1f
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82A6D070: 419A0008  beq cr6, 0x82a6d078
	if ctx.cr[6].eq {
	pc = 0x82A6D078; continue 'dispatch;
	}
	// 82A6D074: 4B85381D  bl 0x822c0890
	ctx.lr = 0x82A6D078;
	sub_822C0890(ctx, base);
	// 82A6D078: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6D07C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A6D080: 41820014  beq 0x82a6d094
	if ctx.cr[0].eq {
	pc = 0x82A6D094; continue 'dispatch;
	}
	// 82A6D084: 419AFF70  beq cr6, 0x82a6cff4
	if ctx.cr[6].eq {
	pc = 0x82A6CFF4; continue 'dispatch;
	}
	// 82A6D088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6D08C: 4B853805  bl 0x822c0890
	ctx.lr = 0x82A6D090;
	sub_822C0890(ctx, base);
	// 82A6D090: 4BFFFF64  b 0x82a6cff4
	pc = 0x82A6CFF4; continue 'dispatch;
	// 82A6D094: 8BDD0018  lbz r30, 0x18(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A6D098: 419A000C  beq cr6, 0x82a6d0a4
	if ctx.cr[6].eq {
	pc = 0x82A6D0A4; continue 'dispatch;
	}
	// 82A6D09C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6D0A0: 4B8537F1  bl 0x822c0890
	ctx.lr = 0x82A6D0A4;
	sub_822C0890(ctx, base);
	// 82A6D0A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6D0A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A6D0AC: 4873B110  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6D0B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6D0B0 size=268
    let mut pc: u32 = 0x82A6D0B0;
    'dispatch: loop {
        match pc {
            0x82A6D0B0 => {
    //   block [0x82A6D0B0..0x82A6D1BC)
	// 82A6D0B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6D0B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6D0B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6D0BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6D0C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6D0C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6D0C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A6D0CC: 817F019C  lwz r11, 0x19c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 82A6D0D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6D0D4: 409A000C  bne cr6, 0x82a6d0e0
	if !ctx.cr[6].eq {
	pc = 0x82A6D0E0; continue 'dispatch;
	}
	// 82A6D0D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A6D0DC: 480000C8  b 0x82a6d1a4
	pc = 0x82A6D1A4; continue 'dispatch;
	// 82A6D0E0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A6D0E4: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82A6D0E8: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82A6D0EC: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82A6D0F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6D0F4: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A6D0F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A6D0FC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6D1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6D1C0 size=240
    let mut pc: u32 = 0x82A6D1C0;
    'dispatch: loop {
        match pc {
            0x82A6D1C0 => {
    //   block [0x82A6D1C0..0x82A6D2B0)
	// 82A6D1C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6D1C4: 4873AFA9  bl 0x831a816c
	ctx.lr = 0x82A6D1C8;
	sub_831A8130(ctx, base);
	// 82A6D1C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6D1CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6D1D0: 817F019C  lwz r11, 0x19c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 82A6D1D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6D1D8: 409A000C  bne cr6, 0x82a6d1e4
	if !ctx.cr[6].eq {
	pc = 0x82A6D1E4; continue 'dispatch;
	}
	// 82A6D1DC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A6D1E0: 480000C8  b 0x82a6d2a8
	pc = 0x82A6D2A8; continue 'dispatch;
	// 82A6D1E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6D1E8: 4BA00979  bl 0x8246db60
	ctx.lr = 0x82A6D1EC;
	sub_8246DB60(ctx, base);
	// 82A6D1EC: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6D1F0: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A6D1F4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A6D1F8: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82A6D1FC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82A6D200: 419A0024  beq cr6, 0x82a6d224
	if ctx.cr[6].eq {
	pc = 0x82A6D224; continue 'dispatch;
	}
	// 82A6D204: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82A6D208: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6D20C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6D210: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6D214: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6D218: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6D21C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6D220: 4082FFE8  bne 0x82a6d208
	if !ctx.cr[0].eq {
	pc = 0x82A6D208; continue 'dispatch;
	}
	// 82A6D224: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6D228: 80DF019C  lwz r6, 0x19c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) } as u64;
	// 82A6D22C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82A6D230: 388B0068  addi r4, r11, 0x68
	ctx.r[4].s64 = ctx.r[11].s64 + 104;
	// 82A6D234: 38A0046A  li r5, 0x46a
	ctx.r[5].s64 = 1130;
	// 82A6D238: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A6D23C: 483E9DAD  bl 0x82e56fe8
	ctx.lr = 0x82A6D240;
	sub_82E56FE8(ctx, base);
	// 82A6D240: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A6D244: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6D248: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 82A6D24C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6D250: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82A6D254: 557FDFFE  rlwinm r31, r11, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82A6D258: 419A0008  beq cr6, 0x82a6d260
	if ctx.cr[6].eq {
	pc = 0x82A6D260; continue 'dispatch;
	}
	// 82A6D25C: 4B853635  bl 0x822c0890
	ctx.lr = 0x82A6D260;
	sub_822C0890(ctx, base);
	// 82A6D260: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6D264: 41820018  beq 0x82a6d27c
	if ctx.cr[0].eq {
	pc = 0x82A6D27C; continue 'dispatch;
	}
	// 82A6D268: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A6D26C: 419AFF70  beq cr6, 0x82a6d1dc
	if ctx.cr[6].eq {
	pc = 0x82A6D1DC; continue 'dispatch;
	}
	// 82A6D270: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6D274: 4B85361D  bl 0x822c0890
	ctx.lr = 0x82A6D278;
	sub_822C0890(ctx, base);
	// 82A6D278: 4BFFFF64  b 0x82a6d1dc
	pc = 0x82A6D1DC; continue 'dispatch;
	// 82A6D27C: 897D0018  lbz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A6D280: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A6D284: 40820010  bne 0x82a6d294
	if !ctx.cr[0].eq {
	pc = 0x82A6D294; continue 'dispatch;
	}
	// 82A6D288: 897D0019  lbz r11, 0x19(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(25 as u32) ) } as u64;
	// 82A6D28C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A6D290: 4182FFD8  beq 0x82a6d268
	if ctx.cr[0].eq {
	pc = 0x82A6D268; continue 'dispatch;
	}
	// 82A6D294: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A6D298: 419A000C  beq cr6, 0x82a6d2a4
	if ctx.cr[6].eq {
	pc = 0x82A6D2A4; continue 'dispatch;
	}
	// 82A6D29C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6D2A0: 4B8535F1  bl 0x822c0890
	ctx.lr = 0x82A6D2A4;
	sub_822C0890(ctx, base);
	// 82A6D2A4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A6D2A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A6D2AC: 4873AF10  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6D2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6D2B0 size=280
    let mut pc: u32 = 0x82A6D2B0;
    'dispatch: loop {
        match pc {
            0x82A6D2B0 => {
    //   block [0x82A6D2B0..0x82A6D3C8)
	// 82A6D2B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6D2B4: 4873AEAD  bl 0x831a8160
	ctx.lr = 0x82A6D2B8;
	sub_831A8130(ctx, base);
	// 82A6D2B8: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82A6D2BC: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6D2C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6D2C4: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82A6D2C8: 3B9F0028  addi r28, r31, 0x28
	ctx.r[28].s64 = ctx.r[31].s64 + 40;
	// 82A6D2CC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82A6D2D0: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82A6D2D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A6D2D8: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 82A6D2DC: 4859BCDD  bl 0x83008fb8
	ctx.lr = 0x82A6D2E0;
	sub_83008FB8(ctx, base);
	// 82A6D2E0: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82A6D2E4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A6D2E8: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82A6D2EC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A6D2F0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A6D2F4: 4B93A9ED  bl 0x823a7ce0
	ctx.lr = 0x82A6D2F8;
	sub_823A7CE0(ctx, base);
	// 82A6D2F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6D2FC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6D300: 4BAA21C9  bl 0x8250f4c8
	ctx.lr = 0x82A6D304;
	sub_8250F4C8(ctx, base);
	// 82A6D304: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6D308: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6D30C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A6D310: 409A0008  bne cr6, 0x82a6d318
	if !ctx.cr[6].eq {
	pc = 0x82A6D318; continue 'dispatch;
	}
	// 82A6D314: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A6D318: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82A6D31C: 4BA9B365  bl 0x82508680
	ctx.lr = 0x82A6D320;
	sub_82508680(ctx, base);
	// 82A6D320: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A6D324: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6D328: 48384969  bl 0x82df1c90
	ctx.lr = 0x82A6D32C;
	sub_82DF1C90(ctx, base);
	// 82A6D32C: 83C1006C  lwz r30, 0x6c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A6D330: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A6D334: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A6D338: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82A6D33C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A6D340: 419A0024  beq cr6, 0x82a6d364
	if ctx.cr[6].eq {
	pc = 0x82A6D364; continue 'dispatch;
	}
	// 82A6D344: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82A6D348: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6D34C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6D350: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6D354: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6D358: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6D35C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6D360: 4082FFE8  bne 0x82a6d348
	if !ctx.cr[0].eq {
	pc = 0x82A6D348; continue 'dispatch;
	}
	// 82A6D364: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A6D368: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A6D36C: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82A6D370: 388A0068  addi r4, r10, 0x68
	ctx.r[4].s64 = ctx.r[10].s64 + 104;
	// 82A6D374: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A6D378: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A6D37C: 38A00593  li r5, 0x593
	ctx.r[5].s64 = 1427;
	// 82A6D380: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A6D384: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6D388: 483EB6B9  bl 0x82e58a40
	ctx.lr = 0x82A6D38C;
	sub_82E58A40(ctx, base);
	// 82A6D38C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A6D390: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6D394: 419A0008  beq cr6, 0x82a6d39c
	if ctx.cr[6].eq {
	pc = 0x82A6D39C; continue 'dispatch;
	}
	// 82A6D398: 4B8534F9  bl 0x822c0890
	ctx.lr = 0x82A6D39C;
	sub_822C0890(ctx, base);
	// 82A6D39C: D3FF01E0  stfs f31, 0x1e0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), tmp.u32 ) };
	// 82A6D3A0: 9B7F01E8  stb r27, 0x1e8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(488 as u32), ctx.r[27].u8 ) };
	// 82A6D3A4: 935F01E4  stw r26, 0x1e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), ctx.r[26].u32 ) };
	// 82A6D3A8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A6D3AC: 937F01EC  stw r27, 0x1ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(492 as u32), ctx.r[27].u32 ) };
	// 82A6D3B0: 419A000C  beq cr6, 0x82a6d3bc
	if ctx.cr[6].eq {
	pc = 0x82A6D3BC; continue 'dispatch;
	}
	// 82A6D3B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6D3B8: 4B8534D9  bl 0x822c0890
	ctx.lr = 0x82A6D3BC;
	sub_822C0890(ctx, base);
	// 82A6D3BC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A6D3C0: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82A6D3C4: 4873ADEC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6D3C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6D3C8 size=196
    let mut pc: u32 = 0x82A6D3C8;
    'dispatch: loop {
        match pc {
            0x82A6D3C8 => {
    //   block [0x82A6D3C8..0x82A6D48C)
	// 82A6D3C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6D3CC: 4873ADA1  bl 0x831a816c
	ctx.lr = 0x82A6D3D0;
	sub_831A8130(ctx, base);
	// 82A6D3D0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A6D3D4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6D3D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6D3DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A6D3E0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A6D3E4: 815F01F0  lwz r10, 0x1f0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(496 as u32) ) } as u64;
	// 82A6D3E8: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A6D3EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6D3F0: 419A0088  beq cr6, 0x82a6d478
	if ctx.cr[6].eq {
	pc = 0x82A6D478; continue 'dispatch;
	}
	// 82A6D3F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6D3F8: 4BEB8459  bl 0x82925850
	ctx.lr = 0x82A6D3FC;
	sub_82925850(ctx, base);
	// 82A6D3FC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A6D400: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A6D404: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6D408: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A6D40C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82A6D410: 419A0024  beq cr6, 0x82a6d434
	if ctx.cr[6].eq {
	pc = 0x82A6D434; continue 'dispatch;
	}
	// 82A6D414: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82A6D418: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6D41C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6D420: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6D424: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6D428: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6D42C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6D430: 4082FFE8  bne 0x82a6d418
	if !ctx.cr[0].eq {
	pc = 0x82A6D418; continue 'dispatch;
	}
	// 82A6D434: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6D438: 80DF01F0  lwz r6, 0x1f0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(496 as u32) ) } as u64;
	// 82A6D43C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82A6D440: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6D444: 388B0068  addi r4, r11, 0x68
	ctx.r[4].s64 = ctx.r[11].s64 + 104;
	// 82A6D448: 38A005A3  li r5, 0x5a3
	ctx.r[5].s64 = 1443;
	// 82A6D44C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A6D450: 483EB5F1  bl 0x82e58a40
	ctx.lr = 0x82A6D454;
	sub_82E58A40(ctx, base);
	// 82A6D454: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6D458: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6D45C: 419A0008  beq cr6, 0x82a6d464
	if ctx.cr[6].eq {
	pc = 0x82A6D464; continue 'dispatch;
	}
	// 82A6D460: 4B853431  bl 0x822c0890
	ctx.lr = 0x82A6D464;
	sub_822C0890(ctx, base);
	// 82A6D464: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A6D468: 93BF01F0  stw r29, 0x1f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(496 as u32), ctx.r[29].u32 ) };
	// 82A6D46C: 419A000C  beq cr6, 0x82a6d478
	if ctx.cr[6].eq {
	pc = 0x82A6D478; continue 'dispatch;
	}
	// 82A6D470: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6D474: 4B85341D  bl 0x822c0890
	ctx.lr = 0x82A6D478;
	sub_822C0890(ctx, base);
	// 82A6D478: D3FF01E0  stfs f31, 0x1e0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), tmp.u32 ) };
	// 82A6D47C: 93BF01EC  stw r29, 0x1ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(492 as u32), ctx.r[29].u32 ) };
	// 82A6D480: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A6D484: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A6D488: 4873AD34  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6D490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A6D490 size=12
    let mut pc: u32 = 0x82A6D490;
    'dispatch: loop {
        match pc {
            0x82A6D490 => {
    //   block [0x82A6D490..0x82A6D49C)
	// 82A6D490: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A6D494: 99630220  stb r11, 0x220(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(544 as u32), ctx.r[11].u8 ) };
	// 82A6D498: 4BFFE2C8  b 0x82a6b760
	sub_82A6B760(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6D4A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6D4A0 size=208
    let mut pc: u32 = 0x82A6D4A0;
    'dispatch: loop {
        match pc {
            0x82A6D4A0 => {
    //   block [0x82A6D4A0..0x82A6D570)
	// 82A6D4A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6D4A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6D4A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6D4AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6D4B0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6D4B4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A6D4B8: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82A6D4BC: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82A6D4C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A6D4C4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A6D4C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6D4CC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6D570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6D570 size=196
    let mut pc: u32 = 0x82A6D570;
    'dispatch: loop {
        match pc {
            0x82A6D570 => {
    //   block [0x82A6D570..0x82A6D634)
	// 82A6D570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6D574: 4873ABF5  bl 0x831a8168
	ctx.lr = 0x82A6D578;
	sub_831A8130(ctx, base);
	// 82A6D578: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6D57C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A6D580: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6D584: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82A6D588: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82A6D58C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A6D590: 3BA00250  li r29, 0x250
	ctx.r[29].s64 = 592;
	// 82A6D594: 815F01F8  lwz r10, 0x1f8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(504 as u32) ) } as u64;
	// 82A6D598: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A6D59C: 2F0A0007  cmpwi cr6, r10, 7
	ctx.cr[6].compare_i32(ctx.r[10].s32, 7, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6D638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6D638 size=372
    let mut pc: u32 = 0x82A6D638;
    'dispatch: loop {
        match pc {
            0x82A6D638 => {
    //   block [0x82A6D638..0x82A6D7AC)
	// 82A6D638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6D63C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6D640: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6D644: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6D648: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6D64C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6D650: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6D654: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A6D658: 388B01E0  addi r4, r11, 0x1e0
	ctx.r[4].s64 = ctx.r[11].s64 + 480;
	// 82A6D65C: 483863AD  bl 0x82df3a08
	ctx.lr = 0x82A6D660;
	sub_82DF3A08(ctx, base);
	// 82A6D660: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A6D664: 4BA7D425  bl 0x824eaa88
	ctx.lr = 0x82A6D668;
	sub_824EAA88(ctx, base);
	// 82A6D668: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6D66C: 4BA7C1E5  bl 0x824e9850
	ctx.lr = 0x82A6D670;
	sub_824E9850(ctx, base);
	// 82A6D670: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A6D674: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A6D678: C00B9524  lfs f0, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6D67C: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6D680: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82A6D684: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 82A6D688: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6D68C: 48384605  bl 0x82df1c90
	ctx.lr = 0x82A6D690;
	sub_82DF1C90(ctx, base);
	// 82A6D690: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 82A6D694: 409A0028  bne cr6, 0x82a6d6bc
	if !ctx.cr[6].eq {
	pc = 0x82A6D6BC; continue 'dispatch;
	}
	// 82A6D698: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6D69C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6D6A0: 388B01D4  addi r4, r11, 0x1d4
	ctx.r[4].s64 = ctx.r[11].s64 + 468;
	// 82A6D6A4: 48386365  bl 0x82df3a08
	ctx.lr = 0x82A6D6A8;
	sub_82DF3A08(ctx, base);
	// 82A6D6A8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A6D6AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A6D6B0: 48386429  bl 0x82df3ad8
	ctx.lr = 0x82A6D6B4;
	sub_82DF3AD8(ctx, base);
	// 82A6D6B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6D6B8: 48385D71  bl 0x82df3428
	ctx.lr = 0x82A6D6BC;
	sub_82DF3428(ctx, base);
	// 82A6D6BC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A6D6C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A6D6C4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A6D6C8: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82A6D6CC: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82A6D6D0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A6D6D4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A6D6D8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A6D6DC: 4BFF0E95  bl 0x82a5e570
	ctx.lr = 0x82A6D6E0;
	sub_82A5E570(ctx, base);
	// 82A6D6E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6D6E4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A6D6E8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6D6EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6D6F0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A6D6F4: 419A0024  beq cr6, 0x82a6d718
	if ctx.cr[6].eq {
	pc = 0x82A6D718; continue 'dispatch;
	}
	// 82A6D6F8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6D6FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6D700: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6D704: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6D708: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6D70C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6D710: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6D714: 4082FFE8  bne 0x82a6d6fc
	if !ctx.cr[0].eq {
	pc = 0x82A6D6FC; continue 'dispatch;
	}
	// 82A6D718: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6D71C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6D720: 4BAA1DA9  bl 0x8250f4c8
	ctx.lr = 0x82A6D724;
	sub_8250F4C8(ctx, base);
	// 82A6D724: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6D728: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6D72C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A6D730: 409A0008  bne cr6, 0x82a6d738
	if !ctx.cr[6].eq {
	pc = 0x82A6D738; continue 'dispatch;
	}
	// 82A6D734: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A6D738: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 82A6D73C: 4BA9AEDD  bl 0x82508618
	ctx.lr = 0x82A6D740;
	sub_82508618(ctx, base);
	// 82A6D740: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A6D744: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A6D748: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A6D74C: 388A0068  addi r4, r10, 0x68
	ctx.r[4].s64 = ctx.r[10].s64 + 104;
	// 82A6D750: 38A007BB  li r5, 0x7bb
	ctx.r[5].s64 = 1979;
	// 82A6D754: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A6D758: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A6D75C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A6D760: 483EB2E1  bl 0x82e58a40
	ctx.lr = 0x82A6D764;
	sub_82E58A40(ctx, base);
	// 82A6D764: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6D768: 48384529  bl 0x82df1c90
	ctx.lr = 0x82A6D76C;
	sub_82DF1C90(ctx, base);
	// 82A6D76C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A6D770: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6D774: 419A0008  beq cr6, 0x82a6d77c
	if ctx.cr[6].eq {
	pc = 0x82A6D77C; continue 'dispatch;
	}
	// 82A6D778: 4B853119  bl 0x822c0890
	ctx.lr = 0x82A6D77C;
	sub_822C0890(ctx, base);
	// 82A6D77C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A6D780: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6D784: 419A0008  beq cr6, 0x82a6d78c
	if ctx.cr[6].eq {
	pc = 0x82A6D78C; continue 'dispatch;
	}
	// 82A6D788: 4B853109  bl 0x822c0890
	ctx.lr = 0x82A6D78C;
	sub_822C0890(ctx, base);
	// 82A6D78C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A6D790: 48385C99  bl 0x82df3428
	ctx.lr = 0x82A6D794;
	sub_82DF3428(ctx, base);
	// 82A6D794: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A6D798: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6D79C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6D7A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6D7A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6D7A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6D7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6D7B0 size=412
    let mut pc: u32 = 0x82A6D7B0;
    'dispatch: loop {
        match pc {
            0x82A6D7B0 => {
    //   block [0x82A6D7B0..0x82A6D94C)
	// 82A6D7B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6D7B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6D7B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6D7BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6D7C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6D7C4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6D7C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A6D7CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A6D7D0: 388B0204  addi r4, r11, 0x204
	ctx.r[4].s64 = ctx.r[11].s64 + 516;
	// 82A6D7D4: 48386235  bl 0x82df3a08
	ctx.lr = 0x82A6D7D8;
	sub_82DF3A08(ctx, base);
	// 82A6D7D8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6D7DC: 4BA7D2AD  bl 0x824eaa88
	ctx.lr = 0x82A6D7E0;
	sub_824EAA88(ctx, base);
	// 82A6D7E0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6D7E4: 4BA7C06D  bl 0x824e9850
	ctx.lr = 0x82A6D7E8;
	sub_824E9850(ctx, base);
	// 82A6D7E8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A6D7EC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6D7F0: C00BA1C4  lfs f0, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6D7F4: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6D7F8: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82A6D7FC: D8010060  stfd f0, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[0].u64 ) };
	// 82A6D800: 83E10064  lwz r31, 0x64(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A6D804: 4838448D  bl 0x82df1c90
	ctx.lr = 0x82A6D808;
	sub_82DF1C90(ctx, base);
	// 82A6D808: 2F1F0001  cmpwi cr6, r31, 1
	ctx.cr[6].compare_i32(ctx.r[31].s32, 1, &mut ctx.xer);
	// 82A6D80C: 419A0030  beq cr6, 0x82a6d83c
	if ctx.cr[6].eq {
	pc = 0x82A6D83C; continue 'dispatch;
	}
	// 82A6D810: 2F1F0002  cmpwi cr6, r31, 2
	ctx.cr[6].compare_i32(ctx.r[31].s32, 2, &mut ctx.xer);
	// 82A6D814: 409A004C  bne cr6, 0x82a6d860
	if !ctx.cr[6].eq {
	pc = 0x82A6D860; continue 'dispatch;
	}
	// 82A6D818: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6D81C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6D820: 388B01F8  addi r4, r11, 0x1f8
	ctx.r[4].s64 = ctx.r[11].s64 + 504;
	// 82A6D824: 483861E5  bl 0x82df3a08
	ctx.lr = 0x82A6D828;
	sub_82DF3A08(ctx, base);
	// 82A6D828: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A6D82C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A6D830: 483862A9  bl 0x82df3ad8
	ctx.lr = 0x82A6D834;
	sub_82DF3AD8(ctx, base);
	// 82A6D834: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6D838: 48000024  b 0x82a6d85c
	pc = 0x82A6D85C; continue 'dispatch;
	// 82A6D83C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6D840: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A6D844: 388B01EC  addi r4, r11, 0x1ec
	ctx.r[4].s64 = ctx.r[11].s64 + 492;
	// 82A6D848: 483861C1  bl 0x82df3a08
	ctx.lr = 0x82A6D84C;
	sub_82DF3A08(ctx, base);
	// 82A6D84C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A6D850: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A6D854: 48386285  bl 0x82df3ad8
	ctx.lr = 0x82A6D858;
	sub_82DF3AD8(ctx, base);
	// 82A6D858: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A6D85C: 48385BCD  bl 0x82df3428
	ctx.lr = 0x82A6D860;
	sub_82DF3428(ctx, base);
	// 82A6D860: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A6D864: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82A6D868: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82A6D86C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A6D870: 9BE10050  stb r31, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u8 ) };
	// 82A6D874: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A6D878: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A6D87C: 4BFF0CF5  bl 0x82a5e570
	ctx.lr = 0x82A6D880;
	sub_82A5E570(ctx, base);
	// 82A6D880: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6D884: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A6D888: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6D88C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6D890: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A6D894: 419A0024  beq cr6, 0x82a6d8b8
	if ctx.cr[6].eq {
	pc = 0x82A6D8B8; continue 'dispatch;
	}
	// 82A6D898: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6D89C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6D8A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6D8A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6D8A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6D8AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6D8B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6D8B4: 4082FFE8  bne 0x82a6d89c
	if !ctx.cr[0].eq {
	pc = 0x82A6D89C; continue 'dispatch;
	}
	// 82A6D8B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A6D8BC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A6D8C0: 4BAA1C09  bl 0x8250f4c8
	ctx.lr = 0x82A6D8C4;
	sub_8250F4C8(ctx, base);
	// 82A6D8C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6D8C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6D8CC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A6D8D0: 409A0008  bne cr6, 0x82a6d8d8
	if !ctx.cr[6].eq {
	pc = 0x82A6D8D8; continue 'dispatch;
	}
	// 82A6D8D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6D8D8: 3BE10068  addi r31, r1, 0x68
	ctx.r[31].s64 = ctx.r[1].s64 + 104;
	// 82A6D8DC: 4BA9AD3D  bl 0x82508618
	ctx.lr = 0x82A6D8E0;
	sub_82508618(ctx, base);
	// 82A6D8E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A6D8E4: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A6D8E8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A6D8EC: 388A0068  addi r4, r10, 0x68
	ctx.r[4].s64 = ctx.r[10].s64 + 104;
	// 82A6D8F0: 38A007D4  li r5, 0x7d4
	ctx.r[5].s64 = 2004;
	// 82A6D8F4: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82A6D8F8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A6D8FC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A6D900: 483EB141  bl 0x82e58a40
	ctx.lr = 0x82A6D904;
	sub_82E58A40(ctx, base);
	// 82A6D904: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A6D908: 48384389  bl 0x82df1c90
	ctx.lr = 0x82A6D90C;
	sub_82DF1C90(ctx, base);
	// 82A6D90C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A6D910: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6D914: 419A0008  beq cr6, 0x82a6d91c
	if ctx.cr[6].eq {
	pc = 0x82A6D91C; continue 'dispatch;
	}
	// 82A6D918: 4B852F79  bl 0x822c0890
	ctx.lr = 0x82A6D91C;
	sub_822C0890(ctx, base);
	// 82A6D91C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A6D920: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6D924: 419A0008  beq cr6, 0x82a6d92c
	if ctx.cr[6].eq {
	pc = 0x82A6D92C; continue 'dispatch;
	}
	// 82A6D928: 4B852F69  bl 0x822c0890
	ctx.lr = 0x82A6D92C;
	sub_822C0890(ctx, base);
	// 82A6D92C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A6D930: 48385AF9  bl 0x82df3428
	ctx.lr = 0x82A6D934;
	sub_82DF3428(ctx, base);
	// 82A6D934: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A6D938: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6D93C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6D940: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6D944: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6D948: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6D950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6D950 size=368
    let mut pc: u32 = 0x82A6D950;
    'dispatch: loop {
        match pc {
            0x82A6D950 => {
    //   block [0x82A6D950..0x82A6DAC0)
	// 82A6D950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6D954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6D958: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6D95C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6D960: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6D964: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6D968: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A6D96C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A6D970: 388B021C  addi r4, r11, 0x21c
	ctx.r[4].s64 = ctx.r[11].s64 + 540;
	// 82A6D974: 48386095  bl 0x82df3a08
	ctx.lr = 0x82A6D978;
	sub_82DF3A08(ctx, base);
	// 82A6D978: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A6D97C: 4BA7D10D  bl 0x824eaa88
	ctx.lr = 0x82A6D980;
	sub_824EAA88(ctx, base);
	// 82A6D980: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6D984: 4BA7BECD  bl 0x824e9850
	ctx.lr = 0x82A6D988;
	sub_824E9850(ctx, base);
	// 82A6D988: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A6D98C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A6D990: C00B9524  lfs f0, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6D994: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6D998: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82A6D99C: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 82A6D9A0: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6D9A4: 483842ED  bl 0x82df1c90
	ctx.lr = 0x82A6D9A8;
	sub_82DF1C90(ctx, base);
	// 82A6D9A8: 2F1F0001  cmpwi cr6, r31, 1
	ctx.cr[6].compare_i32(ctx.r[31].s32, 1, &mut ctx.xer);
	// 82A6D9AC: 409A0028  bne cr6, 0x82a6d9d4
	if !ctx.cr[6].eq {
	pc = 0x82A6D9D4; continue 'dispatch;
	}
	// 82A6D9B0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6D9B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6D9B8: 388B0210  addi r4, r11, 0x210
	ctx.r[4].s64 = ctx.r[11].s64 + 528;
	// 82A6D9BC: 4838604D  bl 0x82df3a08
	ctx.lr = 0x82A6D9C0;
	sub_82DF3A08(ctx, base);
	// 82A6D9C0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A6D9C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A6D9C8: 48386111  bl 0x82df3ad8
	ctx.lr = 0x82A6D9CC;
	sub_82DF3AD8(ctx, base);
	// 82A6D9CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6D9D0: 48385A59  bl 0x82df3428
	ctx.lr = 0x82A6D9D4;
	sub_82DF3428(ctx, base);
	// 82A6D9D4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A6D9D8: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82A6D9DC: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82A6D9E0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A6D9E4: 9BE10050  stb r31, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u8 ) };
	// 82A6D9E8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A6D9EC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A6D9F0: 4BFF0B81  bl 0x82a5e570
	ctx.lr = 0x82A6D9F4;
	sub_82A5E570(ctx, base);
	// 82A6D9F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6D9F8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A6D9FC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6DA00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6DA04: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A6DA08: 419A0024  beq cr6, 0x82a6da2c
	if ctx.cr[6].eq {
	pc = 0x82A6DA2C; continue 'dispatch;
	}
	// 82A6DA0C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6DA10: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6DA14: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6DA18: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6DA1C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6DA20: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6DA24: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6DA28: 4082FFE8  bne 0x82a6da10
	if !ctx.cr[0].eq {
	pc = 0x82A6DA10; continue 'dispatch;
	}
	// 82A6DA2C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A6DA30: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6DA34: 4BAA1A95  bl 0x8250f4c8
	ctx.lr = 0x82A6DA38;
	sub_8250F4C8(ctx, base);
	// 82A6DA38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6DA3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6DA40: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A6DA44: 409A0008  bne cr6, 0x82a6da4c
	if !ctx.cr[6].eq {
	pc = 0x82A6DA4C; continue 'dispatch;
	}
	// 82A6DA48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6DA4C: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 82A6DA50: 4BA9ABC9  bl 0x82508618
	ctx.lr = 0x82A6DA54;
	sub_82508618(ctx, base);
	// 82A6DA54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A6DA58: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A6DA5C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A6DA60: 388A0068  addi r4, r10, 0x68
	ctx.r[4].s64 = ctx.r[10].s64 + 104;
	// 82A6DA64: 38A007E8  li r5, 0x7e8
	ctx.r[5].s64 = 2024;
	// 82A6DA68: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82A6DA6C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A6DA70: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A6DA74: 483EAFCD  bl 0x82e58a40
	ctx.lr = 0x82A6DA78;
	sub_82E58A40(ctx, base);
	// 82A6DA78: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6DA7C: 48384215  bl 0x82df1c90
	ctx.lr = 0x82A6DA80;
	sub_82DF1C90(ctx, base);
	// 82A6DA80: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A6DA84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6DA88: 419A0008  beq cr6, 0x82a6da90
	if ctx.cr[6].eq {
	pc = 0x82A6DA90; continue 'dispatch;
	}
	// 82A6DA8C: 4B852E05  bl 0x822c0890
	ctx.lr = 0x82A6DA90;
	sub_822C0890(ctx, base);
	// 82A6DA90: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A6DA94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6DA98: 419A0008  beq cr6, 0x82a6daa0
	if ctx.cr[6].eq {
	pc = 0x82A6DAA0; continue 'dispatch;
	}
	// 82A6DA9C: 4B852DF5  bl 0x822c0890
	ctx.lr = 0x82A6DAA0;
	sub_822C0890(ctx, base);
	// 82A6DAA0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A6DAA4: 48385985  bl 0x82df3428
	ctx.lr = 0x82A6DAA8;
	sub_82DF3428(ctx, base);
	// 82A6DAA8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A6DAAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6DAB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6DAB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6DAB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6DABC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6DAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6DAC0 size=360
    let mut pc: u32 = 0x82A6DAC0;
    'dispatch: loop {
        match pc {
            0x82A6DAC0 => {
    //   block [0x82A6DAC0..0x82A6DC28)
	// 82A6DAC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6DAC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6DAC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6DACC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6DAD0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6DAD4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6DAD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6DADC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A6DAE0: 388B0234  addi r4, r11, 0x234
	ctx.r[4].s64 = ctx.r[11].s64 + 564;
	// 82A6DAE4: 48385F25  bl 0x82df3a08
	ctx.lr = 0x82A6DAE8;
	sub_82DF3A08(ctx, base);
	// 82A6DAE8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A6DAEC: 4BA7CF9D  bl 0x824eaa88
	ctx.lr = 0x82A6DAF0;
	sub_824EAA88(ctx, base);
	// 82A6DAF0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6DAF4: 4BA7BD5D  bl 0x824e9850
	ctx.lr = 0x82A6DAF8;
	sub_824E9850(ctx, base);
	// 82A6DAF8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A6DAFC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A6DB00: C00B9524  lfs f0, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6DB04: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A6DB08: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82A6DB0C: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 82A6DB10: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6DB14: 4838417D  bl 0x82df1c90
	ctx.lr = 0x82A6DB18;
	sub_82DF1C90(ctx, base);
	// 82A6DB18: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 82A6DB1C: 409A0028  bne cr6, 0x82a6db44
	if !ctx.cr[6].eq {
	pc = 0x82A6DB44; continue 'dispatch;
	}
	// 82A6DB20: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6DB24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6DB28: 388B0228  addi r4, r11, 0x228
	ctx.r[4].s64 = ctx.r[11].s64 + 552;
	// 82A6DB2C: 48385EDD  bl 0x82df3a08
	ctx.lr = 0x82A6DB30;
	sub_82DF3A08(ctx, base);
	// 82A6DB30: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A6DB34: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A6DB38: 48385FA1  bl 0x82df3ad8
	ctx.lr = 0x82A6DB3C;
	sub_82DF3AD8(ctx, base);
	// 82A6DB3C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A6DB40: 483858E9  bl 0x82df3428
	ctx.lr = 0x82A6DB44;
	sub_82DF3428(ctx, base);
	// 82A6DB44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A6DB48: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A6DB4C: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82A6DB50: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A6DB54: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A6DB58: 4BFFE251  bl 0x82a6bda8
	ctx.lr = 0x82A6DB5C;
	sub_82A6BDA8(ctx, base);
	// 82A6DB5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6DB60: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A6DB64: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6DB68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6DB6C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A6DB70: 419A0024  beq cr6, 0x82a6db94
	if ctx.cr[6].eq {
	pc = 0x82A6DB94; continue 'dispatch;
	}
	// 82A6DB74: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6DB78: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6DB7C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6DB80: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6DB84: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6DB88: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6DB8C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6DB90: 4082FFE8  bne 0x82a6db78
	if !ctx.cr[0].eq {
	pc = 0x82A6DB78; continue 'dispatch;
	}
	// 82A6DB94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6DB98: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6DB9C: 4BAA192D  bl 0x8250f4c8
	ctx.lr = 0x82A6DBA0;
	sub_8250F4C8(ctx, base);
	// 82A6DBA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6DBA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6DBA8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A6DBAC: 409A0008  bne cr6, 0x82a6dbb4
	if !ctx.cr[6].eq {
	pc = 0x82A6DBB4; continue 'dispatch;
	}
	// 82A6DBB0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A6DBB4: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 82A6DBB8: 4BA9AA61  bl 0x82508618
	ctx.lr = 0x82A6DBBC;
	sub_82508618(ctx, base);
	// 82A6DBBC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A6DBC0: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A6DBC4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A6DBC8: 388A0068  addi r4, r10, 0x68
	ctx.r[4].s64 = ctx.r[10].s64 + 104;
	// 82A6DBCC: 38A007FC  li r5, 0x7fc
	ctx.r[5].s64 = 2044;
	// 82A6DBD0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A6DBD4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A6DBD8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A6DBDC: 483EAE65  bl 0x82e58a40
	ctx.lr = 0x82A6DBE0;
	sub_82E58A40(ctx, base);
	// 82A6DBE0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6DBE4: 483840AD  bl 0x82df1c90
	ctx.lr = 0x82A6DBE8;
	sub_82DF1C90(ctx, base);
	// 82A6DBE8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A6DBEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6DBF0: 419A0008  beq cr6, 0x82a6dbf8
	if ctx.cr[6].eq {
	pc = 0x82A6DBF8; continue 'dispatch;
	}
	// 82A6DBF4: 4B852C9D  bl 0x822c0890
	ctx.lr = 0x82A6DBF8;
	sub_822C0890(ctx, base);
	// 82A6DBF8: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A6DBFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6DC00: 419A0008  beq cr6, 0x82a6dc08
	if ctx.cr[6].eq {
	pc = 0x82A6DC08; continue 'dispatch;
	}
	// 82A6DC04: 4B852C8D  bl 0x822c0890
	ctx.lr = 0x82A6DC08;
	sub_822C0890(ctx, base);
	// 82A6DC08: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A6DC0C: 4838581D  bl 0x82df3428
	ctx.lr = 0x82A6DC10;
	sub_82DF3428(ctx, base);
	// 82A6DC10: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A6DC14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6DC18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6DC1C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6DC20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6DC24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6DC28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6DC28 size=648
    let mut pc: u32 = 0x82A6DC28;
    'dispatch: loop {
        match pc {
            0x82A6DC28 => {
    //   block [0x82A6DC28..0x82A6DEB0)
	// 82A6DC28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6DC2C: 4873A539  bl 0x831a8164
	ctx.lr = 0x82A6DC30;
	sub_831A8130(ctx, base);
	// 82A6DC30: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6DC34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6DC38: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6DC3C: 3B6B0068  addi r27, r11, 0x68
	ctx.r[27].s64 = ctx.r[11].s64 + 104;
	// 82A6DC40: 815F027C  lwz r10, 0x27c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(636 as u32) ) } as u64;
	// 82A6DC44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A6DC48: 419A007C  beq cr6, 0x82a6dcc4
	if ctx.cr[6].eq {
	pc = 0x82A6DCC4; continue 'dispatch;
	}
	// 82A6DC4C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A6DC50: 4BFFE1E1  bl 0x82a6be30
	ctx.lr = 0x82A6DC54;
	sub_82A6BE30(ctx, base);
	// 82A6DC54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6DC58: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A6DC5C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6DC60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6DC64: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A6DC68: 419A0024  beq cr6, 0x82a6dc8c
	if ctx.cr[6].eq {
	pc = 0x82A6DC8C; continue 'dispatch;
	}
	// 82A6DC6C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6DC70: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6DC74: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6DC78: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6DC7C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6DC80: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6DC84: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6DC88: 4082FFE8  bne 0x82a6dc70
	if !ctx.cr[0].eq {
	pc = 0x82A6DC70; continue 'dispatch;
	}
	// 82A6DC8C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A6DC90: 80DF027C  lwz r6, 0x27c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(636 as u32) ) } as u64;
	// 82A6DC94: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82A6DC98: 38A00843  li r5, 0x843
	ctx.r[5].s64 = 2115;
	// 82A6DC9C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A6DCA0: 483E9349  bl 0x82e56fe8
	ctx.lr = 0x82A6DCA4;
	sub_82E56FE8(ctx, base);
	// 82A6DCA4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6DCA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6DCAC: 419A0008  beq cr6, 0x82a6dcb4
	if ctx.cr[6].eq {
	pc = 0x82A6DCB4; continue 'dispatch;
	}
	// 82A6DCB0: 4B852BE1  bl 0x822c0890
	ctx.lr = 0x82A6DCB4;
	sub_822C0890(ctx, base);
	// 82A6DCB4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A6DCB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6DCBC: 419A0008  beq cr6, 0x82a6dcc4
	if ctx.cr[6].eq {
	pc = 0x82A6DCC4; continue 'dispatch;
	}
	// 82A6DCC0: 4B852BD1  bl 0x822c0890
	ctx.lr = 0x82A6DCC4;
	sub_822C0890(ctx, base);
	// 82A6DCC4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A6DCC8: 397F02B4  addi r11, r31, 0x2b4
	ctx.r[11].s64 = ctx.r[31].s64 + 692;
	// 82A6DCCC: 939F02B4  stw r28, 0x2b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(692 as u32), ctx.r[28].u32 ) };
	// 82A6DCD0: 807F02B8  lwz r3, 0x2b8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(696 as u32) ) } as u64;
	// 82A6DCD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6DCD8: 939F02B8  stw r28, 0x2b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(696 as u32), ctx.r[28].u32 ) };
	// 82A6DCDC: 419A0008  beq cr6, 0x82a6dce4
	if ctx.cr[6].eq {
	pc = 0x82A6DCE4; continue 'dispatch;
	}
	// 82A6DCE0: 4B852BB1  bl 0x822c0890
	ctx.lr = 0x82A6DCE4;
	sub_822C0890(ctx, base);
	// 82A6DCE4: 3BDF0280  addi r30, r31, 0x280
	ctx.r[30].s64 = ctx.r[31].s64 + 640;
	// 82A6DCE8: 939F027C  stw r28, 0x27c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(636 as u32), ctx.r[28].u32 ) };
	// 82A6DCEC: 3BA00003  li r29, 3
	ctx.r[29].s64 = 3;
	// 82A6DCF0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6DCF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6DCF8: 419A007C  beq cr6, 0x82a6dd74
	if ctx.cr[6].eq {
	pc = 0x82A6DD74; continue 'dispatch;
	}
	// 82A6DCFC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A6DD00: 4BFFE131  bl 0x82a6be30
	ctx.lr = 0x82A6DD04;
	sub_82A6BE30(ctx, base);
	// 82A6DD04: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6DD08: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A6DD0C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6DD10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6DD14: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A6DD18: 419A0024  beq cr6, 0x82a6dd3c
	if ctx.cr[6].eq {
	pc = 0x82A6DD3C; continue 'dispatch;
	}
	// 82A6DD1C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6DD20: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6DD24: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6DD28: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6DD2C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6DD30: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6DD34: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6DD38: 4082FFE8  bne 0x82a6dd20
	if !ctx.cr[0].eq {
	pc = 0x82A6DD20; continue 'dispatch;
	}
	// 82A6DD3C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A6DD40: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6DD44: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82A6DD48: 38A0084D  li r5, 0x84d
	ctx.r[5].s64 = 2125;
	// 82A6DD4C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A6DD50: 483E9299  bl 0x82e56fe8
	ctx.lr = 0x82A6DD54;
	sub_82E56FE8(ctx, base);
	// 82A6DD54: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6DD58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6DD5C: 419A0008  beq cr6, 0x82a6dd64
	if ctx.cr[6].eq {
	pc = 0x82A6DD64; continue 'dispatch;
	}
	// 82A6DD60: 4B852B31  bl 0x822c0890
	ctx.lr = 0x82A6DD64;
	sub_822C0890(ctx, base);
	// 82A6DD64: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A6DD68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6DD6C: 419A0008  beq cr6, 0x82a6dd74
	if ctx.cr[6].eq {
	pc = 0x82A6DD74; continue 'dispatch;
	}
	// 82A6DD70: 4B852B21  bl 0x822c0890
	ctx.lr = 0x82A6DD74;
	sub_822C0890(ctx, base);
	// 82A6DD74: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82A6DD78: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A6DD7C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82A6DD80: 4082FF70  bne 0x82a6dcf0
	if !ctx.cr[0].eq {
	pc = 0x82A6DCF0; continue 'dispatch;
	}
	// 82A6DD84: 3BDF028C  addi r30, r31, 0x28c
	ctx.r[30].s64 = ctx.r[31].s64 + 652;
	// 82A6DD88: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 82A6DD8C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6DD90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6DD94: 419A007C  beq cr6, 0x82a6de10
	if ctx.cr[6].eq {
	pc = 0x82A6DE10; continue 'dispatch;
	}
	// 82A6DD98: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A6DD9C: 4BFFE095  bl 0x82a6be30
	ctx.lr = 0x82A6DDA0;
	sub_82A6BE30(ctx, base);
	// 82A6DDA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6DDA4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A6DDA8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6DDAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6DDB0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A6DDB4: 419A0024  beq cr6, 0x82a6ddd8
	if ctx.cr[6].eq {
	pc = 0x82A6DDD8; continue 'dispatch;
	}
	// 82A6DDB8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6DDBC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6DDC0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6DDC4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6DDC8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6DDCC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6DDD0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6DDD4: 4082FFE8  bne 0x82a6ddbc
	if !ctx.cr[0].eq {
	pc = 0x82A6DDBC; continue 'dispatch;
	}
	// 82A6DDD8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A6DDDC: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6DDE0: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82A6DDE4: 38A00856  li r5, 0x856
	ctx.r[5].s64 = 2134;
	// 82A6DDE8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A6DDEC: 483E91FD  bl 0x82e56fe8
	ctx.lr = 0x82A6DDF0;
	sub_82E56FE8(ctx, base);
	// 82A6DDF0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A6DDF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6DDF8: 419A0008  beq cr6, 0x82a6de00
	if ctx.cr[6].eq {
	pc = 0x82A6DE00; continue 'dispatch;
	}
	// 82A6DDFC: 4B852A95  bl 0x822c0890
	ctx.lr = 0x82A6DE00;
	sub_822C0890(ctx, base);
	// 82A6DE00: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A6DE04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6DE08: 419A0008  beq cr6, 0x82a6de10
	if ctx.cr[6].eq {
	pc = 0x82A6DE10; continue 'dispatch;
	}
	// 82A6DE0C: 4B852A85  bl 0x822c0890
	ctx.lr = 0x82A6DE10;
	sub_822C0890(ctx, base);
	// 82A6DE10: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82A6DE14: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A6DE18: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82A6DE1C: 4082FF70  bne 0x82a6dd8c
	if !ctx.cr[0].eq {
	pc = 0x82A6DD8C; continue 'dispatch;
	}
	// 82A6DE20: 817F0294  lwz r11, 0x294(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(660 as u32) ) } as u64;
	// 82A6DE24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6DE28: 419A007C  beq cr6, 0x82a6dea4
	if ctx.cr[6].eq {
	pc = 0x82A6DEA4; continue 'dispatch;
	}
	// 82A6DE2C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A6DE30: 4BFFE001  bl 0x82a6be30
	ctx.lr = 0x82A6DE34;
	sub_82A6BE30(ctx, base);
	// 82A6DE34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6DE38: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A6DE3C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6DE40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6DE44: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A6DE48: 419A0024  beq cr6, 0x82a6de6c
	if ctx.cr[6].eq {
	pc = 0x82A6DE6C; continue 'dispatch;
	}
	// 82A6DE4C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6DE50: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6DE54: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6DE58: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6DE5C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6DE60: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6DE64: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6DE68: 4082FFE8  bne 0x82a6de50
	if !ctx.cr[0].eq {
	pc = 0x82A6DE50; continue 'dispatch;
	}
	// 82A6DE6C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A6DE70: 80DF0294  lwz r6, 0x294(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(660 as u32) ) } as u64;
	// 82A6DE74: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 82A6DE78: 38A0085F  li r5, 0x85f
	ctx.r[5].s64 = 2143;
	// 82A6DE7C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A6DE80: 483E9169  bl 0x82e56fe8
	ctx.lr = 0x82A6DE84;
	sub_82E56FE8(ctx, base);
	// 82A6DE84: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A6DE88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6DE8C: 419A0008  beq cr6, 0x82a6de94
	if ctx.cr[6].eq {
	pc = 0x82A6DE94; continue 'dispatch;
	}
	// 82A6DE90: 4B852A01  bl 0x822c0890
	ctx.lr = 0x82A6DE94;
	sub_822C0890(ctx, base);
	// 82A6DE94: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A6DE98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6DE9C: 419A0008  beq cr6, 0x82a6dea4
	if ctx.cr[6].eq {
	pc = 0x82A6DEA4; continue 'dispatch;
	}
	// 82A6DEA0: 4B8529F1  bl 0x822c0890
	ctx.lr = 0x82A6DEA4;
	sub_822C0890(ctx, base);
	// 82A6DEA4: 939F0294  stw r28, 0x294(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(660 as u32), ctx.r[28].u32 ) };
	// 82A6DEA8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A6DEAC: 4873A308  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6DEB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6DEB0 size=332
    let mut pc: u32 = 0x82A6DEB0;
    'dispatch: loop {
        match pc {
            0x82A6DEB0 => {
    //   block [0x82A6DEB0..0x82A6DFFC)
	// 82A6DEB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6DEB4: 4873A2B9  bl 0x831a816c
	ctx.lr = 0x82A6DEB8;
	sub_831A8130(ctx, base);
	// 82A6DEB8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A6DEBC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6DEC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6DEC4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A6DEC8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6DECC: 3BCB0068  addi r30, r11, 0x68
	ctx.r[30].s64 = ctx.r[11].s64 + 104;
	// 82A6DED0: 813F0274  lwz r9, 0x274(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 82A6DED4: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A6DED8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A6DEDC: 419A0080  beq cr6, 0x82a6df5c
	if ctx.cr[6].eq {
	pc = 0x82A6DF5C; continue 'dispatch;
	}
	// 82A6DEE0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A6DEE4: 4BFF096D  bl 0x82a5e850
	ctx.lr = 0x82A6DEE8;
	sub_82A5E850(ctx, base);
	// 82A6DEE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6DEEC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A6DEF0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6DEF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6DEF8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A6DEFC: 419A0024  beq cr6, 0x82a6df20
	if ctx.cr[6].eq {
	pc = 0x82A6DF20; continue 'dispatch;
	}
	// 82A6DF00: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6DF04: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6DF08: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6DF0C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6DF10: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6DF14: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6DF18: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6DF1C: 4082FFE8  bne 0x82a6df04
	if !ctx.cr[0].eq {
	pc = 0x82A6DF04; continue 'dispatch;
	}
	// 82A6DF20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A6DF24: 80DF0274  lwz r6, 0x274(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 82A6DF28: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82A6DF2C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6DF30: 38A00882  li r5, 0x882
	ctx.r[5].s64 = 2178;
	// 82A6DF34: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A6DF38: 483EAB09  bl 0x82e58a40
	ctx.lr = 0x82A6DF3C;
	sub_82E58A40(ctx, base);
	// 82A6DF3C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6DF40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6DF44: 419A0008  beq cr6, 0x82a6df4c
	if ctx.cr[6].eq {
	pc = 0x82A6DF4C; continue 'dispatch;
	}
	// 82A6DF48: 4B852949  bl 0x822c0890
	ctx.lr = 0x82A6DF4C;
	sub_822C0890(ctx, base);
	// 82A6DF4C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A6DF50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6DF54: 419A0008  beq cr6, 0x82a6df5c
	if ctx.cr[6].eq {
	pc = 0x82A6DF5C; continue 'dispatch;
	}
	// 82A6DF58: 4B852939  bl 0x822c0890
	ctx.lr = 0x82A6DF5C;
	sub_822C0890(ctx, base);
	// 82A6DF5C: 817F0278  lwz r11, 0x278(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(632 as u32) ) } as u64;
	// 82A6DF60: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A6DF64: 93BF0274  stw r29, 0x274(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(628 as u32), ctx.r[29].u32 ) };
	// 82A6DF68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6DF6C: 419A0080  beq cr6, 0x82a6dfec
	if ctx.cr[6].eq {
	pc = 0x82A6DFEC; continue 'dispatch;
	}
	// 82A6DF70: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A6DF74: 4BFF08DD  bl 0x82a5e850
	ctx.lr = 0x82A6DF78;
	sub_82A5E850(ctx, base);
	// 82A6DF78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6DF7C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A6DF80: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6DF84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6DF88: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A6DF8C: 419A0024  beq cr6, 0x82a6dfb0
	if ctx.cr[6].eq {
	pc = 0x82A6DFB0; continue 'dispatch;
	}
	// 82A6DF90: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6DF94: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6DF98: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6DF9C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6DFA0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6DFA4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6DFA8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6DFAC: 4082FFE8  bne 0x82a6df94
	if !ctx.cr[0].eq {
	pc = 0x82A6DF94; continue 'dispatch;
	}
	// 82A6DFB0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A6DFB4: 80DF0278  lwz r6, 0x278(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(632 as u32) ) } as u64;
	// 82A6DFB8: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82A6DFBC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6DFC0: 38A00888  li r5, 0x888
	ctx.r[5].s64 = 2184;
	// 82A6DFC4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A6DFC8: 483EAA79  bl 0x82e58a40
	ctx.lr = 0x82A6DFCC;
	sub_82E58A40(ctx, base);
	// 82A6DFCC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A6DFD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6DFD4: 419A0008  beq cr6, 0x82a6dfdc
	if ctx.cr[6].eq {
	pc = 0x82A6DFDC; continue 'dispatch;
	}
	// 82A6DFD8: 4B8528B9  bl 0x822c0890
	ctx.lr = 0x82A6DFDC;
	sub_822C0890(ctx, base);
	// 82A6DFDC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A6DFE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6DFE4: 419A0008  beq cr6, 0x82a6dfec
	if ctx.cr[6].eq {
	pc = 0x82A6DFEC; continue 'dispatch;
	}
	// 82A6DFE8: 4B8528A9  bl 0x822c0890
	ctx.lr = 0x82A6DFEC;
	sub_822C0890(ctx, base);
	// 82A6DFEC: 93BF0278  stw r29, 0x278(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(632 as u32), ctx.r[29].u32 ) };
	// 82A6DFF0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A6DFF4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A6DFF8: 4873A1C4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6E000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A6E000 size=556
    let mut pc: u32 = 0x82A6E000;
    'dispatch: loop {
        match pc {
            0x82A6E000 => {
    //   block [0x82A6E000..0x82A6E22C)
	// 82A6E000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6E004: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6E008: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6E00C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6E010: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A6E014: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6E230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6E230 size=96
    let mut pc: u32 = 0x82A6E230;
    'dispatch: loop {
        match pc {
            0x82A6E230 => {
    //   block [0x82A6E230..0x82A6E290)
	// 82A6E230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6E234: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6E238: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6E23C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6E240: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6E244: 4BFFC7A5  bl 0x82a6a9e8
	ctx.lr = 0x82A6E248;
	sub_82A6A9E8(ctx, base);
	// 82A6E248: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E24C: 4BFFB6ED  bl 0x82a69938
	ctx.lr = 0x82A6E250;
	sub_82A69938(ctx, base);
	// 82A6E250: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E254: 4BFFC69D  bl 0x82a6a8f0
	ctx.lr = 0x82A6E258;
	sub_82A6A8F0(ctx, base);
	// 82A6E258: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E25C: 4BFFEA1D  bl 0x82a6cc78
	ctx.lr = 0x82A6E260;
	sub_82A6CC78(ctx, base);
	// 82A6E260: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E264: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A6E268: 4BAA18D9  bl 0x8250fb40
	ctx.lr = 0x82A6E26C;
	sub_8250FB40(ctx, base);
	// 82A6E26C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E270: 4BFFFC41  bl 0x82a6deb0
	ctx.lr = 0x82A6E274;
	sub_82A6DEB0(ctx, base);
	// 82A6E274: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E278: 4BFFF9B1  bl 0x82a6dc28
	ctx.lr = 0x82A6E27C;
	sub_82A6DC28(ctx, base);
	// 82A6E27C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A6E280: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6E284: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6E288: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6E28C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6E290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6E290 size=60
    let mut pc: u32 = 0x82A6E290;
    'dispatch: loop {
        match pc {
            0x82A6E290 => {
    //   block [0x82A6E290..0x82A6E2CC)
	// 82A6E290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6E294: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6E298: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6E29C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6E2A0: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A6E2A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6E2A8: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 82A6E2AC: 4BFFE9CD  bl 0x82a6cc78
	ctx.lr = 0x82A6E2B0;
	sub_82A6CC78(ctx, base);
	// 82A6E2B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E2B4: 4BFFDD8D  bl 0x82a6c040
	ctx.lr = 0x82A6E2B8;
	sub_82A6C040(ctx, base);
	// 82A6E2B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A6E2BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6E2C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6E2C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6E2C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6E2D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A6E2D0 size=12
    let mut pc: u32 = 0x82A6E2D0;
    'dispatch: loop {
        match pc {
            0x82A6E2D0 => {
    //   block [0x82A6E2D0..0x82A6E2DC)
	// 82A6E2D0: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A6E2D4: 556A07BD  rlwinm. r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A6E2D8: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6E2DC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A6E2DC size=12
    let mut pc: u32 = 0x82A6E2DC;
    'dispatch: loop {
        match pc {
            0x82A6E2DC => {
    //   block [0x82A6E2DC..0x82A6E2E8)
	// 82A6E2DC: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6E2E0: 41820008  beq 0x82a6e2e8
	if ctx.cr[0].eq {
		sub_82A6E2E8(ctx, base);
		return;
	}
	// 82A6E2E4: 4BFFFF4C  b 0x82a6e230
	sub_82A6E230(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6E2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A6E2E8 size=8
    let mut pc: u32 = 0x82A6E2E8;
    'dispatch: loop {
        match pc {
            0x82A6E2E8 => {
    //   block [0x82A6E2E8..0x82A6E2F0)
	// 82A6E2E8: 4BFFFF48  b 0x82a6e230
	sub_82A6E230(ctx, base);
	return;
	// 82A6E2EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6E2F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6E2F0 size=56
    let mut pc: u32 = 0x82A6E2F0;
    'dispatch: loop {
        match pc {
            0x82A6E2F0 => {
    //   block [0x82A6E2F0..0x82A6E328)
	// 82A6E2F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6E2F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6E2F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6E2FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6E300: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A6E304: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6E308: 4BAA1839  bl 0x8250fb40
	ctx.lr = 0x82A6E30C;
	sub_8250FB40(ctx, base);
	// 82A6E30C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E310: 4BFFFBA1  bl 0x82a6deb0
	ctx.lr = 0x82A6E314;
	sub_82A6DEB0(ctx, base);
	// 82A6E314: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A6E318: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6E31C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6E320: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6E324: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6E328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6E328 size=256
    let mut pc: u32 = 0x82A6E328;
    'dispatch: loop {
        match pc {
            0x82A6E328 => {
    //   block [0x82A6E328..0x82A6E428)
	// 82A6E328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6E32C: 48739E41  bl 0x831a816c
	ctx.lr = 0x82A6E330;
	sub_831A8130(ctx, base);
	// 82A6E330: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6E334: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6E338: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A6E33C: 3BA00260  li r29, 0x260
	ctx.r[29].s64 = 608;
	// 82A6E340: 817F01F8  lwz r11, 0x1f8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(504 as u32) ) } as u64;
	// 82A6E344: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A6E348: 419A0050  beq cr6, 0x82a6e398
	if ctx.cr[6].eq {
	pc = 0x82A6E398; continue 'dispatch;
	}
	// 82A6E34C: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82A6E350: 419A0038  beq cr6, 0x82a6e388
	if ctx.cr[6].eq {
	pc = 0x82A6E388; continue 'dispatch;
	}
	// 82A6E354: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 82A6E358: 409A0050  bne cr6, 0x82a6e3a8
	if !ctx.cr[6].eq {
	pc = 0x82A6E3A8; continue 'dispatch;
	}
	// 82A6E35C: 4BAA378D  bl 0x82511ae8
	ctx.lr = 0x82A6E360;
	sub_82511AE8(ctx, base);
	// 82A6E360: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A6E364: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A6E368: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6E428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6E428 size=1340
    let mut pc: u32 = 0x82A6E428;
    'dispatch: loop {
        match pc {
            0x82A6E428 => {
    //   block [0x82A6E428..0x82A6E964)
	// 82A6E428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6E42C: 48739D3D  bl 0x831a8168
	ctx.lr = 0x82A6E430;
	sub_831A8130(ctx, base);
	// 82A6E430: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6E434: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A6E438: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A6E43C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A6E440: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A6E444: 41820038  beq 0x82a6e47c
	if ctx.cr[0].eq {
	pc = 0x82A6E47C; continue 'dispatch;
	}
	// 82A6E448: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E44C: 4873B53D  bl 0x831a9988
	ctx.lr = 0x82A6E450;
	sub_831A9988(ctx, base);
	// 82A6E450: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82A6E454: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6E458: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 82A6E45C: 48739C9D  bl 0x831a80f8
	ctx.lr = 0x82A6E460;
	sub_831A80F8(ctx, base);
	// 82A6E460: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6E464: 41820018  beq 0x82a6e47c
	if ctx.cr[0].eq {
	pc = 0x82A6E47C; continue 'dispatch;
	}
	// 82A6E468: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E46C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A6E470: 4BFFE481  bl 0x82a6c8f0
	ctx.lr = 0x82A6E474;
	sub_82A6C8F0(ctx, base);
	// 82A6E474: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A6E478: 480004E4  b 0x82a6e95c
	pc = 0x82A6E95C; continue 'dispatch;
	// 82A6E47C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6E480: 419A049C  beq cr6, 0x82a6e91c
	if ctx.cr[6].eq {
	pc = 0x82A6E91C; continue 'dispatch;
	}
	// 82A6E484: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E488: 4873B501  bl 0x831a9988
	ctx.lr = 0x82A6E48C;
	sub_831A9988(ctx, base);
	// 82A6E48C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A6E490: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6E494: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 82A6E498: 48739C61  bl 0x831a80f8
	ctx.lr = 0x82A6E49C;
	sub_831A80F8(ctx, base);
	// 82A6E49C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6E4A0: 41820014  beq 0x82a6e4b4
	if ctx.cr[0].eq {
	pc = 0x82A6E4B4; continue 'dispatch;
	}
	// 82A6E4A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E4A8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A6E4AC: 4BFFE605  bl 0x82a6cab0
	ctx.lr = 0x82A6E4B0;
	sub_82A6CAB0(ctx, base);
	// 82A6E4B0: 4BFFFFC4  b 0x82a6e474
	pc = 0x82A6E474; continue 'dispatch;
	// 82A6E4B4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6E4B8: 419A0464  beq cr6, 0x82a6e91c
	if ctx.cr[6].eq {
	pc = 0x82A6E91C; continue 'dispatch;
	}
	// 82A6E4BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E4C0: 4873B4C9  bl 0x831a9988
	ctx.lr = 0x82A6E4C4;
	sub_831A9988(ctx, base);
	// 82A6E4C4: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A6E4C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6E4CC: 386B7788  addi r3, r11, 0x7788
	ctx.r[3].s64 = ctx.r[11].s64 + 30600;
	// 82A6E4D0: 48739C29  bl 0x831a80f8
	ctx.lr = 0x82A6E4D4;
	sub_831A80F8(ctx, base);
	// 82A6E4D4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6E4D8: 41820014  beq 0x82a6e4ec
	if ctx.cr[0].eq {
	pc = 0x82A6E4EC; continue 'dispatch;
	}
	// 82A6E4DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E4E0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A6E4E4: 4BB23CAD  bl 0x82592190
	ctx.lr = 0x82A6E4E8;
	sub_82592190(ctx, base);
	// 82A6E4E8: 4BFFFF8C  b 0x82a6e474
	pc = 0x82A6E474; continue 'dispatch;
	// 82A6E4EC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6E4F0: 419A042C  beq cr6, 0x82a6e91c
	if ctx.cr[6].eq {
	pc = 0x82A6E91C; continue 'dispatch;
	}
	// 82A6E4F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E4F8: 4873B491  bl 0x831a9988
	ctx.lr = 0x82A6E4FC;
	sub_831A9988(ctx, base);
	// 82A6E4FC: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A6E500: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6E504: 386B5AB4  addi r3, r11, 0x5ab4
	ctx.r[3].s64 = ctx.r[11].s64 + 23220;
	// 82A6E508: 48739BF1  bl 0x831a80f8
	ctx.lr = 0x82A6E50C;
	sub_831A80F8(ctx, base);
	// 82A6E50C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6E510: 41820014  beq 0x82a6e524
	if ctx.cr[0].eq {
	pc = 0x82A6E524; continue 'dispatch;
	}
	// 82A6E514: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E518: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A6E51C: 4BFFFE0D  bl 0x82a6e328
	ctx.lr = 0x82A6E520;
	sub_82A6E328(ctx, base);
	// 82A6E520: 4BFFFF54  b 0x82a6e474
	pc = 0x82A6E474; continue 'dispatch;
	// 82A6E524: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6E528: 419A03F4  beq cr6, 0x82a6e91c
	if ctx.cr[6].eq {
	pc = 0x82A6E91C; continue 'dispatch;
	}
	// 82A6E52C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E530: 4873B459  bl 0x831a9988
	ctx.lr = 0x82A6E534;
	sub_831A9988(ctx, base);
	// 82A6E534: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A6E538: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6E53C: 386B5B78  addi r3, r11, 0x5b78
	ctx.r[3].s64 = ctx.r[11].s64 + 23416;
	// 82A6E540: 48739BB9  bl 0x831a80f8
	ctx.lr = 0x82A6E544;
	sub_831A80F8(ctx, base);
	// 82A6E544: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6E548: 41820014  beq 0x82a6e55c
	if ctx.cr[0].eq {
	pc = 0x82A6E55C; continue 'dispatch;
	}
	// 82A6E54C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E550: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A6E554: 4BFFB215  bl 0x82a69768
	ctx.lr = 0x82A6E558;
	sub_82A69768(ctx, base);
	// 82A6E558: 4BFFFF1C  b 0x82a6e474
	pc = 0x82A6E474; continue 'dispatch;
	// 82A6E55C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6E560: 419A03BC  beq cr6, 0x82a6e91c
	if ctx.cr[6].eq {
	pc = 0x82A6E91C; continue 'dispatch;
	}
	// 82A6E564: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E568: 4873B421  bl 0x831a9988
	ctx.lr = 0x82A6E56C;
	sub_831A9988(ctx, base);
	// 82A6E56C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6E570: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6E574: 386B7404  addi r3, r11, 0x7404
	ctx.r[3].s64 = ctx.r[11].s64 + 29700;
	// 82A6E578: 48739B81  bl 0x831a80f8
	ctx.lr = 0x82A6E57C;
	sub_831A80F8(ctx, base);
	// 82A6E57C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6E580: 41820014  beq 0x82a6e594
	if ctx.cr[0].eq {
	pc = 0x82A6E594; continue 'dispatch;
	}
	// 82A6E584: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E588: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A6E58C: 4BFFFD05  bl 0x82a6e290
	ctx.lr = 0x82A6E590;
	sub_82A6E290(ctx, base);
	// 82A6E590: 4BFFFEE4  b 0x82a6e474
	pc = 0x82A6E474; continue 'dispatch;
	// 82A6E594: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6E598: 419A0384  beq cr6, 0x82a6e91c
	if ctx.cr[6].eq {
	pc = 0x82A6E91C; continue 'dispatch;
	}
	// 82A6E59C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E5A0: 4873B3E9  bl 0x831a9988
	ctx.lr = 0x82A6E5A4;
	sub_831A9988(ctx, base);
	// 82A6E5A4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6E5A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6E5AC: 386B4FD0  addi r3, r11, 0x4fd0
	ctx.r[3].s64 = ctx.r[11].s64 + 20432;
	// 82A6E5B0: 48739B49  bl 0x831a80f8
	ctx.lr = 0x82A6E5B4;
	sub_831A80F8(ctx, base);
	// 82A6E5B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6E5B8: 41820014  beq 0x82a6e5cc
	if ctx.cr[0].eq {
	pc = 0x82A6E5CC; continue 'dispatch;
	}
	// 82A6E5BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E5C0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A6E5C4: 4BFFBCA5  bl 0x82a6a268
	ctx.lr = 0x82A6E5C8;
	sub_82A6A268(ctx, base);
	// 82A6E5C8: 4BFFFEAC  b 0x82a6e474
	pc = 0x82A6E474; continue 'dispatch;
	// 82A6E5CC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6E5D0: 419A034C  beq cr6, 0x82a6e91c
	if ctx.cr[6].eq {
	pc = 0x82A6E91C; continue 'dispatch;
	}
	// 82A6E5D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E5D8: 4873B3B1  bl 0x831a9988
	ctx.lr = 0x82A6E5DC;
	sub_831A9988(ctx, base);
	// 82A6E5DC: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 82A6E5E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6E5E4: 386BF2B0  addi r3, r11, -0xd50
	ctx.r[3].s64 = ctx.r[11].s64 + -3408;
	// 82A6E5E8: 48739B11  bl 0x831a80f8
	ctx.lr = 0x82A6E5EC;
	sub_831A80F8(ctx, base);
	// 82A6E5EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6E5F0: 41820014  beq 0x82a6e604
	if ctx.cr[0].eq {
	pc = 0x82A6E604; continue 'dispatch;
	}
	// 82A6E5F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E5F8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A6E5FC: 4BFFEF75  bl 0x82a6d570
	ctx.lr = 0x82A6E600;
	sub_82A6D570(ctx, base);
	// 82A6E600: 4800035C  b 0x82a6e95c
	pc = 0x82A6E95C; continue 'dispatch;
	// 82A6E604: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6E608: 419A0314  beq cr6, 0x82a6e91c
	if ctx.cr[6].eq {
	pc = 0x82A6E91C; continue 'dispatch;
	}
	// 82A6E60C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E610: 4873B379  bl 0x831a9988
	ctx.lr = 0x82A6E614;
	sub_831A9988(ctx, base);
	// 82A6E614: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82A6E618: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6E61C: 386B3BDC  addi r3, r11, 0x3bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 15324;
	// 82A6E620: 48739AD9  bl 0x831a80f8
	ctx.lr = 0x82A6E624;
	sub_831A80F8(ctx, base);
	// 82A6E624: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6E628: 41820014  beq 0x82a6e63c
	if ctx.cr[0].eq {
	pc = 0x82A6E63C; continue 'dispatch;
	}
	// 82A6E62C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E630: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A6E634: 4BFFADED  bl 0x82a69420
	ctx.lr = 0x82A6E638;
	sub_82A69420(ctx, base);
	// 82A6E638: 48000324  b 0x82a6e95c
	pc = 0x82A6E95C; continue 'dispatch;
	// 82A6E63C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6E640: 419A02DC  beq cr6, 0x82a6e91c
	if ctx.cr[6].eq {
	pc = 0x82A6E91C; continue 'dispatch;
	}
	// 82A6E644: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E648: 4873B341  bl 0x831a9988
	ctx.lr = 0x82A6E64C;
	sub_831A9988(ctx, base);
	// 82A6E64C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82A6E650: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6E654: 386B3A14  addi r3, r11, 0x3a14
	ctx.r[3].s64 = ctx.r[11].s64 + 14868;
	// 82A6E658: 48739AA1  bl 0x831a80f8
	ctx.lr = 0x82A6E65C;
	sub_831A80F8(ctx, base);
	// 82A6E65C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6E660: 41820014  beq 0x82a6e674
	if ctx.cr[0].eq {
	pc = 0x82A6E674; continue 'dispatch;
	}
	// 82A6E664: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E668: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A6E66C: 4BFFAE05  bl 0x82a69470
	ctx.lr = 0x82A6E670;
	sub_82A69470(ctx, base);
	// 82A6E670: 4BFFFE04  b 0x82a6e474
	pc = 0x82A6E474; continue 'dispatch;
	// 82A6E674: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6E678: 419A02A4  beq cr6, 0x82a6e91c
	if ctx.cr[6].eq {
	pc = 0x82A6E91C; continue 'dispatch;
	}
	// 82A6E67C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E680: 4873B309  bl 0x831a9988
	ctx.lr = 0x82A6E684;
	sub_831A9988(ctx, base);
	// 82A6E684: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82A6E688: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6E68C: 386B3BB4  addi r3, r11, 0x3bb4
	ctx.r[3].s64 = ctx.r[11].s64 + 15284;
	// 82A6E690: 48739A69  bl 0x831a80f8
	ctx.lr = 0x82A6E694;
	sub_831A80F8(ctx, base);
	// 82A6E694: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6E698: 41820014  beq 0x82a6e6ac
	if ctx.cr[0].eq {
	pc = 0x82A6E6AC; continue 'dispatch;
	}
	// 82A6E69C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E6A0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A6E6A4: 4BFFADAD  bl 0x82a69450
	ctx.lr = 0x82A6E6A8;
	sub_82A69450(ctx, base);
	// 82A6E6A8: 480002B4  b 0x82a6e95c
	pc = 0x82A6E95C; continue 'dispatch;
	// 82A6E6AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6E6B0: 419A026C  beq cr6, 0x82a6e91c
	if ctx.cr[6].eq {
	pc = 0x82A6E91C; continue 'dispatch;
	}
	// 82A6E6B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E6B8: 4873B2D1  bl 0x831a9988
	ctx.lr = 0x82A6E6BC;
	sub_831A9988(ctx, base);
	// 82A6E6BC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6E6C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6E6C4: 386B5028  addi r3, r11, 0x5028
	ctx.r[3].s64 = ctx.r[11].s64 + 20520;
	// 82A6E6C8: 48739A31  bl 0x831a80f8
	ctx.lr = 0x82A6E6CC;
	sub_831A80F8(ctx, base);
	// 82A6E6CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6E6D0: 41820014  beq 0x82a6e6e4
	if ctx.cr[0].eq {
	pc = 0x82A6E6E4; continue 'dispatch;
	}
	// 82A6E6D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E6D8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A6E6DC: 4BFFAC6D  bl 0x82a69348
	ctx.lr = 0x82A6E6E0;
	sub_82A69348(ctx, base);
	// 82A6E6E0: 4BFFFD94  b 0x82a6e474
	pc = 0x82A6E474; continue 'dispatch;
	// 82A6E6E4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6E6E8: 419A0234  beq cr6, 0x82a6e91c
	if ctx.cr[6].eq {
	pc = 0x82A6E91C; continue 'dispatch;
	}
	// 82A6E6EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E6F0: 4873B299  bl 0x831a9988
	ctx.lr = 0x82A6E6F4;
	sub_831A9988(ctx, base);
	// 82A6E6F4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6E6F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6E6FC: 386B4FFC  addi r3, r11, 0x4ffc
	ctx.r[3].s64 = ctx.r[11].s64 + 20476;
	// 82A6E700: 487399F9  bl 0x831a80f8
	ctx.lr = 0x82A6E704;
	sub_831A80F8(ctx, base);
	// 82A6E704: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6E708: 41820014  beq 0x82a6e71c
	if ctx.cr[0].eq {
	pc = 0x82A6E71C; continue 'dispatch;
	}
	// 82A6E70C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E710: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A6E714: 4BFFAC45  bl 0x82a69358
	ctx.lr = 0x82A6E718;
	sub_82A69358(ctx, base);
	// 82A6E718: 4BFFFD5C  b 0x82a6e474
	pc = 0x82A6E474; continue 'dispatch;
	// 82A6E71C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6E720: 419A01FC  beq cr6, 0x82a6e91c
	if ctx.cr[6].eq {
	pc = 0x82A6E91C; continue 'dispatch;
	}
	// 82A6E724: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E728: 4873B261  bl 0x831a9988
	ctx.lr = 0x82A6E72C;
	sub_831A9988(ctx, base);
	// 82A6E72C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6E730: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6E734: 386B5054  addi r3, r11, 0x5054
	ctx.r[3].s64 = ctx.r[11].s64 + 20564;
	// 82A6E738: 487399C1  bl 0x831a80f8
	ctx.lr = 0x82A6E73C;
	sub_831A80F8(ctx, base);
	// 82A6E73C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6E740: 41820014  beq 0x82a6e754
	if ctx.cr[0].eq {
	pc = 0x82A6E754; continue 'dispatch;
	}
	// 82A6E744: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E748: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A6E74C: 4BFFAC1D  bl 0x82a69368
	ctx.lr = 0x82A6E750;
	sub_82A69368(ctx, base);
	// 82A6E750: 4BFFFD24  b 0x82a6e474
	pc = 0x82A6E474; continue 'dispatch;
	// 82A6E754: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6E758: 419A01C4  beq cr6, 0x82a6e91c
	if ctx.cr[6].eq {
	pc = 0x82A6E91C; continue 'dispatch;
	}
	// 82A6E75C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E760: 4873B229  bl 0x831a9988
	ctx.lr = 0x82A6E764;
	sub_831A9988(ctx, base);
	// 82A6E764: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6E768: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6E76C: 386B73D4  addi r3, r11, 0x73d4
	ctx.r[3].s64 = ctx.r[11].s64 + 29652;
	// 82A6E770: 48739989  bl 0x831a80f8
	ctx.lr = 0x82A6E774;
	sub_831A80F8(ctx, base);
	// 82A6E774: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6E778: 41820014  beq 0x82a6e78c
	if ctx.cr[0].eq {
	pc = 0x82A6E78C; continue 'dispatch;
	}
	// 82A6E77C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E780: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A6E784: 4BFFAC0D  bl 0x82a69390
	ctx.lr = 0x82A6E788;
	sub_82A69390(ctx, base);
	// 82A6E788: 480001D4  b 0x82a6e95c
	pc = 0x82A6E95C; continue 'dispatch;
	// 82A6E78C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6E790: 419A018C  beq cr6, 0x82a6e91c
	if ctx.cr[6].eq {
	pc = 0x82A6E91C; continue 'dispatch;
	}
	// 82A6E794: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E798: 4873B1F1  bl 0x831a9988
	ctx.lr = 0x82A6E79C;
	sub_831A9988(ctx, base);
	// 82A6E79C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82A6E7A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6E7A4: 386B3824  addi r3, r11, 0x3824
	ctx.r[3].s64 = ctx.r[11].s64 + 14372;
	// 82A6E7A8: 48739951  bl 0x831a80f8
	ctx.lr = 0x82A6E7AC;
	sub_831A80F8(ctx, base);
	// 82A6E7AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6E7B0: 41820014  beq 0x82a6e7c4
	if ctx.cr[0].eq {
	pc = 0x82A6E7C4; continue 'dispatch;
	}
	// 82A6E7B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E7B8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A6E7BC: 4BFFABE5  bl 0x82a693a0
	ctx.lr = 0x82A6E7C0;
	sub_82A693A0(ctx, base);
	// 82A6E7C0: 4800019C  b 0x82a6e95c
	pc = 0x82A6E95C; continue 'dispatch;
	// 82A6E7C4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6E7C8: 419A0154  beq cr6, 0x82a6e91c
	if ctx.cr[6].eq {
	pc = 0x82A6E91C; continue 'dispatch;
	}
	// 82A6E7CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E7D0: 4873B1B9  bl 0x831a9988
	ctx.lr = 0x82A6E7D4;
	sub_831A9988(ctx, base);
	// 82A6E7D4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6E7D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6E7DC: 386B73A8  addi r3, r11, 0x73a8
	ctx.r[3].s64 = ctx.r[11].s64 + 29608;
	// 82A6E7E0: 48739919  bl 0x831a80f8
	ctx.lr = 0x82A6E7E4;
	sub_831A80F8(ctx, base);
	// 82A6E7E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6E7E8: 41820014  beq 0x82a6e7fc
	if ctx.cr[0].eq {
	pc = 0x82A6E7FC; continue 'dispatch;
	}
	// 82A6E7EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E7F0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A6E7F4: 4BFFCEF5  bl 0x82a6b6e8
	ctx.lr = 0x82A6E7F8;
	sub_82A6B6E8(ctx, base);
	// 82A6E7F8: 4BFFFC7C  b 0x82a6e474
	pc = 0x82A6E474; continue 'dispatch;
	// 82A6E7FC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6E800: 419A011C  beq cr6, 0x82a6e91c
	if ctx.cr[6].eq {
	pc = 0x82A6E91C; continue 'dispatch;
	}
	// 82A6E804: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E808: 4873B181  bl 0x831a9988
	ctx.lr = 0x82A6E80C;
	sub_831A9988(ctx, base);
	// 82A6E80C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6E810: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6E814: 386B737C  addi r3, r11, 0x737c
	ctx.r[3].s64 = ctx.r[11].s64 + 29564;
	// 82A6E818: 487398E1  bl 0x831a80f8
	ctx.lr = 0x82A6E81C;
	sub_831A80F8(ctx, base);
	// 82A6E81C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6E820: 41820014  beq 0x82a6e834
	if ctx.cr[0].eq {
	pc = 0x82A6E834; continue 'dispatch;
	}
	// 82A6E824: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E828: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A6E82C: 4BFFEC65  bl 0x82a6d490
	ctx.lr = 0x82A6E830;
	sub_82A6D490(ctx, base);
	// 82A6E830: 4BFFFC44  b 0x82a6e474
	pc = 0x82A6E474; continue 'dispatch;
	// 82A6E834: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6E838: 419A0034  beq cr6, 0x82a6e86c
	if ctx.cr[6].eq {
	pc = 0x82A6E86C; continue 'dispatch;
	}
	// 82A6E83C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E840: 4873B149  bl 0x831a9988
	ctx.lr = 0x82A6E844;
	sub_831A9988(ctx, base);
	// 82A6E844: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6E848: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6E84C: 386B5080  addi r3, r11, 0x5080
	ctx.r[3].s64 = ctx.r[11].s64 + 20608;
	// 82A6E850: 487398A9  bl 0x831a80f8
	ctx.lr = 0x82A6E854;
	sub_831A80F8(ctx, base);
	// 82A6E854: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6E858: 41820014  beq 0x82a6e86c
	if ctx.cr[0].eq {
	pc = 0x82A6E86C; continue 'dispatch;
	}
	// 82A6E85C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E860: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A6E864: 4BFFFA8D  bl 0x82a6e2f0
	ctx.lr = 0x82A6E868;
	sub_82A6E2F0(ctx, base);
	// 82A6E868: 4BFFFC0C  b 0x82a6e474
	pc = 0x82A6E474; continue 'dispatch;
	// 82A6E86C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6E870: 419A0034  beq cr6, 0x82a6e8a4
	if ctx.cr[6].eq {
	pc = 0x82A6E8A4; continue 'dispatch;
	}
	// 82A6E874: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E878: 4873B111  bl 0x831a9988
	ctx.lr = 0x82A6E87C;
	sub_831A9988(ctx, base);
	// 82A6E87C: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 82A6E880: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6E884: 386B2F78  addi r3, r11, 0x2f78
	ctx.r[3].s64 = ctx.r[11].s64 + 12152;
	// 82A6E888: 48739871  bl 0x831a80f8
	ctx.lr = 0x82A6E88C;
	sub_831A80F8(ctx, base);
	// 82A6E88C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6E890: 41820014  beq 0x82a6e8a4
	if ctx.cr[0].eq {
	pc = 0x82A6E8A4; continue 'dispatch;
	}
	// 82A6E894: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E898: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A6E89C: 4BFFAD0D  bl 0x82a695a8
	ctx.lr = 0x82A6E8A0;
	sub_82A695A8(ctx, base);
	// 82A6E8A0: 480000BC  b 0x82a6e95c
	pc = 0x82A6E95C; continue 'dispatch;
	// 82A6E8A4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6E8A8: 419A0034  beq cr6, 0x82a6e8dc
	if ctx.cr[6].eq {
	pc = 0x82A6E8DC; continue 'dispatch;
	}
	// 82A6E8AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E8B0: 4873B0D9  bl 0x831a9988
	ctx.lr = 0x82A6E8B4;
	sub_831A9988(ctx, base);
	// 82A6E8B4: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A6E8B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6E8BC: 386B59B0  addi r3, r11, 0x59b0
	ctx.r[3].s64 = ctx.r[11].s64 + 22960;
	// 82A6E8C0: 48739839  bl 0x831a80f8
	ctx.lr = 0x82A6E8C4;
	sub_831A80F8(ctx, base);
	// 82A6E8C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6E8C8: 41820014  beq 0x82a6e8dc
	if ctx.cr[0].eq {
	pc = 0x82A6E8DC; continue 'dispatch;
	}
	// 82A6E8CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E8D0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A6E8D4: 4BFFBDFD  bl 0x82a6a6d0
	ctx.lr = 0x82A6E8D8;
	sub_82A6A6D0(ctx, base);
	// 82A6E8D8: 4BFFFB9C  b 0x82a6e474
	pc = 0x82A6E474; continue 'dispatch;
	// 82A6E8DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6E8E0: 419A0034  beq cr6, 0x82a6e914
	if ctx.cr[6].eq {
	pc = 0x82A6E914; continue 'dispatch;
	}
	// 82A6E8E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E8E8: 4873B0A1  bl 0x831a9988
	ctx.lr = 0x82A6E8EC;
	sub_831A9988(ctx, base);
	// 82A6E8EC: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A6E8F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6E8F4: 386B5984  addi r3, r11, 0x5984
	ctx.r[3].s64 = ctx.r[11].s64 + 22916;
	// 82A6E8F8: 48739801  bl 0x831a80f8
	ctx.lr = 0x82A6E8FC;
	sub_831A80F8(ctx, base);
	// 82A6E8FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6E900: 41820014  beq 0x82a6e914
	if ctx.cr[0].eq {
	pc = 0x82A6E914; continue 'dispatch;
	}
	// 82A6E904: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E908: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A6E90C: 4BFFACD5  bl 0x82a695e0
	ctx.lr = 0x82A6E910;
	sub_82A695E0(ctx, base);
	// 82A6E910: 4BFFFB64  b 0x82a6e474
	pc = 0x82A6E474; continue 'dispatch;
	// 82A6E914: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A6E918: 409A0034  bne cr6, 0x82a6e94c
	if !ctx.cr[6].eq {
	pc = 0x82A6E94C; continue 'dispatch;
	}
	// 82A6E91C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E920: 4873B069  bl 0x831a9988
	ctx.lr = 0x82A6E924;
	sub_831A9988(ctx, base);
	// 82A6E924: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A6E928: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6E92C: 386B5A88  addi r3, r11, 0x5a88
	ctx.r[3].s64 = ctx.r[11].s64 + 23176;
	// 82A6E930: 487397C9  bl 0x831a80f8
	ctx.lr = 0x82A6E934;
	sub_831A80F8(ctx, base);
	// 82A6E934: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6E938: 41820014  beq 0x82a6e94c
	if ctx.cr[0].eq {
	pc = 0x82A6E94C; continue 'dispatch;
	}
	// 82A6E93C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E940: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A6E944: 4BFFF98D  bl 0x82a6e2d0
	ctx.lr = 0x82A6E948;
	sub_82A6E2D0(ctx, base);
	// 82A6E948: 4BFFFB2C  b 0x82a6e474
	pc = 0x82A6E474; continue 'dispatch;
	// 82A6E94C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A6E950: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6E954: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6E958: 4BAA3CC1  bl 0x82512618
	ctx.lr = 0x82A6E95C;
	sub_82512618(ctx, base);
	// 82A6E95C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A6E960: 48739858  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6E968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6E968 size=128
    let mut pc: u32 = 0x82A6E968;
    'dispatch: loop {
        match pc {
            0x82A6E968 => {
    //   block [0x82A6E968..0x82A6E9E8)
	// 82A6E968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6E96C: 48739801  bl 0x831a816c
	ctx.lr = 0x82A6E970;
	sub_831A8130(ctx, base);
	// 82A6E970: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6E974: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A6E978: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A6E97C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A6E980: 3BEBDFFC  addi r31, r11, -0x2004
	ctx.r[31].s64 = ctx.r[11].s64 + -8196;
	// 82A6E984: 816AE004  lwz r11, -0x1ffc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8188 as u32) ) } as u64;
	// 82A6E988: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A6E98C: 40820024  bne 0x82a6e9b0
	if !ctx.cr[0].eq {
	pc = 0x82A6E9B0; continue 'dispatch;
	}
	// 82A6E990: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 82A6E994: 3D0082A7  lis r8, -0x7d59
	ctx.r[8].s64 = -2102984704;
	// 82A6E998: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82A6E99C: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 82A6E9A0: 3908A6E0  addi r8, r8, -0x5920
	ctx.r[8].s64 = ctx.r[8].s64 + -22816;
	// 82A6E9A4: 916AE004  stw r11, -0x1ffc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8188 as u32), ctx.r[11].u32 ) };
	// 82A6E9A8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A6E9AC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A6E9B0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A6E9B4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A6E9B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6E9BC: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82A6E9C0: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82A6E9C4: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A6E9C8: 4BBE5BF9  bl 0x826545c0
	ctx.lr = 0x82A6E9CC;
	sub_826545C0(ctx, base);
	// 82A6E9CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6E9D0: 4182000C  beq 0x82a6e9dc
	if ctx.cr[0].eq {
	pc = 0x82A6E9DC; continue 'dispatch;
	}
	// 82A6E9D4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A6E9D8: 48000008  b 0x82a6e9e0
	pc = 0x82A6E9E0; continue 'dispatch;
	// 82A6E9DC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A6E9E0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A6E9E4: 487397D8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6E9E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6E9E8 size=184
    let mut pc: u32 = 0x82A6E9E8;
    'dispatch: loop {
        match pc {
            0x82A6E9E8 => {
    //   block [0x82A6E9E8..0x82A6EAA0)
	// 82A6E9E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6E9EC: 48739781  bl 0x831a816c
	ctx.lr = 0x82A6E9F0;
	sub_831A8130(ctx, base);
	// 82A6E9F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6E9F4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6E9F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6E9FC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A6EA00: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A6EA04: 388B0068  addi r4, r11, 0x68
	ctx.r[4].s64 = ctx.r[11].s64 + 104;
	// 82A6EA08: 38A00127  li r5, 0x127
	ctx.r[5].s64 = 295;
	// 82A6EA0C: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 82A6EA10: 483839D9  bl 0x82df23e8
	ctx.lr = 0x82A6EA14;
	sub_82DF23E8(ctx, base);
	// 82A6EA14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A6EA18: 41820010  beq 0x82a6ea28
	if ctx.cr[0].eq {
	pc = 0x82A6EA28; continue 'dispatch;
	}
	// 82A6EA1C: 4BB8E555  bl 0x825fcf70
	ctx.lr = 0x82A6EA20;
	sub_825FCF70(ctx, base);
	// 82A6EA20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A6EA24: 48000008  b 0x82a6ea2c
	pc = 0x82A6EA2C; continue 'dispatch;
	// 82A6EA28: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A6EA2C: 3BDF0188  addi r30, r31, 0x188
	ctx.r[30].s64 = ctx.r[31].s64 + 392;
	// 82A6EA30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6EA34: 4BB8CDC5  bl 0x825fb7f8
	ctx.lr = 0x82A6EA38;
	sub_825FB7F8(ctx, base);
	// 82A6EA38: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82A6EA3C: 4BDA3A3D  bl 0x82812478
	ctx.lr = 0x82A6EA40;
	sub_82812478(ctx, base);
	// 82A6EA40: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A6EA44: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A6EA48: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6EA4C: 483A7DF5  bl 0x82e16840
	ctx.lr = 0x82A6EA50;
	sub_82E16840(ctx, base);
	// 82A6EA50: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A6EA54: 807F0188  lwz r3, 0x188(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82A6EA58: 483A8909  bl 0x82e17360
	ctx.lr = 0x82A6EA5C;
	sub_82E17360(ctx, base);
	// 82A6EA5C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A6EA60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6EA64: 388B51D0  addi r4, r11, 0x51d0
	ctx.r[4].s64 = ctx.r[11].s64 + 20944;
	// 82A6EA68: 83DF0188  lwz r30, 0x188(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82A6EA6C: 4838AAC5  bl 0x82df9530
	ctx.lr = 0x82A6EA70;
	sub_82DF9530(ctx, base);
	// 82A6EA70: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A6EA74: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82A6EA78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6EA7C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6EA80: 483A8CC9  bl 0x82e17748
	ctx.lr = 0x82A6EA84;
	sub_82E17748(ctx, base);
	// 82A6EA84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A6EA88: 809F0190  lwz r4, 0x190(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82A6EA8C: 807F0188  lwz r3, 0x188(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82A6EA90: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A6EA94: 483CFDA5  bl 0x82e3e838
	ctx.lr = 0x82A6EA98;
	sub_82E3E838(ctx, base);
	// 82A6EA98: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A6EA9C: 48739720  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6EAA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6EAA0 size=1188
    let mut pc: u32 = 0x82A6EAA0;
    'dispatch: loop {
        match pc {
            0x82A6EAA0 => {
    //   block [0x82A6EAA0..0x82A6EF44)
	// 82A6EAA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6EAA4: 487396B9  bl 0x831a815c
	ctx.lr = 0x82A6EAA8;
	sub_831A8130(ctx, base);
	// 82A6EAA8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82A6EAAC: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6EAB0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A6EAB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6EAB8: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82A6EABC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A6EAC0: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82A6EAC4: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82A6EAC8: 4BAA2F11  bl 0x825119d8
	ctx.lr = 0x82A6EACC;
	sub_825119D8(ctx, base);
	// 82A6EACC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82A6EAD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6EAD4: 4BAA089D  bl 0x8250f370
	ctx.lr = 0x82A6EAD8;
	sub_8250F370(ctx, base);
	// 82A6EAD8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82A6EADC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6EAE0: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82A6EAE4: 48384F25  bl 0x82df3a08
	ctx.lr = 0x82A6EAE8;
	sub_82DF3A08(ctx, base);
	// 82A6EAE8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A6EAEC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A6EAF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6EAF4: 4BA99C8D  bl 0x82508780
	ctx.lr = 0x82A6EAF8;
	sub_82508780(ctx, base);
	// 82A6EAF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6EAFC: 4838492D  bl 0x82df3428
	ctx.lr = 0x82A6EB00;
	sub_82DF3428(ctx, base);
	// 82A6EB00: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A6EB04: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82A6EB08: 409A0008  bne cr6, 0x82a6eb10
	if !ctx.cr[6].eq {
	pc = 0x82A6EB10; continue 'dispatch;
	}
	// 82A6EB0C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A6EB10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6EB14: 4BA99C8D  bl 0x825087a0
	ctx.lr = 0x82A6EB18;
	sub_825087A0(ctx, base);
	// 82A6EB18: 3B5F0028  addi r26, r31, 0x28
	ctx.r[26].s64 = ctx.r[31].s64 + 40;
	// 82A6EB1C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A6EB20: 4859A499  bl 0x83008fb8
	ctx.lr = 0x82A6EB24;
	sub_83008FB8(ctx, base);
	// 82A6EB24: 3D208338  lis r9, -0x7cc8
	ctx.r[9].s64 = -2093481984;
	// 82A6EB28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A6EB2C: 395F00F8  addi r10, r31, 0xf8
	ctx.r[10].s64 = ctx.r[31].s64 + 248;
	// 82A6EB30: 389B0004  addi r4, r27, 4
	ctx.r[4].s64 = ctx.r[27].s64 + 4;
	// 82A6EB34: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82A6EB38: 9169DFF8  stw r11, -0x2008(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-8200 as u32), ctx.r[11].u32 ) };
	// 82A6EB3C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6EB40: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 82A6EB44: 4B85591D  bl 0x822c4460
	ctx.lr = 0x82A6EB48;
	sub_822C4460(ctx, base);
	// 82A6EB48: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6EB4C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A6EB50: 3B8B0068  addi r28, r11, 0x68
	ctx.r[28].s64 = ctx.r[11].s64 + 104;
	// 82A6EB54: 38A00105  li r5, 0x105
	ctx.r[5].s64 = 261;
	// 82A6EB58: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A6EB5C: 38600038  li r3, 0x38
	ctx.r[3].s64 = 56;
	// 82A6EB60: 4B851879  bl 0x822c03d8
	ctx.lr = 0x82A6EB64;
	sub_822C03D8(ctx, base);
	// 82A6EB64: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A6EB68: 4182002C  beq 0x82a6eb94
	if ctx.cr[0].eq {
	pc = 0x82A6EB94; continue 'dispatch;
	}
	// 82A6EB6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6EB70: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A6EB74: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82A6EB78: 4BAA0951  bl 0x8250f4c8
	ctx.lr = 0x82A6EB7C;
	sub_8250F4C8(ctx, base);
	// 82A6EB7C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A6EB80: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A6EB84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6EB88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A6EB8C: 48000B5D  bl 0x82a6f6e8
	ctx.lr = 0x82A6EB90;
	sub_82A6F6E8(ctx, base);
	// 82A6EB90: 48000008  b 0x82a6eb98
	pc = 0x82A6EB98; continue 'dispatch;
	// 82A6EB94: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A6EB98: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6EB9C: 907F00F0  stw r3, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[3].u32 ) };
	// 82A6EBA0: 4182000C  beq 0x82a6ebac
	if ctx.cr[0].eq {
	pc = 0x82A6EBAC; continue 'dispatch;
	}
	// 82A6EBA4: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A6EBA8: 483830E9  bl 0x82df1c90
	ctx.lr = 0x82A6EBAC;
	sub_82DF1C90(ctx, base);
	// 82A6EBAC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A6EBB0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A6EBB4: 38A00108  li r5, 0x108
	ctx.r[5].s64 = 264;
	// 82A6EBB8: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 82A6EBBC: 4B85181D  bl 0x822c03d8
	ctx.lr = 0x82A6EBC0;
	sub_822C03D8(ctx, base);
	// 82A6EBC0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A6EBC4: 41820010  beq 0x82a6ebd4
	if ctx.cr[0].eq {
	pc = 0x82A6EBD4; continue 'dispatch;
	}
	// 82A6EBC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6EBCC: 48000CA5  bl 0x82a6f870
	ctx.lr = 0x82A6EBD0;
	sub_82A6F870(ctx, base);
	// 82A6EBD0: 48000008  b 0x82a6ebd8
	pc = 0x82A6EBD8; continue 'dispatch;
	// 82A6EBD4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A6EBD8: 907F00F4  stw r3, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[3].u32 ) };
	// 82A6EBDC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A6EBE0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A6EBE4: 38A0010B  li r5, 0x10b
	ctx.r[5].s64 = 267;
	// 82A6EBE8: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 82A6EBEC: 483837FD  bl 0x82df23e8
	ctx.lr = 0x82A6EBF0;
	sub_82DF23E8(ctx, base);
	// 82A6EBF0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A6EBF4: 41820010  beq 0x82a6ec04
	if ctx.cr[0].eq {
	pc = 0x82A6EC04; continue 'dispatch;
	}
	// 82A6EBF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6EBFC: 480022A5  bl 0x82a70ea0
	ctx.lr = 0x82A6EC00;
	sub_82A70EA0(ctx, base);
	// 82A6EC00: 48000008  b 0x82a6ec08
	pc = 0x82A6EC08; continue 'dispatch;
	// 82A6EC04: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A6EC08: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A6EC0C: 907F00EC  stw r3, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[3].u32 ) };
	// 82A6EC10: 3D408327  lis r10, -0x7cd9
	ctx.r[10].s64 = -2094596096;
	// 82A6EC14: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A6EC18: 388A4E10  addi r4, r10, 0x4e10
	ctx.r[4].s64 = ctx.r[10].s64 + 19984;
	// 82A6EC1C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A6EC20: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A6EC24: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A6EC28: 4B9F1C29  bl 0x82460850
	ctx.lr = 0x82A6EC2C;
	sub_82460850(ctx, base);
	// 82A6EC2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6EC30: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A6EC34: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6EC38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6EC3C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82A6EC40: 419A0024  beq cr6, 0x82a6ec64
	if ctx.cr[6].eq {
	pc = 0x82A6EC64; continue 'dispatch;
	}
	// 82A6EC44: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6EC48: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6EC4C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6EC50: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6EC54: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6EC58: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6EC5C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6EC60: 4082FFE8  bne 0x82a6ec48
	if !ctx.cr[0].eq {
	pc = 0x82A6EC48; continue 'dispatch;
	}
	// 82A6EC64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6EC68: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82A6EC6C: 4BAA08AD  bl 0x8250f518
	ctx.lr = 0x82A6EC70;
	sub_8250F518(ctx, base);
	// 82A6EC70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6EC74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6EC78: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 82A6EC7C: 409A0008  bne cr6, 0x82a6ec84
	if !ctx.cr[6].eq {
	pc = 0x82A6EC84; continue 'dispatch;
	}
	// 82A6EC80: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A6EC84: 3BC10070  addi r30, r1, 0x70
	ctx.r[30].s64 = ctx.r[1].s64 + 112;
	// 82A6EC88: 4BAB93C9  bl 0x82528050
	ctx.lr = 0x82A6EC8C;
	sub_82528050(ctx, base);
	// 82A6EC8C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A6EC90: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A6EC94: 38A0010E  li r5, 0x10e
	ctx.r[5].s64 = 270;
	// 82A6EC98: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A6EC9C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A6ECA0: 483E8349  bl 0x82e56fe8
	ctx.lr = 0x82A6ECA4;
	sub_82E56FE8(ctx, base);
	// 82A6ECA4: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82A6ECA8: 48382FE9  bl 0x82df1c90
	ctx.lr = 0x82A6ECAC;
	sub_82DF1C90(ctx, base);
	// 82A6ECAC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A6ECB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6ECB4: 419A0008  beq cr6, 0x82a6ecbc
	if ctx.cr[6].eq {
	pc = 0x82A6ECBC; continue 'dispatch;
	}
	// 82A6ECB8: 4B851BD9  bl 0x822c0890
	ctx.lr = 0x82A6ECBC;
	sub_822C0890(ctx, base);
	// 82A6ECBC: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A6ECC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6ECC4: 419A0008  beq cr6, 0x82a6eccc
	if ctx.cr[6].eq {
	pc = 0x82A6ECCC; continue 'dispatch;
	}
	// 82A6ECC8: 4B851BC9  bl 0x822c0890
	ctx.lr = 0x82A6ECCC;
	sub_822C0890(ctx, base);
	// 82A6ECCC: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 82A6ECD0: 4BBE65C9  bl 0x82655298
	ctx.lr = 0x82A6ECD4;
	sub_82655298(ctx, base);
	// 82A6ECD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6ECD8: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82A6ECDC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6ECE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6ECE4: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82A6ECE8: 419A0024  beq cr6, 0x82a6ed0c
	if ctx.cr[6].eq {
	pc = 0x82A6ED0C; continue 'dispatch;
	}
	// 82A6ECEC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A6ECF0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A6ECF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6ECF8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A6ECFC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A6ED00: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A6ED04: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A6ED08: 4082FFE8  bne 0x82a6ecf0
	if !ctx.cr[0].eq {
	pc = 0x82A6ECF0; continue 'dispatch;
	}
	// 82A6ED0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A6ED10: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82A6ED14: 4BAA0805  bl 0x8250f518
	ctx.lr = 0x82A6ED18;
	sub_8250F518(ctx, base);
	// 82A6ED18: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6ED1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A6ED20: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 82A6ED24: 409A0008  bne cr6, 0x82a6ed2c
	if !ctx.cr[6].eq {
	pc = 0x82A6ED2C; continue 'dispatch;
	}
	// 82A6ED28: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A6ED2C: 3BC10078  addi r30, r1, 0x78
	ctx.r[30].s64 = ctx.r[1].s64 + 120;
	// 82A6ED30: 4BAB9321  bl 0x82528050
	ctx.lr = 0x82A6ED34;
	sub_82528050(ctx, base);
	// 82A6ED34: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A6ED38: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A6ED3C: 38A0010F  li r5, 0x10f
	ctx.r[5].s64 = 271;
	// 82A6ED40: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A6ED44: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A6ED48: 483E82A1  bl 0x82e56fe8
	ctx.lr = 0x82A6ED4C;
	sub_82E56FE8(ctx, base);
	// 82A6ED4C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82A6ED50: 48382F41  bl 0x82df1c90
	ctx.lr = 0x82A6ED54;
	sub_82DF1C90(ctx, base);
	// 82A6ED54: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A6ED58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6ED5C: 419A0008  beq cr6, 0x82a6ed64
	if ctx.cr[6].eq {
	pc = 0x82A6ED64; continue 'dispatch;
	}
	// 82A6ED60: 4B851B31  bl 0x822c0890
	ctx.lr = 0x82A6ED64;
	sub_822C0890(ctx, base);
	// 82A6ED64: 806100EC  lwz r3, 0xec(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A6ED68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6ED6C: 419A0008  beq cr6, 0x82a6ed74
	if ctx.cr[6].eq {
	pc = 0x82A6ED74; continue 'dispatch;
	}
	// 82A6ED70: 4B851B21  bl 0x822c0890
	ctx.lr = 0x82A6ED74;
	sub_822C0890(ctx, base);
	// 82A6ED74: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A6ED78: D3E100A0  stfs f31, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82A6ED7C: D3E100A4  stfs f31, 0xa4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82A6ED80: 38810120  addi r4, r1, 0x120
	ctx.r[4].s64 = ctx.r[1].s64 + 288;
	// 82A6ED84: D3E100AC  stfs f31, 0xac(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82A6ED88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6ED8C: C00B9534  lfs f0, -0x6acc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6ED90: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82A6ED94: 4BAA3005  bl 0x82511d98
	ctx.lr = 0x82A6ED98;
	sub_82511D98(ctx, base);
	// 82A6ED98: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 82A6ED9C: 38810120  addi r4, r1, 0x120
	ctx.r[4].s64 = ctx.r[1].s64 + 288;
	// 82A6EDA0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82A6EDA4: 4840CFA5  bl 0x82e7bd48
	ctx.lr = 0x82A6EDA8;
	sub_82E7BD48(ctx, base);
	// 82A6EDA8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A6EDAC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A6EDB0: 39200110  li r9, 0x110
	ctx.r[9].s64 = 272;
	// 82A6EDB4: 38810160  addi r4, r1, 0x160
	ctx.r[4].s64 = ctx.r[1].s64 + 352;
	// 82A6EDB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6EDBC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A6EDC0: C00A08A8  lfs f0, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A6EDC4: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82A6EDC8: D3E10094  stfs f31, 0x94(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82A6EDCC: D3E10098  stfs f31, 0x98(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82A6EDD0: D3E1009C  stfs f31, 0x9c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6EF48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6EF48 size=92
    let mut pc: u32 = 0x82A6EF48;
    'dispatch: loop {
        match pc {
            0x82A6EF48 => {
    //   block [0x82A6EF48..0x82A6EFA4)
	// 82A6EF48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6EF4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6EF50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6EF54: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6EF58: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A6EF5C: 1D440030  mulli r10, r4, 0x30
	ctx.r[10].s64 = ctx.r[4].s64 * 48;
	// 82A6EF60: 396B7440  addi r11, r11, 0x7440
	ctx.r[11].s64 = ctx.r[11].s64 + 29760;
	// 82A6EF64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6EF68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6EF6C: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A6EF70: 48384A99  bl 0x82df3a08
	ctx.lr = 0x82A6EF74;
	sub_82DF3A08(ctx, base);
	// 82A6EF74: 389F001C  addi r4, r31, 0x1c
	ctx.r[4].s64 = ctx.r[31].s64 + 28;
	// 82A6EF78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6EF7C: 4838438D  bl 0x82df3308
	ctx.lr = 0x82A6EF80;
	sub_82DF3308(ctx, base);
	// 82A6EF80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6EF84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6EF88: 483844A1  bl 0x82df3428
	ctx.lr = 0x82A6EF8C;
	sub_82DF3428(ctx, base);
	// 82A6EF8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A6EF90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6EF94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6EF98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6EF9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6EFA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6EFA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A6EFA8 size=120
    let mut pc: u32 = 0x82A6EFA8;
    'dispatch: loop {
        match pc {
            0x82A6EFA8 => {
    //   block [0x82A6EFA8..0x82A6F020)
	// 82A6EFA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6EFAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6EFB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6EFB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6EFB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6EFBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6EFC0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A6EFC4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A6EFC8: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6EFCC: 4838F815  bl 0x82dfe7e0
	ctx.lr = 0x82A6EFD0;
	sub_82DFE7E0(ctx, base);
	// 82A6EFD0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6EFD4: 41820028  beq 0x82a6effc
	if ctx.cr[0].eq {
	pc = 0x82A6EFFC; continue 'dispatch;
	}
	// 82A6EFD8: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A6EFDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6EFE0: 419A001C  beq cr6, 0x82a6effc
	if ctx.cr[6].eq {
	pc = 0x82A6EFFC; continue 'dispatch;
	}
	// 82A6EFE4: 48145835  bl 0x82bb4818
	ctx.lr = 0x82A6EFE8;
	sub_82BB4818(ctx, base);
	// 82A6EFE8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A6EFEC: 41820010  beq 0x82a6effc
	if ctx.cr[0].eq {
	pc = 0x82A6EFFC; continue 'dispatch;
	}
	// 82A6EFF0: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A6EFF4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A6EFF8: 481464F9  bl 0x82bb54f0
	ctx.lr = 0x82A6EFFC;
	sub_82BB54F0(ctx, base);
	// 82A6EFFC: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82A6F000: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A6F004: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82A6F008: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A6F00C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6F010: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6F014: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6F018: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6F01C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6F020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6F020 size=180
    let mut pc: u32 = 0x82A6F020;
    'dispatch: loop {
        match pc {
            0x82A6F020 => {
    //   block [0x82A6F020..0x82A6F0D4)
	// 82A6F020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6F024: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6F028: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6F02C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6F030: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6F034: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A6F038: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82A6F03C: 396B0268  addi r11, r11, 0x268
	ctx.r[11].s64 = ctx.r[11].s64 + 616;
	// 82A6F040: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A6F044: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A6F048: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82A6F04C: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A6F050: 808A7058  lwz r4, 0x7058(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A6F054: 4BAA119D  bl 0x825101f0
	ctx.lr = 0x82A6F058;
	sub_825101F0(ctx, base);
	// 82A6F058: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82A6F05C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6F060: 419A0018  beq cr6, 0x82a6f078
	if ctx.cr[6].eq {
	pc = 0x82A6F078; continue 'dispatch;
	}
	// 82A6F064: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6F068: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A6F06C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6F070: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A6F074: 4E800421  bctrl
	ctx.lr = 0x82A6F078;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A6F078: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82A6F07C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6F080: 419A0008  beq cr6, 0x82a6f088
	if ctx.cr[6].eq {
	pc = 0x82A6F088; continue 'dispatch;
	}
	// 82A6F084: 4B85180D  bl 0x822c0890
	ctx.lr = 0x82A6F088;
	sub_822C0890(ctx, base);
	// 82A6F088: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82A6F08C: 4838439D  bl 0x82df3428
	ctx.lr = 0x82A6F090;
	sub_82DF3428(ctx, base);
	// 82A6F090: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A6F094: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6F098: 419A0008  beq cr6, 0x82a6f0a0
	if ctx.cr[6].eq {
	pc = 0x82A6F0A0; continue 'dispatch;
	}
	// 82A6F09C: 4B8517F5  bl 0x822c0890
	ctx.lr = 0x82A6F0A0;
	sub_822C0890(ctx, base);
	// 82A6F0A0: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A6F0A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6F0A8: 419A0008  beq cr6, 0x82a6f0b0
	if ctx.cr[6].eq {
	pc = 0x82A6F0B0; continue 'dispatch;
	}
	// 82A6F0AC: 4B8517E5  bl 0x822c0890
	ctx.lr = 0x82A6F0B0;
	sub_822C0890(ctx, base);
	// 82A6F0B0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A6F0B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6F0B8: 419A0008  beq cr6, 0x82a6f0c0
	if ctx.cr[6].eq {
	pc = 0x82A6F0C0; continue 'dispatch;
	}
	// 82A6F0BC: 4B8517D5  bl 0x822c0890
	ctx.lr = 0x82A6F0C0;
	sub_822C0890(ctx, base);
	// 82A6F0C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A6F0C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6F0C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6F0CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6F0D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A6F0D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A6F0D8 size=196
    let mut pc: u32 = 0x82A6F0D8;
    'dispatch: loop {
        match pc {
            0x82A6F0D8 => {
    //   block [0x82A6F0D8..0x82A6F19C)
	// 82A6F0D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A6F0DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A6F0E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A6F0E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A6F0E8: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82A6F0EC: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A6F0F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A6F0F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A6F0F8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A6F0FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A6F100: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82A6F104: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82A6F108: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A6F10C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A6F110: 419A006C  beq cr6, 0x82a6f17c
	if ctx.cr[6].eq {
	pc = 0x82A6F17C; continue 'dispatch;
	}
	// 82A6F114: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82A6F118: 48384AB9  bl 0x82df3bd0
	ctx.lr = 0x82A6F11C;
	sub_82DF3BD0(ctx, base);
	// 82A6F11C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A6F120: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A6F124: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A6F128: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82A6F12C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A6F130: 48144249  bl 0x82bb3378
	ctx.lr = 0x82A6F134;
	sub_82BB3378(ctx, base);
	// 82A6F134: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A6F138: 3BDF0014  addi r30, r31, 0x14
	ctx.r[30].s64 = ctx.r[31].s64 + 20;
	// 82A6F13C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A6F140: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82A6F144: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6F148: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82A6F14C: 4B855315  bl 0x822c4460
	ctx.lr = 0x82A6F150;
	sub_822C4460(ctx, base);
	// 82A6F150: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A6F154: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6F158: 419A0008  beq cr6, 0x82a6f160
	if ctx.cr[6].eq {
	pc = 0x82A6F160; continue 'dispatch;
	}
	// 82A6F15C: 4B851735  bl 0x822c0890
	ctx.lr = 0x82A6F160;
	sub_822C0890(ctx, base);
	// 82A6F160: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A6F164: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A6F168: 419A000C  beq cr6, 0x82a6f174
	if ctx.cr[6].eq {
	pc = 0x82A6F174; continue 'dispatch;
	}
	// 82A6F16C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A6F170: 48149901  bl 0x82bb8a70
	ctx.lr = 0x82A6F174;
	sub_82BB8A70(ctx, base);
	// 82A6F174: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82A6F178: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82A6F17C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A6F180: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A6F184: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A6F188: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A6F18C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A6F190: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A6F194: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A6F198: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


