pub fn sub_82A1CDB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1CDB0 size=100
    let mut pc: u32 = 0x82A1CDB0;
    'dispatch: loop {
        match pc {
            0x82A1CDB0 => {
    //   block [0x82A1CDB0..0x82A1CE14)
	// 82A1CDB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1CDB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1CDB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1CDBC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1CDC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1CDC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1CDC8: 4BFFF6B9  bl 0x82a1c480
	ctx.lr = 0x82A1CDCC;
	sub_82A1C480(ctx, base);
	// 82A1CDCC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1CDD0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1CDD4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A1CDD8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A1CDDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1CDE0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1CDE4: 419A0018  beq cr6, 0x82a1cdfc
	if ctx.cr[6].eq {
	pc = 0x82A1CDFC; continue 'dispatch;
	}
	// 82A1CDE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1CDEC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A1CDF0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1CDF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A1CDF8: 4E800421  bctrl
	ctx.lr = 0x82A1CDFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1CDFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1CE00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1CE04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1CE08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1CE0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1CE10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1CE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1CE18 size=92
    let mut pc: u32 = 0x82A1CE18;
    'dispatch: loop {
        match pc {
            0x82A1CE18 => {
    //   block [0x82A1CE18..0x82A1CE74)
	// 82A1CE18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1CE1C: 4878B351  bl 0x831a816c
	ctx.lr = 0x82A1CE20;
	sub_831A8130(ctx, base);
	// 82A1CE20: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1CE24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1CE28: 3D4082A2  lis r10, -0x7d5e
	ctx.r[10].s64 = -2103312384;
	// 82A1CE2C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1CE30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1CE34: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1CE38: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1CE3C: 388AC4F0  addi r4, r10, -0x3b10
	ctx.r[4].s64 = ctx.r[10].s64 + -15120;
	// 82A1CE40: 4B942C31  bl 0x8235fa70
	ctx.lr = 0x82A1CE44;
	sub_8235FA70(ctx, base);
	// 82A1CE44: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1CE48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1CE4C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A1CE50: 483D6DB1  bl 0x82df3c00
	ctx.lr = 0x82A1CE54;
	sub_82DF3C00(ctx, base);
	// 82A1CE54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1CE58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1CE5C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1CE60: 4843F2F9  bl 0x82e5c158
	ctx.lr = 0x82A1CE64;
	sub_82E5C158(ctx, base);
	// 82A1CE64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1CE68: 483D65C1  bl 0x82df3428
	ctx.lr = 0x82A1CE6C;
	sub_82DF3428(ctx, base);
	// 82A1CE6C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1CE70: 4878B34C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1CE78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1CE78 size=92
    let mut pc: u32 = 0x82A1CE78;
    'dispatch: loop {
        match pc {
            0x82A1CE78 => {
    //   block [0x82A1CE78..0x82A1CED4)
	// 82A1CE78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1CE7C: 4878B2F1  bl 0x831a816c
	ctx.lr = 0x82A1CE80;
	sub_831A8130(ctx, base);
	// 82A1CE80: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1CE84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1CE88: 3D4082A2  lis r10, -0x7d5e
	ctx.r[10].s64 = -2103312384;
	// 82A1CE8C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1CE90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1CE94: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1CE98: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1CE9C: 388AC560  addi r4, r10, -0x3aa0
	ctx.r[4].s64 = ctx.r[10].s64 + -15008;
	// 82A1CEA0: 4B942BD1  bl 0x8235fa70
	ctx.lr = 0x82A1CEA4;
	sub_8235FA70(ctx, base);
	// 82A1CEA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1CEA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1CEAC: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A1CEB0: 483D6D51  bl 0x82df3c00
	ctx.lr = 0x82A1CEB4;
	sub_82DF3C00(ctx, base);
	// 82A1CEB4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1CEB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1CEBC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1CEC0: 4843F299  bl 0x82e5c158
	ctx.lr = 0x82A1CEC4;
	sub_82E5C158(ctx, base);
	// 82A1CEC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1CEC8: 483D6561  bl 0x82df3428
	ctx.lr = 0x82A1CECC;
	sub_82DF3428(ctx, base);
	// 82A1CECC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1CED0: 4878B2EC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1CED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1CED8 size=92
    let mut pc: u32 = 0x82A1CED8;
    'dispatch: loop {
        match pc {
            0x82A1CED8 => {
    //   block [0x82A1CED8..0x82A1CF34)
	// 82A1CED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1CEDC: 4878B291  bl 0x831a816c
	ctx.lr = 0x82A1CEE0;
	sub_831A8130(ctx, base);
	// 82A1CEE0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1CEE4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1CEE8: 3D4082A2  lis r10, -0x7d5e
	ctx.r[10].s64 = -2103312384;
	// 82A1CEEC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1CEF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1CEF4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1CEF8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1CEFC: 388AC5D0  addi r4, r10, -0x3a30
	ctx.r[4].s64 = ctx.r[10].s64 + -14896;
	// 82A1CF00: 4B942B71  bl 0x8235fa70
	ctx.lr = 0x82A1CF04;
	sub_8235FA70(ctx, base);
	// 82A1CF04: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1CF08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1CF0C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A1CF10: 483D6CF1  bl 0x82df3c00
	ctx.lr = 0x82A1CF14;
	sub_82DF3C00(ctx, base);
	// 82A1CF14: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1CF18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1CF1C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1CF20: 4843F239  bl 0x82e5c158
	ctx.lr = 0x82A1CF24;
	sub_82E5C158(ctx, base);
	// 82A1CF24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1CF28: 483D6501  bl 0x82df3428
	ctx.lr = 0x82A1CF2C;
	sub_82DF3428(ctx, base);
	// 82A1CF2C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1CF30: 4878B28C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1CF38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1CF38 size=92
    let mut pc: u32 = 0x82A1CF38;
    'dispatch: loop {
        match pc {
            0x82A1CF38 => {
    //   block [0x82A1CF38..0x82A1CF94)
	// 82A1CF38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1CF3C: 4878B231  bl 0x831a816c
	ctx.lr = 0x82A1CF40;
	sub_831A8130(ctx, base);
	// 82A1CF40: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1CF44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1CF48: 3D4082A2  lis r10, -0x7d5e
	ctx.r[10].s64 = -2103312384;
	// 82A1CF4C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1CF50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1CF54: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1CF58: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1CF5C: 388AC640  addi r4, r10, -0x39c0
	ctx.r[4].s64 = ctx.r[10].s64 + -14784;
	// 82A1CF60: 4B942B11  bl 0x8235fa70
	ctx.lr = 0x82A1CF64;
	sub_8235FA70(ctx, base);
	// 82A1CF64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1CF68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1CF6C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A1CF70: 483D6C91  bl 0x82df3c00
	ctx.lr = 0x82A1CF74;
	sub_82DF3C00(ctx, base);
	// 82A1CF74: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1CF78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1CF7C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1CF80: 4843F1D9  bl 0x82e5c158
	ctx.lr = 0x82A1CF84;
	sub_82E5C158(ctx, base);
	// 82A1CF84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1CF88: 483D64A1  bl 0x82df3428
	ctx.lr = 0x82A1CF8C;
	sub_82DF3428(ctx, base);
	// 82A1CF8C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1CF90: 4878B22C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1CF98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1CF98 size=92
    let mut pc: u32 = 0x82A1CF98;
    'dispatch: loop {
        match pc {
            0x82A1CF98 => {
    //   block [0x82A1CF98..0x82A1CFF4)
	// 82A1CF98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1CF9C: 4878B1D1  bl 0x831a816c
	ctx.lr = 0x82A1CFA0;
	sub_831A8130(ctx, base);
	// 82A1CFA0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1CFA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1CFA8: 3D4082A2  lis r10, -0x7d5e
	ctx.r[10].s64 = -2103312384;
	// 82A1CFAC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1CFB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1CFB4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1CFB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1CFBC: 388AC6B0  addi r4, r10, -0x3950
	ctx.r[4].s64 = ctx.r[10].s64 + -14672;
	// 82A1CFC0: 4B942AB1  bl 0x8235fa70
	ctx.lr = 0x82A1CFC4;
	sub_8235FA70(ctx, base);
	// 82A1CFC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1CFC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1CFCC: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A1CFD0: 483D6C31  bl 0x82df3c00
	ctx.lr = 0x82A1CFD4;
	sub_82DF3C00(ctx, base);
	// 82A1CFD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1CFD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1CFDC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1CFE0: 4843F179  bl 0x82e5c158
	ctx.lr = 0x82A1CFE4;
	sub_82E5C158(ctx, base);
	// 82A1CFE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1CFE8: 483D6441  bl 0x82df3428
	ctx.lr = 0x82A1CFEC;
	sub_82DF3428(ctx, base);
	// 82A1CFEC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1CFF0: 4878B1CC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1CFF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1CFF8 size=92
    let mut pc: u32 = 0x82A1CFF8;
    'dispatch: loop {
        match pc {
            0x82A1CFF8 => {
    //   block [0x82A1CFF8..0x82A1D054)
	// 82A1CFF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1CFFC: 4878B171  bl 0x831a816c
	ctx.lr = 0x82A1D000;
	sub_831A8130(ctx, base);
	// 82A1D000: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1D004: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1D008: 3D4082A2  lis r10, -0x7d5e
	ctx.r[10].s64 = -2103312384;
	// 82A1D00C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1D010: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1D014: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1D018: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D01C: 388AC720  addi r4, r10, -0x38e0
	ctx.r[4].s64 = ctx.r[10].s64 + -14560;
	// 82A1D020: 4B942A51  bl 0x8235fa70
	ctx.lr = 0x82A1D024;
	sub_8235FA70(ctx, base);
	// 82A1D024: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1D028: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D02C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A1D030: 483D6BD1  bl 0x82df3c00
	ctx.lr = 0x82A1D034;
	sub_82DF3C00(ctx, base);
	// 82A1D034: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D038: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D03C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1D040: 4843F119  bl 0x82e5c158
	ctx.lr = 0x82A1D044;
	sub_82E5C158(ctx, base);
	// 82A1D044: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1D048: 483D63E1  bl 0x82df3428
	ctx.lr = 0x82A1D04C;
	sub_82DF3428(ctx, base);
	// 82A1D04C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1D050: 4878B16C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1D058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1D058 size=92
    let mut pc: u32 = 0x82A1D058;
    'dispatch: loop {
        match pc {
            0x82A1D058 => {
    //   block [0x82A1D058..0x82A1D0B4)
	// 82A1D058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1D05C: 4878B111  bl 0x831a816c
	ctx.lr = 0x82A1D060;
	sub_831A8130(ctx, base);
	// 82A1D060: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1D064: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1D068: 3D4082A2  lis r10, -0x7d5e
	ctx.r[10].s64 = -2103312384;
	// 82A1D06C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1D070: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1D074: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1D078: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D07C: 388AC790  addi r4, r10, -0x3870
	ctx.r[4].s64 = ctx.r[10].s64 + -14448;
	// 82A1D080: 4B9429F1  bl 0x8235fa70
	ctx.lr = 0x82A1D084;
	sub_8235FA70(ctx, base);
	// 82A1D084: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1D088: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D08C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A1D090: 483D6B71  bl 0x82df3c00
	ctx.lr = 0x82A1D094;
	sub_82DF3C00(ctx, base);
	// 82A1D094: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D098: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D09C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1D0A0: 4843F0B9  bl 0x82e5c158
	ctx.lr = 0x82A1D0A4;
	sub_82E5C158(ctx, base);
	// 82A1D0A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1D0A8: 483D6381  bl 0x82df3428
	ctx.lr = 0x82A1D0AC;
	sub_82DF3428(ctx, base);
	// 82A1D0AC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1D0B0: 4878B10C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1D0B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1D0B8 size=92
    let mut pc: u32 = 0x82A1D0B8;
    'dispatch: loop {
        match pc {
            0x82A1D0B8 => {
    //   block [0x82A1D0B8..0x82A1D114)
	// 82A1D0B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1D0BC: 4878B0B1  bl 0x831a816c
	ctx.lr = 0x82A1D0C0;
	sub_831A8130(ctx, base);
	// 82A1D0C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1D0C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1D0C8: 3D4082A2  lis r10, -0x7d5e
	ctx.r[10].s64 = -2103312384;
	// 82A1D0CC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1D0D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1D0D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1D0D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D0DC: 388AC800  addi r4, r10, -0x3800
	ctx.r[4].s64 = ctx.r[10].s64 + -14336;
	// 82A1D0E0: 4B942991  bl 0x8235fa70
	ctx.lr = 0x82A1D0E4;
	sub_8235FA70(ctx, base);
	// 82A1D0E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1D0E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D0EC: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A1D0F0: 483D6B11  bl 0x82df3c00
	ctx.lr = 0x82A1D0F4;
	sub_82DF3C00(ctx, base);
	// 82A1D0F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D0F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D0FC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1D100: 4843F059  bl 0x82e5c158
	ctx.lr = 0x82A1D104;
	sub_82E5C158(ctx, base);
	// 82A1D104: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1D108: 483D6321  bl 0x82df3428
	ctx.lr = 0x82A1D10C;
	sub_82DF3428(ctx, base);
	// 82A1D10C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1D110: 4878B0AC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1D118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1D118 size=92
    let mut pc: u32 = 0x82A1D118;
    'dispatch: loop {
        match pc {
            0x82A1D118 => {
    //   block [0x82A1D118..0x82A1D174)
	// 82A1D118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1D11C: 4878B051  bl 0x831a816c
	ctx.lr = 0x82A1D120;
	sub_831A8130(ctx, base);
	// 82A1D120: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1D124: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1D128: 3D4082A2  lis r10, -0x7d5e
	ctx.r[10].s64 = -2103312384;
	// 82A1D12C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1D130: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1D134: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1D138: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D13C: 388AC870  addi r4, r10, -0x3790
	ctx.r[4].s64 = ctx.r[10].s64 + -14224;
	// 82A1D140: 4B942931  bl 0x8235fa70
	ctx.lr = 0x82A1D144;
	sub_8235FA70(ctx, base);
	// 82A1D144: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1D148: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D14C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A1D150: 483D6AB1  bl 0x82df3c00
	ctx.lr = 0x82A1D154;
	sub_82DF3C00(ctx, base);
	// 82A1D154: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D158: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D15C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1D160: 4843EFF9  bl 0x82e5c158
	ctx.lr = 0x82A1D164;
	sub_82E5C158(ctx, base);
	// 82A1D164: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1D168: 483D62C1  bl 0x82df3428
	ctx.lr = 0x82A1D16C;
	sub_82DF3428(ctx, base);
	// 82A1D16C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1D170: 4878B04C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1D178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1D178 size=92
    let mut pc: u32 = 0x82A1D178;
    'dispatch: loop {
        match pc {
            0x82A1D178 => {
    //   block [0x82A1D178..0x82A1D1D4)
	// 82A1D178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1D17C: 4878AFF1  bl 0x831a816c
	ctx.lr = 0x82A1D180;
	sub_831A8130(ctx, base);
	// 82A1D180: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1D184: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1D188: 3D4082A2  lis r10, -0x7d5e
	ctx.r[10].s64 = -2103312384;
	// 82A1D18C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1D190: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1D194: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1D198: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D19C: 388AC8E0  addi r4, r10, -0x3720
	ctx.r[4].s64 = ctx.r[10].s64 + -14112;
	// 82A1D1A0: 4B9428D1  bl 0x8235fa70
	ctx.lr = 0x82A1D1A4;
	sub_8235FA70(ctx, base);
	// 82A1D1A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1D1A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D1AC: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A1D1B0: 483D6A51  bl 0x82df3c00
	ctx.lr = 0x82A1D1B4;
	sub_82DF3C00(ctx, base);
	// 82A1D1B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D1B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D1BC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1D1C0: 4843EF99  bl 0x82e5c158
	ctx.lr = 0x82A1D1C4;
	sub_82E5C158(ctx, base);
	// 82A1D1C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1D1C8: 483D6261  bl 0x82df3428
	ctx.lr = 0x82A1D1CC;
	sub_82DF3428(ctx, base);
	// 82A1D1CC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1D1D0: 4878AFEC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1D1D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1D1D8 size=92
    let mut pc: u32 = 0x82A1D1D8;
    'dispatch: loop {
        match pc {
            0x82A1D1D8 => {
    //   block [0x82A1D1D8..0x82A1D234)
	// 82A1D1D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1D1DC: 4878AF91  bl 0x831a816c
	ctx.lr = 0x82A1D1E0;
	sub_831A8130(ctx, base);
	// 82A1D1E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1D1E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1D1E8: 3D4082A2  lis r10, -0x7d5e
	ctx.r[10].s64 = -2103312384;
	// 82A1D1EC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1D1F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1D1F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1D1F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D1FC: 388AC950  addi r4, r10, -0x36b0
	ctx.r[4].s64 = ctx.r[10].s64 + -14000;
	// 82A1D200: 4B942871  bl 0x8235fa70
	ctx.lr = 0x82A1D204;
	sub_8235FA70(ctx, base);
	// 82A1D204: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1D208: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D20C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A1D210: 483D69F1  bl 0x82df3c00
	ctx.lr = 0x82A1D214;
	sub_82DF3C00(ctx, base);
	// 82A1D214: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D218: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D21C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1D220: 4843EF39  bl 0x82e5c158
	ctx.lr = 0x82A1D224;
	sub_82E5C158(ctx, base);
	// 82A1D224: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1D228: 483D6201  bl 0x82df3428
	ctx.lr = 0x82A1D22C;
	sub_82DF3428(ctx, base);
	// 82A1D22C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1D230: 4878AF8C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1D238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1D238 size=92
    let mut pc: u32 = 0x82A1D238;
    'dispatch: loop {
        match pc {
            0x82A1D238 => {
    //   block [0x82A1D238..0x82A1D294)
	// 82A1D238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1D23C: 4878AF31  bl 0x831a816c
	ctx.lr = 0x82A1D240;
	sub_831A8130(ctx, base);
	// 82A1D240: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1D244: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1D248: 3D4082A2  lis r10, -0x7d5e
	ctx.r[10].s64 = -2103312384;
	// 82A1D24C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1D250: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1D254: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1D258: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D25C: 388AC9C0  addi r4, r10, -0x3640
	ctx.r[4].s64 = ctx.r[10].s64 + -13888;
	// 82A1D260: 4B942811  bl 0x8235fa70
	ctx.lr = 0x82A1D264;
	sub_8235FA70(ctx, base);
	// 82A1D264: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1D268: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D26C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A1D270: 483D6991  bl 0x82df3c00
	ctx.lr = 0x82A1D274;
	sub_82DF3C00(ctx, base);
	// 82A1D274: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D278: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D27C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1D280: 4843EED9  bl 0x82e5c158
	ctx.lr = 0x82A1D284;
	sub_82E5C158(ctx, base);
	// 82A1D284: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1D288: 483D61A1  bl 0x82df3428
	ctx.lr = 0x82A1D28C;
	sub_82DF3428(ctx, base);
	// 82A1D28C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1D290: 4878AF2C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1D298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1D298 size=92
    let mut pc: u32 = 0x82A1D298;
    'dispatch: loop {
        match pc {
            0x82A1D298 => {
    //   block [0x82A1D298..0x82A1D2F4)
	// 82A1D298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1D29C: 4878AED1  bl 0x831a816c
	ctx.lr = 0x82A1D2A0;
	sub_831A8130(ctx, base);
	// 82A1D2A0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1D2A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1D2A8: 3D4082A2  lis r10, -0x7d5e
	ctx.r[10].s64 = -2103312384;
	// 82A1D2AC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1D2B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1D2B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1D2B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D2BC: 388ACA30  addi r4, r10, -0x35d0
	ctx.r[4].s64 = ctx.r[10].s64 + -13776;
	// 82A1D2C0: 4B9427B1  bl 0x8235fa70
	ctx.lr = 0x82A1D2C4;
	sub_8235FA70(ctx, base);
	// 82A1D2C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1D2C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D2CC: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A1D2D0: 483D6931  bl 0x82df3c00
	ctx.lr = 0x82A1D2D4;
	sub_82DF3C00(ctx, base);
	// 82A1D2D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D2D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D2DC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1D2E0: 4843EE79  bl 0x82e5c158
	ctx.lr = 0x82A1D2E4;
	sub_82E5C158(ctx, base);
	// 82A1D2E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1D2E8: 483D6141  bl 0x82df3428
	ctx.lr = 0x82A1D2EC;
	sub_82DF3428(ctx, base);
	// 82A1D2EC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1D2F0: 4878AECC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1D2F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1D2F8 size=92
    let mut pc: u32 = 0x82A1D2F8;
    'dispatch: loop {
        match pc {
            0x82A1D2F8 => {
    //   block [0x82A1D2F8..0x82A1D354)
	// 82A1D2F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1D2FC: 4878AE71  bl 0x831a816c
	ctx.lr = 0x82A1D300;
	sub_831A8130(ctx, base);
	// 82A1D300: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1D304: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1D308: 3D4082A2  lis r10, -0x7d5e
	ctx.r[10].s64 = -2103312384;
	// 82A1D30C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1D310: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1D314: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1D318: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D31C: 388ACAA0  addi r4, r10, -0x3560
	ctx.r[4].s64 = ctx.r[10].s64 + -13664;
	// 82A1D320: 4B942751  bl 0x8235fa70
	ctx.lr = 0x82A1D324;
	sub_8235FA70(ctx, base);
	// 82A1D324: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1D328: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D32C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A1D330: 483D68D1  bl 0x82df3c00
	ctx.lr = 0x82A1D334;
	sub_82DF3C00(ctx, base);
	// 82A1D334: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D33C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1D340: 4843EE19  bl 0x82e5c158
	ctx.lr = 0x82A1D344;
	sub_82E5C158(ctx, base);
	// 82A1D344: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1D348: 483D60E1  bl 0x82df3428
	ctx.lr = 0x82A1D34C;
	sub_82DF3428(ctx, base);
	// 82A1D34C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1D350: 4878AE6C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1D358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1D358 size=92
    let mut pc: u32 = 0x82A1D358;
    'dispatch: loop {
        match pc {
            0x82A1D358 => {
    //   block [0x82A1D358..0x82A1D3B4)
	// 82A1D358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1D35C: 4878AE11  bl 0x831a816c
	ctx.lr = 0x82A1D360;
	sub_831A8130(ctx, base);
	// 82A1D360: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1D364: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1D368: 3D4082A2  lis r10, -0x7d5e
	ctx.r[10].s64 = -2103312384;
	// 82A1D36C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1D370: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1D374: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1D378: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D37C: 388ACB10  addi r4, r10, -0x34f0
	ctx.r[4].s64 = ctx.r[10].s64 + -13552;
	// 82A1D380: 4B9426F1  bl 0x8235fa70
	ctx.lr = 0x82A1D384;
	sub_8235FA70(ctx, base);
	// 82A1D384: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1D388: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D38C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A1D390: 483D6871  bl 0x82df3c00
	ctx.lr = 0x82A1D394;
	sub_82DF3C00(ctx, base);
	// 82A1D394: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D39C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1D3A0: 4843EDB9  bl 0x82e5c158
	ctx.lr = 0x82A1D3A4;
	sub_82E5C158(ctx, base);
	// 82A1D3A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1D3A8: 483D6081  bl 0x82df3428
	ctx.lr = 0x82A1D3AC;
	sub_82DF3428(ctx, base);
	// 82A1D3AC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1D3B0: 4878AE0C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1D3B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1D3B8 size=92
    let mut pc: u32 = 0x82A1D3B8;
    'dispatch: loop {
        match pc {
            0x82A1D3B8 => {
    //   block [0x82A1D3B8..0x82A1D414)
	// 82A1D3B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1D3BC: 4878ADB1  bl 0x831a816c
	ctx.lr = 0x82A1D3C0;
	sub_831A8130(ctx, base);
	// 82A1D3C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1D3C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1D3C8: 3D4082A2  lis r10, -0x7d5e
	ctx.r[10].s64 = -2103312384;
	// 82A1D3CC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1D3D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1D3D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1D3D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D3DC: 388ACB80  addi r4, r10, -0x3480
	ctx.r[4].s64 = ctx.r[10].s64 + -13440;
	// 82A1D3E0: 4B942691  bl 0x8235fa70
	ctx.lr = 0x82A1D3E4;
	sub_8235FA70(ctx, base);
	// 82A1D3E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1D3E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D3EC: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A1D3F0: 483D6811  bl 0x82df3c00
	ctx.lr = 0x82A1D3F4;
	sub_82DF3C00(ctx, base);
	// 82A1D3F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D3F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D3FC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1D400: 4843ED59  bl 0x82e5c158
	ctx.lr = 0x82A1D404;
	sub_82E5C158(ctx, base);
	// 82A1D404: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1D408: 483D6021  bl 0x82df3428
	ctx.lr = 0x82A1D40C;
	sub_82DF3428(ctx, base);
	// 82A1D40C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1D410: 4878ADAC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1D418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1D418 size=92
    let mut pc: u32 = 0x82A1D418;
    'dispatch: loop {
        match pc {
            0x82A1D418 => {
    //   block [0x82A1D418..0x82A1D474)
	// 82A1D418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1D41C: 4878AD51  bl 0x831a816c
	ctx.lr = 0x82A1D420;
	sub_831A8130(ctx, base);
	// 82A1D420: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1D424: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1D428: 3D4082A2  lis r10, -0x7d5e
	ctx.r[10].s64 = -2103312384;
	// 82A1D42C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1D430: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1D434: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1D438: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D43C: 388ACBF0  addi r4, r10, -0x3410
	ctx.r[4].s64 = ctx.r[10].s64 + -13328;
	// 82A1D440: 4B942631  bl 0x8235fa70
	ctx.lr = 0x82A1D444;
	sub_8235FA70(ctx, base);
	// 82A1D444: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1D448: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D44C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A1D450: 483D67B1  bl 0x82df3c00
	ctx.lr = 0x82A1D454;
	sub_82DF3C00(ctx, base);
	// 82A1D454: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D458: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D45C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1D460: 4843ECF9  bl 0x82e5c158
	ctx.lr = 0x82A1D464;
	sub_82E5C158(ctx, base);
	// 82A1D464: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1D468: 483D5FC1  bl 0x82df3428
	ctx.lr = 0x82A1D46C;
	sub_82DF3428(ctx, base);
	// 82A1D46C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1D470: 4878AD4C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1D478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1D478 size=92
    let mut pc: u32 = 0x82A1D478;
    'dispatch: loop {
        match pc {
            0x82A1D478 => {
    //   block [0x82A1D478..0x82A1D4D4)
	// 82A1D478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1D47C: 4878ACF1  bl 0x831a816c
	ctx.lr = 0x82A1D480;
	sub_831A8130(ctx, base);
	// 82A1D480: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1D484: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1D488: 3D4082A2  lis r10, -0x7d5e
	ctx.r[10].s64 = -2103312384;
	// 82A1D48C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1D490: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1D494: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1D498: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D49C: 388ACC60  addi r4, r10, -0x33a0
	ctx.r[4].s64 = ctx.r[10].s64 + -13216;
	// 82A1D4A0: 4B9425D1  bl 0x8235fa70
	ctx.lr = 0x82A1D4A4;
	sub_8235FA70(ctx, base);
	// 82A1D4A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1D4A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D4AC: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A1D4B0: 483D6751  bl 0x82df3c00
	ctx.lr = 0x82A1D4B4;
	sub_82DF3C00(ctx, base);
	// 82A1D4B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D4B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D4BC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1D4C0: 4843EC99  bl 0x82e5c158
	ctx.lr = 0x82A1D4C4;
	sub_82E5C158(ctx, base);
	// 82A1D4C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1D4C8: 483D5F61  bl 0x82df3428
	ctx.lr = 0x82A1D4CC;
	sub_82DF3428(ctx, base);
	// 82A1D4CC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1D4D0: 4878ACEC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1D4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1D4D8 size=92
    let mut pc: u32 = 0x82A1D4D8;
    'dispatch: loop {
        match pc {
            0x82A1D4D8 => {
    //   block [0x82A1D4D8..0x82A1D534)
	// 82A1D4D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1D4DC: 4878AC91  bl 0x831a816c
	ctx.lr = 0x82A1D4E0;
	sub_831A8130(ctx, base);
	// 82A1D4E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1D4E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1D4E8: 3D4082A2  lis r10, -0x7d5e
	ctx.r[10].s64 = -2103312384;
	// 82A1D4EC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1D4F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1D4F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1D4F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D4FC: 388ACCD0  addi r4, r10, -0x3330
	ctx.r[4].s64 = ctx.r[10].s64 + -13104;
	// 82A1D500: 4B942571  bl 0x8235fa70
	ctx.lr = 0x82A1D504;
	sub_8235FA70(ctx, base);
	// 82A1D504: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1D508: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D50C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A1D510: 483D66F1  bl 0x82df3c00
	ctx.lr = 0x82A1D514;
	sub_82DF3C00(ctx, base);
	// 82A1D514: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D518: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D51C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1D520: 4843EC39  bl 0x82e5c158
	ctx.lr = 0x82A1D524;
	sub_82E5C158(ctx, base);
	// 82A1D524: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1D528: 483D5F01  bl 0x82df3428
	ctx.lr = 0x82A1D52C;
	sub_82DF3428(ctx, base);
	// 82A1D52C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1D530: 4878AC8C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1D538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1D538 size=92
    let mut pc: u32 = 0x82A1D538;
    'dispatch: loop {
        match pc {
            0x82A1D538 => {
    //   block [0x82A1D538..0x82A1D594)
	// 82A1D538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1D53C: 4878AC31  bl 0x831a816c
	ctx.lr = 0x82A1D540;
	sub_831A8130(ctx, base);
	// 82A1D540: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1D544: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1D548: 3D4082A2  lis r10, -0x7d5e
	ctx.r[10].s64 = -2103312384;
	// 82A1D54C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1D550: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1D554: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1D558: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D55C: 388ACD40  addi r4, r10, -0x32c0
	ctx.r[4].s64 = ctx.r[10].s64 + -12992;
	// 82A1D560: 4B942511  bl 0x8235fa70
	ctx.lr = 0x82A1D564;
	sub_8235FA70(ctx, base);
	// 82A1D564: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1D568: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D56C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A1D570: 483D6691  bl 0x82df3c00
	ctx.lr = 0x82A1D574;
	sub_82DF3C00(ctx, base);
	// 82A1D574: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D578: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D57C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1D580: 4843EBD9  bl 0x82e5c158
	ctx.lr = 0x82A1D584;
	sub_82E5C158(ctx, base);
	// 82A1D584: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1D588: 483D5EA1  bl 0x82df3428
	ctx.lr = 0x82A1D58C;
	sub_82DF3428(ctx, base);
	// 82A1D58C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1D590: 4878AC2C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1D598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A1D598 size=756
    let mut pc: u32 = 0x82A1D598;
    'dispatch: loop {
        match pc {
            0x82A1D598 => {
    //   block [0x82A1D598..0x82A1D88C)
	// 82A1D598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1D59C: 4878ABCD  bl 0x831a8168
	ctx.lr = 0x82A1D5A0;
	sub_831A8130(ctx, base);
	// 82A1D5A0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1D5A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1D5A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1D5AC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A1D5B0: 48440321  bl 0x82e5d8d0
	ctx.lr = 0x82A1D5B4;
	sub_82E5D8D0(ctx, base);
	// 82A1D5B4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1D5B8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A1D5BC: 396B9F20  addi r11, r11, -0x60e0
	ctx.r[11].s64 = ctx.r[11].s64 + -24800;
	// 82A1D5C0: 915F0060  stw r10, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82A1D5C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D5C8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A1D5CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1D5D0: 48635D41  bl 0x83053310
	ctx.lr = 0x82A1D5D4;
	sub_83053310(ctx, base);
	// 82A1D5D4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1D5D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D5DC: 388BA11C  addi r4, r11, -0x5ee4
	ctx.r[4].s64 = ctx.r[11].s64 + -24292;
	// 82A1D5E0: 483D6429  bl 0x82df3a08
	ctx.lr = 0x82A1D5E4;
	sub_82DF3A08(ctx, base);
	// 82A1D5E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D5E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D5EC: 4BFFF82D  bl 0x82a1ce18
	ctx.lr = 0x82A1D5F0;
	sub_82A1CE18(ctx, base);
	// 82A1D5F0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82A1D5F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D5F8: 388B9FE8  addi r4, r11, -0x6018
	ctx.r[4].s64 = ctx.r[11].s64 + -24600;
	// 82A1D5FC: 483D640D  bl 0x82df3a08
	ctx.lr = 0x82A1D600;
	sub_82DF3A08(ctx, base);
	// 82A1D600: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D608: 4BFFF871  bl 0x82a1ce78
	ctx.lr = 0x82A1D60C;
	sub_82A1CE78(ctx, base);
	// 82A1D60C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A1D610: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D614: 388B893C  addi r4, r11, -0x76c4
	ctx.r[4].s64 = ctx.r[11].s64 + -30404;
	// 82A1D618: 483D63F1  bl 0x82df3a08
	ctx.lr = 0x82A1D61C;
	sub_82DF3A08(ctx, base);
	// 82A1D61C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D620: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D624: 4BFFF8B5  bl 0x82a1ced8
	ctx.lr = 0x82A1D628;
	sub_82A1CED8(ctx, base);
	// 82A1D628: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A1D62C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D630: 388B0740  addi r4, r11, 0x740
	ctx.r[4].s64 = ctx.r[11].s64 + 1856;
	// 82A1D634: 483D63D5  bl 0x82df3a08
	ctx.lr = 0x82A1D638;
	sub_82DF3A08(ctx, base);
	// 82A1D638: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D63C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D640: 4BFFF8F9  bl 0x82a1cf38
	ctx.lr = 0x82A1D644;
	sub_82A1CF38(ctx, base);
	// 82A1D644: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82A1D648: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D64C: 388B60C8  addi r4, r11, 0x60c8
	ctx.r[4].s64 = ctx.r[11].s64 + 24776;
	// 82A1D650: 483D63B9  bl 0x82df3a08
	ctx.lr = 0x82A1D654;
	sub_82DF3A08(ctx, base);
	// 82A1D654: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D658: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D65C: 4BFFF93D  bl 0x82a1cf98
	ctx.lr = 0x82A1D660;
	sub_82A1CF98(ctx, base);
	// 82A1D660: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82A1D664: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D668: 388B4418  addi r4, r11, 0x4418
	ctx.r[4].s64 = ctx.r[11].s64 + 17432;
	// 82A1D66C: 483D639D  bl 0x82df3a08
	ctx.lr = 0x82A1D670;
	sub_82DF3A08(ctx, base);
	// 82A1D670: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D674: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D678: 4BFFF981  bl 0x82a1cff8
	ctx.lr = 0x82A1D67C;
	sub_82A1CFF8(ctx, base);
	// 82A1D67C: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82A1D680: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D684: 388B05D0  addi r4, r11, 0x5d0
	ctx.r[4].s64 = ctx.r[11].s64 + 1488;
	// 82A1D688: 483D6381  bl 0x82df3a08
	ctx.lr = 0x82A1D68C;
	sub_82DF3A08(ctx, base);
	// 82A1D68C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D690: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D694: 4BFFF9C5  bl 0x82a1d058
	ctx.lr = 0x82A1D698;
	sub_82A1D058(ctx, base);
	// 82A1D698: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1D69C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D6A0: 388BA10C  addi r4, r11, -0x5ef4
	ctx.r[4].s64 = ctx.r[11].s64 + -24308;
	// 82A1D6A4: 483D6365  bl 0x82df3a08
	ctx.lr = 0x82A1D6A8;
	sub_82DF3A08(ctx, base);
	// 82A1D6A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D6AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D6B0: 4BFFFA09  bl 0x82a1d0b8
	ctx.lr = 0x82A1D6B4;
	sub_82A1D0B8(ctx, base);
	// 82A1D6B4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1D6B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D6BC: 388B8F40  addi r4, r11, -0x70c0
	ctx.r[4].s64 = ctx.r[11].s64 + -28864;
	// 82A1D6C0: 483D6349  bl 0x82df3a08
	ctx.lr = 0x82A1D6C4;
	sub_82DF3A08(ctx, base);
	// 82A1D6C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D6C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D6CC: 4BFFFA4D  bl 0x82a1d118
	ctx.lr = 0x82A1D6D0;
	sub_82A1D118(ctx, base);
	// 82A1D6D0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1D6D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D6D8: 388BA100  addi r4, r11, -0x5f00
	ctx.r[4].s64 = ctx.r[11].s64 + -24320;
	// 82A1D6DC: 483D632D  bl 0x82df3a08
	ctx.lr = 0x82A1D6E0;
	sub_82DF3A08(ctx, base);
	// 82A1D6E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D6E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D6E8: 4BFFFA91  bl 0x82a1d178
	ctx.lr = 0x82A1D6EC;
	sub_82A1D178(ctx, base);
	// 82A1D6EC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A1D6F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D6F4: 388BA2C4  addi r4, r11, -0x5d3c
	ctx.r[4].s64 = ctx.r[11].s64 + -23868;
	// 82A1D6F8: 483D6311  bl 0x82df3a08
	ctx.lr = 0x82A1D6FC;
	sub_82DF3A08(ctx, base);
	// 82A1D6FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D704: 4BFFFAD5  bl 0x82a1d1d8
	ctx.lr = 0x82A1D708;
	sub_82A1D1D8(ctx, base);
	// 82A1D708: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1D70C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D710: 388BA0F4  addi r4, r11, -0x5f0c
	ctx.r[4].s64 = ctx.r[11].s64 + -24332;
	// 82A1D714: 483D62F5  bl 0x82df3a08
	ctx.lr = 0x82A1D718;
	sub_82DF3A08(ctx, base);
	// 82A1D718: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D71C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D720: 4BFFFB19  bl 0x82a1d238
	ctx.lr = 0x82A1D724;
	sub_82A1D238(ctx, base);
	// 82A1D724: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82A1D728: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D72C: 388B31AC  addi r4, r11, 0x31ac
	ctx.r[4].s64 = ctx.r[11].s64 + 12716;
	// 82A1D730: 483D62D9  bl 0x82df3a08
	ctx.lr = 0x82A1D734;
	sub_82DF3A08(ctx, base);
	// 82A1D734: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D738: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D73C: 4BFFFB5D  bl 0x82a1d298
	ctx.lr = 0x82A1D740;
	sub_82A1D298(ctx, base);
	// 82A1D740: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A1D744: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D748: 388B17D4  addi r4, r11, 0x17d4
	ctx.r[4].s64 = ctx.r[11].s64 + 6100;
	// 82A1D74C: 483D62BD  bl 0x82df3a08
	ctx.lr = 0x82A1D750;
	sub_82DF3A08(ctx, base);
	// 82A1D750: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D754: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D758: 4BFFFBA1  bl 0x82a1d2f8
	ctx.lr = 0x82A1D75C;
	sub_82A1D2F8(ctx, base);
	// 82A1D75C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A1D760: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D764: 388B836C  addi r4, r11, -0x7c94
	ctx.r[4].s64 = ctx.r[11].s64 + -31892;
	// 82A1D768: 483D62A1  bl 0x82df3a08
	ctx.lr = 0x82A1D76C;
	sub_82DF3A08(ctx, base);
	// 82A1D76C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D770: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D774: 4BFFFBE5  bl 0x82a1d358
	ctx.lr = 0x82A1D778;
	sub_82A1D358(ctx, base);
	// 82A1D778: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82A1D77C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D780: 3BCBC3B0  addi r30, r11, -0x3c50
	ctx.r[30].s64 = ctx.r[11].s64 + -15440;
	// 82A1D784: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1D788: 483D6281  bl 0x82df3a08
	ctx.lr = 0x82A1D78C;
	sub_82DF3A08(ctx, base);
	// 82A1D78C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D790: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D794: 4BFFFC25  bl 0x82a1d3b8
	ctx.lr = 0x82A1D798;
	sub_82A1D3B8(ctx, base);
	// 82A1D798: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1D79C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D7A0: 388B907C  addi r4, r11, -0x6f84
	ctx.r[4].s64 = ctx.r[11].s64 + -28548;
	// 82A1D7A4: 483D6265  bl 0x82df3a08
	ctx.lr = 0x82A1D7A8;
	sub_82DF3A08(ctx, base);
	// 82A1D7A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D7AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D7B0: 4BFFFC69  bl 0x82a1d418
	ctx.lr = 0x82A1D7B4;
	sub_82A1D418(ctx, base);
	// 82A1D7B4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1D7B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D7BC: 3BABA0EC  addi r29, r11, -0x5f14
	ctx.r[29].s64 = ctx.r[11].s64 + -24340;
	// 82A1D7C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A1D7C4: 483D6245  bl 0x82df3a08
	ctx.lr = 0x82A1D7C8;
	sub_82DF3A08(ctx, base);
	// 82A1D7C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D7CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D7D0: 4BFFFCA9  bl 0x82a1d478
	ctx.lr = 0x82A1D7D4;
	sub_82A1D478(ctx, base);
	// 82A1D7D4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1D7D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D7DC: 388BA0DC  addi r4, r11, -0x5f24
	ctx.r[4].s64 = ctx.r[11].s64 + -24356;
	// 82A1D7E0: 483D6229  bl 0x82df3a08
	ctx.lr = 0x82A1D7E4;
	sub_82DF3A08(ctx, base);
	// 82A1D7E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D7E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D7EC: 4BFFFCED  bl 0x82a1d4d8
	ctx.lr = 0x82A1D7F0;
	sub_82A1D4D8(ctx, base);
	// 82A1D7F0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1D7F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D7F8: 388BA0CC  addi r4, r11, -0x5f34
	ctx.r[4].s64 = ctx.r[11].s64 + -24372;
	// 82A1D7FC: 483D620D  bl 0x82df3a08
	ctx.lr = 0x82A1D800;
	sub_82DF3A08(ctx, base);
	// 82A1D800: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D804: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D808: 4BFFFD31  bl 0x82a1d538
	ctx.lr = 0x82A1D80C;
	sub_82A1D538(ctx, base);
	// 82A1D80C: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1D810: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1D814: 41820034  beq 0x82a1d848
	if ctx.cr[0].eq {
	pc = 0x82A1D848; continue 'dispatch;
	}
	// 82A1D818: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A1D81C: 483D61ED  bl 0x82df3a08
	ctx.lr = 0x82A1D820;
	sub_82DF3A08(ctx, base);
	// 82A1D820: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1D824: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A1D828: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1D82C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1D830: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A1D834: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A1D838: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A1D83C: 48441125  bl 0x82e5e960
	ctx.lr = 0x82A1D840;
	sub_82E5E960(ctx, base);
	// 82A1D840: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A1D844: 48000030  b 0x82a1d874
	pc = 0x82A1D874; continue 'dispatch;
	// 82A1D848: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1D84C: 483D61BD  bl 0x82df3a08
	ctx.lr = 0x82A1D850;
	sub_82DF3A08(ctx, base);
	// 82A1D850: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1D854: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A1D858: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1D85C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D860: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A1D864: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A1D868: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A1D86C: 484410F5  bl 0x82e5e960
	ctx.lr = 0x82A1D870;
	sub_82E5E960(ctx, base);
	// 82A1D870: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A1D874: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1D878: 419A0008  beq cr6, 0x82a1d880
	if ctx.cr[6].eq {
	pc = 0x82A1D880; continue 'dispatch;
	}
	// 82A1D87C: 4B8A3015  bl 0x822c0890
	ctx.lr = 0x82A1D880;
	sub_822C0890(ctx, base);
	// 82A1D880: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D884: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A1D888: 4878A930  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1D890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A1D890 size=608
    let mut pc: u32 = 0x82A1D890;
    'dispatch: loop {
        match pc {
            0x82A1D890 => {
    //   block [0x82A1D890..0x82A1DAF0)
	// 82A1D890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1D894: 4878A8D5  bl 0x831a8168
	ctx.lr = 0x82A1D898;
	sub_831A8130(ctx, base);
	// 82A1D898: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1D89C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1D8A0: 4845ACA9  bl 0x82e78548
	ctx.lr = 0x82A1D8A4;
	sub_82E78548(ctx, base);
	// 82A1D8A4: 4BFF8C75  bl 0x82a16518
	ctx.lr = 0x82A1D8A8;
	sub_82A16518(ctx, base);
	// 82A1D8A8: 2F030101  cmpwi cr6, r3, 0x101
	ctx.cr[6].compare_i32(ctx.r[3].s32, 257, &mut ctx.xer);
	// 82A1D8AC: 419A01FC  beq cr6, 0x82a1daa8
	if ctx.cr[6].eq {
	pc = 0x82A1DAA8; continue 'dispatch;
	}
	// 82A1D8B0: 2F030200  cmpwi cr6, r3, 0x200
	ctx.cr[6].compare_i32(ctx.r[3].s32, 512, &mut ctx.xer);
	// 82A1D8B4: 40990044  ble cr6, 0x82a1d8f8
	if !ctx.cr[6].gt {
	pc = 0x82A1D8F8; continue 'dispatch;
	}
	// 82A1D8B8: 2F030202  cmpwi cr6, r3, 0x202
	ctx.cr[6].compare_i32(ctx.r[3].s32, 514, &mut ctx.xer);
	// 82A1D8BC: 4199003C  bgt cr6, 0x82a1d8f8
	if ctx.cr[6].gt {
	pc = 0x82A1D8F8; continue 'dispatch;
	}
	// 82A1D8C0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A1D8C4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A1D8C8: 388B17D4  addi r4, r11, 0x17d4
	ctx.r[4].s64 = ctx.r[11].s64 + 6100;
	// 82A1D8CC: 483D613D  bl 0x82df3a08
	ctx.lr = 0x82A1D8D0;
	sub_82DF3A08(ctx, base);
	// 82A1D8D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1D8D4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A1D8D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1D8DC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A1D8E0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A1D8E4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A1D8E8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A1D8EC: 48441075  bl 0x82e5e960
	ctx.lr = 0x82A1D8F0;
	sub_82E5E960(ctx, base);
	// 82A1D8F0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A1D8F4: 480001E8  b 0x82a1dadc
	pc = 0x82A1DADC; continue 'dispatch;
	// 82A1D8F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D8FC: 48010375  bl 0x82a2dc70
	ctx.lr = 0x82A1D900;
	sub_82A2DC70(ctx, base);
	// 82A1D900: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A1D904: 83DF0060  lwz r30, 0x60(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A1D908: 4800F519  bl 0x82a2ce20
	ctx.lr = 0x82A1D90C;
	sub_82A2CE20(ctx, base);
	// 82A1D90C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A1D910: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A1D914: 3BAB0410  addi r29, r11, 0x410
	ctx.r[29].s64 = ctx.r[11].s64 + 1040;
	// 82A1D918: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1D91C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A1D920: 7D4AE82E  lwzx r10, r10, r29
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82A1D924: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A1D928: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82A1D92C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A1D930: 409A0028  bne cr6, 0x82a1d958
	if !ctx.cr[6].eq {
	pc = 0x82A1D958; continue 'dispatch;
	}
	// 82A1D934: 939F0060  stw r28, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82A1D938: 579E003E  slwi r30, r28, 0
	ctx.r[30].u32 = ctx.r[28].u32.wrapping_shl(0);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82A1D93C: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A1D940: 4800F4E1  bl 0x82a2ce20
	ctx.lr = 0x82A1D944;
	sub_82A2CE20(ctx, base);
	// 82A1D944: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1D948: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A1D94C: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82A1D950: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A1D954: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A1D958: 395E0001  addi r10, r30, 1
	ctx.r[10].s64 = ctx.r[30].s64 + 1;
	// 82A1D95C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A1D960: 915F0060  stw r10, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82A1D964: 409A004C  bne cr6, 0x82a1d9b0
	if !ctx.cr[6].eq {
	pc = 0x82A1D9B0; continue 'dispatch;
	}
	// 82A1D968: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1D96C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A1D970: 388BA0DC  addi r4, r11, -0x5f24
	ctx.r[4].s64 = ctx.r[11].s64 + -24356;
	// 82A1D974: 483D6095  bl 0x82df3a08
	ctx.lr = 0x82A1D978;
	sub_82DF3A08(ctx, base);
	// 82A1D978: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1D97C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A1D980: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1D984: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A1D988: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A1D98C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A1D990: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A1D994: 48440FCD  bl 0x82e5e960
	ctx.lr = 0x82A1D998;
	sub_82E5E960(ctx, base);
	// 82A1D998: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A1D99C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1D9A0: 419A0008  beq cr6, 0x82a1d9a8
	if ctx.cr[6].eq {
	pc = 0x82A1D9A8; continue 'dispatch;
	}
	// 82A1D9A4: 4B8A2EED  bl 0x822c0890
	ctx.lr = 0x82A1D9A8;
	sub_822C0890(ctx, base);
	// 82A1D9A8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A1D9AC: 48000130  b 0x82a1dadc
	pc = 0x82A1DADC; continue 'dispatch;
	// 82A1D9B0: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A1D9B4: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82A1D9B8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1D9BC: 394A03C0  addi r10, r10, 0x3c0
	ctx.r[10].s64 = ctx.r[10].s64 + 960;
	// 82A1D9C0: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A1D9C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A1D9C8: 3889A130  addi r4, r9, -0x5ed0
	ctx.r[4].s64 = ctx.r[9].s64 + -24272;
	// 82A1D9CC: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A1D9D0: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D9D4: 483D6035  bl 0x82df3a08
	ctx.lr = 0x82A1D9D8;
	sub_82DF3A08(ctx, base);
	// 82A1D9D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1D9DC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A1D9E0: 4843CB41  bl 0x82e5a520
	ctx.lr = 0x82A1D9E4;
	sub_82E5A520(ctx, base);
	// 82A1D9E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D9E8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A1D9EC: 386B0038  addi r3, r11, 0x38
	ctx.r[3].s64 = ctx.r[11].s64 + 56;
	// 82A1D9F0: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 82A1D9F4: 4B90EE4D  bl 0x8232c840
	ctx.lr = 0x82A1D9F8;
	sub_8232C840(ctx, base);
	// 82A1D9F8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A1D9FC: 4BFFF3B5  bl 0x82a1cdb0
	ctx.lr = 0x82A1DA00;
	sub_82A1CDB0(ctx, base);
	// 82A1DA00: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A1DA04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1DA08: 419A0008  beq cr6, 0x82a1da10
	if ctx.cr[6].eq {
	pc = 0x82A1DA10; continue 'dispatch;
	}
	// 82A1DA0C: 4B8A2E85  bl 0x822c0890
	ctx.lr = 0x82A1DA10;
	sub_822C0890(ctx, base);
	// 82A1DA10: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A1DA14: 483D5A15  bl 0x82df3428
	ctx.lr = 0x82A1DA18;
	sub_82DF3428(ctx, base);
	// 82A1DA18: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1DA1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1DA20: 388BA124  addi r4, r11, -0x5edc
	ctx.r[4].s64 = ctx.r[11].s64 + -24284;
	// 82A1DA24: 483D5FE5  bl 0x82df3a08
	ctx.lr = 0x82A1DA28;
	sub_82DF3A08(ctx, base);
	// 82A1DA28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1DA2C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A1DA30: 4843CAF1  bl 0x82e5a520
	ctx.lr = 0x82A1DA34;
	sub_82E5A520(ctx, base);
	// 82A1DA34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1DA38: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A1DA3C: 386B0038  addi r3, r11, 0x38
	ctx.r[3].s64 = ctx.r[11].s64 + 56;
	// 82A1DA40: 3BA1005C  addi r29, r1, 0x5c
	ctx.r[29].s64 = ctx.r[1].s64 + 92;
	// 82A1DA44: 4B90EDFD  bl 0x8232c840
	ctx.lr = 0x82A1DA48;
	sub_8232C840(ctx, base);
	// 82A1DA48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A1DA4C: 4B918DD5  bl 0x82336820
	ctx.lr = 0x82A1DA50;
	sub_82336820(ctx, base);
	// 82A1DA50: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A1DA54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1DA58: 419A0008  beq cr6, 0x82a1da60
	if ctx.cr[6].eq {
	pc = 0x82A1DA60; continue 'dispatch;
	}
	// 82A1DA5C: 4B8A2E35  bl 0x822c0890
	ctx.lr = 0x82A1DA60;
	sub_822C0890(ctx, base);
	// 82A1DA60: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1DA64: 483D59C5  bl 0x82df3428
	ctx.lr = 0x82A1DA68;
	sub_82DF3428(ctx, base);
	// 82A1DA68: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A1DA6C: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A1DA70: 396BDD3C  addi r11, r11, -0x22c4
	ctx.r[11].s64 = ctx.r[11].s64 + -8900;
	// 82A1DA74: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A1DA78: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A1DA7C: 483D6185  bl 0x82df3c00
	ctx.lr = 0x82A1DA80;
	sub_82DF3C00(ctx, base);
	// 82A1DA80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1DA84: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A1DA88: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A1DA8C: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82A1DA90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1DA94: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A1DA98: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A1DA9C: 48440EC5  bl 0x82e5e960
	ctx.lr = 0x82A1DAA0;
	sub_82E5E960(ctx, base);
	// 82A1DAA0: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A1DAA4: 4BFFFEF8  b 0x82a1d99c
	pc = 0x82A1D99C; continue 'dispatch;
	// 82A1DAA8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82A1DAAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1DAB0: 388B9FE8  addi r4, r11, -0x6018
	ctx.r[4].s64 = ctx.r[11].s64 + -24600;
	// 82A1DAB4: 483D5F55  bl 0x82df3a08
	ctx.lr = 0x82A1DAB8;
	sub_82DF3A08(ctx, base);
	// 82A1DAB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1DABC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A1DAC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1DAC4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A1DAC8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A1DACC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A1DAD0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A1DAD4: 48440E8D  bl 0x82e5e960
	ctx.lr = 0x82A1DAD8;
	sub_82E5E960(ctx, base);
	// 82A1DAD8: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A1DADC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1DAE0: 419A0008  beq cr6, 0x82a1dae8
	if ctx.cr[6].eq {
	pc = 0x82A1DAE8; continue 'dispatch;
	}
	// 82A1DAE4: 4B8A2DAD  bl 0x822c0890
	ctx.lr = 0x82A1DAE8;
	sub_822C0890(ctx, base);
	// 82A1DAE8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A1DAEC: 4878A6CC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1DAF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A1DAF0 size=760
    let mut pc: u32 = 0x82A1DAF0;
    'dispatch: loop {
        match pc {
            0x82A1DAF0 => {
    //   block [0x82A1DAF0..0x82A1DDE8)
	// 82A1DAF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1DAF4: 4878A675  bl 0x831a8168
	ctx.lr = 0x82A1DAF8;
	sub_831A8130(ctx, base);
	// 82A1DAF8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1DAFC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A1DB00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1DB04: 93A100EC  stw r29, 0xec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[29].u32 ) };
	// 82A1DB08: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A1DB0C: 4845AA3D  bl 0x82e78548
	ctx.lr = 0x82A1DB10;
	sub_82E78548(ctx, base);
	// 82A1DB10: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1DB14: 4BFF8A05  bl 0x82a16518
	ctx.lr = 0x82A1DB18;
	sub_82A16518(ctx, base);
	// 82A1DB18: 2F030101  cmpwi cr6, r3, 0x101
	ctx.cr[6].compare_i32(ctx.r[3].s32, 257, &mut ctx.xer);
	// 82A1DB1C: 419A0284  beq cr6, 0x82a1dda0
	if ctx.cr[6].eq {
	pc = 0x82A1DDA0; continue 'dispatch;
	}
	// 82A1DB20: 2F030200  cmpwi cr6, r3, 0x200
	ctx.cr[6].compare_i32(ctx.r[3].s32, 512, &mut ctx.xer);
	// 82A1DB24: 40990044  ble cr6, 0x82a1db68
	if !ctx.cr[6].gt {
	pc = 0x82A1DB68; continue 'dispatch;
	}
	// 82A1DB28: 2F030202  cmpwi cr6, r3, 0x202
	ctx.cr[6].compare_i32(ctx.r[3].s32, 514, &mut ctx.xer);
	// 82A1DB2C: 4199003C  bgt cr6, 0x82a1db68
	if ctx.cr[6].gt {
	pc = 0x82A1DB68; continue 'dispatch;
	}
	// 82A1DB30: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A1DB34: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82A1DB38: 388B17D4  addi r4, r11, 0x17d4
	ctx.r[4].s64 = ctx.r[11].s64 + 6100;
	// 82A1DB3C: 483D5ECD  bl 0x82df3a08
	ctx.lr = 0x82A1DB40;
	sub_82DF3A08(ctx, base);
	// 82A1DB40: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1DB44: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A1DB48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1DB4C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A1DB50: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A1DB54: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A1DB58: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A1DB5C: 48440E05  bl 0x82e5e960
	ctx.lr = 0x82A1DB60;
	sub_82E5E960(ctx, base);
	// 82A1DB60: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A1DB64: 48000270  b 0x82a1ddd4
	pc = 0x82A1DDD4; continue 'dispatch;
	// 82A1DB68: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A1DB6C: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A1DB70: 392B03C0  addi r9, r11, 0x3c0
	ctx.r[9].s64 = ctx.r[11].s64 + 960;
	// 82A1DB74: 397C0001  addi r11, r28, 1
	ctx.r[11].s64 = ctx.r[28].s64 + 1;
	// 82A1DB78: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A1DB7C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A1DB80: 7D6A482E  lwzx r11, r10, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82A1DB84: 7FAB402E  lwzx r29, r11, r8
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82A1DB88: 2F1DFFFF  cmpwi cr6, r29, -1
	ctx.cr[6].compare_i32(ctx.r[29].s32, -1, &mut ctx.xer);
	// 82A1DB8C: 419A00E4  beq cr6, 0x82a1dc70
	if ctx.cr[6].eq {
	pc = 0x82A1DC70; continue 'dispatch;
	}
	// 82A1DB90: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1DB94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A1DB98: 388BA130  addi r4, r11, -0x5ed0
	ctx.r[4].s64 = ctx.r[11].s64 + -24272;
	// 82A1DB9C: 483D5E6D  bl 0x82df3a08
	ctx.lr = 0x82A1DBA0;
	sub_82DF3A08(ctx, base);
	// 82A1DBA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1DBA4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A1DBA8: 4843C979  bl 0x82e5a520
	ctx.lr = 0x82A1DBAC;
	sub_82E5A520(ctx, base);
	// 82A1DBAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1DBB0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A1DBB4: 386B0038  addi r3, r11, 0x38
	ctx.r[3].s64 = ctx.r[11].s64 + 56;
	// 82A1DBB8: 3BC100EC  addi r30, r1, 0xec
	ctx.r[30].s64 = ctx.r[1].s64 + 236;
	// 82A1DBBC: 4B90EC85  bl 0x8232c840
	ctx.lr = 0x82A1DBC0;
	sub_8232C840(ctx, base);
	// 82A1DBC0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1DBC4: 4BFFF1ED  bl 0x82a1cdb0
	ctx.lr = 0x82A1DBC8;
	sub_82A1CDB0(ctx, base);
	// 82A1DBC8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A1DBCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1DBD0: 419A0008  beq cr6, 0x82a1dbd8
	if ctx.cr[6].eq {
	pc = 0x82A1DBD8; continue 'dispatch;
	}
	// 82A1DBD4: 4B8A2CBD  bl 0x822c0890
	ctx.lr = 0x82A1DBD8;
	sub_822C0890(ctx, base);
	// 82A1DBD8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A1DBDC: 483D584D  bl 0x82df3428
	ctx.lr = 0x82A1DBE0;
	sub_82DF3428(ctx, base);
	// 82A1DBE0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1DBE4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1DBE8: 388BA124  addi r4, r11, -0x5edc
	ctx.r[4].s64 = ctx.r[11].s64 + -24284;
	// 82A1DBEC: 483D5E1D  bl 0x82df3a08
	ctx.lr = 0x82A1DBF0;
	sub_82DF3A08(ctx, base);
	// 82A1DBF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1DBF4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A1DBF8: 4843C929  bl 0x82e5a520
	ctx.lr = 0x82A1DBFC;
	sub_82E5A520(ctx, base);
	// 82A1DBFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1DC00: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A1DC04: 386B0038  addi r3, r11, 0x38
	ctx.r[3].s64 = ctx.r[11].s64 + 56;
	// 82A1DC08: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82A1DC0C: 4B90EC35  bl 0x8232c840
	ctx.lr = 0x82A1DC10;
	sub_8232C840(ctx, base);
	// 82A1DC10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1DC14: 4B918C0D  bl 0x82336820
	ctx.lr = 0x82A1DC18;
	sub_82336820(ctx, base);
	// 82A1DC18: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A1DC1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1DC20: 419A0008  beq cr6, 0x82a1dc28
	if ctx.cr[6].eq {
	pc = 0x82A1DC28; continue 'dispatch;
	}
	// 82A1DC24: 4B8A2C6D  bl 0x822c0890
	ctx.lr = 0x82A1DC28;
	sub_822C0890(ctx, base);
	// 82A1DC28: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1DC2C: 483D57FD  bl 0x82df3428
	ctx.lr = 0x82A1DC30;
	sub_82DF3428(ctx, base);
	// 82A1DC30: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A1DC34: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A1DC38: 396BDD3C  addi r11, r11, -0x22c4
	ctx.r[11].s64 = ctx.r[11].s64 + -8900;
	// 82A1DC3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1DC40: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A1DC44: 483D5FBD  bl 0x82df3c00
	ctx.lr = 0x82A1DC48;
	sub_82DF3C00(ctx, base);
	// 82A1DC48: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1DC4C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A1DC50: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A1DC54: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A1DC58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1DC5C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A1DC60: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A1DC64: 48440CFD  bl 0x82e5e960
	ctx.lr = 0x82A1DC68;
	sub_82E5E960(ctx, base);
	// 82A1DC68: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A1DC6C: 48000168  b 0x82a1ddd4
	pc = 0x82A1DDD4; continue 'dispatch;
	// 82A1DC70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1DC74: 483D547D  bl 0x82df30f0
	ctx.lr = 0x82A1DC78;
	sub_82DF30F0(ctx, base);
	// 82A1DC78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1DC7C: 4845A8CD  bl 0x82e78548
	ctx.lr = 0x82A1DC80;
	sub_82E78548(ctx, base);
	// 82A1DC80: 4BFF5311  bl 0x82a12f90
	ctx.lr = 0x82A1DC84;
	sub_82A12F90(ctx, base);
	// 82A1DC84: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1DC88: 41820038  beq 0x82a1dcc0
	if ctx.cr[0].eq {
	pc = 0x82A1DCC0; continue 'dispatch;
	}
	// 82A1DC8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1DC90: 4845A8B9  bl 0x82e78548
	ctx.lr = 0x82A1DC94;
	sub_82E78548(ctx, base);
	// 82A1DC94: 4BFF534D  bl 0x82a12fe0
	ctx.lr = 0x82A1DC98;
	sub_82A12FE0(ctx, base);
	// 82A1DC98: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1DC9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1DCA0: 41820010  beq 0x82a1dcb0
	if ctx.cr[0].eq {
	pc = 0x82A1DCB0; continue 'dispatch;
	}
	// 82A1DCA4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1DCA8: 388BA0DC  addi r4, r11, -0x5f24
	ctx.r[4].s64 = ctx.r[11].s64 + -24356;
	// 82A1DCAC: 4800000C  b 0x82a1dcb8
	pc = 0x82A1DCB8; continue 'dispatch;
	// 82A1DCB0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1DCB4: 388BA0CC  addi r4, r11, -0x5f34
	ctx.r[4].s64 = ctx.r[11].s64 + -24372;
	// 82A1DCB8: 483D5BC1  bl 0x82df3878
	ctx.lr = 0x82A1DCBC;
	sub_82DF3878(ctx, base);
	// 82A1DCBC: 4800009C  b 0x82a1dd58
	pc = 0x82A1DD58; continue 'dispatch;
	// 82A1DCC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1DCC4: 4BDCE515  bl 0x827ec1d8
	ctx.lr = 0x82A1DCC8;
	sub_827EC1D8(ctx, base);
	// 82A1DCC8: 4845A881  bl 0x82e78548
	ctx.lr = 0x82A1DCCC;
	sub_82E78548(ctx, base);
	// 82A1DCCC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A1DCD0: 4BFF5A61  bl 0x82a13730
	ctx.lr = 0x82A1DCD4;
	sub_82A13730(ctx, base);
	// 82A1DCD4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A1DCD8: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A1DCDC: 396BDD3C  addi r11, r11, -0x22c4
	ctx.r[11].s64 = ctx.r[11].s64 + -8900;
	// 82A1DCE0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A1DCE4: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A1DCE8: 483D5F19  bl 0x82df3c00
	ctx.lr = 0x82A1DCEC;
	sub_82DF3C00(ctx, base);
	// 82A1DCEC: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82A1DCF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1DCF4: 483D5EDD  bl 0x82df3bd0
	ctx.lr = 0x82A1DCF8;
	sub_82DF3BD0(ctx, base);
	// 82A1DCF8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A1DCFC: 483D572D  bl 0x82df3428
	ctx.lr = 0x82A1DD00;
	sub_82DF3428(ctx, base);
	// 82A1DD00: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1DD04: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82A1DD08: 388BA130  addi r4, r11, -0x5ed0
	ctx.r[4].s64 = ctx.r[11].s64 + -24272;
	// 82A1DD0C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1DD10: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82A1DD14: 483D5CF5  bl 0x82df3a08
	ctx.lr = 0x82A1DD18;
	sub_82DF3A08(ctx, base);
	// 82A1DD18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1DD1C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A1DD20: 4843C801  bl 0x82e5a520
	ctx.lr = 0x82A1DD24;
	sub_82E5A520(ctx, base);
	// 82A1DD24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1DD28: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A1DD2C: 386B0038  addi r3, r11, 0x38
	ctx.r[3].s64 = ctx.r[11].s64 + 56;
	// 82A1DD30: 3BC10064  addi r30, r1, 0x64
	ctx.r[30].s64 = ctx.r[1].s64 + 100;
	// 82A1DD34: 4B90EB0D  bl 0x8232c840
	ctx.lr = 0x82A1DD38;
	sub_8232C840(ctx, base);
	// 82A1DD38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1DD3C: 4BFFF075  bl 0x82a1cdb0
	ctx.lr = 0x82A1DD40;
	sub_82A1CDB0(ctx, base);
	// 82A1DD40: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A1DD44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1DD48: 419A0008  beq cr6, 0x82a1dd50
	if ctx.cr[6].eq {
	pc = 0x82A1DD50; continue 'dispatch;
	}
	// 82A1DD4C: 4B8A2B45  bl 0x822c0890
	ctx.lr = 0x82A1DD50;
	sub_822C0890(ctx, base);
	// 82A1DD50: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1DD54: 483D56D5  bl 0x82df3428
	ctx.lr = 0x82A1DD58;
	sub_82DF3428(ctx, base);
	// 82A1DD58: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A1DD5C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82A1DD60: 483D5EA1  bl 0x82df3c00
	ctx.lr = 0x82A1DD64;
	sub_82DF3C00(ctx, base);
	// 82A1DD64: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1DD68: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A1DD6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1DD70: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A1DD74: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A1DD78: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A1DD7C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A1DD80: 48440BE1  bl 0x82e5e960
	ctx.lr = 0x82A1DD84;
	sub_82E5E960(ctx, base);
	// 82A1DD84: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A1DD88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1DD8C: 419A0008  beq cr6, 0x82a1dd94
	if ctx.cr[6].eq {
	pc = 0x82A1DD94; continue 'dispatch;
	}
	// 82A1DD90: 4B8A2B01  bl 0x822c0890
	ctx.lr = 0x82A1DD94;
	sub_822C0890(ctx, base);
	// 82A1DD94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1DD98: 483D5691  bl 0x82df3428
	ctx.lr = 0x82A1DD9C;
	sub_82DF3428(ctx, base);
	// 82A1DD9C: 48000044  b 0x82a1dde0
	pc = 0x82A1DDE0; continue 'dispatch;
	// 82A1DDA0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82A1DDA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1DDA8: 388B9FE8  addi r4, r11, -0x6018
	ctx.r[4].s64 = ctx.r[11].s64 + -24600;
	// 82A1DDAC: 483D5C5D  bl 0x82df3a08
	ctx.lr = 0x82A1DDB0;
	sub_82DF3A08(ctx, base);
	// 82A1DDB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1DDB4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A1DDB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1DDBC: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A1DDC0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A1DDC4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A1DDC8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A1DDCC: 48440B95  bl 0x82e5e960
	ctx.lr = 0x82A1DDD0;
	sub_82E5E960(ctx, base);
	// 82A1DDD0: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82A1DDD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1DDD8: 419A0008  beq cr6, 0x82a1dde0
	if ctx.cr[6].eq {
	pc = 0x82A1DDE0; continue 'dispatch;
	}
	// 82A1DDDC: 4B8A2AB5  bl 0x822c0890
	ctx.lr = 0x82A1DDE0;
	sub_822C0890(ctx, base);
	// 82A1DDE0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A1DDE4: 4878A3D4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1DDE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A1DDE8 size=68
    let mut pc: u32 = 0x82A1DDE8;
    'dispatch: loop {
        match pc {
            0x82A1DDE8 => {
    //   block [0x82A1DDE8..0x82A1DE2C)
	// 82A1DDE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1DDEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1DDF0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1DDF4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1DDF8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A1DDFC: 91430064  stw r10, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82A1DE00: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1DE04: D0030060  stfs f0, 0x60(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A1DE08: D0030068  stfs f0, 0x68(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A1DE0C: 487367F5  bl 0x83154600
	ctx.lr = 0x82A1DE10;
	sub_83154600(ctx, base);
	// 82A1DE10: 4BFF50A9  bl 0x82a12eb8
	ctx.lr = 0x82A1DE14;
	sub_82A12EB8(ctx, base);
	// 82A1DE14: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 82A1DE18: 4BFFBAF1  bl 0x82a19908
	ctx.lr = 0x82A1DE1C;
	sub_82A19908(ctx, base);
	// 82A1DE1C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A1DE20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1DE24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1DE28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1DE30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1DE30 size=96
    let mut pc: u32 = 0x82A1DE30;
    'dispatch: loop {
        match pc {
            0x82A1DE30 => {
    //   block [0x82A1DE30..0x82A1DE90)
	// 82A1DE30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1DE34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1DE38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1DE3C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1DE40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1DE44: 48000305  bl 0x82a1e148
	ctx.lr = 0x82A1DE48;
	sub_82A1E148(ctx, base);
	// 82A1DE48: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1DE4C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A1DE50: 396BA140  addi r11, r11, -0x5ec0
	ctx.r[11].s64 = ctx.r[11].s64 + -24256;
	// 82A1DE54: 388AA11C  addi r4, r10, -0x5ee4
	ctx.r[4].s64 = ctx.r[10].s64 + -24292;
	// 82A1DE58: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A1DE5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1DE60: 483D5BA9  bl 0x82df3a08
	ctx.lr = 0x82A1DE64;
	sub_82DF3A08(ctx, base);
	// 82A1DE64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1DE68: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A1DE6C: 4843B87D  bl 0x82e596e8
	ctx.lr = 0x82A1DE70;
	sub_82E596E8(ctx, base);
	// 82A1DE70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1DE74: 483D55B5  bl 0x82df3428
	ctx.lr = 0x82A1DE78;
	sub_82DF3428(ctx, base);
	// 82A1DE78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1DE7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1DE80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1DE84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1DE88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1DE8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1DE90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A1DE90 size=356
    let mut pc: u32 = 0x82A1DE90;
    'dispatch: loop {
        match pc {
            0x82A1DE90 => {
    //   block [0x82A1DE90..0x82A1DFF4)
	// 82A1DE90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1DE94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1DE98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1DE9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1DEA0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A1DEA4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1DEA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1DEAC: 48736755  bl 0x83154600
	ctx.lr = 0x82A1DEB0;
	sub_83154600(ctx, base);
	// 82A1DEB0: 4BFF5009  bl 0x82a12eb8
	ctx.lr = 0x82A1DEB4;
	sub_82A12EB8(ctx, base);
	// 82A1DEB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1DEB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1DEBC: 4843B8BD  bl 0x82e59778
	ctx.lr = 0x82A1DEC0;
	sub_82E59778(ctx, base);
	// 82A1DEC0: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1DEC4: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A1DEC8: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82A1DECC: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A1DED0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A1DED4: 419800F0  blt cr6, 0x82a1dfc4
	if ctx.cr[6].lt {
	pc = 0x82A1DFC4; continue 'dispatch;
	}
	// 82A1DED8: 419A00BC  beq cr6, 0x82a1df94
	if ctx.cr[6].eq {
	pc = 0x82A1DF94; continue 'dispatch;
	}
	// 82A1DEDC: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A1DEE0: 4198006C  blt cr6, 0x82a1df4c
	if ctx.cr[6].lt {
	pc = 0x82A1DF4C; continue 'dispatch;
	}
	// 82A1DEE4: 409A00F4  bne cr6, 0x82a1dfd8
	if !ctx.cr[6].eq {
	pc = 0x82A1DFD8; continue 'dispatch;
	}
	// 82A1DEE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1DEEC: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A1DEF0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A1DEF4: 409800E4  bge cr6, 0x82a1dfd8
	if !ctx.cr[6].lt {
	pc = 0x82A1DFD8; continue 'dispatch;
	}
	// 82A1DEF8: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82A1DEFC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A1DF00: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A1DF04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1DF08: 388A893C  addi r4, r10, -0x76c4
	ctx.r[4].s64 = ctx.r[10].s64 + -30404;
	// 82A1DF0C: 483D5AFD  bl 0x82df3a08
	ctx.lr = 0x82A1DF10;
	sub_82DF3A08(ctx, base);
	// 82A1DF10: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1DF14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1DF18: 485EA211  bl 0x83008128
	ctx.lr = 0x82A1DF1C;
	sub_83008128(ctx, base);
	// 82A1DF1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1DF20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1DF24: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A1DF28: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A1DF2C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A1DF30: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A1DF34: 48440A2D  bl 0x82e5e960
	ctx.lr = 0x82A1DF38;
	sub_82E5E960(ctx, base);
	// 82A1DF38: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A1DF3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1DF40: 419A0098  beq cr6, 0x82a1dfd8
	if ctx.cr[6].eq {
	pc = 0x82A1DFD8; continue 'dispatch;
	}
	// 82A1DF44: 4B8A294D  bl 0x822c0890
	ctx.lr = 0x82A1DF48;
	sub_822C0890(ctx, base);
	// 82A1DF48: 48000090  b 0x82a1dfd8
	pc = 0x82A1DFD8; continue 'dispatch;
	// 82A1DF4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1DF50: 4BDD6491  bl 0x827f43e0
	ctx.lr = 0x82A1DF54;
	sub_827F43E0(ctx, base);
	// 82A1DF54: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1DF58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1DF5C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1DF60: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A1DF64: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A1DF68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A1DF6C: 4E800421  bctrl
	ctx.lr = 0x82A1DF70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1DF70: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1DF74: 41820064  beq 0x82a1dfd8
	if ctx.cr[0].eq {
	pc = 0x82A1DFD8; continue 'dispatch;
	}
	// 82A1DF78: 38800022  li r4, 0x22
	ctx.r[4].s64 = 34;
	// 82A1DF7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1DF80: 4BFFB989  bl 0x82a19908
	ctx.lr = 0x82A1DF84;
	sub_82A19908(ctx, base);
	// 82A1DF84: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1DF88: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 82A1DF8C: C00B9F18  lfs f0, -0x60e8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1DF90: 48000040  b 0x82a1dfd0
	pc = 0x82A1DFD0; continue 'dispatch;
	// 82A1DF94: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1DF98: C1AB08A4  lfs f13, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A1DF9C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A1DFA0: 40980038  bge cr6, 0x82a1dfd8
	if !ctx.cr[6].lt {
	pc = 0x82A1DFD8; continue 'dispatch;
	}
	// 82A1DFA4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1DFA8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A1DFAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1DFB0: C02B9EFC  lfs f1, -0x6104(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24836 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A1DFB4: 4BFFB5B5  bl 0x82a19568
	ctx.lr = 0x82A1DFB8;
	sub_82A19568(ctx, base);
	// 82A1DFB8: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A1DFBC: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A1DFC0: 48000018  b 0x82a1dfd8
	pc = 0x82A1DFD8; continue 'dispatch;
	// 82A1DFC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1DFC8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A1DFCC: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1DFD0: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A1DFD4: 915F0064  stw r10, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82A1DFD8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A1DFDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1DFE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1DFE4: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A1DFE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1DFEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1DFF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1DFF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A1DFF8 size=12
    let mut pc: u32 = 0x82A1DFF8;
    'dispatch: loop {
        match pc {
            0x82A1DFF8 => {
    //   block [0x82A1DFF8..0x82A1E004)
	// 82A1DFF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1DFFC: 91630064  stw r11, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A1E000: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1E008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1E008 size=96
    let mut pc: u32 = 0x82A1E008;
    'dispatch: loop {
        match pc {
            0x82A1E008 => {
    //   block [0x82A1E008..0x82A1E068)
	// 82A1E008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1E00C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1E010: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1E014: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1E018: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1E01C: 4800012D  bl 0x82a1e148
	ctx.lr = 0x82A1E020;
	sub_82A1E148(ctx, base);
	// 82A1E020: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1E024: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 82A1E028: 396BA168  addi r11, r11, -0x5e98
	ctx.r[11].s64 = ctx.r[11].s64 + -24216;
	// 82A1E02C: 388A9FE8  addi r4, r10, -0x6018
	ctx.r[4].s64 = ctx.r[10].s64 + -24600;
	// 82A1E030: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A1E034: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1E038: 483D59D1  bl 0x82df3a08
	ctx.lr = 0x82A1E03C;
	sub_82DF3A08(ctx, base);
	// 82A1E03C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1E040: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A1E044: 4843B6A5  bl 0x82e596e8
	ctx.lr = 0x82A1E048;
	sub_82E596E8(ctx, base);
	// 82A1E048: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1E04C: 483D53DD  bl 0x82df3428
	ctx.lr = 0x82A1E050;
	sub_82DF3428(ctx, base);
	// 82A1E050: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1E054: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1E058: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1E05C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1E060: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1E064: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1E068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A1E068 size=224
    let mut pc: u32 = 0x82A1E068;
    'dispatch: loop {
        match pc {
            0x82A1E068 => {
    //   block [0x82A1E068..0x82A1E148)
	// 82A1E068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1E06C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1E070: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1E074: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1E078: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A1E07C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1E080: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1E084: 4873657D  bl 0x83154600
	ctx.lr = 0x82A1E088;
	sub_83154600(ctx, base);
	// 82A1E088: 4BFF4E31  bl 0x82a12eb8
	ctx.lr = 0x82A1E08C;
	sub_82A12EB8(ctx, base);
	// 82A1E08C: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A1E090: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A1E094: 41980080  blt cr6, 0x82a1e114
	if ctx.cr[6].lt {
	pc = 0x82A1E114; continue 'dispatch;
	}
	// 82A1E098: 409A0094  bne cr6, 0x82a1e12c
	if !ctx.cr[6].eq {
	pc = 0x82A1E12C; continue 'dispatch;
	}
	// 82A1E09C: 4BDD6345  bl 0x827f43e0
	ctx.lr = 0x82A1E0A0;
	sub_827F43E0(ctx, base);
	// 82A1E0A0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1E0A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1E0A8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1E0AC: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A1E0B0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A1E0B4: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A1E0B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A1E0BC: 4E800421  bctrl
	ctx.lr = 0x82A1E0C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1E0C0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1E0C4: 41820068  beq 0x82a1e12c
	if ctx.cr[0].eq {
	pc = 0x82A1E12C; continue 'dispatch;
	}
	// 82A1E0C8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A1E0CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1E0D0: 388B893C  addi r4, r11, -0x76c4
	ctx.r[4].s64 = ctx.r[11].s64 + -30404;
	// 82A1E0D4: 483D5935  bl 0x82df3a08
	ctx.lr = 0x82A1E0D8;
	sub_82DF3A08(ctx, base);
	// 82A1E0D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1E0DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1E0E0: 485EA049  bl 0x83008128
	ctx.lr = 0x82A1E0E4;
	sub_83008128(ctx, base);
	// 82A1E0E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1E0E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1E0EC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A1E0F0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A1E0F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A1E0F8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A1E0FC: 48440865  bl 0x82e5e960
	ctx.lr = 0x82A1E100;
	sub_82E5E960(ctx, base);
	// 82A1E100: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A1E104: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1E108: 419A0024  beq cr6, 0x82a1e12c
	if ctx.cr[6].eq {
	pc = 0x82A1E12C; continue 'dispatch;
	}
	// 82A1E10C: 4B8A2785  bl 0x822c0890
	ctx.lr = 0x82A1E110;
	sub_822C0890(ctx, base);
	// 82A1E110: 4800001C  b 0x82a1e12c
	pc = 0x82A1E12C; continue 'dispatch;
	// 82A1E114: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1E118: 3880000F  li r4, 0xf
	ctx.r[4].s64 = 15;
	// 82A1E11C: C02B9EFC  lfs f1, -0x6104(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24836 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A1E120: 4BFFB449  bl 0x82a19568
	ctx.lr = 0x82A1E124;
	sub_82A19568(ctx, base);
	// 82A1E124: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A1E128: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A1E12C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A1E130: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1E134: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1E138: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A1E13C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1E140: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1E144: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1E148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A1E148 size=72
    let mut pc: u32 = 0x82A1E148;
    'dispatch: loop {
        match pc {
            0x82A1E148 => {
    //   block [0x82A1E148..0x82A1E190)
	// 82A1E148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1E14C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1E150: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1E154: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1E158: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1E15C: 4843E7CD  bl 0x82e5c928
	ctx.lr = 0x82A1E160;
	sub_82E5C928(ctx, base);
	// 82A1E160: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1E164: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A1E168: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1E16C: 394AA190  addi r10, r10, -0x5e70
	ctx.r[10].s64 = ctx.r[10].s64 + -24176;
	// 82A1E170: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1E174: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1E178: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A1E17C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A1E180: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1E184: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1E188: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1E18C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1E190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A1E190 size=12
    let mut pc: u32 = 0x82A1E190;
    'dispatch: loop {
        match pc {
            0x82A1E190 => {
    //   block [0x82A1E190..0x82A1E19C)
	// 82A1E190: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A1E194: 386B0DA8  addi r3, r11, 0xda8
	ctx.r[3].s64 = ctx.r[11].s64 + 3496;
	// 82A1E198: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1E1A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1E1A0 size=84
    let mut pc: u32 = 0x82A1E1A0;
    'dispatch: loop {
        match pc {
            0x82A1E1A0 => {
    //   block [0x82A1E1A0..0x82A1E1F4)
	// 82A1E1A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1E1A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1E1A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1E1AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1E1B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1E1B4: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82A1E1B8: 4B8A2781  bl 0x822c0938
	ctx.lr = 0x82A1E1BC;
	sub_822C0938(ctx, base);
	// 82A1E1BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A1E1C0: 4182001C  beq 0x82a1e1dc
	if ctx.cr[0].eq {
	pc = 0x82A1E1DC; continue 'dispatch;
	}
	// 82A1E1C4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1E1C8: 396BA1B8  addi r11, r11, -0x5e48
	ctx.r[11].s64 = ctx.r[11].s64 + -24136;
	// 82A1E1CC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A1E1D0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1E1D4: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A1E1D8: 48000008  b 0x82a1e1e0
	pc = 0x82A1E1E0; continue 'dispatch;
	// 82A1E1DC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A1E1E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A1E1E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1E1E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1E1EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1E1F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1E1F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1E1F8 size=96
    let mut pc: u32 = 0x82A1E1F8;
    'dispatch: loop {
        match pc {
            0x82A1E1F8 => {
    //   block [0x82A1E1F8..0x82A1E258)
	// 82A1E1F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1E1FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1E200: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1E204: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1E208: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1E20C: 4BFFFF3D  bl 0x82a1e148
	ctx.lr = 0x82A1E210;
	sub_82A1E148(ctx, base);
	// 82A1E210: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1E214: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A1E218: 396BA1C8  addi r11, r11, -0x5e38
	ctx.r[11].s64 = ctx.r[11].s64 + -24120;
	// 82A1E21C: 388A893C  addi r4, r10, -0x76c4
	ctx.r[4].s64 = ctx.r[10].s64 + -30404;
	// 82A1E220: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A1E224: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1E228: 483D57E1  bl 0x82df3a08
	ctx.lr = 0x82A1E22C;
	sub_82DF3A08(ctx, base);
	// 82A1E22C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1E230: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A1E234: 4843B4B5  bl 0x82e596e8
	ctx.lr = 0x82A1E238;
	sub_82E596E8(ctx, base);
	// 82A1E238: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1E23C: 483D51ED  bl 0x82df3428
	ctx.lr = 0x82A1E240;
	sub_82DF3428(ctx, base);
	// 82A1E240: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1E244: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1E248: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1E24C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1E250: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1E254: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1E258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1E258 size=108
    let mut pc: u32 = 0x82A1E258;
    'dispatch: loop {
        match pc {
            0x82A1E258 => {
    //   block [0x82A1E258..0x82A1E2C4)
	// 82A1E258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1E25C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1E260: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1E264: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1E268: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1E26C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1E270: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82A1E274: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A1E278: 4B8A26C1  bl 0x822c0938
	ctx.lr = 0x82A1E27C;
	sub_822C0938(ctx, base);
	// 82A1E27C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A1E280: 41820020  beq 0x82a1e2a0
	if ctx.cr[0].eq {
	pc = 0x82A1E2A0; continue 'dispatch;
	}
	// 82A1E284: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A1E288: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A1E28C: 394AA1B8  addi r10, r10, -0x5e48
	ctx.r[10].s64 = ctx.r[10].s64 + -24136;
	// 82A1E290: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1E294: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1E298: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A1E29C: 48000008  b 0x82a1e2a4
	pc = 0x82A1E2A4; continue 'dispatch;
	// 82A1E2A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1E2A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A1E2A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1E2AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1E2B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1E2B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1E2B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1E2BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1E2C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1E2C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1E2C8 size=100
    let mut pc: u32 = 0x82A1E2C8;
    'dispatch: loop {
        match pc {
            0x82A1E2C8 => {
    //   block [0x82A1E2C8..0x82A1E32C)
	// 82A1E2C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1E2CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1E2D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1E2D4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1E2D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1E2DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1E2E0: 4BFFFF79  bl 0x82a1e258
	ctx.lr = 0x82A1E2E4;
	sub_82A1E258(ctx, base);
	// 82A1E2E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1E2E8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1E2EC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A1E2F0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A1E2F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1E2F8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1E2FC: 419A0018  beq cr6, 0x82a1e314
	if ctx.cr[6].eq {
	pc = 0x82A1E314; continue 'dispatch;
	}
	// 82A1E300: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1E304: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A1E308: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1E30C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A1E310: 4E800421  bctrl
	ctx.lr = 0x82A1E314;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1E314: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1E318: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1E31C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1E320: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1E324: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1E328: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1E330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A1E330 size=912
    let mut pc: u32 = 0x82A1E330;
    'dispatch: loop {
        match pc {
            0x82A1E330 => {
    //   block [0x82A1E330..0x82A1E6C0)
	// 82A1E330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1E334: 48789E35  bl 0x831a8168
	ctx.lr = 0x82A1E338;
	sub_831A8130(ctx, base);
	// 82A1E338: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A1E33C: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1E340: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1E344: 487362BD  bl 0x83154600
	ctx.lr = 0x82A1E348;
	sub_83154600(ctx, base);
	// 82A1E348: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1E34C: 4BDCDE8D  bl 0x827ec1d8
	ctx.lr = 0x82A1E350;
	sub_827EC1D8(ctx, base);
	// 82A1E350: 396100C0  addi r11, r1, 0xc0
	ctx.r[11].s64 = ctx.r[1].s64 + 192;
	// 82A1E354: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A1E358: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A1E35C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A1E360: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A1E364: 4B8FEE6D  bl 0x8231d1d0
	ctx.lr = 0x82A1E368;
	sub_8231D1D0(ctx, base);
	// 82A1E368: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1E36C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1E370: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1E374: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1E378: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A1E37C: 419A0024  beq cr6, 0x82a1e3a0
	if ctx.cr[6].eq {
	pc = 0x82A1E3A0; continue 'dispatch;
	}
	// 82A1E380: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A1E384: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1E388: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1E38C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1E390: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A1E394: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1E398: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1E39C: 4082FFE8  bne 0x82a1e384
	if !ctx.cr[0].eq {
	pc = 0x82A1E384; continue 'dispatch;
	}
	// 82A1E3A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1E3A4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A1E3A8: 4BAF1121  bl 0x8250f4c8
	ctx.lr = 0x82A1E3AC;
	sub_8250F4C8(ctx, base);
	// 82A1E3AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1E3B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1E3B4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A1E3B8: 409A0008  bne cr6, 0x82a1e3c0
	if !ctx.cr[6].eq {
	pc = 0x82A1E3C0; continue 'dispatch;
	}
	// 82A1E3BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A1E3C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A1E3C4: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 82A1E3C8: 4BAEA651  bl 0x82508a18
	ctx.lr = 0x82A1E3CC;
	sub_82508A18(ctx, base);
	// 82A1E3CC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1E3D0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A1E3D4: 388BA1F8  addi r4, r11, -0x5e08
	ctx.r[4].s64 = ctx.r[11].s64 + -24072;
	// 82A1E3D8: 38A00038  li r5, 0x38
	ctx.r[5].s64 = 56;
	// 82A1E3DC: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A1E3E0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A1E3E4: 48438C05  bl 0x82e56fe8
	ctx.lr = 0x82A1E3E8;
	sub_82E56FE8(ctx, base);
	// 82A1E3E8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A1E3EC: 483D38A5  bl 0x82df1c90
	ctx.lr = 0x82A1E3F0;
	sub_82DF1C90(ctx, base);
	// 82A1E3F0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A1E3F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1E3F8: 419A0008  beq cr6, 0x82a1e400
	if ctx.cr[6].eq {
	pc = 0x82A1E400; continue 'dispatch;
	}
	// 82A1E3FC: 4B8A2495  bl 0x822c0890
	ctx.lr = 0x82A1E400;
	sub_822C0890(ctx, base);
	// 82A1E400: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A1E404: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1E408: 419A0008  beq cr6, 0x82a1e410
	if ctx.cr[6].eq {
	pc = 0x82A1E410; continue 'dispatch;
	}
	// 82A1E40C: 4B8A2485  bl 0x822c0890
	ctx.lr = 0x82A1E410;
	sub_822C0890(ctx, base);
	// 82A1E410: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1E414: 4BFF526D  bl 0x82a13680
	ctx.lr = 0x82A1E418;
	sub_82A13680(ctx, base);
	// 82A1E418: 396100C0  addi r11, r1, 0xc0
	ctx.r[11].s64 = ctx.r[1].s64 + 192;
	// 82A1E41C: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A1E420: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A1E424: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82A1E428: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1E42C: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1E6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1E6C0 size=112
    let mut pc: u32 = 0x82A1E6C0;
    'dispatch: loop {
        match pc {
            0x82A1E6C0 => {
    //   block [0x82A1E6C0..0x82A1E730)
	// 82A1E6C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1E6C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1E6C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1E6CC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1E6D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1E6D4: 4BFFFA75  bl 0x82a1e148
	ctx.lr = 0x82A1E6D8;
	sub_82A1E148(ctx, base);
	// 82A1E6D8: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A1E6DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1E6E0: 394AA244  addi r10, r10, -0x5dbc
	ctx.r[10].s64 = ctx.r[10].s64 + -23996;
	// 82A1E6E4: 997F0068  stb r11, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u8 ) };
	// 82A1E6E8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82A1E6EC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1E6F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1E6F4: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A1E6F8: 38890740  addi r4, r9, 0x740
	ctx.r[4].s64 = ctx.r[9].s64 + 1856;
	// 82A1E6FC: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A1E700: 483D5309  bl 0x82df3a08
	ctx.lr = 0x82A1E704;
	sub_82DF3A08(ctx, base);
	// 82A1E704: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1E708: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A1E70C: 4843AFDD  bl 0x82e596e8
	ctx.lr = 0x82A1E710;
	sub_82E596E8(ctx, base);
	// 82A1E710: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1E714: 483D4D15  bl 0x82df3428
	ctx.lr = 0x82A1E718;
	sub_82DF3428(ctx, base);
	// 82A1E718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1E71C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1E720: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1E724: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1E728: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1E72C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1E730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A1E730 size=272
    let mut pc: u32 = 0x82A1E730;
    'dispatch: loop {
        match pc {
            0x82A1E730 => {
    //   block [0x82A1E730..0x82A1E840)
	// 82A1E730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1E734: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1E738: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1E73C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1E740: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A1E744: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1E748: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1E74C: 48735EB5  bl 0x83154600
	ctx.lr = 0x82A1E750;
	sub_83154600(ctx, base);
	// 82A1E750: 4BFF4769  bl 0x82a12eb8
	ctx.lr = 0x82A1E754;
	sub_82A12EB8(ctx, base);
	// 82A1E754: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A1E758: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A1E75C: 41980080  blt cr6, 0x82a1e7dc
	if ctx.cr[6].lt {
	pc = 0x82A1E7DC; continue 'dispatch;
	}
	// 82A1E760: 409A00C4  bne cr6, 0x82a1e824
	if !ctx.cr[6].eq {
	pc = 0x82A1E824; continue 'dispatch;
	}
	// 82A1E764: 4BDD5C7D  bl 0x827f43e0
	ctx.lr = 0x82A1E768;
	sub_827F43E0(ctx, base);
	// 82A1E768: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1E76C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1E770: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1E774: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A1E778: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A1E77C: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A1E780: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A1E784: 4E800421  bctrl
	ctx.lr = 0x82A1E788;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1E788: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1E78C: 41820098  beq 0x82a1e824
	if ctx.cr[0].eq {
	pc = 0x82A1E824; continue 'dispatch;
	}
	// 82A1E790: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A1E794: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1E798: 388B893C  addi r4, r11, -0x76c4
	ctx.r[4].s64 = ctx.r[11].s64 + -30404;
	// 82A1E79C: 483D526D  bl 0x82df3a08
	ctx.lr = 0x82A1E7A0;
	sub_82DF3A08(ctx, base);
	// 82A1E7A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1E7A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1E7A8: 485E9981  bl 0x83008128
	ctx.lr = 0x82A1E7AC;
	sub_83008128(ctx, base);
	// 82A1E7AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1E7B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1E7B4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A1E7B8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A1E7BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A1E7C0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A1E7C4: 4844019D  bl 0x82e5e960
	ctx.lr = 0x82A1E7C8;
	sub_82E5E960(ctx, base);
	// 82A1E7C8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A1E7CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1E7D0: 419A0054  beq cr6, 0x82a1e824
	if ctx.cr[6].eq {
	pc = 0x82A1E824; continue 'dispatch;
	}
	// 82A1E7D4: 4B8A20BD  bl 0x822c0890
	ctx.lr = 0x82A1E7D8;
	sub_822C0890(ctx, base);
	// 82A1E7D8: 4800004C  b 0x82a1e824
	pc = 0x82A1E824; continue 'dispatch;
	// 82A1E7DC: 897F0068  lbz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A1E7E0: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82A1E7E4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A1E7E8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1E7EC: C02B9EFC  lfs f1, -0x6104(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24836 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A1E7F0: 40820008  bne 0x82a1e7f8
	if !ctx.cr[0].eq {
	pc = 0x82A1E7F8; continue 'dispatch;
	}
	// 82A1E7F4: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82A1E7F8: 4BFFAD71  bl 0x82a19568
	ctx.lr = 0x82A1E7FC;
	sub_82A19568(ctx, base);
	// 82A1E7FC: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A1E800: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A1E804: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A1E808: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A1E80C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A1E810: 388AA268  addi r4, r10, -0x5d98
	ctx.r[4].s64 = ctx.r[10].s64 + -23960;
	// 82A1E814: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1E818: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1E81C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A1E820: 4E800421  bctrl
	ctx.lr = 0x82A1E824;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1E824: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A1E828: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1E82C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1E830: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A1E834: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1E838: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1E83C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1E840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1E840 size=232
    let mut pc: u32 = 0x82A1E840;
    'dispatch: loop {
        match pc {
            0x82A1E840 => {
    //   block [0x82A1E840..0x82A1E928)
	// 82A1E840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1E844: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1E848: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1E84C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1E850: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1E854: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1E858: 48735DA9  bl 0x83154600
	ctx.lr = 0x82A1E85C;
	sub_83154600(ctx, base);
	// 82A1E85C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1E860: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A1E864: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A1E868: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1E86C: 388A9768  addi r4, r10, -0x6898
	ctx.r[4].s64 = ctx.r[10].s64 + -26776;
	// 82A1E870: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1E874: 483D5195  bl 0x82df3a08
	ctx.lr = 0x82A1E878;
	sub_82DF3A08(ctx, base);
	// 82A1E878: 38BF0068  addi r5, r31, 0x68
	ctx.r[5].s64 = ctx.r[31].s64 + 104;
	// 82A1E87C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A1E880: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1E884: 4B915955  bl 0x823341d8
	ctx.lr = 0x82A1E888;
	sub_823341D8(ctx, base);
	// 82A1E888: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1E88C: 483D4B9D  bl 0x82df3428
	ctx.lr = 0x82A1E890;
	sub_82DF3428(ctx, base);
	// 82A1E890: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1E894: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1E898: 4BAF0C31  bl 0x8250f4c8
	ctx.lr = 0x82A1E89C;
	sub_8250F4C8(ctx, base);
	// 82A1E89C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1E8A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1E8A4: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A1E8A8: 409A0008  bne cr6, 0x82a1e8b0
	if !ctx.cr[6].eq {
	pc = 0x82A1E8B0; continue 'dispatch;
	}
	// 82A1E8AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A1E8B0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A1E8B4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A1E8B8: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82A1E8BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1E8C0: 481285E1  bl 0x82b46ea0
	ctx.lr = 0x82A1E8C4;
	sub_82B46EA0(ctx, base);
	// 82A1E8C4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A1E8C8: 3BFF006C  addi r31, r31, 0x6c
	ctx.r[31].s64 = ctx.r[31].s64 + 108;
	// 82A1E8CC: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A1E8D0: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82A1E8D4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1E8D8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A1E8DC: 4B8A5B85  bl 0x822c4460
	ctx.lr = 0x82A1E8E0;
	sub_822C4460(ctx, base);
	// 82A1E8E0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A1E8E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1E8E8: 419A0008  beq cr6, 0x82a1e8f0
	if ctx.cr[6].eq {
	pc = 0x82A1E8F0; continue 'dispatch;
	}
	// 82A1E8EC: 4B8A1FA5  bl 0x822c0890
	ctx.lr = 0x82A1E8F0;
	sub_822C0890(ctx, base);
	// 82A1E8F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1E8F4: 483D339D  bl 0x82df1c90
	ctx.lr = 0x82A1E8F8;
	sub_82DF1C90(ctx, base);
	// 82A1E8F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1E8FC: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1E900: 4BFF4D81  bl 0x82a13680
	ctx.lr = 0x82A1E904;
	sub_82A13680(ctx, base);
	// 82A1E904: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1E908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1E90C: 4812829D  bl 0x82b46ba8
	ctx.lr = 0x82A1E910;
	sub_82B46BA8(ctx, base);
	// 82A1E910: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A1E914: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1E918: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1E91C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1E920: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1E924: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1E928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1E928 size=96
    let mut pc: u32 = 0x82A1E928;
    'dispatch: loop {
        match pc {
            0x82A1E928 => {
    //   block [0x82A1E928..0x82A1E988)
	// 82A1E928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1E92C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1E930: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1E934: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1E938: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1E93C: 4BFFF80D  bl 0x82a1e148
	ctx.lr = 0x82A1E940;
	sub_82A1E148(ctx, base);
	// 82A1E940: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1E944: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82A1E948: 396BA27C  addi r11, r11, -0x5d84
	ctx.r[11].s64 = ctx.r[11].s64 + -23940;
	// 82A1E94C: 388A60C8  addi r4, r10, 0x60c8
	ctx.r[4].s64 = ctx.r[10].s64 + 24776;
	// 82A1E950: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A1E954: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1E958: 483D50B1  bl 0x82df3a08
	ctx.lr = 0x82A1E95C;
	sub_82DF3A08(ctx, base);
	// 82A1E95C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1E960: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A1E964: 4843AD85  bl 0x82e596e8
	ctx.lr = 0x82A1E968;
	sub_82E596E8(ctx, base);
	// 82A1E968: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1E96C: 483D4ABD  bl 0x82df3428
	ctx.lr = 0x82A1E970;
	sub_82DF3428(ctx, base);
	// 82A1E970: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1E974: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1E978: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1E97C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1E980: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1E984: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1E988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A1E988 size=564
    let mut pc: u32 = 0x82A1E988;
    'dispatch: loop {
        match pc {
            0x82A1E988 => {
    //   block [0x82A1E988..0x82A1EBBC)
	// 82A1E988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1E98C: 487897D9  bl 0x831a8164
	ctx.lr = 0x82A1E990;
	sub_831A8130(ctx, base);
	// 82A1E990: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A1E994: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1E998: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1E99C: 91630064  stw r11, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A1E9A0: 48735C61  bl 0x83154600
	ctx.lr = 0x82A1E9A4;
	sub_83154600(ctx, base);
	// 82A1E9A4: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82A1E9A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1E9AC: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	// 82A1E9B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A1E9B4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A1E9B8: 4BAA40E1  bl 0x824c2a98
	ctx.lr = 0x82A1E9BC;
	sub_824C2A98(ctx, base);
	// 82A1E9BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1E9C0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A1E9C4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1E9C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1E9CC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A1E9D0: 419A0024  beq cr6, 0x82a1e9f4
	if ctx.cr[6].eq {
	pc = 0x82A1E9F4; continue 'dispatch;
	}
	// 82A1E9D4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A1E9D8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1E9DC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1E9E0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1E9E4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A1E9E8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1E9EC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1E9F0: 4082FFE8  bne 0x82a1e9d8
	if !ctx.cr[0].eq {
	pc = 0x82A1E9D8; continue 'dispatch;
	}
	// 82A1E9F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1E9F8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A1E9FC: 4BAF0ACD  bl 0x8250f4c8
	ctx.lr = 0x82A1EA00;
	sub_8250F4C8(ctx, base);
	// 82A1EA00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1EA04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1EA08: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A1EA0C: 409A0008  bne cr6, 0x82a1ea14
	if !ctx.cr[6].eq {
	pc = 0x82A1EA14; continue 'dispatch;
	}
	// 82A1EA10: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A1EA14: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 82A1EA18: 3B610058  addi r27, r1, 0x58
	ctx.r[27].s64 = ctx.r[1].s64 + 88;
	// 82A1EA1C: 4BAEA065  bl 0x82508a80
	ctx.lr = 0x82A1EA20;
	sub_82508A80(ctx, base);
	// 82A1EA20: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1EA24: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A1EA28: 3BABA2A0  addi r29, r11, -0x5d60
	ctx.r[29].s64 = ctx.r[11].s64 + -23904;
	// 82A1EA2C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A1EA30: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A1EA34: 38A0003A  li r5, 0x3a
	ctx.r[5].s64 = 58;
	// 82A1EA38: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A1EA3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1EA40: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82A1EA44: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A1EA48: 48439FF9  bl 0x82e58a40
	ctx.lr = 0x82A1EA4C;
	sub_82E58A40(ctx, base);
	// 82A1EA4C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A1EA50: 483D3241  bl 0x82df1c90
	ctx.lr = 0x82A1EA54;
	sub_82DF1C90(ctx, base);
	// 82A1EA54: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A1EA58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1EA5C: 419A0008  beq cr6, 0x82a1ea64
	if ctx.cr[6].eq {
	pc = 0x82A1EA64; continue 'dispatch;
	}
	// 82A1EA60: 4B8A1E31  bl 0x822c0890
	ctx.lr = 0x82A1EA64;
	sub_822C0890(ctx, base);
	// 82A1EA64: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A1EA68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1EA6C: 419A0008  beq cr6, 0x82a1ea74
	if ctx.cr[6].eq {
	pc = 0x82A1EA74; continue 'dispatch;
	}
	// 82A1EA70: 4B8A1E21  bl 0x822c0890
	ctx.lr = 0x82A1EA74;
	sub_822C0890(ctx, base);
	// 82A1EA74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1EA78: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A1EA7C: 4BAF0A4D  bl 0x8250f4c8
	ctx.lr = 0x82A1EA80;
	sub_8250F4C8(ctx, base);
	// 82A1EA80: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1EA84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1EA88: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A1EA8C: 409A0008  bne cr6, 0x82a1ea94
	if !ctx.cr[6].eq {
	pc = 0x82A1EA94; continue 'dispatch;
	}
	// 82A1EA90: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A1EA94: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A1EA98: 4BAE9BE9  bl 0x82508680
	ctx.lr = 0x82A1EA9C;
	sub_82508680(ctx, base);
	// 82A1EA9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1EAA0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A1EAA4: 483D31ED  bl 0x82df1c90
	ctx.lr = 0x82A1EAA8;
	sub_82DF1C90(ctx, base);
	// 82A1EAA8: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82A1EAAC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A1EAB0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A1EAB4: 4B9A04FD  bl 0x823befb0
	ctx.lr = 0x82A1EAB8;
	sub_823BEFB0(ctx, base);
	// 82A1EAB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1EABC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1EAC0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1EAC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1EAC8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A1EACC: 419A0024  beq cr6, 0x82a1eaf0
	if ctx.cr[6].eq {
	pc = 0x82A1EAF0; continue 'dispatch;
	}
	// 82A1EAD0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A1EAD4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1EAD8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1EADC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1EAE0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A1EAE4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1EAE8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1EAEC: 4082FFE8  bne 0x82a1ead4
	if !ctx.cr[0].eq {
	pc = 0x82A1EAD4; continue 'dispatch;
	}
	// 82A1EAF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A1EAF4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A1EAF8: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82A1EAFC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82A1EB00: 38A0003E  li r5, 0x3e
	ctx.r[5].s64 = 62;
	// 82A1EB04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1EB08: 48439F39  bl 0x82e58a40
	ctx.lr = 0x82A1EB0C;
	sub_82E58A40(ctx, base);
	// 82A1EB0C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A1EB10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1EB14: 419A0008  beq cr6, 0x82a1eb1c
	if ctx.cr[6].eq {
	pc = 0x82A1EB1C; continue 'dispatch;
	}
	// 82A1EB18: 4B8A1D79  bl 0x822c0890
	ctx.lr = 0x82A1EB1C;
	sub_822C0890(ctx, base);
	// 82A1EB1C: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A1EB20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1EB24: 419A0008  beq cr6, 0x82a1eb2c
	if ctx.cr[6].eq {
	pc = 0x82A1EB2C; continue 'dispatch;
	}
	// 82A1EB28: 4B8A1D69  bl 0x822c0890
	ctx.lr = 0x82A1EB2C;
	sub_822C0890(ctx, base);
	// 82A1EB2C: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	// 82A1EB30: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A1EB34: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A1EB38: 4BB59D99  bl 0x825788d0
	ctx.lr = 0x82A1EB3C;
	sub_825788D0(ctx, base);
	// 82A1EB3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1EB40: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A1EB44: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1EB48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1EB4C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A1EB50: 419A0024  beq cr6, 0x82a1eb74
	if ctx.cr[6].eq {
	pc = 0x82A1EB74; continue 'dispatch;
	}
	// 82A1EB54: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A1EB58: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1EB5C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1EB60: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1EB64: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A1EB68: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1EB6C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1EB70: 4082FFE8  bne 0x82a1eb58
	if !ctx.cr[0].eq {
	pc = 0x82A1EB58; continue 'dispatch;
	}
	// 82A1EB74: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A1EB78: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A1EB7C: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 82A1EB80: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82A1EB84: 38A0003F  li r5, 0x3f
	ctx.r[5].s64 = 63;
	// 82A1EB88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1EB8C: 48439EB5  bl 0x82e58a40
	ctx.lr = 0x82A1EB90;
	sub_82E58A40(ctx, base);
	// 82A1EB90: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A1EB94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1EB98: 419A0008  beq cr6, 0x82a1eba0
	if ctx.cr[6].eq {
	pc = 0x82A1EBA0; continue 'dispatch;
	}
	// 82A1EB9C: 4B8A1CF5  bl 0x822c0890
	ctx.lr = 0x82A1EBA0;
	sub_822C0890(ctx, base);
	// 82A1EBA0: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A1EBA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1EBA8: 419A0008  beq cr6, 0x82a1ebb0
	if ctx.cr[6].eq {
	pc = 0x82A1EBB0; continue 'dispatch;
	}
	// 82A1EBAC: 4B8A1CE5  bl 0x822c0890
	ctx.lr = 0x82A1EBB0;
	sub_822C0890(ctx, base);
	// 82A1EBB0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A1EBB4: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A1EBB8: 487895FC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1EBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A1EBC0 size=1316
    let mut pc: u32 = 0x82A1EBC0;
    'dispatch: loop {
        match pc {
            0x82A1EBC0 => {
    //   block [0x82A1EBC0..0x82A1F0E4)
	// 82A1EBC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1EBC4: 487895A5  bl 0x831a8168
	ctx.lr = 0x82A1EBC8;
	sub_831A8130(ctx, base);
	// 82A1EBC8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A1EBCC: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1EBD0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A1EBD4: 48735A2D  bl 0x83154600
	ctx.lr = 0x82A1EBD8;
	sub_83154600(ctx, base);
	// 82A1EBD8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1EBDC: 4BFF42DD  bl 0x82a12eb8
	ctx.lr = 0x82A1EBE0;
	sub_82A12EB8(ctx, base);
	// 82A1EBE0: 817C0064  lwz r11, 0x64(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A1EBE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1EBE8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A1EBEC: 419803AC  blt cr6, 0x82a1ef98
	if ctx.cr[6].lt {
	pc = 0x82A1EF98; continue 'dispatch;
	}
	// 82A1EBF0: 419A0364  beq cr6, 0x82a1ef54
	if ctx.cr[6].eq {
	pc = 0x82A1EF54; continue 'dispatch;
	}
	// 82A1EBF4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A1EBF8: 419800E0  blt cr6, 0x82a1ecd8
	if ctx.cr[6].lt {
	pc = 0x82A1ECD8; continue 'dispatch;
	}
	// 82A1EBFC: 409A04DC  bne cr6, 0x82a1f0d8
	if !ctx.cr[6].eq {
	pc = 0x82A1F0D8; continue 'dispatch;
	}
	// 82A1EC00: 4BDD57E1  bl 0x827f43e0
	ctx.lr = 0x82A1EC04;
	sub_827F43E0(ctx, base);
	// 82A1EC04: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1EC08: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1EC0C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1EC10: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A1EC14: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A1EC18: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A1EC1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A1EC20: 4E800421  bctrl
	ctx.lr = 0x82A1EC24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1EC24: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1EC28: 418204B0  beq 0x82a1f0d8
	if ctx.cr[0].eq {
	pc = 0x82A1F0D8; continue 'dispatch;
	}
	// 82A1EC2C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A1EC30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1EC34: 4BFF49FD  bl 0x82a13630
	ctx.lr = 0x82A1EC38;
	sub_82A13630(ctx, base);
	// 82A1EC38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A1EC3C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A1EC40: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82A1EC44: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A1EC48: 4BF6C399  bl 0x8298afe0
	ctx.lr = 0x82A1EC4C;
	sub_8298AFE0(ctx, base);
	// 82A1EC4C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1EC50: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82A1EC54: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1EC58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1EC5C: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82A1EC60: 419A0024  beq cr6, 0x82a1ec84
	if ctx.cr[6].eq {
	pc = 0x82A1EC84; continue 'dispatch;
	}
	// 82A1EC64: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A1EC68: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1EC6C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1EC70: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1EC74: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A1EC78: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1EC7C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1EC80: 4082FFE8  bne 0x82a1ec68
	if !ctx.cr[0].eq {
	pc = 0x82A1EC68; continue 'dispatch;
	}
	// 82A1EC84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1EC88: 3BE10078  addi r31, r1, 0x78
	ctx.r[31].s64 = ctx.r[1].s64 + 120;
	// 82A1EC8C: 4BFF48F5  bl 0x82a13580
	ctx.lr = 0x82A1EC90;
	sub_82A13580(ctx, base);
	// 82A1EC90: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1EC94: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A1EC98: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A1EC9C: 388BA2A0  addi r4, r11, -0x5d60
	ctx.r[4].s64 = ctx.r[11].s64 + -23904;
	// 82A1ECA0: 38A00088  li r5, 0x88
	ctx.r[5].s64 = 136;
	// 82A1ECA4: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82A1ECA8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A1ECAC: 48439D95  bl 0x82e58a40
	ctx.lr = 0x82A1ECB0;
	sub_82E58A40(ctx, base);
	// 82A1ECB0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A1ECB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1ECB8: 419A0008  beq cr6, 0x82a1ecc0
	if ctx.cr[6].eq {
	pc = 0x82A1ECC0; continue 'dispatch;
	}
	// 82A1ECBC: 4B8A1BD5  bl 0x822c0890
	ctx.lr = 0x82A1ECC0;
	sub_822C0890(ctx, base);
	// 82A1ECC0: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A1ECC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1ECC8: 419A0008  beq cr6, 0x82a1ecd0
	if ctx.cr[6].eq {
	pc = 0x82A1ECD0; continue 'dispatch;
	}
	// 82A1ECCC: 4B8A1BC5  bl 0x822c0890
	ctx.lr = 0x82A1ECD0;
	sub_822C0890(ctx, base);
	// 82A1ECD0: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82A1ECD4: 480002BC  b 0x82a1ef90
	pc = 0x82A1EF90; continue 'dispatch;
	// 82A1ECD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1ECDC: 4BDD5705  bl 0x827f43e0
	ctx.lr = 0x82A1ECE0;
	sub_827F43E0(ctx, base);
	// 82A1ECE0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1ECE4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A1ECE8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1ECEC: C02BD5B8  lfs f1, -0x2a48(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A1ECF0: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A1ECF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A1ECF8: 4E800421  bctrl
	ctx.lr = 0x82A1ECFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1ECFC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1ED00: 418203D8  beq 0x82a1f0d8
	if ctx.cr[0].eq {
	pc = 0x82A1F0D8; continue 'dispatch;
	}
	// 82A1ED04: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1ED08: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1ED0C: 4BAF07BD  bl 0x8250f4c8
	ctx.lr = 0x82A1ED10;
	sub_8250F4C8(ctx, base);
	// 82A1ED10: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A1ED14: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A1ED18: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A1ED1C: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82A1ED20: 3CE08202  lis r7, -0x7dfe
	ctx.r[7].s64 = -2113798144;
	// 82A1ED24: C00B9534  lfs f0, -0x6acc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1ED28: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82A1ED2C: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A1ED30: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82A1ED34: C1A9A308  lfs f13, -0x5cf8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-23800 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A1ED38: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82A1ED3C: C18831E0  lfs f12, 0x31e0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12768 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A1ED40: C16782D0  lfs f11, -0x7d30(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-32048 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A1ED44: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82A1ED48: D3E100A4  stfs f31, 0xa4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82A1ED4C: D3E100A8  stfs f31, 0xa8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82A1ED50: D3E100AC  stfs f31, 0xac(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82A1ED54: D1A10090  stfs f13, 0x90(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82A1ED58: D1810094  stfs f12, 0x94(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82A1ED5C: D1610098  stfs f11, 0x98(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82A1ED60: D3E1009C  stfs f31, 0x9c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82A1ED64: 4BC3BA2D  bl 0x8265a790
	ctx.lr = 0x82A1ED68;
	sub_8265A790(ctx, base);
	// 82A1ED68: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1ED6C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A1ED70: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1ED74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1ED78: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82A1ED7C: 419A0024  beq cr6, 0x82a1eda0
	if ctx.cr[6].eq {
	pc = 0x82A1EDA0; continue 'dispatch;
	}
	// 82A1ED80: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A1ED84: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1ED88: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1ED8C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1ED90: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A1ED94: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1ED98: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1ED9C: 4082FFE8  bne 0x82a1ed84
	if !ctx.cr[0].eq {
	pc = 0x82A1ED84; continue 'dispatch;
	}
	// 82A1EDA0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A1EDA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1EDA8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A1EDAC: 409A0008  bne cr6, 0x82a1edb4
	if !ctx.cr[6].eq {
	pc = 0x82A1EDB4; continue 'dispatch;
	}
	// 82A1EDB0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A1EDB4: 3BFE0028  addi r31, r30, 0x28
	ctx.r[31].s64 = ctx.r[30].s64 + 40;
	// 82A1EDB8: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82A1EDBC: 4BAE9CC5  bl 0x82508a80
	ctx.lr = 0x82A1EDC0;
	sub_82508A80(ctx, base);
	// 82A1EDC0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1EDC4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A1EDC8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A1EDCC: 3BCBA2A0  addi r30, r11, -0x5d60
	ctx.r[30].s64 = ctx.r[11].s64 + -23904;
	// 82A1EDD0: 38A0006F  li r5, 0x6f
	ctx.r[5].s64 = 111;
	// 82A1EDD4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1EDD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1EDDC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A1EDE0: 48439C61  bl 0x82e58a40
	ctx.lr = 0x82A1EDE4;
	sub_82E58A40(ctx, base);
	// 82A1EDE4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A1EDE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1EDEC: 419A0008  beq cr6, 0x82a1edf4
	if ctx.cr[6].eq {
	pc = 0x82A1EDF4; continue 'dispatch;
	}
	// 82A1EDF0: 4B8A1AA1  bl 0x822c0890
	ctx.lr = 0x82A1EDF4;
	sub_822C0890(ctx, base);
	// 82A1EDF4: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82A1EDF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1EDFC: 419A0008  beq cr6, 0x82a1ee04
	if ctx.cr[6].eq {
	pc = 0x82A1EE04; continue 'dispatch;
	}
	// 82A1EE00: 4B8A1A91  bl 0x822c0890
	ctx.lr = 0x82A1EE04;
	sub_822C0890(ctx, base);
	// 82A1EE04: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82A1EE08: 4BB78C71  bl 0x82597a78
	ctx.lr = 0x82A1EE0C;
	sub_82597A78(ctx, base);
	// 82A1EE0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1EE10: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1EE14: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1EE18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1EE1C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A1EE20: 419A0024  beq cr6, 0x82a1ee44
	if ctx.cr[6].eq {
	pc = 0x82A1EE44; continue 'dispatch;
	}
	// 82A1EE24: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A1EE28: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1EE2C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1EE30: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1EE34: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A1EE38: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1EE3C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1EE40: 4082FFE8  bne 0x82a1ee28
	if !ctx.cr[0].eq {
	pc = 0x82A1EE28; continue 'dispatch;
	}
	// 82A1EE44: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A1EE48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1EE4C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A1EE50: 409A0008  bne cr6, 0x82a1ee58
	if !ctx.cr[6].eq {
	pc = 0x82A1EE58; continue 'dispatch;
	}
	// 82A1EE54: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A1EE58: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A1EE5C: 4BAEA005  bl 0x82508e60
	ctx.lr = 0x82A1EE60;
	sub_82508E60(ctx, base);
	// 82A1EE60: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A1EE64: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A1EE68: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1EE6C: 38A00076  li r5, 0x76
	ctx.r[5].s64 = 118;
	// 82A1EE70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1EE74: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A1EE78: 48439BC9  bl 0x82e58a40
	ctx.lr = 0x82A1EE7C;
	sub_82E58A40(ctx, base);
	// 82A1EE7C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A1EE80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1EE84: 419A0008  beq cr6, 0x82a1ee8c
	if ctx.cr[6].eq {
	pc = 0x82A1EE8C; continue 'dispatch;
	}
	// 82A1EE88: 4B8A1A09  bl 0x822c0890
	ctx.lr = 0x82A1EE8C;
	sub_822C0890(ctx, base);
	// 82A1EE8C: 806100E4  lwz r3, 0xe4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A1EE90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1EE94: 419A0008  beq cr6, 0x82a1ee9c
	if ctx.cr[6].eq {
	pc = 0x82A1EE9C; continue 'dispatch;
	}
	// 82A1EE98: 4B8A19F9  bl 0x822c0890
	ctx.lr = 0x82A1EE9C;
	sub_822C0890(ctx, base);
	// 82A1EE9C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1EEA0: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82A1EEA4: 388BA304  addi r4, r11, -0x5cfc
	ctx.r[4].s64 = ctx.r[11].s64 + -23804;
	// 82A1EEA8: 4BF6C0C1  bl 0x8298af68
	ctx.lr = 0x82A1EEAC;
	sub_8298AF68(ctx, base);
	// 82A1EEAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1EEB0: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82A1EEB4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1EEB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1EEBC: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82A1EEC0: 419A0024  beq cr6, 0x82a1eee4
	if ctx.cr[6].eq {
	pc = 0x82A1EEE4; continue 'dispatch;
	}
	// 82A1EEC4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A1EEC8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1EECC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1EED0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1EED4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A1EED8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1EEDC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1EEE0: 4082FFE8  bne 0x82a1eec8
	if !ctx.cr[0].eq {
	pc = 0x82A1EEC8; continue 'dispatch;
	}
	// 82A1EEE4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A1EEE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1EEEC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A1EEF0: 409A0008  bne cr6, 0x82a1eef8
	if !ctx.cr[6].eq {
	pc = 0x82A1EEF8; continue 'dispatch;
	}
	// 82A1EEF4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A1EEF8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A1EEFC: 3BA10080  addi r29, r1, 0x80
	ctx.r[29].s64 = ctx.r[1].s64 + 128;
	// 82A1EF00: 4BAE9B19  bl 0x82508a18
	ctx.lr = 0x82A1EF04;
	sub_82508A18(ctx, base);
	// 82A1EF04: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A1EF08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1EF0C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A1EF10: 38A0007D  li r5, 0x7d
	ctx.r[5].s64 = 125;
	// 82A1EF14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1EF18: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A1EF1C: 48439B25  bl 0x82e58a40
	ctx.lr = 0x82A1EF20;
	sub_82E58A40(ctx, base);
	// 82A1EF20: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A1EF24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1EF28: 419A0008  beq cr6, 0x82a1ef30
	if ctx.cr[6].eq {
	pc = 0x82A1EF30; continue 'dispatch;
	}
	// 82A1EF2C: 4B8A1965  bl 0x822c0890
	ctx.lr = 0x82A1EF30;
	sub_822C0890(ctx, base);
	// 82A1EF30: 806100DC  lwz r3, 0xdc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82A1EF34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1EF38: 419A0008  beq cr6, 0x82a1ef40
	if ctx.cr[6].eq {
	pc = 0x82A1EF40; continue 'dispatch;
	}
	// 82A1EF3C: 4B8A1955  bl 0x822c0890
	ctx.lr = 0x82A1EF40;
	sub_822C0890(ctx, base);
	// 82A1EF40: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82A1EF44: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1EF48: 917C0064  stw r11, 0x64(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A1EF4C: 483D2D45  bl 0x82df1c90
	ctx.lr = 0x82A1EF50;
	sub_82DF1C90(ctx, base);
	// 82A1EF50: 48000188  b 0x82a1f0d8
	pc = 0x82A1F0D8; continue 'dispatch;
	// 82A1EF54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1EF58: 4BDD5489  bl 0x827f43e0
	ctx.lr = 0x82A1EF5C;
	sub_827F43E0(ctx, base);
	// 82A1EF5C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1EF60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1EF64: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1EF68: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A1EF6C: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A1EF70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A1EF74: 4E800421  bctrl
	ctx.lr = 0x82A1EF78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1EF78: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1EF7C: 4182015C  beq 0x82a1f0d8
	if ctx.cr[0].eq {
	pc = 0x82A1F0D8; continue 'dispatch;
	}
	// 82A1EF80: 3880000D  li r4, 0xd
	ctx.r[4].s64 = 13;
	// 82A1EF84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1EF88: 4BFFA981  bl 0x82a19908
	ctx.lr = 0x82A1EF8C;
	sub_82A19908(ctx, base);
	// 82A1EF8C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A1EF90: 917C0064  stw r11, 0x64(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A1EF94: 48000144  b 0x82a1f0d8
	pc = 0x82A1F0D8; continue 'dispatch;
	// 82A1EF98: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1EF9C: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 82A1EFA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1EFA4: C02B9EFC  lfs f1, -0x6104(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24836 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A1EFA8: 4BFFA5C1  bl 0x82a19568
	ctx.lr = 0x82A1EFAC;
	sub_82A19568(ctx, base);
	// 82A1EFAC: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82A1EFB0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A1EFB4: 93BC0064  stw r29, 0x64(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82A1EFB8: 4800ECB9  bl 0x82a2dc70
	ctx.lr = 0x82A1EFBC;
	sub_82A2DC70(ctx, base);
	// 82A1EFBC: 80610088  lwz r3, 0x88(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82A1EFC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1EFC4: 419A0008  beq cr6, 0x82a1efcc
	if ctx.cr[6].eq {
	pc = 0x82A1EFCC; continue 'dispatch;
	}
	// 82A1EFC8: 4800DE49  bl 0x82a2ce10
	ctx.lr = 0x82A1EFCC;
	sub_82A2CE10(ctx, base);
	// 82A1EFCC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1EFD0: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A1EFD4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1EFD8: 38AAA2F4  addi r5, r10, -0x5d0c
	ctx.r[5].s64 = ctx.r[10].s64 + -23820;
	// 82A1EFDC: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82A1EFE0: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A1EFE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A1EFE8: 4E800421  bctrl
	ctx.lr = 0x82A1EFEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1EFEC: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A1EFF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1EFF4: 419A0008  beq cr6, 0x82a1effc
	if ctx.cr[6].eq {
	pc = 0x82A1EFFC; continue 'dispatch;
	}
	// 82A1EFF8: 4B8A1899  bl 0x822c0890
	ctx.lr = 0x82A1EFFC;
	sub_822C0890(ctx, base);
	// 82A1EFFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1F000: 4BFFA7F9  bl 0x82a197f8
	ctx.lr = 0x82A1F004;
	sub_82A197F8(ctx, base);
	// 82A1F004: 9BA10050  stb r29, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 82A1F008: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1F00C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A1F010: 388BA2E8  addi r4, r11, -0x5d18
	ctx.r[4].s64 = ctx.r[11].s64 + -23832;
	// 82A1F014: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82A1F018: 4BF6BE21  bl 0x8298ae38
	ctx.lr = 0x82A1F01C;
	sub_8298AE38(ctx, base);
	// 82A1F01C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1F020: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A1F024: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1F028: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F02C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A1F030: 419A0024  beq cr6, 0x82a1f054
	if ctx.cr[6].eq {
	pc = 0x82A1F054; continue 'dispatch;
	}
	// 82A1F034: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A1F038: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1F03C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1F040: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1F044: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A1F048: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1F04C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1F050: 4082FFE8  bne 0x82a1f038
	if !ctx.cr[0].eq {
	pc = 0x82A1F038; continue 'dispatch;
	}
	// 82A1F054: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1F058: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A1F05C: 4BAF046D  bl 0x8250f4c8
	ctx.lr = 0x82A1F060;
	sub_8250F4C8(ctx, base);
	// 82A1F060: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1F064: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F068: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A1F06C: 409A0008  bne cr6, 0x82a1f074
	if !ctx.cr[6].eq {
	pc = 0x82A1F074; continue 'dispatch;
	}
	// 82A1F070: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A1F074: 3BE10068  addi r31, r1, 0x68
	ctx.r[31].s64 = ctx.r[1].s64 + 104;
	// 82A1F078: 4BAE95A1  bl 0x82508618
	ctx.lr = 0x82A1F07C;
	sub_82508618(ctx, base);
	// 82A1F07C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1F080: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A1F084: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A1F088: 388AA2A0  addi r4, r10, -0x5d60
	ctx.r[4].s64 = ctx.r[10].s64 + -23904;
	// 82A1F08C: 38A0005C  li r5, 0x5c
	ctx.r[5].s64 = 92;
	// 82A1F090: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82A1F094: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A1F098: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A1F09C: 484399A5  bl 0x82e58a40
	ctx.lr = 0x82A1F0A0;
	sub_82E58A40(ctx, base);
	// 82A1F0A0: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A1F0A4: 483D2BED  bl 0x82df1c90
	ctx.lr = 0x82A1F0A8;
	sub_82DF1C90(ctx, base);
	// 82A1F0A8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A1F0AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1F0B0: 419A0008  beq cr6, 0x82a1f0b8
	if ctx.cr[6].eq {
	pc = 0x82A1F0B8; continue 'dispatch;
	}
	// 82A1F0B4: 4B8A17DD  bl 0x822c0890
	ctx.lr = 0x82A1F0B8;
	sub_822C0890(ctx, base);
	// 82A1F0B8: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A1F0BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1F0C0: 419A0008  beq cr6, 0x82a1f0c8
	if ctx.cr[6].eq {
	pc = 0x82A1F0C8; continue 'dispatch;
	}
	// 82A1F0C4: 4B8A17CD  bl 0x822c0890
	ctx.lr = 0x82A1F0C8;
	sub_822C0890(ctx, base);
	// 82A1F0C8: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A1F0CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1F0D0: 419A0008  beq cr6, 0x82a1f0d8
	if ctx.cr[6].eq {
	pc = 0x82A1F0D8; continue 'dispatch;
	}
	// 82A1F0D4: 4B8A17BD  bl 0x822c0890
	ctx.lr = 0x82A1F0D8;
	sub_822C0890(ctx, base);
	// 82A1F0D8: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82A1F0DC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A1F0E0: 487890D8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1F0E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1F0E8 size=132
    let mut pc: u32 = 0x82A1F0E8;
    'dispatch: loop {
        match pc {
            0x82A1F0E8 => {
    //   block [0x82A1F0E8..0x82A1F16C)
	// 82A1F0E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1F0EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1F0F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1F0F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1F0F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1F0FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1F100: 4BFFF049  bl 0x82a1e148
	ctx.lr = 0x82A1F104;
	sub_82A1E148(ctx, base);
	// 82A1F104: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1F108: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A1F10C: 396BA310  addi r11, r11, -0x5cf0
	ctx.r[11].s64 = ctx.r[11].s64 + -23792;
	// 82A1F110: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82A1F114: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A1F118: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1F11C: 93FE006C  stw r31, 0x6c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 82A1F120: 388A4418  addi r4, r10, 0x4418
	ctx.r[4].s64 = ctx.r[10].s64 + 17432;
	// 82A1F124: 93FE0070  stw r31, 0x70(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 82A1F128: 93FE0074  stw r31, 0x74(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82A1F12C: 93FE0078  stw r31, 0x78(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 82A1F130: 483D48D9  bl 0x82df3a08
	ctx.lr = 0x82A1F134;
	sub_82DF3A08(ctx, base);
	// 82A1F134: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1F138: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A1F13C: 4843A5AD  bl 0x82e596e8
	ctx.lr = 0x82A1F140;
	sub_82E596E8(ctx, base);
	// 82A1F140: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1F144: 483D42E5  bl 0x82df3428
	ctx.lr = 0x82A1F148;
	sub_82DF3428(ctx, base);
	// 82A1F148: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A1F14C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1F150: 9BEBDD48  stb r31, -0x22b8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-8888 as u32), ctx.r[31].u8 ) };
	// 82A1F154: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1F158: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1F15C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1F160: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1F164: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1F168: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1F170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1F170 size=224
    let mut pc: u32 = 0x82A1F170;
    'dispatch: loop {
        match pc {
            0x82A1F170 => {
    //   block [0x82A1F170..0x82A1F250)
	// 82A1F170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1F174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1F178: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1F17C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1F180: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1F184: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1F188: 48735479  bl 0x83154600
	ctx.lr = 0x82A1F18C;
	sub_83154600(ctx, base);
	// 82A1F18C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1F190: 4BFF3D31  bl 0x82a12ec0
	ctx.lr = 0x82A1F194;
	sub_82A12EC0(ctx, base);
	// 82A1F194: 4BFFB5C5  bl 0x82a1a758
	ctx.lr = 0x82A1F198;
	sub_82A1A758(ctx, base);
	// 82A1F198: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A1F19C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1F1A0: 4BFF43E9  bl 0x82a13588
	ctx.lr = 0x82A1F1A4;
	sub_82A13588(ctx, base);
	// 82A1F1A4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1F1A8: 41820010  beq 0x82a1f1b8
	if ctx.cr[0].eq {
	pc = 0x82A1F1B8; continue 'dispatch;
	}
	// 82A1F1AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A1F1B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1F1B4: 4BFF7835  bl 0x82a169e8
	ctx.lr = 0x82A1F1B8;
	sub_82A169E8(ctx, base);
	// 82A1F1B8: 3BDE0074  addi r30, r30, 0x74
	ctx.r[30].s64 = ctx.r[30].s64 + 116;
	// 82A1F1BC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1F1C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F1C4: 419A0074  beq cr6, 0x82a1f238
	if ctx.cr[6].eq {
	pc = 0x82A1F238; continue 'dispatch;
	}
	// 82A1F1C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1F1CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1F1D0: 4BAF02F9  bl 0x8250f4c8
	ctx.lr = 0x82A1F1D4;
	sub_8250F4C8(ctx, base);
	// 82A1F1D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1F1D8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A1F1DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F1E0: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A1F1E4: 409A0008  bne cr6, 0x82a1f1ec
	if !ctx.cr[6].eq {
	pc = 0x82A1F1EC; continue 'dispatch;
	}
	// 82A1F1E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1F1EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1F1F0: 4BAEB761  bl 0x8250a950
	ctx.lr = 0x82A1F1F4;
	sub_8250A950(ctx, base);
	// 82A1F1F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1F1F8: 483D2A99  bl 0x82df1c90
	ctx.lr = 0x82A1F1FC;
	sub_82DF1C90(ctx, base);
	// 82A1F1FC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A1F200: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F204: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82A1F208: 409A0008  bne cr6, 0x82a1f210
	if !ctx.cr[6].eq {
	pc = 0x82A1F210; continue 'dispatch;
	}
	// 82A1F20C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1F210: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1F214: 4BDB475D  bl 0x827d3970
	ctx.lr = 0x82A1F218;
	sub_827D3970(ctx, base);
	// 82A1F218: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A1F21C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1F220: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1F224: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A1F228: 419A0008  beq cr6, 0x82a1f230
	if ctx.cr[6].eq {
	pc = 0x82A1F230; continue 'dispatch;
	}
	// 82A1F22C: 4B8A1665  bl 0x822c0890
	ctx.lr = 0x82A1F230;
	sub_822C0890(ctx, base);
	// 82A1F230: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1F234: 483D2A5D  bl 0x82df1c90
	ctx.lr = 0x82A1F238;
	sub_82DF1C90(ctx, base);
	// 82A1F238: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A1F23C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1F240: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1F244: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1F248: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1F24C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1F250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A1F250 size=344
    let mut pc: u32 = 0x82A1F250;
    'dispatch: loop {
        match pc {
            0x82A1F250 => {
    //   block [0x82A1F250..0x82A1F3A8)
	// 82A1F250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1F254: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1F258: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1F25C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1F260: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1F264: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1F268: 48735399  bl 0x83154600
	ctx.lr = 0x82A1F26C;
	sub_83154600(ctx, base);
	// 82A1F26C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1F270: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A1F274: 4BAF0255  bl 0x8250f4c8
	ctx.lr = 0x82A1F278;
	sub_8250F4C8(ctx, base);
	// 82A1F278: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1F27C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F280: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A1F284: 409A0008  bne cr6, 0x82a1f28c
	if !ctx.cr[6].eq {
	pc = 0x82A1F28C; continue 'dispatch;
	}
	// 82A1F288: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A1F28C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1F290: 4BAEB6C1  bl 0x8250a950
	ctx.lr = 0x82A1F294;
	sub_8250A950(ctx, base);
	// 82A1F294: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A1F298: 483D29F9  bl 0x82df1c90
	ctx.lr = 0x82A1F29C;
	sub_82DF1C90(ctx, base);
	// 82A1F29C: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A1F2A0: 3BDF0074  addi r30, r31, 0x74
	ctx.r[30].s64 = ctx.r[31].s64 + 116;
	// 82A1F2A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F2A8: 419A0020  beq cr6, 0x82a1f2c8
	if ctx.cr[6].eq {
	pc = 0x82A1F2C8; continue 'dispatch;
	}
	// 82A1F2AC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A1F2B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F2B4: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82A1F2B8: 409A0008  bne cr6, 0x82a1f2c0
	if !ctx.cr[6].eq {
	pc = 0x82A1F2C0; continue 'dispatch;
	}
	// 82A1F2BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A1F2C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1F2C4: 4BDB46AD  bl 0x827d3970
	ctx.lr = 0x82A1F2C8;
	sub_827D3970(ctx, base);
	// 82A1F2C8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A1F2CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1F2D0: 388B1360  addi r4, r11, 0x1360
	ctx.r[4].s64 = ctx.r[11].s64 + 4960;
	// 82A1F2D4: 483D4735  bl 0x82df3a08
	ctx.lr = 0x82A1F2D8;
	sub_82DF3A08(ctx, base);
	// 82A1F2D8: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A1F2DC: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A1F2E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F2E4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A1F2E8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A1F2EC: 419A0024  beq cr6, 0x82a1f310
	if ctx.cr[6].eq {
	pc = 0x82A1F310; continue 'dispatch;
	}
	// 82A1F2F0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A1F2F4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1F2F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1F2FC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1F300: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A1F304: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1F308: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1F30C: 4082FFE8  bne 0x82a1f2f4
	if !ctx.cr[0].eq {
	pc = 0x82A1F2F4; continue 'dispatch;
	}
	// 82A1F310: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A1F314: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F318: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 82A1F31C: 409A0008  bne cr6, 0x82a1f324
	if !ctx.cr[6].eq {
	pc = 0x82A1F324; continue 'dispatch;
	}
	// 82A1F320: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A1F324: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A1F328: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A1F32C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A1F330: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A1F334: 4BDB597D  bl 0x827d4cb0
	ctx.lr = 0x82A1F338;
	sub_827D4CB0(ctx, base);
	// 82A1F338: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A1F33C: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82A1F340: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A1F344: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1F348: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A1F34C: 4B8A5115  bl 0x822c4460
	ctx.lr = 0x82A1F350;
	sub_822C4460(ctx, base);
	// 82A1F350: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A1F354: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1F358: 419A0008  beq cr6, 0x82a1f360
	if ctx.cr[6].eq {
	pc = 0x82A1F360; continue 'dispatch;
	}
	// 82A1F35C: 4B8A1535  bl 0x822c0890
	ctx.lr = 0x82A1F360;
	sub_822C0890(ctx, base);
	// 82A1F360: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A1F364: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1F368: 419A0008  beq cr6, 0x82a1f370
	if ctx.cr[6].eq {
	pc = 0x82A1F370; continue 'dispatch;
	}
	// 82A1F36C: 4B8A1525  bl 0x822c0890
	ctx.lr = 0x82A1F370;
	sub_822C0890(ctx, base);
	// 82A1F370: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1F374: 483D40B5  bl 0x82df3428
	ctx.lr = 0x82A1F378;
	sub_82DF3428(ctx, base);
	// 82A1F378: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A1F37C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1F380: C02BA1C4  lfs f1, -0x5e3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A1F384: 4846216D  bl 0x82e814f0
	ctx.lr = 0x82A1F388;
	sub_82E814F0(ctx, base);
	// 82A1F388: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1F38C: 483D2905  bl 0x82df1c90
	ctx.lr = 0x82A1F390;
	sub_82DF1C90(ctx, base);
	// 82A1F390: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A1F394: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1F398: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1F39C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1F3A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1F3A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1F3A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A1F3A8 size=796
    let mut pc: u32 = 0x82A1F3A8;
    'dispatch: loop {
        match pc {
            0x82A1F3A8 => {
    //   block [0x82A1F3A8..0x82A1F6C4)
	// 82A1F3A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1F3AC: 48788DBD  bl 0x831a8168
	ctx.lr = 0x82A1F3B0;
	sub_831A8130(ctx, base);
	// 82A1F3B0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A1F3B4: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1F3B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1F3BC: 48735245  bl 0x83154600
	ctx.lr = 0x82A1F3C0;
	sub_83154600(ctx, base);
	// 82A1F3C0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A1F3C4: 4BFF3AF5  bl 0x82a12eb8
	ctx.lr = 0x82A1F3C8;
	sub_82A12EB8(ctx, base);
	// 82A1F3C8: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A1F3CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1F3D0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A1F3D4: 41980288  blt cr6, 0x82a1f65c
	if ctx.cr[6].lt {
	pc = 0x82A1F65C; continue 'dispatch;
	}
	// 82A1F3D8: 419A0238  beq cr6, 0x82a1f610
	if ctx.cr[6].eq {
	pc = 0x82A1F610; continue 'dispatch;
	}
	// 82A1F3DC: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A1F3E0: 41980080  blt cr6, 0x82a1f460
	if ctx.cr[6].lt {
	pc = 0x82A1F460; continue 'dispatch;
	}
	// 82A1F3E4: 409A02D4  bne cr6, 0x82a1f6b8
	if !ctx.cr[6].eq {
	pc = 0x82A1F6B8; continue 'dispatch;
	}
	// 82A1F3E8: 4BDD4FF9  bl 0x827f43e0
	ctx.lr = 0x82A1F3EC;
	sub_827F43E0(ctx, base);
	// 82A1F3EC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1F3F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1F3F4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1F3F8: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A1F3FC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A1F400: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A1F404: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A1F408: 4E800421  bctrl
	ctx.lr = 0x82A1F40C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1F40C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1F410: 418202A8  beq 0x82a1f6b8
	if ctx.cr[0].eq {
	pc = 0x82A1F6B8; continue 'dispatch;
	}
	// 82A1F414: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A1F418: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1F41C: 388B893C  addi r4, r11, -0x76c4
	ctx.r[4].s64 = ctx.r[11].s64 + -30404;
	// 82A1F420: 483D45E9  bl 0x82df3a08
	ctx.lr = 0x82A1F424;
	sub_82DF3A08(ctx, base);
	// 82A1F424: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1F428: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1F42C: 485E8CFD  bl 0x83008128
	ctx.lr = 0x82A1F430;
	sub_83008128(ctx, base);
	// 82A1F430: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1F434: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1F438: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A1F43C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A1F440: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A1F444: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A1F448: 4843F519  bl 0x82e5e960
	ctx.lr = 0x82A1F44C;
	sub_82E5E960(ctx, base);
	// 82A1F44C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A1F450: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1F454: 419A0264  beq cr6, 0x82a1f6b8
	if ctx.cr[6].eq {
	pc = 0x82A1F6B8; continue 'dispatch;
	}
	// 82A1F458: 4B8A1439  bl 0x822c0890
	ctx.lr = 0x82A1F45C;
	sub_822C0890(ctx, base);
	// 82A1F45C: 4800025C  b 0x82a1f6b8
	pc = 0x82A1F6B8; continue 'dispatch;
	// 82A1F460: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1F464: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1F468: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A1F46C: 4843A30D  bl 0x82e59778
	ctx.lr = 0x82A1F470;
	sub_82E59778(ctx, base);
	// 82A1F470: 3FA0832E  lis r29, -0x7cd2
	ctx.r[29].s64 = -2094137344;
	// 82A1F474: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1F478: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1F47C: EDA1002A  fadds f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A1F480: D1BF0060  stfs f13, 0x60(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A1F484: C19D0284  lfs f12, 0x284(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(644 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A1F488: C00B9DFC  lfs f0, -0x6204(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1F48C: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A1F490: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A1F494: 41980030  blt cr6, 0x82a1f4c4
	if ctx.cr[6].lt {
	pc = 0x82A1F4C4; continue 'dispatch;
	}
	// 82A1F498: C1BF0068  lfs f13, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A1F49C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A1F4A0: 40990024  ble cr6, 0x82a1f4c4
	if !ctx.cr[6].gt {
	pc = 0x82A1F4C4; continue 'dispatch;
	}
	// 82A1F4A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1F4A8: 4800E7C9  bl 0x82a2dc70
	ctx.lr = 0x82A1F4AC;
	sub_82A2DC70(ctx, base);
	// 82A1F4AC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1F4B0: 4800DF49  bl 0x82a2d3f8
	ctx.lr = 0x82A1F4B4;
	sub_82A2D3F8(ctx, base);
	// 82A1F4B4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A1F4B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1F4BC: 419A0008  beq cr6, 0x82a1f4c4
	if ctx.cr[6].eq {
	pc = 0x82A1F4C4; continue 'dispatch;
	}
	// 82A1F4C0: 4B8A13D1  bl 0x822c0890
	ctx.lr = 0x82A1F4C4;
	sub_822C0890(ctx, base);
	// 82A1F4C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1F4C8: C1BD0284  lfs f13, 0x284(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(644 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A1F4CC: C19F0060  lfs f12, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A1F4D0: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1F4D4: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A1F4D8: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82A1F4DC: 4198001C  blt cr6, 0x82a1f4f8
	if ctx.cr[6].lt {
	pc = 0x82A1F4F8; continue 'dispatch;
	}
	// 82A1F4E0: C1BF0068  lfs f13, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A1F4E4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A1F4E8: 40990010  ble cr6, 0x82a1f4f8
	if !ctx.cr[6].gt {
	pc = 0x82A1F4F8; continue 'dispatch;
	}
	// 82A1F4EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A1F4F0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A1F4F4: 4BFF720D  bl 0x82a16700
	ctx.lr = 0x82A1F4F8;
	sub_82A16700(ctx, base);
	// 82A1F4F8: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1F4FC: C1BD0284  lfs f13, 0x284(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(644 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A1F500: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A1F504: 419801B4  blt cr6, 0x82a1f6b8
	if ctx.cr[6].lt {
	pc = 0x82A1F6B8; continue 'dispatch;
	}
	// 82A1F508: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A1F50C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1F510: 4BFFA3F9  bl 0x82a19908
	ctx.lr = 0x82A1F514;
	sub_82A19908(ctx, base);
	// 82A1F514: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1F518: 4BFF99F9  bl 0x82a18f10
	ctx.lr = 0x82A1F51C;
	sub_82A18F10(ctx, base);
	// 82A1F51C: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A1F520: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F524: 419A0048  beq cr6, 0x82a1f56c
	if ctx.cr[6].eq {
	pc = 0x82A1F56C; continue 'dispatch;
	}
	// 82A1F528: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A1F52C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A1F530: 4BAEFF99  bl 0x8250f4c8
	ctx.lr = 0x82A1F534;
	sub_8250F4C8(ctx, base);
	// 82A1F534: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1F538: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F53C: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A1F540: 409A0008  bne cr6, 0x82a1f548
	if !ctx.cr[6].eq {
	pc = 0x82A1F548; continue 'dispatch;
	}
	// 82A1F544: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A1F548: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A1F54C: 4BAEB405  bl 0x8250a950
	ctx.lr = 0x82A1F550;
	sub_8250A950(ctx, base);
	// 82A1F550: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A1F554: 483D273D  bl 0x82df1c90
	ctx.lr = 0x82A1F558;
	sub_82DF1C90(ctx, base);
	// 82A1F558: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A1F55C: 807F0074  lwz r3, 0x74(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A1F560: 484621E1  bl 0x82e81740
	ctx.lr = 0x82A1F564;
	sub_82E81740(ctx, base);
	// 82A1F564: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A1F568: 483D2729  bl 0x82df1c90
	ctx.lr = 0x82A1F56C;
	sub_82DF1C90(ctx, base);
	// 82A1F56C: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 82A1F570: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A1F574: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82A1F578: 4BFF4381  bl 0x82a138f8
	ctx.lr = 0x82A1F57C;
	sub_82A138F8(ctx, base);
	// 82A1F57C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1F580: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A1F584: 38ABA350  addi r5, r11, -0x5cb0
	ctx.r[5].s64 = ctx.r[11].s64 + -23728;
	// 82A1F588: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A1F58C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1F590: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A1F594: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A1F598: 4E800421  bctrl
	ctx.lr = 0x82A1F59C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1F59C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A1F5A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1F5A4: 419A0008  beq cr6, 0x82a1f5ac
	if ctx.cr[6].eq {
	pc = 0x82A1F5AC; continue 'dispatch;
	}
	// 82A1F5A8: 4B8A12E9  bl 0x822c0890
	ctx.lr = 0x82A1F5AC;
	sub_822C0890(ctx, base);
	// 82A1F5AC: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A1F5B0: 896ADD48  lbz r11, -0x22b8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(-8888 as u32) ) } as u64;
	// 82A1F5B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A1F5B8: 40820100  bne 0x82a1f6b8
	if !ctx.cr[0].eq {
	pc = 0x82A1F6B8; continue 'dispatch;
	}
	// 82A1F5BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A1F5C0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A1F5C4: 996ADD48  stb r11, -0x22b8(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(-8888 as u32), ctx.r[11].u8 ) };
	// 82A1F5C8: 4800E6A9  bl 0x82a2dc70
	ctx.lr = 0x82A1F5CC;
	sub_82A2DC70(ctx, base);
	// 82A1F5CC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1F5D0: 4BFF3FC9  bl 0x82a13598
	ctx.lr = 0x82A1F5D4;
	sub_82A13598(ctx, base);
	// 82A1F5D4: 7D7E1810  subfc r11, r30, r3
	ctx.xer.ca = ctx.r[3].u32 >= ctx.r[30].u32;
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[30].s64;
	// 82A1F5D8: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A1F5DC: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82A1F5E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1F5E4: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 82A1F5E8: 419A000C  beq cr6, 0x82a1f5f4
	if ctx.cr[6].eq {
	pc = 0x82A1F5F4; continue 'dispatch;
	}
	// 82A1F5EC: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82A1F5F0: 4B8A12A1  bl 0x822c0890
	ctx.lr = 0x82A1F5F4;
	sub_822C0890(ctx, base);
	// 82A1F5F4: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1F5F8: 418200C0  beq 0x82a1f6b8
	if ctx.cr[0].eq {
	pc = 0x82A1F6B8; continue 'dispatch;
	}
	// 82A1F5FC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1F600: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A1F604: 388BA344  addi r4, r11, -0x5cbc
	ctx.r[4].s64 = ctx.r[11].s64 + -23740;
	// 82A1F608: 4BFF75B9  bl 0x82a16bc0
	ctx.lr = 0x82A1F60C;
	sub_82A16BC0(ctx, base);
	// 82A1F60C: 480000AC  b 0x82a1f6b8
	pc = 0x82A1F6B8; continue 'dispatch;
	// 82A1F610: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1F614: 4BDD4DCD  bl 0x827f43e0
	ctx.lr = 0x82A1F618;
	sub_827F43E0(ctx, base);
	// 82A1F618: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1F61C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1F620: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1F624: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A1F628: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A1F62C: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A1F630: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A1F634: 4E800421  bctrl
	ctx.lr = 0x82A1F638;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1F638: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1F63C: 4182007C  beq 0x82a1f6b8
	if ctx.cr[0].eq {
	pc = 0x82A1F6B8; continue 'dispatch;
	}
	// 82A1F640: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 82A1F644: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1F648: 4BFFA2C1  bl 0x82a19908
	ctx.lr = 0x82A1F64C;
	sub_82A19908(ctx, base);
	// 82A1F64C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A1F650: D3FF0060  stfs f31, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A1F654: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A1F658: 48000060  b 0x82a1f6b8
	pc = 0x82A1F6B8; continue 'dispatch;
	// 82A1F65C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1F660: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 82A1F664: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1F668: C02B9EFC  lfs f1, -0x6104(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24836 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A1F66C: 4BFF9EFD  bl 0x82a19568
	ctx.lr = 0x82A1F670;
	sub_82A19568(ctx, base);
	// 82A1F670: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1F674: 4BFFA185  bl 0x82a197f8
	ctx.lr = 0x82A1F678;
	sub_82A197F8(ctx, base);
	// 82A1F678: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A1F67C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A1F680: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A1F684: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A1F688: 38AAA334  addi r5, r10, -0x5ccc
	ctx.r[5].s64 = ctx.r[10].s64 + -23756;
	// 82A1F68C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A1F690: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1F694: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A1F698: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A1F69C: 4E800421  bctrl
	ctx.lr = 0x82A1F6A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1F6A0: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A1F6A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1F6A8: 419A0008  beq cr6, 0x82a1f6b0
	if ctx.cr[6].eq {
	pc = 0x82A1F6B0; continue 'dispatch;
	}
	// 82A1F6AC: 4B8A11E5  bl 0x822c0890
	ctx.lr = 0x82A1F6B0;
	sub_822C0890(ctx, base);
	// 82A1F6B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1F6B4: 4BFFFB9D  bl 0x82a1f250
	ctx.lr = 0x82A1F6B8;
	sub_82A1F250(ctx, base);
	// 82A1F6B8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A1F6BC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A1F6C0: 48788AF8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1F6C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1F6C8 size=276
    let mut pc: u32 = 0x82A1F6C8;
    'dispatch: loop {
        match pc {
            0x82A1F6C8 => {
    //   block [0x82A1F6C8..0x82A1F7DC)
	// 82A1F6C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1F6CC: 48788AA1  bl 0x831a816c
	ctx.lr = 0x82A1F6D0;
	sub_831A8130(ctx, base);
	// 82A1F6D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1F6D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1F6D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1F6DC: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A1F6E0: 48734F21  bl 0x83154600
	ctx.lr = 0x82A1F6E4;
	sub_83154600(ctx, base);
	// 82A1F6E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1F6E8: 4BFF37D9  bl 0x82a12ec0
	ctx.lr = 0x82A1F6EC;
	sub_82A12EC0(ctx, base);
	// 82A1F6EC: 4BFFB05D  bl 0x82a1a748
	ctx.lr = 0x82A1F6F0;
	sub_82A1A748(ctx, base);
	// 82A1F6F0: 3BFF006C  addi r31, r31, 0x6c
	ctx.r[31].s64 = ctx.r[31].s64 + 108;
	// 82A1F6F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1F6F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F6FC: 409A00D8  bne cr6, 0x82a1f7d4
	if !ctx.cr[6].eq {
	pc = 0x82A1F7D4; continue 'dispatch;
	}
	// 82A1F700: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1F704: 4BFF37B5  bl 0x82a12eb8
	ctx.lr = 0x82A1F708;
	sub_82A12EB8(ctx, base);
	// 82A1F708: 4BDD0031  bl 0x827ef738
	ctx.lr = 0x82A1F70C;
	sub_827EF738(ctx, base);
	// 82A1F70C: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1F710: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1F714: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A1F718: 419A0024  beq cr6, 0x82a1f73c
	if ctx.cr[6].eq {
	pc = 0x82A1F73C; continue 'dispatch;
	}
	// 82A1F71C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82A1F720: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1F724: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1F728: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1F72C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A1F730: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1F734: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1F738: 4082FFE8  bne 0x82a1f720
	if !ctx.cr[0].eq {
	pc = 0x82A1F720; continue 'dispatch;
	}
	// 82A1F73C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1F740: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A1F744: 388BA360  addi r4, r11, -0x5ca0
	ctx.r[4].s64 = ctx.r[11].s64 + -23712;
	// 82A1F748: 38A0003B  li r5, 0x3b
	ctx.r[5].s64 = 59;
	// 82A1F74C: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82A1F750: 483D2C99  bl 0x82df23e8
	ctx.lr = 0x82A1F754;
	sub_82DF23E8(ctx, base);
	// 82A1F754: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A1F758: 41820018  beq 0x82a1f770
	if ctx.cr[0].eq {
	pc = 0x82A1F770; continue 'dispatch;
	}
	// 82A1F75C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A1F760: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 82A1F764: 483F398D  bl 0x82e130f0
	ctx.lr = 0x82A1F768;
	sub_82E130F0(ctx, base);
	// 82A1F768: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1F76C: 48000008  b 0x82a1f774
	pc = 0x82A1F774; continue 'dispatch;
	// 82A1F770: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A1F774: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1F778: 4B8C25D9  bl 0x822e1d50
	ctx.lr = 0x82A1F77C;
	sub_822E1D50(ctx, base);
	// 82A1F77C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A1F780: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1F784: 388B2DB8  addi r4, r11, 0x2db8
	ctx.r[4].s64 = ctx.r[11].s64 + 11704;
	// 82A1F788: 483D4281  bl 0x82df3a08
	ctx.lr = 0x82A1F78C;
	sub_82DF3A08(ctx, base);
	// 82A1F78C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A1F790: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1F794: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1F798: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1F79C: 483F5895  bl 0x82e15030
	ctx.lr = 0x82A1F7A0;
	sub_82E15030(ctx, base);
	// 82A1F7A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1F7A4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1F7A8: 483F3689  bl 0x82e12e30
	ctx.lr = 0x82A1F7AC;
	sub_82E12E30(ctx, base);
	// 82A1F7AC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A1F7B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1F7B4: 419A0008  beq cr6, 0x82a1f7bc
	if ctx.cr[6].eq {
	pc = 0x82A1F7BC; continue 'dispatch;
	}
	// 82A1F7B8: 4B8A10D9  bl 0x822c0890
	ctx.lr = 0x82A1F7BC;
	sub_822C0890(ctx, base);
	// 82A1F7BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1F7C0: 483D3C69  bl 0x82df3428
	ctx.lr = 0x82A1F7C4;
	sub_82DF3428(ctx, base);
	// 82A1F7C4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A1F7C8: 419A000C  beq cr6, 0x82a1f7d4
	if ctx.cr[6].eq {
	pc = 0x82A1F7D4; continue 'dispatch;
	}
	// 82A1F7CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A1F7D0: 4B8A10C1  bl 0x822c0890
	ctx.lr = 0x82A1F7D4;
	sub_822C0890(ctx, base);
	// 82A1F7D4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A1F7D8: 487889E4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1F7E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1F7E0 size=88
    let mut pc: u32 = 0x82A1F7E0;
    'dispatch: loop {
        match pc {
            0x82A1F7E0 => {
    //   block [0x82A1F7E0..0x82A1F838)
	// 82A1F7E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1F7E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1F7E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1F7EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1F7F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1F7F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1F7F8: 48734E09  bl 0x83154600
	ctx.lr = 0x82A1F7FC;
	sub_83154600(ctx, base);
	// 82A1F7FC: 4BFF36C5  bl 0x82a12ec0
	ctx.lr = 0x82A1F800;
	sub_82A12EC0(ctx, base);
	// 82A1F800: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A1F804: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1F808: 4BFFAFB1  bl 0x82a1a7b8
	ctx.lr = 0x82A1F80C;
	sub_82A1A7B8(ctx, base);
	// 82A1F80C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82A1F810: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1F814: 4BFFAFA5  bl 0x82a1a7b8
	ctx.lr = 0x82A1F818;
	sub_82A1A7B8(ctx, base);
	// 82A1F818: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A1F81C: 48126EAD  bl 0x82b466c8
	ctx.lr = 0x82A1F820;
	sub_82B466C8(ctx, base);
	// 82A1F820: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1F824: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1F828: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1F82C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1F830: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1F834: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1F838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1F838 size=124
    let mut pc: u32 = 0x82A1F838;
    'dispatch: loop {
        match pc {
            0x82A1F838 => {
    //   block [0x82A1F838..0x82A1F8B4)
	// 82A1F838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1F83C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1F840: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1F844: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1F848: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1F84C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A1F850: 419A004C  beq cr6, 0x82a1f89c
	if ctx.cr[6].eq {
	pc = 0x82A1F89C; continue 'dispatch;
	}
	// 82A1F854: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1F858: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1F85C: 419A0018  beq cr6, 0x82a1f874
	if ctx.cr[6].eq {
	pc = 0x82A1F874; continue 'dispatch;
	}
	// 82A1F860: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1F864: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1F868: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A1F86C: 4E800421  bctrl
	ctx.lr = 0x82A1F870;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1F870: 4800000C  b 0x82a1f87c
	pc = 0x82A1F87C; continue 'dispatch;
	// 82A1F874: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82A1F878: 386B869C  addi r3, r11, -0x7964
	ctx.r[3].s64 = ctx.r[11].s64 + -31076;
	// 82A1F87C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A1F880: 388B0C2C  addi r4, r11, 0xc2c
	ctx.r[4].s64 = ctx.r[11].s64 + 3116;
	// 82A1F884: 48788875  bl 0x831a80f8
	ctx.lr = 0x82A1F888;
	sub_831A80F8(ctx, base);
	// 82A1F888: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1F88C: 41820010  beq 0x82a1f89c
	if ctx.cr[0].eq {
	pc = 0x82A1F89C; continue 'dispatch;
	}
	// 82A1F890: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1F894: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82A1F898: 48000008  b 0x82a1f8a0
	pc = 0x82A1F8A0; continue 'dispatch;
	// 82A1F89C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A1F8A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A1F8A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1F8A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1F8AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1F8B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1F8B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A1F8B8 size=12
    let mut pc: u32 = 0x82A1F8B8;
    'dispatch: loop {
        match pc {
            0x82A1F8B8 => {
    //   block [0x82A1F8B8..0x82A1F8C4)
	// 82A1F8B8: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82A1F8BC: 386B7624  addi r3, r11, 0x7624
	ctx.r[3].s64 = ctx.r[11].s64 + 30244;
	// 82A1F8C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1F8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1F8C8 size=100
    let mut pc: u32 = 0x82A1F8C8;
    'dispatch: loop {
        match pc {
            0x82A1F8C8 => {
    //   block [0x82A1F8C8..0x82A1F92C)
	// 82A1F8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1F8CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1F8D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1F8D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1F8D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1F8DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1F8E0: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82A1F8E4: 4B8A1055  bl 0x822c0938
	ctx.lr = 0x82A1F8E8;
	sub_822C0938(ctx, base);
	// 82A1F8E8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A1F8EC: 41820024  beq 0x82a1f910
	if ctx.cr[0].eq {
	pc = 0x82A1F910; continue 'dispatch;
	}
	// 82A1F8F0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1F8F4: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 82A1F8F8: 396BA3D0  addi r11, r11, -0x5c30
	ctx.r[11].s64 = ctx.r[11].s64 + -23600;
	// 82A1F8FC: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82A1F900: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A1F904: 483D42FD  bl 0x82df3c00
	ctx.lr = 0x82A1F908;
	sub_82DF3C00(ctx, base);
	// 82A1F908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1F90C: 48000008  b 0x82a1f914
	pc = 0x82A1F914; continue 'dispatch;
	// 82A1F910: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A1F914: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1F918: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1F91C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1F920: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1F924: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1F928: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1F930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1F930 size=96
    let mut pc: u32 = 0x82A1F930;
    'dispatch: loop {
        match pc {
            0x82A1F930 => {
    //   block [0x82A1F930..0x82A1F990)
	// 82A1F930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1F934: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1F938: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1F93C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1F940: 4BFFFEF9  bl 0x82a1f838
	ctx.lr = 0x82A1F944;
	sub_82A1F838(ctx, base);
	// 82A1F944: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A1F948: 40820030  bne 0x82a1f978
	if !ctx.cr[0].eq {
	pc = 0x82A1F978; continue 'dispatch;
	}
	// 82A1F94C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A1F950: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A1F954: 396B94B4  addi r11, r11, -0x6b4c
	ctx.r[11].s64 = ctx.r[11].s64 + -27468;
	// 82A1F958: 394A1014  addi r10, r10, 0x1014
	ctx.r[10].s64 = ctx.r[10].s64 + 4116;
	// 82A1F95C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A1F960: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1F964: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A1F968: 4B8A0699  bl 0x822c0000
	ctx.lr = 0x82A1F96C;
	sub_822C0000(ctx, base);
	// 82A1F96C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1F970: 396B0818  addi r11, r11, 0x818
	ctx.r[11].s64 = ctx.r[11].s64 + 2072;
	// 82A1F974: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A1F978: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1F97C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1F980: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1F984: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1F988: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1F98C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1F990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1F990 size=84
    let mut pc: u32 = 0x82A1F990;
    'dispatch: loop {
        match pc {
            0x82A1F990 => {
    //   block [0x82A1F990..0x82A1F9E4)
	// 82A1F990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1F994: 487887D9  bl 0x831a816c
	ctx.lr = 0x82A1F998;
	sub_831A8130(ctx, base);
	// 82A1F998: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1F99C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A1F9A0: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82A1F9A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1F9A8: 4B8A0F91  bl 0x822c0938
	ctx.lr = 0x82A1F9AC;
	sub_822C0938(ctx, base);
	// 82A1F9AC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A1F9B0: 41820020  beq 0x82a1f9d0
	if ctx.cr[0].eq {
	pc = 0x82A1F9D0; continue 'dispatch;
	}
	// 82A1F9B4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1F9B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1F9BC: 396BA3D0  addi r11, r11, -0x5c30
	ctx.r[11].s64 = ctx.r[11].s64 + -23600;
	// 82A1F9C0: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82A1F9C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A1F9C8: 483D4239  bl 0x82df3c00
	ctx.lr = 0x82A1F9CC;
	sub_82DF3C00(ctx, base);
	// 82A1F9CC: 48000008  b 0x82a1f9d4
	pc = 0x82A1F9D4; continue 'dispatch;
	// 82A1F9D0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A1F9D4: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A1F9D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A1F9DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1F9E0: 487887DC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1F9E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1F9E8 size=92
    let mut pc: u32 = 0x82A1F9E8;
    'dispatch: loop {
        match pc {
            0x82A1F9E8 => {
    //   block [0x82A1F9E8..0x82A1FA44)
	// 82A1F9E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1F9EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1F9F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1F9F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1F9F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1F9FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1FA00: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1FA04: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82A1FA08: 483D3A21  bl 0x82df3428
	ctx.lr = 0x82A1FA0C;
	sub_82DF3428(ctx, base);
	// 82A1FA0C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A1FA10: 57CA07FF  clrlwi. r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A1FA14: 396BD82C  addi r11, r11, -0x27d4
	ctx.r[11].s64 = ctx.r[11].s64 + -10196;
	// 82A1FA18: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A1FA1C: 4182000C  beq 0x82a1fa28
	if ctx.cr[0].eq {
	pc = 0x82A1FA28; continue 'dispatch;
	}
	// 82A1FA20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1FA24: 4B8A0845  bl 0x822c0268
	ctx.lr = 0x82A1FA28;
	sub_822C0268(ctx, base);
	// 82A1FA28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1FA2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1FA30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1FA34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1FA38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1FA3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1FA40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1FA48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A1FA48 size=152
    let mut pc: u32 = 0x82A1FA48;
    'dispatch: loop {
        match pc {
            0x82A1FA48 => {
    //   block [0x82A1FA48..0x82A1FAE0)
	// 82A1FA48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1FA4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1FA50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1FA54: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1FA58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1FA5C: 4BFFE6ED  bl 0x82a1e148
	ctx.lr = 0x82A1FA60;
	sub_82A1E148(ctx, base);
	// 82A1FA60: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A1FA64: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A1FA68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1FA6C: 3929A3E0  addi r9, r9, -0x5c20
	ctx.r[9].s64 = ctx.r[9].s64 + -23584;
	// 82A1FA70: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 82A1FA74: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A1FA78: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A1FA7C: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1FA80: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A1FA84: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A1FA88: 911F006C  stw r8, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[8].u32 ) };
	// 82A1FA8C: 3D408207  lis r10, -0x7df9
	ctx.r[10].s64 = -2113470464;
	// 82A1FA90: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A1FA94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1FA98: 98FF0074  stb r7, 0x74(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[7].u8 ) };
	// 82A1FA9C: 388A05D0  addi r4, r10, 0x5d0
	ctx.r[4].s64 = ctx.r[10].s64 + 1488;
	// 82A1FAA0: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82A1FAA4: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82A1FAA8: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82A1FAAC: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82A1FAB0: 483D3F59  bl 0x82df3a08
	ctx.lr = 0x82A1FAB4;
	sub_82DF3A08(ctx, base);
	// 82A1FAB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1FAB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A1FABC: 48439C2D  bl 0x82e596e8
	ctx.lr = 0x82A1FAC0;
	sub_82E596E8(ctx, base);
	// 82A1FAC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1FAC4: 483D3965  bl 0x82df3428
	ctx.lr = 0x82A1FAC8;
	sub_82DF3428(ctx, base);
	// 82A1FAC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1FACC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1FAD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1FAD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1FAD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1FADC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1FAE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1FAE0 size=80
    let mut pc: u32 = 0x82A1FAE0;
    'dispatch: loop {
        match pc {
            0x82A1FAE0 => {
    //   block [0x82A1FAE0..0x82A1FB30)
	// 82A1FAE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1FAE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1FAE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1FAEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1FAF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1FAF4: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A1FAF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1FAFC: 419A0008  beq cr6, 0x82a1fb04
	if ctx.cr[6].eq {
	pc = 0x82A1FB04; continue 'dispatch;
	}
	// 82A1FB00: 4B8A0D91  bl 0x822c0890
	ctx.lr = 0x82A1FB04;
	sub_822C0890(ctx, base);
	// 82A1FB04: 807F007C  lwz r3, 0x7c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A1FB08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1FB0C: 419A0008  beq cr6, 0x82a1fb14
	if ctx.cr[6].eq {
	pc = 0x82A1FB14; continue 'dispatch;
	}
	// 82A1FB10: 4B8A0D81  bl 0x822c0890
	ctx.lr = 0x82A1FB14;
	sub_822C0890(ctx, base);
	// 82A1FB14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1FB18: 4843CA71  bl 0x82e5c588
	ctx.lr = 0x82A1FB1C;
	sub_82E5C588(ctx, base);
	// 82A1FB1C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A1FB20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1FB24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1FB28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1FB2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1FB30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1FB30 size=76
    let mut pc: u32 = 0x82A1FB30;
    'dispatch: loop {
        match pc {
            0x82A1FB30 => {
    //   block [0x82A1FB30..0x82A1FB7C)
	// 82A1FB30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1FB34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1FB38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1FB3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1FB40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1FB44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1FB48: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1FB4C: 4BFFFF95  bl 0x82a1fae0
	ctx.lr = 0x82A1FB50;
	sub_82A1FAE0(ctx, base);
	// 82A1FB50: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1FB54: 4182000C  beq 0x82a1fb60
	if ctx.cr[0].eq {
	pc = 0x82A1FB60; continue 'dispatch;
	}
	// 82A1FB58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1FB5C: 483D287D  bl 0x82df23d8
	ctx.lr = 0x82A1FB60;
	sub_82DF23D8(ctx, base);
	// 82A1FB60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1FB64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1FB68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1FB6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1FB70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1FB74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1FB78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1FB80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1FB80 size=100
    let mut pc: u32 = 0x82A1FB80;
    'dispatch: loop {
        match pc {
            0x82A1FB80 => {
    //   block [0x82A1FB80..0x82A1FBE4)
	// 82A1FB80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1FB84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1FB88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1FB8C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1FB90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1FB94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1FB98: 4BFFFDF9  bl 0x82a1f990
	ctx.lr = 0x82A1FB9C;
	sub_82A1F990(ctx, base);
	// 82A1FB9C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1FBA0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1FBA4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A1FBA8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A1FBAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1FBB0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1FBB4: 419A0018  beq cr6, 0x82a1fbcc
	if ctx.cr[6].eq {
	pc = 0x82A1FBCC; continue 'dispatch;
	}
	// 82A1FBB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1FBBC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A1FBC0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1FBC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A1FBC8: 4E800421  bctrl
	ctx.lr = 0x82A1FBCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1FBCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1FBD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1FBD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1FBD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1FBDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1FBE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1FBE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1FBE8 size=172
    let mut pc: u32 = 0x82A1FBE8;
    'dispatch: loop {
        match pc {
            0x82A1FBE8 => {
    //   block [0x82A1FBE8..0x82A1FC94)
	// 82A1FBE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1FBEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1FBF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1FBF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1FBF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1FBFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1FC00: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A1FC04: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82A1FC08: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 82A1FC0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1FC10: 4BA726F9  bl 0x82492308
	ctx.lr = 0x82A1FC14;
	sub_82492308(ctx, base);
	// 82A1FC14: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A1FC18: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82A1FC1C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A1FC20: 419A0058  beq cr6, 0x82a1fc78
	if ctx.cr[6].eq {
	pc = 0x82A1FC78; continue 'dispatch;
	}
	// 82A1FC24: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1FC28: 3BEB0010  addi r31, r11, 0x10
	ctx.r[31].s64 = ctx.r[11].s64 + 16;
	// 82A1FC2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1FC30: 419A0018  beq cr6, 0x82a1fc48
	if ctx.cr[6].eq {
	pc = 0x82A1FC48; continue 'dispatch;
	}
	// 82A1FC34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1FC38: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1FC3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A1FC40: 4E800421  bctrl
	ctx.lr = 0x82A1FC44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1FC44: 4800000C  b 0x82a1fc50
	pc = 0x82A1FC50; continue 'dispatch;
	// 82A1FC48: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82A1FC4C: 386B869C  addi r3, r11, -0x7964
	ctx.r[3].s64 = ctx.r[11].s64 + -31076;
	// 82A1FC50: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A1FC54: 388B0C2C  addi r4, r11, 0xc2c
	ctx.r[4].s64 = ctx.r[11].s64 + 3116;
	// 82A1FC58: 487884A1  bl 0x831a80f8
	ctx.lr = 0x82A1FC5C;
	sub_831A80F8(ctx, base);
	// 82A1FC5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1FC60: 41820018  beq 0x82a1fc78
	if ctx.cr[0].eq {
	pc = 0x82A1FC78; continue 'dispatch;
	}
	// 82A1FC64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1FC68: 4BFFFCC9  bl 0x82a1f930
	ctx.lr = 0x82A1FC6C;
	sub_82A1F930(ctx, base);
	// 82A1FC6C: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82A1FC70: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A1FC74: 48000008  b 0x82a1fc7c
	pc = 0x82A1FC7C; continue 'dispatch;
	// 82A1FC78: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A1FC7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1FC80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1FC84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1FC88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1FC8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1FC90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1FC98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A1FC98 size=1616
    let mut pc: u32 = 0x82A1FC98;
    'dispatch: loop {
        match pc {
            0x82A1FC98 => {
    //   block [0x82A1FC98..0x82A202E8)
	// 82A1FC98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1FC9C: 487884C1  bl 0x831a815c
	ctx.lr = 0x82A1FCA0;
	sub_831A8130(ctx, base);
	// 82A1FCA0: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82A1FCA4: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1FCA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1FCAC: 48734955  bl 0x83154600
	ctx.lr = 0x82A1FCB0;
	sub_83154600(ctx, base);
	// 82A1FCB0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1FCB4: 4BFF3205  bl 0x82a12eb8
	ctx.lr = 0x82A1FCB8;
	sub_82A12EB8(ctx, base);
	// 82A1FCB8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A1FCBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1FCC0: 4BFF3201  bl 0x82a12ec0
	ctx.lr = 0x82A1FCC4;
	sub_82A12EC0(ctx, base);
	// 82A1FCC4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82A1FCC8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A1FCCC: 4800DFA5  bl 0x82a2dc70
	ctx.lr = 0x82A1FCD0;
	sub_82A2DC70(ctx, base);
	// 82A1FCD0: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1FCD4: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A1FCD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1FCDC: 48439A9D  bl 0x82e59778
	ctx.lr = 0x82A1FCE0;
	sub_82E59778(ctx, base);
	// 82A1FCE0: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1FCE4: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A1FCE8: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A1FCEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1FCF0: 4BE3E101  bl 0x8285ddf0
	ctx.lr = 0x82A1FCF4;
	sub_8285DDF0(ctx, base);
	// 82A1FCF4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1FCF8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82A1FCFC: 41820008  beq 0x82a1fd04
	if ctx.cr[0].eq {
	pc = 0x82A1FD04; continue 'dispatch;
	}
	// 82A1FD00: 9BBF0074  stb r29, 0x74(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[29].u8 ) };
	// 82A1FD04: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A1FD08: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A1FD0C: 41980500  blt cr6, 0x82a2020c
	if ctx.cr[6].lt {
	pc = 0x82A2020C; continue 'dispatch;
	}
	// 82A1FD10: 419A0330  beq cr6, 0x82a20040
	if ctx.cr[6].eq {
	pc = 0x82A20040; continue 'dispatch;
	}
	// 82A1FD14: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A1FD18: 4198012C  blt cr6, 0x82a1fe44
	if ctx.cr[6].lt {
	pc = 0x82A1FE44; continue 'dispatch;
	}
	// 82A1FD1C: 409A05B0  bne cr6, 0x82a202cc
	if !ctx.cr[6].eq {
	pc = 0x82A202CC; continue 'dispatch;
	}
	// 82A1FD20: 897F0074  lbz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A1FD24: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A1FD28: 4182003C  beq 0x82a1fd64
	if ctx.cr[0].eq {
	pc = 0x82A1FD64; continue 'dispatch;
	}
	// 82A1FD2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1FD30: 4BFF6FD9  bl 0x82a16d08
	ctx.lr = 0x82A1FD34;
	sub_82A16D08(ctx, base);
	// 82A1FD34: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1FD38: 4082002C  bne 0x82a1fd64
	if !ctx.cr[0].eq {
	pc = 0x82A1FD64; continue 'dispatch;
	}
	// 82A1FD3C: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A1FD40: 4800D0E1  bl 0x82a2ce20
	ctx.lr = 0x82A1FD44;
	sub_82A2CE20(ctx, base);
	// 82A1FD44: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1FD48: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1FD4C: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A1FD50: 396BA3A8  addi r11, r11, -0x5c58
	ctx.r[11].s64 = ctx.r[11].s64 + -23640;
	// 82A1FD54: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82A1FD58: 7DAA5C2E  lfsx f13, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A1FD5C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A1FD60: 4199056C  bgt cr6, 0x82a202cc
	if ctx.cr[6].gt {
	pc = 0x82A202CC; continue 'dispatch;
	}
	// 82A1FD64: 897F0074  lbz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A1FD68: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A1FD6C: 418200C0  beq 0x82a1fe2c
	if ctx.cr[0].eq {
	pc = 0x82A1FE2C; continue 'dispatch;
	}
	// 82A1FD70: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A1FD74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1FD78: 388B893C  addi r4, r11, -0x76c4
	ctx.r[4].s64 = ctx.r[11].s64 + -30404;
	// 82A1FD7C: 483D3C8D  bl 0x82df3a08
	ctx.lr = 0x82A1FD80;
	sub_82DF3A08(ctx, base);
	// 82A1FD80: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1FD84: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A1FD88: 388BA46C  addi r4, r11, -0x5b94
	ctx.r[4].s64 = ctx.r[11].s64 + -23444;
	// 82A1FD8C: 483D3C7D  bl 0x82df3a08
	ctx.lr = 0x82A1FD90;
	sub_82DF3A08(ctx, base);
	// 82A1FD90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1FD94: 485E8395  bl 0x83008128
	ctx.lr = 0x82A1FD98;
	sub_83008128(ctx, base);
	// 82A1FD98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1FD9C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A1FDA0: 4843A781  bl 0x82e5a520
	ctx.lr = 0x82A1FDA4;
	sub_82E5A520(ctx, base);
	// 82A1FDA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1FDA8: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82A1FDAC: 386B0038  addi r3, r11, 0x38
	ctx.r[3].s64 = ctx.r[11].s64 + 56;
	// 82A1FDB0: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82A1FDB4: 4B90CA8D  bl 0x8232c840
	ctx.lr = 0x82A1FDB8;
	sub_8232C840(ctx, base);
	// 82A1FDB8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1FDBC: 4BFFFDC5  bl 0x82a1fb80
	ctx.lr = 0x82A1FDC0;
	sub_82A1FB80(ctx, base);
	// 82A1FDC0: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A1FDC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1FDC8: 419A0008  beq cr6, 0x82a1fdd0
	if ctx.cr[6].eq {
	pc = 0x82A1FDD0; continue 'dispatch;
	}
	// 82A1FDCC: 4B8A0AC5  bl 0x822c0890
	ctx.lr = 0x82A1FDD0;
	sub_822C0890(ctx, base);
	// 82A1FDD0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A1FDD4: 483D3655  bl 0x82df3428
	ctx.lr = 0x82A1FDD8;
	sub_82DF3428(ctx, base);
	// 82A1FDD8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A1FDDC: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82A1FDE0: 388B836C  addi r4, r11, -0x7c94
	ctx.r[4].s64 = ctx.r[11].s64 + -31892;
	// 82A1FDE4: 483D3C25  bl 0x82df3a08
	ctx.lr = 0x82A1FDE8;
	sub_82DF3A08(ctx, base);
	// 82A1FDE8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1FDEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1FDF0: 485E8339  bl 0x83008128
	ctx.lr = 0x82A1FDF4;
	sub_83008128(ctx, base);
	// 82A1FDF4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1FDF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1FDFC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A1FE00: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A1FE04: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A1FE08: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A1FE0C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A1FE10: 4843EB51  bl 0x82e5e960
	ctx.lr = 0x82A1FE14;
	sub_82E5E960(ctx, base);
	// 82A1FE14: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A1FE18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1FE1C: 419A0008  beq cr6, 0x82a1fe24
	if ctx.cr[6].eq {
	pc = 0x82A1FE24; continue 'dispatch;
	}
	// 82A1FE20: 4B8A0A71  bl 0x822c0890
	ctx.lr = 0x82A1FE24;
	sub_822C0890(ctx, base);
	// 82A1FE24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1FE28: 480003DC  b 0x82a20204
	pc = 0x82A20204; continue 'dispatch;
	// 82A1FE2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1FE30: 4BDCC3A9  bl 0x827ec1d8
	ctx.lr = 0x82A1FE34;
	sub_827EC1D8(ctx, base);
	// 82A1FE34: 80BF0070  lwz r5, 0x70(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A1FE38: 809F006C  lwz r4, 0x6c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A1FE3C: 4BFFDCB5  bl 0x82a1daf0
	ctx.lr = 0x82A1FE40;
	sub_82A1DAF0(ctx, base);
	// 82A1FE40: 4800048C  b 0x82a202cc
	pc = 0x82A202CC; continue 'dispatch;
	// 82A1FE44: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1FE48: C1BF0068  lfs f13, 0x68(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A1FE4C: C00B9E34  lfs f0, -0x61cc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25036 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1FE50: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A1FE54: 40980180  bge cr6, 0x82a1ffd4
	if !ctx.cr[6].lt {
	pc = 0x82A1FFD4; continue 'dispatch;
	}
	// 82A1FE58: C1BF0060  lfs f13, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A1FE5C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A1FE60: 41990174  bgt cr6, 0x82a1ffd4
	if ctx.cr[6].gt {
	pc = 0x82A1FFD4; continue 'dispatch;
	}
	// 82A1FE64: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A1FE68: 4BDCF8D1  bl 0x827ef738
	ctx.lr = 0x82A1FE6C;
	sub_827EF738(ctx, base);
	// 82A1FE6C: 83430004  lwz r26, 4(r3)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1FE70: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1FE74: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82A1FE78: 419A0024  beq cr6, 0x82a1fe9c
	if ctx.cr[6].eq {
	pc = 0x82A1FE9C; continue 'dispatch;
	}
	// 82A1FE7C: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 82A1FE80: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1FE84: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1FE88: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1FE8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A1FE90: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1FE94: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1FE98: 4082FFE8  bne 0x82a1fe80
	if !ctx.cr[0].eq {
	pc = 0x82A1FE80; continue 'dispatch;
	}
	// 82A1FE9C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1FEA0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1FEA4: 388B97CC  addi r4, r11, -0x6834
	ctx.r[4].s64 = ctx.r[11].s64 + -26676;
	// 82A1FEA8: 483D3B61  bl 0x82df3a08
	ctx.lr = 0x82A1FEAC;
	sub_82DF3A08(ctx, base);
	// 82A1FEAC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A1FEB0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A1FEB4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A1FEB8: 483F5179  bl 0x82e15030
	ctx.lr = 0x82A1FEBC;
	sub_82E15030(ctx, base);
	// 82A1FEBC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1FEC0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1FEC4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1FEC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A1FECC: 4E800421  bctrl
	ctx.lr = 0x82A1FED0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1FED0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A1FED4: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A1FED8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1FEDC: C00B003C  lfs f0, 0x3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1FEE0: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A1FEE4: C18B0034  lfs f12, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A1FEE8: C16B0030  lfs f11, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A1FEEC: D1610070  stfs f11, 0x70(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82A1FEF0: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82A1FEF4: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82A1FEF8: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82A1FEFC: 419A0008  beq cr6, 0x82a1ff04
	if ctx.cr[6].eq {
	pc = 0x82A1FF04; continue 'dispatch;
	}
	// 82A1FF00: 4B8A0991  bl 0x822c0890
	ctx.lr = 0x82A1FF04;
	sub_822C0890(ctx, base);
	// 82A1FF04: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1FF08: 483D3521  bl 0x82df3428
	ctx.lr = 0x82A1FF0C;
	sub_82DF3428(ctx, base);
	// 82A1FF0C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1FF10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1FF14: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82A1FF18: C00BA3A8  lfs f0, -0x5c58(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23640 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1FF1C: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82A1FF20: 83610068  lwz r27, 0x68(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A1FF24: 4BAEF5A5  bl 0x8250f4c8
	ctx.lr = 0x82A1FF28;
	sub_8250F4C8(ctx, base);
	// 82A1FF28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1FF2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1FF30: 3BABFFFC  addi r29, r11, -4
	ctx.r[29].s64 = ctx.r[11].s64 + -4;
	// 82A1FF34: 409A0008  bne cr6, 0x82a1ff3c
	if !ctx.cr[6].eq {
	pc = 0x82A1FF3C; continue 'dispatch;
	}
	// 82A1FF38: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A1FF3C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A1FF40: 4800CEE1  bl 0x82a2ce20
	ctx.lr = 0x82A1FF44;
	sub_82A2CE20(ctx, base);
	// 82A1FF44: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A1FF48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1FF4C: 4BFF3735  bl 0x82a13680
	ctx.lr = 0x82A1FF50;
	sub_82A13680(ctx, base);
	// 82A1FF50: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A1FF54: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A1FF58: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82A1FF5C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A1FF60: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A1FF64: 4800FC85  bl 0x82a2fbe8
	ctx.lr = 0x82A1FF68;
	sub_82A2FBE8(ctx, base);
	// 82A1FF68: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A1FF6C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1FF70: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82A1FF74: 4BAEF5A5  bl 0x8250f518
	ctx.lr = 0x82A1FF78;
	sub_8250F518(ctx, base);
	// 82A1FF78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1FF7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A1FF80: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A1FF84: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A1FF88: 4BAED581  bl 0x8250d508
	ctx.lr = 0x82A1FF8C;
	sub_8250D508(ctx, base);
	// 82A1FF8C: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82A1FF90: 483D1D01  bl 0x82df1c90
	ctx.lr = 0x82A1FF94;
	sub_82DF1C90(ctx, base);
	// 82A1FF94: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82A1FF98: 483D1CF9  bl 0x82df1c90
	ctx.lr = 0x82A1FF9C;
	sub_82DF1C90(ctx, base);
	// 82A1FF9C: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82A1FFA0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1FFA4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A1FFA8: 388BA454  addi r4, r11, -0x5bac
	ctx.r[4].s64 = ctx.r[11].s64 + -23468;
	// 82A1FFAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1FFB0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1FFB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A1FFB8: 4E800421  bctrl
	ctx.lr = 0x82A1FFBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1FFBC: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A1FFC0: 48126709  bl 0x82b466c8
	ctx.lr = 0x82A1FFC4;
	sub_82B466C8(ctx, base);
	// 82A1FFC4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82A1FFC8: 419A000C  beq cr6, 0x82a1ffd4
	if ctx.cr[6].eq {
	pc = 0x82A1FFD4; continue 'dispatch;
	}
	// 82A1FFCC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A1FFD0: 4B8A08C1  bl 0x822c0890
	ctx.lr = 0x82A1FFD4;
	sub_822C0890(ctx, base);
	// 82A1FFD4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A1FFD8: 4BDD4409  bl 0x827f43e0
	ctx.lr = 0x82A1FFDC;
	sub_827F43E0(ctx, base);
	// 82A1FFDC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1FFE0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1FFE4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1FFE8: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A1FFEC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A1FFF0: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A1FFF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A1FFF8: 4E800421  bctrl
	ctx.lr = 0x82A1FFFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1FFFC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A20000: 418202CC  beq 0x82a202cc
	if ctx.cr[0].eq {
	pc = 0x82A202CC; continue 'dispatch;
	}
	// 82A20004: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A20008: 38800022  li r4, 0x22
	ctx.r[4].s64 = 34;
	// 82A2000C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A20010: C02B9EFC  lfs f1, -0x6104(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24836 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A20014: 4BFF9555  bl 0x82a19568
	ctx.lr = 0x82A20018;
	sub_82A19568(ctx, base);
	// 82A20018: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82A2001C: D3FF0060  stfs f31, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A20020: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A20024: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A20028: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A2002C: 4BFFA78D  bl 0x82a1a7b8
	ctx.lr = 0x82A20030;
	sub_82A1A7B8(ctx, base);
	// 82A20030: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82A20034: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A20038: 4BFFA781  bl 0x82a1a7b8
	ctx.lr = 0x82A2003C;
	sub_82A1A7B8(ctx, base);
	// 82A2003C: 48000290  b 0x82a202cc
	pc = 0x82A202CC; continue 'dispatch;
	// 82A20040: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A20044: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82A20048: 4BFF9D19  bl 0x82a19d60
	ctx.lr = 0x82A2004C;
	sub_82A19D60(ctx, base);
	// 82A2004C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A20050: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A20054: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82A20058: 4BFF9579  bl 0x82a195d0
	ctx.lr = 0x82A2005C;
	sub_82A195D0(ctx, base);
	// 82A2005C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A20060: 4BFF3629  bl 0x82a13688
	ctx.lr = 0x82A20064;
	sub_82A13688(ctx, base);
	// 82A20064: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A20068: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A2006C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82A20070: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 82A20074: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82A20078: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A2007C: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82A20080: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A20084: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82A20088: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A2008C: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82A20090: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A20094: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82A20098: C02A02BC  lfs f1, 0x2bc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(700 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A2009C: 4845D22D  bl 0x82e7d2c8
	ctx.lr = 0x82A200A0;
	sub_82E7D2C8(ctx, base);
	// 82A200A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A200A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A200A8: 4808B431  bl 0x82aab4d8
	ctx.lr = 0x82A200AC;
	sub_82AAB4D8(ctx, base);
	// 82A200AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A200B0: 4BDD4331  bl 0x827f43e0
	ctx.lr = 0x82A200B4;
	sub_827F43E0(ctx, base);
	// 82A200B4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A200B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A200BC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A200C0: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A200C4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A200C8: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A200CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A200D0: 4E800421  bctrl
	ctx.lr = 0x82A200D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A200D4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A200D8: 41820068  beq 0x82a20140
	if ctx.cr[0].eq {
	pc = 0x82A20140; continue 'dispatch;
	}
	// 82A200DC: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82A200E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A200E4: 4BFF9825  bl 0x82a19908
	ctx.lr = 0x82A200E8;
	sub_82A19908(ctx, base);
	// 82A200E8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A200EC: 4BFF900D  bl 0x82a190f8
	ctx.lr = 0x82A200F0;
	sub_82A190F8(ctx, base);
	// 82A200F0: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A200F4: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A200F8: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A200FC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A20100: 4BFFA6D1  bl 0x82a1a7d0
	ctx.lr = 0x82A20104;
	sub_82A1A7D0(ctx, base);
	// 82A20104: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82A20108: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A2010C: 4BFFA6C5  bl 0x82a1a7d0
	ctx.lr = 0x82A20110;
	sub_82A1A7D0(ctx, base);
	// 82A20110: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A20114: 4BFF2EA5  bl 0x82a12fb8
	ctx.lr = 0x82A20118;
	sub_82A12FB8(ctx, base);
	// 82A20118: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82A2011C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A20120: D3FF0060  stfs f31, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A20124: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A20128: 388BA440  addi r4, r11, -0x5bc0
	ctx.r[4].s64 = ctx.r[11].s64 + -23488;
	// 82A2012C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20130: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A20134: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A20138: 4E800421  bctrl
	ctx.lr = 0x82A2013C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A2013C: 48000190  b 0x82a202cc
	pc = 0x82A202CC; continue 'dispatch;
	// 82A20140: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A20144: 4BFF6BC5  bl 0x82a16d08
	ctx.lr = 0x82A20148;
	sub_82A16D08(ctx, base);
	// 82A20148: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2014C: 41820180  beq 0x82a202cc
	if ctx.cr[0].eq {
	pc = 0x82A202CC; continue 'dispatch;
	}
	// 82A20150: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82A20154: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A20158: 388B05D0  addi r4, r11, 0x5d0
	ctx.r[4].s64 = ctx.r[11].s64 + 1488;
	// 82A2015C: 483D38AD  bl 0x82df3a08
	ctx.lr = 0x82A20160;
	sub_82DF3A08(ctx, base);
	// 82A20160: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A20164: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A20168: 388BA46C  addi r4, r11, -0x5b94
	ctx.r[4].s64 = ctx.r[11].s64 + -23444;
	// 82A2016C: 483D389D  bl 0x82df3a08
	ctx.lr = 0x82A20170;
	sub_82DF3A08(ctx, base);
	// 82A20170: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A20174: 485E7FB5  bl 0x83008128
	ctx.lr = 0x82A20178;
	sub_83008128(ctx, base);
	// 82A20178: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A2017C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82A20180: 4843A3A1  bl 0x82e5a520
	ctx.lr = 0x82A20184;
	sub_82E5A520(ctx, base);
	// 82A20184: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20188: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A2018C: 386B0038  addi r3, r11, 0x38
	ctx.r[3].s64 = ctx.r[11].s64 + 56;
	// 82A20190: 3BC10054  addi r30, r1, 0x54
	ctx.r[30].s64 = ctx.r[1].s64 + 84;
	// 82A20194: 4B90C6AD  bl 0x8232c840
	ctx.lr = 0x82A20198;
	sub_8232C840(ctx, base);
	// 82A20198: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A2019C: 4BFFF9E5  bl 0x82a1fb80
	ctx.lr = 0x82A201A0;
	sub_82A1FB80(ctx, base);
	// 82A201A0: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A201A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A201A8: 419A0008  beq cr6, 0x82a201b0
	if ctx.cr[6].eq {
	pc = 0x82A201B0; continue 'dispatch;
	}
	// 82A201AC: 4B8A06E5  bl 0x822c0890
	ctx.lr = 0x82A201B0;
	sub_822C0890(ctx, base);
	// 82A201B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A201B4: 483D3275  bl 0x82df3428
	ctx.lr = 0x82A201B8;
	sub_82DF3428(ctx, base);
	// 82A201B8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A201BC: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A201C0: 388B836C  addi r4, r11, -0x7c94
	ctx.r[4].s64 = ctx.r[11].s64 + -31892;
	// 82A201C4: 483D3845  bl 0x82df3a08
	ctx.lr = 0x82A201C8;
	sub_82DF3A08(ctx, base);
	// 82A201C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A201CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A201D0: 485E7F59  bl 0x83008128
	ctx.lr = 0x82A201D4;
	sub_83008128(ctx, base);
	// 82A201D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A201D8: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A201DC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A201E0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A201E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A201E8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A201EC: 4843E775  bl 0x82e5e960
	ctx.lr = 0x82A201F0;
	sub_82E5E960(ctx, base);
	// 82A201F0: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A201F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A201F8: 419A0008  beq cr6, 0x82a20200
	if ctx.cr[6].eq {
	pc = 0x82A20200; continue 'dispatch;
	}
	// 82A201FC: 4B8A0695  bl 0x822c0890
	ctx.lr = 0x82A20200;
	sub_822C0890(ctx, base);
	// 82A20200: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A20204: 483D3225  bl 0x82df3428
	ctx.lr = 0x82A20208;
	sub_82DF3428(ctx, base);
	// 82A20208: 480000C4  b 0x82a202cc
	pc = 0x82A202CC; continue 'dispatch;
	// 82A2020C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A20210: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 82A20214: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A20218: C02B9EFC  lfs f1, -0x6104(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24836 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A2021C: 4BFF934D  bl 0x82a19568
	ctx.lr = 0x82A20220;
	sub_82A19568(ctx, base);
	// 82A20220: 897F0074  lbz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A20224: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A20228: 41820028  beq 0x82a20250
	if ctx.cr[0].eq {
	pc = 0x82A20250; continue 'dispatch;
	}
	// 82A2022C: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A20230: 4800CBF1  bl 0x82a2ce20
	ctx.lr = 0x82A20234;
	sub_82A2CE20(ctx, base);
	// 82A20234: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A20238: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A2023C: 396BA3A8  addi r11, r11, -0x5c58
	ctx.r[11].s64 = ctx.r[11].s64 + -23640;
	// 82A20240: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A20244: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A20248: 7C2A5C2E  lfsx f1, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A2024C: 4BFF8E2D  bl 0x82a19078
	ctx.lr = 0x82A20250;
	sub_82A19078(ctx, base);
	// 82A20250: 93BF0064  stw r29, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82A20254: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A20258: 4BFF2D41  bl 0x82a12f98
	ctx.lr = 0x82A2025C;
	sub_82A12F98(ctx, base);
	// 82A2025C: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82A20260: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A20264: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A20268: 388BA428  addi r4, r11, -0x5bd8
	ctx.r[4].s64 = ctx.r[11].s64 + -23512;
	// 82A2026C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20270: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A20274: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A20278: 4E800421  bctrl
	ctx.lr = 0x82A2027C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A2027C: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A20280: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A20284: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A20288: 388BA414  addi r4, r11, -0x5bec
	ctx.r[4].s64 = ctx.r[11].s64 + -23532;
	// 82A2028C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20290: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A20294: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A20298: 4E800421  bctrl
	ctx.lr = 0x82A2029C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A2029C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A202A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A202A4: 38ABA404  addi r5, r11, -0x5bfc
	ctx.r[5].s64 = ctx.r[11].s64 + -23548;
	// 82A202A8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A202AC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A202B0: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A202B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A202B8: 4E800421  bctrl
	ctx.lr = 0x82A202BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A202BC: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82A202C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A202C4: 419A0008  beq cr6, 0x82a202cc
	if ctx.cr[6].eq {
	pc = 0x82A202CC; continue 'dispatch;
	}
	// 82A202C8: 4B8A05C9  bl 0x822c0890
	ctx.lr = 0x82A202CC;
	sub_822C0890(ctx, base);
	// 82A202CC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A202D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A202D4: 419A0008  beq cr6, 0x82a202dc
	if ctx.cr[6].eq {
	pc = 0x82A202DC; continue 'dispatch;
	}
	// 82A202D8: 4B8A05B9  bl 0x822c0890
	ctx.lr = 0x82A202DC;
	sub_822C0890(ctx, base);
	// 82A202DC: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 82A202E0: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82A202E4: 48787EC8  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A202E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A202E8 size=84
    let mut pc: u32 = 0x82A202E8;
    'dispatch: loop {
        match pc {
            0x82A202E8 => {
    //   block [0x82A202E8..0x82A2033C)
	// 82A202E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A202EC: 48787E81  bl 0x831a816c
	ctx.lr = 0x82A202F0;
	sub_831A8130(ctx, base);
	// 82A202F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A202F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A202F8: 48734309  bl 0x83154600
	ctx.lr = 0x82A202FC;
	sub_83154600(ctx, base);
	// 82A202FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A20300: 4BFF2BC1  bl 0x82a12ec0
	ctx.lr = 0x82A20304;
	sub_82A12EC0(ctx, base);
	// 82A20304: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A20308: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A2030C: 4BFFA4AD  bl 0x82a1a7b8
	ctx.lr = 0x82A20310;
	sub_82A1A7B8(ctx, base);
	// 82A20310: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82A20314: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A20318: 4BFFA4A1  bl 0x82a1a7b8
	ctx.lr = 0x82A2031C;
	sub_82A1A7B8(ctx, base);
	// 82A2031C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A20320: 4BFF2BC1  bl 0x82a12ee0
	ctx.lr = 0x82A20324;
	sub_82A12EE0(ctx, base);
	// 82A20324: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A20328: 4BFF2C41  bl 0x82a12f68
	ctx.lr = 0x82A2032C;
	sub_82A12F68(ctx, base);
	// 82A2032C: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A20330: 48126399  bl 0x82b466c8
	ctx.lr = 0x82A20334;
	sub_82B466C8(ctx, base);
	// 82A20334: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A20338: 48787E84  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A20340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A20340 size=152
    let mut pc: u32 = 0x82A20340;
    'dispatch: loop {
        match pc {
            0x82A20340 => {
    //   block [0x82A20340..0x82A203D8)
	// 82A20340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A20344: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A20348: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2034C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A20350: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A20354: 4BFFDDF5  bl 0x82a1e148
	ctx.lr = 0x82A20358;
	sub_82A1E148(ctx, base);
	// 82A20358: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A2035C: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A20360: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A20364: 3929A4A0  addi r9, r9, -0x5b60
	ctx.r[9].s64 = ctx.r[9].s64 + -23392;
	// 82A20368: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 82A2036C: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A20370: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A20374: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A20378: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A2037C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A20380: 911F006C  stw r8, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[8].u32 ) };
	// 82A20384: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A20388: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A2038C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A20390: 98FF0074  stb r7, 0x74(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[7].u8 ) };
	// 82A20394: 388AA10C  addi r4, r10, -0x5ef4
	ctx.r[4].s64 = ctx.r[10].s64 + -24308;
	// 82A20398: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82A2039C: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82A203A0: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82A203A4: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82A203A8: 483D3661  bl 0x82df3a08
	ctx.lr = 0x82A203AC;
	sub_82DF3A08(ctx, base);
	// 82A203AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A203B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A203B4: 48439335  bl 0x82e596e8
	ctx.lr = 0x82A203B8;
	sub_82E596E8(ctx, base);
	// 82A203B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A203BC: 483D306D  bl 0x82df3428
	ctx.lr = 0x82A203C0;
	sub_82DF3428(ctx, base);
	// 82A203C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A203C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A203C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A203CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A203D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A203D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A203D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A203D8 size=424
    let mut pc: u32 = 0x82A203D8;
    'dispatch: loop {
        match pc {
            0x82A203D8 => {
    //   block [0x82A203D8..0x82A20580)
	// 82A203D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A203DC: 48787D91  bl 0x831a816c
	ctx.lr = 0x82A203E0;
	sub_831A8130(ctx, base);
	// 82A203E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A203E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A203E8: 48734219  bl 0x83154600
	ctx.lr = 0x82A203EC;
	sub_83154600(ctx, base);
	// 82A203EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A203F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A203F4: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A203F8: 915F0064  stw r10, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82A203FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A20400: 3889A130  addi r4, r9, -0x5ed0
	ctx.r[4].s64 = ctx.r[9].s64 + -24272;
	// 82A20404: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A20408: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2040C: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A20410: 483D35F9  bl 0x82df3a08
	ctx.lr = 0x82A20414;
	sub_82DF3A08(ctx, base);
	// 82A20414: 3BDF006C  addi r30, r31, 0x6c
	ctx.r[30].s64 = ctx.r[31].s64 + 108;
	// 82A20418: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A2041C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A20420: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A20424: 4BFFF7C5  bl 0x82a1fbe8
	ctx.lr = 0x82A20428;
	sub_82A1FBE8(ctx, base);
	// 82A20428: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2042C: 483D2FFD  bl 0x82df3428
	ctx.lr = 0x82A20430;
	sub_82DF3428(ctx, base);
	// 82A20430: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A20434: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82A20438: 419A002C  beq cr6, 0x82a20464
	if ctx.cr[6].eq {
	pc = 0x82A20464; continue 'dispatch;
	}
	// 82A2043C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A20440: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A20444: 388BA124  addi r4, r11, -0x5edc
	ctx.r[4].s64 = ctx.r[11].s64 + -24284;
	// 82A20448: 483D35C1  bl 0x82df3a08
	ctx.lr = 0x82A2044C;
	sub_82DF3A08(ctx, base);
	// 82A2044C: 38BF0070  addi r5, r31, 0x70
	ctx.r[5].s64 = ctx.r[31].s64 + 112;
	// 82A20450: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A20454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A20458: 4B913CD1  bl 0x82334128
	ctx.lr = 0x82A2045C;
	sub_82334128(ctx, base);
	// 82A2045C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A20460: 483D2FC9  bl 0x82df3428
	ctx.lr = 0x82A20464;
	sub_82DF3428(ctx, base);
	// 82A20464: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20468: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A2046C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A20470: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A20474: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82A20478: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82A2047C: 997F0074  stb r11, 0x74(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u8 ) };
	// 82A20480: 4BAEF049  bl 0x8250f4c8
	ctx.lr = 0x82A20484;
	sub_8250F4C8(ctx, base);
	// 82A20484: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20488: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2048C: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A20490: 409A0008  bne cr6, 0x82a20498
	if !ctx.cr[6].eq {
	pc = 0x82A20498; continue 'dispatch;
	}
	// 82A20494: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A20498: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A2049C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A204A0: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82A204A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A204A8: 481269F9  bl 0x82b46ea0
	ctx.lr = 0x82A204AC;
	sub_82B46EA0(ctx, base);
	// 82A204AC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A204B0: 3BDF0078  addi r30, r31, 0x78
	ctx.r[30].s64 = ctx.r[31].s64 + 120;
	// 82A204B4: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A204B8: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82A204BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A204C0: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82A204C4: 4B8A3F9D  bl 0x822c4460
	ctx.lr = 0x82A204C8;
	sub_822C4460(ctx, base);
	// 82A204C8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A204CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A204D0: 419A0008  beq cr6, 0x82a204d8
	if ctx.cr[6].eq {
	pc = 0x82A204D8; continue 'dispatch;
	}
	// 82A204D4: 4B8A03BD  bl 0x822c0890
	ctx.lr = 0x82A204D8;
	sub_822C0890(ctx, base);
	// 82A204D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A204DC: 483D17B5  bl 0x82df1c90
	ctx.lr = 0x82A204E0;
	sub_82DF1C90(ctx, base);
	// 82A204E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A204E4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A204E8: 4BAEEFE1  bl 0x8250f4c8
	ctx.lr = 0x82A204EC;
	sub_8250F4C8(ctx, base);
	// 82A204EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A204F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A204F4: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A204F8: 409A0008  bne cr6, 0x82a20500
	if !ctx.cr[6].eq {
	pc = 0x82A20500; continue 'dispatch;
	}
	// 82A204FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A20500: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A20504: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A20508: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82A2050C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A20510: 48126991  bl 0x82b46ea0
	ctx.lr = 0x82A20514;
	sub_82B46EA0(ctx, base);
	// 82A20514: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A20518: 3BFF0080  addi r31, r31, 0x80
	ctx.r[31].s64 = ctx.r[31].s64 + 128;
	// 82A2051C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A20520: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82A20524: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20528: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A2052C: 4B8A3F35  bl 0x822c4460
	ctx.lr = 0x82A20530;
	sub_822C4460(ctx, base);
	// 82A20530: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A20534: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A20538: 419A0008  beq cr6, 0x82a20540
	if ctx.cr[6].eq {
	pc = 0x82A20540; continue 'dispatch;
	}
	// 82A2053C: 4B8A0355  bl 0x822c0890
	ctx.lr = 0x82A20540;
	sub_822C0890(ctx, base);
	// 82A20540: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A20544: 483D174D  bl 0x82df1c90
	ctx.lr = 0x82A20548;
	sub_82DF1C90(ctx, base);
	// 82A20548: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A2054C: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20550: 4BFF3131  bl 0x82a13680
	ctx.lr = 0x82A20554;
	sub_82A13680(ctx, base);
	// 82A20554: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A20558: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2055C: 4812664D  bl 0x82b46ba8
	ctx.lr = 0x82A20560;
	sub_82B46BA8(ctx, base);
	// 82A20560: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A20564: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20568: 4BFF3119  bl 0x82a13680
	ctx.lr = 0x82A2056C;
	sub_82A13680(ctx, base);
	// 82A2056C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A20570: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A20574: 48126635  bl 0x82b46ba8
	ctx.lr = 0x82A20578;
	sub_82B46BA8(ctx, base);
	// 82A20578: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A2057C: 48787C40  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A20580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A20580 size=1828
    let mut pc: u32 = 0x82A20580;
    'dispatch: loop {
        match pc {
            0x82A20580 => {
    //   block [0x82A20580..0x82A20CA4)
	// 82A20580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A20584: 48787BD9  bl 0x831a815c
	ctx.lr = 0x82A20588;
	sub_831A8130(ctx, base);
	// 82A20588: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82A2058C: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A20590: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A20594: 4873406D  bl 0x83154600
	ctx.lr = 0x82A20598;
	sub_83154600(ctx, base);
	// 82A20598: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A2059C: 4BFF291D  bl 0x82a12eb8
	ctx.lr = 0x82A205A0;
	sub_82A12EB8(ctx, base);
	// 82A205A0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A205A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A205A8: 4BFF2919  bl 0x82a12ec0
	ctx.lr = 0x82A205AC;
	sub_82A12EC0(ctx, base);
	// 82A205AC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82A205B0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A205B4: 4800D6BD  bl 0x82a2dc70
	ctx.lr = 0x82A205B8;
	sub_82A2DC70(ctx, base);
	// 82A205B8: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A205BC: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A205C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A205C4: 484391B5  bl 0x82e59778
	ctx.lr = 0x82A205C8;
	sub_82E59778(ctx, base);
	// 82A205C8: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A205CC: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A205D0: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A205D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A205D8: 4BE3D819  bl 0x8285ddf0
	ctx.lr = 0x82A205DC;
	sub_8285DDF0(ctx, base);
	// 82A205DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A205E0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82A205E4: 41820008  beq 0x82a205ec
	if ctx.cr[0].eq {
	pc = 0x82A205EC; continue 'dispatch;
	}
	// 82A205E8: 9B9F0074  stb r28, 0x74(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[28].u8 ) };
	// 82A205EC: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A205F0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A205F4: 419805CC  blt cr6, 0x82a20bc0
	if ctx.cr[6].lt {
	pc = 0x82A20BC0; continue 'dispatch;
	}
	// 82A205F8: 419A0438  beq cr6, 0x82a20a30
	if ctx.cr[6].eq {
	pc = 0x82A20A30; continue 'dispatch;
	}
	// 82A205FC: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A20600: 41980340  blt cr6, 0x82a20940
	if ctx.cr[6].lt {
	pc = 0x82A20940; continue 'dispatch;
	}
	// 82A20604: 419A0130  beq cr6, 0x82a20734
	if ctx.cr[6].eq {
	pc = 0x82A20734; continue 'dispatch;
	}
	// 82A20608: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82A2060C: 4098067C  bge cr6, 0x82a20c88
	if !ctx.cr[6].lt {
	pc = 0x82A20C88; continue 'dispatch;
	}
	// 82A20610: 897F0074  lbz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A20614: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A20618: 4182003C  beq 0x82a20654
	if ctx.cr[0].eq {
	pc = 0x82A20654; continue 'dispatch;
	}
	// 82A2061C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A20620: 4BFF66E9  bl 0x82a16d08
	ctx.lr = 0x82A20624;
	sub_82A16D08(ctx, base);
	// 82A20624: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A20628: 4082002C  bne 0x82a20654
	if !ctx.cr[0].eq {
	pc = 0x82A20654; continue 'dispatch;
	}
	// 82A2062C: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A20630: 4800C7F1  bl 0x82a2ce20
	ctx.lr = 0x82A20634;
	sub_82A2CE20(ctx, base);
	// 82A20634: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A20638: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A2063C: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A20640: 396BA478  addi r11, r11, -0x5b88
	ctx.r[11].s64 = ctx.r[11].s64 + -23432;
	// 82A20644: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82A20648: 7DAA5C2E  lfsx f13, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A2064C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A20650: 41990638  bgt cr6, 0x82a20c88
	if ctx.cr[6].gt {
	pc = 0x82A20C88; continue 'dispatch;
	}
	// 82A20654: 897F0074  lbz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A20658: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A2065C: 418200C0  beq 0x82a2071c
	if ctx.cr[0].eq {
	pc = 0x82A2071C; continue 'dispatch;
	}
	// 82A20660: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A20664: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A20668: 388B893C  addi r4, r11, -0x76c4
	ctx.r[4].s64 = ctx.r[11].s64 + -30404;
	// 82A2066C: 483D339D  bl 0x82df3a08
	ctx.lr = 0x82A20670;
	sub_82DF3A08(ctx, base);
	// 82A20670: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A20674: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A20678: 388BA46C  addi r4, r11, -0x5b94
	ctx.r[4].s64 = ctx.r[11].s64 + -23444;
	// 82A2067C: 483D338D  bl 0x82df3a08
	ctx.lr = 0x82A20680;
	sub_82DF3A08(ctx, base);
	// 82A20680: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A20684: 485E7AA5  bl 0x83008128
	ctx.lr = 0x82A20688;
	sub_83008128(ctx, base);
	// 82A20688: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A2068C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A20690: 48439E91  bl 0x82e5a520
	ctx.lr = 0x82A20694;
	sub_82E5A520(ctx, base);
	// 82A20694: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20698: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A2069C: 386B0038  addi r3, r11, 0x38
	ctx.r[3].s64 = ctx.r[11].s64 + 56;
	// 82A206A0: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82A206A4: 4B90C19D  bl 0x8232c840
	ctx.lr = 0x82A206A8;
	sub_8232C840(ctx, base);
	// 82A206A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A206AC: 4BFFF4D5  bl 0x82a1fb80
	ctx.lr = 0x82A206B0;
	sub_82A1FB80(ctx, base);
	// 82A206B0: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A206B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A206B8: 419A0008  beq cr6, 0x82a206c0
	if ctx.cr[6].eq {
	pc = 0x82A206C0; continue 'dispatch;
	}
	// 82A206BC: 4B8A01D5  bl 0x822c0890
	ctx.lr = 0x82A206C0;
	sub_822C0890(ctx, base);
	// 82A206C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A206C4: 483D2D65  bl 0x82df3428
	ctx.lr = 0x82A206C8;
	sub_82DF3428(ctx, base);
	// 82A206C8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A206CC: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A206D0: 388B836C  addi r4, r11, -0x7c94
	ctx.r[4].s64 = ctx.r[11].s64 + -31892;
	// 82A206D4: 483D3335  bl 0x82df3a08
	ctx.lr = 0x82A206D8;
	sub_82DF3A08(ctx, base);
	// 82A206D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A206DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A206E0: 485E7A49  bl 0x83008128
	ctx.lr = 0x82A206E4;
	sub_83008128(ctx, base);
	// 82A206E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A206E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A206EC: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82A206F0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A206F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A206F8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A206FC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A20700: 4843E261  bl 0x82e5e960
	ctx.lr = 0x82A20704;
	sub_82E5E960(ctx, base);
	// 82A20704: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A20708: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2070C: 419A0008  beq cr6, 0x82a20714
	if ctx.cr[6].eq {
	pc = 0x82A20714; continue 'dispatch;
	}
	// 82A20710: 4B8A0181  bl 0x822c0890
	ctx.lr = 0x82A20714;
	sub_822C0890(ctx, base);
	// 82A20714: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A20718: 480004A0  b 0x82a20bb8
	pc = 0x82A20BB8; continue 'dispatch;
	// 82A2071C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A20720: 4BDCBAB9  bl 0x827ec1d8
	ctx.lr = 0x82A20724;
	sub_827EC1D8(ctx, base);
	// 82A20724: 80BF0070  lwz r5, 0x70(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A20728: 809F006C  lwz r4, 0x6c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A2072C: 4BFFD3C5  bl 0x82a1daf0
	ctx.lr = 0x82A20730;
	sub_82A1DAF0(ctx, base);
	// 82A20730: 48000558  b 0x82a20c88
	pc = 0x82A20C88; continue 'dispatch;
	// 82A20734: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A20738: C1BF0068  lfs f13, 0x68(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A2073C: C00B9E38  lfs f0, -0x61c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25032 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A20740: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A20744: 40980180  bge cr6, 0x82a208c4
	if !ctx.cr[6].lt {
	pc = 0x82A208C4; continue 'dispatch;
	}
	// 82A20748: C1BF0060  lfs f13, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A2074C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A20750: 41990174  bgt cr6, 0x82a208c4
	if ctx.cr[6].gt {
	pc = 0x82A208C4; continue 'dispatch;
	}
	// 82A20754: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A20758: 4BDCEFE1  bl 0x827ef738
	ctx.lr = 0x82A2075C;
	sub_827EF738(ctx, base);
	// 82A2075C: 83430004  lwz r26, 4(r3)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A20760: 83830000  lwz r28, 0(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20764: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82A20768: 419A0024  beq cr6, 0x82a2078c
	if ctx.cr[6].eq {
	pc = 0x82A2078C; continue 'dispatch;
	}
	// 82A2076C: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 82A20770: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A20774: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A20778: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A2077C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A20780: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A20784: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A20788: 4082FFE8  bne 0x82a20770
	if !ctx.cr[0].eq {
	pc = 0x82A20770; continue 'dispatch;
	}
	// 82A2078C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A20790: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A20794: 388B97CC  addi r4, r11, -0x6834
	ctx.r[4].s64 = ctx.r[11].s64 + -26676;
	// 82A20798: 483D3271  bl 0x82df3a08
	ctx.lr = 0x82A2079C;
	sub_82DF3A08(ctx, base);
	// 82A2079C: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82A207A0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A207A4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A207A8: 483F4889  bl 0x82e15030
	ctx.lr = 0x82A207AC;
	sub_82E15030(ctx, base);
	// 82A207AC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A207B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A207B4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A207B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A207BC: 4E800421  bctrl
	ctx.lr = 0x82A207C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A207C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A207C4: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A207C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A207CC: C00B003C  lfs f0, 0x3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A207D0: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A207D4: C18B0034  lfs f12, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A207D8: C16B0030  lfs f11, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A207DC: D1610070  stfs f11, 0x70(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82A207E0: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82A207E4: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82A207E8: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82A207EC: 419A0008  beq cr6, 0x82a207f4
	if ctx.cr[6].eq {
	pc = 0x82A207F4; continue 'dispatch;
	}
	// 82A207F0: 4B8A00A1  bl 0x822c0890
	ctx.lr = 0x82A207F4;
	sub_822C0890(ctx, base);
	// 82A207F4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A207F8: 483D2C31  bl 0x82df3428
	ctx.lr = 0x82A207FC;
	sub_82DF3428(ctx, base);
	// 82A207FC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A20800: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A20804: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82A20808: C00BA478  lfs f0, -0x5b88(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23432 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A2080C: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82A20810: 83610068  lwz r27, 0x68(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A20814: 4BAEECB5  bl 0x8250f4c8
	ctx.lr = 0x82A20818;
	sub_8250F4C8(ctx, base);
	// 82A20818: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2081C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A20820: 3B8BFFFC  addi r28, r11, -4
	ctx.r[28].s64 = ctx.r[11].s64 + -4;
	// 82A20824: 409A0008  bne cr6, 0x82a2082c
	if !ctx.cr[6].eq {
	pc = 0x82A2082C; continue 'dispatch;
	}
	// 82A20828: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A2082C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A20830: 4800C5F1  bl 0x82a2ce20
	ctx.lr = 0x82A20834;
	sub_82A2CE20(ctx, base);
	// 82A20834: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A20838: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2083C: 4BFF2E45  bl 0x82a13680
	ctx.lr = 0x82A20840;
	sub_82A13680(ctx, base);
	// 82A20840: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A20844: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A20848: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 82A2084C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A20850: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A20854: 4800F395  bl 0x82a2fbe8
	ctx.lr = 0x82A20858;
	sub_82A2FBE8(ctx, base);
	// 82A20858: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A2085C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A20860: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A20864: 4BAEECB5  bl 0x8250f518
	ctx.lr = 0x82A20868;
	sub_8250F518(ctx, base);
	// 82A20868: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A2086C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A20870: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A20874: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A20878: 4BAECC91  bl 0x8250d508
	ctx.lr = 0x82A2087C;
	sub_8250D508(ctx, base);
	// 82A2087C: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82A20880: 483D1411  bl 0x82df1c90
	ctx.lr = 0x82A20884;
	sub_82DF1C90(ctx, base);
	// 82A20884: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A20888: 483D1409  bl 0x82df1c90
	ctx.lr = 0x82A2088C;
	sub_82DF1C90(ctx, base);
	// 82A2088C: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82A20890: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A20894: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A20898: 388BA4E8  addi r4, r11, -0x5b18
	ctx.r[4].s64 = ctx.r[11].s64 + -23320;
	// 82A2089C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A208A0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A208A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A208A8: 4E800421  bctrl
	ctx.lr = 0x82A208AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A208AC: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A208B0: 48125E19  bl 0x82b466c8
	ctx.lr = 0x82A208B4;
	sub_82B466C8(ctx, base);
	// 82A208B4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82A208B8: 419A000C  beq cr6, 0x82a208c4
	if ctx.cr[6].eq {
	pc = 0x82A208C4; continue 'dispatch;
	}
	// 82A208BC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A208C0: 4B89FFD1  bl 0x822c0890
	ctx.lr = 0x82A208C4;
	sub_822C0890(ctx, base);
	// 82A208C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A208C8: 4BDD3B19  bl 0x827f43e0
	ctx.lr = 0x82A208CC;
	sub_827F43E0(ctx, base);
	// 82A208CC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A208D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A208D4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A208D8: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A208DC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A208E0: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A208E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A208E8: 4E800421  bctrl
	ctx.lr = 0x82A208EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A208EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A208F0: 41820398  beq 0x82a20c88
	if ctx.cr[0].eq {
	pc = 0x82A20C88; continue 'dispatch;
	}
	// 82A208F4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A208F8: 38800022  li r4, 0x22
	ctx.r[4].s64 = 34;
	// 82A208FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A20900: C02B9EFC  lfs f1, -0x6104(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24836 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A20904: 4BFF8C65  bl 0x82a19568
	ctx.lr = 0x82A20908;
	sub_82A19568(ctx, base);
	// 82A20908: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2090C: 4BFF25D5  bl 0x82a12ee0
	ctx.lr = 0x82A20910;
	sub_82A12EE0(ctx, base);
	// 82A20910: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A20914: 4BFF2655  bl 0x82a12f68
	ctx.lr = 0x82A20918;
	sub_82A12F68(ctx, base);
	// 82A20918: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82A2091C: D3FF0060  stfs f31, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A20920: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A20924: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A20928: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A2092C: 4BFF9E8D  bl 0x82a1a7b8
	ctx.lr = 0x82A20930;
	sub_82A1A7B8(ctx, base);
	// 82A20930: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82A20934: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A20938: 4BFF9E81  bl 0x82a1a7b8
	ctx.lr = 0x82A2093C;
	sub_82A1A7B8(ctx, base);
	// 82A2093C: 4800034C  b 0x82a20c88
	pc = 0x82A20C88; continue 'dispatch;
	// 82A20940: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A20944: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82A20948: 4BFF9419  bl 0x82a19d60
	ctx.lr = 0x82A2094C;
	sub_82A19D60(ctx, base);
	// 82A2094C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A20950: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A20954: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82A20958: 4BFF8C79  bl 0x82a195d0
	ctx.lr = 0x82A2095C;
	sub_82A195D0(ctx, base);
	// 82A2095C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A20960: 4BFF2D29  bl 0x82a13688
	ctx.lr = 0x82A20964;
	sub_82A13688(ctx, base);
	// 82A20964: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A20968: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A2096C: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82A20970: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 82A20974: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82A20978: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A2097C: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82A20980: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A20984: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82A20988: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A2098C: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82A20990: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A20994: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82A20998: C02A02BC  lfs f1, 0x2bc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(700 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A2099C: 4845C92D  bl 0x82e7d2c8
	ctx.lr = 0x82A209A0;
	sub_82E7D2C8(ctx, base);
	// 82A209A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A209A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A209A8: 4808AB31  bl 0x82aab4d8
	ctx.lr = 0x82A209AC;
	sub_82AAB4D8(ctx, base);
	// 82A209AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A209B0: 4BDD3A31  bl 0x827f43e0
	ctx.lr = 0x82A209B4;
	sub_827F43E0(ctx, base);
	// 82A209B4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A209B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A209BC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A209C0: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A209C4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A209C8: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A209CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A209D0: 4E800421  bctrl
	ctx.lr = 0x82A209D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A209D4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A209D8: 418202B0  beq 0x82a20c88
	if ctx.cr[0].eq {
	pc = 0x82A20C88; continue 'dispatch;
	}
	// 82A209DC: 38800012  li r4, 0x12
	ctx.r[4].s64 = 18;
	// 82A209E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A209E4: 4BFF8F25  bl 0x82a19908
	ctx.lr = 0x82A209E8;
	sub_82A19908(ctx, base);
	// 82A209E8: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82A209EC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A209F0: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A209F4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A209F8: 4BFF9DD9  bl 0x82a1a7d0
	ctx.lr = 0x82A209FC;
	sub_82A1A7D0(ctx, base);
	// 82A209FC: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82A20A00: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A20A04: 4BFF9DCD  bl 0x82a1a7d0
	ctx.lr = 0x82A20A08;
	sub_82A1A7D0(ctx, base);
	// 82A20A08: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82A20A0C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A20A10: D3FF0060  stfs f31, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A20A14: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A20A18: 388BA440  addi r4, r11, -0x5bc0
	ctx.r[4].s64 = ctx.r[11].s64 + -23488;
	// 82A20A1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20A20: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A20A24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A20A28: 4E800421  bctrl
	ctx.lr = 0x82A20A2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A20A2C: 4800025C  b 0x82a20c88
	pc = 0x82A20C88; continue 'dispatch;
	// 82A20A30: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A20A34: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82A20A38: 4BFF9329  bl 0x82a19d60
	ctx.lr = 0x82A20A3C;
	sub_82A19D60(ctx, base);
	// 82A20A3C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A20A40: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A20A44: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82A20A48: 4BFF8B89  bl 0x82a195d0
	ctx.lr = 0x82A20A4C;
	sub_82A195D0(ctx, base);
	// 82A20A4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A20A50: 4BFF2C39  bl 0x82a13688
	ctx.lr = 0x82A20A54;
	sub_82A13688(ctx, base);
	// 82A20A54: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A20A58: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A20A5C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82A20A60: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 82A20A64: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 82A20A68: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A20A6C: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82A20A70: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A20A74: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82A20A78: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A20A7C: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82A20A80: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A20A84: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82A20A88: C02A02BC  lfs f1, 0x2bc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(700 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A20A8C: 4845C83D  bl 0x82e7d2c8
	ctx.lr = 0x82A20A90;
	sub_82E7D2C8(ctx, base);
	// 82A20A90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A20A94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A20A98: 4808AA41  bl 0x82aab4d8
	ctx.lr = 0x82A20A9C;
	sub_82AAB4D8(ctx, base);
	// 82A20A9C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A20AA0: 4BDD3941  bl 0x827f43e0
	ctx.lr = 0x82A20AA4;
	sub_827F43E0(ctx, base);
	// 82A20AA4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20AA8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A20AAC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20AB0: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A20AB4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A20AB8: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A20ABC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A20AC0: 4E800421  bctrl
	ctx.lr = 0x82A20AC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A20AC4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A20AC8: 4182002C  beq 0x82a20af4
	if ctx.cr[0].eq {
	pc = 0x82A20AF4; continue 'dispatch;
	}
	// 82A20ACC: 38800013  li r4, 0x13
	ctx.r[4].s64 = 19;
	// 82A20AD0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A20AD4: 4BFF8E35  bl 0x82a19908
	ctx.lr = 0x82A20AD8;
	sub_82A19908(ctx, base);
	// 82A20AD8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A20ADC: 4BFF861D  bl 0x82a190f8
	ctx.lr = 0x82A20AE0;
	sub_82A190F8(ctx, base);
	// 82A20AE0: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A20AE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A20AE8: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A20AEC: 4BFF24CD  bl 0x82a12fb8
	ctx.lr = 0x82A20AF0;
	sub_82A12FB8(ctx, base);
	// 82A20AF0: 48000198  b 0x82a20c88
	pc = 0x82A20C88; continue 'dispatch;
	// 82A20AF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A20AF8: 4BFF6211  bl 0x82a16d08
	ctx.lr = 0x82A20AFC;
	sub_82A16D08(ctx, base);
	// 82A20AFC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A20B00: 41820188  beq 0x82a20c88
	if ctx.cr[0].eq {
	pc = 0x82A20C88; continue 'dispatch;
	}
	// 82A20B04: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A20B08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A20B0C: 388BA10C  addi r4, r11, -0x5ef4
	ctx.r[4].s64 = ctx.r[11].s64 + -24308;
	// 82A20B10: 483D2EF9  bl 0x82df3a08
	ctx.lr = 0x82A20B14;
	sub_82DF3A08(ctx, base);
	// 82A20B14: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A20B18: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A20B1C: 388BA46C  addi r4, r11, -0x5b94
	ctx.r[4].s64 = ctx.r[11].s64 + -23444;
	// 82A20B20: 483D2EE9  bl 0x82df3a08
	ctx.lr = 0x82A20B24;
	sub_82DF3A08(ctx, base);
	// 82A20B24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A20B28: 485E7601  bl 0x83008128
	ctx.lr = 0x82A20B2C;
	sub_83008128(ctx, base);
	// 82A20B2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A20B30: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82A20B34: 484399ED  bl 0x82e5a520
	ctx.lr = 0x82A20B38;
	sub_82E5A520(ctx, base);
	// 82A20B38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20B3C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A20B40: 386B0038  addi r3, r11, 0x38
	ctx.r[3].s64 = ctx.r[11].s64 + 56;
	// 82A20B44: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82A20B48: 4B90BCF9  bl 0x8232c840
	ctx.lr = 0x82A20B4C;
	sub_8232C840(ctx, base);
	// 82A20B4C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A20B50: 4BFFF031  bl 0x82a1fb80
	ctx.lr = 0x82A20B54;
	sub_82A1FB80(ctx, base);
	// 82A20B54: 806100F4  lwz r3, 0xf4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A20B58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A20B5C: 419A0008  beq cr6, 0x82a20b64
	if ctx.cr[6].eq {
	pc = 0x82A20B64; continue 'dispatch;
	}
	// 82A20B60: 4B89FD31  bl 0x822c0890
	ctx.lr = 0x82A20B64;
	sub_822C0890(ctx, base);
	// 82A20B64: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A20B68: 483D28C1  bl 0x82df3428
	ctx.lr = 0x82A20B6C;
	sub_82DF3428(ctx, base);
	// 82A20B6C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A20B70: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82A20B74: 388B836C  addi r4, r11, -0x7c94
	ctx.r[4].s64 = ctx.r[11].s64 + -31892;
	// 82A20B78: 483D2E91  bl 0x82df3a08
	ctx.lr = 0x82A20B7C;
	sub_82DF3A08(ctx, base);
	// 82A20B7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A20B80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A20B84: 485E75A5  bl 0x83008128
	ctx.lr = 0x82A20B88;
	sub_83008128(ctx, base);
	// 82A20B88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A20B8C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82A20B90: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A20B94: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A20B98: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A20B9C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A20BA0: 4843DDC1  bl 0x82e5e960
	ctx.lr = 0x82A20BA4;
	sub_82E5E960(ctx, base);
	// 82A20BA4: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82A20BA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A20BAC: 419A0008  beq cr6, 0x82a20bb4
	if ctx.cr[6].eq {
	pc = 0x82A20BB4; continue 'dispatch;
	}
	// 82A20BB0: 4B89FCE1  bl 0x822c0890
	ctx.lr = 0x82A20BB4;
	sub_822C0890(ctx, base);
	// 82A20BB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A20BB8: 483D2871  bl 0x82df3428
	ctx.lr = 0x82A20BBC;
	sub_82DF3428(ctx, base);
	// 82A20BBC: 480000CC  b 0x82a20c88
	pc = 0x82A20C88; continue 'dispatch;
	// 82A20BC0: 38800014  li r4, 0x14
	ctx.r[4].s64 = 20;
	// 82A20BC4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A20BC8: 4BFF8D41  bl 0x82a19908
	ctx.lr = 0x82A20BCC;
	sub_82A19908(ctx, base);
	// 82A20BCC: 897F0074  lbz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A20BD0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A20BD4: 41820028  beq 0x82a20bfc
	if ctx.cr[0].eq {
	pc = 0x82A20BFC; continue 'dispatch;
	}
	// 82A20BD8: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A20BDC: 4800C245  bl 0x82a2ce20
	ctx.lr = 0x82A20BE0;
	sub_82A2CE20(ctx, base);
	// 82A20BE0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A20BE4: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A20BE8: 396BA478  addi r11, r11, -0x5b88
	ctx.r[11].s64 = ctx.r[11].s64 + -23432;
	// 82A20BEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A20BF0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A20BF4: 7C2A5C2E  lfsx f1, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A20BF8: 4BFF8481  bl 0x82a19078
	ctx.lr = 0x82A20BFC;
	sub_82A19078(ctx, base);
	// 82A20BFC: 939F0064  stw r28, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 82A20C00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A20C04: 4BFF22CD  bl 0x82a12ed0
	ctx.lr = 0x82A20C08;
	sub_82A12ED0(ctx, base);
	// 82A20C08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A20C0C: 4BFF234D  bl 0x82a12f58
	ctx.lr = 0x82A20C10;
	sub_82A12F58(ctx, base);
	// 82A20C10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A20C14: 4BFF2385  bl 0x82a12f98
	ctx.lr = 0x82A20C18;
	sub_82A12F98(ctx, base);
	// 82A20C18: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82A20C1C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A20C20: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A20C24: 388BA428  addi r4, r11, -0x5bd8
	ctx.r[4].s64 = ctx.r[11].s64 + -23512;
	// 82A20C28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20C2C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A20C30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A20C34: 4E800421  bctrl
	ctx.lr = 0x82A20C38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A20C38: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A20C3C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A20C40: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A20C44: 388BA4D4  addi r4, r11, -0x5b2c
	ctx.r[4].s64 = ctx.r[11].s64 + -23340;
	// 82A20C48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20C4C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A20C50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A20C54: 4E800421  bctrl
	ctx.lr = 0x82A20C58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A20C58: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A20C5C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A20C60: 38ABA4C4  addi r5, r11, -0x5b3c
	ctx.r[5].s64 = ctx.r[11].s64 + -23356;
	// 82A20C64: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82A20C68: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20C6C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A20C70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A20C74: 4E800421  bctrl
	ctx.lr = 0x82A20C78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A20C78: 80610104  lwz r3, 0x104(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A20C7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A20C80: 419A0008  beq cr6, 0x82a20c88
	if ctx.cr[6].eq {
	pc = 0x82A20C88; continue 'dispatch;
	}
	// 82A20C84: 4B89FC0D  bl 0x822c0890
	ctx.lr = 0x82A20C88;
	sub_822C0890(ctx, base);
	// 82A20C88: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A20C8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A20C90: 419A0008  beq cr6, 0x82a20c98
	if ctx.cr[6].eq {
	pc = 0x82A20C98; continue 'dispatch;
	}
	// 82A20C94: 4B89FBFD  bl 0x822c0890
	ctx.lr = 0x82A20C98;
	sub_822C0890(ctx, base);
	// 82A20C98: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 82A20C9C: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82A20CA0: 4878750C  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A20CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A20CA8 size=56
    let mut pc: u32 = 0x82A20CA8;
    'dispatch: loop {
        match pc {
            0x82A20CA8 => {
    //   block [0x82A20CA8..0x82A20CE0)
	// 82A20CA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A20CAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A20CB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A20CB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A20CB8: 48733949  bl 0x83154600
	ctx.lr = 0x82A20CBC;
	sub_83154600(ctx, base);
	// 82A20CBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A20CC0: 4BFF2221  bl 0x82a12ee0
	ctx.lr = 0x82A20CC4;
	sub_82A12EE0(ctx, base);
	// 82A20CC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A20CC8: 4BFF2249  bl 0x82a12f10
	ctx.lr = 0x82A20CCC;
	sub_82A12F10(ctx, base);
	// 82A20CCC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A20CD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A20CD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A20CD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A20CDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A20CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A20CE0 size=104
    let mut pc: u32 = 0x82A20CE0;
    'dispatch: loop {
        match pc {
            0x82A20CE0 => {
    //   block [0x82A20CE0..0x82A20D48)
	// 82A20CE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A20CE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A20CE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A20CEC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A20CF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A20CF4: 4BFFD455  bl 0x82a1e148
	ctx.lr = 0x82A20CF8;
	sub_82A1E148(ctx, base);
	// 82A20CF8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A20CFC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A20D00: 396BA504  addi r11, r11, -0x5afc
	ctx.r[11].s64 = ctx.r[11].s64 + -23292;
	// 82A20D04: 995F0068  stb r10, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[10].u8 ) };
	// 82A20D08: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A20D0C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A20D10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A20D14: 388A8F40  addi r4, r10, -0x70c0
	ctx.r[4].s64 = ctx.r[10].s64 + -28864;
	// 82A20D18: 483D2CF1  bl 0x82df3a08
	ctx.lr = 0x82A20D1C;
	sub_82DF3A08(ctx, base);
	// 82A20D1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A20D20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A20D24: 484389C5  bl 0x82e596e8
	ctx.lr = 0x82A20D28;
	sub_82E596E8(ctx, base);
	// 82A20D28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A20D2C: 483D26FD  bl 0x82df3428
	ctx.lr = 0x82A20D30;
	sub_82DF3428(ctx, base);
	// 82A20D30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A20D34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A20D38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A20D3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A20D40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A20D44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A20D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A20D48 size=584
    let mut pc: u32 = 0x82A20D48;
    'dispatch: loop {
        match pc {
            0x82A20D48 => {
    //   block [0x82A20D48..0x82A20F90)
	// 82A20D48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A20D4C: 48787421  bl 0x831a816c
	ctx.lr = 0x82A20D50;
	sub_831A8130(ctx, base);
	// 82A20D50: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A20D54: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A20D58: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A20D5C: 487338A5  bl 0x83154600
	ctx.lr = 0x82A20D60;
	sub_83154600(ctx, base);
	// 82A20D60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A20D64: 4BFF2155  bl 0x82a12eb8
	ctx.lr = 0x82A20D68;
	sub_82A12EB8(ctx, base);
	// 82A20D68: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A20D6C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A20D70: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A20D74: 419801F4  blt cr6, 0x82a20f68
	if ctx.cr[6].lt {
	pc = 0x82A20F68; continue 'dispatch;
	}
	// 82A20D78: 419A015C  beq cr6, 0x82a20ed4
	if ctx.cr[6].eq {
	pc = 0x82A20ED4; continue 'dispatch;
	}
	// 82A20D7C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A20D80: 419800E4  blt cr6, 0x82a20e64
	if ctx.cr[6].lt {
	pc = 0x82A20E64; continue 'dispatch;
	}
	// 82A20D84: 419A0050  beq cr6, 0x82a20dd4
	if ctx.cr[6].eq {
	pc = 0x82A20DD4; continue 'dispatch;
	}
	// 82A20D88: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82A20D8C: 409801F8  bge cr6, 0x82a20f84
	if !ctx.cr[6].lt {
	pc = 0x82A20F84; continue 'dispatch;
	}
	// 82A20D90: 4BDD3651  bl 0x827f43e0
	ctx.lr = 0x82A20D94;
	sub_827F43E0(ctx, base);
	// 82A20D94: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20D98: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A20D9C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20DA0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A20DA4: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A20DA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A20DAC: 4E800421  bctrl
	ctx.lr = 0x82A20DB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A20DB0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A20DB4: 418201D0  beq 0x82a20f84
	if ctx.cr[0].eq {
	pc = 0x82A20F84; continue 'dispatch;
	}
	// 82A20DB8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A20DBC: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 82A20DC0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A20DC4: C02B9EFC  lfs f1, -0x6104(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24836 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A20DC8: 4BFF87A1  bl 0x82a19568
	ctx.lr = 0x82A20DCC;
	sub_82A19568(ctx, base);
	// 82A20DCC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A20DD0: 480000FC  b 0x82a20ecc
	pc = 0x82A20ECC; continue 'dispatch;
	// 82A20DD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A20DD8: 4BDD3609  bl 0x827f43e0
	ctx.lr = 0x82A20DDC;
	sub_827F43E0(ctx, base);
	// 82A20DDC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20DE0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A20DE4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20DE8: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A20DEC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A20DF0: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A20DF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A20DF8: 4E800421  bctrl
	ctx.lr = 0x82A20DFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A20DFC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A20E00: 41820184  beq 0x82a20f84
	if ctx.cr[0].eq {
	pc = 0x82A20F84; continue 'dispatch;
	}
	// 82A20E04: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A20E08: 38800022  li r4, 0x22
	ctx.r[4].s64 = 34;
	// 82A20E0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A20E10: C02B9EFC  lfs f1, -0x6104(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24836 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A20E14: 4BFF8755  bl 0x82a19568
	ctx.lr = 0x82A20E18;
	sub_82A19568(ctx, base);
	// 82A20E18: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A20E1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A20E20: 388B893C  addi r4, r11, -0x76c4
	ctx.r[4].s64 = ctx.r[11].s64 + -30404;
	// 82A20E24: 483D2BE5  bl 0x82df3a08
	ctx.lr = 0x82A20E28;
	sub_82DF3A08(ctx, base);
	// 82A20E28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A20E2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A20E30: 485E72F9  bl 0x83008128
	ctx.lr = 0x82A20E34;
	sub_83008128(ctx, base);
	// 82A20E34: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A20E38: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A20E3C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A20E40: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A20E44: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A20E48: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A20E4C: 4843DB15  bl 0x82e5e960
	ctx.lr = 0x82A20E50;
	sub_82E5E960(ctx, base);
	// 82A20E50: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A20E54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A20E58: 419A012C  beq cr6, 0x82a20f84
	if ctx.cr[6].eq {
	pc = 0x82A20F84; continue 'dispatch;
	}
	// 82A20E5C: 4B89FA35  bl 0x822c0890
	ctx.lr = 0x82A20E60;
	sub_822C0890(ctx, base);
	// 82A20E60: 48000124  b 0x82a20f84
	pc = 0x82A20F84; continue 'dispatch;
	// 82A20E64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A20E68: 4BFF85C1  bl 0x82a19428
	ctx.lr = 0x82A20E6C;
	sub_82A19428(ctx, base);
	// 82A20E6C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A20E70: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A20E74: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82A20E78: 409A0024  bne cr6, 0x82a20e9c
	if !ctx.cr[6].eq {
	pc = 0x82A20E9C; continue 'dispatch;
	}
	// 82A20E7C: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 82A20E80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A20E84: 4BFF8A85  bl 0x82a19908
	ctx.lr = 0x82A20E88;
	sub_82A19908(ctx, base);
	// 82A20E88: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82A20E8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A20E90: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A20E94: 4BFF207D  bl 0x82a12f10
	ctx.lr = 0x82A20E98;
	sub_82A12F10(ctx, base);
	// 82A20E98: 480000EC  b 0x82a20f84
	pc = 0x82A20F84; continue 'dispatch;
	// 82A20E9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A20EA0: 4BFF20B1  bl 0x82a12f50
	ctx.lr = 0x82A20EA4;
	sub_82A12F50(ctx, base);
	// 82A20EA4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A20EA8: 418200DC  beq 0x82a20f84
	if ctx.cr[0].eq {
	pc = 0x82A20F84; continue 'dispatch;
	}
	// 82A20EAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A20EB0: 4BFF2091  bl 0x82a12f40
	ctx.lr = 0x82A20EB4;
	sub_82A12F40(ctx, base);
	// 82A20EB4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A20EB8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82A20EBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A20EC0: C02B9EFC  lfs f1, -0x6104(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24836 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A20EC4: 4BFF86A5  bl 0x82a19568
	ctx.lr = 0x82A20EC8;
	sub_82A19568(ctx, base);
	// 82A20EC8: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82A20ECC: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A20ED0: 480000B4  b 0x82a20f84
	pc = 0x82A20F84; continue 'dispatch;
	// 82A20ED4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A20ED8: 4BDD3509  bl 0x827f43e0
	ctx.lr = 0x82A20EDC;
	sub_827F43E0(ctx, base);
	// 82A20EDC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20EE0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A20EE4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20EE8: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A20EEC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A20EF0: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A20EF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A20EF8: 4E800421  bctrl
	ctx.lr = 0x82A20EFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A20EFC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A20F00: 41820084  beq 0x82a20f84
	if ctx.cr[0].eq {
	pc = 0x82A20F84; continue 'dispatch;
	}
	// 82A20F04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A20F08: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A20F0C: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A20F10: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 82A20F14: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A20F18: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A20F1C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A20F20: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A20F24: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A20F28: C02ADFAC  lfs f1, -0x2054(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A20F2C: 4845BD15  bl 0x82e7cc40
	ctx.lr = 0x82A20F30;
	sub_82E7CC40(ctx, base);
	// 82A20F30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A20F34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A20F38: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A20F3C: 4BFF2755  bl 0x82a13690
	ctx.lr = 0x82A20F40;
	sub_82A13690(ctx, base);
	// 82A20F40: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 82A20F44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A20F48: 4BFF89C1  bl 0x82a19908
	ctx.lr = 0x82A20F4C;
	sub_82A19908(ctx, base);
	// 82A20F4C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A20F50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A20F54: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A20F58: 4BFF1F89  bl 0x82a12ee0
	ctx.lr = 0x82A20F5C;
	sub_82A12EE0(ctx, base);
	// 82A20F5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A20F60: 4BFF1F99  bl 0x82a12ef8
	ctx.lr = 0x82A20F64;
	sub_82A12EF8(ctx, base);
	// 82A20F64: 48000020  b 0x82a20f84
	pc = 0x82A20F84; continue 'dispatch;
	// 82A20F68: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82A20F6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A20F70: 4BFF8999  bl 0x82a19908
	ctx.lr = 0x82A20F74;
	sub_82A19908(ctx, base);
	// 82A20F74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A20F78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A20F7C: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A20F80: 4BFF1F51  bl 0x82a12ed0
	ctx.lr = 0x82A20F84;
	sub_82A12ED0(ctx, base);
	// 82A20F84: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A20F88: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A20F8C: 48787230  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A20F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A20F90 size=124
    let mut pc: u32 = 0x82A20F90;
    'dispatch: loop {
        match pc {
            0x82A20F90 => {
    //   block [0x82A20F90..0x82A2100C)
	// 82A20F90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A20F94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A20F98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A20F9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A20FA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A20FA4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A20FA8: 419A004C  beq cr6, 0x82a20ff4
	if ctx.cr[6].eq {
	pc = 0x82A20FF4; continue 'dispatch;
	}
	// 82A20FAC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20FB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A20FB4: 419A0018  beq cr6, 0x82a20fcc
	if ctx.cr[6].eq {
	pc = 0x82A20FCC; continue 'dispatch;
	}
	// 82A20FB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20FBC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A20FC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A20FC4: 4E800421  bctrl
	ctx.lr = 0x82A20FC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A20FC8: 4800000C  b 0x82a20fd4
	pc = 0x82A20FD4; continue 'dispatch;
	// 82A20FCC: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82A20FD0: 386B869C  addi r3, r11, -0x7964
	ctx.r[3].s64 = ctx.r[11].s64 + -31076;
	// 82A20FD4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A20FD8: 388B0DA8  addi r4, r11, 0xda8
	ctx.r[4].s64 = ctx.r[11].s64 + 3496;
	// 82A20FDC: 4878711D  bl 0x831a80f8
	ctx.lr = 0x82A20FE0;
	sub_831A80F8(ctx, base);
	// 82A20FE0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A20FE4: 41820010  beq 0x82a20ff4
	if ctx.cr[0].eq {
	pc = 0x82A20FF4; continue 'dispatch;
	}
	// 82A20FE8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20FEC: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82A20FF0: 48000008  b 0x82a20ff8
	pc = 0x82A20FF8; continue 'dispatch;
	// 82A20FF4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A20FF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A20FFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A21000: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A21004: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A21008: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A21010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A21010 size=120
    let mut pc: u32 = 0x82A21010;
    'dispatch: loop {
        match pc {
            0x82A21010 => {
    //   block [0x82A21010..0x82A21088)
	// 82A21010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A21014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A21018: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2101C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A21020: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A21024: 4BFFD125  bl 0x82a1e148
	ctx.lr = 0x82A21028;
	sub_82A1E148(ctx, base);
	// 82A21028: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A2102C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A21030: 394AA52C  addi r10, r10, -0x5ad4
	ctx.r[10].s64 = ctx.r[10].s64 + -23252;
	// 82A21034: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 82A21038: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A2103C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A21040: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A21044: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A21048: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2104C: 913F006C  stw r9, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 82A21050: 388AA100  addi r4, r10, -0x5f00
	ctx.r[4].s64 = ctx.r[10].s64 + -24320;
	// 82A21054: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A21058: 483D29B1  bl 0x82df3a08
	ctx.lr = 0x82A2105C;
	sub_82DF3A08(ctx, base);
	// 82A2105C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A21060: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A21064: 48438685  bl 0x82e596e8
	ctx.lr = 0x82A21068;
	sub_82E596E8(ctx, base);
	// 82A21068: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2106C: 483D23BD  bl 0x82df3428
	ctx.lr = 0x82A21070;
	sub_82DF3428(ctx, base);
	// 82A21070: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A21074: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A21078: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2107C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A21080: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A21084: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A21088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A21088 size=96
    let mut pc: u32 = 0x82A21088;
    'dispatch: loop {
        match pc {
            0x82A21088 => {
    //   block [0x82A21088..0x82A210E8)
	// 82A21088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2108C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A21090: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A21094: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A21098: 4BFFFEF9  bl 0x82a20f90
	ctx.lr = 0x82A2109C;
	sub_82A20F90(ctx, base);
	// 82A2109C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A210A0: 40820030  bne 0x82a210d0
	if !ctx.cr[0].eq {
	pc = 0x82A210D0; continue 'dispatch;
	}
	// 82A210A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A210A8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A210AC: 396B94B4  addi r11, r11, -0x6b4c
	ctx.r[11].s64 = ctx.r[11].s64 + -27468;
	// 82A210B0: 394A1014  addi r10, r10, 0x1014
	ctx.r[10].s64 = ctx.r[10].s64 + 4116;
	// 82A210B4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A210B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A210BC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A210C0: 4B89EF41  bl 0x822c0000
	ctx.lr = 0x82A210C4;
	sub_822C0000(ctx, base);
	// 82A210C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A210C8: 396B0818  addi r11, r11, 0x818
	ctx.r[11].s64 = ctx.r[11].s64 + 2072;
	// 82A210CC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A210D0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A210D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A210D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A210DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A210E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A210E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A210E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A210E8 size=220
    let mut pc: u32 = 0x82A210E8;
    'dispatch: loop {
        match pc {
            0x82A210E8 => {
    //   block [0x82A210E8..0x82A211C4)
	// 82A210E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A210EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A210F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A210F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A210F8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A210FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A21100: 48733501  bl 0x83154600
	ctx.lr = 0x82A21104;
	sub_83154600(ctx, base);
	// 82A21104: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A21108: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A2110C: 388BDDCC  addi r4, r11, -0x2234
	ctx.r[4].s64 = ctx.r[11].s64 + -8756;
	// 82A21110: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A21114: 4BFA7645  bl 0x829c8758
	ctx.lr = 0x82A21118;
	sub_829C8758(ctx, base);
	// 82A21118: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A2111C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82A21120: 409A001C  bne cr6, 0x82a2113c
	if !ctx.cr[6].eq {
	pc = 0x82A2113C; continue 'dispatch;
	}
	// 82A21124: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A21128: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2112C: 419A0008  beq cr6, 0x82a21134
	if ctx.cr[6].eq {
	pc = 0x82A21134; continue 'dispatch;
	}
	// 82A21130: 4B89F761  bl 0x822c0890
	ctx.lr = 0x82A21134;
	sub_822C0890(ctx, base);
	// 82A21134: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A21138: 48000074  b 0x82a211ac
	pc = 0x82A211AC; continue 'dispatch;
	// 82A2113C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A21140: 80BF006C  lwz r5, 0x6c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A21144: 4800AEBD  bl 0x82a2c000
	ctx.lr = 0x82A21148;
	sub_82A2C000(ctx, base);
	// 82A21148: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2114C: 4BFF2535  bl 0x82a13680
	ctx.lr = 0x82A21150;
	sub_82A13680(ctx, base);
	// 82A21150: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 82A21154: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A21158: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A211C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A211C8 size=172
    let mut pc: u32 = 0x82A211C8;
    'dispatch: loop {
        match pc {
            0x82A211C8 => {
    //   block [0x82A211C8..0x82A21274)
	// 82A211C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A211CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A211D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A211D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A211D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A211DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A211E0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A211E4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82A211E8: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 82A211EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A211F0: 4BA71119  bl 0x82492308
	ctx.lr = 0x82A211F4;
	sub_82492308(ctx, base);
	// 82A211F4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A211F8: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82A211FC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A21200: 419A0058  beq cr6, 0x82a21258
	if ctx.cr[6].eq {
	pc = 0x82A21258; continue 'dispatch;
	}
	// 82A21204: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A21208: 3BEB0010  addi r31, r11, 0x10
	ctx.r[31].s64 = ctx.r[11].s64 + 16;
	// 82A2120C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A21210: 419A0018  beq cr6, 0x82a21228
	if ctx.cr[6].eq {
	pc = 0x82A21228; continue 'dispatch;
	}
	// 82A21214: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A21218: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A2121C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A21220: 4E800421  bctrl
	ctx.lr = 0x82A21224;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A21224: 4800000C  b 0x82a21230
	pc = 0x82A21230; continue 'dispatch;
	// 82A21228: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82A2122C: 386B869C  addi r3, r11, -0x7964
	ctx.r[3].s64 = ctx.r[11].s64 + -31076;
	// 82A21230: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A21234: 388B0DA8  addi r4, r11, 0xda8
	ctx.r[4].s64 = ctx.r[11].s64 + 3496;
	// 82A21238: 48786EC1  bl 0x831a80f8
	ctx.lr = 0x82A2123C;
	sub_831A80F8(ctx, base);
	// 82A2123C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A21240: 41820018  beq 0x82a21258
	if ctx.cr[0].eq {
	pc = 0x82A21258; continue 'dispatch;
	}
	// 82A21244: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A21248: 4BFFFE41  bl 0x82a21088
	ctx.lr = 0x82A2124C;
	sub_82A21088(ctx, base);
	// 82A2124C: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82A21250: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A21254: 48000008  b 0x82a2125c
	pc = 0x82A2125C; continue 'dispatch;
	// 82A21258: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A2125C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A21260: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A21264: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A21268: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A2126C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A21270: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A21278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A21278 size=128
    let mut pc: u32 = 0x82A21278;
    'dispatch: loop {
        match pc {
            0x82A21278 => {
    //   block [0x82A21278..0x82A212F8)
	// 82A21278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2127C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A21280: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A21284: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A21288: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2128C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A21290: 48733371  bl 0x83154600
	ctx.lr = 0x82A21294;
	sub_83154600(ctx, base);
	// 82A21294: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A21298: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A2129C: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A212A0: 915F0064  stw r10, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82A212A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A212A8: 3889A1EC  addi r4, r9, -0x5e14
	ctx.r[4].s64 = ctx.r[9].s64 + -24084;
	// 82A212AC: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A212B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A212B4: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A212B8: 483D2751  bl 0x82df3a08
	ctx.lr = 0x82A212BC;
	sub_82DF3A08(ctx, base);
	// 82A212BC: 38BF006C  addi r5, r31, 0x6c
	ctx.r[5].s64 = ctx.r[31].s64 + 108;
	// 82A212C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A212C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A212C8: 4BFFFF01  bl 0x82a211c8
	ctx.lr = 0x82A212CC;
	sub_82A211C8(ctx, base);
	// 82A212CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A212D0: 483D2159  bl 0x82df3428
	ctx.lr = 0x82A212D4;
	sub_82DF3428(ctx, base);
	// 82A212D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A212D8: 809F006C  lwz r4, 0x6c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A212DC: 4BFF1CCD  bl 0x82a12fa8
	ctx.lr = 0x82A212E0;
	sub_82A12FA8(ctx, base);
	// 82A212E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A212E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A212E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A212EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A212F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A212F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A212F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A212F8 size=1244
    let mut pc: u32 = 0x82A212F8;
    'dispatch: loop {
        match pc {
            0x82A212F8 => {
    //   block [0x82A212F8..0x82A217D4)
	// 82A212F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A212FC: 48786E6D  bl 0x831a8168
	ctx.lr = 0x82A21300;
	sub_831A8130(ctx, base);
	// 82A21300: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82A21304: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A21308: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A217D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A217D8 size=44
    let mut pc: u32 = 0x82A217D8;
    'dispatch: loop {
        match pc {
            0x82A217D8 => {
    //   block [0x82A217D8..0x82A21804)
	// 82A217D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A217DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A217E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A217E4: 48732E1D  bl 0x83154600
	ctx.lr = 0x82A217E8;
	sub_83154600(ctx, base);
	// 82A217E8: 4BFF16D9  bl 0x82a12ec0
	ctx.lr = 0x82A217EC;
	sub_82A12EC0(ctx, base);
	// 82A217EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A217F0: 4BFF8FC9  bl 0x82a1a7b8
	ctx.lr = 0x82A217F4;
	sub_82A1A7B8(ctx, base);
	// 82A217F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A217F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A217FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A21800: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A21808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A21808 size=144
    let mut pc: u32 = 0x82A21808;
    'dispatch: loop {
        match pc {
            0x82A21808 => {
    //   block [0x82A21808..0x82A21898)
	// 82A21808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2180C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A21810: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A21814: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A21818: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2181C: 4BFFC92D  bl 0x82a1e148
	ctx.lr = 0x82A21820;
	sub_82A1E148(ctx, base);
	// 82A21820: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A21824: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A21828: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A2182C: 3929A574  addi r9, r9, -0x5a8c
	ctx.r[9].s64 = ctx.r[9].s64 + -23180;
	// 82A21830: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 82A21834: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A21838: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A2183C: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A21840: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A21844: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A21848: 911F006C  stw r8, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[8].u32 ) };
	// 82A2184C: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82A21850: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A21854: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A21858: 98FF0074  stb r7, 0x74(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[7].u8 ) };
	// 82A2185C: 388AA2C4  addi r4, r10, -0x5d3c
	ctx.r[4].s64 = ctx.r[10].s64 + -23868;
	// 82A21860: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82A21864: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82A21868: 483D21A1  bl 0x82df3a08
	ctx.lr = 0x82A2186C;
	sub_82DF3A08(ctx, base);
	// 82A2186C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A21870: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A21874: 48437E75  bl 0x82e596e8
	ctx.lr = 0x82A21878;
	sub_82E596E8(ctx, base);
	// 82A21878: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2187C: 483D1BAD  bl 0x82df3428
	ctx.lr = 0x82A21880;
	sub_82DF3428(ctx, base);
	// 82A21880: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A21884: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A21888: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2188C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A21890: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A21894: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A21898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A21898 size=296
    let mut pc: u32 = 0x82A21898;
    'dispatch: loop {
        match pc {
            0x82A21898 => {
    //   block [0x82A21898..0x82A219C0)
	// 82A21898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2189C: 487868D1  bl 0x831a816c
	ctx.lr = 0x82A218A0;
	sub_831A8130(ctx, base);
	// 82A218A0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A218A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A218A8: 48732D59  bl 0x83154600
	ctx.lr = 0x82A218AC;
	sub_83154600(ctx, base);
	// 82A218AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A218B0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A218B4: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A218B8: 915F0064  stw r10, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82A218BC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A218C0: 3889A130  addi r4, r9, -0x5ed0
	ctx.r[4].s64 = ctx.r[9].s64 + -24272;
	// 82A218C4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A218C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A218CC: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A218D0: 483D2139  bl 0x82df3a08
	ctx.lr = 0x82A218D4;
	sub_82DF3A08(ctx, base);
	// 82A218D4: 3BDF006C  addi r30, r31, 0x6c
	ctx.r[30].s64 = ctx.r[31].s64 + 108;
	// 82A218D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A218DC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A218E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A218E4: 4BFFE305  bl 0x82a1fbe8
	ctx.lr = 0x82A218E8;
	sub_82A1FBE8(ctx, base);
	// 82A218E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A218EC: 483D1B3D  bl 0x82df3428
	ctx.lr = 0x82A218F0;
	sub_82DF3428(ctx, base);
	// 82A218F0: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A218F4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82A218F8: 419A002C  beq cr6, 0x82a21924
	if ctx.cr[6].eq {
	pc = 0x82A21924; continue 'dispatch;
	}
	// 82A218FC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A21900: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A21904: 388BA124  addi r4, r11, -0x5edc
	ctx.r[4].s64 = ctx.r[11].s64 + -24284;
	// 82A21908: 483D2101  bl 0x82df3a08
	ctx.lr = 0x82A2190C;
	sub_82DF3A08(ctx, base);
	// 82A2190C: 38BF0070  addi r5, r31, 0x70
	ctx.r[5].s64 = ctx.r[31].s64 + 112;
	// 82A21910: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A21914: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A21918: 4B912811  bl 0x82334128
	ctx.lr = 0x82A2191C;
	sub_82334128(ctx, base);
	// 82A2191C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A21920: 483D1B09  bl 0x82df3428
	ctx.lr = 0x82A21924;
	sub_82DF3428(ctx, base);
	// 82A21924: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A21928: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A2192C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A21930: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A21934: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82A21938: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82A2193C: 997F0074  stb r11, 0x74(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u8 ) };
	// 82A21940: 4BAEDB89  bl 0x8250f4c8
	ctx.lr = 0x82A21944;
	sub_8250F4C8(ctx, base);
	// 82A21944: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A21948: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2194C: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A21950: 409A0008  bne cr6, 0x82a21958
	if !ctx.cr[6].eq {
	pc = 0x82A21958; continue 'dispatch;
	}
	// 82A21954: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A21958: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A2195C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A21960: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82A21964: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A21968: 48125539  bl 0x82b46ea0
	ctx.lr = 0x82A2196C;
	sub_82B46EA0(ctx, base);
	// 82A2196C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A21970: 3BFF0078  addi r31, r31, 0x78
	ctx.r[31].s64 = ctx.r[31].s64 + 120;
	// 82A21974: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A21978: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82A2197C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A21980: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A21984: 4B8A2ADD  bl 0x822c4460
	ctx.lr = 0x82A21988;
	sub_822C4460(ctx, base);
	// 82A21988: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A2198C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A21990: 419A0008  beq cr6, 0x82a21998
	if ctx.cr[6].eq {
	pc = 0x82A21998; continue 'dispatch;
	}
	// 82A21994: 4B89EEFD  bl 0x822c0890
	ctx.lr = 0x82A21998;
	sub_822C0890(ctx, base);
	// 82A21998: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A2199C: 483D02F5  bl 0x82df1c90
	ctx.lr = 0x82A219A0;
	sub_82DF1C90(ctx, base);
	// 82A219A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A219A4: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A219A8: 4BFF1CD9  bl 0x82a13680
	ctx.lr = 0x82A219AC;
	sub_82A13680(ctx, base);
	// 82A219AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A219B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A219B4: 481251F5  bl 0x82b46ba8
	ctx.lr = 0x82A219B8;
	sub_82B46BA8(ctx, base);
	// 82A219B8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A219BC: 48786800  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A219C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A219C0 size=1472
    let mut pc: u32 = 0x82A219C0;
    'dispatch: loop {
        match pc {
            0x82A219C0 => {
    //   block [0x82A219C0..0x82A21F80)
	// 82A219C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A219C4: 487867A1  bl 0x831a8164
	ctx.lr = 0x82A219C8;
	sub_831A8130(ctx, base);
	// 82A219C8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A219CC: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A219D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A219D4: 48732C2D  bl 0x83154600
	ctx.lr = 0x82A219D8;
	sub_83154600(ctx, base);
	// 82A219D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A219DC: 4BFF14DD  bl 0x82a12eb8
	ctx.lr = 0x82A219E0;
	sub_82A12EB8(ctx, base);
	// 82A219E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A219E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A219E8: 4BFF14D9  bl 0x82a12ec0
	ctx.lr = 0x82A219EC;
	sub_82A12EC0(ctx, base);
	// 82A219EC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A219F0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A219F4: 4800C27D  bl 0x82a2dc70
	ctx.lr = 0x82A219F8;
	sub_82A2DC70(ctx, base);
	// 82A219F8: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A219FC: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A21A00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A21A04: 48437D75  bl 0x82e59778
	ctx.lr = 0x82A21A08;
	sub_82E59778(ctx, base);
	// 82A21A08: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A21A0C: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A21A10: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A21A14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A21A18: 4BE3C3D9  bl 0x8285ddf0
	ctx.lr = 0x82A21A1C;
	sub_8285DDF0(ctx, base);
	// 82A21A1C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A21A20: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82A21A24: 41820008  beq 0x82a21a2c
	if ctx.cr[0].eq {
	pc = 0x82A21A2C; continue 'dispatch;
	}
	// 82A21A28: 9B7F0074  stb r27, 0x74(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[27].u8 ) };
	// 82A21A2C: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A21A30: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A21A34: 41980400  blt cr6, 0x82a21e34
	if ctx.cr[6].lt {
	pc = 0x82A21E34; continue 'dispatch;
	}
	// 82A21A38: 419A0194  beq cr6, 0x82a21bcc
	if ctx.cr[6].eq {
	pc = 0x82A21BCC; continue 'dispatch;
	}
	// 82A21A3C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A21A40: 4198012C  blt cr6, 0x82a21b6c
	if ctx.cr[6].lt {
	pc = 0x82A21B6C; continue 'dispatch;
	}
	// 82A21A44: 409A0520  bne cr6, 0x82a21f64
	if !ctx.cr[6].eq {
	pc = 0x82A21F64; continue 'dispatch;
	}
	// 82A21A48: 897F0074  lbz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A21A4C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A21A50: 4182003C  beq 0x82a21a8c
	if ctx.cr[0].eq {
	pc = 0x82A21A8C; continue 'dispatch;
	}
	// 82A21A54: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A21A58: 4BFF52B1  bl 0x82a16d08
	ctx.lr = 0x82A21A5C;
	sub_82A16D08(ctx, base);
	// 82A21A5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A21A60: 4082002C  bne 0x82a21a8c
	if !ctx.cr[0].eq {
	pc = 0x82A21A8C; continue 'dispatch;
	}
	// 82A21A64: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A21A68: 4800B3B9  bl 0x82a2ce20
	ctx.lr = 0x82A21A6C;
	sub_82A2CE20(ctx, base);
	// 82A21A6C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A21A70: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A21A74: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A21A78: 396BA550  addi r11, r11, -0x5ab0
	ctx.r[11].s64 = ctx.r[11].s64 + -23216;
	// 82A21A7C: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82A21A80: 7DAA5C2E  lfsx f13, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A21A84: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A21A88: 419904DC  bgt cr6, 0x82a21f64
	if ctx.cr[6].gt {
	pc = 0x82A21F64; continue 'dispatch;
	}
	// 82A21A8C: 897F0074  lbz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A21A90: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A21A94: 418200C0  beq 0x82a21b54
	if ctx.cr[0].eq {
	pc = 0x82A21B54; continue 'dispatch;
	}
	// 82A21A98: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A21A9C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82A21AA0: 388B893C  addi r4, r11, -0x76c4
	ctx.r[4].s64 = ctx.r[11].s64 + -30404;
	// 82A21AA4: 483D1F65  bl 0x82df3a08
	ctx.lr = 0x82A21AA8;
	sub_82DF3A08(ctx, base);
	// 82A21AA8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A21AAC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A21AB0: 388BA46C  addi r4, r11, -0x5b94
	ctx.r[4].s64 = ctx.r[11].s64 + -23444;
	// 82A21AB4: 483D1F55  bl 0x82df3a08
	ctx.lr = 0x82A21AB8;
	sub_82DF3A08(ctx, base);
	// 82A21AB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A21ABC: 485E666D  bl 0x83008128
	ctx.lr = 0x82A21AC0;
	sub_83008128(ctx, base);
	// 82A21AC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A21AC4: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82A21AC8: 48438A59  bl 0x82e5a520
	ctx.lr = 0x82A21ACC;
	sub_82E5A520(ctx, base);
	// 82A21ACC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A21AD0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A21AD4: 386B0038  addi r3, r11, 0x38
	ctx.r[3].s64 = ctx.r[11].s64 + 56;
	// 82A21AD8: 3BC10064  addi r30, r1, 0x64
	ctx.r[30].s64 = ctx.r[1].s64 + 100;
	// 82A21ADC: 4B90AD65  bl 0x8232c840
	ctx.lr = 0x82A21AE0;
	sub_8232C840(ctx, base);
	// 82A21AE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A21AE4: 4BFFE09D  bl 0x82a1fb80
	ctx.lr = 0x82A21AE8;
	sub_82A1FB80(ctx, base);
	// 82A21AE8: 806100DC  lwz r3, 0xdc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82A21AEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A21AF0: 419A0008  beq cr6, 0x82a21af8
	if ctx.cr[6].eq {
	pc = 0x82A21AF8; continue 'dispatch;
	}
	// 82A21AF4: 4B89ED9D  bl 0x822c0890
	ctx.lr = 0x82A21AF8;
	sub_822C0890(ctx, base);
	// 82A21AF8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A21AFC: 483D192D  bl 0x82df3428
	ctx.lr = 0x82A21B00;
	sub_82DF3428(ctx, base);
	// 82A21B00: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A21B04: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82A21B08: 388B836C  addi r4, r11, -0x7c94
	ctx.r[4].s64 = ctx.r[11].s64 + -31892;
	// 82A21B0C: 483D1EFD  bl 0x82df3a08
	ctx.lr = 0x82A21B10;
	sub_82DF3A08(ctx, base);
	// 82A21B10: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A21B14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A21B18: 485E6611  bl 0x83008128
	ctx.lr = 0x82A21B1C;
	sub_83008128(ctx, base);
	// 82A21B1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A21B20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A21B24: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A21B28: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A21B2C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A21B30: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A21B34: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A21B38: 4843CE29  bl 0x82e5e960
	ctx.lr = 0x82A21B3C;
	sub_82E5E960(ctx, base);
	// 82A21B3C: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A21B40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A21B44: 419A0008  beq cr6, 0x82a21b4c
	if ctx.cr[6].eq {
	pc = 0x82A21B4C; continue 'dispatch;
	}
	// 82A21B48: 4B89ED49  bl 0x822c0890
	ctx.lr = 0x82A21B4C;
	sub_822C0890(ctx, base);
	// 82A21B4C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82A21B50: 480002DC  b 0x82a21e2c
	pc = 0x82A21E2C; continue 'dispatch;
	// 82A21B54: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A21B58: 4BDCA681  bl 0x827ec1d8
	ctx.lr = 0x82A21B5C;
	sub_827EC1D8(ctx, base);
	// 82A21B5C: 80BF0070  lwz r5, 0x70(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A21B60: 809F006C  lwz r4, 0x6c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A21B64: 4BFFBF8D  bl 0x82a1daf0
	ctx.lr = 0x82A21B68;
	sub_82A1DAF0(ctx, base);
	// 82A21B68: 480003FC  b 0x82a21f64
	pc = 0x82A21F64; continue 'dispatch;
	// 82A21B6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A21B70: 4BDD2871  bl 0x827f43e0
	ctx.lr = 0x82A21B74;
	sub_827F43E0(ctx, base);
	// 82A21B74: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A21B78: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A21B7C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A21B80: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A21B84: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A21B88: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A21B8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A21B90: 4E800421  bctrl
	ctx.lr = 0x82A21B94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A21B94: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A21B98: 418203CC  beq 0x82a21f64
	if ctx.cr[0].eq {
	pc = 0x82A21F64; continue 'dispatch;
	}
	// 82A21B9C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A21BA0: 38800022  li r4, 0x22
	ctx.r[4].s64 = 34;
	// 82A21BA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A21BA8: C02B9EFC  lfs f1, -0x6104(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24836 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A21BAC: 4BFF79BD  bl 0x82a19568
	ctx.lr = 0x82A21BB0;
	sub_82A19568(ctx, base);
	// 82A21BB0: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82A21BB4: D3FF0060  stfs f31, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A21BB8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A21BBC: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A21BC0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A21BC4: 4BFF8BF5  bl 0x82a1a7b8
	ctx.lr = 0x82A21BC8;
	sub_82A1A7B8(ctx, base);
	// 82A21BC8: 4800039C  b 0x82a21f64
	pc = 0x82A21F64; continue 'dispatch;
	// 82A21BCC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A21BD0: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82A21BD4: 4BFF818D  bl 0x82a19d60
	ctx.lr = 0x82A21BD8;
	sub_82A19D60(ctx, base);
	// 82A21BD8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A21BDC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A21BE0: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82A21BE4: 4BFF79ED  bl 0x82a195d0
	ctx.lr = 0x82A21BE8;
	sub_82A195D0(ctx, base);
	// 82A21BE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A21BEC: 4BFF1A9D  bl 0x82a13688
	ctx.lr = 0x82A21BF0;
	sub_82A13688(ctx, base);
	// 82A21BF0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A21BF4: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A21BF8: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82A21BFC: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 82A21C00: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82A21C04: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A21C08: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82A21C0C: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A21C10: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82A21C14: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A21C18: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82A21C1C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A21C20: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82A21C24: C02A02BC  lfs f1, 0x2bc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(700 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A21C28: 4845B6A1  bl 0x82e7d2c8
	ctx.lr = 0x82A21C2C;
	sub_82E7D2C8(ctx, base);
	// 82A21C2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A21C30: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A21C34: 480898A5  bl 0x82aab4d8
	ctx.lr = 0x82A21C38;
	sub_82AAB4D8(ctx, base);
	// 82A21C38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A21C3C: 4BDD27A5  bl 0x827f43e0
	ctx.lr = 0x82A21C40;
	sub_827F43E0(ctx, base);
	// 82A21C40: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A21C44: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A21C48: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A21C4C: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A21C50: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A21C54: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A21C58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A21C5C: 4E800421  bctrl
	ctx.lr = 0x82A21C60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A21C60: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A21C64: 41820104  beq 0x82a21d68
	if ctx.cr[0].eq {
	pc = 0x82A21D68; continue 'dispatch;
	}
	// 82A21C68: 38800015  li r4, 0x15
	ctx.r[4].s64 = 21;
	// 82A21C6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A21C70: 4BFF7C99  bl 0x82a19908
	ctx.lr = 0x82A21C74;
	sub_82A19908(ctx, base);
	// 82A21C74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A21C78: 4BFF7481  bl 0x82a190f8
	ctx.lr = 0x82A21C7C;
	sub_82A190F8(ctx, base);
	// 82A21C7C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A21C80: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A21C84: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A21C88: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A21C8C: 4BFF8B45  bl 0x82a1a7d0
	ctx.lr = 0x82A21C90;
	sub_82A1A7D0(ctx, base);
	// 82A21C90: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A21C94: 4BFF1325  bl 0x82a12fb8
	ctx.lr = 0x82A21C98;
	sub_82A12FB8(ctx, base);
	// 82A21C98: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A21C9C: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 82A21CA0: 4BAED829  bl 0x8250f4c8
	ctx.lr = 0x82A21CA4;
	sub_8250F4C8(ctx, base);
	// 82A21CA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A21CA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A21CAC: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A21CB0: 409A0008  bne cr6, 0x82a21cb8
	if !ctx.cr[6].eq {
	pc = 0x82A21CB8; continue 'dispatch;
	}
	// 82A21CB4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A21CB8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A21CBC: 4BAE8C95  bl 0x8250a950
	ctx.lr = 0x82A21CC0;
	sub_8250A950(ctx, base);
	// 82A21CC0: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 82A21CC4: 483CFFCD  bl 0x82df1c90
	ctx.lr = 0x82A21CC8;
	sub_82DF1C90(ctx, base);
	// 82A21CC8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A21CCC: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82A21CD0: 388BA5D0  addi r4, r11, -0x5a30
	ctx.r[4].s64 = ctx.r[11].s64 + -23088;
	// 82A21CD4: 483D1D35  bl 0x82df3a08
	ctx.lr = 0x82A21CD8;
	sub_82DF3A08(ctx, base);
	// 82A21CD8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A21CDC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A21CE0: 388B2DC8  addi r4, r11, 0x2dc8
	ctx.r[4].s64 = ctx.r[11].s64 + 11720;
	// 82A21CE4: 483D1D25  bl 0x82df3a08
	ctx.lr = 0x82A21CE8;
	sub_82DF3A08(ctx, base);
	// 82A21CE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A21CEC: 4BDCDA4D  bl 0x827ef738
	ctx.lr = 0x82A21CF0;
	sub_827EF738(ctx, base);
	// 82A21CF0: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A21CF4: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A21CF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A21CFC: 3BCBFF40  addi r30, r11, -0xc0
	ctx.r[30].s64 = ctx.r[11].s64 + -192;
	// 82A21D00: 409A0008  bne cr6, 0x82a21d08
	if !ctx.cr[6].eq {
	pc = 0x82A21D08; continue 'dispatch;
	}
	// 82A21D04: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A21D08: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82A21D0C: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82A21D10: 3BA1006C  addi r29, r1, 0x6c
	ctx.r[29].s64 = ctx.r[1].s64 + 108;
	// 82A21D14: 483F331D  bl 0x82e15030
	ctx.lr = 0x82A21D18;
	sub_82E15030(ctx, base);
	// 82A21D18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A21D1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A21D20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A21D24: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A21D28: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A21D2C: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A21D30: 4BDB2471  bl 0x827d41a0
	ctx.lr = 0x82A21D34;
	sub_827D41A0(ctx, base);
	// 82A21D34: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A21D38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A21D3C: 419A0008  beq cr6, 0x82a21d44
	if ctx.cr[6].eq {
	pc = 0x82A21D44; continue 'dispatch;
	}
	// 82A21D40: 4B89EB51  bl 0x822c0890
	ctx.lr = 0x82A21D44;
	sub_822C0890(ctx, base);
	// 82A21D44: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A21D48: 483D16E1  bl 0x82df3428
	ctx.lr = 0x82A21D4C;
	sub_82DF3428(ctx, base);
	// 82A21D4C: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82A21D50: 483D16D9  bl 0x82df3428
	ctx.lr = 0x82A21D54;
	sub_82DF3428(ctx, base);
	// 82A21D54: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A21D58: 483CFF39  bl 0x82df1c90
	ctx.lr = 0x82A21D5C;
	sub_82DF1C90(ctx, base);
	// 82A21D5C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A21D60: 388BA5C0  addi r4, r11, -0x5a40
	ctx.r[4].s64 = ctx.r[11].s64 + -23104;
	// 82A21D64: 480001E8  b 0x82a21f4c
	pc = 0x82A21F4C; continue 'dispatch;
	// 82A21D68: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A21D6C: 4BFF4F9D  bl 0x82a16d08
	ctx.lr = 0x82A21D70;
	sub_82A16D08(ctx, base);
	// 82A21D70: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A21D74: 418201F0  beq 0x82a21f64
	if ctx.cr[0].eq {
	pc = 0x82A21F64; continue 'dispatch;
	}
	// 82A21D78: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A21D7C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A21D80: 388BA2C4  addi r4, r11, -0x5d3c
	ctx.r[4].s64 = ctx.r[11].s64 + -23868;
	// 82A21D84: 483D1C85  bl 0x82df3a08
	ctx.lr = 0x82A21D88;
	sub_82DF3A08(ctx, base);
	// 82A21D88: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A21D8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A21D90: 388BA46C  addi r4, r11, -0x5b94
	ctx.r[4].s64 = ctx.r[11].s64 + -23444;
	// 82A21D94: 483D1C75  bl 0x82df3a08
	ctx.lr = 0x82A21D98;
	sub_82DF3A08(ctx, base);
	// 82A21D98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A21D9C: 485E638D  bl 0x83008128
	ctx.lr = 0x82A21DA0;
	sub_83008128(ctx, base);
	// 82A21DA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A21DA4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A21DA8: 48438779  bl 0x82e5a520
	ctx.lr = 0x82A21DAC;
	sub_82E5A520(ctx, base);
	// 82A21DAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A21DB0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A21DB4: 386B0038  addi r3, r11, 0x38
	ctx.r[3].s64 = ctx.r[11].s64 + 56;
	// 82A21DB8: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82A21DBC: 4B90AA85  bl 0x8232c840
	ctx.lr = 0x82A21DC0;
	sub_8232C840(ctx, base);
	// 82A21DC0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A21DC4: 4BFFDDBD  bl 0x82a1fb80
	ctx.lr = 0x82A21DC8;
	sub_82A1FB80(ctx, base);
	// 82A21DC8: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A21DCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A21DD0: 419A0008  beq cr6, 0x82a21dd8
	if ctx.cr[6].eq {
	pc = 0x82A21DD8; continue 'dispatch;
	}
	// 82A21DD4: 4B89EABD  bl 0x822c0890
	ctx.lr = 0x82A21DD8;
	sub_822C0890(ctx, base);
	// 82A21DD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A21DDC: 483D164D  bl 0x82df3428
	ctx.lr = 0x82A21DE0;
	sub_82DF3428(ctx, base);
	// 82A21DE0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A21DE4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82A21DE8: 388B836C  addi r4, r11, -0x7c94
	ctx.r[4].s64 = ctx.r[11].s64 + -31892;
	// 82A21DEC: 483D1C1D  bl 0x82df3a08
	ctx.lr = 0x82A21DF0;
	sub_82DF3A08(ctx, base);
	// 82A21DF0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A21DF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A21DF8: 485E6331  bl 0x83008128
	ctx.lr = 0x82A21DFC;
	sub_83008128(ctx, base);
	// 82A21DFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A21E00: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A21E04: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A21E08: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A21E0C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A21E10: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A21E14: 4843CB4D  bl 0x82e5e960
	ctx.lr = 0x82A21E18;
	sub_82E5E960(ctx, base);
	// 82A21E18: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A21E1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A21E20: 419A0008  beq cr6, 0x82a21e28
	if ctx.cr[6].eq {
	pc = 0x82A21E28; continue 'dispatch;
	}
	// 82A21E24: 4B89EA6D  bl 0x822c0890
	ctx.lr = 0x82A21E28;
	sub_822C0890(ctx, base);
	// 82A21E28: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A21E2C: 483D15FD  bl 0x82df3428
	ctx.lr = 0x82A21E30;
	sub_82DF3428(ctx, base);
	// 82A21E30: 48000134  b 0x82a21f64
	pc = 0x82A21F64; continue 'dispatch;
	// 82A21E34: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A21E38: 38800016  li r4, 0x16
	ctx.r[4].s64 = 22;
	// 82A21E3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A21E40: C02B9EFC  lfs f1, -0x6104(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24836 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A21E44: 4BFF7725  bl 0x82a19568
	ctx.lr = 0x82A21E48;
	sub_82A19568(ctx, base);
	// 82A21E48: 897F0074  lbz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A21E4C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A21E50: 41820024  beq 0x82a21e74
	if ctx.cr[0].eq {
	pc = 0x82A21E74; continue 'dispatch;
	}
	// 82A21E54: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A21E58: 4800AFC9  bl 0x82a2ce20
	ctx.lr = 0x82A21E5C;
	sub_82A2CE20(ctx, base);
	// 82A21E5C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A21E60: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A21E64: 396BA550  addi r11, r11, -0x5ab0
	ctx.r[11].s64 = ctx.r[11].s64 + -23216;
	// 82A21E68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A21E6C: 7C2A5C2E  lfsx f1, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A21E70: 4BFF7209  bl 0x82a19078
	ctx.lr = 0x82A21E74;
	sub_82A19078(ctx, base);
	// 82A21E74: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A21E78: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A21E7C: 4BAED64D  bl 0x8250f4c8
	ctx.lr = 0x82A21E80;
	sub_8250F4C8(ctx, base);
	// 82A21E80: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A21E84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A21E88: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A21E8C: 409A0008  bne cr6, 0x82a21e94
	if !ctx.cr[6].eq {
	pc = 0x82A21E94; continue 'dispatch;
	}
	// 82A21E90: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A21E94: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A21E98: 4BAE8AB9  bl 0x8250a950
	ctx.lr = 0x82A21E9C;
	sub_8250A950(ctx, base);
	// 82A21E9C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A21EA0: 483CFDF1  bl 0x82df1c90
	ctx.lr = 0x82A21EA4;
	sub_82DF1C90(ctx, base);
	// 82A21EA4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A21EA8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A21EAC: 388BA5AC  addi r4, r11, -0x5a54
	ctx.r[4].s64 = ctx.r[11].s64 + -23124;
	// 82A21EB0: 483D1B59  bl 0x82df3a08
	ctx.lr = 0x82A21EB4;
	sub_82DF3A08(ctx, base);
	// 82A21EB4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A21EB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A21EBC: 388B2DC8  addi r4, r11, 0x2dc8
	ctx.r[4].s64 = ctx.r[11].s64 + 11720;
	// 82A21EC0: 483D1B49  bl 0x82df3a08
	ctx.lr = 0x82A21EC4;
	sub_82DF3A08(ctx, base);
	// 82A21EC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A21EC8: 4BDCD871  bl 0x827ef738
	ctx.lr = 0x82A21ECC;
	sub_827EF738(ctx, base);
	// 82A21ECC: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82A21ED0: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A21ED4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A21ED8: 3BCBFF40  addi r30, r11, -0xc0
	ctx.r[30].s64 = ctx.r[11].s64 + -192;
	// 82A21EDC: 409A0008  bne cr6, 0x82a21ee4
	if !ctx.cr[6].eq {
	pc = 0x82A21EE4; continue 'dispatch;
	}
	// 82A21EE0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A21EE4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A21EE8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82A21EEC: 3B810068  addi r28, r1, 0x68
	ctx.r[28].s64 = ctx.r[1].s64 + 104;
	// 82A21EF0: 483F3141  bl 0x82e15030
	ctx.lr = 0x82A21EF4;
	sub_82E15030(ctx, base);
	// 82A21EF4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A21EF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A21EFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A21F00: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A21F04: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A21F08: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A21F0C: 4BDB2295  bl 0x827d41a0
	ctx.lr = 0x82A21F10;
	sub_827D41A0(ctx, base);
	// 82A21F10: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A21F14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A21F18: 419A0008  beq cr6, 0x82a21f20
	if ctx.cr[6].eq {
	pc = 0x82A21F20; continue 'dispatch;
	}
	// 82A21F1C: 4B89E975  bl 0x822c0890
	ctx.lr = 0x82A21F20;
	sub_822C0890(ctx, base);
	// 82A21F20: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A21F24: 483D1505  bl 0x82df3428
	ctx.lr = 0x82A21F28;
	sub_82DF3428(ctx, base);
	// 82A21F28: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A21F2C: 483D14FD  bl 0x82df3428
	ctx.lr = 0x82A21F30;
	sub_82DF3428(ctx, base);
	// 82A21F30: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A21F34: 483CFD5D  bl 0x82df1c90
	ctx.lr = 0x82A21F38;
	sub_82DF1C90(ctx, base);
	// 82A21F38: 937F0064  stw r27, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 82A21F3C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A21F40: 4BFF1059  bl 0x82a12f98
	ctx.lr = 0x82A21F44;
	sub_82A12F98(ctx, base);
	// 82A21F44: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A21F48: 388BA598  addi r4, r11, -0x5a68
	ctx.r[4].s64 = ctx.r[11].s64 + -23144;
	// 82A21F4C: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82A21F50: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A21F54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A21F58: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A21F5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A21F60: 4E800421  bctrl
	ctx.lr = 0x82A21F64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A21F64: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A21F68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A21F6C: 419A0008  beq cr6, 0x82a21f74
	if ctx.cr[6].eq {
	pc = 0x82A21F74; continue 'dispatch;
	}
	// 82A21F70: 4B89E921  bl 0x822c0890
	ctx.lr = 0x82A21F74;
	sub_822C0890(ctx, base);
	// 82A21F74: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 82A21F78: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A21F7C: 48786238  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A21F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A21F80 size=112
    let mut pc: u32 = 0x82A21F80;
    'dispatch: loop {
        match pc {
            0x82A21F80 => {
    //   block [0x82A21F80..0x82A21FF0)
	// 82A21F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A21F84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A21F88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A21F8C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A21F90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A21F94: 4BFFC1B5  bl 0x82a1e148
	ctx.lr = 0x82A21F98;
	sub_82A1E148(ctx, base);
	// 82A21F98: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A21F9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A21FA0: 394AA5E4  addi r10, r10, -0x5a1c
	ctx.r[10].s64 = ctx.r[10].s64 + -23068;
	// 82A21FA4: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A21FA8: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A21FAC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A21FB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A21FB4: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A21FB8: 3889A0F4  addi r4, r9, -0x5f0c
	ctx.r[4].s64 = ctx.r[9].s64 + -24332;
	// 82A21FBC: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A21FC0: 483D1A49  bl 0x82df3a08
	ctx.lr = 0x82A21FC4;
	sub_82DF3A08(ctx, base);
	// 82A21FC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A21FC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A21FCC: 4843771D  bl 0x82e596e8
	ctx.lr = 0x82A21FD0;
	sub_82E596E8(ctx, base);
	// 82A21FD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A21FD4: 483D1455  bl 0x82df3428
	ctx.lr = 0x82A21FD8;
	sub_82DF3428(ctx, base);
	// 82A21FD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A21FDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A21FE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A21FE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A21FE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A21FEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A21FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A21FF0 size=780
    let mut pc: u32 = 0x82A21FF0;
    'dispatch: loop {
        match pc {
            0x82A21FF0 => {
    //   block [0x82A21FF0..0x82A222FC)
	// 82A21FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A21FF4: 48786171  bl 0x831a8164
	ctx.lr = 0x82A21FF8;
	sub_831A8130(ctx, base);
	// 82A21FF8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A21FFC: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A22000: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A22004: 487325FD  bl 0x83154600
	ctx.lr = 0x82A22008;
	sub_83154600(ctx, base);
	// 82A22008: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A2200C: 4BFF0EAD  bl 0x82a12eb8
	ctx.lr = 0x82A22010;
	sub_82A12EB8(ctx, base);
	// 82A22010: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A22014: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A22018: 4BFF0EA9  bl 0x82a12ec0
	ctx.lr = 0x82A2201C;
	sub_82A12EC0(ctx, base);
	// 82A2201C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A22020: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A22024: 388BDDCC  addi r4, r11, -0x2234
	ctx.r[4].s64 = ctx.r[11].s64 + -8756;
	// 82A22028: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A2202C: 4BFA672D  bl 0x829c8758
	ctx.lr = 0x82A22030;
	sub_829C8758(ctx, base);
	// 82A22030: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A22034: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A22038: 419A025C  beq cr6, 0x82a22294
	if ctx.cr[6].eq {
	pc = 0x82A22294; continue 'dispatch;
	}
	// 82A2203C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A22040: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A22044: 4800A075  bl 0x82a2c0b8
	ctx.lr = 0x82A22048;
	sub_82A2C0B8(ctx, base);
	// 82A22048: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2204C: 41820248  beq 0x82a22294
	if ctx.cr[0].eq {
	pc = 0x82A22294; continue 'dispatch;
	}
	// 82A22050: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A22054: 48437725  bl 0x82e59778
	ctx.lr = 0x82A22058;
	sub_82E59778(ctx, base);
	// 82A22058: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A2205C: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A22060: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A22064: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A22068: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A2206C: 419801E8  blt cr6, 0x82a22254
	if ctx.cr[6].lt {
	pc = 0x82A22254; continue 'dispatch;
	}
	// 82A22070: 419A0124  beq cr6, 0x82a22194
	if ctx.cr[6].eq {
	pc = 0x82A22194; continue 'dispatch;
	}
	// 82A22074: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A22078: 419800CC  blt cr6, 0x82a22144
	if ctx.cr[6].lt {
	pc = 0x82A22144; continue 'dispatch;
	}
	// 82A2207C: 419A007C  beq cr6, 0x82a220f8
	if ctx.cr[6].eq {
	pc = 0x82A220F8; continue 'dispatch;
	}
	// 82A22080: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82A22084: 4098025C  bge cr6, 0x82a222e0
	if !ctx.cr[6].lt {
	pc = 0x82A222E0; continue 'dispatch;
	}
	// 82A22088: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A2208C: 4BDD2355  bl 0x827f43e0
	ctx.lr = 0x82A22090;
	sub_827F43E0(ctx, base);
	// 82A22090: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A22094: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A22098: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2209C: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A220A0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A220A4: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A220A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A220AC: 4E800421  bctrl
	ctx.lr = 0x82A220B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A220B0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A220B4: 4182022C  beq 0x82a222e0
	if ctx.cr[0].eq {
	pc = 0x82A222E0; continue 'dispatch;
	}
	// 82A220B8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A220BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A220C0: 388B893C  addi r4, r11, -0x76c4
	ctx.r[4].s64 = ctx.r[11].s64 + -30404;
	// 82A220C4: 483D1945  bl 0x82df3a08
	ctx.lr = 0x82A220C8;
	sub_82DF3A08(ctx, base);
	// 82A220C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A220CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A220D0: 485E6059  bl 0x83008128
	ctx.lr = 0x82A220D4;
	sub_83008128(ctx, base);
	// 82A220D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A220D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A220DC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A220E0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A220E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A220E8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A220EC: 4843C875  bl 0x82e5e960
	ctx.lr = 0x82A220F0;
	sub_82E5E960(ctx, base);
	// 82A220F0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A220F4: 480001E0  b 0x82a222d4
	pc = 0x82A222D4; continue 'dispatch;
	// 82A220F8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A220FC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A22100: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82A22104: 816B9F14  lwz r11, -0x60ec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24812 as u32) ) } as u64;
	// 82A22108: C1AA9528  lfs f13, -0x6ad8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A2210C: C189980C  lfs f12, -0x67f4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-26612 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A22110: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82A22114: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A22118: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 82A2211C: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82A22120: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A22124: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82A22128: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A2212C: 419801B4  blt cr6, 0x82a222e0
	if ctx.cr[6].lt {
	pc = 0x82A222E0; continue 'dispatch;
	}
	// 82A22130: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A22134: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A22138: 4BFF8681  bl 0x82a1a7b8
	ctx.lr = 0x82A2213C;
	sub_82A1A7B8(ctx, base);
	// 82A2213C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82A22140: 4800004C  b 0x82a2218c
	pc = 0x82A2218C; continue 'dispatch;
	// 82A22144: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A22148: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A2214C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82A22150: 816B9F10  lwz r11, -0x60f0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24816 as u32) ) } as u64;
	// 82A22154: C1AA9528  lfs f13, -0x6ad8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A22158: C189980C  lfs f12, -0x67f4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-26612 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A2215C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82A22160: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A22164: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 82A22168: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82A2216C: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A22170: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82A22174: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A22178: 41980168  blt cr6, 0x82a222e0
	if ctx.cr[6].lt {
	pc = 0x82A222E0; continue 'dispatch;
	}
	// 82A2217C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A22180: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A22184: 4BFF864D  bl 0x82a1a7d0
	ctx.lr = 0x82A22188;
	sub_82A1A7D0(ctx, base);
	// 82A22188: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82A2218C: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A22190: 48000150  b 0x82a222e0
	pc = 0x82A222E0; continue 'dispatch;
	// 82A22194: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A22198: 80BF0068  lwz r5, 0x68(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A2219C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A221A0: 48009E61  bl 0x82a2c000
	ctx.lr = 0x82A221A4;
	sub_82A2C000(ctx, base);
	// 82A221A4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A221A8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A221AC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A221B0: 4BFF7421  bl 0x82a195d0
	ctx.lr = 0x82A221B4;
	sub_82A195D0(ctx, base);
	// 82A221B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A221B8: 4BFF14D1  bl 0x82a13688
	ctx.lr = 0x82A221BC;
	sub_82A13688(ctx, base);
	// 82A221BC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A221C0: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A221C4: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82A221C8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82A221CC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A221D0: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A221D4: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82A221D8: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A221DC: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82A221E0: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A221E4: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82A221E8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A221EC: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82A221F0: C02A02BC  lfs f1, 0x2bc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(700 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A221F4: 4845B0D5  bl 0x82e7d2c8
	ctx.lr = 0x82A221F8;
	sub_82E7D2C8(ctx, base);
	// 82A221F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A221FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A22200: 480892D9  bl 0x82aab4d8
	ctx.lr = 0x82A22204;
	sub_82AAB4D8(ctx, base);
	// 82A22204: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A22208: 4BDD21D9  bl 0x827f43e0
	ctx.lr = 0x82A2220C;
	sub_827F43E0(ctx, base);
	// 82A2220C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A22210: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A22214: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A22218: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A2221C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A22220: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A22224: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A22228: 4E800421  bctrl
	ctx.lr = 0x82A2222C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A2222C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A22230: 418200B0  beq 0x82a222e0
	if ctx.cr[0].eq {
	pc = 0x82A222E0; continue 'dispatch;
	}
	// 82A22234: 38800015  li r4, 0x15
	ctx.r[4].s64 = 21;
	// 82A22238: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A2223C: 4BFF76CD  bl 0x82a19908
	ctx.lr = 0x82A22240;
	sub_82A19908(ctx, base);
	// 82A22240: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A22244: D3FF0060  stfs f31, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A22248: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A2224C: 388AA5C0  addi r4, r10, -0x5a40
	ctx.r[4].s64 = ctx.r[10].s64 + -23104;
	// 82A22250: 48000024  b 0x82a22274
	pc = 0x82A22274; continue 'dispatch;
	// 82A22254: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A22258: 38800016  li r4, 0x16
	ctx.r[4].s64 = 22;
	// 82A2225C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A22260: C02B9EFC  lfs f1, -0x6104(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24836 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A22264: 4BFF7305  bl 0x82a19568
	ctx.lr = 0x82A22268;
	sub_82A19568(ctx, base);
	// 82A22268: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A2226C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A22270: 388AA598  addi r4, r10, -0x5a68
	ctx.r[4].s64 = ctx.r[10].s64 + -23144;
	// 82A22274: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A22278: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A2227C: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A22280: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A22284: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A22288: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A2228C: 4E800421  bctrl
	ctx.lr = 0x82A22290;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A22290: 48000050  b 0x82a222e0
	pc = 0x82A222E0; continue 'dispatch;
	// 82A22294: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A22298: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2229C: 388B893C  addi r4, r11, -0x76c4
	ctx.r[4].s64 = ctx.r[11].s64 + -30404;
	// 82A222A0: 483D1769  bl 0x82df3a08
	ctx.lr = 0x82A222A4;
	sub_82DF3A08(ctx, base);
	// 82A222A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A222A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A222AC: 485E5E7D  bl 0x83008128
	ctx.lr = 0x82A222B0;
	sub_83008128(ctx, base);
	// 82A222B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A222B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A222B8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A222BC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A222C0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A222C4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A222C8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A222CC: 4843C695  bl 0x82e5e960
	ctx.lr = 0x82A222D0;
	sub_82E5E960(ctx, base);
	// 82A222D0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A222D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A222D8: 419A0008  beq cr6, 0x82a222e0
	if ctx.cr[6].eq {
	pc = 0x82A222E0; continue 'dispatch;
	}
	// 82A222DC: 4B89E5B5  bl 0x822c0890
	ctx.lr = 0x82A222E0;
	sub_822C0890(ctx, base);
	// 82A222E0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A222E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A222E8: 419A0008  beq cr6, 0x82a222f0
	if ctx.cr[6].eq {
	pc = 0x82A222F0; continue 'dispatch;
	}
	// 82A222EC: 4B89E5A5  bl 0x822c0890
	ctx.lr = 0x82A222F0;
	sub_822C0890(ctx, base);
	// 82A222F0: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82A222F4: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A222F8: 48785EBC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A22300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A22300 size=244
    let mut pc: u32 = 0x82A22300;
    'dispatch: loop {
        match pc {
            0x82A22300 => {
    //   block [0x82A22300..0x82A223F4)
	// 82A22300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A22304: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A22308: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A2230C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A22310: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A22314: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A22318: 487322E9  bl 0x83154600
	ctx.lr = 0x82A2231C;
	sub_83154600(ctx, base);
	// 82A2231C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A22320: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A22324: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A22328: 915F0064  stw r10, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82A2232C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A22330: 3889A1EC  addi r4, r9, -0x5e14
	ctx.r[4].s64 = ctx.r[9].s64 + -24084;
	// 82A22334: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A22338: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2233C: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A22340: 483D16C9  bl 0x82df3a08
	ctx.lr = 0x82A22344;
	sub_82DF3A08(ctx, base);
	// 82A22344: 38BF0068  addi r5, r31, 0x68
	ctx.r[5].s64 = ctx.r[31].s64 + 104;
	// 82A22348: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A2234C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A22350: 4BFFEE79  bl 0x82a211c8
	ctx.lr = 0x82A22354;
	sub_82A211C8(ctx, base);
	// 82A22354: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A22358: 483D10D1  bl 0x82df3428
	ctx.lr = 0x82A2235C;
	sub_82DF3428(ctx, base);
	// 82A2235C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A22360: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A22364: 4BAED165  bl 0x8250f4c8
	ctx.lr = 0x82A22368;
	sub_8250F4C8(ctx, base);
	// 82A22368: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2236C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A22370: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A22374: 409A0008  bne cr6, 0x82a2237c
	if !ctx.cr[6].eq {
	pc = 0x82A2237C; continue 'dispatch;
	}
	// 82A22378: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A2237C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A22380: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A22384: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82A22388: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A2238C: 48124B15  bl 0x82b46ea0
	ctx.lr = 0x82A22390;
	sub_82B46EA0(ctx, base);
	// 82A22390: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A22394: 3BFF006C  addi r31, r31, 0x6c
	ctx.r[31].s64 = ctx.r[31].s64 + 108;
	// 82A22398: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A2239C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82A223A0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A223A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A223A8: 4B8A20B9  bl 0x822c4460
	ctx.lr = 0x82A223AC;
	sub_822C4460(ctx, base);
	// 82A223AC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A223B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A223B4: 419A0008  beq cr6, 0x82a223bc
	if ctx.cr[6].eq {
	pc = 0x82A223BC; continue 'dispatch;
	}
	// 82A223B8: 4B89E4D9  bl 0x822c0890
	ctx.lr = 0x82A223BC;
	sub_822C0890(ctx, base);
	// 82A223BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A223C0: 483CF8D1  bl 0x82df1c90
	ctx.lr = 0x82A223C4;
	sub_82DF1C90(ctx, base);
	// 82A223C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A223C8: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A223CC: 4BFF12B5  bl 0x82a13680
	ctx.lr = 0x82A223D0;
	sub_82A13680(ctx, base);
	// 82A223D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A223D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A223D8: 481247D1  bl 0x82b46ba8
	ctx.lr = 0x82A223DC;
	sub_82B46BA8(ctx, base);
	// 82A223DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A223E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A223E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A223E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A223EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A223F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A223F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A223F8 size=52
    let mut pc: u32 = 0x82A223F8;
    'dispatch: loop {
        match pc {
            0x82A223F8 => {
    //   block [0x82A223F8..0x82A2242C)
	// 82A223F8: 81630070  lwz r11, 0x70(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A223FC: C004001C  lfs f0, 0x1c(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A22400: 91640020  stw r11, 0x20(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82A22404: C1A30080  lfs f13, 0x80(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A22408: D1A40024  stfs f13, 0x24(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82A2240C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A22410: C1A30080  lfs f13, 0x80(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A22414: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A22418: 40990008  ble cr6, 0x82a22420
	if !ctx.cr[6].gt {
	pc = 0x82A22420; continue 'dispatch;
	}
	// 82A2241C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A22420: 99640028  stb r11, 0x28(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(40 as u32), ctx.r[11].u8 ) };
	// 82A22424: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A22428: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A22430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A22430 size=72
    let mut pc: u32 = 0x82A22430;
    'dispatch: loop {
        match pc {
            0x82A22430 => {
    //   block [0x82A22430..0x82A22478)
	// 82A22430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A22434: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A22438: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2243C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A22440: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A22444: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A22448: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82A2244C: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82A22450: 8964001C  lbz r11, 0x1c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A22454: 997F0078  stb r11, 0x78(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u8 ) };
	// 82A22458: 485E5CD1  bl 0x83008128
	ctx.lr = 0x82A2245C;
	sub_83008128(ctx, base);
	// 82A2245C: 907F0090  stw r3, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[3].u32 ) };
	// 82A22460: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A22464: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A22468: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2246C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A22470: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A22474: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A22478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A22478 size=160
    let mut pc: u32 = 0x82A22478;
    'dispatch: loop {
        match pc {
            0x82A22478 => {
    //   block [0x82A22478..0x82A22518)
	// 82A22478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2247C: 48785CED  bl 0x831a8168
	ctx.lr = 0x82A22480;
	sub_831A8130(ctx, base);
	// 82A22480: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A22484: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A22488: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A2248C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A22490: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82A22494: 41820034  beq 0x82a224c8
	if ctx.cr[0].eq {
	pc = 0x82A224C8; continue 'dispatch;
	}
	// 82A22498: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2249C: 487874ED  bl 0x831a9988
	ctx.lr = 0x82A224A0;
	sub_831A9988(ctx, base);
	// 82A224A0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82A224A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A224A8: 386B3BDC  addi r3, r11, 0x3bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 15324;
	// 82A224AC: 48785C4D  bl 0x831a80f8
	ctx.lr = 0x82A224B0;
	sub_831A80F8(ctx, base);
	// 82A224B0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A224B4: 41820014  beq 0x82a224c8
	if ctx.cr[0].eq {
	pc = 0x82A224C8; continue 'dispatch;
	}
	// 82A224B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A224BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A224C0: 4BFFFF39  bl 0x82a223f8
	ctx.lr = 0x82A224C4;
	sub_82A223F8(ctx, base);
	// 82A224C4: 4800004C  b 0x82a22510
	pc = 0x82A22510; continue 'dispatch;
	// 82A224C8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A224CC: 419A0034  beq cr6, 0x82a22500
	if ctx.cr[6].eq {
	pc = 0x82A22500; continue 'dispatch;
	}
	// 82A224D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A224D4: 487874B5  bl 0x831a9988
	ctx.lr = 0x82A224D8;
	sub_831A9988(ctx, base);
	// 82A224D8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82A224DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A224E0: 386B3BB4  addi r3, r11, 0x3bb4
	ctx.r[3].s64 = ctx.r[11].s64 + 15284;
	// 82A224E4: 48785C15  bl 0x831a80f8
	ctx.lr = 0x82A224E8;
	sub_831A80F8(ctx, base);
	// 82A224E8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A224EC: 41820014  beq 0x82a22500
	if ctx.cr[0].eq {
	pc = 0x82A22500; continue 'dispatch;
	}
	// 82A224F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A224F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A224F8: 4BFFFF39  bl 0x82a22430
	ctx.lr = 0x82A224FC;
	sub_82A22430(ctx, base);
	// 82A224FC: 48000014  b 0x82a22510
	pc = 0x82A22510; continue 'dispatch;
	// 82A22500: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A22504: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A22508: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2250C: 4875BF7D  bl 0x8317e488
	ctx.lr = 0x82A22510;
	sub_8317E488(ctx, base);
	// 82A22510: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A22514: 48785CA4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A22518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A22518 size=212
    let mut pc: u32 = 0x82A22518;
    'dispatch: loop {
        match pc {
            0x82A22518 => {
    //   block [0x82A22518..0x82A225EC)
	// 82A22518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2251C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A22520: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A22524: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A22528: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2252C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A22530: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82A22534: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A22538: 419A009C  beq cr6, 0x82a225d4
	if ctx.cr[6].eq {
	pc = 0x82A225D4; continue 'dispatch;
	}
	// 82A2253C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A22540: 811F0084  lwz r8, 0x84(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A22544: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A22548: 392AA758  addi r9, r10, -0x58a8
	ctx.r[9].s64 = ctx.r[10].s64 + -22696;
	// 82A2254C: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82A22550: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A22554: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A22558: 419A0018  beq cr6, 0x82a22570
	if ctx.cr[6].eq {
	pc = 0x82A22570; continue 'dispatch;
	}
	// 82A2255C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A22560: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82A22564: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A22568: 4198FFE8  blt cr6, 0x82a22550
	if ctx.cr[6].lt {
	pc = 0x82A22550; continue 'dispatch;
	}
	// 82A2256C: 48000068  b 0x82a225d4
	pc = 0x82A225D4; continue 'dispatch;
	// 82A22570: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A22574: C1BF007C  lfs f13, 0x7c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A22578: 39490004  addi r10, r9, 4
	ctx.r[10].s64 = ctx.r[9].s64 + 4;
	// 82A2257C: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A22580: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A22584: 41990050  bgt cr6, 0x82a225d4
	if ctx.cr[6].gt {
	pc = 0x82A225D4; continue 'dispatch;
	}
	// 82A22588: C1BF0080  lfs f13, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A2258C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A22590: 40980044  bge cr6, 0x82a225d4
	if !ctx.cr[6].lt {
	pc = 0x82A225D4; continue 'dispatch;
	}
	// 82A22594: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A22598: 48732069  bl 0x83154600
	ctx.lr = 0x82A2259C;
	sub_83154600(ctx, base);
	// 82A2259C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A225A0: 4BFF0FF9  bl 0x82a13598
	ctx.lr = 0x82A225A4;
	sub_82A13598(ctx, base);
	// 82A225A4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A225A8: 816B02CC  lwz r11, 0x2cc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(716 as u32) ) } as u64;
	// 82A225AC: 7C8B1851  subf. r4, r11, r3
	ctx.r[4].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82A225B0: 4181001C  bgt 0x82a225cc
	if ctx.cr[0].gt {
	pc = 0x82A225CC; continue 'dispatch;
	}
	// 82A225B4: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82A225B8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A225BC: 815F00C4  lwz r10, 0xc4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A225C0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A225C4: 40990008  ble cr6, 0x82a225cc
	if !ctx.cr[6].gt {
	pc = 0x82A225CC; continue 'dispatch;
	}
	// 82A225C8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A225CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A225D0: 4BDC35C1  bl 0x827e5b90
	ctx.lr = 0x82A225D4;
	sub_827E5B90(ctx, base);
	// 82A225D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A225D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A225DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A225E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A225E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A225E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A225F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A225F0 size=120
    let mut pc: u32 = 0x82A225F0;
    'dispatch: loop {
        match pc {
            0x82A225F0 => {
    //   block [0x82A225F0..0x82A22668)
	// 82A225F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A225F4: 48785B79  bl 0x831a816c
	ctx.lr = 0x82A225F8;
	sub_831A8130(ctx, base);
	// 82A225F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A225FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A22600: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A22604: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A22608: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A2260C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A22610: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82A22614: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82A22618: 483CFDD1  bl 0x82df23e8
	ctx.lr = 0x82A2261C;
	sub_82DF23E8(ctx, base);
	// 82A2261C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A22620: 41820014  beq 0x82a22634
	if ctx.cr[0].eq {
	pc = 0x82A22634; continue 'dispatch;
	}
	// 82A22624: 889F0000  lbz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A22628: 4BF32B19  bl 0x82955140
	ctx.lr = 0x82A2262C;
	sub_82955140(ctx, base);
	// 82A2262C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A22630: 48000008  b 0x82a22638
	pc = 0x82A22638; continue 'dispatch;
	// 82A22634: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A22638: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A2263C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A22640: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A22644: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A22648: 4BF02ED1  bl 0x82925518
	ctx.lr = 0x82A2264C;
	sub_82925518(ctx, base);
	// 82A2264C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A22650: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A22654: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A22658: 4B89D9A9  bl 0x822c0000
	ctx.lr = 0x82A2265C;
	sub_822C0000(ctx, base);
	// 82A2265C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A22660: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A22664: 48785B58  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A22668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A22668 size=404
    let mut pc: u32 = 0x82A22668;
    'dispatch: loop {
        match pc {
            0x82A22668 => {
    //   block [0x82A22668..0x82A227FC)
	// 82A22668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2266C: 48785AF9  bl 0x831a8164
	ctx.lr = 0x82A22670;
	sub_831A8130(ctx, base);
	// 82A22670: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A22674: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A22678: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2267C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82A22680: 48731F81  bl 0x83154600
	ctx.lr = 0x82A22684;
	sub_83154600(ctx, base);
	// 82A22684: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A22688: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A2268C: 388BA760  addi r4, r11, -0x58a0
	ctx.r[4].s64 = ctx.r[11].s64 + -22688;
	// 82A22690: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A22694: 38A00197  li r5, 0x197
	ctx.r[5].s64 = 407;
	// 82A22698: 386000C4  li r3, 0xc4
	ctx.r[3].s64 = 196;
	// 82A2269C: 483CFD4D  bl 0x82df23e8
	ctx.lr = 0x82A226A0;
	sub_82DF23E8(ctx, base);
	// 82A226A0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A226A4: 4182003C  beq 0x82a226e0
	if ctx.cr[0].eq {
	pc = 0x82A226E0; continue 'dispatch;
	}
	// 82A226A8: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82A226AC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A226B0: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82A226B4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A226B8: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A226BC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82A226C0: 7FAA5A14  add r29, r10, r11
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A226C4: 4BFF1805  bl 0x82a13ec8
	ctx.lr = 0x82A226C8;
	sub_82A13EC8(ctx, base);
	// 82A226C8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A226CC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A226D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A226D4: 4816F5BD  bl 0x82b91c90
	ctx.lr = 0x82A226D8;
	sub_82B91C90(ctx, base);
	// 82A226D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A226DC: 48000008  b 0x82a226e4
	pc = 0x82A226E4; continue 'dispatch;
	// 82A226E0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A226E4: 3BFF00C8  addi r31, r31, 0xc8
	ctx.r[31].s64 = ctx.r[31].s64 + 200;
	// 82A226E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A226EC: 4BF994B5  bl 0x829bbba0
	ctx.lr = 0x82A226F0;
	sub_829BBBA0(ctx, base);
	// 82A226F0: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A226F4: 41820014  beq 0x82a22708
	if ctx.cr[0].eq {
	pc = 0x82A22708; continue 'dispatch;
	}
	// 82A226F8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A226FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A22700: 419A0008  beq cr6, 0x82a22708
	if ctx.cr[6].eq {
	pc = 0x82A22708; continue 'dispatch;
	}
	// 82A22704: 4B89E18D  bl 0x822c0890
	ctx.lr = 0x82A22708;
	sub_822C0890(ctx, base);
	// 82A22708: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82A2270C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A22710: 388B059C  addi r4, r11, 0x59c
	ctx.r[4].s64 = ctx.r[11].s64 + 1436;
	// 82A22714: 483D12F5  bl 0x82df3a08
	ctx.lr = 0x82A22718;
	sub_82DF3A08(ctx, base);
	// 82A22718: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A2271C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A22720: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A22724: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A22728: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A2272C: 419A0024  beq cr6, 0x82a22750
	if ctx.cr[6].eq {
	pc = 0x82A22750; continue 'dispatch;
	}
	// 82A22730: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A22734: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A22738: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A2273C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A22740: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A22744: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A22748: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A2274C: 4082FFE8  bne 0x82a22734
	if !ctx.cr[0].eq {
	pc = 0x82A22734; continue 'dispatch;
	}
	// 82A22750: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A22754: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A22758: 4BAECD71  bl 0x8250f4c8
	ctx.lr = 0x82A2275C;
	sub_8250F4C8(ctx, base);
	// 82A2275C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A22760: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A22764: 3BABFFFC  addi r29, r11, -4
	ctx.r[29].s64 = ctx.r[11].s64 + -4;
	// 82A22768: 409A0008  bne cr6, 0x82a22770
	if !ctx.cr[6].eq {
	pc = 0x82A22770; continue 'dispatch;
	}
	// 82A2276C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A22770: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A22774: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A22778: 4BAECD51  bl 0x8250f4c8
	ctx.lr = 0x82A2277C;
	sub_8250F4C8(ctx, base);
	// 82A2277C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A22780: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A22784: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 82A22788: 409A0008  bne cr6, 0x82a22790
	if !ctx.cr[6].eq {
	pc = 0x82A22790; continue 'dispatch;
	}
	// 82A2278C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A22790: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A22794: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A22798: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A2279C: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 82A227A0: 4BAE8EB1  bl 0x8250b650
	ctx.lr = 0x82A227A4;
	sub_8250B650(ctx, base);
	// 82A227A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A227A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A227AC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A227B0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A227B4: 4BAEAD55  bl 0x8250d508
	ctx.lr = 0x82A227B8;
	sub_8250D508(ctx, base);
	// 82A227B8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A227BC: 483CF4D5  bl 0x82df1c90
	ctx.lr = 0x82A227C0;
	sub_82DF1C90(ctx, base);
	// 82A227C0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A227C4: 483CF4CD  bl 0x82df1c90
	ctx.lr = 0x82A227C8;
	sub_82DF1C90(ctx, base);
	// 82A227C8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A227CC: 483CF4C5  bl 0x82df1c90
	ctx.lr = 0x82A227D0;
	sub_82DF1C90(ctx, base);
	// 82A227D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A227D4: 483D0C55  bl 0x82df3428
	ctx.lr = 0x82A227D8;
	sub_82DF3428(ctx, base);
	// 82A227D8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A227DC: 4816BE65  bl 0x82b8e640
	ctx.lr = 0x82A227E0;
	sub_82B8E640(ctx, base);
	// 82A227E0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A227E4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A227E8: 4816BEA9  bl 0x82b8e690
	ctx.lr = 0x82A227EC;
	sub_82B8E690(ctx, base);
	// 82A227EC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A227F0: 4816CE01  bl 0x82b8f5f0
	ctx.lr = 0x82A227F4;
	sub_82B8F5F0(ctx, base);
	// 82A227F4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A227F8: 487859BC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A22800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A22800 size=200
    let mut pc: u32 = 0x82A22800;
    'dispatch: loop {
        match pc {
            0x82A22800 => {
    //   block [0x82A22800..0x82A228C8)
	// 82A22800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A22804: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A22808: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A2280C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A22810: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A22814: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A22818: 48731DE9  bl 0x83154600
	ctx.lr = 0x82A2281C;
	sub_83154600(ctx, base);
	// 82A2281C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A22820: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A22824: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82A22828: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A2282C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A22830: 4BFFFDC1  bl 0x82a225f0
	ctx.lr = 0x82A22834;
	sub_82A225F0(ctx, base);
	// 82A22834: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A22838: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A2283C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A22840: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A22844: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A22848: 419A0024  beq cr6, 0x82a2286c
	if ctx.cr[6].eq {
	pc = 0x82A2286C; continue 'dispatch;
	}
	// 82A2284C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A22850: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A22854: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A22858: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A2285C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A22860: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A22864: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A22868: 4082FFE8  bne 0x82a22850
	if !ctx.cr[0].eq {
	pc = 0x82A22850; continue 'dispatch;
	}
	// 82A2286C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A22870: 80DF0090  lwz r6, 0x90(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82A22874: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A22878: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82A2287C: 388AA760  addi r4, r10, -0x58a0
	ctx.r[4].s64 = ctx.r[10].s64 + -22688;
	// 82A22880: 38A001A7  li r5, 0x1a7
	ctx.r[5].s64 = 423;
	// 82A22884: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82A22888: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A2288C: 484361B5  bl 0x82e58a40
	ctx.lr = 0x82A22890;
	sub_82E58A40(ctx, base);
	// 82A22890: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A22894: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A22898: 419A0008  beq cr6, 0x82a228a0
	if ctx.cr[6].eq {
	pc = 0x82A228A0; continue 'dispatch;
	}
	// 82A2289C: 4B89DFF5  bl 0x822c0890
	ctx.lr = 0x82A228A0;
	sub_822C0890(ctx, base);
	// 82A228A0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A228A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A228A8: 419A0008  beq cr6, 0x82a228b0
	if ctx.cr[6].eq {
	pc = 0x82A228B0; continue 'dispatch;
	}
	// 82A228AC: 4B89DFE5  bl 0x822c0890
	ctx.lr = 0x82A228B0;
	sub_822C0890(ctx, base);
	// 82A228B0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A228B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A228B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A228BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A228C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A228C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A228C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A228C8 size=276
    let mut pc: u32 = 0x82A228C8;
    'dispatch: loop {
        match pc {
            0x82A228C8 => {
    //   block [0x82A228C8..0x82A229DC)
	// 82A228C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A228CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A228D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A228D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A228D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A228DC: 816300C4  lwz r11, 0xc4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A228E0: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 82A228E4: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 82A228E8: 916300C4  stw r11, 0xc4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 82A228EC: 48731D15  bl 0x83154600
	ctx.lr = 0x82A228F0;
	sub_83154600(ctx, base);
	// 82A228F0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A228F4: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82A228F8: 38CB6910  addi r6, r11, 0x6910
	ctx.r[6].s64 = ctx.r[11].s64 + 26896;
	// 82A228FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A22900: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 82A22904: 388A8604  addi r4, r10, -0x79fc
	ctx.r[4].s64 = ctx.r[10].s64 + -31228;
	// 82A22908: 38A1009C  addi r5, r1, 0x9c
	ctx.r[5].s64 = ctx.r[1].s64 + 156;
	// 82A2290C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A22910: 4B9F4AB1  bl 0x824173c0
	ctx.lr = 0x82A22914;
	sub_824173C0(ctx, base);
	// 82A22914: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A22918: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A2291C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A22920: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A22924: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A22928: 419A0024  beq cr6, 0x82a2294c
	if ctx.cr[6].eq {
	pc = 0x82A2294C; continue 'dispatch;
	}
	// 82A2292C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A22930: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A22934: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A22938: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A2293C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A22940: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A22944: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A22948: 4082FFE8  bne 0x82a22930
	if !ctx.cr[0].eq {
	pc = 0x82A22930; continue 'dispatch;
	}
	// 82A2294C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A22950: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A22954: 4BAECB75  bl 0x8250f4c8
	ctx.lr = 0x82A22958;
	sub_8250F4C8(ctx, base);
	// 82A22958: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2295C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A22960: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A22964: 409A0008  bne cr6, 0x82a2296c
	if !ctx.cr[6].eq {
	pc = 0x82A2296C; continue 'dispatch;
	}
	// 82A22968: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A2296C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A22970: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82A22974: 4BAE60A5  bl 0x82508a18
	ctx.lr = 0x82A22978;
	sub_82508A18(ctx, base);
	// 82A22978: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A2297C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A22980: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A22984: 388AA760  addi r4, r10, -0x58a0
	ctx.r[4].s64 = ctx.r[10].s64 + -22688;
	// 82A22988: 38A001F4  li r5, 0x1f4
	ctx.r[5].s64 = 500;
	// 82A2298C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A22990: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A22994: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A22998: 484360A9  bl 0x82e58a40
	ctx.lr = 0x82A2299C;
	sub_82E58A40(ctx, base);
	// 82A2299C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A229A0: 483CF2F1  bl 0x82df1c90
	ctx.lr = 0x82A229A4;
	sub_82DF1C90(ctx, base);
	// 82A229A4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A229A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A229AC: 419A0008  beq cr6, 0x82a229b4
	if ctx.cr[6].eq {
	pc = 0x82A229B4; continue 'dispatch;
	}
	// 82A229B0: 4B89DEE1  bl 0x822c0890
	ctx.lr = 0x82A229B4;
	sub_822C0890(ctx, base);
	// 82A229B4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A229B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A229BC: 419A0008  beq cr6, 0x82a229c4
	if ctx.cr[6].eq {
	pc = 0x82A229C4; continue 'dispatch;
	}
	// 82A229C0: 4B89DED1  bl 0x822c0890
	ctx.lr = 0x82A229C4;
	sub_822C0890(ctx, base);
	// 82A229C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A229C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A229CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A229D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A229D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A229D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A229E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A229E0 size=1040
    let mut pc: u32 = 0x82A229E0;
    'dispatch: loop {
        match pc {
            0x82A229E0 => {
    //   block [0x82A229E0..0x82A22DF0)
	// 82A229E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A229E4: 4878577D  bl 0x831a8160
	ctx.lr = 0x82A229E8;
	sub_831A8130(ctx, base);
	// 82A229E8: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 82A229EC: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82A229F0: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A229F4: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A229F8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A229FC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A22A00: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82A22A04: 3BEBDD80  addi r31, r11, -0x2280
	ctx.r[31].s64 = ctx.r[11].s64 + -8832;
	// 82A22A08: 816ADDB0  lwz r11, -0x2250(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8784 as u32) ) } as u64;
	// 82A22A0C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A22A10: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A22A14: 556707FF  clrlwi. r7, r11, 0x1f
	ctx.r[7].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82A22A18: C00831E0  lfs f0, 0x31e0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12768 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A22A1C: 40820064  bne 0x82a22a80
	if !ctx.cr[0].eq {
	pc = 0x82A22A80; continue 'dispatch;
	}
	// 82A22A20: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A22A24: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A22A28: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A22A2C: D3FF000C  stfs f31, 0xc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A22A30: 3CE0820B  lis r7, -0x7df5
	ctx.r[7].s64 = -2113208320;
	// 82A22A34: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82A22A38: 3CC0820B  lis r6, -0x7df5
	ctx.r[6].s64 = -2113208320;
	// 82A22A3C: D3FF001C  stfs f31, 0x1c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82A22A40: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 82A22A44: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82A22A48: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82A22A4C: C1A9A7CC  lfs f13, -0x5834(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-22580 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A22A50: C188A7C8  lfs f12, -0x5838(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-22584 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A22A54: C167A7C4  lfs f11, -0x583c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-22588 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A22A58: 916ADDB0  stw r11, -0x2250(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8784 as u32), ctx.r[11].u32 ) };
	// 82A22A5C: C146A7C0  lfs f10, -0x5840(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-22592 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82A22A60: C125A7BC  lfs f9, -0x5844(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-22596 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82A22A64: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A22A68: D19F0008  stfs f12, 8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A22A6C: D17F0010  stfs f11, 0x10(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82A22A70: D15F0018  stfs f10, 0x18(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A22A74: D13F0020  stfs f9, 0x20(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82A22A78: D3FF0028  stfs f31, 0x28(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82A22A7C: D3FF002C  stfs f31, 0x2c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82A22A80: 3D208338  lis r9, -0x7cc8
	ctx.r[9].s64 = -2093481984;
	// 82A22A84: 556807BD  rlwinm. r8, r11, 0, 0x1e, 0x1e
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82A22A88: 3BC9DD50  addi r30, r9, -0x22b0
	ctx.r[30].s64 = ctx.r[9].s64 + -8880;
	// 82A22A8C: 40820064  bne 0x82a22af0
	if !ctx.cr[0].eq {
	pc = 0x82A22AF0; continue 'dispatch;
	}
	// 82A22A90: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A22A94: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A22A98: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A22A9C: D3FE000C  stfs f31, 0xc(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A22AA0: 3CE0820B  lis r7, -0x7df5
	ctx.r[7].s64 = -2113208320;
	// 82A22AA4: D01E0014  stfs f0, 0x14(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82A22AA8: 3CC0820B  lis r6, -0x7df5
	ctx.r[6].s64 = -2113208320;
	// 82A22AAC: D3FE001C  stfs f31, 0x1c(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82A22AB0: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 82A22AB4: D01E0024  stfs f0, 0x24(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82A22AB8: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 82A22ABC: C1A9A7B8  lfs f13, -0x5848(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-22600 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A22AC0: C188A7B4  lfs f12, -0x584c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-22604 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A22AC4: C167A7B0  lfs f11, -0x5850(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-22608 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A22AC8: 916ADDB0  stw r11, -0x2250(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8784 as u32), ctx.r[11].u32 ) };
	// 82A22ACC: C146A7AC  lfs f10, -0x5854(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-22612 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82A22AD0: C125A7A8  lfs f9, -0x5858(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-22616 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82A22AD4: D1BE0000  stfs f13, 0(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A22AD8: D19E0008  stfs f12, 8(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A22ADC: D17E0010  stfs f11, 0x10(r30)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82A22AE0: D15E0018  stfs f10, 0x18(r30)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A22AE4: D13E0020  stfs f9, 0x20(r30)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82A22AE8: D3FE0028  stfs f31, 0x28(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82A22AEC: D3FE002C  stfs f31, 0x2c(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82A22AF0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A22AF4: 48731B0D  bl 0x83154600
	ctx.lr = 0x82A22AF8;
	sub_83154600(ctx, base);
	// 82A22AF8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A22AFC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A22B00: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A22B04: 4BAEC9C5  bl 0x8250f4c8
	ctx.lr = 0x82A22B08;
	sub_8250F4C8(ctx, base);
	// 82A22B08: 817B0068  lwz r11, 0x68(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A22B0C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A22B10: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A22B14: 7C8BFA14  add r4, r11, r31
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A22B18: 4B951FC1  bl 0x82374ad8
	ctx.lr = 0x82A22B1C;
	sub_82374AD8(ctx, base);
	// 82A22B1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A22B20: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A22B24: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A22B28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A22B2C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A22B30: 419A0024  beq cr6, 0x82a22b54
	if ctx.cr[6].eq {
	pc = 0x82A22B54; continue 'dispatch;
	}
	// 82A22B34: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A22B38: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A22B3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A22B40: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A22B44: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A22B48: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A22B4C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A22B50: 4082FFE8  bne 0x82a22b38
	if !ctx.cr[0].eq {
	pc = 0x82A22B38; continue 'dispatch;
	}
	// 82A22B54: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A22B58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A22B5C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A22B60: 409A0008  bne cr6, 0x82a22b68
	if !ctx.cr[6].eq {
	pc = 0x82A22B68; continue 'dispatch;
	}
	// 82A22B64: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A22B68: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A22B6C: 3BFD0028  addi r31, r29, 0x28
	ctx.r[31].s64 = ctx.r[29].s64 + 40;
	// 82A22B70: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 82A22B74: 4BAE5EA5  bl 0x82508a18
	ctx.lr = 0x82A22B78;
	sub_82508A18(ctx, base);
	// 82A22B78: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A22B7C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A22B80: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A22B84: 3BABA760  addi r29, r11, -0x58a0
	ctx.r[29].s64 = ctx.r[11].s64 + -22688;
	// 82A22B88: 38A00231  li r5, 0x231
	ctx.r[5].s64 = 561;
	// 82A22B8C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A22B90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A22B94: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A22B98: 48435EA9  bl 0x82e58a40
	ctx.lr = 0x82A22B9C;
	sub_82E58A40(ctx, base);
	// 82A22B9C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A22BA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A22BA4: 419A0008  beq cr6, 0x82a22bac
	if ctx.cr[6].eq {
	pc = 0x82A22BAC; continue 'dispatch;
	}
	// 82A22BA8: 4B89DCE9  bl 0x822c0890
	ctx.lr = 0x82A22BAC;
	sub_822C0890(ctx, base);
	// 82A22BAC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A22BB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A22BB4: 419A0008  beq cr6, 0x82a22bbc
	if ctx.cr[6].eq {
	pc = 0x82A22BBC; continue 'dispatch;
	}
	// 82A22BB8: 4B89DCD9  bl 0x822c0890
	ctx.lr = 0x82A22BBC;
	sub_822C0890(ctx, base);
	// 82A22BBC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A22BC0: D3E100A0  stfs f31, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82A22BC4: D3E100A8  stfs f31, 0xa8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82A22BC8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A22BCC: D3E100AC  stfs f31, 0xac(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82A22BD0: 3F808212  lis r28, -0x7dee
	ctx.r[28].s64 = -2112749568;
	// 82A22BD4: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82A22BD8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82A22BDC: C3CB08A8  lfs f30, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A22BE0: D3C100A4  stfs f30, 0xa4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82A22BE4: C1AA9450  lfs f13, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A22BE8: C01CDFAC  lfs f0, -0x2054(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A22BEC: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82A22BF0: 4845A051  bl 0x82e7cc40
	ctx.lr = 0x82A22BF4;
	sub_82E7CC40(ctx, base);
	// 82A22BF4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A22BF8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A22BFC: 4BA3D82D  bl 0x82460428
	ctx.lr = 0x82A22C00;
	sub_82460428(ctx, base);
	// 82A22C00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A22C04: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A22C08: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A22C0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A22C10: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A22C14: 419A0024  beq cr6, 0x82a22c38
	if ctx.cr[6].eq {
	pc = 0x82A22C38; continue 'dispatch;
	}
	// 82A22C18: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A22C1C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A22C20: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A22C24: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A22C28: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A22C2C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A22C30: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A22C34: 4082FFE8  bne 0x82a22c1c
	if !ctx.cr[0].eq {
	pc = 0x82A22C1C; continue 'dispatch;
	}
	// 82A22C38: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A22C3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A22C40: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A22C44: 409A0008  bne cr6, 0x82a22c4c
	if !ctx.cr[6].eq {
	pc = 0x82A22C4C; continue 'dispatch;
	}
	// 82A22C48: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A22C4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A22C50: 3B410058  addi r26, r1, 0x58
	ctx.r[26].s64 = ctx.r[1].s64 + 88;
	// 82A22C54: 4BAE5DC5  bl 0x82508a18
	ctx.lr = 0x82A22C58;
	sub_82508A18(ctx, base);
	// 82A22C58: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A22C5C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A22C60: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A22C64: 38A00232  li r5, 0x232
	ctx.r[5].s64 = 562;
	// 82A22C68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A22C6C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82A22C70: 48435DD1  bl 0x82e58a40
	ctx.lr = 0x82A22C74;
	sub_82E58A40(ctx, base);
	// 82A22C74: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A22C78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A22C7C: 419A0008  beq cr6, 0x82a22c84
	if ctx.cr[6].eq {
	pc = 0x82A22C84; continue 'dispatch;
	}
	// 82A22C80: 4B89DC11  bl 0x822c0890
	ctx.lr = 0x82A22C84;
	sub_822C0890(ctx, base);
	// 82A22C84: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A22C88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A22C8C: 419A0008  beq cr6, 0x82a22c94
	if ctx.cr[6].eq {
	pc = 0x82A22C94; continue 'dispatch;
	}
	// 82A22C90: 4B89DC01  bl 0x822c0890
	ctx.lr = 0x82A22C94;
	sub_822C0890(ctx, base);
	// 82A22C94: 817B0068  lwz r11, 0x68(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A22C98: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A22C9C: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A22CA0: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A22CA4: 4B951E35  bl 0x82374ad8
	ctx.lr = 0x82A22CA8;
	sub_82374AD8(ctx, base);
	// 82A22CA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A22CAC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A22CB0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A22CB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A22CB8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A22CBC: 419A0024  beq cr6, 0x82a22ce0
	if ctx.cr[6].eq {
	pc = 0x82A22CE0; continue 'dispatch;
	}
	// 82A22CC0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A22CC4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A22CC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A22CCC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A22CD0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A22CD4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A22CD8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A22CDC: 4082FFE8  bne 0x82a22cc4
	if !ctx.cr[0].eq {
	pc = 0x82A22CC4; continue 'dispatch;
	}
	// 82A22CE0: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 82A22CE4: 4BFF01C5  bl 0x82a12ea8
	ctx.lr = 0x82A22CE8;
	sub_82A12EA8(ctx, base);
	// 82A22CE8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A22CEC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A22CF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A22CF4: 38A00235  li r5, 0x235
	ctx.r[5].s64 = 565;
	// 82A22CF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A22CFC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A22D00: 48435D41  bl 0x82e58a40
	ctx.lr = 0x82A22D04;
	sub_82E58A40(ctx, base);
	// 82A22D04: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A22D08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A22D0C: 419A0008  beq cr6, 0x82a22d14
	if ctx.cr[6].eq {
	pc = 0x82A22D14; continue 'dispatch;
	}
	// 82A22D10: 4B89DB81  bl 0x822c0890
	ctx.lr = 0x82A22D14;
	sub_822C0890(ctx, base);
	// 82A22D14: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A22D18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A22D1C: 419A0008  beq cr6, 0x82a22d24
	if ctx.cr[6].eq {
	pc = 0x82A22D24; continue 'dispatch;
	}
	// 82A22D20: 4B89DB71  bl 0x822c0890
	ctx.lr = 0x82A22D24;
	sub_822C0890(ctx, base);
	// 82A22D24: D3E100B0  stfs f31, 0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82A22D28: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A22D2C: D3C100B4  stfs f30, 0xb4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82A22D30: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82A22D34: D3E100B8  stfs f31, 0xb8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82A22D38: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82A22D3C: D3E100BC  stfs f31, 0xbc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82A22D40: C01CDFAC  lfs f0, -0x2054(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A22D44: C1AB9530  lfs f13, -0x6ad0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27344 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A22D48: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82A22D4C: 48459EF5  bl 0x82e7cc40
	ctx.lr = 0x82A22D50;
	sub_82E7CC40(ctx, base);
	// 82A22D50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A22D54: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A22D58: 4BA3D6D1  bl 0x82460428
	ctx.lr = 0x82A22D5C;
	sub_82460428(ctx, base);
	// 82A22D5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A22D60: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A22D64: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A22D68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A22D6C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A22D70: 419A0024  beq cr6, 0x82a22d94
	if ctx.cr[6].eq {
	pc = 0x82A22D94; continue 'dispatch;
	}
	// 82A22D74: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A22D78: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A22D7C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A22D80: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A22D84: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A22D88: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A22D8C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A22D90: 4082FFE8  bne 0x82a22d78
	if !ctx.cr[0].eq {
	pc = 0x82A22D78; continue 'dispatch;
	}
	// 82A22D94: 3BC10068  addi r30, r1, 0x68
	ctx.r[30].s64 = ctx.r[1].s64 + 104;
	// 82A22D98: 4BFF0111  bl 0x82a12ea8
	ctx.lr = 0x82A22D9C;
	sub_82A12EA8(ctx, base);
	// 82A22D9C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A22DA0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A22DA4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A22DA8: 38A00236  li r5, 0x236
	ctx.r[5].s64 = 566;
	// 82A22DAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A22DB0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A22DB4: 48435C8D  bl 0x82e58a40
	ctx.lr = 0x82A22DB8;
	sub_82E58A40(ctx, base);
	// 82A22DB8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A22DBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A22DC0: 419A0008  beq cr6, 0x82a22dc8
	if ctx.cr[6].eq {
	pc = 0x82A22DC8; continue 'dispatch;
	}
	// 82A22DC4: 4B89DACD  bl 0x822c0890
	ctx.lr = 0x82A22DC8;
	sub_822C0890(ctx, base);
	// 82A22DC8: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A22DCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A22DD0: 419A0008  beq cr6, 0x82a22dd8
	if ctx.cr[6].eq {
	pc = 0x82A22DD8; continue 'dispatch;
	}
	// 82A22DD4: 4B89DABD  bl 0x822c0890
	ctx.lr = 0x82A22DD8;
	sub_822C0890(ctx, base);
	// 82A22DD8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A22DDC: 483CEEB5  bl 0x82df1c90
	ctx.lr = 0x82A22DE0;
	sub_82DF1C90(ctx, base);
	// 82A22DE0: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82A22DE4: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82A22DE8: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82A22DEC: 487853C4  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A22DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A22DF0 size=168
    let mut pc: u32 = 0x82A22DF0;
    'dispatch: loop {
        match pc {
            0x82A22DF0 => {
    //   block [0x82A22DF0..0x82A22E98)
	// 82A22DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A22DF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A22DF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A22DFC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A22E00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A22E04: 897F007B  lbz r11, 0x7b(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(123 as u32) ) } as u64;
	// 82A22E08: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A22E0C: 41820078  beq 0x82a22e84
	if ctx.cr[0].eq {
	pc = 0x82A22E84; continue 'dispatch;
	}
	// 82A22E10: C01F0080  lfs f0, 0x80(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A22E14: D01F007C  stfs f0, 0x7c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82A22E18: 48436961  bl 0x82e59778
	ctx.lr = 0x82A22E1C;
	sub_82E59778(ctx, base);
	// 82A22E1C: C01F0080  lfs f0, 0x80(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A22E20: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A22E24: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82A22E28: 807F00C8  lwz r3, 0xc8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82A22E2C: 4816B715  bl 0x82b8e540
	ctx.lr = 0x82A22E30;
	sub_82B8E540(ctx, base);
	// 82A22E30: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A22E34: 40820050  bne 0x82a22e84
	if !ctx.cr[0].eq {
	pc = 0x82A22E84; continue 'dispatch;
	}
	// 82A22E38: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82A22E3C: 815F008C  lwz r10, 0x8c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A22E40: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A22E44: 917F0088  stw r11, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82A22E48: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A22E4C: 41980030  blt cr6, 0x82a22e7c
	if ctx.cr[6].lt {
	pc = 0x82A22E7C; continue 'dispatch;
	}
	// 82A22E50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A22E54: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A22E58: 997F007B  stb r11, 0x7b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(123 as u32), ctx.r[11].u8 ) };
	// 82A22E5C: 995F0079  stb r10, 0x79(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(121 as u32), ctx.r[10].u8 ) };
	// 82A22E60: 917F00C8  stw r11, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 82A22E64: 807F00CC  lwz r3, 0xcc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A22E68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A22E6C: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 82A22E70: 419A0014  beq cr6, 0x82a22e84
	if ctx.cr[6].eq {
	pc = 0x82A22E84; continue 'dispatch;
	}
	// 82A22E74: 4B89DA1D  bl 0x822c0890
	ctx.lr = 0x82A22E78;
	sub_822C0890(ctx, base);
	// 82A22E78: 4800000C  b 0x82a22e84
	pc = 0x82A22E84; continue 'dispatch;
	// 82A22E7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A22E80: 4BFFF7E9  bl 0x82a22668
	ctx.lr = 0x82A22E84;
	sub_82A22668(ctx, base);
	// 82A22E84: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A22E88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A22E8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A22E90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A22E94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A22E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A22E98 size=244
    let mut pc: u32 = 0x82A22E98;
    'dispatch: loop {
        match pc {
            0x82A22E98 => {
    //   block [0x82A22E98..0x82A22F8C)
	// 82A22E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A22E9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A22EA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A22EA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A22EA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A22EAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A22EB0: 4BFFB299  bl 0x82a1e148
	ctx.lr = 0x82A22EB4;
	sub_82A1E148(ctx, base);
	// 82A22EB4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A22EB8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A22EBC: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A22EC0: 390B6910  addi r8, r11, 0x6910
	ctx.r[8].s64 = ctx.r[11].s64 + 26896;
	// 82A22EC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A22EC8: 3929A7D4  addi r9, r9, -0x582c
	ctx.r[9].s64 = ctx.r[9].s64 + -22572;
	// 82A22ECC: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 82A22ED0: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A22ED4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A22ED8: D01F007C  stfs f0, 0x7c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82A22EDC: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82A22EE0: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A22EE4: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82A22EE8: 394000A0  li r10, 0xa0
	ctx.r[10].s64 = 160;
	// 82A22EEC: 997F0078  stb r11, 0x78(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u8 ) };
	// 82A22EF0: 392000B0  li r9, 0xb0
	ctx.r[9].s64 = 176;
	// 82A22EF4: 997F0079  stb r11, 0x79(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(121 as u32), ctx.r[11].u8 ) };
	// 82A22EF8: 3CC08202  lis r6, -0x7dfe
	ctx.r[6].s64 = -2113798144;
	// 82A22EFC: 997F007A  stb r11, 0x7a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(122 as u32), ctx.r[11].u8 ) };
	// 82A22F00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A22F04: 997F007B  stb r11, 0x7b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(123 as u32), ctx.r[11].u8 ) };
	// 82A22F08: 388631AC  addi r4, r6, 0x31ac
	ctx.r[4].s64 = ctx.r[6].s64 + 12716;
	// 82A22F0C: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82A22F10: 3BDF00D0  addi r30, r31, 0xd0
	ctx.r[30].s64 = ctx.r[31].s64 + 208;
	// 82A22F14: 917F0088  stw r11, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82A22F18: 917F008C  stw r11, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82A22F1C: 90FF0090  stw r7, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[7].u32 ) };
	// 82A22F20: 13E040C7  vcmpequd (lvx128) v31, v0, v8
	tmp.u32 = ctx.r[8].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A22F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A22F90 size=104
    let mut pc: u32 = 0x82A22F90;
    'dispatch: loop {
        match pc {
            0x82A22F90 => {
    //   block [0x82A22F90..0x82A22FF8)
	// 82A22F90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A22F94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A22F98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A22F9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A22FA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A22FA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A22FA8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A22FAC: 387F00D0  addi r3, r31, 0xd0
	ctx.r[3].s64 = ctx.r[31].s64 + 208;
	// 82A22FB0: 4BA8E2F1  bl 0x824b12a0
	ctx.lr = 0x82A22FB4;
	sub_824B12A0(ctx, base);
	// 82A22FB4: 807F00CC  lwz r3, 0xcc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A22FB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A22FBC: 419A0008  beq cr6, 0x82a22fc4
	if ctx.cr[6].eq {
	pc = 0x82A22FC4; continue 'dispatch;
	}
	// 82A22FC0: 4B89D8D1  bl 0x822c0890
	ctx.lr = 0x82A22FC4;
	sub_822C0890(ctx, base);
	// 82A22FC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A22FC8: 484395C1  bl 0x82e5c588
	ctx.lr = 0x82A22FCC;
	sub_82E5C588(ctx, base);
	// 82A22FCC: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A22FD0: 4182000C  beq 0x82a22fdc
	if ctx.cr[0].eq {
	pc = 0x82A22FDC; continue 'dispatch;
	}
	// 82A22FD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A22FD8: 483CF401  bl 0x82df23d8
	ctx.lr = 0x82A22FDC;
	sub_82DF23D8(ctx, base);
	// 82A22FDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A22FE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A22FE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A22FE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A22FEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A22FF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A22FF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A22FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A22FF8 size=1176
    let mut pc: u32 = 0x82A22FF8;
    'dispatch: loop {
        match pc {
            0x82A22FF8 => {
    //   block [0x82A22FF8..0x82A23490)
	// 82A22FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A22FFC: 48785165  bl 0x831a8160
	ctx.lr = 0x82A23000;
	sub_831A8130(ctx, base);
	// 82A23000: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82A23004: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A23008: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A2300C: 487315F5  bl 0x83154600
	ctx.lr = 0x82A23010;
	sub_83154600(ctx, base);
	// 82A23010: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A23014: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A23018: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82A2301C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A23020: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82A23024: 4BA86F45  bl 0x824a9f68
	ctx.lr = 0x82A23028;
	sub_824A9F68(ctx, base);
	// 82A23028: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2302C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A23030: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A23034: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A23038: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82A2303C: 419A0024  beq cr6, 0x82a23060
	if ctx.cr[6].eq {
	pc = 0x82A23060; continue 'dispatch;
	}
	// 82A23040: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A23044: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A23048: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A2304C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A23050: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A23054: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A23058: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A2305C: 4082FFE8  bne 0x82a23044
	if !ctx.cr[0].eq {
	pc = 0x82A23044; continue 'dispatch;
	}
	// 82A23060: 3BDA0028  addi r30, r26, 0x28
	ctx.r[30].s64 = ctx.r[26].s64 + 40;
	// 82A23064: 3BE10070  addi r31, r1, 0x70
	ctx.r[31].s64 = ctx.r[1].s64 + 112;
	// 82A23068: 4BFEFE41  bl 0x82a12ea8
	ctx.lr = 0x82A2306C;
	sub_82A12EA8(ctx, base);
	// 82A2306C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A23070: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A23074: 3BABA760  addi r29, r11, -0x58a0
	ctx.r[29].s64 = ctx.r[11].s64 + -22688;
	// 82A23078: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A2307C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A23080: 38A001B3  li r5, 0x1b3
	ctx.r[5].s64 = 435;
	// 82A23084: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A23088: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2308C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A23090: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A23094: 484359AD  bl 0x82e58a40
	ctx.lr = 0x82A23098;
	sub_82E58A40(ctx, base);
	// 82A23098: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A2309C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A230A0: 419A0008  beq cr6, 0x82a230a8
	if ctx.cr[6].eq {
	pc = 0x82A230A8; continue 'dispatch;
	}
	// 82A230A4: 4B89D7ED  bl 0x822c0890
	ctx.lr = 0x82A230A8;
	sub_822C0890(ctx, base);
	// 82A230A8: 806100DC  lwz r3, 0xdc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82A230AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A230B0: 419A0008  beq cr6, 0x82a230b8
	if ctx.cr[6].eq {
	pc = 0x82A230B8; continue 'dispatch;
	}
	// 82A230B4: 4B89D7DD  bl 0x822c0890
	ctx.lr = 0x82A230B8;
	sub_822C0890(ctx, base);
	// 82A230B8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82A230BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A230C0: 9B610050  stb r27, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 82A230C4: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A230C8: 4BA9F9D1  bl 0x824c2a98
	ctx.lr = 0x82A230CC;
	sub_824C2A98(ctx, base);
	// 82A230CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A230D0: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82A230D4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A230D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A230DC: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82A230E0: 419A0024  beq cr6, 0x82a23104
	if ctx.cr[6].eq {
	pc = 0x82A23104; continue 'dispatch;
	}
	// 82A230E4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A230E8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A230EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A230F0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A230F4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A230F8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A230FC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A23100: 4082FFE8  bne 0x82a230e8
	if !ctx.cr[0].eq {
	pc = 0x82A230E8; continue 'dispatch;
	}
	// 82A23104: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A23108: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A2310C: 4BAEC3BD  bl 0x8250f4c8
	ctx.lr = 0x82A23110;
	sub_8250F4C8(ctx, base);
	// 82A23110: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A23114: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A23118: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A2311C: 409A0008  bne cr6, 0x82a23124
	if !ctx.cr[6].eq {
	pc = 0x82A23124; continue 'dispatch;
	}
	// 82A23120: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A23124: 3BE10080  addi r31, r1, 0x80
	ctx.r[31].s64 = ctx.r[1].s64 + 128;
	// 82A23128: 4BAE5959  bl 0x82508a80
	ctx.lr = 0x82A2312C;
	sub_82508A80(ctx, base);
	// 82A2312C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A23130: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A23134: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A23138: 38A001B5  li r5, 0x1b5
	ctx.r[5].s64 = 437;
	// 82A2313C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A23140: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A23144: 484358FD  bl 0x82e58a40
	ctx.lr = 0x82A23148;
	sub_82E58A40(ctx, base);
	// 82A23148: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A2314C: 483CEB45  bl 0x82df1c90
	ctx.lr = 0x82A23150;
	sub_82DF1C90(ctx, base);
	// 82A23150: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A23154: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A23158: 419A0008  beq cr6, 0x82a23160
	if ctx.cr[6].eq {
	pc = 0x82A23160; continue 'dispatch;
	}
	// 82A2315C: 4B89D735  bl 0x822c0890
	ctx.lr = 0x82A23160;
	sub_822C0890(ctx, base);
	// 82A23160: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A23164: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A23168: 419A0008  beq cr6, 0x82a23170
	if ctx.cr[6].eq {
	pc = 0x82A23170; continue 'dispatch;
	}
	// 82A2316C: 4B89D725  bl 0x822c0890
	ctx.lr = 0x82A23170;
	sub_822C0890(ctx, base);
	// 82A23170: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A23174: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82A23178: 4BAEC351  bl 0x8250f4c8
	ctx.lr = 0x82A2317C;
	sub_8250F4C8(ctx, base);
	// 82A2317C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A23180: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A23184: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A23188: 409A0008  bne cr6, 0x82a23190
	if !ctx.cr[6].eq {
	pc = 0x82A23190; continue 'dispatch;
	}
	// 82A2318C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A23190: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A23194: 4BAE54ED  bl 0x82508680
	ctx.lr = 0x82A23198;
	sub_82508680(ctx, base);
	// 82A23198: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2319C: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82A231A0: 483CEAF1  bl 0x82df1c90
	ctx.lr = 0x82A231A4;
	sub_82DF1C90(ctx, base);
	// 82A231A4: 9B610050  stb r27, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 82A231A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A231AC: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A231B0: 4BB55721  bl 0x825788d0
	ctx.lr = 0x82A231B4;
	sub_825788D0(ctx, base);
	// 82A231B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A231B8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A231BC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A231C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A231C4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A231C8: 419A0024  beq cr6, 0x82a231ec
	if ctx.cr[6].eq {
	pc = 0x82A231EC; continue 'dispatch;
	}
	// 82A231CC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A231D0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A231D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A231D8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A231DC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A231E0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A231E4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A231E8: 4082FFE8  bne 0x82a231d0
	if !ctx.cr[0].eq {
	pc = 0x82A231D0; continue 'dispatch;
	}
	// 82A231EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A231F0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A231F4: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82A231F8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82A231FC: 38A001B8  li r5, 0x1b8
	ctx.r[5].s64 = 440;
	// 82A23200: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A23204: 4843583D  bl 0x82e58a40
	ctx.lr = 0x82A23208;
	sub_82E58A40(ctx, base);
	// 82A23208: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A2320C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A23210: 419A0008  beq cr6, 0x82a23218
	if ctx.cr[6].eq {
	pc = 0x82A23218; continue 'dispatch;
	}
	// 82A23214: 4B89D67D  bl 0x822c0890
	ctx.lr = 0x82A23218;
	sub_822C0890(ctx, base);
	// 82A23218: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A2321C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A23220: 419A0008  beq cr6, 0x82a23228
	if ctx.cr[6].eq {
	pc = 0x82A23228; continue 'dispatch;
	}
	// 82A23224: 4B89D66D  bl 0x822c0890
	ctx.lr = 0x82A23228;
	sub_822C0890(ctx, base);
	// 82A23228: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A2322C: 480097AD  bl 0x82a2c9d8
	ctx.lr = 0x82A23230;
	sub_82A2C9D8(ctx, base);
	// 82A23230: 80610088  lwz r3, 0x88(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82A23234: 48008D7D  bl 0x82a2bfb0
	ctx.lr = 0x82A23238;
	sub_82A2BFB0(ctx, base);
	// 82A23238: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A2323C: 4BFA6C6D  bl 0x829c9ea8
	ctx.lr = 0x82A23240;
	sub_829C9EA8(ctx, base);
	// 82A23240: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A23244: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A23248: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A2324C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A23250: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A23254: 419A0024  beq cr6, 0x82a23278
	if ctx.cr[6].eq {
	pc = 0x82A23278; continue 'dispatch;
	}
	// 82A23258: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A2325C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A23260: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A23264: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A23268: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A2326C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A23270: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A23274: 4082FFE8  bne 0x82a2325c
	if !ctx.cr[0].eq {
	pc = 0x82A2325C; continue 'dispatch;
	}
	// 82A23278: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A2327C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A23280: 4BAEC249  bl 0x8250f4c8
	ctx.lr = 0x82A23284;
	sub_8250F4C8(ctx, base);
	// 82A23284: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A23288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2328C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A23290: 409A0008  bne cr6, 0x82a23298
	if !ctx.cr[6].eq {
	pc = 0x82A23298; continue 'dispatch;
	}
	// 82A23294: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A23298: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A2329C: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 82A232A0: 4BAE5779  bl 0x82508a18
	ctx.lr = 0x82A232A4;
	sub_82508A18(ctx, base);
	// 82A232A4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A232A8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A232AC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A232B0: 38A001BD  li r5, 0x1bd
	ctx.r[5].s64 = 445;
	// 82A232B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A232B8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A232BC: 48435785  bl 0x82e58a40
	ctx.lr = 0x82A232C0;
	sub_82E58A40(ctx, base);
	// 82A232C0: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A232C4: 483CE9CD  bl 0x82df1c90
	ctx.lr = 0x82A232C8;
	sub_82DF1C90(ctx, base);
	// 82A232C8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A232CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A232D0: 419A0008  beq cr6, 0x82a232d8
	if ctx.cr[6].eq {
	pc = 0x82A232D8; continue 'dispatch;
	}
	// 82A232D4: 4B89D5BD  bl 0x822c0890
	ctx.lr = 0x82A232D8;
	sub_822C0890(ctx, base);
	// 82A232D8: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A232DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A232E0: 419A0008  beq cr6, 0x82a232e8
	if ctx.cr[6].eq {
	pc = 0x82A232E8; continue 'dispatch;
	}
	// 82A232E4: 4B89D5AD  bl 0x822c0890
	ctx.lr = 0x82A232E8;
	sub_822C0890(ctx, base);
	// 82A232E8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A232EC: 4BFFF6F5  bl 0x82a229e0
	ctx.lr = 0x82A232F0;
	sub_82A229E0(ctx, base);
	// 82A232F0: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A232F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A232F8: 419A0008  beq cr6, 0x82a23300
	if ctx.cr[6].eq {
	pc = 0x82A23300; continue 'dispatch;
	}
	// 82A232FC: 4B89D595  bl 0x822c0890
	ctx.lr = 0x82A23300;
	sub_822C0890(ctx, base);
	// 82A23300: 937C00C8  stw r27, 0xc8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(200 as u32), ctx.r[27].u32 ) };
	// 82A23304: 397C00C8  addi r11, r28, 0xc8
	ctx.r[11].s64 = ctx.r[28].s64 + 200;
	// 82A23308: 807C00CC  lwz r3, 0xcc(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A2330C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A23310: 937C00CC  stw r27, 0xcc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(204 as u32), ctx.r[27].u32 ) };
	// 82A23314: 419A0008  beq cr6, 0x82a2331c
	if ctx.cr[6].eq {
	pc = 0x82A2331C; continue 'dispatch;
	}
	// 82A23318: 4B89D579  bl 0x822c0890
	ctx.lr = 0x82A2331C;
	sub_822C0890(ctx, base);
	// 82A2331C: 387C00D0  addi r3, r28, 0xd0
	ctx.r[3].s64 = ctx.r[28].s64 + 208;
	// 82A23320: 4B8A3889  bl 0x822c6ba8
	ctx.lr = 0x82A23324;
	sub_822C6BA8(ctx, base);
	// 82A23324: 389C00A0  addi r4, r28, 0xa0
	ctx.r[4].s64 = ctx.r[28].s64 + 160;
	// 82A23328: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82A2332C: 4BFB475D  bl 0x829d7a88
	ctx.lr = 0x82A23330;
	sub_829D7A88(ctx, base);
	// 82A23330: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A23334: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A23338: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A2333C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A23340: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A23344: 419A0024  beq cr6, 0x82a23368
	if ctx.cr[6].eq {
	pc = 0x82A23368; continue 'dispatch;
	}
	// 82A23348: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A2334C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A23350: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A23354: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A23358: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A2335C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A23360: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A23364: 4082FFE8  bne 0x82a2334c
	if !ctx.cr[0].eq {
	pc = 0x82A2334C; continue 'dispatch;
	}
	// 82A23368: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A2336C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A23370: 4BAEC159  bl 0x8250f4c8
	ctx.lr = 0x82A23374;
	sub_8250F4C8(ctx, base);
	// 82A23374: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A23378: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2337C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A23380: 409A0008  bne cr6, 0x82a23388
	if !ctx.cr[6].eq {
	pc = 0x82A23388; continue 'dispatch;
	}
	// 82A23384: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A23388: 3BE10068  addi r31, r1, 0x68
	ctx.r[31].s64 = ctx.r[1].s64 + 104;
	// 82A2338C: 4BAE5965  bl 0x82508cf0
	ctx.lr = 0x82A23390;
	sub_82508CF0(ctx, base);
	// 82A23390: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A23394: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A23398: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A2339C: 38A001CF  li r5, 0x1cf
	ctx.r[5].s64 = 463;
	// 82A233A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A233A4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A233A8: 48435699  bl 0x82e58a40
	ctx.lr = 0x82A233AC;
	sub_82E58A40(ctx, base);
	// 82A233AC: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A233B0: 483CE8E1  bl 0x82df1c90
	ctx.lr = 0x82A233B4;
	sub_82DF1C90(ctx, base);
	// 82A233B4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A233B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A233BC: 419A0008  beq cr6, 0x82a233c4
	if ctx.cr[6].eq {
	pc = 0x82A233C4; continue 'dispatch;
	}
	// 82A233C0: 4B89D4D1  bl 0x822c0890
	ctx.lr = 0x82A233C4;
	sub_822C0890(ctx, base);
	// 82A233C4: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A233C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A233CC: 419A0008  beq cr6, 0x82a233d4
	if ctx.cr[6].eq {
	pc = 0x82A233D4; continue 'dispatch;
	}
	// 82A233D0: 4B89D4C1  bl 0x822c0890
	ctx.lr = 0x82A233D4;
	sub_822C0890(ctx, base);
	// 82A233D4: 389C00B0  addi r4, r28, 0xb0
	ctx.r[4].s64 = ctx.r[28].s64 + 176;
	// 82A233D8: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82A233DC: 4BFB4725  bl 0x829d7b00
	ctx.lr = 0x82A233E0;
	sub_829D7B00(ctx, base);
	// 82A233E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A233E4: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82A233E8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A233EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A233F0: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82A233F4: 419A0024  beq cr6, 0x82a23418
	if ctx.cr[6].eq {
	pc = 0x82A23418; continue 'dispatch;
	}
	// 82A233F8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A233FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A23400: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A23404: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A23408: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A2340C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A23410: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A23414: 4082FFE8  bne 0x82a233fc
	if !ctx.cr[0].eq {
	pc = 0x82A233FC; continue 'dispatch;
	}
	// 82A23418: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A2341C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82A23420: 4BAEC0A9  bl 0x8250f4c8
	ctx.lr = 0x82A23424;
	sub_8250F4C8(ctx, base);
	// 82A23424: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A23428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2342C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A23430: 409A0008  bne cr6, 0x82a23438
	if !ctx.cr[6].eq {
	pc = 0x82A23438; continue 'dispatch;
	}
	// 82A23434: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A23438: 3BE10078  addi r31, r1, 0x78
	ctx.r[31].s64 = ctx.r[1].s64 + 120;
	// 82A2343C: 4BAE58B5  bl 0x82508cf0
	ctx.lr = 0x82A23440;
	sub_82508CF0(ctx, base);
	// 82A23440: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A23444: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A23448: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A2344C: 38A001D0  li r5, 0x1d0
	ctx.r[5].s64 = 464;
	// 82A23450: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A23454: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A23458: 484355E9  bl 0x82e58a40
	ctx.lr = 0x82A2345C;
	sub_82E58A40(ctx, base);
	// 82A2345C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82A23460: 483CE831  bl 0x82df1c90
	ctx.lr = 0x82A23464;
	sub_82DF1C90(ctx, base);
	// 82A23464: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A23468: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2346C: 419A0008  beq cr6, 0x82a23474
	if ctx.cr[6].eq {
	pc = 0x82A23474; continue 'dispatch;
	}
	// 82A23470: 4B89D421  bl 0x822c0890
	ctx.lr = 0x82A23474;
	sub_822C0890(ctx, base);
	// 82A23474: 806100E4  lwz r3, 0xe4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A23478: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2347C: 419A0008  beq cr6, 0x82a23484
	if ctx.cr[6].eq {
	pc = 0x82A23484; continue 'dispatch;
	}
	// 82A23480: 4B89D411  bl 0x822c0890
	ctx.lr = 0x82A23484;
	sub_822C0890(ctx, base);
	// 82A23484: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82A23488: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82A2348C: 48784D24  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A23490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A23490 size=224
    let mut pc: u32 = 0x82A23490;
    'dispatch: loop {
        match pc {
            0x82A23490 => {
    //   block [0x82A23490..0x82A23570)
	// 82A23490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A23494: 48784CD5  bl 0x831a8168
	ctx.lr = 0x82A23498;
	sub_831A8130(ctx, base);
	// 82A23498: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2349C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A234A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A234A4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A234A8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A234AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A234B0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A234B4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A234B8: D01F007C  stfs f0, 0x7c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82A234BC: 93BF0084  stw r29, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[29].u32 ) };
	// 82A234C0: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82A234C4: 93DF008C  stw r30, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 82A234C8: 995F007B  stb r10, 0x7b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(123 as u32), ctx.r[10].u8 ) };
	// 82A234CC: 913F0088  stw r9, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[9].u32 ) };
	// 82A234D0: 48731131  bl 0x83154600
	ctx.lr = 0x82A234D4;
	sub_83154600(ctx, base);
	// 82A234D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A234D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A234DC: 4BFF09ED  bl 0x82a13ec8
	ctx.lr = 0x82A234E0;
	sub_82A13EC8(ctx, base);
	// 82A234E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A234E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A234E8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A234EC: 4BEF1985  bl 0x82914e70
	ctx.lr = 0x82A234F0;
	sub_82914E70(ctx, base);
	// 82A234F0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A234F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A234F8: 419A0008  beq cr6, 0x82a23500
	if ctx.cr[6].eq {
	pc = 0x82A23500; continue 'dispatch;
	}
	// 82A234FC: 4B89D395  bl 0x822c0890
	ctx.lr = 0x82A23500;
	sub_822C0890(ctx, base);
	// 82A23500: 3B9F00D0  addi r28, r31, 0xd0
	ctx.r[28].s64 = ctx.r[31].s64 + 208;
	// 82A23504: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A23508: 4B8A36A1  bl 0x822c6ba8
	ctx.lr = 0x82A2350C;
	sub_822C6BA8(ctx, base);
	// 82A2350C: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A23510: 40990050  ble cr6, 0x82a23560
	if !ctx.cr[6].gt {
	pc = 0x82A23560; continue 'dispatch;
	}
	// 82A23514: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A23518: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2351C: 483D04ED  bl 0x82df3a08
	ctx.lr = 0x82A23520;
	sub_82DF3A08(ctx, base);
	// 82A23520: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A23524: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A23528: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A2352C: 4815C4B5  bl 0x82b7f9e0
	ctx.lr = 0x82A23530;
	sub_82B7F9E0(ctx, base);
	// 82A23530: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A23534: 483CFEF5  bl 0x82df3428
	ctx.lr = 0x82A23538;
	sub_82DF3428(ctx, base);
	// 82A23538: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A2353C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A23540: 4818FBC9  bl 0x82bb3108
	ctx.lr = 0x82A23544;
	sub_82BB3108(ctx, base);
	// 82A23544: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A23548: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2354C: 419A0008  beq cr6, 0x82a23554
	if ctx.cr[6].eq {
	pc = 0x82A23554; continue 'dispatch;
	}
	// 82A23550: 4B89D341  bl 0x822c0890
	ctx.lr = 0x82A23554;
	sub_822C0890(ctx, base);
	// 82A23554: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A23558: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82A2355C: 4082FFB8  bne 0x82a23514
	if !ctx.cr[0].eq {
	pc = 0x82A23514; continue 'dispatch;
	}
	// 82A23560: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A23564: 4BFFF105  bl 0x82a22668
	ctx.lr = 0x82A23568;
	sub_82A22668(ctx, base);
	// 82A23568: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A2356C: 48784C4C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A23570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A23570 size=1048
    let mut pc: u32 = 0x82A23570;
    'dispatch: loop {
        match pc {
            0x82A23570 => {
    //   block [0x82A23570..0x82A23988)
	// 82A23570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A23574: 48784BE9  bl 0x831a815c
	ctx.lr = 0x82A23578;
	sub_831A8130(ctx, base);
	// 82A23578: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82A2357C: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A23580: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A23584: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A23588: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82A2358C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A23590: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A23594: D3FA007C  stfs f31, 0x7c(r26)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82A23598: 933A0064  stw r25, 0x64(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 82A2359C: D3FA0080  stfs f31, 0x80(r26)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82A235A0: 915A0068  stw r10, 0x68(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82A235A4: 4873105D  bl 0x83154600
	ctx.lr = 0x82A235A8;
	sub_83154600(ctx, base);
	// 82A235A8: 397A00A0  addi r11, r26, 0xa0
	ctx.r[11].s64 = ctx.r[26].s64 + 160;
	// 82A235AC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A235B0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A235B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A235B8: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82A235BC: 4BFB43DD  bl 0x829d7998
	ctx.lr = 0x82A235C0;
	sub_829D7998(ctx, base);
	// 82A235C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A235C4: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A235C8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A235CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A235D0: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82A235D4: 419A0024  beq cr6, 0x82a235f8
	if ctx.cr[6].eq {
	pc = 0x82A235F8; continue 'dispatch;
	}
	// 82A235D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A235DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A235E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A235E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A235E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A235EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A235F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A235F4: 4082FFE8  bne 0x82a235dc
	if !ctx.cr[0].eq {
	pc = 0x82A235DC; continue 'dispatch;
	}
	// 82A235F8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A235FC: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82A23600: 4BAEBEC9  bl 0x8250f4c8
	ctx.lr = 0x82A23604;
	sub_8250F4C8(ctx, base);
	// 82A23604: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A23608: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2360C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A23610: 409A0008  bne cr6, 0x82a23618
	if !ctx.cr[6].eq {
	pc = 0x82A23618; continue 'dispatch;
	}
	// 82A23614: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A23618: 3BBB0028  addi r29, r27, 0x28
	ctx.r[29].s64 = ctx.r[27].s64 + 40;
	// 82A2361C: 3BE10070  addi r31, r1, 0x70
	ctx.r[31].s64 = ctx.r[1].s64 + 112;
	// 82A23620: 4BAE56D1  bl 0x82508cf0
	ctx.lr = 0x82A23624;
	sub_82508CF0(ctx, base);
	// 82A23624: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A23628: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A2362C: 3B8BA760  addi r28, r11, -0x58a0
	ctx.r[28].s64 = ctx.r[11].s64 + -22688;
	// 82A23630: 38A0009C  li r5, 0x9c
	ctx.r[5].s64 = 156;
	// 82A23634: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A23638: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A2363C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A23640: 484339A9  bl 0x82e56fe8
	ctx.lr = 0x82A23644;
	sub_82E56FE8(ctx, base);
	// 82A23644: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82A23648: 483CE649  bl 0x82df1c90
	ctx.lr = 0x82A2364C;
	sub_82DF1C90(ctx, base);
	// 82A2364C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A23650: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A23654: 419A0008  beq cr6, 0x82a2365c
	if ctx.cr[6].eq {
	pc = 0x82A2365C; continue 'dispatch;
	}
	// 82A23658: 4B89D239  bl 0x822c0890
	ctx.lr = 0x82A2365C;
	sub_822C0890(ctx, base);
	// 82A2365C: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82A23660: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A23664: 419A0008  beq cr6, 0x82a2366c
	if ctx.cr[6].eq {
	pc = 0x82A2366C; continue 'dispatch;
	}
	// 82A23668: 4B89D229  bl 0x822c0890
	ctx.lr = 0x82A2366C;
	sub_822C0890(ctx, base);
	// 82A2366C: 397A00B0  addi r11, r26, 0xb0
	ctx.r[11].s64 = ctx.r[26].s64 + 176;
	// 82A23670: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A23674: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A23678: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82A2367C: 4BFB4395  bl 0x829d7a10
	ctx.lr = 0x82A23680;
	sub_829D7A10(ctx, base);
	// 82A23680: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A23684: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82A23688: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A2368C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A23690: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82A23694: 419A0024  beq cr6, 0x82a236b8
	if ctx.cr[6].eq {
	pc = 0x82A236B8; continue 'dispatch;
	}
	// 82A23698: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A2369C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A236A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A236A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A236A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A236AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A236B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A236B4: 4082FFE8  bne 0x82a2369c
	if !ctx.cr[0].eq {
	pc = 0x82A2369C; continue 'dispatch;
	}
	// 82A236B8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A236BC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A236C0: 4BAEBE09  bl 0x8250f4c8
	ctx.lr = 0x82A236C4;
	sub_8250F4C8(ctx, base);
	// 82A236C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A236C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A236CC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A236D0: 409A0008  bne cr6, 0x82a236d8
	if !ctx.cr[6].eq {
	pc = 0x82A236D8; continue 'dispatch;
	}
	// 82A236D4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A236D8: 3BE10078  addi r31, r1, 0x78
	ctx.r[31].s64 = ctx.r[1].s64 + 120;
	// 82A236DC: 4BAE5615  bl 0x82508cf0
	ctx.lr = 0x82A236E0;
	sub_82508CF0(ctx, base);
	// 82A236E0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A236E4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A236E8: 38A0009D  li r5, 0x9d
	ctx.r[5].s64 = 157;
	// 82A236EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A236F0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A236F4: 484338F5  bl 0x82e56fe8
	ctx.lr = 0x82A236F8;
	sub_82E56FE8(ctx, base);
	// 82A236F8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A236FC: 483CE595  bl 0x82df1c90
	ctx.lr = 0x82A23700;
	sub_82DF1C90(ctx, base);
	// 82A23700: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A23704: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A23708: 419A0008  beq cr6, 0x82a23710
	if ctx.cr[6].eq {
	pc = 0x82A23710; continue 'dispatch;
	}
	// 82A2370C: 4B89D185  bl 0x822c0890
	ctx.lr = 0x82A23710;
	sub_822C0890(ctx, base);
	// 82A23710: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A23714: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A23718: 419A0008  beq cr6, 0x82a23720
	if ctx.cr[6].eq {
	pc = 0x82A23720; continue 'dispatch;
	}
	// 82A2371C: 4B89D175  bl 0x822c0890
	ctx.lr = 0x82A23720;
	sub_822C0890(ctx, base);
	// 82A23720: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A23724: D3E1009C  stfs f31, 0x9c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82A23728: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82A2372C: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82A23730: C00B6150  lfs f0, 0x6150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A23734: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82A23738: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82A2373C: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82A23740: 4BFB4349  bl 0x829d7a88
	ctx.lr = 0x82A23744;
	sub_829D7A88(ctx, base);
	// 82A23744: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A23748: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A2374C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A23750: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A23754: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A23758: 419A0024  beq cr6, 0x82a2377c
	if ctx.cr[6].eq {
	pc = 0x82A2377C; continue 'dispatch;
	}
	// 82A2375C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A23760: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A23764: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A23768: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A2376C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A23770: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A23774: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A23778: 4082FFE8  bne 0x82a23760
	if !ctx.cr[0].eq {
	pc = 0x82A23760; continue 'dispatch;
	}
	// 82A2377C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A23780: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A23784: 4BAEBD45  bl 0x8250f4c8
	ctx.lr = 0x82A23788;
	sub_8250F4C8(ctx, base);
	// 82A23788: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2378C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A23790: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A23794: 409A0008  bne cr6, 0x82a2379c
	if !ctx.cr[6].eq {
	pc = 0x82A2379C; continue 'dispatch;
	}
	// 82A23798: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A2379C: 3BE10058  addi r31, r1, 0x58
	ctx.r[31].s64 = ctx.r[1].s64 + 88;
	// 82A237A0: 4BAE5551  bl 0x82508cf0
	ctx.lr = 0x82A237A4;
	sub_82508CF0(ctx, base);
	// 82A237A4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A237A8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A237AC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A237B0: 38A000A0  li r5, 0xa0
	ctx.r[5].s64 = 160;
	// 82A237B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A237B8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A237BC: 48435285  bl 0x82e58a40
	ctx.lr = 0x82A237C0;
	sub_82E58A40(ctx, base);
	// 82A237C0: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A237C4: 483CE4CD  bl 0x82df1c90
	ctx.lr = 0x82A237C8;
	sub_82DF1C90(ctx, base);
	// 82A237C8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A237CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A237D0: 419A0008  beq cr6, 0x82a237d8
	if ctx.cr[6].eq {
	pc = 0x82A237D8; continue 'dispatch;
	}
	// 82A237D4: 4B89D0BD  bl 0x822c0890
	ctx.lr = 0x82A237D8;
	sub_822C0890(ctx, base);
	// 82A237D8: 806100DC  lwz r3, 0xdc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82A237DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A237E0: 419A0008  beq cr6, 0x82a237e8
	if ctx.cr[6].eq {
	pc = 0x82A237E8; continue 'dispatch;
	}
	// 82A237E4: 4B89D0AD  bl 0x822c0890
	ctx.lr = 0x82A237E8;
	sub_822C0890(ctx, base);
	// 82A237E8: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82A237EC: D3E1008C  stfs f31, 0x8c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82A237F0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82A237F4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A237F8: C00B7BC8  lfs f0, 0x7bc8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31688 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A237FC: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82A23800: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82A23804: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82A23808: 4BFB42F9  bl 0x829d7b00
	ctx.lr = 0x82A2380C;
	sub_829D7B00(ctx, base);
	// 82A2380C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A23810: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A23814: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A23818: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2381C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A23820: 419A0024  beq cr6, 0x82a23844
	if ctx.cr[6].eq {
	pc = 0x82A23844; continue 'dispatch;
	}
	// 82A23824: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A23828: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A2382C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A23830: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A23834: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A23838: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A2383C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A23840: 4082FFE8  bne 0x82a23828
	if !ctx.cr[0].eq {
	pc = 0x82A23828; continue 'dispatch;
	}
	// 82A23844: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A23848: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A2384C: 4BAEBC7D  bl 0x8250f4c8
	ctx.lr = 0x82A23850;
	sub_8250F4C8(ctx, base);
	// 82A23850: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A23854: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A23858: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A2385C: 409A0008  bne cr6, 0x82a23864
	if !ctx.cr[6].eq {
	pc = 0x82A23864; continue 'dispatch;
	}
	// 82A23860: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A23864: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 82A23868: 4BAE5489  bl 0x82508cf0
	ctx.lr = 0x82A2386C;
	sub_82508CF0(ctx, base);
	// 82A2386C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A23870: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A23874: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A23878: 38A000A1  li r5, 0xa1
	ctx.r[5].s64 = 161;
	// 82A2387C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A23880: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A23884: 484351BD  bl 0x82e58a40
	ctx.lr = 0x82A23888;
	sub_82E58A40(ctx, base);
	// 82A23888: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A2388C: 483CE405  bl 0x82df1c90
	ctx.lr = 0x82A23890;
	sub_82DF1C90(ctx, base);
	// 82A23890: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A23894: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A23898: 419A0008  beq cr6, 0x82a238a0
	if ctx.cr[6].eq {
	pc = 0x82A238A0; continue 'dispatch;
	}
	// 82A2389C: 4B89CFF5  bl 0x822c0890
	ctx.lr = 0x82A238A0;
	sub_822C0890(ctx, base);
	// 82A238A0: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A238A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A238A8: 419A0008  beq cr6, 0x82a238b0
	if ctx.cr[6].eq {
	pc = 0x82A238B0; continue 'dispatch;
	}
	// 82A238AC: 4B89CFE5  bl 0x822c0890
	ctx.lr = 0x82A238B0;
	sub_822C0890(ctx, base);
	// 82A238B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A238B4: 4BA7783D  bl 0x8249b0f0
	ctx.lr = 0x82A238B8;
	sub_8249B0F0(ctx, base);
	// 82A238B8: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A238BC: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A238C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A238C4: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 82A238C8: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82A238CC: 419A0024  beq cr6, 0x82a238f0
	if ctx.cr[6].eq {
	pc = 0x82A238F0; continue 'dispatch;
	}
	// 82A238D0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A238D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A238D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A238DC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A238E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A238E4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A238E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A238EC: 4082FFE8  bne 0x82a238d4
	if !ctx.cr[0].eq {
	pc = 0x82A238D4; continue 'dispatch;
	}
	// 82A238F0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A238F4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82A238F8: 4BAEBBD1  bl 0x8250f4c8
	ctx.lr = 0x82A238FC;
	sub_8250F4C8(ctx, base);
	// 82A238FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A23900: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A23904: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A23908: 409A0008  bne cr6, 0x82a23910
	if !ctx.cr[6].eq {
	pc = 0x82A23910; continue 'dispatch;
	}
	// 82A2390C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A23910: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A23914: 3B610068  addi r27, r1, 0x68
	ctx.r[27].s64 = ctx.r[1].s64 + 104;
	// 82A23918: 4BAE5101  bl 0x82508a18
	ctx.lr = 0x82A2391C;
	sub_82508A18(ctx, base);
	// 82A2391C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A23920: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A23924: 38A000A5  li r5, 0xa5
	ctx.r[5].s64 = 165;
	// 82A23928: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A2392C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82A23930: 484336B9  bl 0x82e56fe8
	ctx.lr = 0x82A23934;
	sub_82E56FE8(ctx, base);
	// 82A23934: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82A23938: 483CE359  bl 0x82df1c90
	ctx.lr = 0x82A2393C;
	sub_82DF1C90(ctx, base);
	// 82A2393C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A23940: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A23944: 419A0008  beq cr6, 0x82a2394c
	if ctx.cr[6].eq {
	pc = 0x82A2394C; continue 'dispatch;
	}
	// 82A23948: 4B89CF49  bl 0x822c0890
	ctx.lr = 0x82A2394C;
	sub_822C0890(ctx, base);
	// 82A2394C: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A23950: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A23954: 933A00C4  stw r25, 0xc4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(196 as u32), ctx.r[25].u32 ) };
	// 82A23958: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82A2395C: 388A1034  addi r4, r10, 0x1034
	ctx.r[4].s64 = ctx.r[10].s64 + 4148;
	// 82A23960: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A23964: 917A00C0  stw r11, 0xc0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82A23968: 4BFFFB29  bl 0x82a23490
	ctx.lr = 0x82A2396C;
	sub_82A23490(ctx, base);
	// 82A2396C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A23970: 419A000C  beq cr6, 0x82a2397c
	if ctx.cr[6].eq {
	pc = 0x82A2397C; continue 'dispatch;
	}
	// 82A23974: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A23978: 4B89CF19  bl 0x822c0890
	ctx.lr = 0x82A2397C;
	sub_822C0890(ctx, base);
	// 82A2397C: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82A23980: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82A23984: 48784828  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A23988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A23988 size=1676
    let mut pc: u32 = 0x82A23988;
    'dispatch: loop {
        match pc {
            0x82A23988 => {
    //   block [0x82A23988..0x82A24014)
	// 82A23988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2398C: 487847D1  bl 0x831a815c
	ctx.lr = 0x82A23990;
	sub_831A8130(ctx, base);
	// 82A23990: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82A23994: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A23998: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2399C: 48730C65  bl 0x83154600
	ctx.lr = 0x82A239A0;
	sub_83154600(ctx, base);
	// 82A239A0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A239A4: 4BFEF515  bl 0x82a12eb8
	ctx.lr = 0x82A239A8;
	sub_82A12EB8(ctx, base);
	// 82A239A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A239AC: 4BFFF445  bl 0x82a22df0
	ctx.lr = 0x82A239B0;
	sub_82A22DF0(ctx, base);
	// 82A239B0: 897F0079  lbz r11, 0x79(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(121 as u32) ) } as u64;
	// 82A239B4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A239B8: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 82A239BC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A239C0: 4182000C  beq 0x82a239cc
	if ctx.cr[0].eq {
	pc = 0x82A239CC; continue 'dispatch;
	}
	// 82A239C4: 9B5F0079  stb r26, 0x79(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(121 as u32), ctx.r[26].u8 ) };
	// 82A239C8: 9B3F007A  stb r25, 0x7a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(122 as u32), ctx.r[25].u8 ) };
	// 82A239CC: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A239D0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A239D4: 4198034C  blt cr6, 0x82a23d20
	if ctx.cr[6].lt {
	pc = 0x82A23D20; continue 'dispatch;
	}
	// 82A239D8: 419A0294  beq cr6, 0x82a23c6c
	if ctx.cr[6].eq {
	pc = 0x82A23C6C; continue 'dispatch;
	}
	// 82A239DC: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A239E0: 419801E0  blt cr6, 0x82a23bc0
	if ctx.cr[6].lt {
	pc = 0x82A23BC0; continue 'dispatch;
	}
	// 82A239E4: 419A0150  beq cr6, 0x82a23b34
	if ctx.cr[6].eq {
	pc = 0x82A23B34; continue 'dispatch;
	}
	// 82A239E8: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82A239EC: 419800A8  blt cr6, 0x82a23a94
	if ctx.cr[6].lt {
	pc = 0x82A23A94; continue 'dispatch;
	}
	// 82A239F0: 409A0618  bne cr6, 0x82a24008
	if !ctx.cr[6].eq {
	pc = 0x82A24008; continue 'dispatch;
	}
	// 82A239F4: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A239F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A239FC: 409A0048  bne cr6, 0x82a23a44
	if !ctx.cr[6].eq {
	pc = 0x82A23A44; continue 'dispatch;
	}
	// 82A23A00: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A23A04: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82A23A08: 388BA11C  addi r4, r11, -0x5ee4
	ctx.r[4].s64 = ctx.r[11].s64 + -24292;
	// 82A23A0C: 483CFFFD  bl 0x82df3a08
	ctx.lr = 0x82A23A10;
	sub_82DF3A08(ctx, base);
	// 82A23A10: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A23A14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A23A18: 485E4711  bl 0x83008128
	ctx.lr = 0x82A23A1C;
	sub_83008128(ctx, base);
	// 82A23A1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A23A20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A23A24: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A23A28: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A23A2C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A23A30: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A23A34: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A23A38: 4843AF29  bl 0x82e5e960
	ctx.lr = 0x82A23A3C;
	sub_82E5E960(ctx, base);
	// 82A23A3C: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A23A40: 48000044  b 0x82a23a84
	pc = 0x82A23A84; continue 'dispatch;
	// 82A23A44: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A23A48: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A23A4C: 388B893C  addi r4, r11, -0x76c4
	ctx.r[4].s64 = ctx.r[11].s64 + -30404;
	// 82A23A50: 483CFFB9  bl 0x82df3a08
	ctx.lr = 0x82A23A54;
	sub_82DF3A08(ctx, base);
	// 82A23A54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A23A58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A23A5C: 485E46CD  bl 0x83008128
	ctx.lr = 0x82A23A60;
	sub_83008128(ctx, base);
	// 82A23A60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A23A64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A23A68: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A23A6C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A23A70: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A23A74: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A23A78: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A23A7C: 4843AEE5  bl 0x82e5e960
	ctx.lr = 0x82A23A80;
	sub_82E5E960(ctx, base);
	// 82A23A80: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A23A84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A23A88: 419A0580  beq cr6, 0x82a24008
	if ctx.cr[6].eq {
	pc = 0x82A24008; continue 'dispatch;
	}
	// 82A23A8C: 4B89CE05  bl 0x822c0890
	ctx.lr = 0x82A23A90;
	sub_822C0890(ctx, base);
	// 82A23A90: 48000578  b 0x82a24008
	pc = 0x82A24008; continue 'dispatch;
	// 82A23A94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A23A98: 4BFFEA81  bl 0x82a22518
	ctx.lr = 0x82A23A9C;
	sub_82A22518(ctx, base);
	// 82A23A9C: 897F007A  lbz r11, 0x7a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(122 as u32) ) } as u64;
	// 82A23AA0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A23AA4: 41820564  beq 0x82a24008
	if ctx.cr[0].eq {
	pc = 0x82A24008; continue 'dispatch;
	}
	// 82A23AA8: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82A23AAC: 4BF01DA5  bl 0x82925850
	ctx.lr = 0x82A23AB0;
	sub_82925850(ctx, base);
	// 82A23AB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A23AB4: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82A23AB8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A23ABC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A23AC0: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82A23AC4: 419A0024  beq cr6, 0x82a23ae8
	if ctx.cr[6].eq {
	pc = 0x82A23AE8; continue 'dispatch;
	}
	// 82A23AC8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A23ACC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A23AD0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A23AD4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A23AD8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A23ADC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A23AE0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A23AE4: 4082FFE8  bne 0x82a23acc
	if !ctx.cr[0].eq {
	pc = 0x82A23ACC; continue 'dispatch;
	}
	// 82A23AE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A23AEC: 80DF0090  lwz r6, 0x90(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82A23AF0: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A23AF4: 38E10078  addi r7, r1, 0x78
	ctx.r[7].s64 = ctx.r[1].s64 + 120;
	// 82A23AF8: 388AA760  addi r4, r10, -0x58a0
	ctx.r[4].s64 = ctx.r[10].s64 + -22688;
	// 82A23AFC: 38A00140  li r5, 0x140
	ctx.r[5].s64 = 320;
	// 82A23B00: 387B0028  addi r3, r27, 0x28
	ctx.r[3].s64 = ctx.r[27].s64 + 40;
	// 82A23B04: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A23B08: 48434F39  bl 0x82e58a40
	ctx.lr = 0x82A23B0C;
	sub_82E58A40(ctx, base);
	// 82A23B0C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A23B10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A23B14: 419A0008  beq cr6, 0x82a23b1c
	if ctx.cr[6].eq {
	pc = 0x82A23B1C; continue 'dispatch;
	}
	// 82A23B18: 4B89CD79  bl 0x822c0890
	ctx.lr = 0x82A23B1C;
	sub_822C0890(ctx, base);
	// 82A23B1C: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A23B20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A23B24: 419A0008  beq cr6, 0x82a23b2c
	if ctx.cr[6].eq {
	pc = 0x82A23B2C; continue 'dispatch;
	}
	// 82A23B28: 4B89CD69  bl 0x822c0890
	ctx.lr = 0x82A23B2C;
	sub_822C0890(ctx, base);
	// 82A23B2C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82A23B30: 480001E8  b 0x82a23d18
	pc = 0x82A23D18; continue 'dispatch;
	// 82A23B34: 815F0070  lwz r10, 0x70(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A23B38: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A23B3C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A23B40: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A23B44: 409A04C4  bne cr6, 0x82a24008
	if !ctx.cr[6].eq {
	pc = 0x82A24008; continue 'dispatch;
	}
	// 82A23B48: 895F007A  lbz r10, 0x7a(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(122 as u32) ) } as u64;
	// 82A23B4C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A23B50: 418204B8  beq 0x82a24008
	if ctx.cr[0].eq {
	pc = 0x82A24008; continue 'dispatch;
	}
	// 82A23B54: 895F0078  lbz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82A23B58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A23B5C: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A23B60: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A23B64: 9B5F007A  stb r26, 0x7a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(122 as u32), ctx.r[26].u8 ) };
	// 82A23B68: 41820020  beq 0x82a23b88
	if ctx.cr[0].eq {
	pc = 0x82A23B88; continue 'dispatch;
	}
	// 82A23B6C: 933F0068  stw r25, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[25].u32 ) };
	// 82A23B70: 4BFFEC91  bl 0x82a22800
	ctx.lr = 0x82A23B74;
	sub_82A22800(ctx, base);
	// 82A23B74: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A23B78: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82A23B7C: 396B1054  addi r11, r11, 0x1054
	ctx.r[11].s64 = ctx.r[11].s64 + 4180;
	// 82A23B80: 388B002C  addi r4, r11, 0x2c
	ctx.r[4].s64 = ctx.r[11].s64 + 44;
	// 82A23B84: 4800002C  b 0x82a23bb0
	pc = 0x82A23BB0; continue 'dispatch;
	// 82A23B88: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A23B8C: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A23B90: 4BFFEC71  bl 0x82a22800
	ctx.lr = 0x82A23B94;
	sub_82A22800(ctx, base);
	// 82A23B94: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A23B98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A23B9C: 808B02C8  lwz r4, 0x2c8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(712 as u32) ) } as u64;
	// 82A23BA0: 4BFFED29  bl 0x82a228c8
	ctx.lr = 0x82A23BA4;
	sub_82A228C8(ctx, base);
	// 82A23BA4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A23BA8: 388B1054  addi r4, r11, 0x1054
	ctx.r[4].s64 = ctx.r[11].s64 + 4180;
	// 82A23BAC: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82A23BB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A23BB4: 4BFFF8DD  bl 0x82a23490
	ctx.lr = 0x82A23BB8;
	sub_82A23490(ctx, base);
	// 82A23BB8: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82A23BBC: 4800015C  b 0x82a23d18
	pc = 0x82A23D18; continue 'dispatch;
	// 82A23BC0: 815F0070  lwz r10, 0x70(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A23BC4: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A23BC8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A23BCC: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A23BD0: 409A0438  bne cr6, 0x82a24008
	if !ctx.cr[6].eq {
	pc = 0x82A24008; continue 'dispatch;
	}
	// 82A23BD4: 895F007A  lbz r10, 0x7a(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(122 as u32) ) } as u64;
	// 82A23BD8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A23BDC: 4182042C  beq 0x82a24008
	if ctx.cr[0].eq {
	pc = 0x82A24008; continue 'dispatch;
	}
	// 82A23BE0: 895F0078  lbz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82A23BE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A23BE8: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A23BEC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A23BF0: 9B5F007A  stb r26, 0x7a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(122 as u32), ctx.r[26].u8 ) };
	// 82A23BF4: 41820020  beq 0x82a23c14
	if ctx.cr[0].eq {
	pc = 0x82A23C14; continue 'dispatch;
	}
	// 82A23BF8: 933F0068  stw r25, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[25].u32 ) };
	// 82A23BFC: 4BFFEC05  bl 0x82a22800
	ctx.lr = 0x82A23C00;
	sub_82A22800(ctx, base);
	// 82A23C00: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A23C04: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 82A23C08: 396B1054  addi r11, r11, 0x1054
	ctx.r[11].s64 = ctx.r[11].s64 + 4180;
	// 82A23C0C: 388B0018  addi r4, r11, 0x18
	ctx.r[4].s64 = ctx.r[11].s64 + 24;
	// 82A23C10: 4BFFFFA0  b 0x82a23bb0
	pc = 0x82A23BB0; continue 'dispatch;
	// 82A23C14: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A23C18: 808B02C4  lwz r4, 0x2c4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(708 as u32) ) } as u64;
	// 82A23C1C: 4BFFECAD  bl 0x82a228c8
	ctx.lr = 0x82A23C20;
	sub_82A228C8(ctx, base);
	// 82A23C20: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82A23C24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A23C28: 815F00C4  lwz r10, 0xc4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A23C2C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A23C30: 41990020  bgt cr6, 0x82a23c50
	if ctx.cr[6].gt {
	pc = 0x82A23C50; continue 'dispatch;
	}
	// 82A23C34: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A23C38: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A23C3C: 4BFFEBC5  bl 0x82a22800
	ctx.lr = 0x82A23C40;
	sub_82A22800(ctx, base);
	// 82A23C40: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A23C44: 396B1054  addi r11, r11, 0x1054
	ctx.r[11].s64 = ctx.r[11].s64 + 4180;
	// 82A23C48: 388B0048  addi r4, r11, 0x48
	ctx.r[4].s64 = ctx.r[11].s64 + 72;
	// 82A23C4C: 4BFFFF60  b 0x82a23bac
	pc = 0x82A23BAC; continue 'dispatch;
	// 82A23C50: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A23C54: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A23C58: 396B1054  addi r11, r11, 0x1054
	ctx.r[11].s64 = ctx.r[11].s64 + 4180;
	// 82A23C5C: 388BFFF0  addi r4, r11, -0x10
	ctx.r[4].s64 = ctx.r[11].s64 + -16;
	// 82A23C60: 4BFFF831  bl 0x82a23490
	ctx.lr = 0x82A23C64;
	sub_82A23490(ctx, base);
	// 82A23C64: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82A23C68: 480000B0  b 0x82a23d18
	pc = 0x82A23D18; continue 'dispatch;
	// 82A23C6C: 815F0070  lwz r10, 0x70(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A23C70: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A23C74: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A23C78: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A23C7C: 409A038C  bne cr6, 0x82a24008
	if !ctx.cr[6].eq {
	pc = 0x82A24008; continue 'dispatch;
	}
	// 82A23C80: 895F007A  lbz r10, 0x7a(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(122 as u32) ) } as u64;
	// 82A23C84: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A23C88: 41820380  beq 0x82a24008
	if ctx.cr[0].eq {
	pc = 0x82A24008; continue 'dispatch;
	}
	// 82A23C8C: 895F0078  lbz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82A23C90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A23C94: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A23C98: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A23C9C: 9B5F007A  stb r26, 0x7a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(122 as u32), ctx.r[26].u8 ) };
	// 82A23CA0: 41820020  beq 0x82a23cc0
	if ctx.cr[0].eq {
	pc = 0x82A23CC0; continue 'dispatch;
	}
	// 82A23CA4: 935F0068  stw r26, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[26].u32 ) };
	// 82A23CA8: 4BFFEB59  bl 0x82a22800
	ctx.lr = 0x82A23CAC;
	sub_82A22800(ctx, base);
	// 82A23CAC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A23CB0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A23CB4: 396B1054  addi r11, r11, 0x1054
	ctx.r[11].s64 = ctx.r[11].s64 + 4180;
	// 82A23CB8: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 82A23CBC: 4BFFFEF4  b 0x82a23bb0
	pc = 0x82A23BB0; continue 'dispatch;
	// 82A23CC0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A23CC4: 808B02C0  lwz r4, 0x2c0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(704 as u32) ) } as u64;
	// 82A23CC8: 4BFFEC01  bl 0x82a228c8
	ctx.lr = 0x82A23CCC;
	sub_82A228C8(ctx, base);
	// 82A23CCC: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82A23CD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A23CD4: 815F00C4  lwz r10, 0xc4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A23CD8: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A23CDC: 41990024  bgt cr6, 0x82a23d00
	if ctx.cr[6].gt {
	pc = 0x82A23D00; continue 'dispatch;
	}
	// 82A23CE0: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A23CE4: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A23CE8: 4BFFEB19  bl 0x82a22800
	ctx.lr = 0x82A23CEC;
	sub_82A22800(ctx, base);
	// 82A23CEC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A23CF0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A23CF4: 396B1054  addi r11, r11, 0x1054
	ctx.r[11].s64 = ctx.r[11].s64 + 4180;
	// 82A23CF8: 388B0038  addi r4, r11, 0x38
	ctx.r[4].s64 = ctx.r[11].s64 + 56;
	// 82A23CFC: 4BFFFEB4  b 0x82a23bb0
	pc = 0x82A23BB0; continue 'dispatch;
	// 82A23D00: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A23D04: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82A23D08: 396B1054  addi r11, r11, 0x1054
	ctx.r[11].s64 = ctx.r[11].s64 + 4180;
	// 82A23D0C: 388BFFE8  addi r4, r11, -0x18
	ctx.r[4].s64 = ctx.r[11].s64 + -24;
	// 82A23D10: 4BFFF781  bl 0x82a23490
	ctx.lr = 0x82A23D14;
	sub_82A23490(ctx, base);
	// 82A23D14: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A23D18: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A23D1C: 480002EC  b 0x82a24008
	pc = 0x82A24008; continue 'dispatch;
	// 82A23D20: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A23D24: 4BFA62FD  bl 0x829ca020
	ctx.lr = 0x82A23D28;
	sub_829CA020(ctx, base);
	// 82A23D28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A23D2C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A23D30: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A23D34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A23D38: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A23D3C: 419A0024  beq cr6, 0x82a23d60
	if ctx.cr[6].eq {
	pc = 0x82A23D60; continue 'dispatch;
	}
	// 82A23D40: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A23D44: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A23D48: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A23D4C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A23D50: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A23D54: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A23D58: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A23D5C: 4082FFE8  bne 0x82a23d44
	if !ctx.cr[0].eq {
	pc = 0x82A23D44; continue 'dispatch;
	}
	// 82A23D60: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A23D64: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A23D68: 4BAEB761  bl 0x8250f4c8
	ctx.lr = 0x82A23D6C;
	sub_8250F4C8(ctx, base);
	// 82A23D6C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A23D70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A23D74: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A23D78: 409A0008  bne cr6, 0x82a23d80
	if !ctx.cr[6].eq {
	pc = 0x82A23D80; continue 'dispatch;
	}
	// 82A23D7C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A23D80: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A23D84: 3BBB0028  addi r29, r27, 0x28
	ctx.r[29].s64 = ctx.r[27].s64 + 40;
	// 82A23D88: 3BC10068  addi r30, r1, 0x68
	ctx.r[30].s64 = ctx.r[1].s64 + 104;
	// 82A23D8C: 4BAE4C8D  bl 0x82508a18
	ctx.lr = 0x82A23D90;
	sub_82508A18(ctx, base);
	// 82A23D90: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A23D94: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A23D98: 3B8BA760  addi r28, r11, -0x58a0
	ctx.r[28].s64 = ctx.r[11].s64 + -22688;
	// 82A23D9C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A23DA0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A23DA4: 38A000C1  li r5, 0xc1
	ctx.r[5].s64 = 193;
	// 82A23DA8: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A23DAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A23DB0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A23DB4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A23DB8: 48434C89  bl 0x82e58a40
	ctx.lr = 0x82A23DBC;
	sub_82E58A40(ctx, base);
	// 82A23DBC: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A23DC0: 483CDED1  bl 0x82df1c90
	ctx.lr = 0x82A23DC4;
	sub_82DF1C90(ctx, base);
	// 82A23DC4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A23DC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A23DCC: 419A0008  beq cr6, 0x82a23dd4
	if ctx.cr[6].eq {
	pc = 0x82A23DD4; continue 'dispatch;
	}
	// 82A23DD0: 4B89CAC1  bl 0x822c0890
	ctx.lr = 0x82A23DD4;
	sub_822C0890(ctx, base);
	// 82A23DD4: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A23DD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A23DDC: 419A0008  beq cr6, 0x82a23de4
	if ctx.cr[6].eq {
	pc = 0x82A23DE4; continue 'dispatch;
	}
	// 82A23DE0: 4B89CAB1  bl 0x822c0890
	ctx.lr = 0x82A23DE4;
	sub_822C0890(ctx, base);
	// 82A23DE4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A23DE8: 48008BF1  bl 0x82a2c9d8
	ctx.lr = 0x82A23DEC;
	sub_82A2C9D8(ctx, base);
	// 82A23DEC: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82A23DF0: 48008171  bl 0x82a2bf60
	ctx.lr = 0x82A23DF4;
	sub_82A2BF60(ctx, base);
	// 82A23DF4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A23DF8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A23DFC: 4BAEB6CD  bl 0x8250f4c8
	ctx.lr = 0x82A23E00;
	sub_8250F4C8(ctx, base);
	// 82A23E00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A23E04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A23E08: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A23E0C: 409A0008  bne cr6, 0x82a23e14
	if !ctx.cr[6].eq {
	pc = 0x82A23E14; continue 'dispatch;
	}
	// 82A23E10: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A23E14: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A23E18: 4BAE4869  bl 0x82508680
	ctx.lr = 0x82A23E1C;
	sub_82508680(ctx, base);
	// 82A23E1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A23E20: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A23E24: 483CDE6D  bl 0x82df1c90
	ctx.lr = 0x82A23E28;
	sub_82DF1C90(ctx, base);
	// 82A23E28: 9B210050  stb r25, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u8 ) };
	// 82A23E2C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A23E30: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A23E34: 4BB54A9D  bl 0x825788d0
	ctx.lr = 0x82A23E38;
	sub_825788D0(ctx, base);
	// 82A23E38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A23E3C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A23E40: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A23E44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A23E48: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A23E4C: 419A0024  beq cr6, 0x82a23e70
	if ctx.cr[6].eq {
	pc = 0x82A23E70; continue 'dispatch;
	}
	// 82A23E50: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A23E54: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A23E58: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A23E5C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A23E60: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A23E64: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A23E68: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A23E6C: 4082FFE8  bne 0x82a23e54
	if !ctx.cr[0].eq {
	pc = 0x82A23E54; continue 'dispatch;
	}
	// 82A23E70: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A23E74: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A23E78: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82A23E7C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A23E80: 38A000C7  li r5, 0xc7
	ctx.r[5].s64 = 199;
	// 82A23E84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A23E88: 48434BB9  bl 0x82e58a40
	ctx.lr = 0x82A23E8C;
	sub_82E58A40(ctx, base);
	// 82A23E8C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A23E90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A23E94: 419A0008  beq cr6, 0x82a23e9c
	if ctx.cr[6].eq {
	pc = 0x82A23E9C; continue 'dispatch;
	}
	// 82A23E98: 4B89C9F9  bl 0x822c0890
	ctx.lr = 0x82A23E9C;
	sub_822C0890(ctx, base);
	// 82A23E9C: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A23EA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A23EA4: 419A0008  beq cr6, 0x82a23eac
	if ctx.cr[6].eq {
	pc = 0x82A23EAC; continue 'dispatch;
	}
	// 82A23EA8: 4B89C9E9  bl 0x822c0890
	ctx.lr = 0x82A23EAC;
	sub_822C0890(ctx, base);
	// 82A23EAC: 9B210050  stb r25, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u8 ) };
	// 82A23EB0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A23EB4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82A23EB8: 4BA9EBE1  bl 0x824c2a98
	ctx.lr = 0x82A23EBC;
	sub_824C2A98(ctx, base);
	// 82A23EBC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A23EC0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A23EC4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A23EC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A23ECC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A23ED0: 419A0024  beq cr6, 0x82a23ef4
	if ctx.cr[6].eq {
	pc = 0x82A23EF4; continue 'dispatch;
	}
	// 82A23ED4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A23ED8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A23EDC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A23EE0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A23EE4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A23EE8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A23EEC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A23EF0: 4082FFE8  bne 0x82a23ed8
	if !ctx.cr[0].eq {
	pc = 0x82A23ED8; continue 'dispatch;
	}
	// 82A23EF4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A23EF8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82A23EFC: 4BAEB5CD  bl 0x8250f4c8
	ctx.lr = 0x82A23F00;
	sub_8250F4C8(ctx, base);
	// 82A23F00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A23F04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A23F08: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A23F0C: 409A0008  bne cr6, 0x82a23f14
	if !ctx.cr[6].eq {
	pc = 0x82A23F14; continue 'dispatch;
	}
	// 82A23F10: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A23F14: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 82A23F18: 4BAE4B69  bl 0x82508a80
	ctx.lr = 0x82A23F1C;
	sub_82508A80(ctx, base);
	// 82A23F1C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A23F20: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A23F24: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A23F28: 38A000C9  li r5, 0xc9
	ctx.r[5].s64 = 201;
	// 82A23F2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A23F30: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A23F34: 48434B0D  bl 0x82e58a40
	ctx.lr = 0x82A23F38;
	sub_82E58A40(ctx, base);
	// 82A23F38: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82A23F3C: 483CDD55  bl 0x82df1c90
	ctx.lr = 0x82A23F40;
	sub_82DF1C90(ctx, base);
	// 82A23F40: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A23F44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A23F48: 419A0008  beq cr6, 0x82a23f50
	if ctx.cr[6].eq {
	pc = 0x82A23F50; continue 'dispatch;
	}
	// 82A23F4C: 4B89C945  bl 0x822c0890
	ctx.lr = 0x82A23F50;
	sub_822C0890(ctx, base);
	// 82A23F50: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82A23F54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A23F58: 419A0008  beq cr6, 0x82a23f60
	if ctx.cr[6].eq {
	pc = 0x82A23F60; continue 'dispatch;
	}
	// 82A23F5C: 4B89C935  bl 0x822c0890
	ctx.lr = 0x82A23F60;
	sub_822C0890(ctx, base);
	// 82A23F60: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A23F64: 4BFF417D  bl 0x82a180e0
	ctx.lr = 0x82A23F68;
	sub_82A180E0(ctx, base);
	// 82A23F68: 9B410050  stb r26, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u8 ) };
	// 82A23F6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A23F70: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82A23F74: 4BA85FF5  bl 0x824a9f68
	ctx.lr = 0x82A23F78;
	sub_824A9F68(ctx, base);
	// 82A23F78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A23F7C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A23F80: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A23F84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A23F88: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82A23F8C: 419A0024  beq cr6, 0x82a23fb0
	if ctx.cr[6].eq {
	pc = 0x82A23FB0; continue 'dispatch;
	}
	// 82A23F90: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A23F94: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A23F98: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A23F9C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A23FA0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A23FA4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A23FA8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A23FAC: 4082FFE8  bne 0x82a23f94
	if !ctx.cr[0].eq {
	pc = 0x82A23F94; continue 'dispatch;
	}
	// 82A23FB0: 3BC10070  addi r30, r1, 0x70
	ctx.r[30].s64 = ctx.r[1].s64 + 112;
	// 82A23FB4: 4BFEEEF5  bl 0x82a12ea8
	ctx.lr = 0x82A23FB8;
	sub_82A12EA8(ctx, base);
	// 82A23FB8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A23FBC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A23FC0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A23FC4: 38A000CD  li r5, 0xcd
	ctx.r[5].s64 = 205;
	// 82A23FC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A23FCC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A23FD0: 48434A71  bl 0x82e58a40
	ctx.lr = 0x82A23FD4;
	sub_82E58A40(ctx, base);
	// 82A23FD4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A23FD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A23FDC: 419A0008  beq cr6, 0x82a23fe4
	if ctx.cr[6].eq {
	pc = 0x82A23FE4; continue 'dispatch;
	}
	// 82A23FE0: 4B89C8B1  bl 0x822c0890
	ctx.lr = 0x82A23FE4;
	sub_822C0890(ctx, base);
	// 82A23FE4: 806100E4  lwz r3, 0xe4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A23FE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A23FEC: 419A0008  beq cr6, 0x82a23ff4
	if ctx.cr[6].eq {
	pc = 0x82A23FF4; continue 'dispatch;
	}
	// 82A23FF0: 4B89C8A1  bl 0x822c0890
	ctx.lr = 0x82A23FF4;
	sub_822C0890(ctx, base);
	// 82A23FF4: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A23FF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A23FFC: 419A0008  beq cr6, 0x82a24004
	if ctx.cr[6].eq {
	pc = 0x82A24004; continue 'dispatch;
	}
	// 82A24000: 4B89C891  bl 0x822c0890
	ctx.lr = 0x82A24004;
	sub_822C0890(ctx, base);
	// 82A24004: 933F0064  stw r25, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 82A24008: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82A2400C: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82A24010: 4878419C  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A24018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A24018 size=96
    let mut pc: u32 = 0x82A24018;
    'dispatch: loop {
        match pc {
            0x82A24018 => {
    //   block [0x82A24018..0x82A24078)
	// 82A24018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2401C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A24020: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A24024: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A24028: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2402C: 4BFFA11D  bl 0x82a1e148
	ctx.lr = 0x82A24030;
	sub_82A1E148(ctx, base);
	// 82A24030: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A24034: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A24038: 396BA7FC  addi r11, r11, -0x5804
	ctx.r[11].s64 = ctx.r[11].s64 + -22532;
	// 82A2403C: 388AA0EC  addi r4, r10, -0x5f14
	ctx.r[4].s64 = ctx.r[10].s64 + -24340;
	// 82A24040: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A24044: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A24048: 483CF9C1  bl 0x82df3a08
	ctx.lr = 0x82A2404C;
	sub_82DF3A08(ctx, base);
	// 82A2404C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A24050: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A24054: 48435695  bl 0x82e596e8
	ctx.lr = 0x82A24058;
	sub_82E596E8(ctx, base);
	// 82A24058: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2405C: 483CF3CD  bl 0x82df3428
	ctx.lr = 0x82A24060;
	sub_82DF3428(ctx, base);
	// 82A24060: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A24064: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A24068: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2406C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A24070: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A24074: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A24078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A24078 size=508
    let mut pc: u32 = 0x82A24078;
    'dispatch: loop {
        match pc {
            0x82A24078 => {
    //   block [0x82A24078..0x82A24274)
	// 82A24078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2407C: 487840E9  bl 0x831a8164
	ctx.lr = 0x82A24080;
	sub_831A8130(ctx, base);
	// 82A24080: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A24084: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A24088: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A2408C: 48730575  bl 0x83154600
	ctx.lr = 0x82A24090;
	sub_83154600(ctx, base);
	// 82A24090: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A24094: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A24098: 4BF66D21  bl 0x8298adb8
	ctx.lr = 0x82A2409C;
	sub_8298ADB8(ctx, base);
	// 82A2409C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A240A0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A240A4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A240A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A240AC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A240B0: 419A0024  beq cr6, 0x82a240d4
	if ctx.cr[6].eq {
	pc = 0x82A240D4; continue 'dispatch;
	}
	// 82A240B4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A240B8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A240BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A240C0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A240C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A240C8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A240CC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A240D0: 4082FFE8  bne 0x82a240b8
	if !ctx.cr[0].eq {
	pc = 0x82A240B8; continue 'dispatch;
	}
	// 82A240D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A240D8: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 82A240DC: 4BFEF4A5  bl 0x82a13580
	ctx.lr = 0x82A240E0;
	sub_82A13580(ctx, base);
	// 82A240E0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A240E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A240E8: 3BEBA820  addi r31, r11, -0x57e0
	ctx.r[31].s64 = ctx.r[11].s64 + -22496;
	// 82A240EC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A240F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A240F4: 38A00032  li r5, 0x32
	ctx.r[5].s64 = 50;
	// 82A240F8: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A240FC: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82A24100: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A24104: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A24108: 48434939  bl 0x82e58a40
	ctx.lr = 0x82A2410C;
	sub_82E58A40(ctx, base);
	// 82A2410C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A24110: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A24114: 419A0008  beq cr6, 0x82a2411c
	if ctx.cr[6].eq {
	pc = 0x82A2411C; continue 'dispatch;
	}
	// 82A24118: 4B89C779  bl 0x822c0890
	ctx.lr = 0x82A2411C;
	sub_822C0890(ctx, base);
	// 82A2411C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A24120: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A24124: 419A0008  beq cr6, 0x82a2412c
	if ctx.cr[6].eq {
	pc = 0x82A2412C; continue 'dispatch;
	}
	// 82A24128: 4B89C769  bl 0x822c0890
	ctx.lr = 0x82A2412C;
	sub_822C0890(ctx, base);
	// 82A2412C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A24130: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A24134: 38A00034  li r5, 0x34
	ctx.r[5].s64 = 52;
	// 82A24138: 386000F8  li r3, 0xf8
	ctx.r[3].s64 = 248;
	// 82A2413C: 483CE2AD  bl 0x82df23e8
	ctx.lr = 0x82A24140;
	sub_82DF23E8(ctx, base);
	// 82A24140: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A24144: 4182001C  beq 0x82a24160
	if ctx.cr[0].eq {
	pc = 0x82A24160; continue 'dispatch;
	}
	// 82A24148: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A2414C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A24150: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 82A24154: 4BF6283D  bl 0x82986990
	ctx.lr = 0x82A24158;
	sub_82986990(ctx, base);
	// 82A24158: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2415C: 48000008  b 0x82a24164
	pc = 0x82A24164; continue 'dispatch;
	// 82A24160: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A24164: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A24168: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2416C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A24170: 4BF63799  bl 0x82987908
	ctx.lr = 0x82A24174;
	sub_82987908(ctx, base);
	// 82A24174: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A24178: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2417C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A24180: 4B89BE81  bl 0x822c0000
	ctx.lr = 0x82A24184;
	sub_822C0000(ctx, base);
	// 82A24184: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A24188: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A2418C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A24190: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82A24194: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A24198: 419A0024  beq cr6, 0x82a241bc
	if ctx.cr[6].eq {
	pc = 0x82A241BC; continue 'dispatch;
	}
	// 82A2419C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82A241A0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A241A4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A241A8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A241AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A241B0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A241B4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A241B8: 4082FFE8  bne 0x82a241a0
	if !ctx.cr[0].eq {
	pc = 0x82A241A0; continue 'dispatch;
	}
	// 82A241BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A241C0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A241C4: 4BAEB305  bl 0x8250f4c8
	ctx.lr = 0x82A241C8;
	sub_8250F4C8(ctx, base);
	// 82A241C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A241CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A241D0: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82A241D4: 409A0008  bne cr6, 0x82a241dc
	if !ctx.cr[6].eq {
	pc = 0x82A241DC; continue 'dispatch;
	}
	// 82A241D8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A241DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A241E0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A241E4: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 82A241E8: 4BAEB331  bl 0x8250f518
	ctx.lr = 0x82A241EC;
	sub_8250F518(ctx, base);
	// 82A241EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A241F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A241F4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A241F8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A241FC: 4BAE930D  bl 0x8250d508
	ctx.lr = 0x82A24200;
	sub_8250D508(ctx, base);
	// 82A24200: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A24204: 483CDA8D  bl 0x82df1c90
	ctx.lr = 0x82A24208;
	sub_82DF1C90(ctx, base);
	// 82A24208: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A2420C: 483CDA85  bl 0x82df1c90
	ctx.lr = 0x82A24210;
	sub_82DF1C90(ctx, base);
	// 82A24210: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A24214: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A24218: 388B893C  addi r4, r11, -0x76c4
	ctx.r[4].s64 = ctx.r[11].s64 + -30404;
	// 82A2421C: 483CF7ED  bl 0x82df3a08
	ctx.lr = 0x82A24220;
	sub_82DF3A08(ctx, base);
	// 82A24220: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A24224: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A24228: 485E3F01  bl 0x83008128
	ctx.lr = 0x82A2422C;
	sub_83008128(ctx, base);
	// 82A2422C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A24230: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A24234: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A24238: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A2423C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A24240: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A24244: 4843A71D  bl 0x82e5e960
	ctx.lr = 0x82A24248;
	sub_82E5E960(ctx, base);
	// 82A24248: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A2424C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A24250: 419A0008  beq cr6, 0x82a24258
	if ctx.cr[6].eq {
	pc = 0x82A24258; continue 'dispatch;
	}
	// 82A24254: 4B89C63D  bl 0x822c0890
	ctx.lr = 0x82A24258;
	sub_822C0890(ctx, base);
	// 82A24258: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A2425C: 419A000C  beq cr6, 0x82a24268
	if ctx.cr[6].eq {
	pc = 0x82A24268; continue 'dispatch;
	}
	// 82A24260: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A24264: 4B89C62D  bl 0x822c0890
	ctx.lr = 0x82A24268;
	sub_822C0890(ctx, base);
	// 82A24268: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A2426C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A24270: 48783F44  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A24278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A24278 size=180
    let mut pc: u32 = 0x82A24278;
    'dispatch: loop {
        match pc {
            0x82A24278 => {
    //   block [0x82A24278..0x82A2432C)
	// 82A24278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2427C: 48783EF1  bl 0x831a816c
	ctx.lr = 0x82A24280;
	sub_831A8130(ctx, base);
	// 82A24280: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A24284: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A24288: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2428C: 48730375  bl 0x83154600
	ctx.lr = 0x82A24290;
	sub_83154600(ctx, base);
	// 82A24290: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A24294: 4BFEEC25  bl 0x82a12eb8
	ctx.lr = 0x82A24298;
	sub_82A12EB8(ctx, base);
	// 82A24298: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A2429C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A242A0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A242A4: 915F0064  stw r10, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82A242A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A242AC: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A242B0: D3FF0060  stfs f31, 0x60(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A242B4: 4BFEECE5  bl 0x82a12f98
	ctx.lr = 0x82A242B8;
	sub_82A12F98(ctx, base);
	// 82A242B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A242BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A242C0: 4BFF5AA1  bl 0x82a19d60
	ctx.lr = 0x82A242C4;
	sub_82A19D60(ctx, base);
	// 82A242C4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A242C8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A242CC: 39200070  li r9, 0x70
	ctx.r[9].s64 = 112;
	// 82A242D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A242D4: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82A242D8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A242DC: C00A08A8  lfs f0, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A242E0: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A242E4: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A242E8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82A242EC: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A24330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A24330 size=72
    let mut pc: u32 = 0x82A24330;
    'dispatch: loop {
        match pc {
            0x82A24330 => {
    //   block [0x82A24330..0x82A24378)
	// 82A24330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A24334: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A24338: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2433C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A24340: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A24344: 487302BD  bl 0x83154600
	ctx.lr = 0x82A24348;
	sub_83154600(ctx, base);
	// 82A24348: 4BFEEB71  bl 0x82a12eb8
	ctx.lr = 0x82A2434C;
	sub_82A12EB8(ctx, base);
	// 82A2434C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A24350: 38800022  li r4, 0x22
	ctx.r[4].s64 = 34;
	// 82A24354: C02B9EFC  lfs f1, -0x6104(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24836 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A24358: 4BFF5211  bl 0x82a19568
	ctx.lr = 0x82A2435C;
	sub_82A19568(ctx, base);
	// 82A2435C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A24360: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A24364: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A24368: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2436C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A24370: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A24374: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A24378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A24378 size=108
    let mut pc: u32 = 0x82A24378;
    'dispatch: loop {
        match pc {
            0x82A24378 => {
    //   block [0x82A24378..0x82A243E4)
	// 82A24378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2437C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A24380: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A24384: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A24388: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2438C: 4BFF9DBD  bl 0x82a1e148
	ctx.lr = 0x82A24390;
	sub_82A1E148(ctx, base);
	// 82A24390: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A24394: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A24398: 394AA870  addi r10, r10, -0x5790
	ctx.r[10].s64 = ctx.r[10].s64 + -22416;
	// 82A2439C: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A243A0: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82A243A4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A243A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A243AC: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A243B0: 388917D4  addi r4, r9, 0x17d4
	ctx.r[4].s64 = ctx.r[9].s64 + 6100;
	// 82A243B4: 483CF655  bl 0x82df3a08
	ctx.lr = 0x82A243B8;
	sub_82DF3A08(ctx, base);
	// 82A243B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A243BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A243C0: 48435329  bl 0x82e596e8
	ctx.lr = 0x82A243C4;
	sub_82E596E8(ctx, base);
	// 82A243C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A243C8: 483CF061  bl 0x82df3428
	ctx.lr = 0x82A243CC;
	sub_82DF3428(ctx, base);
	// 82A243CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A243D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A243D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A243D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A243DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A243E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A243E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A243E8 size=904
    let mut pc: u32 = 0x82A243E8;
    'dispatch: loop {
        match pc {
            0x82A243E8 => {
    //   block [0x82A243E8..0x82A24770)
	// 82A243E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A243EC: 48783D75  bl 0x831a8160
	ctx.lr = 0x82A243F0;
	sub_831A8130(ctx, base);
	// 82A243F0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82A243F4: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A243F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A243FC: 48730205  bl 0x83154600
	ctx.lr = 0x82A24400;
	sub_83154600(ctx, base);
	// 82A24400: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A24404: 4BFEEAB5  bl 0x82a12eb8
	ctx.lr = 0x82A24408;
	sub_82A12EB8(ctx, base);
	// 82A24408: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A2440C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A24410: 4BFEF131  bl 0x82a13540
	ctx.lr = 0x82A24414;
	sub_82A13540(ctx, base);
	// 82A24414: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A24418: 41820018  beq 0x82a24430
	if ctx.cr[0].eq {
	pc = 0x82A24430; continue 'dispatch;
	}
	// 82A2441C: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A24420: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82A24424: 419A000C  beq cr6, 0x82a24430
	if ctx.cr[6].eq {
	pc = 0x82A24430; continue 'dispatch;
	}
	// 82A24428: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2442C: 4BFFFF05  bl 0x82a24330
	ctx.lr = 0x82A24430;
	sub_82A24330(ctx, base);
	// 82A24430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A24434: 48435345  bl 0x82e59778
	ctx.lr = 0x82A24438;
	sub_82E59778(ctx, base);
	// 82A24438: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A2443C: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A24440: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A24444: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A24448: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A2444C: 41980290  blt cr6, 0x82a246dc
	if ctx.cr[6].lt {
	pc = 0x82A246DC; continue 'dispatch;
	}
	// 82A24450: 419A0060  beq cr6, 0x82a244b0
	if ctx.cr[6].eq {
	pc = 0x82A244B0; continue 'dispatch;
	}
	// 82A24454: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A24458: 4098030C  bge cr6, 0x82a24764
	if !ctx.cr[6].lt {
	pc = 0x82A24764; continue 'dispatch;
	}
	// 82A2445C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A24460: 4BFEF0E1  bl 0x82a13540
	ctx.lr = 0x82A24464;
	sub_82A13540(ctx, base);
	// 82A24464: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A24468: 408202FC  bne 0x82a24764
	if !ctx.cr[0].eq {
	pc = 0x82A24764; continue 'dispatch;
	}
	// 82A2446C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A24470: 3861009C  addi r3, r1, 0x9c
	ctx.r[3].s64 = ctx.r[1].s64 + 156;
	// 82A24474: 388B893C  addi r4, r11, -0x76c4
	ctx.r[4].s64 = ctx.r[11].s64 + -30404;
	// 82A24478: 483CF591  bl 0x82df3a08
	ctx.lr = 0x82A2447C;
	sub_82DF3A08(ctx, base);
	// 82A2447C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A24480: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A24484: 485E3CA5  bl 0x83008128
	ctx.lr = 0x82A24488;
	sub_83008128(ctx, base);
	// 82A24488: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A2448C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A24490: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A24494: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A24498: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A2449C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A244A0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A244A4: 4843A4BD  bl 0x82e5e960
	ctx.lr = 0x82A244A8;
	sub_82E5E960(ctx, base);
	// 82A244A8: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A244AC: 4800007C  b 0x82a24528
	pc = 0x82A24528; continue 'dispatch;
	// 82A244B0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A244B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A244B8: 4BFF58A9  bl 0x82a19d60
	ctx.lr = 0x82A244BC;
	sub_82A19D60(ctx, base);
	// 82A244BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A244C0: 4BFF2059  bl 0x82a16518
	ctx.lr = 0x82A244C4;
	sub_82A16518(ctx, base);
	// 82A244C4: 2F030101  cmpwi cr6, r3, 0x101
	ctx.cr[6].compare_i32(ctx.r[3].s32, 257, &mut ctx.xer);
	// 82A244C8: 419A01E4  beq cr6, 0x82a246ac
	if ctx.cr[6].eq {
	pc = 0x82A246AC; continue 'dispatch;
	}
	// 82A244CC: 2F030102  cmpwi cr6, r3, 0x102
	ctx.cr[6].compare_i32(ctx.r[3].s32, 258, &mut ctx.xer);
	// 82A244D0: 419A01DC  beq cr6, 0x82a246ac
	if ctx.cr[6].eq {
	pc = 0x82A246AC; continue 'dispatch;
	}
	// 82A244D4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A244D8: C1BF0060  lfs f13, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A244DC: C00B9E14  lfs f0, -0x61ec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A244E0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A244E4: 41990054  bgt cr6, 0x82a24538
	if ctx.cr[6].gt {
	pc = 0x82A24538; continue 'dispatch;
	}
	// 82A244E8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A244EC: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A244F0: 388BA0CC  addi r4, r11, -0x5f34
	ctx.r[4].s64 = ctx.r[11].s64 + -24372;
	// 82A244F4: 483CF515  bl 0x82df3a08
	ctx.lr = 0x82A244F8;
	sub_82DF3A08(ctx, base);
	// 82A244F8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A244FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A24500: 485E3C29  bl 0x83008128
	ctx.lr = 0x82A24504;
	sub_83008128(ctx, base);
	// 82A24504: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A24508: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A2450C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A24510: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A24514: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A24518: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A2451C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A24520: 4843A441  bl 0x82e5e960
	ctx.lr = 0x82A24524;
	sub_82E5E960(ctx, base);
	// 82A24524: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A24528: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2452C: 419A0238  beq cr6, 0x82a24764
	if ctx.cr[6].eq {
	pc = 0x82A24764; continue 'dispatch;
	}
	// 82A24530: 4B89C361  bl 0x822c0890
	ctx.lr = 0x82A24534;
	sub_822C0890(ctx, base);
	// 82A24534: 48000230  b 0x82a24764
	pc = 0x82A24764; continue 'dispatch;
	// 82A24538: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A2453C: C0210050  lfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A24540: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A24544: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82A24548: 4BFEF059  bl 0x82a135a0
	ctx.lr = 0x82A2454C;
	sub_82A135A0(ctx, base);
	// 82A2454C: D0210050  stfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A24550: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82A24554: C0210058  lfs f1, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A24558: 4BFEF079  bl 0x82a135d0
	ctx.lr = 0x82A2455C;
	sub_82A135D0(ctx, base);
	// 82A2455C: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A24560: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A24564: D0210058  stfs f1, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82A24568: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A2456C: 3B800070  li r28, 0x70
	ctx.r[28].s64 = 112;
	// 82A24570: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A24574: 814A9F0C  lwz r10, -0x60f4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24820 as u32) ) } as u64;
	// 82A24578: 7D2B5396  divwu r9, r11, r10
	ctx.r[9].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 82A2457C: 0CCA0000  twi 6, r10, 0
	// 82A24580: 7D4951D6  mullw r10, r9, r10
	ctx.r[10].s64 = (ctx.r[9].s32 as i64) * (ctx.r[10].s32 as i64);
	// 82A24584: 7D6A5851  subf. r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A24588: 40820060  bne 0x82a245e8
	if !ctx.cr[0].eq {
	pc = 0x82A245E8; continue 'dispatch;
	}
	// 82A2458C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A24590: 4BFEF281  bl 0x82a13810
	ctx.lr = 0x82A24594;
	sub_82A13810(ctx, base);
	// 82A24594: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A24598: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2459C: 3B410050  addi r26, r1, 0x50
	ctx.r[26].s64 = ctx.r[1].s64 + 80;
	// 82A245A0: 83BB0000  lwz r29, 0(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A245A4: 4BFEF0DD  bl 0x82a13680
	ctx.lr = 0x82A245A8;
	sub_82A13680(ctx, base);
	// 82A245A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A245AC: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A245B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A245B4: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82A245B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A245BC: 4E800421  bctrl
	ctx.lr = 0x82A245C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A245C0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A245C4: 41820024  beq 0x82a245e8
	if ctx.cr[0].eq {
	pc = 0x82A245E8; continue 'dispatch;
	}
	// 82A245C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A245CC: 4BFEF245  bl 0x82a13810
	ctx.lr = 0x82A245D0;
	sub_82A13810(ctx, base);
	// 82A245D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A245D4: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82A245D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A245DC: 4E800421  bctrl
	ctx.lr = 0x82A245E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A245E0: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A24770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A24770 size=124
    let mut pc: u32 = 0x82A24770;
    'dispatch: loop {
        match pc {
            0x82A24770 => {
    //   block [0x82A24770..0x82A247EC)
	// 82A24770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A24774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A24778: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2477C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A24780: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A24784: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A24788: 419A004C  beq cr6, 0x82a247d4
	if ctx.cr[6].eq {
	pc = 0x82A247D4; continue 'dispatch;
	}
	// 82A2478C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A24790: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A24794: 419A0018  beq cr6, 0x82a247ac
	if ctx.cr[6].eq {
	pc = 0x82A247AC; continue 'dispatch;
	}
	// 82A24798: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2479C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A247A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A247A4: 4E800421  bctrl
	ctx.lr = 0x82A247A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A247A8: 4800000C  b 0x82a247b4
	pc = 0x82A247B4; continue 'dispatch;
	// 82A247AC: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82A247B0: 386B869C  addi r3, r11, -0x7964
	ctx.r[3].s64 = ctx.r[11].s64 + -31076;
	// 82A247B4: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82A247B8: 388B7624  addi r4, r11, 0x7624
	ctx.r[4].s64 = ctx.r[11].s64 + 30244;
	// 82A247BC: 4878393D  bl 0x831a80f8
	ctx.lr = 0x82A247C0;
	sub_831A80F8(ctx, base);
	// 82A247C0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A247C4: 41820010  beq 0x82a247d4
	if ctx.cr[0].eq {
	pc = 0x82A247D4; continue 'dispatch;
	}
	// 82A247C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A247CC: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82A247D0: 48000008  b 0x82a247d8
	pc = 0x82A247D8; continue 'dispatch;
	// 82A247D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A247D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A247DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A247E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A247E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A247E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A247F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A247F0 size=124
    let mut pc: u32 = 0x82A247F0;
    'dispatch: loop {
        match pc {
            0x82A247F0 => {
    //   block [0x82A247F0..0x82A2486C)
	// 82A247F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A247F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A247F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A247FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A24800: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A24804: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A24808: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82A2480C: 4BFFFF65  bl 0x82a24770
	ctx.lr = 0x82A24810;
	sub_82A24770(ctx, base);
	// 82A24810: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A24814: 40820030  bne 0x82a24844
	if !ctx.cr[0].eq {
	pc = 0x82A24844; continue 'dispatch;
	}
	// 82A24818: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A2481C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A24820: 396B94B4  addi r11, r11, -0x6b4c
	ctx.r[11].s64 = ctx.r[11].s64 + -27468;
	// 82A24824: 394A1014  addi r10, r10, 0x1014
	ctx.r[10].s64 = ctx.r[10].s64 + 4116;
	// 82A24828: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A2482C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A24830: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A24834: 4B89B7CD  bl 0x822c0000
	ctx.lr = 0x82A24838;
	sub_822C0000(ctx, base);
	// 82A24838: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A2483C: 396B0818  addi r11, r11, 0x818
	ctx.r[11].s64 = ctx.r[11].s64 + 2072;
	// 82A24840: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A24844: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A24848: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2484C: 483CF3B5  bl 0x82df3c00
	ctx.lr = 0x82A24850;
	sub_82DF3C00(ctx, base);
	// 82A24850: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A24854: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A24858: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2485C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A24860: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A24864: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A24868: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A24870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A24870 size=124
    let mut pc: u32 = 0x82A24870;
    'dispatch: loop {
        match pc {
            0x82A24870 => {
    //   block [0x82A24870..0x82A248EC)
	// 82A24870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A24874: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A24878: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2487C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A24880: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A24884: 4BFF98C5  bl 0x82a1e148
	ctx.lr = 0x82A24888;
	sub_82A1E148(ctx, base);
	// 82A24888: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A2488C: 387F0068  addi r3, r31, 0x68
	ctx.r[3].s64 = ctx.r[31].s64 + 104;
	// 82A24890: 396BA898  addi r11, r11, -0x5768
	ctx.r[11].s64 = ctx.r[11].s64 + -22376;
	// 82A24894: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A24898: 483CE859  bl 0x82df30f0
	ctx.lr = 0x82A2489C;
	sub_82DF30F0(ctx, base);
	// 82A2489C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A248A0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 82A248A4: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A248A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A248AC: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A248B0: 388A836C  addi r4, r10, -0x7c94
	ctx.r[4].s64 = ctx.r[10].s64 + -31892;
	// 82A248B4: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82A248B8: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82A248BC: 483CF14D  bl 0x82df3a08
	ctx.lr = 0x82A248C0;
	sub_82DF3A08(ctx, base);
	// 82A248C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A248C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A248C8: 48434E21  bl 0x82e596e8
	ctx.lr = 0x82A248CC;
	sub_82E596E8(ctx, base);
	// 82A248CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A248D0: 483CEB59  bl 0x82df3428
	ctx.lr = 0x82A248D4;
	sub_82DF3428(ctx, base);
	// 82A248D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A248D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A248DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A248E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A248E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A248E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A248F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A248F0 size=88
    let mut pc: u32 = 0x82A248F0;
    'dispatch: loop {
        match pc {
            0x82A248F0 => {
    //   block [0x82A248F0..0x82A24948)
	// 82A248F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A248F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A248F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A248FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A24900: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A24904: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82A24908: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2490C: 419A0008  beq cr6, 0x82a24914
	if ctx.cr[6].eq {
	pc = 0x82A24914; continue 'dispatch;
	}
	// 82A24910: 4B89BF81  bl 0x822c0890
	ctx.lr = 0x82A24914;
	sub_822C0890(ctx, base);
	// 82A24914: 807F0070  lwz r3, 0x70(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A24918: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2491C: 419A0008  beq cr6, 0x82a24924
	if ctx.cr[6].eq {
	pc = 0x82A24924; continue 'dispatch;
	}
	// 82A24920: 4B89BF71  bl 0x822c0890
	ctx.lr = 0x82A24924;
	sub_822C0890(ctx, base);
	// 82A24924: 387F0068  addi r3, r31, 0x68
	ctx.r[3].s64 = ctx.r[31].s64 + 104;
	// 82A24928: 483CEB01  bl 0x82df3428
	ctx.lr = 0x82A2492C;
	sub_82DF3428(ctx, base);
	// 82A2492C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A24930: 48437C59  bl 0x82e5c588
	ctx.lr = 0x82A24934;
	sub_82E5C588(ctx, base);
	// 82A24934: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A24938: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2493C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A24940: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A24944: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A24948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A24948 size=76
    let mut pc: u32 = 0x82A24948;
    'dispatch: loop {
        match pc {
            0x82A24948 => {
    //   block [0x82A24948..0x82A24994)
	// 82A24948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2494C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A24950: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A24954: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A24958: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2495C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A24960: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A24964: 4BFFFF8D  bl 0x82a248f0
	ctx.lr = 0x82A24968;
	sub_82A248F0(ctx, base);
	// 82A24968: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2496C: 4182000C  beq 0x82a24978
	if ctx.cr[0].eq {
	pc = 0x82A24978; continue 'dispatch;
	}
	// 82A24970: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A24974: 483CDA65  bl 0x82df23d8
	ctx.lr = 0x82A24978;
	sub_82DF23D8(ctx, base);
	// 82A24978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2497C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A24980: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A24984: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A24988: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A2498C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A24990: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A24998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A24998 size=252
    let mut pc: u32 = 0x82A24998;
    'dispatch: loop {
        match pc {
            0x82A24998 => {
    //   block [0x82A24998..0x82A24A94)
	// 82A24998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2499C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A249A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A249A4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A249A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A249AC: 4872FC55  bl 0x83154600
	ctx.lr = 0x82A249B0;
	sub_83154600(ctx, base);
	// 82A249B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A249B4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A249B8: 4BAEAB11  bl 0x8250f4c8
	ctx.lr = 0x82A249BC;
	sub_8250F4C8(ctx, base);
	// 82A249BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A249C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A249C4: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A249C8: 409A0008  bne cr6, 0x82a249d0
	if !ctx.cr[6].eq {
	pc = 0x82A249D0; continue 'dispatch;
	}
	// 82A249CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A249D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A249D4: 4BAE5F7D  bl 0x8250a950
	ctx.lr = 0x82A249D8;
	sub_8250A950(ctx, base);
	// 82A249D8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A249DC: 483CD2B5  bl 0x82df1c90
	ctx.lr = 0x82A249E0;
	sub_82DF1C90(ctx, base);
	// 82A249E0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A249E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A249E8: 388B5558  addi r4, r11, 0x5558
	ctx.r[4].s64 = ctx.r[11].s64 + 21848;
	// 82A249EC: 483CF01D  bl 0x82df3a08
	ctx.lr = 0x82A249F0;
	sub_82DF3A08(ctx, base);
	// 82A249F0: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82A249F4: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A249F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A249FC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A24A00: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A24A04: 419A0024  beq cr6, 0x82a24a28
	if ctx.cr[6].eq {
	pc = 0x82A24A28; continue 'dispatch;
	}
	// 82A24A08: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A24A0C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A24A10: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A24A14: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A24A18: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A24A1C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A24A20: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A24A24: 4082FFE8  bne 0x82a24a0c
	if !ctx.cr[0].eq {
	pc = 0x82A24A0C; continue 'dispatch;
	}
	// 82A24A28: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A24A2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A24A30: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 82A24A34: 409A0008  bne cr6, 0x82a24a3c
	if !ctx.cr[6].eq {
	pc = 0x82A24A3C; continue 'dispatch;
	}
	// 82A24A38: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A24A3C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A24A40: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A24A44: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A24A48: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A24A4C: 4BDB0265  bl 0x827d4cb0
	ctx.lr = 0x82A24A50;
	sub_827D4CB0(ctx, base);
	// 82A24A50: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A24A54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A24A58: 419A0008  beq cr6, 0x82a24a60
	if ctx.cr[6].eq {
	pc = 0x82A24A60; continue 'dispatch;
	}
	// 82A24A5C: 4B89BE35  bl 0x822c0890
	ctx.lr = 0x82A24A60;
	sub_822C0890(ctx, base);
	// 82A24A60: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A24A64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A24A68: 419A0008  beq cr6, 0x82a24a70
	if ctx.cr[6].eq {
	pc = 0x82A24A70; continue 'dispatch;
	}
	// 82A24A6C: 4B89BE25  bl 0x822c0890
	ctx.lr = 0x82A24A70;
	sub_822C0890(ctx, base);
	// 82A24A70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A24A74: 483CE9B5  bl 0x82df3428
	ctx.lr = 0x82A24A78;
	sub_82DF3428(ctx, base);
	// 82A24A78: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A24A7C: 483CD215  bl 0x82df1c90
	ctx.lr = 0x82A24A80;
	sub_82DF1C90(ctx, base);
	// 82A24A80: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A24A84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A24A88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A24A8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A24A90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A24A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A24A98 size=628
    let mut pc: u32 = 0x82A24A98;
    'dispatch: loop {
        match pc {
            0x82A24A98 => {
    //   block [0x82A24A98..0x82A24D0C)
	// 82A24A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A24A9C: 487836C5  bl 0x831a8160
	ctx.lr = 0x82A24AA0;
	sub_831A8130(ctx, base);
	// 82A24AA0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A24AA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A24AA8: 4872FB59  bl 0x83154600
	ctx.lr = 0x82A24AAC;
	sub_83154600(ctx, base);
	// 82A24AAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A24AB0: 4BFEE409  bl 0x82a12eb8
	ctx.lr = 0x82A24AB4;
	sub_82A12EB8(ctx, base);
	// 82A24AB4: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A24AB8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A24ABC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A24AC0: 419801BC  blt cr6, 0x82a24c7c
	if ctx.cr[6].lt {
	pc = 0x82A24C7C; continue 'dispatch;
	}
	// 82A24AC4: 419A0054  beq cr6, 0x82a24b18
	if ctx.cr[6].eq {
	pc = 0x82A24B18; continue 'dispatch;
	}
	// 82A24AC8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A24ACC: 40980238  bge cr6, 0x82a24d04
	if !ctx.cr[6].lt {
	pc = 0x82A24D04; continue 'dispatch;
	}
	// 82A24AD0: 4BDCF911  bl 0x827f43e0
	ctx.lr = 0x82A24AD4;
	sub_827F43E0(ctx, base);
	// 82A24AD4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A24AD8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A24ADC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A24AE0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A24AE4: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A24AE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A24AEC: 4E800421  bctrl
	ctx.lr = 0x82A24AF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A24AF0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A24AF4: 41820210  beq 0x82a24d04
	if ctx.cr[0].eq {
	pc = 0x82A24D04; continue 'dispatch;
	}
	// 82A24AF8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A24AFC: 38800017  li r4, 0x17
	ctx.r[4].s64 = 23;
	// 82A24B00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A24B04: C02B9EFC  lfs f1, -0x6104(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24836 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A24B08: 4BFF4A61  bl 0x82a19568
	ctx.lr = 0x82A24B0C;
	sub_82A19568(ctx, base);
	// 82A24B0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A24B10: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A24B14: 480001F0  b 0x82a24d04
	pc = 0x82A24D04; continue 'dispatch;
	// 82A24B18: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A24B1C: 4BA589C5  bl 0x8247d4e0
	ctx.lr = 0x82A24B20;
	sub_8247D4E0(ctx, base);
	// 82A24B20: 83610064  lwz r27, 0x64(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A24B24: 83810060  lwz r28, 0x60(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A24B28: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82A24B2C: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 82A24B30: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82A24B34: 419A0024  beq cr6, 0x82a24b58
	if ctx.cr[6].eq {
	pc = 0x82A24B58; continue 'dispatch;
	}
	// 82A24B38: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 82A24B3C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A24B40: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A24B44: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A24B48: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A24B4C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A24B50: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A24B54: 4082FFE8  bne 0x82a24b3c
	if !ctx.cr[0].eq {
	pc = 0x82A24B3C; continue 'dispatch;
	}
	// 82A24B58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A24B5C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A24B60: 4BAEA969  bl 0x8250f4c8
	ctx.lr = 0x82A24B64;
	sub_8250F4C8(ctx, base);
	// 82A24B64: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A24B68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A24B6C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A24B70: 409A0008  bne cr6, 0x82a24b78
	if !ctx.cr[6].eq {
	pc = 0x82A24B78; continue 'dispatch;
	}
	// 82A24B74: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A24B78: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A24B7C: 3B410058  addi r26, r1, 0x58
	ctx.r[26].s64 = ctx.r[1].s64 + 88;
	// 82A24B80: 4BAE3E99  bl 0x82508a18
	ctx.lr = 0x82A24B84;
	sub_82508A18(ctx, base);
	// 82A24B84: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A24B88: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A24B8C: 388BA8D0  addi r4, r11, -0x5730
	ctx.r[4].s64 = ctx.r[11].s64 + -22320;
	// 82A24B90: 38A00062  li r5, 0x62
	ctx.r[5].s64 = 98;
	// 82A24B94: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82A24B98: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82A24B9C: 4843244D  bl 0x82e56fe8
	ctx.lr = 0x82A24BA0;
	sub_82E56FE8(ctx, base);
	// 82A24BA0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A24BA4: 483CD0ED  bl 0x82df1c90
	ctx.lr = 0x82A24BA8;
	sub_82DF1C90(ctx, base);
	// 82A24BA8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A24BAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A24BB0: 419A0008  beq cr6, 0x82a24bb8
	if ctx.cr[6].eq {
	pc = 0x82A24BB8; continue 'dispatch;
	}
	// 82A24BB4: 4B89BCDD  bl 0x822c0890
	ctx.lr = 0x82A24BB8;
	sub_822C0890(ctx, base);
	// 82A24BB8: 817C0070  lwz r11, 0x70(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A24BBC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82A24BC0: 419A005C  beq cr6, 0x82a24c1c
	if ctx.cr[6].eq {
	pc = 0x82A24C1C; continue 'dispatch;
	}
	// 82A24BC4: 389F0068  addi r4, r31, 0x68
	ctx.r[4].s64 = ctx.r[31].s64 + 104;
	// 82A24BC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A24BCC: 483CF035  bl 0x82df3c00
	ctx.lr = 0x82A24BD0;
	sub_82DF3C00(ctx, base);
	// 82A24BD0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A24BD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A24BD8: 485E3551  bl 0x83008128
	ctx.lr = 0x82A24BDC;
	sub_83008128(ctx, base);
	// 82A24BDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A24BE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A24BE4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A24BE8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A24BEC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A24BF0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A24BF4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A24BF8: 48439D69  bl 0x82e5e960
	ctx.lr = 0x82A24BFC;
	sub_82E5E960(ctx, base);
	// 82A24BFC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A24C00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A24C04: 419A0008  beq cr6, 0x82a24c0c
	if ctx.cr[6].eq {
	pc = 0x82A24C0C; continue 'dispatch;
	}
	// 82A24C08: 4B89BC89  bl 0x822c0890
	ctx.lr = 0x82A24C0C;
	sub_822C0890(ctx, base);
	// 82A24C0C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82A24C10: 419A00F4  beq cr6, 0x82a24d04
	if ctx.cr[6].eq {
	pc = 0x82A24D04; continue 'dispatch;
	}
	// 82A24C14: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A24C18: 480000E8  b 0x82a24d00
	pc = 0x82A24D00; continue 'dispatch;
	// 82A24C1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A24C20: 4BFEE369  bl 0x82a12f88
	ctx.lr = 0x82A24C24;
	sub_82A12F88(ctx, base);
	// 82A24C24: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A24C28: 4182FFE4  beq 0x82a24c0c
	if ctx.cr[0].eq {
	pc = 0x82A24C0C; continue 'dispatch;
	}
	// 82A24C2C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A24C30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A24C34: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A24C38: 4BFEE341  bl 0x82a12f78
	ctx.lr = 0x82A24C3C;
	sub_82A12F78(ctx, base);
	// 82A24C3C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A24C40: 38800018  li r4, 0x18
	ctx.r[4].s64 = 24;
	// 82A24C44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A24C48: C02B9EFC  lfs f1, -0x6104(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24836 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A24C4C: 4BFF491D  bl 0x82a19568
	ctx.lr = 0x82A24C50;
	sub_82A19568(ctx, base);
	// 82A24C50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A24C54: 4BFFFD45  bl 0x82a24998
	ctx.lr = 0x82A24C58;
	sub_82A24998(ctx, base);
	// 82A24C58: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A24C5C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A24C60: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A24C64: 388BA8BC  addi r4, r11, -0x5744
	ctx.r[4].s64 = ctx.r[11].s64 + -22340;
	// 82A24C68: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A24C6C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A24C70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A24C74: 4E800421  bctrl
	ctx.lr = 0x82A24C78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A24C78: 4BFFFF94  b 0x82a24c0c
	pc = 0x82A24C0C; continue 'dispatch;
	// 82A24C7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A24C80: 4BFF2089  bl 0x82a16d08
	ctx.lr = 0x82A24C84;
	sub_82A16D08(ctx, base);
	// 82A24C84: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A24C88: 41820034  beq 0x82a24cbc
	if ctx.cr[0].eq {
	pc = 0x82A24CBC; continue 'dispatch;
	}
	// 82A24C8C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A24C90: 38800017  li r4, 0x17
	ctx.r[4].s64 = 23;
	// 82A24C94: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A24C98: C02B9EFC  lfs f1, -0x6104(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24836 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A24C9C: 4BFF48CD  bl 0x82a19568
	ctx.lr = 0x82A24CA0;
	sub_82A19568(ctx, base);
	// 82A24CA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A24CA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A24CA8: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A24CAC: 4BFEE2CD  bl 0x82a12f78
	ctx.lr = 0x82A24CB0;
	sub_82A12F78(ctx, base);
	// 82A24CB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A24CB4: 4BFFFCE5  bl 0x82a24998
	ctx.lr = 0x82A24CB8;
	sub_82A24998(ctx, base);
	// 82A24CB8: 4800004C  b 0x82a24d04
	pc = 0x82A24D04; continue 'dispatch;
	// 82A24CBC: 389F0068  addi r4, r31, 0x68
	ctx.r[4].s64 = ctx.r[31].s64 + 104;
	// 82A24CC0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A24CC4: 483CEF3D  bl 0x82df3c00
	ctx.lr = 0x82A24CC8;
	sub_82DF3C00(ctx, base);
	// 82A24CC8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A24CCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A24CD0: 485E3459  bl 0x83008128
	ctx.lr = 0x82A24CD4;
	sub_83008128(ctx, base);
	// 82A24CD4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A24CD8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A24CDC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A24CE0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A24CE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A24CE8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A24CEC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A24CF0: 48439C71  bl 0x82e5e960
	ctx.lr = 0x82A24CF4;
	sub_82E5E960(ctx, base);
	// 82A24CF4: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A24CF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A24CFC: 419A0008  beq cr6, 0x82a24d04
	if ctx.cr[6].eq {
	pc = 0x82A24D04; continue 'dispatch;
	}
	// 82A24D00: 4B89BB91  bl 0x822c0890
	ctx.lr = 0x82A24D04;
	sub_822C0890(ctx, base);
	// 82A24D04: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A24D08: 487834A8  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A24D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A24D10 size=192
    let mut pc: u32 = 0x82A24D10;
    'dispatch: loop {
        match pc {
            0x82A24D10 => {
    //   block [0x82A24D10..0x82A24DD0)
	// 82A24D10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A24D14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A24D18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A24D1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A24D20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A24D24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A24D28: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A24D2C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82A24D30: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 82A24D34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A24D38: 4BA6D5D1  bl 0x82492308
	ctx.lr = 0x82A24D3C;
	sub_82492308(ctx, base);
	// 82A24D3C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A24D40: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82A24D44: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A24D48: 419A006C  beq cr6, 0x82a24db4
	if ctx.cr[6].eq {
	pc = 0x82A24DB4; continue 'dispatch;
	}
	// 82A24D4C: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A24D50: 3BEB0010  addi r31, r11, 0x10
	ctx.r[31].s64 = ctx.r[11].s64 + 16;
	// 82A24D54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A24D58: 419A0018  beq cr6, 0x82a24d70
	if ctx.cr[6].eq {
	pc = 0x82A24D70; continue 'dispatch;
	}
	// 82A24D5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A24D60: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A24D64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A24D68: 4E800421  bctrl
	ctx.lr = 0x82A24D6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A24D6C: 4800000C  b 0x82a24d78
	pc = 0x82A24D78; continue 'dispatch;
	// 82A24D70: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82A24D74: 386B869C  addi r3, r11, -0x7964
	ctx.r[3].s64 = ctx.r[11].s64 + -31076;
	// 82A24D78: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82A24D7C: 388B7624  addi r4, r11, 0x7624
	ctx.r[4].s64 = ctx.r[11].s64 + 30244;
	// 82A24D80: 48783379  bl 0x831a80f8
	ctx.lr = 0x82A24D84;
	sub_831A80F8(ctx, base);
	// 82A24D84: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A24D88: 4182002C  beq 0x82a24db4
	if ctx.cr[0].eq {
	pc = 0x82A24DB4; continue 'dispatch;
	}
	// 82A24D8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A24D90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A24D94: 4BFFFA5D  bl 0x82a247f0
	ctx.lr = 0x82A24D98;
	sub_82A247F0(ctx, base);
	// 82A24D98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A24D9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A24DA0: 483CEE31  bl 0x82df3bd0
	ctx.lr = 0x82A24DA4;
	sub_82DF3BD0(ctx, base);
	// 82A24DA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A24DA8: 483CE681  bl 0x82df3428
	ctx.lr = 0x82A24DAC;
	sub_82DF3428(ctx, base);
	// 82A24DAC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A24DB0: 48000008  b 0x82a24db8
	pc = 0x82A24DB8; continue 'dispatch;
	// 82A24DB4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A24DB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A24DBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A24DC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A24DC4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A24DC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A24DCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A24DD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A24DD0 size=440
    let mut pc: u32 = 0x82A24DD0;
    'dispatch: loop {
        match pc {
            0x82A24DD0 => {
    //   block [0x82A24DD0..0x82A24F88)
	// 82A24DD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A24DD4: 48783399  bl 0x831a816c
	ctx.lr = 0x82A24DD8;
	sub_831A8130(ctx, base);
	// 82A24DD8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A24DDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A24DE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A24DE4: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A24DE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A24DEC: 388AA46C  addi r4, r10, -0x5b94
	ctx.r[4].s64 = ctx.r[10].s64 + -23444;
	// 82A24DF0: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A24DF4: 483CEC15  bl 0x82df3a08
	ctx.lr = 0x82A24DF8;
	sub_82DF3A08(ctx, base);
	// 82A24DF8: 38BF0068  addi r5, r31, 0x68
	ctx.r[5].s64 = ctx.r[31].s64 + 104;
	// 82A24DFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A24E00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A24E04: 4BFFFF0D  bl 0x82a24d10
	ctx.lr = 0x82A24E08;
	sub_82A24D10(ctx, base);
	// 82A24E08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A24E0C: 483CE61D  bl 0x82df3428
	ctx.lr = 0x82A24E10;
	sub_82DF3428(ctx, base);
	// 82A24E10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A24E14: 4872F7ED  bl 0x83154600
	ctx.lr = 0x82A24E18;
	sub_83154600(ctx, base);
	// 82A24E18: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A24E1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A24E20: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A24E24: 4BAEA6A5  bl 0x8250f4c8
	ctx.lr = 0x82A24E28;
	sub_8250F4C8(ctx, base);
	// 82A24E28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A24E2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A24E30: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A24E34: 409A0008  bne cr6, 0x82a24e3c
	if !ctx.cr[6].eq {
	pc = 0x82A24E3C; continue 'dispatch;
	}
	// 82A24E38: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A24E3C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A24E40: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A24E44: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82A24E48: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A24E4C: 48122055  bl 0x82b46ea0
	ctx.lr = 0x82A24E50;
	sub_82B46EA0(ctx, base);
	// 82A24E50: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A24E54: 3BDF006C  addi r30, r31, 0x6c
	ctx.r[30].s64 = ctx.r[31].s64 + 108;
	// 82A24E58: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A24E5C: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82A24E60: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A24E64: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A24E68: 4B89F5F9  bl 0x822c4460
	ctx.lr = 0x82A24E6C;
	sub_822C4460(ctx, base);
	// 82A24E6C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A24E70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A24E74: 419A0008  beq cr6, 0x82a24e7c
	if ctx.cr[6].eq {
	pc = 0x82A24E7C; continue 'dispatch;
	}
	// 82A24E78: 4B89BA19  bl 0x822c0890
	ctx.lr = 0x82A24E7C;
	sub_822C0890(ctx, base);
	// 82A24E7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A24E80: 483CCE11  bl 0x82df1c90
	ctx.lr = 0x82A24E84;
	sub_82DF1C90(ctx, base);
	// 82A24E84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A24E88: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A24E8C: 4BFEE7F5  bl 0x82a13680
	ctx.lr = 0x82A24E90;
	sub_82A13680(ctx, base);
	// 82A24E90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A24E94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A24E98: 48121D11  bl 0x82b46ba8
	ctx.lr = 0x82A24E9C;
	sub_82B46BA8(ctx, base);
	// 82A24E9C: 3BFF0074  addi r31, r31, 0x74
	ctx.r[31].s64 = ctx.r[31].s64 + 116;
	// 82A24EA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A24EA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A24EA8: 409A00D8  bne cr6, 0x82a24f80
	if !ctx.cr[6].eq {
	pc = 0x82A24F80; continue 'dispatch;
	}
	// 82A24EAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A24EB0: 4BFEE009  bl 0x82a12eb8
	ctx.lr = 0x82A24EB4;
	sub_82A12EB8(ctx, base);
	// 82A24EB4: 4BDCA885  bl 0x827ef738
	ctx.lr = 0x82A24EB8;
	sub_827EF738(ctx, base);
	// 82A24EB8: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A24EBC: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A24EC0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A24EC4: 419A0024  beq cr6, 0x82a24ee8
	if ctx.cr[6].eq {
	pc = 0x82A24EE8; continue 'dispatch;
	}
	// 82A24EC8: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82A24ECC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A24ED0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A24ED4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A24ED8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A24EDC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A24EE0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A24EE4: 4082FFE8  bne 0x82a24ecc
	if !ctx.cr[0].eq {
	pc = 0x82A24ECC; continue 'dispatch;
	}
	// 82A24EE8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A24EEC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A24EF0: 388BA8D0  addi r4, r11, -0x5730
	ctx.r[4].s64 = ctx.r[11].s64 + -22320;
	// 82A24EF4: 38A00041  li r5, 0x41
	ctx.r[5].s64 = 65;
	// 82A24EF8: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82A24EFC: 483CD4ED  bl 0x82df23e8
	ctx.lr = 0x82A24F00;
	sub_82DF23E8(ctx, base);
	// 82A24F00: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A24F04: 41820018  beq 0x82a24f1c
	if ctx.cr[0].eq {
	pc = 0x82A24F1C; continue 'dispatch;
	}
	// 82A24F08: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A24F0C: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 82A24F10: 483EE1E1  bl 0x82e130f0
	ctx.lr = 0x82A24F14;
	sub_82E130F0(ctx, base);
	// 82A24F14: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A24F18: 48000008  b 0x82a24f20
	pc = 0x82A24F20; continue 'dispatch;
	// 82A24F1C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A24F20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A24F24: 4B8BCE2D  bl 0x822e1d50
	ctx.lr = 0x82A24F28;
	sub_822E1D50(ctx, base);
	// 82A24F28: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A24F2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A24F30: 388B2DC8  addi r4, r11, 0x2dc8
	ctx.r[4].s64 = ctx.r[11].s64 + 11720;
	// 82A24F34: 483CEAD5  bl 0x82df3a08
	ctx.lr = 0x82A24F38;
	sub_82DF3A08(ctx, base);
	// 82A24F38: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A24F3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A24F40: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A24F44: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A24F48: 483F00E9  bl 0x82e15030
	ctx.lr = 0x82A24F4C;
	sub_82E15030(ctx, base);
	// 82A24F4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A24F50: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A24F54: 483EDEDD  bl 0x82e12e30
	ctx.lr = 0x82A24F58;
	sub_82E12E30(ctx, base);
	// 82A24F58: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A24F5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A24F60: 419A0008  beq cr6, 0x82a24f68
	if ctx.cr[6].eq {
	pc = 0x82A24F68; continue 'dispatch;
	}
	// 82A24F64: 4B89B92D  bl 0x822c0890
	ctx.lr = 0x82A24F68;
	sub_822C0890(ctx, base);
	// 82A24F68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A24F6C: 483CE4BD  bl 0x82df3428
	ctx.lr = 0x82A24F70;
	sub_82DF3428(ctx, base);
	// 82A24F70: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A24F74: 419A000C  beq cr6, 0x82a24f80
	if ctx.cr[6].eq {
	pc = 0x82A24F80; continue 'dispatch;
	}
	// 82A24F78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A24F7C: 4B89B915  bl 0x822c0890
	ctx.lr = 0x82A24F80;
	sub_822C0890(ctx, base);
	// 82A24F80: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A24F84: 48783238  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A24F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A24F88 size=116
    let mut pc: u32 = 0x82A24F88;
    'dispatch: loop {
        match pc {
            0x82A24F88 => {
    //   block [0x82A24F88..0x82A24FFC)
	// 82A24F88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A24F8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A24F90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A24F94: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A24F98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A24F9C: 4BFF91AD  bl 0x82a1e148
	ctx.lr = 0x82A24FA0;
	sub_82A1E148(ctx, base);
	// 82A24FA0: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A24FA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A24FA8: 394AA94C  addi r10, r10, -0x56b4
	ctx.r[10].s64 = ctx.r[10].s64 + -22196;
	// 82A24FAC: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A24FB0: 3D208203  lis r9, -0x7dfd
	ctx.r[9].s64 = -2113732608;
	// 82A24FB4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A24FB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A24FBC: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A24FC0: 3889C3B0  addi r4, r9, -0x3c50
	ctx.r[4].s64 = ctx.r[9].s64 + -15440;
	// 82A24FC4: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A24FC8: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A24FCC: 483CEA3D  bl 0x82df3a08
	ctx.lr = 0x82A24FD0;
	sub_82DF3A08(ctx, base);
	// 82A24FD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A24FD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A24FD8: 48434711  bl 0x82e596e8
	ctx.lr = 0x82A24FDC;
	sub_82E596E8(ctx, base);
	// 82A24FDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A24FE0: 483CE449  bl 0x82df3428
	ctx.lr = 0x82A24FE4;
	sub_82DF3428(ctx, base);
	// 82A24FE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A24FE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A24FEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A24FF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A24FF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A24FF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A25000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A25000 size=440
    let mut pc: u32 = 0x82A25000;
    'dispatch: loop {
        match pc {
            0x82A25000 => {
    //   block [0x82A25000..0x82A251B8)
	// 82A25000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A25004: 48783161  bl 0x831a8164
	ctx.lr = 0x82A25008;
	sub_831A8130(ctx, base);
	// 82A25008: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A2500C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A25010: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A25014: 93830064  stw r28, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 82A25018: 93830068  stw r28, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 82A2501C: 4872F5E5  bl 0x83154600
	ctx.lr = 0x82A25020;
	sub_83154600(ctx, base);
	// 82A25020: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A25024: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A25028: 4BFEE609  bl 0x82a13630
	ctx.lr = 0x82A2502C;
	sub_82A13630(ctx, base);
	// 82A2502C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A25030: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A25034: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82A25038: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A2503C: 4BA9DA5D  bl 0x824c2a98
	ctx.lr = 0x82A25040;
	sub_824C2A98(ctx, base);
	// 82A25040: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A25044: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A25048: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A2504C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A25050: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A25054: 419A0024  beq cr6, 0x82a25078
	if ctx.cr[6].eq {
	pc = 0x82A25078; continue 'dispatch;
	}
	// 82A25058: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A2505C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A25060: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A25064: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A25068: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A2506C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A25070: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A25074: 4082FFE8  bne 0x82a2505c
	if !ctx.cr[0].eq {
	pc = 0x82A2505C; continue 'dispatch;
	}
	// 82A25078: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2507C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A25080: 4BAEA449  bl 0x8250f4c8
	ctx.lr = 0x82A25084;
	sub_8250F4C8(ctx, base);
	// 82A25084: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A25088: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2508C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A25090: 409A0008  bne cr6, 0x82a25098
	if !ctx.cr[6].eq {
	pc = 0x82A25098; continue 'dispatch;
	}
	// 82A25094: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A25098: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 82A2509C: 3B610058  addi r27, r1, 0x58
	ctx.r[27].s64 = ctx.r[1].s64 + 88;
	// 82A250A0: 4BAE39E1  bl 0x82508a80
	ctx.lr = 0x82A250A4;
	sub_82508A80(ctx, base);
	// 82A250A4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A250A8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A250AC: 3BABA970  addi r29, r11, -0x5690
	ctx.r[29].s64 = ctx.r[11].s64 + -22160;
	// 82A250B0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A250B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A250B8: 38A0003C  li r5, 0x3c
	ctx.r[5].s64 = 60;
	// 82A250BC: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A250C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A250C4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82A250C8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A250CC: 48433975  bl 0x82e58a40
	ctx.lr = 0x82A250D0;
	sub_82E58A40(ctx, base);
	// 82A250D0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A250D4: 483CCBBD  bl 0x82df1c90
	ctx.lr = 0x82A250D8;
	sub_82DF1C90(ctx, base);
	// 82A250D8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A250DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A250E0: 419A0008  beq cr6, 0x82a250e8
	if ctx.cr[6].eq {
	pc = 0x82A250E8; continue 'dispatch;
	}
	// 82A250E4: 4B89B7AD  bl 0x822c0890
	ctx.lr = 0x82A250E8;
	sub_822C0890(ctx, base);
	// 82A250E8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A250EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A250F0: 419A0008  beq cr6, 0x82a250f8
	if ctx.cr[6].eq {
	pc = 0x82A250F8; continue 'dispatch;
	}
	// 82A250F4: 4B89B79D  bl 0x822c0890
	ctx.lr = 0x82A250F8;
	sub_822C0890(ctx, base);
	// 82A250F8: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	// 82A250FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A25100: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A25104: 4BA84E65  bl 0x824a9f68
	ctx.lr = 0x82A25108;
	sub_824A9F68(ctx, base);
	// 82A25108: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2510C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A25110: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A25114: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A25118: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A2511C: 419A0024  beq cr6, 0x82a25140
	if ctx.cr[6].eq {
	pc = 0x82A25140; continue 'dispatch;
	}
	// 82A25120: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A25124: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A25128: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A2512C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A25130: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A25134: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A25138: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A2513C: 4082FFE8  bne 0x82a25124
	if !ctx.cr[0].eq {
	pc = 0x82A25124; continue 'dispatch;
	}
	// 82A25140: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A25144: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A25148: 4BAEA381  bl 0x8250f4c8
	ctx.lr = 0x82A2514C;
	sub_8250F4C8(ctx, base);
	// 82A2514C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A25150: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A25154: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A25158: 409A0008  bne cr6, 0x82a25160
	if !ctx.cr[6].eq {
	pc = 0x82A25160; continue 'dispatch;
	}
	// 82A2515C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A25160: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 82A25164: 4BAE3425  bl 0x82508588
	ctx.lr = 0x82A25168;
	sub_82508588(ctx, base);
	// 82A25168: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A2516C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A25170: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A25174: 38A0003E  li r5, 0x3e
	ctx.r[5].s64 = 62;
	// 82A25178: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2517C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A25180: 484338C1  bl 0x82e58a40
	ctx.lr = 0x82A25184;
	sub_82E58A40(ctx, base);
	// 82A25184: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A25188: 483CCB09  bl 0x82df1c90
	ctx.lr = 0x82A2518C;
	sub_82DF1C90(ctx, base);
	// 82A2518C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A25190: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A25194: 419A0008  beq cr6, 0x82a2519c
	if ctx.cr[6].eq {
	pc = 0x82A2519C; continue 'dispatch;
	}
	// 82A25198: 4B89B6F9  bl 0x822c0890
	ctx.lr = 0x82A2519C;
	sub_822C0890(ctx, base);
	// 82A2519C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A251A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A251A4: 419A0008  beq cr6, 0x82a251ac
	if ctx.cr[6].eq {
	pc = 0x82A251AC; continue 'dispatch;
	}
	// 82A251A8: 4B89B6E9  bl 0x822c0890
	ctx.lr = 0x82A251AC;
	sub_822C0890(ctx, base);
	// 82A251AC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A251B0: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A251B4: 48783000  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A251B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A251B8 size=964
    let mut pc: u32 = 0x82A251B8;
    'dispatch: loop {
        match pc {
            0x82A251B8 => {
    //   block [0x82A251B8..0x82A2557C)
	// 82A251B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A251BC: 48782FA5  bl 0x831a8160
	ctx.lr = 0x82A251C0;
	sub_831A8130(ctx, base);
	// 82A251C0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82A251C4: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A251C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A251CC: 4872F435  bl 0x83154600
	ctx.lr = 0x82A251D0;
	sub_83154600(ctx, base);
	// 82A251D0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A251D4: 813E006C  lwz r9, 0x6c(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A251D8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A251DC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82A251E0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A251E4: 3BABA970  addi r29, r11, -0x5690
	ctx.r[29].s64 = ctx.r[11].s64 + -22160;
	// 82A251E8: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A251EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A251F0: 419A017C  beq cr6, 0x82a2536c
	if ctx.cr[6].eq {
	pc = 0x82A2536C; continue 'dispatch;
	}
	// 82A251F4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A251F8: 4BB53751  bl 0x82578948
	ctx.lr = 0x82A251FC;
	sub_82578948(ctx, base);
	// 82A251FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A25200: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A25204: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A25208: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2520C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A25210: 419A0024  beq cr6, 0x82a25234
	if ctx.cr[6].eq {
	pc = 0x82A25234; continue 'dispatch;
	}
	// 82A25214: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A25218: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A2521C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A25220: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A25224: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A25228: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A2522C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A25230: 4082FFE8  bne 0x82a25218
	if !ctx.cr[0].eq {
	pc = 0x82A25218; continue 'dispatch;
	}
	// 82A25234: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A25238: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A2523C: 4BAEA28D  bl 0x8250f4c8
	ctx.lr = 0x82A25240;
	sub_8250F4C8(ctx, base);
	// 82A25240: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A25244: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A25248: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A2524C: 409A0008  bne cr6, 0x82a25254
	if !ctx.cr[6].eq {
	pc = 0x82A25254; continue 'dispatch;
	}
	// 82A25250: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A25254: 3BFC0028  addi r31, r28, 0x28
	ctx.r[31].s64 = ctx.r[28].s64 + 40;
	// 82A25258: 3B410058  addi r26, r1, 0x58
	ctx.r[26].s64 = ctx.r[1].s64 + 88;
	// 82A2525C: 4BAE3825  bl 0x82508a80
	ctx.lr = 0x82A25260;
	sub_82508A80(ctx, base);
	// 82A25260: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A25264: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A25268: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A2526C: 38A00066  li r5, 0x66
	ctx.r[5].s64 = 102;
	// 82A25270: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A25274: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82A25278: 484337C9  bl 0x82e58a40
	ctx.lr = 0x82A2527C;
	sub_82E58A40(ctx, base);
	// 82A2527C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A25280: 483CCA11  bl 0x82df1c90
	ctx.lr = 0x82A25284;
	sub_82DF1C90(ctx, base);
	// 82A25284: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A25288: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2528C: 419A0008  beq cr6, 0x82a25294
	if ctx.cr[6].eq {
	pc = 0x82A25294; continue 'dispatch;
	}
	// 82A25290: 4B89B601  bl 0x822c0890
	ctx.lr = 0x82A25294;
	sub_822C0890(ctx, base);
	// 82A25294: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A25298: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2529C: 419A0008  beq cr6, 0x82a252a4
	if ctx.cr[6].eq {
	pc = 0x82A252A4; continue 'dispatch;
	}
	// 82A252A0: 4B89B5F1  bl 0x822c0890
	ctx.lr = 0x82A252A4;
	sub_822C0890(ctx, base);
	// 82A252A4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A252A8: 4BB536A1  bl 0x82578948
	ctx.lr = 0x82A252AC;
	sub_82578948(ctx, base);
	// 82A252AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A252B0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A252B4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A252B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A252BC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A252C0: 419A0024  beq cr6, 0x82a252e4
	if ctx.cr[6].eq {
	pc = 0x82A252E4; continue 'dispatch;
	}
	// 82A252C4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A252C8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A252CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A252D0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A252D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A252D8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A252DC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A252E0: 4082FFE8  bne 0x82a252c8
	if !ctx.cr[0].eq {
	pc = 0x82A252C8; continue 'dispatch;
	}
	// 82A252E4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A252E8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A252EC: 4BAEA1DD  bl 0x8250f4c8
	ctx.lr = 0x82A252F0;
	sub_8250F4C8(ctx, base);
	// 82A252F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A252F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A252F8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A252FC: 409A0008  bne cr6, 0x82a25304
	if !ctx.cr[6].eq {
	pc = 0x82A25304; continue 'dispatch;
	}
	// 82A25300: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A25304: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A25308: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 82A2530C: 4BAE370D  bl 0x82508a18
	ctx.lr = 0x82A25310;
	sub_82508A18(ctx, base);
	// 82A25310: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A25314: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A25318: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A2531C: 38A00068  li r5, 0x68
	ctx.r[5].s64 = 104;
	// 82A25320: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A25324: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82A25328: 48433719  bl 0x82e58a40
	ctx.lr = 0x82A2532C;
	sub_82E58A40(ctx, base);
	// 82A2532C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A25330: 483CC961  bl 0x82df1c90
	ctx.lr = 0x82A25334;
	sub_82DF1C90(ctx, base);
	// 82A25334: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A25338: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2533C: 419A0008  beq cr6, 0x82a25344
	if ctx.cr[6].eq {
	pc = 0x82A25344; continue 'dispatch;
	}
	// 82A25340: 4B89B551  bl 0x822c0890
	ctx.lr = 0x82A25344;
	sub_822C0890(ctx, base);
	// 82A25344: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82A25348: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2534C: 419A0008  beq cr6, 0x82a25354
	if ctx.cr[6].eq {
	pc = 0x82A25354; continue 'dispatch;
	}
	// 82A25350: 4B89B541  bl 0x822c0890
	ctx.lr = 0x82A25354;
	sub_822C0890(ctx, base);
	// 82A25354: 937E006C  stw r27, 0x6c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), ctx.r[27].u32 ) };
	// 82A25358: 807E0070  lwz r3, 0x70(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A2535C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A25360: 937E0070  stw r27, 0x70(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 82A25364: 419A0008  beq cr6, 0x82a2536c
	if ctx.cr[6].eq {
	pc = 0x82A2536C; continue 'dispatch;
	}
	// 82A25368: 4B89B529  bl 0x822c0890
	ctx.lr = 0x82A2536C;
	sub_822C0890(ctx, base);
	// 82A2536C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A25370: 4BF65A49  bl 0x8298adb8
	ctx.lr = 0x82A25374;
	sub_8298ADB8(ctx, base);
	// 82A25374: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A25378: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A2537C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A25380: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A25384: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A25388: 419A0024  beq cr6, 0x82a253ac
	if ctx.cr[6].eq {
	pc = 0x82A253AC; continue 'dispatch;
	}
	// 82A2538C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A25390: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A25394: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A25398: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A2539C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A253A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A253A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A253A8: 4082FFE8  bne 0x82a25390
	if !ctx.cr[0].eq {
	pc = 0x82A25390; continue 'dispatch;
	}
	// 82A253AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A253B0: 3BFC0028  addi r31, r28, 0x28
	ctx.r[31].s64 = ctx.r[28].s64 + 40;
	// 82A253B4: 3BC10068  addi r30, r1, 0x68
	ctx.r[30].s64 = ctx.r[1].s64 + 104;
	// 82A253B8: 4BFEE1C9  bl 0x82a13580
	ctx.lr = 0x82A253BC;
	sub_82A13580(ctx, base);
	// 82A253BC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A253C0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A253C4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A253C8: 38A0006D  li r5, 0x6d
	ctx.r[5].s64 = 109;
	// 82A253CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A253D0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A253D4: 4843366D  bl 0x82e58a40
	ctx.lr = 0x82A253D8;
	sub_82E58A40(ctx, base);
	// 82A253D8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A253DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A253E0: 419A0008  beq cr6, 0x82a253e8
	if ctx.cr[6].eq {
	pc = 0x82A253E8; continue 'dispatch;
	}
	// 82A253E4: 4B89B4AD  bl 0x822c0890
	ctx.lr = 0x82A253E8;
	sub_822C0890(ctx, base);
	// 82A253E8: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A253EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A253F0: 419A0008  beq cr6, 0x82a253f8
	if ctx.cr[6].eq {
	pc = 0x82A253F8; continue 'dispatch;
	}
	// 82A253F4: 4B89B49D  bl 0x822c0890
	ctx.lr = 0x82A253F8;
	sub_822C0890(ctx, base);
	// 82A253F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A253FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A25400: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82A25404: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A25408: 4BA84B61  bl 0x824a9f68
	ctx.lr = 0x82A2540C;
	sub_824A9F68(ctx, base);
	// 82A2540C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A25410: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A25414: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A25418: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2541C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82A25420: 419A0024  beq cr6, 0x82a25444
	if ctx.cr[6].eq {
	pc = 0x82A25444; continue 'dispatch;
	}
	// 82A25424: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A25428: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A2542C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A25430: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A25434: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A25438: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A2543C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A25440: 4082FFE8  bne 0x82a25428
	if !ctx.cr[0].eq {
	pc = 0x82A25428; continue 'dispatch;
	}
	// 82A25444: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A25448: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A2544C: 4BAEA07D  bl 0x8250f4c8
	ctx.lr = 0x82A25450;
	sub_8250F4C8(ctx, base);
	// 82A25450: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A25454: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A25458: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A2545C: 409A0008  bne cr6, 0x82a25464
	if !ctx.cr[6].eq {
	pc = 0x82A25464; continue 'dispatch;
	}
	// 82A25460: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A25464: 3BC10070  addi r30, r1, 0x70
	ctx.r[30].s64 = ctx.r[1].s64 + 112;
	// 82A25468: 4BAE3121  bl 0x82508588
	ctx.lr = 0x82A2546C;
	sub_82508588(ctx, base);
	// 82A2546C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A25470: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A25474: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A25478: 38A0006F  li r5, 0x6f
	ctx.r[5].s64 = 111;
	// 82A2547C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A25480: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A25484: 484335BD  bl 0x82e58a40
	ctx.lr = 0x82A25488;
	sub_82E58A40(ctx, base);
	// 82A25488: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A2548C: 483CC805  bl 0x82df1c90
	ctx.lr = 0x82A25490;
	sub_82DF1C90(ctx, base);
	// 82A25490: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A25494: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A25498: 419A0008  beq cr6, 0x82a254a0
	if ctx.cr[6].eq {
	pc = 0x82A254A0; continue 'dispatch;
	}
	// 82A2549C: 4B89B3F5  bl 0x822c0890
	ctx.lr = 0x82A254A0;
	sub_822C0890(ctx, base);
	// 82A254A0: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A254A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A254A8: 419A0008  beq cr6, 0x82a254b0
	if ctx.cr[6].eq {
	pc = 0x82A254B0; continue 'dispatch;
	}
	// 82A254AC: 4B89B3E5  bl 0x822c0890
	ctx.lr = 0x82A254B0;
	sub_822C0890(ctx, base);
	// 82A254B0: 9B610050  stb r27, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 82A254B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A254B8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82A254BC: 4BA9D5DD  bl 0x824c2a98
	ctx.lr = 0x82A254C0;
	sub_824C2A98(ctx, base);
	// 82A254C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A254C4: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82A254C8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A254CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A254D0: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82A254D4: 419A0024  beq cr6, 0x82a254f8
	if ctx.cr[6].eq {
	pc = 0x82A254F8; continue 'dispatch;
	}
	// 82A254D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A254DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A254E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A254E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A254E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A254EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A254F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A254F4: 4082FFE8  bne 0x82a254dc
	if !ctx.cr[0].eq {
	pc = 0x82A254DC; continue 'dispatch;
	}
	// 82A254F8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A254FC: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A25500: 4BAE9FC9  bl 0x8250f4c8
	ctx.lr = 0x82A25504;
	sub_8250F4C8(ctx, base);
	// 82A25504: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A25508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2550C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A25510: 409A0008  bne cr6, 0x82a25518
	if !ctx.cr[6].eq {
	pc = 0x82A25518; continue 'dispatch;
	}
	// 82A25514: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A25518: 3BC10078  addi r30, r1, 0x78
	ctx.r[30].s64 = ctx.r[1].s64 + 120;
	// 82A2551C: 4BAE3565  bl 0x82508a80
	ctx.lr = 0x82A25520;
	sub_82508A80(ctx, base);
	// 82A25520: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A25524: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A25528: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A2552C: 38A00071  li r5, 0x71
	ctx.r[5].s64 = 113;
	// 82A25530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A25534: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A25538: 48433509  bl 0x82e58a40
	ctx.lr = 0x82A2553C;
	sub_82E58A40(ctx, base);
	// 82A2553C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A25540: 483CC751  bl 0x82df1c90
	ctx.lr = 0x82A25544;
	sub_82DF1C90(ctx, base);
	// 82A25544: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A25548: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2554C: 419A0008  beq cr6, 0x82a25554
	if ctx.cr[6].eq {
	pc = 0x82A25554; continue 'dispatch;
	}
	// 82A25550: 4B89B341  bl 0x822c0890
	ctx.lr = 0x82A25554;
	sub_822C0890(ctx, base);
	// 82A25554: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A25558: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2555C: 419A0008  beq cr6, 0x82a25564
	if ctx.cr[6].eq {
	pc = 0x82A25564; continue 'dispatch;
	}
	// 82A25560: 4B89B331  bl 0x822c0890
	ctx.lr = 0x82A25564;
	sub_822C0890(ctx, base);
	// 82A25564: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A25568: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A2556C: 4BFEE0C5  bl 0x82a13630
	ctx.lr = 0x82A25570;
	sub_82A13630(ctx, base);
	// 82A25570: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82A25574: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82A25578: 48782C38  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A25580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A25580 size=1480
    let mut pc: u32 = 0x82A25580;
    'dispatch: loop {
        match pc {
            0x82A25580 => {
    //   block [0x82A25580..0x82A25B48)
	// 82A25580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A25584: 48782BD9  bl 0x831a815c
	ctx.lr = 0x82A25588;
	sub_831A8130(ctx, base);
	// 82A25588: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82A2558C: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A25590: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A25594: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A25598: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82A2559C: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82A255A0: 4872F061  bl 0x83154600
	ctx.lr = 0x82A255A4;
	sub_83154600(ctx, base);
	// 82A255A4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A255A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A255AC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A255B0: 4BAE9F19  bl 0x8250f4c8
	ctx.lr = 0x82A255B4;
	sub_8250F4C8(ctx, base);
	// 82A255B4: 817C0068  lwz r11, 0x68(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A255B8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A255BC: 41980184  blt cr6, 0x82a25740
	if ctx.cr[6].lt {
	pc = 0x82A25740; continue 'dispatch;
	}
	// 82A255C0: 933C006C  stw r25, 0x6c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(108 as u32), ctx.r[25].u32 ) };
	// 82A255C4: 397C006C  addi r11, r28, 0x6c
	ctx.r[11].s64 = ctx.r[28].s64 + 108;
	// 82A255C8: 807C0070  lwz r3, 0x70(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A255CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A255D0: 933C0070  stw r25, 0x70(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(112 as u32), ctx.r[25].u32 ) };
	// 82A255D4: 419A0008  beq cr6, 0x82a255dc
	if ctx.cr[6].eq {
	pc = 0x82A255DC; continue 'dispatch;
	}
	// 82A255D8: 4B89B2B9  bl 0x822c0890
	ctx.lr = 0x82A255DC;
	sub_822C0890(ctx, base);
	// 82A255DC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A255E0: 4BB53369  bl 0x82578948
	ctx.lr = 0x82A255E4;
	sub_82578948(ctx, base);
	// 82A255E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A255E8: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A255EC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A255F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A255F4: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82A255F8: 419A0024  beq cr6, 0x82a2561c
	if ctx.cr[6].eq {
	pc = 0x82A2561C; continue 'dispatch;
	}
	// 82A255FC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A25600: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A25604: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A25608: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A2560C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A25610: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A25614: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A25618: 4082FFE8  bne 0x82a25600
	if !ctx.cr[0].eq {
	pc = 0x82A25600; continue 'dispatch;
	}
	// 82A2561C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A25620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A25624: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A25628: 409A0008  bne cr6, 0x82a25630
	if !ctx.cr[6].eq {
	pc = 0x82A25630; continue 'dispatch;
	}
	// 82A2562C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A25630: 3BFA0028  addi r31, r26, 0x28
	ctx.r[31].s64 = ctx.r[26].s64 + 40;
	// 82A25634: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82A25638: 4BAE3449  bl 0x82508a80
	ctx.lr = 0x82A2563C;
	sub_82508A80(ctx, base);
	// 82A2563C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A25640: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A25644: 3BCBA970  addi r30, r11, -0x5690
	ctx.r[30].s64 = ctx.r[11].s64 + -22160;
	// 82A25648: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A2564C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A25650: 38A00083  li r5, 0x83
	ctx.r[5].s64 = 131;
	// 82A25654: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A25658: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2565C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A25660: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A25664: 484333DD  bl 0x82e58a40
	ctx.lr = 0x82A25668;
	sub_82E58A40(ctx, base);
	// 82A25668: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A2566C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A25670: 419A0008  beq cr6, 0x82a25678
	if ctx.cr[6].eq {
	pc = 0x82A25678; continue 'dispatch;
	}
	// 82A25674: 4B89B21D  bl 0x822c0890
	ctx.lr = 0x82A25678;
	sub_822C0890(ctx, base);
	// 82A25678: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A2567C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A25680: 419A0008  beq cr6, 0x82a25688
	if ctx.cr[6].eq {
	pc = 0x82A25688; continue 'dispatch;
	}
	// 82A25684: 4B89B20D  bl 0x822c0890
	ctx.lr = 0x82A25688;
	sub_822C0890(ctx, base);
	// 82A25688: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82A2568C: 4BB532BD  bl 0x82578948
	ctx.lr = 0x82A25690;
	sub_82578948(ctx, base);
	// 82A25690: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A25694: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82A25698: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A2569C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A256A0: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82A256A4: 419A0024  beq cr6, 0x82a256c8
	if ctx.cr[6].eq {
	pc = 0x82A256C8; continue 'dispatch;
	}
	// 82A256A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A256AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A256B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A256B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A256B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A256BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A256C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A256C4: 4082FFE8  bne 0x82a256ac
	if !ctx.cr[0].eq {
	pc = 0x82A256AC; continue 'dispatch;
	}
	// 82A256C8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A256CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A256D0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A256D4: 409A0008  bne cr6, 0x82a256dc
	if !ctx.cr[6].eq {
	pc = 0x82A256DC; continue 'dispatch;
	}
	// 82A256D8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A256DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A256E0: 3BA10088  addi r29, r1, 0x88
	ctx.r[29].s64 = ctx.r[1].s64 + 136;
	// 82A256E4: 4BAE3335  bl 0x82508a18
	ctx.lr = 0x82A256E8;
	sub_82508A18(ctx, base);
	// 82A256E8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A256EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A256F0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A256F4: 38A00085  li r5, 0x85
	ctx.r[5].s64 = 133;
	// 82A256F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A256FC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A25700: 48433341  bl 0x82e58a40
	ctx.lr = 0x82A25704;
	sub_82E58A40(ctx, base);
	// 82A25704: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A25708: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2570C: 419A0008  beq cr6, 0x82a25714
	if ctx.cr[6].eq {
	pc = 0x82A25714; continue 'dispatch;
	}
	// 82A25710: 4B89B181  bl 0x822c0890
	ctx.lr = 0x82A25714;
	sub_822C0890(ctx, base);
	// 82A25714: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A25718: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2571C: 419A0008  beq cr6, 0x82a25724
	if ctx.cr[6].eq {
	pc = 0x82A25724; continue 'dispatch;
	}
	// 82A25720: 4B89B171  bl 0x822c0890
	ctx.lr = 0x82A25724;
	sub_822C0890(ctx, base);
	// 82A25724: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 82A25728: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A2572C: 483CC565  bl 0x82df1c90
	ctx.lr = 0x82A25730;
	sub_82DF1C90(ctx, base);
	// 82A25730: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A25734: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82A25738: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82A2573C: 48782A70  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
	// 82A25740: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A25744: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A25748: 4BFEE781  bl 0x82a13ec8
	ctx.lr = 0x82A2574C;
	sub_82A13EC8(ctx, base);
	// 82A2574C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A25750: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A25754: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A25758: 4BEEF719  bl 0x82914e70
	ctx.lr = 0x82A2575C;
	sub_82914E70(ctx, base);
	// 82A2575C: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A25760: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A25764: 419A0008  beq cr6, 0x82a2576c
	if ctx.cr[6].eq {
	pc = 0x82A2576C; continue 'dispatch;
	}
	// 82A25768: 4B89B129  bl 0x822c0890
	ctx.lr = 0x82A2576C;
	sub_822C0890(ctx, base);
	// 82A2576C: 817C0068  lwz r11, 0x68(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A25770: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A25774: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A25778: 394A1170  addi r10, r10, 0x1170
	ctx.r[10].s64 = ctx.r[10].s64 + 4464;
	// 82A2577C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A25780: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A25784: 483CE285  bl 0x82df3a08
	ctx.lr = 0x82A25788;
	sub_82DF3A08(ctx, base);
	// 82A25788: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A2578C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A25790: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A25794: 4815A24D  bl 0x82b7f9e0
	ctx.lr = 0x82A25798;
	sub_82B7F9E0(ctx, base);
	// 82A25798: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2579C: 483CDC8D  bl 0x82df3428
	ctx.lr = 0x82A257A0;
	sub_82DF3428(ctx, base);
	// 82A257A0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A257A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A257A8: 3B6BA970  addi r27, r11, -0x5690
	ctx.r[27].s64 = ctx.r[11].s64 + -22160;
	// 82A257AC: 38A0008B  li r5, 0x8b
	ctx.r[5].s64 = 139;
	// 82A257B0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A257B4: 386000C4  li r3, 0xc4
	ctx.r[3].s64 = 196;
	// 82A257B8: 483CCC31  bl 0x82df23e8
	ctx.lr = 0x82A257BC;
	sub_82DF23E8(ctx, base);
	// 82A257BC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A257C0: 4182002C  beq 0x82a257ec
	if ctx.cr[0].eq {
	pc = 0x82A257EC; continue 'dispatch;
	}
	// 82A257C4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A257C8: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82A257CC: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82A257D0: 4BFEE6F9  bl 0x82a13ec8
	ctx.lr = 0x82A257D4;
	sub_82A13EC8(ctx, base);
	// 82A257D4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A257D8: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82A257DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A257E0: 4816C4B1  bl 0x82b91c90
	ctx.lr = 0x82A257E4;
	sub_82B91C90(ctx, base);
	// 82A257E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A257E8: 48000008  b 0x82a257f0
	pc = 0x82A257F0; continue 'dispatch;
	// 82A257EC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A257F0: 3BDC006C  addi r30, r28, 0x6c
	ctx.r[30].s64 = ctx.r[28].s64 + 108;
	// 82A257F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A257F8: 4BF963A9  bl 0x829bbba0
	ctx.lr = 0x82A257FC;
	sub_829BBBA0(ctx, base);
	// 82A257FC: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A25800: 41820014  beq 0x82a25814
	if ctx.cr[0].eq {
	pc = 0x82A25814; continue 'dispatch;
	}
	// 82A25804: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82A25808: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2580C: 419A0008  beq cr6, 0x82a25814
	if ctx.cr[6].eq {
	pc = 0x82A25814; continue 'dispatch;
	}
	// 82A25810: 4B89B081  bl 0x822c0890
	ctx.lr = 0x82A25814;
	sub_822C0890(ctx, base);
	// 82A25814: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82A25818: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2581C: 388B059C  addi r4, r11, 0x59c
	ctx.r[4].s64 = ctx.r[11].s64 + 1436;
	// 82A25820: 483CE1E9  bl 0x82df3a08
	ctx.lr = 0x82A25824;
	sub_82DF3A08(ctx, base);
	// 82A25824: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A25828: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2582C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A25830: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A25834: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82A25838: 419A0024  beq cr6, 0x82a2585c
	if ctx.cr[6].eq {
	pc = 0x82A2585C; continue 'dispatch;
	}
	// 82A2583C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A25840: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A25844: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A25848: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A2584C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A25850: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A25854: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A25858: 4082FFE8  bne 0x82a25840
	if !ctx.cr[0].eq {
	pc = 0x82A25840; continue 'dispatch;
	}
	// 82A2585C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A25860: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A25864: 4BAE9C65  bl 0x8250f4c8
	ctx.lr = 0x82A25868;
	sub_8250F4C8(ctx, base);
	// 82A25868: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2586C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A25870: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A25874: 409A0008  bne cr6, 0x82a2587c
	if !ctx.cr[6].eq {
	pc = 0x82A2587C; continue 'dispatch;
	}
	// 82A25878: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A2587C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A25880: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A25884: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82A25888: 409A0008  bne cr6, 0x82a25890
	if !ctx.cr[6].eq {
	pc = 0x82A25890; continue 'dispatch;
	}
	// 82A2588C: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 82A25890: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A25894: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A25898: 3BA10068  addi r29, r1, 0x68
	ctx.r[29].s64 = ctx.r[1].s64 + 104;
	// 82A2589C: 4BAE5DB5  bl 0x8250b650
	ctx.lr = 0x82A258A0;
	sub_8250B650(ctx, base);
	// 82A258A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A258A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A258A8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A258AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A258B0: 4BAE7C59  bl 0x8250d508
	ctx.lr = 0x82A258B4;
	sub_8250D508(ctx, base);
	// 82A258B4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A258B8: 483CC3D9  bl 0x82df1c90
	ctx.lr = 0x82A258BC;
	sub_82DF1C90(ctx, base);
	// 82A258BC: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82A258C0: 483CC3D1  bl 0x82df1c90
	ctx.lr = 0x82A258C4;
	sub_82DF1C90(ctx, base);
	// 82A258C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A258C8: 483CDB61  bl 0x82df3428
	ctx.lr = 0x82A258CC;
	sub_82DF3428(ctx, base);
	// 82A258CC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A258D0: 48168D71  bl 0x82b8e640
	ctx.lr = 0x82A258D4;
	sub_82B8E640(ctx, base);
	// 82A258D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A258D8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A258DC: 48168DB5  bl 0x82b8e690
	ctx.lr = 0x82A258E0;
	sub_82B8E690(ctx, base);
	// 82A258E0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A258E4: 48169D0D  bl 0x82b8f5f0
	ctx.lr = 0x82A258E8;
	sub_82B8F5F0(ctx, base);
	// 82A258E8: 817C0068  lwz r11, 0x68(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A258EC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A258F0: 419800EC  blt cr6, 0x82a259dc
	if ctx.cr[6].lt {
	pc = 0x82A259DC; continue 'dispatch;
	}
	// 82A258F4: 409A0230  bne cr6, 0x82a25b24
	if !ctx.cr[6].eq {
	pc = 0x82A25B24; continue 'dispatch;
	}
	// 82A258F8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A258FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A25900: 38A0009B  li r5, 0x9b
	ctx.r[5].s64 = 155;
	// 82A25904: 386000F8  li r3, 0xf8
	ctx.r[3].s64 = 248;
	// 82A25908: 483CCAE1  bl 0x82df23e8
	ctx.lr = 0x82A2590C;
	sub_82DF23E8(ctx, base);
	// 82A2590C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A25910: 41820020  beq 0x82a25930
	if ctx.cr[0].eq {
	pc = 0x82A25930; continue 'dispatch;
	}
	// 82A25914: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A25918: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A2591C: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 82A25920: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A25924: 4BF6106D  bl 0x82986990
	ctx.lr = 0x82A25928;
	sub_82986990(ctx, base);
	// 82A25928: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2592C: 48000008  b 0x82a25934
	pc = 0x82A25934; continue 'dispatch;
	// 82A25930: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 82A25934: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A25938: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2593C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A25940: 4BF61FC9  bl 0x82987908
	ctx.lr = 0x82A25944;
	sub_82987908(ctx, base);
	// 82A25944: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A25948: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2594C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A25950: 4B89A6B1  bl 0x822c0000
	ctx.lr = 0x82A25954;
	sub_822C0000(ctx, base);
	// 82A25954: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A25958: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A2595C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A25960: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82A25964: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A25968: 419A0024  beq cr6, 0x82a2598c
	if ctx.cr[6].eq {
	pc = 0x82A2598C; continue 'dispatch;
	}
	// 82A2596C: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82A25970: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A25974: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A25978: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A2597C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A25980: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A25984: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A25988: 4082FFE8  bne 0x82a25970
	if !ctx.cr[0].eq {
	pc = 0x82A25970; continue 'dispatch;
	}
	// 82A2598C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A25990: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A25994: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82A25998: 409A0008  bne cr6, 0x82a259a0
	if !ctx.cr[6].eq {
	pc = 0x82A259A0; continue 'dispatch;
	}
	// 82A2599C: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 82A259A0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A259A4: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A259A8: 3BA10068  addi r29, r1, 0x68
	ctx.r[29].s64 = ctx.r[1].s64 + 104;
	// 82A259AC: 4BAE9B6D  bl 0x8250f518
	ctx.lr = 0x82A259B0;
	sub_8250F518(ctx, base);
	// 82A259B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A259B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A259B8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A259BC: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82A259C0: 4BAE7B49  bl 0x8250d508
	ctx.lr = 0x82A259C4;
	sub_8250D508(ctx, base);
	// 82A259C4: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A259C8: 483CC2C9  bl 0x82df1c90
	ctx.lr = 0x82A259CC;
	sub_82DF1C90(ctx, base);
	// 82A259CC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A259D0: 419A0154  beq cr6, 0x82a25b24
	if ctx.cr[6].eq {
	pc = 0x82A25B24; continue 'dispatch;
	}
	// 82A259D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A259D8: 48000148  b 0x82a25b20
	pc = 0x82A25B20; continue 'dispatch;
	// 82A259DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A259E0: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82A259E4: 4BB52DDD  bl 0x825787c0
	ctx.lr = 0x82A259E8;
	sub_825787C0(ctx, base);
	// 82A259E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A259EC: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82A259F0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A259F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A259F8: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82A259FC: 419A0024  beq cr6, 0x82a25a20
	if ctx.cr[6].eq {
	pc = 0x82A25A20; continue 'dispatch;
	}
	// 82A25A00: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A25A04: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A25A08: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A25A0C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A25A10: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A25A14: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A25A18: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A25A1C: 4082FFE8  bne 0x82a25a04
	if !ctx.cr[0].eq {
	pc = 0x82A25A04; continue 'dispatch;
	}
	// 82A25A20: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A25A24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A25A28: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A25A2C: 409A0008  bne cr6, 0x82a25a34
	if !ctx.cr[6].eq {
	pc = 0x82A25A34; continue 'dispatch;
	}
	// 82A25A30: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A25A34: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A25A38: 3BFA0028  addi r31, r26, 0x28
	ctx.r[31].s64 = ctx.r[26].s64 + 40;
	// 82A25A3C: 3BA10080  addi r29, r1, 0x80
	ctx.r[29].s64 = ctx.r[1].s64 + 128;
	// 82A25A40: 4BAE2FD9  bl 0x82508a18
	ctx.lr = 0x82A25A44;
	sub_82508A18(ctx, base);
	// 82A25A44: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A25A48: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A25A4C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A25A50: 38A00094  li r5, 0x94
	ctx.r[5].s64 = 148;
	// 82A25A54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A25A58: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A25A5C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A25A60: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A25A64: 48432FDD  bl 0x82e58a40
	ctx.lr = 0x82A25A68;
	sub_82E58A40(ctx, base);
	// 82A25A68: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A25A6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A25A70: 419A0008  beq cr6, 0x82a25a78
	if ctx.cr[6].eq {
	pc = 0x82A25A78; continue 'dispatch;
	}
	// 82A25A74: 4B89AE1D  bl 0x822c0890
	ctx.lr = 0x82A25A78;
	sub_822C0890(ctx, base);
	// 82A25A78: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A25A7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A25A80: 419A0008  beq cr6, 0x82a25a88
	if ctx.cr[6].eq {
	pc = 0x82A25A88; continue 'dispatch;
	}
	// 82A25A84: 4B89AE0D  bl 0x822c0890
	ctx.lr = 0x82A25A88;
	sub_822C0890(ctx, base);
	// 82A25A88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A25A8C: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82A25A90: 4BB52D31  bl 0x825787c0
	ctx.lr = 0x82A25A94;
	sub_825787C0(ctx, base);
	// 82A25A94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A25A98: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82A25A9C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A25AA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A25AA4: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82A25AA8: 419A0024  beq cr6, 0x82a25acc
	if ctx.cr[6].eq {
	pc = 0x82A25ACC; continue 'dispatch;
	}
	// 82A25AAC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A25AB0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A25AB4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A25AB8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A25ABC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A25AC0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A25AC4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A25AC8: 4082FFE8  bne 0x82a25ab0
	if !ctx.cr[0].eq {
	pc = 0x82A25AB0; continue 'dispatch;
	}
	// 82A25ACC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A25AD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A25AD4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A25AD8: 409A0008  bne cr6, 0x82a25ae0
	if !ctx.cr[6].eq {
	pc = 0x82A25AE0; continue 'dispatch;
	}
	// 82A25ADC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A25AE0: 3BC10078  addi r30, r1, 0x78
	ctx.r[30].s64 = ctx.r[1].s64 + 120;
	// 82A25AE4: 4BAE2F9D  bl 0x82508a80
	ctx.lr = 0x82A25AE8;
	sub_82508A80(ctx, base);
	// 82A25AE8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A25AEC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A25AF0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A25AF4: 38A00096  li r5, 0x96
	ctx.r[5].s64 = 150;
	// 82A25AF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A25AFC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A25B00: 48432F41  bl 0x82e58a40
	ctx.lr = 0x82A25B04;
	sub_82E58A40(ctx, base);
	// 82A25B04: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A25B08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A25B0C: 419A0008  beq cr6, 0x82a25b14
	if ctx.cr[6].eq {
	pc = 0x82A25B14; continue 'dispatch;
	}
	// 82A25B10: 4B89AD81  bl 0x822c0890
	ctx.lr = 0x82A25B14;
	sub_822C0890(ctx, base);
	// 82A25B14: 806100DC  lwz r3, 0xdc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82A25B18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A25B1C: 419A0008  beq cr6, 0x82a25b24
	if ctx.cr[6].eq {
	pc = 0x82A25B24; continue 'dispatch;
	}
	// 82A25B20: 4B89AD71  bl 0x822c0890
	ctx.lr = 0x82A25B24;
	sub_822C0890(ctx, base);
	// 82A25B24: 817C0068  lwz r11, 0x68(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A25B28: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A25B2C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A25B30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A25B34: 917C0068  stw r11, 0x68(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A25B38: 419A0008  beq cr6, 0x82a25b40
	if ctx.cr[6].eq {
	pc = 0x82A25B40; continue 'dispatch;
	}
	// 82A25B3C: 4B89AD55  bl 0x822c0890
	ctx.lr = 0x82A25B40;
	sub_822C0890(ctx, base);
	// 82A25B40: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82A25B44: 4BFFFBE4  b 0x82a25728
	pc = 0x82A25728; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A25B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A25B48 size=216
    let mut pc: u32 = 0x82A25B48;
    'dispatch: loop {
        match pc {
            0x82A25B48 => {
    //   block [0x82A25B48..0x82A25C20)
	// 82A25B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A25B4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A25B50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A25B54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A25B58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A25B5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A25B60: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A25B64: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A25B68: 419A005C  beq cr6, 0x82a25bc4
	if ctx.cr[6].eq {
	pc = 0x82A25BC4; continue 'dispatch;
	}
	// 82A25B6C: 2F0B0064  cmpwi cr6, r11, 0x64
	ctx.cr[6].compare_i32(ctx.r[11].s32, 100, &mut ctx.xer);
	// 82A25B70: 409A0098  bne cr6, 0x82a25c08
	if !ctx.cr[6].eq {
	pc = 0x82A25C08; continue 'dispatch;
	}
	// 82A25B74: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A25B78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A25B7C: 388B893C  addi r4, r11, -0x76c4
	ctx.r[4].s64 = ctx.r[11].s64 + -30404;
	// 82A25B80: 483CDE89  bl 0x82df3a08
	ctx.lr = 0x82A25B84;
	sub_82DF3A08(ctx, base);
	// 82A25B84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A25B88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A25B8C: 485E259D  bl 0x83008128
	ctx.lr = 0x82A25B90;
	sub_83008128(ctx, base);
	// 82A25B90: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A25B94: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A25B98: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A25B9C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A25BA0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A25BA4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A25BA8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A25BAC: 48438DB5  bl 0x82e5e960
	ctx.lr = 0x82A25BB0;
	sub_82E5E960(ctx, base);
	// 82A25BB0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A25BB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A25BB8: 419A0050  beq cr6, 0x82a25c08
	if ctx.cr[6].eq {
	pc = 0x82A25C08; continue 'dispatch;
	}
	// 82A25BBC: 4B89ACD5  bl 0x822c0890
	ctx.lr = 0x82A25BC0;
	sub_822C0890(ctx, base);
	// 82A25BC0: 48000048  b 0x82a25c08
	pc = 0x82A25C08; continue 'dispatch;
	// 82A25BC4: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A25BC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A25BCC: 419A0010  beq cr6, 0x82a25bdc
	if ctx.cr[6].eq {
	pc = 0x82A25BDC; continue 'dispatch;
	}
	// 82A25BD0: 48168971  bl 0x82b8e540
	ctx.lr = 0x82A25BD4;
	sub_82B8E540(ctx, base);
	// 82A25BD4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A25BD8: 40820030  bne 0x82a25c08
	if !ctx.cr[0].eq {
	pc = 0x82A25C08; continue 'dispatch;
	}
	// 82A25BDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A25BE0: 4BFFF9A1  bl 0x82a25580
	ctx.lr = 0x82A25BE4;
	sub_82A25580(ctx, base);
	// 82A25BE4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A25BE8: 40820020  bne 0x82a25c08
	if !ctx.cr[0].eq {
	pc = 0x82A25C08; continue 'dispatch;
	}
	// 82A25BEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A25BF0: 4872EA11  bl 0x83154600
	ctx.lr = 0x82A25BF4;
	sub_83154600(ctx, base);
	// 82A25BF4: 4BFED2C5  bl 0x82a12eb8
	ctx.lr = 0x82A25BF8;
	sub_82A12EB8(ctx, base);
	// 82A25BF8: 38800022  li r4, 0x22
	ctx.r[4].s64 = 34;
	// 82A25BFC: 4BFF3D0D  bl 0x82a19908
	ctx.lr = 0x82A25C00;
	sub_82A19908(ctx, base);
	// 82A25C00: 39600064  li r11, 0x64
	ctx.r[11].s64 = 100;
	// 82A25C04: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A25C08: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A25C0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A25C10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A25C14: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A25C18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A25C1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A25C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A25C20 size=56
    let mut pc: u32 = 0x82A25C20;
    'dispatch: loop {
        match pc {
            0x82A25C20 => {
    //   block [0x82A25C20..0x82A25C58)
	// 82A25C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A25C24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A25C28: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A25C2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A25C30: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A25C34: 91430064  stw r10, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82A25C38: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A25C3C: D0030060  stfs f0, 0x60(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A25C40: 4872E9C1  bl 0x83154600
	ctx.lr = 0x82A25C44;
	sub_83154600(ctx, base);
	// 82A25C44: 4BFED315  bl 0x82a12f58
	ctx.lr = 0x82A25C48;
	sub_82A12F58(ctx, base);
	// 82A25C48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A25C4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A25C50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A25C54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A25C58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A25C58 size=60
    let mut pc: u32 = 0x82A25C58;
    'dispatch: loop {
        match pc {
            0x82A25C58 => {
    //   block [0x82A25C58..0x82A25C94)
	// 82A25C58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A25C5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A25C60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A25C64: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A25C68: 4872E999  bl 0x83154600
	ctx.lr = 0x82A25C6C;
	sub_83154600(ctx, base);
	// 82A25C6C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A25C70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A25C74: 4BFF0D75  bl 0x82a169e8
	ctx.lr = 0x82A25C78;
	sub_82A169E8(ctx, base);
	// 82A25C78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A25C7C: 4BFED2ED  bl 0x82a12f68
	ctx.lr = 0x82A25C80;
	sub_82A12F68(ctx, base);
	// 82A25C80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A25C84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A25C88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A25C8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A25C90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A25C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A25C98 size=108
    let mut pc: u32 = 0x82A25C98;
    'dispatch: loop {
        match pc {
            0x82A25C98 => {
    //   block [0x82A25C98..0x82A25D04)
	// 82A25C98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A25C9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A25CA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A25CA4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A25CA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A25CAC: 4BFF849D  bl 0x82a1e148
	ctx.lr = 0x82A25CB0;
	sub_82A1E148(ctx, base);
	// 82A25CB0: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A25CB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A25CB8: 394AA9BC  addi r10, r10, -0x5644
	ctx.r[10].s64 = ctx.r[10].s64 + -22084;
	// 82A25CBC: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A25CC0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A25CC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A25CC8: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A25CCC: 3889907C  addi r4, r9, -0x6f84
	ctx.r[4].s64 = ctx.r[9].s64 + -28548;
	// 82A25CD0: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A25CD4: 483CDD35  bl 0x82df3a08
	ctx.lr = 0x82A25CD8;
	sub_82DF3A08(ctx, base);
	// 82A25CD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A25CDC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A25CE0: 48433A09  bl 0x82e596e8
	ctx.lr = 0x82A25CE4;
	sub_82E596E8(ctx, base);
	// 82A25CE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A25CE8: 483CD741  bl 0x82df3428
	ctx.lr = 0x82A25CEC;
	sub_82DF3428(ctx, base);
	// 82A25CEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A25CF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A25CF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A25CF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A25CFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A25D00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A25D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A25D08 size=96
    let mut pc: u32 = 0x82A25D08;
    'dispatch: loop {
        match pc {
            0x82A25D08 => {
    //   block [0x82A25D08..0x82A25D68)
	// 82A25D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A25D0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A25D10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A25D14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A25D18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A25D1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A25D20: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A25D24: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A25D28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A25D2C: 419A0008  beq cr6, 0x82a25d34
	if ctx.cr[6].eq {
	pc = 0x82A25D34; continue 'dispatch;
	}
	// 82A25D30: 4B89AB61  bl 0x822c0890
	ctx.lr = 0x82A25D34;
	sub_822C0890(ctx, base);
	// 82A25D34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A25D38: 48436851  bl 0x82e5c588
	ctx.lr = 0x82A25D3C;
	sub_82E5C588(ctx, base);
	// 82A25D3C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A25D40: 4182000C  beq 0x82a25d4c
	if ctx.cr[0].eq {
	pc = 0x82A25D4C; continue 'dispatch;
	}
	// 82A25D44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A25D48: 483CC691  bl 0x82df23d8
	ctx.lr = 0x82A25D4C;
	sub_82DF23D8(ctx, base);
	// 82A25D4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A25D50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A25D54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A25D58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A25D5C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A25D60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A25D64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A25D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A25D68 size=636
    let mut pc: u32 = 0x82A25D68;
    'dispatch: loop {
        match pc {
            0x82A25D68 => {
    //   block [0x82A25D68..0x82A25FE4)
	// 82A25D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A25D6C: 48782401  bl 0x831a816c
	ctx.lr = 0x82A25D70;
	sub_831A8130(ctx, base);
	// 82A25D70: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82A25D74: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A25D78: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A25D7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A25D80: 4872E881  bl 0x83154600
	ctx.lr = 0x82A25D84;
	sub_83154600(ctx, base);
	// 82A25D84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A25D88: 4BFED131  bl 0x82a12eb8
	ctx.lr = 0x82A25D8C;
	sub_82A12EB8(ctx, base);
	// 82A25D8C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A25D90: C3DF0060  lfs f30, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A25D94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A25D98: 484339E1  bl 0x82e59778
	ctx.lr = 0x82A25D9C;
	sub_82E59778(ctx, base);
	// 82A25D9C: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A25DA0: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A25DA4: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82A25DA8: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A25DAC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A25DB0: 419801FC  blt cr6, 0x82a25fac
	if ctx.cr[6].lt {
	pc = 0x82A25FAC; continue 'dispatch;
	}
	// 82A25DB4: 419A010C  beq cr6, 0x82a25ec0
	if ctx.cr[6].eq {
	pc = 0x82A25EC0; continue 'dispatch;
	}
	// 82A25DB8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A25DBC: 4198008C  blt cr6, 0x82a25e48
	if ctx.cr[6].lt {
	pc = 0x82A25E48; continue 'dispatch;
	}
	// 82A25DC0: 409A0214  bne cr6, 0x82a25fd4
	if !ctx.cr[6].eq {
	pc = 0x82A25FD4; continue 'dispatch;
	}
	// 82A25DC4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A25DC8: 4BDCE619  bl 0x827f43e0
	ctx.lr = 0x82A25DCC;
	sub_827F43E0(ctx, base);
	// 82A25DCC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A25DD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A25DD4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A25DD8: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A25DDC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A25DE0: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A25DE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A25DE8: 4E800421  bctrl
	ctx.lr = 0x82A25DEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A25DEC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A25DF0: 418201E4  beq 0x82a25fd4
	if ctx.cr[0].eq {
	pc = 0x82A25FD4; continue 'dispatch;
	}
	// 82A25DF4: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82A25DF8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A25DFC: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A25E00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A25E04: 388A893C  addi r4, r10, -0x76c4
	ctx.r[4].s64 = ctx.r[10].s64 + -30404;
	// 82A25E08: 483CDC01  bl 0x82df3a08
	ctx.lr = 0x82A25E0C;
	sub_82DF3A08(ctx, base);
	// 82A25E0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A25E10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A25E14: 485E2315  bl 0x83008128
	ctx.lr = 0x82A25E18;
	sub_83008128(ctx, base);
	// 82A25E18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A25E1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A25E20: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A25E24: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A25E28: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A25E2C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A25E30: 48438B31  bl 0x82e5e960
	ctx.lr = 0x82A25E34;
	sub_82E5E960(ctx, base);
	// 82A25E34: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A25E38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A25E3C: 419A0198  beq cr6, 0x82a25fd4
	if ctx.cr[6].eq {
	pc = 0x82A25FD4; continue 'dispatch;
	}
	// 82A25E40: 4B89AA51  bl 0x822c0890
	ctx.lr = 0x82A25E44;
	sub_822C0890(ctx, base);
	// 82A25E44: 48000190  b 0x82a25fd4
	pc = 0x82A25FD4; continue 'dispatch;
	// 82A25E48: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A25E4C: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A25E50: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A25E54: 40980180  bge cr6, 0x82a25fd4
	if !ctx.cr[6].lt {
	pc = 0x82A25FD4; continue 'dispatch;
	}
	// 82A25E58: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A25E5C: 4BDCE585  bl 0x827f43e0
	ctx.lr = 0x82A25E60;
	sub_827F43E0(ctx, base);
	// 82A25E60: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A25E64: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A25E68: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A25E6C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A25E70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A25E74: 4E800421  bctrl
	ctx.lr = 0x82A25E78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A25E78: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A25E7C: 41820158  beq 0x82a25fd4
	if ctx.cr[0].eq {
	pc = 0x82A25FD4; continue 'dispatch;
	}
	// 82A25E80: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A25E84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A25E88: 419A0024  beq cr6, 0x82a25eac
	if ctx.cr[6].eq {
	pc = 0x82A25EAC; continue 'dispatch;
	}
	// 82A25E8C: 4812083D  bl 0x82b466c8
	ctx.lr = 0x82A25E90;
	sub_82B466C8(ctx, base);
	// 82A25E90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A25E94: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A25E98: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A25E9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A25EA0: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A25EA4: 419A0008  beq cr6, 0x82a25eac
	if ctx.cr[6].eq {
	pc = 0x82A25EAC; continue 'dispatch;
	}
	// 82A25EA8: 4B89A9E9  bl 0x822c0890
	ctx.lr = 0x82A25EAC;
	sub_822C0890(ctx, base);
	// 82A25EAC: 38800024  li r4, 0x24
	ctx.r[4].s64 = 36;
	// 82A25EB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A25EB4: 4BFF3A55  bl 0x82a19908
	ctx.lr = 0x82A25EB8;
	sub_82A19908(ctx, base);
	// 82A25EB8: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82A25EBC: 480000E8  b 0x82a25fa4
	pc = 0x82A25FA4; continue 'dispatch;
	// 82A25EC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A25EC4: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A25EC8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82A25ECC: 41990018  bgt cr6, 0x82a25ee4
	if ctx.cr[6].gt {
	pc = 0x82A25EE4; continue 'dispatch;
	}
	// 82A25ED0: FF1EF800  fcmpu cr6, f30, f31
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 82A25ED4: 40990010  ble cr6, 0x82a25ee4
	if !ctx.cr[6].gt {
	pc = 0x82A25EE4; continue 'dispatch;
	}
	// 82A25ED8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82A25EDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A25EE0: 4BFF0821  bl 0x82a16700
	ctx.lr = 0x82A25EE4;
	sub_82A16700(ctx, base);
	// 82A25EE4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A25EE8: 4BDCE4F9  bl 0x827f43e0
	ctx.lr = 0x82A25EEC;
	sub_827F43E0(ctx, base);
	// 82A25EEC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A25EF0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A25EF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A25EF8: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A25EFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A25F00: 4E800421  bctrl
	ctx.lr = 0x82A25F04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A25F04: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A25F08: 418200CC  beq 0x82a25fd4
	if ctx.cr[0].eq {
	pc = 0x82A25FD4; continue 'dispatch;
	}
	// 82A25F0C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A25F10: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A25F14: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A25F18: 38AAA350  addi r5, r10, -0x5cb0
	ctx.r[5].s64 = ctx.r[10].s64 + -23728;
	// 82A25F1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A25F20: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A25F24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A25F28: 4E800421  bctrl
	ctx.lr = 0x82A25F2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A25F2C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A25F30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A25F34: 419A0008  beq cr6, 0x82a25f3c
	if ctx.cr[6].eq {
	pc = 0x82A25F3C; continue 'dispatch;
	}
	// 82A25F38: 4B89A959  bl 0x822c0890
	ctx.lr = 0x82A25F3C;
	sub_822C0890(ctx, base);
	// 82A25F3C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A25F40: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A25F44: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A25F48: 38AAA9E0  addi r5, r10, -0x5620
	ctx.r[5].s64 = ctx.r[10].s64 + -22048;
	// 82A25F4C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A25F50: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82A25F54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A25F58: 4E800421  bctrl
	ctx.lr = 0x82A25F5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A25F5C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A25F60: 395F0068  addi r10, r31, 0x68
	ctx.r[10].s64 = ctx.r[31].s64 + 104;
	// 82A25F64: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A25F68: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82A25F6C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A25F70: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A25F74: 4B89E4ED  bl 0x822c4460
	ctx.lr = 0x82A25F78;
	sub_822C4460(ctx, base);
	// 82A25F78: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A25F7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A25F80: 419A0008  beq cr6, 0x82a25f88
	if ctx.cr[6].eq {
	pc = 0x82A25F88; continue 'dispatch;
	}
	// 82A25F84: 4B89A90D  bl 0x822c0890
	ctx.lr = 0x82A25F88;
	sub_822C0890(ctx, base);
	// 82A25F88: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A25F8C: 38800025  li r4, 0x25
	ctx.r[4].s64 = 37;
	// 82A25F90: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A25F94: C02B614C  lfs f1, 0x614c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24908 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A25F98: D03F0060  stfs f1, 0x60(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A25F9C: 4BFF35CD  bl 0x82a19568
	ctx.lr = 0x82A25FA0;
	sub_82A19568(ctx, base);
	// 82A25FA0: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A25FA4: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A25FA8: 4800002C  b 0x82a25fd4
	pc = 0x82A25FD4; continue 'dispatch;
	// 82A25FAC: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82A25FB0: 38800026  li r4, 0x26
	ctx.r[4].s64 = 38;
	// 82A25FB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A25FB8: C02B7BC4  lfs f1, 0x7bc4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31684 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A25FBC: 4BFF35AD  bl 0x82a19568
	ctx.lr = 0x82A25FC0;
	sub_82A19568(ctx, base);
	// 82A25FC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A25FC4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A25FC8: 915F0064  stw r10, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82A25FCC: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A25FD0: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A25FD4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A25FD8: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A25FDC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A25FE0: 487821DC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A25FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A25FE8 size=84
    let mut pc: u32 = 0x82A25FE8;
    'dispatch: loop {
        match pc {
            0x82A25FE8 => {
    //   block [0x82A25FE8..0x82A2603C)
	// 82A25FE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A25FEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A25FF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A25FF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A25FF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A25FFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A26000: 4872E601  bl 0x83154600
	ctx.lr = 0x82A26004;
	sub_83154600(ctx, base);
	// 82A26004: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A26008: 4BFECED9  bl 0x82a12ee0
	ctx.lr = 0x82A2600C;
	sub_82A12EE0(ctx, base);
	// 82A2600C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A26010: 4BFECF59  bl 0x82a12f68
	ctx.lr = 0x82A26014;
	sub_82A12F68(ctx, base);
	// 82A26014: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A26018: 4BFECFA1  bl 0x82a12fb8
	ctx.lr = 0x82A2601C;
	sub_82A12FB8(ctx, base);
	// 82A2601C: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A26020: 481206A9  bl 0x82b466c8
	ctx.lr = 0x82A26024;
	sub_82B466C8(ctx, base);
	// 82A26024: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A26028: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2602C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A26030: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A26034: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A26038: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A26040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A26040 size=116
    let mut pc: u32 = 0x82A26040;
    'dispatch: loop {
        match pc {
            0x82A26040 => {
    //   block [0x82A26040..0x82A260B4)
	// 82A26040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A26044: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A26048: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2604C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A26050: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A26054: 4BFF80F5  bl 0x82a1e148
	ctx.lr = 0x82A26058;
	sub_82A1E148(ctx, base);
	// 82A26058: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A2605C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A26060: 394AAA14  addi r10, r10, -0x55ec
	ctx.r[10].s64 = ctx.r[10].s64 + -21996;
	// 82A26064: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A26068: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A2606C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A26070: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A26074: 3889A0DC  addi r4, r9, -0x5f24
	ctx.r[4].s64 = ctx.r[9].s64 + -24356;
	// 82A26078: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A2607C: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A26080: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82A26084: 483CD985  bl 0x82df3a08
	ctx.lr = 0x82A26088;
	sub_82DF3A08(ctx, base);
	// 82A26088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2608C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A26090: 48433659  bl 0x82e596e8
	ctx.lr = 0x82A26094;
	sub_82E596E8(ctx, base);
	// 82A26094: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A26098: 483CD391  bl 0x82df3428
	ctx.lr = 0x82A2609C;
	sub_82DF3428(ctx, base);
	// 82A2609C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A260A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A260A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A260A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A260AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A260B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A260B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A260B8 size=80
    let mut pc: u32 = 0x82A260B8;
    'dispatch: loop {
        match pc {
            0x82A260B8 => {
    //   block [0x82A260B8..0x82A26108)
	// 82A260B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A260BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A260C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A260C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A260C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A260CC: 807F0074  lwz r3, 0x74(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A260D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A260D4: 419A0008  beq cr6, 0x82a260dc
	if ctx.cr[6].eq {
	pc = 0x82A260DC; continue 'dispatch;
	}
	// 82A260D8: 4B89A7B9  bl 0x822c0890
	ctx.lr = 0x82A260DC;
	sub_822C0890(ctx, base);
	// 82A260DC: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A260E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A260E4: 419A0008  beq cr6, 0x82a260ec
	if ctx.cr[6].eq {
	pc = 0x82A260EC; continue 'dispatch;
	}
	// 82A260E8: 4B89A7A9  bl 0x822c0890
	ctx.lr = 0x82A260EC;
	sub_822C0890(ctx, base);
	// 82A260EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A260F0: 48436499  bl 0x82e5c588
	ctx.lr = 0x82A260F4;
	sub_82E5C588(ctx, base);
	// 82A260F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A260F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A260FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A26100: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A26104: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A26108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A26108 size=76
    let mut pc: u32 = 0x82A26108;
    'dispatch: loop {
        match pc {
            0x82A26108 => {
    //   block [0x82A26108..0x82A26154)
	// 82A26108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2610C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A26110: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A26114: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A26118: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2611C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A26120: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A26124: 4BFFFF95  bl 0x82a260b8
	ctx.lr = 0x82A26128;
	sub_82A260B8(ctx, base);
	// 82A26128: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2612C: 4182000C  beq 0x82a26138
	if ctx.cr[0].eq {
	pc = 0x82A26138; continue 'dispatch;
	}
	// 82A26130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A26134: 483CC2A5  bl 0x82df23d8
	ctx.lr = 0x82A26138;
	sub_82DF23D8(ctx, base);
	// 82A26138: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2613C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A26140: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A26144: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A26148: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A2614C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A26150: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A26158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A26158 size=308
    let mut pc: u32 = 0x82A26158;
    'dispatch: loop {
        match pc {
            0x82A26158 => {
    //   block [0x82A26158..0x82A2628C)
	// 82A26158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2615C: 48782011  bl 0x831a816c
	ctx.lr = 0x82A26160;
	sub_831A8130(ctx, base);
	// 82A26160: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A26164: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A26168: 4872E499  bl 0x83154600
	ctx.lr = 0x82A2616C;
	sub_83154600(ctx, base);
	// 82A2616C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A26170: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A26174: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A26178: 915F0064  stw r10, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82A2617C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A26180: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A26184: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A26188: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A2618C: 4BAE933D  bl 0x8250f4c8
	ctx.lr = 0x82A26190;
	sub_8250F4C8(ctx, base);
	// 82A26190: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A26194: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A26198: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A2619C: 409A0008  bne cr6, 0x82a261a4
	if !ctx.cr[6].eq {
	pc = 0x82A261A4; continue 'dispatch;
	}
	// 82A261A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A261A4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A261A8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A261AC: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82A261B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A261B4: 48120CED  bl 0x82b46ea0
	ctx.lr = 0x82A261B8;
	sub_82B46EA0(ctx, base);
	// 82A261B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A261BC: 3BDF0068  addi r30, r31, 0x68
	ctx.r[30].s64 = ctx.r[31].s64 + 104;
	// 82A261C0: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A261C4: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82A261C8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A261CC: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A261D0: 4B89E291  bl 0x822c4460
	ctx.lr = 0x82A261D4;
	sub_822C4460(ctx, base);
	// 82A261D4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A261D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A261DC: 419A0008  beq cr6, 0x82a261e4
	if ctx.cr[6].eq {
	pc = 0x82A261E4; continue 'dispatch;
	}
	// 82A261E0: 4B89A6B1  bl 0x822c0890
	ctx.lr = 0x82A261E4;
	sub_822C0890(ctx, base);
	// 82A261E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A261E8: 483CBAA9  bl 0x82df1c90
	ctx.lr = 0x82A261EC;
	sub_82DF1C90(ctx, base);
	// 82A261EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A261F0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A261F4: 4BAE92D5  bl 0x8250f4c8
	ctx.lr = 0x82A261F8;
	sub_8250F4C8(ctx, base);
	// 82A261F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A261FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A26200: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A26204: 409A0008  bne cr6, 0x82a2620c
	if !ctx.cr[6].eq {
	pc = 0x82A2620C; continue 'dispatch;
	}
	// 82A26208: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A2620C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A26210: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A26214: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82A26218: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A2621C: 48120C85  bl 0x82b46ea0
	ctx.lr = 0x82A26220;
	sub_82B46EA0(ctx, base);
	// 82A26220: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A26224: 3BFF0070  addi r31, r31, 0x70
	ctx.r[31].s64 = ctx.r[31].s64 + 112;
	// 82A26228: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A2622C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82A26230: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A26234: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A26238: 4B89E229  bl 0x822c4460
	ctx.lr = 0x82A2623C;
	sub_822C4460(ctx, base);
	// 82A2623C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A26240: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A26244: 419A0008  beq cr6, 0x82a2624c
	if ctx.cr[6].eq {
	pc = 0x82A2624C; continue 'dispatch;
	}
	// 82A26248: 4B89A649  bl 0x822c0890
	ctx.lr = 0x82A2624C;
	sub_822C0890(ctx, base);
	// 82A2624C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A26250: 483CBA41  bl 0x82df1c90
	ctx.lr = 0x82A26254;
	sub_82DF1C90(ctx, base);
	// 82A26254: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A26258: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2625C: 4BFED425  bl 0x82a13680
	ctx.lr = 0x82A26260;
	sub_82A13680(ctx, base);
	// 82A26260: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A26264: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A26268: 48120941  bl 0x82b46ba8
	ctx.lr = 0x82A2626C;
	sub_82B46BA8(ctx, base);
	// 82A2626C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A26270: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A26274: 4BFED40D  bl 0x82a13680
	ctx.lr = 0x82A26278;
	sub_82A13680(ctx, base);
	// 82A26278: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A2627C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A26280: 48120929  bl 0x82b46ba8
	ctx.lr = 0x82A26284;
	sub_82B46BA8(ctx, base);
	// 82A26284: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A26288: 48781F34  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A26290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A26290 size=768
    let mut pc: u32 = 0x82A26290;
    'dispatch: loop {
        match pc {
            0x82A26290 => {
    //   block [0x82A26290..0x82A26590)
	// 82A26290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A26294: 48781ED5  bl 0x831a8168
	ctx.lr = 0x82A26298;
	sub_831A8130(ctx, base);
	// 82A26298: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A2629C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A262A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A262A4: 4872E35D  bl 0x83154600
	ctx.lr = 0x82A262A8;
	sub_83154600(ctx, base);
	// 82A262A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A262AC: 4BFECC0D  bl 0x82a12eb8
	ctx.lr = 0x82A262B0;
	sub_82A12EB8(ctx, base);
	// 82A262B0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A262B4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A262B8: 480079B9  bl 0x82a2dc70
	ctx.lr = 0x82A262BC;
	sub_82A2DC70(ctx, base);
	// 82A262BC: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A262C0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A262C4: 4198024C  blt cr6, 0x82a26510
	if ctx.cr[6].lt {
	pc = 0x82A26510; continue 'dispatch;
	}
	// 82A262C8: 419A0170  beq cr6, 0x82a26438
	if ctx.cr[6].eq {
	pc = 0x82A26438; continue 'dispatch;
	}
	// 82A262CC: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A262D0: 41980104  blt cr6, 0x82a263d4
	if ctx.cr[6].lt {
	pc = 0x82A263D4; continue 'dispatch;
	}
	// 82A262D4: 409A02A0  bne cr6, 0x82a26574
	if !ctx.cr[6].eq {
	pc = 0x82A26574; continue 'dispatch;
	}
	// 82A262D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A262DC: 4843349D  bl 0x82e59778
	ctx.lr = 0x82A262E0;
	sub_82E59778(ctx, base);
	// 82A262E0: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A262E4: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A262E8: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A262EC: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A262F0: 48006B31  bl 0x82a2ce20
	ctx.lr = 0x82A262F4;
	sub_82A2CE20(ctx, base);
	// 82A262F4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A262F8: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A262FC: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A26300: 396BA9F0  addi r11, r11, -0x5610
	ctx.r[11].s64 = ctx.r[11].s64 + -22032;
	// 82A26304: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82A26308: 7DAA5C2E  lfsx f13, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A2630C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A26310: 41990264  bgt cr6, 0x82a26574
	if ctx.cr[6].gt {
	pc = 0x82A26574; continue 'dispatch;
	}
	// 82A26314: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A26318: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A2631C: 388B17D4  addi r4, r11, 0x17d4
	ctx.r[4].s64 = ctx.r[11].s64 + 6100;
	// 82A26320: 483CD6E9  bl 0x82df3a08
	ctx.lr = 0x82A26324;
	sub_82DF3A08(ctx, base);
	// 82A26324: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A26328: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2632C: 388BA46C  addi r4, r11, -0x5b94
	ctx.r[4].s64 = ctx.r[11].s64 + -23444;
	// 82A26330: 483CD6D9  bl 0x82df3a08
	ctx.lr = 0x82A26334;
	sub_82DF3A08(ctx, base);
	// 82A26334: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A26338: 485E1DF1  bl 0x83008128
	ctx.lr = 0x82A2633C;
	sub_83008128(ctx, base);
	// 82A2633C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A26340: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A26344: 484341DD  bl 0x82e5a520
	ctx.lr = 0x82A26348;
	sub_82E5A520(ctx, base);
	// 82A26348: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2634C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A26350: 386B0038  addi r3, r11, 0x38
	ctx.r[3].s64 = ctx.r[11].s64 + 56;
	// 82A26354: 3BC10054  addi r30, r1, 0x54
	ctx.r[30].s64 = ctx.r[1].s64 + 84;
	// 82A26358: 4B9064E9  bl 0x8232c840
	ctx.lr = 0x82A2635C;
	sub_8232C840(ctx, base);
	// 82A2635C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A26360: 4BFF9821  bl 0x82a1fb80
	ctx.lr = 0x82A26364;
	sub_82A1FB80(ctx, base);
	// 82A26364: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A26368: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2636C: 419A0008  beq cr6, 0x82a26374
	if ctx.cr[6].eq {
	pc = 0x82A26374; continue 'dispatch;
	}
	// 82A26370: 4B89A521  bl 0x822c0890
	ctx.lr = 0x82A26374;
	sub_822C0890(ctx, base);
	// 82A26374: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A26378: 483CD0B1  bl 0x82df3428
	ctx.lr = 0x82A2637C;
	sub_82DF3428(ctx, base);
	// 82A2637C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A26380: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A26384: 388B836C  addi r4, r11, -0x7c94
	ctx.r[4].s64 = ctx.r[11].s64 + -31892;
	// 82A26388: 483CD681  bl 0x82df3a08
	ctx.lr = 0x82A2638C;
	sub_82DF3A08(ctx, base);
	// 82A2638C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A26390: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A26394: 485E1D95  bl 0x83008128
	ctx.lr = 0x82A26398;
	sub_83008128(ctx, base);
	// 82A26398: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A2639C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A263A0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A263A4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A263A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A263AC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A263B0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A263B4: 484385AD  bl 0x82e5e960
	ctx.lr = 0x82A263B8;
	sub_82E5E960(ctx, base);
	// 82A263B8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A263BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A263C0: 419A0008  beq cr6, 0x82a263c8
	if ctx.cr[6].eq {
	pc = 0x82A263C8; continue 'dispatch;
	}
	// 82A263C4: 4B89A4CD  bl 0x822c0890
	ctx.lr = 0x82A263C8;
	sub_822C0890(ctx, base);
	// 82A263C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A263CC: 483CD05D  bl 0x82df3428
	ctx.lr = 0x82A263D0;
	sub_82DF3428(ctx, base);
	// 82A263D0: 480001A4  b 0x82a26574
	pc = 0x82A26574; continue 'dispatch;
	// 82A263D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A263D8: 4BDCE009  bl 0x827f43e0
	ctx.lr = 0x82A263DC;
	sub_827F43E0(ctx, base);
	// 82A263DC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A263E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A263E4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A263E8: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A263EC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A263F0: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A263F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A263F8: 4E800421  bctrl
	ctx.lr = 0x82A263FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A263FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A26400: 41820174  beq 0x82a26574
	if ctx.cr[0].eq {
	pc = 0x82A26574; continue 'dispatch;
	}
	// 82A26404: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A26408: 38800022  li r4, 0x22
	ctx.r[4].s64 = 34;
	// 82A2640C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A26410: C02B9EFC  lfs f1, -0x6104(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24836 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A26414: 4BFF3155  bl 0x82a19568
	ctx.lr = 0x82A26418;
	sub_82A19568(ctx, base);
	// 82A26418: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82A2641C: D3FF0060  stfs f31, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A26420: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A26424: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A26428: 4BFECAB9  bl 0x82a12ee0
	ctx.lr = 0x82A2642C;
	sub_82A12EE0(ctx, base);
	// 82A2642C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A26430: 4BFECB39  bl 0x82a12f68
	ctx.lr = 0x82A26434;
	sub_82A12F68(ctx, base);
	// 82A26434: 48000140  b 0x82a26574
	pc = 0x82A26574; continue 'dispatch;
	// 82A26438: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A2643C: 4BDCDFA5  bl 0x827f43e0
	ctx.lr = 0x82A26440;
	sub_827F43E0(ctx, base);
	// 82A26440: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A26444: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A26448: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2644C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A26450: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A26454: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A26458: 4E800421  bctrl
	ctx.lr = 0x82A2645C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A2645C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A26460: 41820114  beq 0x82a26574
	if ctx.cr[0].eq {
	pc = 0x82A26574; continue 'dispatch;
	}
	// 82A26464: 3880001A  li r4, 0x1a
	ctx.r[4].s64 = 26;
	// 82A26468: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A2646C: 4BFF349D  bl 0x82a19908
	ctx.lr = 0x82A26470;
	sub_82A19908(ctx, base);
	// 82A26470: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A26474: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A26478: 4BAE9051  bl 0x8250f4c8
	ctx.lr = 0x82A2647C;
	sub_8250F4C8(ctx, base);
	// 82A2647C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A26480: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A26484: 3BABFFFC  addi r29, r11, -4
	ctx.r[29].s64 = ctx.r[11].s64 + -4;
	// 82A26488: 409A0008  bne cr6, 0x82a26490
	if !ctx.cr[6].eq {
	pc = 0x82A26490; continue 'dispatch;
	}
	// 82A2648C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A26490: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A26494: 4BFED1ED  bl 0x82a13680
	ctx.lr = 0x82A26498;
	sub_82A13680(ctx, base);
	// 82A26498: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A2649C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A264A0: 4800A301  bl 0x82a307a0
	ctx.lr = 0x82A264A4;
	sub_82A307A0(ctx, base);
	// 82A264A4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A264A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A264AC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A264B0: 4BAE9069  bl 0x8250f518
	ctx.lr = 0x82A264B4;
	sub_8250F518(ctx, base);
	// 82A264B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A264B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A264BC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A264C0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A264C4: 4BAE7045  bl 0x8250d508
	ctx.lr = 0x82A264C8;
	sub_8250D508(ctx, base);
	// 82A264C8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A264CC: 483CB7C5  bl 0x82df1c90
	ctx.lr = 0x82A264D0;
	sub_82DF1C90(ctx, base);
	// 82A264D0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A264D4: 483CB7BD  bl 0x82df1c90
	ctx.lr = 0x82A264D8;
	sub_82DF1C90(ctx, base);
	// 82A264D8: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A264DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A264E0: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A264E4: 4BFEC9ED  bl 0x82a12ed0
	ctx.lr = 0x82A264E8;
	sub_82A12ED0(ctx, base);
	// 82A264E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A264EC: 4BFECA6D  bl 0x82a12f58
	ctx.lr = 0x82A264F0;
	sub_82A12F58(ctx, base);
	// 82A264F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A264F4: 4BFECAC5  bl 0x82a12fb8
	ctx.lr = 0x82A264F8;
	sub_82A12FB8(ctx, base);
	// 82A264F8: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A264FC: 481201CD  bl 0x82b466c8
	ctx.lr = 0x82A26500;
	sub_82B466C8(ctx, base);
	// 82A26500: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A26504: 807F0070  lwz r3, 0x70(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A26508: 388BAA4C  addi r4, r11, -0x55b4
	ctx.r[4].s64 = ctx.r[11].s64 + -21940;
	// 82A2650C: 48000054  b 0x82a26560
	pc = 0x82A26560; continue 'dispatch;
	// 82A26510: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A26514: 3880001B  li r4, 0x1b
	ctx.r[4].s64 = 27;
	// 82A26518: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A2651C: C02B9EFC  lfs f1, -0x6104(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24836 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A26520: 4BFF3049  bl 0x82a19568
	ctx.lr = 0x82A26524;
	sub_82A19568(ctx, base);
	// 82A26524: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A26528: 480068F9  bl 0x82a2ce20
	ctx.lr = 0x82A2652C;
	sub_82A2CE20(ctx, base);
	// 82A2652C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A26530: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A26534: 396BA9F0  addi r11, r11, -0x5610
	ctx.r[11].s64 = ctx.r[11].s64 + -22032;
	// 82A26538: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A2653C: 7C2A5C2E  lfsx f1, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A26540: 4BFF2B39  bl 0x82a19078
	ctx.lr = 0x82A26544;
	sub_82A19078(ctx, base);
	// 82A26544: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A26548: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2654C: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A26550: 4BFECA49  bl 0x82a12f98
	ctx.lr = 0x82A26554;
	sub_82A12F98(ctx, base);
	// 82A26554: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A26558: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A2655C: 388BAA38  addi r4, r11, -0x55c8
	ctx.r[4].s64 = ctx.r[11].s64 + -21960;
	// 82A26560: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A26564: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A26568: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A2656C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A26570: 4E800421  bctrl
	ctx.lr = 0x82A26574;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A26574: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A26578: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2657C: 419A0008  beq cr6, 0x82a26584
	if ctx.cr[6].eq {
	pc = 0x82A26584; continue 'dispatch;
	}
	// 82A26580: 4B89A311  bl 0x822c0890
	ctx.lr = 0x82A26584;
	sub_822C0890(ctx, base);
	// 82A26584: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A26588: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A2658C: 48781C2C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A26590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A26590 size=36
    let mut pc: u32 = 0x82A26590;
    'dispatch: loop {
        match pc {
            0x82A26590 => {
    //   block [0x82A26590..0x82A265B4)
	// 82A26590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A26594: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A26598: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2659C: 4872E065  bl 0x83154600
	ctx.lr = 0x82A265A0;
	sub_83154600(ctx, base);
	// 82A265A0: 4BFECA19  bl 0x82a12fb8
	ctx.lr = 0x82A265A4;
	sub_82A12FB8(ctx, base);
	// 82A265A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A265A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A265AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A265B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A265B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A265B8 size=136
    let mut pc: u32 = 0x82A265B8;
    'dispatch: loop {
        match pc {
            0x82A265B8 => {
    //   block [0x82A265B8..0x82A26640)
	// 82A265B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A265BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A265C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A265C4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A265C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A265CC: 4BFF7B7D  bl 0x82a1e148
	ctx.lr = 0x82A265D0;
	sub_82A1E148(ctx, base);
	// 82A265D0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A265D4: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A265D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A265DC: 3929AA94  addi r9, r9, -0x556c
	ctx.r[9].s64 = ctx.r[9].s64 + -21868;
	// 82A265E0: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A265E4: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A265E8: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A265EC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A265F0: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82A265F4: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A265F8: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82A265FC: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A26600: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82A26604: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A26608: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82A2660C: 3888A0CC  addi r4, r8, -0x5f34
	ctx.r[4].s64 = ctx.r[8].s64 + -24372;
	// 82A26610: 483CD3F9  bl 0x82df3a08
	ctx.lr = 0x82A26614;
	sub_82DF3A08(ctx, base);
	// 82A26614: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A26618: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A2661C: 484330CD  bl 0x82e596e8
	ctx.lr = 0x82A26620;
	sub_82E596E8(ctx, base);
	// 82A26620: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A26624: 483CCE05  bl 0x82df3428
	ctx.lr = 0x82A26628;
	sub_82DF3428(ctx, base);
	// 82A26628: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2662C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A26630: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A26634: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A26638: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A2663C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A26640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A26640 size=96
    let mut pc: u32 = 0x82A26640;
    'dispatch: loop {
        match pc {
            0x82A26640 => {
    //   block [0x82A26640..0x82A266A0)
	// 82A26640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A26644: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A26648: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A2664C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A26650: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A26654: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A26658: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A2665C: 807F007C  lwz r3, 0x7c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A26660: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A26664: 419A0008  beq cr6, 0x82a2666c
	if ctx.cr[6].eq {
	pc = 0x82A2666C; continue 'dispatch;
	}
	// 82A26668: 4B89A229  bl 0x822c0890
	ctx.lr = 0x82A2666C;
	sub_822C0890(ctx, base);
	// 82A2666C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A26670: 48435F19  bl 0x82e5c588
	ctx.lr = 0x82A26674;
	sub_82E5C588(ctx, base);
	// 82A26674: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A26678: 4182000C  beq 0x82a26684
	if ctx.cr[0].eq {
	pc = 0x82A26684; continue 'dispatch;
	}
	// 82A2667C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A26680: 483CBD59  bl 0x82df23d8
	ctx.lr = 0x82A26684;
	sub_82DF23D8(ctx, base);
	// 82A26684: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A26688: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A2668C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A26690: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A26694: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A26698: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A2669C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A266A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A266A0 size=260
    let mut pc: u32 = 0x82A266A0;
    'dispatch: loop {
        match pc {
            0x82A266A0 => {
    //   block [0x82A266A0..0x82A267A4)
	// 82A266A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A266A4: 48781AC9  bl 0x831a816c
	ctx.lr = 0x82A266A8;
	sub_831A8130(ctx, base);
	// 82A266A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A266AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A266B0: 4872DF51  bl 0x83154600
	ctx.lr = 0x82A266B4;
	sub_83154600(ctx, base);
	// 82A266B4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A266B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A266BC: 480075B5  bl 0x82a2dc70
	ctx.lr = 0x82A266C0;
	sub_82A2DC70(ctx, base);
	// 82A266C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A266C4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A266C8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A266CC: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82A266D0: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A266D4: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A266D8: 48006749  bl 0x82a2ce20
	ctx.lr = 0x82A266DC;
	sub_82A2CE20(ctx, base);
	// 82A266DC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A266E0: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A266E4: 396BAA5C  addi r11, r11, -0x55a4
	ctx.r[11].s64 = ctx.r[11].s64 + -21924;
	// 82A266E8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A266EC: 392B0020  addi r9, r11, 0x20
	ctx.r[9].s64 = ctx.r[11].s64 + 32;
	// 82A266F0: 390B0010  addi r8, r11, 0x10
	ctx.r[8].s64 = ctx.r[11].s64 + 16;
	// 82A266F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A266F8: 7D2A482E  lwzx r9, r10, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82A266FC: 93DF006C  stw r30, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82A26700: 913F0068  stw r9, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 82A26704: 7C0A5C2E  lfsx f0, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A26708: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82A2670C: 7C0A442E  lfsx f0, r10, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A26710: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82A26714: 4BAE8DB5  bl 0x8250f4c8
	ctx.lr = 0x82A26718;
	sub_8250F4C8(ctx, base);
	// 82A26718: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2671C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A26720: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A26724: 409A0008  bne cr6, 0x82a2672c
	if !ctx.cr[6].eq {
	pc = 0x82A2672C; continue 'dispatch;
	}
	// 82A26728: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A2672C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A26730: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A26734: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82A26738: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A2673C: 48120765  bl 0x82b46ea0
	ctx.lr = 0x82A26740;
	sub_82B46EA0(ctx, base);
	// 82A26740: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A26744: 3BFF0078  addi r31, r31, 0x78
	ctx.r[31].s64 = ctx.r[31].s64 + 120;
	// 82A26748: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A2674C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82A26750: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A26754: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A26758: 4B89DD09  bl 0x822c4460
	ctx.lr = 0x82A2675C;
	sub_822C4460(ctx, base);
	// 82A2675C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A26760: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A26764: 419A0008  beq cr6, 0x82a2676c
	if ctx.cr[6].eq {
	pc = 0x82A2676C; continue 'dispatch;
	}
	// 82A26768: 4B89A129  bl 0x822c0890
	ctx.lr = 0x82A2676C;
	sub_822C0890(ctx, base);
	// 82A2676C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A26770: 483CB521  bl 0x82df1c90
	ctx.lr = 0x82A26774;
	sub_82DF1C90(ctx, base);
	// 82A26774: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A26778: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2677C: 4BFECF05  bl 0x82a13680
	ctx.lr = 0x82A26780;
	sub_82A13680(ctx, base);
	// 82A26780: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A26784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A26788: 48120421  bl 0x82b46ba8
	ctx.lr = 0x82A2678C;
	sub_82B46BA8(ctx, base);
	// 82A2678C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A26790: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A26794: 419A0008  beq cr6, 0x82a2679c
	if ctx.cr[6].eq {
	pc = 0x82A2679C; continue 'dispatch;
	}
	// 82A26798: 4B89A0F9  bl 0x822c0890
	ctx.lr = 0x82A2679C;
	sub_822C0890(ctx, base);
	// 82A2679C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A267A0: 48781A1C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A267A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A267A8 size=812
    let mut pc: u32 = 0x82A267A8;
    'dispatch: loop {
        match pc {
            0x82A267A8 => {
    //   block [0x82A267A8..0x82A26AD4)
	// 82A267A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A267AC: 487819BD  bl 0x831a8168
	ctx.lr = 0x82A267B0;
	sub_831A8130(ctx, base);
	// 82A267B0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A267B4: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A267B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A267BC: 4872DE45  bl 0x83154600
	ctx.lr = 0x82A267C0;
	sub_83154600(ctx, base);
	// 82A267C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A267C4: 4BFEC6F5  bl 0x82a12eb8
	ctx.lr = 0x82A267C8;
	sub_82A12EB8(ctx, base);
	// 82A267C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A267CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A267D0: 48432FA9  bl 0x82e59778
	ctx.lr = 0x82A267D4;
	sub_82E59778(ctx, base);
	// 82A267D4: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A267D8: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A267DC: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A267E0: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A267E4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A267E8: 4198029C  blt cr6, 0x82a26a84
	if ctx.cr[6].lt {
	pc = 0x82A26A84; continue 'dispatch;
	}
	// 82A267EC: 419A0254  beq cr6, 0x82a26a40
	if ctx.cr[6].eq {
	pc = 0x82A26A40; continue 'dispatch;
	}
	// 82A267F0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82A267F4: 419801B0  blt cr6, 0x82a269a4
	if ctx.cr[6].lt {
	pc = 0x82A269A4; continue 'dispatch;
	}
	// 82A267F8: 419A0164  beq cr6, 0x82a2695c
	if ctx.cr[6].eq {
	pc = 0x82A2695C; continue 'dispatch;
	}
	// 82A267FC: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82A26800: 41980120  blt cr6, 0x82a26920
	if ctx.cr[6].lt {
	pc = 0x82A26920; continue 'dispatch;
	}
	// 82A26804: 409A02C4  bne cr6, 0x82a26ac8
	if !ctx.cr[6].eq {
	pc = 0x82A26AC8; continue 'dispatch;
	}
	// 82A26808: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A2680C: 4BDCDBD5  bl 0x827f43e0
	ctx.lr = 0x82A26810;
	sub_827F43E0(ctx, base);
	// 82A26810: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A26814: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A26818: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2681C: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A26820: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A26824: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A26828: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A2682C: 4E800421  bctrl
	ctx.lr = 0x82A26830;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A26830: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A26834: 41820294  beq 0x82a26ac8
	if ctx.cr[0].eq {
	pc = 0x82A26AC8; continue 'dispatch;
	}
	// 82A26838: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2683C: 4BFEC77D  bl 0x82a12fb8
	ctx.lr = 0x82A26840;
	sub_82A12FB8(ctx, base);
	// 82A26840: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A26844: 483CC8AD  bl 0x82df30f0
	ctx.lr = 0x82A26848;
	sub_82DF30F0(ctx, base);
	// 82A26848: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2684C: 4BFEC745  bl 0x82a12f90
	ctx.lr = 0x82A26850;
	sub_82A12F90(ctx, base);
	// 82A26850: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A26854: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A26858: 41820010  beq 0x82a26868
	if ctx.cr[0].eq {
	pc = 0x82A26868; continue 'dispatch;
	}
	// 82A2685C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A26860: 388B17D4  addi r4, r11, 0x17d4
	ctx.r[4].s64 = ctx.r[11].s64 + 6100;
	// 82A26864: 4800000C  b 0x82a26870
	pc = 0x82A26870; continue 'dispatch;
	// 82A26868: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A2686C: 388B893C  addi r4, r11, -0x76c4
	ctx.r[4].s64 = ctx.r[11].s64 + -30404;
	// 82A26870: 483CD009  bl 0x82df3878
	ctx.lr = 0x82A26874;
	sub_82DF3878(ctx, base);
	// 82A26874: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A26878: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A2687C: 388BA46C  addi r4, r11, -0x5b94
	ctx.r[4].s64 = ctx.r[11].s64 + -23444;
	// 82A26880: 483CD189  bl 0x82df3a08
	ctx.lr = 0x82A26884;
	sub_82DF3A08(ctx, base);
	// 82A26884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A26888: 485E18A1  bl 0x83008128
	ctx.lr = 0x82A2688C;
	sub_83008128(ctx, base);
	// 82A2688C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A26890: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A26894: 48433C8D  bl 0x82e5a520
	ctx.lr = 0x82A26898;
	sub_82E5A520(ctx, base);
	// 82A26898: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2689C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A268A0: 386B0038  addi r3, r11, 0x38
	ctx.r[3].s64 = ctx.r[11].s64 + 56;
	// 82A268A4: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82A268A8: 4B905F99  bl 0x8232c840
	ctx.lr = 0x82A268AC;
	sub_8232C840(ctx, base);
	// 82A268AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A268B0: 4BFF92D1  bl 0x82a1fb80
	ctx.lr = 0x82A268B4;
	sub_82A1FB80(ctx, base);
	// 82A268B4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A268B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A268BC: 419A0008  beq cr6, 0x82a268c4
	if ctx.cr[6].eq {
	pc = 0x82A268C4; continue 'dispatch;
	}
	// 82A268C0: 4B899FD1  bl 0x822c0890
	ctx.lr = 0x82A268C4;
	sub_822C0890(ctx, base);
	// 82A268C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A268C8: 483CCB61  bl 0x82df3428
	ctx.lr = 0x82A268CC;
	sub_82DF3428(ctx, base);
	// 82A268CC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A268D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A268D4: 388B836C  addi r4, r11, -0x7c94
	ctx.r[4].s64 = ctx.r[11].s64 + -31892;
	// 82A268D8: 483CD131  bl 0x82df3a08
	ctx.lr = 0x82A268DC;
	sub_82DF3A08(ctx, base);
	// 82A268DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A268E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A268E4: 485E1845  bl 0x83008128
	ctx.lr = 0x82A268E8;
	sub_83008128(ctx, base);
	// 82A268E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A268EC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A268F0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A268F4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A268F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A268FC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A26900: 48438061  bl 0x82e5e960
	ctx.lr = 0x82A26904;
	sub_82E5E960(ctx, base);
	// 82A26904: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A26908: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2690C: 419A0008  beq cr6, 0x82a26914
	if ctx.cr[6].eq {
	pc = 0x82A26914; continue 'dispatch;
	}
	// 82A26910: 4B899F81  bl 0x822c0890
	ctx.lr = 0x82A26914;
	sub_822C0890(ctx, base);
	// 82A26914: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A26918: 483CCB11  bl 0x82df3428
	ctx.lr = 0x82A2691C;
	sub_82DF3428(ctx, base);
	// 82A2691C: 480001AC  b 0x82a26ac8
	pc = 0x82A26AC8; continue 'dispatch;
	// 82A26920: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A26924: 4BE374CD  bl 0x8285ddf0
	ctx.lr = 0x82A26928;
	sub_8285DDF0(ctx, base);
	// 82A26928: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2692C: 41820018  beq 0x82a26944
	if ctx.cr[0].eq {
	pc = 0x82A26944; continue 'dispatch;
	}
	// 82A26930: 3880001C  li r4, 0x1c
	ctx.r[4].s64 = 28;
	// 82A26934: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A26938: 4BFF2FD1  bl 0x82a19908
	ctx.lr = 0x82A2693C;
	sub_82A19908(ctx, base);
	// 82A2693C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82A26940: 4800013C  b 0x82a26a7c
	pc = 0x82A26A7C; continue 'dispatch;
	// 82A26944: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A26948: C1BF0074  lfs f13, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A2694C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A26950: 41980178  blt cr6, 0x82a26ac8
	if ctx.cr[6].lt {
	pc = 0x82A26AC8; continue 'dispatch;
	}
	// 82A26954: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82A26958: 4800003C  b 0x82a26994
	pc = 0x82A26994; continue 'dispatch;
	// 82A2695C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A26960: 4BE37491  bl 0x8285ddf0
	ctx.lr = 0x82A26964;
	sub_8285DDF0(ctx, base);
	// 82A26964: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A26968: 4082FFC8  bne 0x82a26930
	if !ctx.cr[0].eq {
	pc = 0x82A26930; continue 'dispatch;
	}
	// 82A2696C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A26970: C1BF0060  lfs f13, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A26974: C00BFD2C  lfs f0, -0x2d4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-724 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A26978: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A2697C: 4198014C  blt cr6, 0x82a26ac8
	if ctx.cr[6].lt {
	pc = 0x82A26AC8; continue 'dispatch;
	}
	// 82A26980: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A26984: 815F0068  lwz r10, 0x68(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A26988: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A2698C: 4098FFA4  bge cr6, 0x82a26930
	if !ctx.cr[6].lt {
	pc = 0x82A26930; continue 'dispatch;
	}
	// 82A26990: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82A26994: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A26998: 915F0064  stw r10, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82A2699C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A269A0: 48000098  b 0x82a26a38
	pc = 0x82A26A38; continue 'dispatch;
	// 82A269A4: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A269A8: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A269AC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A269B0: 40980118  bge cr6, 0x82a26ac8
	if !ctx.cr[6].lt {
	pc = 0x82A26AC8; continue 'dispatch;
	}
	// 82A269B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A269B8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A269BC: 4BAE8B0D  bl 0x8250f4c8
	ctx.lr = 0x82A269C0;
	sub_8250F4C8(ctx, base);
	// 82A269C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A269C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A269C8: 3BABFFFC  addi r29, r11, -4
	ctx.r[29].s64 = ctx.r[11].s64 + -4;
	// 82A269CC: 409A0008  bne cr6, 0x82a269d4
	if !ctx.cr[6].eq {
	pc = 0x82A269D4; continue 'dispatch;
	}
	// 82A269D0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A269D4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A269D8: C03F0070  lfs f1, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A269DC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A269E0: C04BAA8C  lfs f2, -0x5574(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21876 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A269E4: 4800ACDD  bl 0x82a316c0
	ctx.lr = 0x82A269E8;
	sub_82A316C0(ctx, base);
	// 82A269E8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A269EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A269F0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A269F4: 4BAE8B25  bl 0x8250f518
	ctx.lr = 0x82A269F8;
	sub_8250F518(ctx, base);
	// 82A269F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A269FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A26A00: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A26A04: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A26A08: 4BAE6B01  bl 0x8250d508
	ctx.lr = 0x82A26A0C;
	sub_8250D508(ctx, base);
	// 82A26A0C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A26A10: 483CB281  bl 0x82df1c90
	ctx.lr = 0x82A26A14;
	sub_82DF1C90(ctx, base);
	// 82A26A14: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A26A18: 483CB279  bl 0x82df1c90
	ctx.lr = 0x82A26A1C;
	sub_82DF1C90(ctx, base);
	// 82A26A1C: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A26A20: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A26A24: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 82A26A28: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A26A2C: 913F0064  stw r9, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82A26A30: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A26A34: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A26A38: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A26A3C: 4800008C  b 0x82a26ac8
	pc = 0x82A26AC8; continue 'dispatch;
	// 82A26A40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A26A44: 4BDCD99D  bl 0x827f43e0
	ctx.lr = 0x82A26A48;
	sub_827F43E0(ctx, base);
	// 82A26A48: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A26A4C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A26A50: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A26A54: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A26A58: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A26A5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A26A60: 4E800421  bctrl
	ctx.lr = 0x82A26A64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A26A64: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A26A68: 41820060  beq 0x82a26ac8
	if ctx.cr[0].eq {
	pc = 0x82A26AC8; continue 'dispatch;
	}
	// 82A26A6C: 3880001D  li r4, 0x1d
	ctx.r[4].s64 = 29;
	// 82A26A70: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A26A74: 4BFF2E95  bl 0x82a19908
	ctx.lr = 0x82A26A78;
	sub_82A19908(ctx, base);
	// 82A26A78: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A26A7C: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A26A80: 48000048  b 0x82a26ac8
	pc = 0x82A26AC8; continue 'dispatch;
	// 82A26A84: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A26A88: 3880001E  li r4, 0x1e
	ctx.r[4].s64 = 30;
	// 82A26A8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A26A90: C02B9EFC  lfs f1, -0x6104(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24836 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A26A94: 4BFF2AD5  bl 0x82a19568
	ctx.lr = 0x82A26A98;
	sub_82A19568(ctx, base);
	// 82A26A98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A26A9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A26AA0: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A26AA4: 4BFEC4F5  bl 0x82a12f98
	ctx.lr = 0x82A26AA8;
	sub_82A12F98(ctx, base);
	// 82A26AA8: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82A26AAC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A26AB0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A26AB4: 388BAAB8  addi r4, r11, -0x5548
	ctx.r[4].s64 = ctx.r[11].s64 + -21832;
	// 82A26AB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A26ABC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A26AC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A26AC4: 4E800421  bctrl
	ctx.lr = 0x82A26AC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A26AC8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A26ACC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A26AD0: 487816E8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A26AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A26AD8 size=76
    let mut pc: u32 = 0x82A26AD8;
    'dispatch: loop {
        match pc {
            0x82A26AD8 => {
    //   block [0x82A26AD8..0x82A26B24)
	// 82A26AD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A26ADC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A26AE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A26AE4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A26AE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A26AEC: 809F0140  lwz r4, 0x140(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 82A26AF0: 4BAEB1D1  bl 0x82511cc0
	ctx.lr = 0x82A26AF4;
	sub_82511CC0(ctx, base);
	// 82A26AF4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A26AF8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A26AFC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A26B00: 915F0148  stw r10, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[10].u32 ) };
	// 82A26B04: 913F00E8  stw r9, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 82A26B08: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A26B0C: D01F0138  stfs f0, 0x138(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 82A26B10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A26B14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A26B18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A26B1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A26B20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A26B28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A26B28 size=20
    let mut pc: u32 = 0x82A26B28;
    'dispatch: loop {
        match pc {
            0x82A26B28 => {
    //   block [0x82A26B28..0x82A26B3C)
	// 82A26B28: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A26B2C: 81440018  lwz r10, 0x18(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A26B30: 816BDDB8  lwz r11, -0x2248(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8776 as u32) ) } as u64;
	// 82A26B34: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A26B38: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A26B3C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A26B3C size=16
    let mut pc: u32 = 0x82A26B3C;
    'dispatch: loop {
        match pc {
            0x82A26B3C => {
    //   block [0x82A26B3C..0x82A26B4C)
	// 82A26B3C: 81630148  lwz r11, 0x148(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(328 as u32) ) } as u64;
	// 82A26B40: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A26B44: 91630148  stw r11, 0x148(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(328 as u32), ctx.r[11].u32 ) };
	// 82A26B48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A26B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A26B50 size=196
    let mut pc: u32 = 0x82A26B50;
    'dispatch: loop {
        match pc {
            0x82A26B50 => {
    //   block [0x82A26B50..0x82A26C14)
	// 82A26B50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A26B54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A26B58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A26B5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A26B60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A26B64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A26B68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A26B6C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A26B70: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A26B74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A26B78: 4B899DC1  bl 0x822c0938
	ctx.lr = 0x82A26B7C;
	sub_822C0938(ctx, base);
	// 82A26B7C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A26B80: 41820028  beq 0x82a26ba8
	if ctx.cr[0].eq {
	pc = 0x82A26BA8; continue 'dispatch;
	}
	// 82A26B84: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A26B88: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A26B8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A26B90: 392BAB20  addi r9, r11, -0x54e0
	ctx.r[9].s64 = ctx.r[11].s64 + -21728;
	// 82A26B94: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A26B98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A26B9C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A26BA0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A26BA4: 48000008  b 0x82a26bac
	pc = 0x82A26BAC; continue 'dispatch;
	// 82A26BA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A26BAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A26BB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A26BB4: 409A0044  bne cr6, 0x82a26bf8
	if !ctx.cr[6].eq {
	pc = 0x82A26BF8; continue 'dispatch;
	}
	// 82A26BB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A26BBC: 419A001C  beq cr6, 0x82a26bd8
	if ctx.cr[6].eq {
	pc = 0x82A26BD8; continue 'dispatch;
	}
	// 82A26BC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A26BC4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A26BC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A26BCC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A26BD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A26BD4: 4E800421  bctrl
	ctx.lr = 0x82A26BD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A26BD8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A26BDC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A26BE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A26BE4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A26BE8: 816B1270  lwz r11, 0x1270(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4720 as u32) ) } as u64;
	// 82A26BEC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A26BF0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A26BF4: 4B89940D  bl 0x822c0000
	ctx.lr = 0x82A26BF8;
	sub_822C0000(ctx, base);
	// 82A26BF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A26BFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A26C00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A26C04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A26C08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A26C0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A26C10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A26C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A26C18 size=252
    let mut pc: u32 = 0x82A26C18;
    'dispatch: loop {
        match pc {
            0x82A26C18 => {
    //   block [0x82A26C18..0x82A26D14)
	// 82A26C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A26C1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A26C20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A26C24: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82A26C28: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A26C2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A26C30: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82A26C34: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A26C38: 38AABA80  addi r5, r10, -0x4580
	ctx.r[5].s64 = ctx.r[10].s64 + -17792;
	// 82A26C3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A26C40: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A26C44: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A26C48: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A26C4C: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82A26C50: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82A26C54: 4BAEB60D  bl 0x82512260
	ctx.lr = 0x82A26C58;
	sub_82512260(ctx, base);
	// 82A26C58: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82A26C5C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A26C60: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A26C64: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A26C68: 38EBA214  addi r7, r11, -0x5dec
	ctx.r[7].s64 = ctx.r[11].s64 + -24044;
	// 82A26C6C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A26C70: 394AAB94  addi r10, r10, -0x546c
	ctx.r[10].s64 = ctx.r[10].s64 + -21612;
	// 82A26C74: 90FF00E4  stw r7, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[7].u32 ) };
	// 82A26C78: 3929AB80  addi r9, r9, -0x5480
	ctx.r[9].s64 = ctx.r[9].s64 + -21632;
	// 82A26C7C: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82A26C80: 3908AB34  addi r8, r8, -0x54cc
	ctx.r[8].s64 = ctx.r[8].s64 + -21708;
	// 82A26C84: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A26C88: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82A26C8C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A26C90: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 82A26C94: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A26C98: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 82A26C9C: D3FF0120  stfs f31, 0x120(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82A26CA0: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 82A26CA4: D3FF0124  stfs f31, 0x124(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82A26CA8: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 82A26CAC: D3FF012C  stfs f31, 0x12c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82A26CB0: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 82A26CB4: C00A9534  lfs f0, -0x6acc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A26CB8: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 82A26CBC: D01F0128  stfs f0, 0x128(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82A26CC0: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 82A26CC4: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A26CC8: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 82A26CCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A26CD0: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 82A26CD4: 917F010C  stw r11, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 82A26CD8: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82A26CDC: D01F0130  stfs f0, 0x130(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 82A26CE0: D01F0134  stfs f0, 0x134(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 82A26CE4: 917F013C  stw r11, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[11].u32 ) };
	// 82A26CE8: D3FF0138  stfs f31, 0x138(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 82A26CEC: 917F0140  stw r11, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 82A26CF0: 917F0144  stw r11, 0x144(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), ctx.r[11].u32 ) };
	// 82A26CF4: 917F0148  stw r11, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[11].u32 ) };
	// 82A26CF8: 997F014C  stb r11, 0x14c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[11].u8 ) };
	// 82A26CFC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A26D00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A26D04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A26D08: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A26D0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A26D10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A26D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A26D18 size=8
    let mut pc: u32 = 0x82A26D18;
    'dispatch: loop {
        match pc {
            0x82A26D18 => {
    //   block [0x82A26D18..0x82A26D20)
	// 82A26D18: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82A26D1C: 4800022C  b 0x82a26f48
	sub_82A26F48(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A26D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A26D20 size=8
    let mut pc: u32 = 0x82A26D20;
    'dispatch: loop {
        match pc {
            0x82A26D20 => {
    //   block [0x82A26D20..0x82A26D28)
	// 82A26D20: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 82A26D24: 48000224  b 0x82a26f48
	sub_82A26F48(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A26D28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A26D28 size=184
    let mut pc: u32 = 0x82A26D28;
    'dispatch: loop {
        match pc {
            0x82A26D28 => {
    //   block [0x82A26D28..0x82A26DE0)
	// 82A26D28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A26D2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A26D30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A26D34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A26D38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A26D3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A26D40: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A26D44: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A26D48: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A26D4C: 396BAB94  addi r11, r11, -0x546c
	ctx.r[11].s64 = ctx.r[11].s64 + -21612;
	// 82A26D50: 394AAB80  addi r10, r10, -0x5480
	ctx.r[10].s64 = ctx.r[10].s64 + -21632;
	// 82A26D54: 3929AB34  addi r9, r9, -0x54cc
	ctx.r[9].s64 = ctx.r[9].s64 + -21708;
	// 82A26D58: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A26D5C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82A26D60: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 82A26D64: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 82A26D68: 807F0110  lwz r3, 0x110(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82A26D6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A26D70: 419A0008  beq cr6, 0x82a26d78
	if ctx.cr[6].eq {
	pc = 0x82A26D78; continue 'dispatch;
	}
	// 82A26D74: 4B899B1D  bl 0x822c0890
	ctx.lr = 0x82A26D78;
	sub_822C0890(ctx, base);
	// 82A26D78: 807F0108  lwz r3, 0x108(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 82A26D7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A26D80: 419A0008  beq cr6, 0x82a26d88
	if ctx.cr[6].eq {
	pc = 0x82A26D88; continue 'dispatch;
	}
	// 82A26D84: 4B899B0D  bl 0x822c0890
	ctx.lr = 0x82A26D88;
	sub_822C0890(ctx, base);
	// 82A26D88: 807F0100  lwz r3, 0x100(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 82A26D8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A26D90: 419A0008  beq cr6, 0x82a26d98
	if ctx.cr[6].eq {
	pc = 0x82A26D98; continue 'dispatch;
	}
	// 82A26D94: 4B899AFD  bl 0x822c0890
	ctx.lr = 0x82A26D98;
	sub_822C0890(ctx, base);
	// 82A26D98: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82A26D9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A26DA0: 419A0008  beq cr6, 0x82a26da8
	if ctx.cr[6].eq {
	pc = 0x82A26DA8; continue 'dispatch;
	}
	// 82A26DA4: 4B899AED  bl 0x822c0890
	ctx.lr = 0x82A26DA8;
	sub_822C0890(ctx, base);
	// 82A26DA8: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82A26DAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A26DB0: 419A0008  beq cr6, 0x82a26db8
	if ctx.cr[6].eq {
	pc = 0x82A26DB8; continue 'dispatch;
	}
	// 82A26DB4: 4B899ADD  bl 0x822c0890
	ctx.lr = 0x82A26DB8;
	sub_822C0890(ctx, base);
	// 82A26DB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A26DBC: 4BD8089D  bl 0x827a7658
	ctx.lr = 0x82A26DC0;
	sub_827A7658(ctx, base);
	// 82A26DC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A26DC4: 4B92858D  bl 0x8234f350
	ctx.lr = 0x82A26DC8;
	sub_8234F350(ctx, base);
	// 82A26DC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A26DCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A26DD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A26DD4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A26DD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A26DDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A26DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A26DE0 size=136
    let mut pc: u32 = 0x82A26DE0;
    'dispatch: loop {
        match pc {
            0x82A26DE0 => {
    //   block [0x82A26DE0..0x82A26E68)
	// 82A26DE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A26DE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A26DE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A26DEC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A26DF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A26DF4: 817F0144  lwz r11, 0x144(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 82A26DF8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A26DFC: 409A000C  bne cr6, 0x82a26e08
	if !ctx.cr[6].eq {
	pc = 0x82A26E08; continue 'dispatch;
	}
	// 82A26E00: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A26E04: 48000050  b 0x82a26e54
	pc = 0x82A26E54; continue 'dispatch;
	// 82A26E08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A26E0C: 48006E65  bl 0x82a2dc70
	ctx.lr = 0x82A26E10;
	sub_82A2DC70(ctx, base);
	// 82A26E10: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A26E14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A26E18: 419A0028  beq cr6, 0x82a26e40
	if ctx.cr[6].eq {
	pc = 0x82A26E40; continue 'dispatch;
	}
	// 82A26E1C: 4BFEC77D  bl 0x82a13598
	ctx.lr = 0x82A26E20;
	sub_82A13598(ctx, base);
	// 82A26E20: 817F0144  lwz r11, 0x144(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 82A26E24: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82A26E28: 409A0018  bne cr6, 0x82a26e40
	if !ctx.cr[6].eq {
	pc = 0x82A26E40; continue 'dispatch;
	}
	// 82A26E2C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A26E30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A26E34: 419AFFCC  beq cr6, 0x82a26e00
	if ctx.cr[6].eq {
	pc = 0x82A26E00; continue 'dispatch;
	}
	// 82A26E38: 4B899A59  bl 0x822c0890
	ctx.lr = 0x82A26E3C;
	sub_822C0890(ctx, base);
	// 82A26E3C: 4BFFFFC4  b 0x82a26e00
	pc = 0x82A26E00; continue 'dispatch;
	// 82A26E40: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A26E44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A26E48: 419A0008  beq cr6, 0x82a26e50
	if ctx.cr[6].eq {
	pc = 0x82A26E50; continue 'dispatch;
	}
	// 82A26E4C: 4B899A45  bl 0x822c0890
	ctx.lr = 0x82A26E50;
	sub_822C0890(ctx, base);
	// 82A26E50: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A26E54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A26E58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A26E5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A26E60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A26E64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A26E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A26E68 size=220
    let mut pc: u32 = 0x82A26E68;
    'dispatch: loop {
        match pc {
            0x82A26E68 => {
    //   block [0x82A26E68..0x82A26F44)
	// 82A26E68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A26E6C: 487812FD  bl 0x831a8168
	ctx.lr = 0x82A26E70;
	sub_831A8130(ctx, base);
	// 82A26E70: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A26E74: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A26E78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A26E7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A26E80: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A26E84: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A26E88: 4BAE8691  bl 0x8250f518
	ctx.lr = 0x82A26E8C;
	sub_8250F518(ctx, base);
	// 82A26E8C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A26E90: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A26E94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A26E98: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 82A26E9C: 409A0008  bne cr6, 0x82a26ea4
	if !ctx.cr[6].eq {
	pc = 0x82A26EA4; continue 'dispatch;
	}
	// 82A26EA0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A26EA4: 4BB016DD  bl 0x82528580
	ctx.lr = 0x82A26EA8;
	sub_82528580(ctx, base);
	// 82A26EA8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A26EAC: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82A26EB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A26EB4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A26F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A26F48 size=76
    let mut pc: u32 = 0x82A26F48;
    'dispatch: loop {
        match pc {
            0x82A26F48 => {
    //   block [0x82A26F48..0x82A26F94)
	// 82A26F48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A26F4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A26F50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A26F54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A26F58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A26F5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A26F60: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A26F64: 4BFFFDC5  bl 0x82a26d28
	ctx.lr = 0x82A26F68;
	sub_82A26D28(ctx, base);
	// 82A26F68: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A26F6C: 4182000C  beq 0x82a26f78
	if ctx.cr[0].eq {
	pc = 0x82A26F78; continue 'dispatch;
	}
	// 82A26F70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A26F74: 483CB465  bl 0x82df23d8
	ctx.lr = 0x82A26F78;
	sub_82DF23D8(ctx, base);
	// 82A26F78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A26F7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A26F80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A26F84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A26F88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A26F8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A26F90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A26F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A26F98 size=316
    let mut pc: u32 = 0x82A26F98;
    'dispatch: loop {
        match pc {
            0x82A26F98 => {
    //   block [0x82A26F98..0x82A270D4)
	// 82A26F98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A26F9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A26FA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A26FA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A26FA8: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 82A26FAC: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82A26FB0: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A26FB4: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A26FB8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A26FBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A26FC0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A26FC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A26FC8: 388BAC00  addi r4, r11, -0x5400
	ctx.r[4].s64 = ctx.r[11].s64 + -21504;
	// 82A26FCC: 483CCA3D  bl 0x82df3a08
	ctx.lr = 0x82A26FD0;
	sub_82DF3A08(ctx, base);
	// 82A26FD0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A26FD4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A26FD8: 388BABF4  addi r4, r11, -0x540c
	ctx.r[4].s64 = ctx.r[11].s64 + -21516;
	// 82A26FDC: 483CCA2D  bl 0x82df3a08
	ctx.lr = 0x82A26FE0;
	sub_82DF3A08(ctx, base);
	// 82A26FE0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A26FE4: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82A26FE8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A26FEC: 38BF004C  addi r5, r31, 0x4c
	ctx.r[5].s64 = ctx.r[31].s64 + 76;
	// 82A26FF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A26FF4: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A26FF8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A26FFC: C3CA6218  lfs f30, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A27000: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A27004: C3A908A4  lfs f29, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82A27008: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82A2700C: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82A27010: 4BB7C299  bl 0x825a32a8
	ctx.lr = 0x82A27014;
	sub_825A32A8(ctx, base);
	// 82A27014: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A27018: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2701C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A27020: 4BB7A751  bl 0x825a1770
	ctx.lr = 0x82A27024;
	sub_825A1770(ctx, base);
	// 82A27024: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82A27028: 483CC401  bl 0x82df3428
	ctx.lr = 0x82A2702C;
	sub_82DF3428(ctx, base);
	// 82A2702C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A27030: 4B8A1C89  bl 0x822c8cb8
	ctx.lr = 0x82A27034;
	sub_822C8CB8(ctx, base);
	// 82A27034: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A27038: 483CC3F1  bl 0x82df3428
	ctx.lr = 0x82A2703C;
	sub_82DF3428(ctx, base);
	// 82A2703C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A27040: 483CC3E9  bl 0x82df3428
	ctx.lr = 0x82A27044;
	sub_82DF3428(ctx, base);
	// 82A27044: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A27048: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A2704C: 388BABE4  addi r4, r11, -0x541c
	ctx.r[4].s64 = ctx.r[11].s64 + -21532;
	// 82A27050: 483CC9B9  bl 0x82df3a08
	ctx.lr = 0x82A27054;
	sub_82DF3A08(ctx, base);
	// 82A27054: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A27058: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2705C: 388BABD4  addi r4, r11, -0x542c
	ctx.r[4].s64 = ctx.r[11].s64 + -21548;
	// 82A27060: 483CC9A9  bl 0x82df3a08
	ctx.lr = 0x82A27064;
	sub_82DF3A08(ctx, base);
	// 82A27064: 38BF0050  addi r5, r31, 0x50
	ctx.r[5].s64 = ctx.r[31].s64 + 80;
	// 82A27068: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A2706C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A27070: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A27074: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82A27078: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82A2707C: 4BB7C22D  bl 0x825a32a8
	ctx.lr = 0x82A27080;
	sub_825A32A8(ctx, base);
	// 82A27080: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A27084: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A27088: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2708C: 4BB7A6E5  bl 0x825a1770
	ctx.lr = 0x82A27090;
	sub_825A1770(ctx, base);
	// 82A27090: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82A27094: 483CC395  bl 0x82df3428
	ctx.lr = 0x82A27098;
	sub_82DF3428(ctx, base);
	// 82A27098: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82A2709C: 4B8A1C1D  bl 0x822c8cb8
	ctx.lr = 0x82A270A0;
	sub_822C8CB8(ctx, base);
	// 82A270A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A270A4: 483CC385  bl 0x82df3428
	ctx.lr = 0x82A270A8;
	sub_82DF3428(ctx, base);
	// 82A270A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A270AC: 483CC37D  bl 0x82df3428
	ctx.lr = 0x82A270B0;
	sub_82DF3428(ctx, base);
	// 82A270B0: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82A270B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A270B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A270BC: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A270C0: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A270C4: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A270C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A270CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A270D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A270D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A270D8 size=408
    let mut pc: u32 = 0x82A270D8;
    'dispatch: loop {
        match pc {
            0x82A270D8 => {
    //   block [0x82A270D8..0x82A27270)
	// 82A270D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A270DC: 4878108D  bl 0x831a8168
	ctx.lr = 0x82A270E0;
	sub_831A8130(ctx, base);
	// 82A270E0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A270E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A270E8: 80840000  lwz r4, 0(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A270EC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A270F0: 484039F9  bl 0x82e2aae8
	ctx.lr = 0x82A270F4;
	sub_82E2AAE8(ctx, base);
	// 82A270F4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A270F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A270FC: 808B1268  lwz r4, 0x1268(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4712 as u32) ) } as u64;
	// 82A27100: 483CC909  bl 0x82df3a08
	ctx.lr = 0x82A27104;
	sub_82DF3A08(ctx, base);
	// 82A27104: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A27108: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A2710C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82A27110: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A27114: 48407D5D  bl 0x82e2ee70
	ctx.lr = 0x82A27118;
	sub_82E2EE70(ctx, base);
	// 82A27118: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2711C: 483CC30D  bl 0x82df3428
	ctx.lr = 0x82A27120;
	sub_82DF3428(ctx, base);
	// 82A27120: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A27124: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A27128: 3BABAC30  addi r29, r11, -0x53d0
	ctx.r[29].s64 = ctx.r[11].s64 + -21456;
	// 82A2712C: 38A000AB  li r5, 0xab
	ctx.r[5].s64 = 171;
	// 82A27130: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A27134: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82A27138: 483CB2B1  bl 0x82df23e8
	ctx.lr = 0x82A2713C;
	sub_82DF23E8(ctx, base);
	// 82A2713C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A27140: 41820014  beq 0x82a27154
	if ctx.cr[0].eq {
	pc = 0x82A27154; continue 'dispatch;
	}
	// 82A27144: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A27148: 483EF749  bl 0x82e16890
	ctx.lr = 0x82A2714C;
	sub_82E16890(ctx, base);
	// 82A2714C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A27150: 48000008  b 0x82a27158
	pc = 0x82A27158; continue 'dispatch;
	// 82A27154: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A27158: 3BDF00EC  addi r30, r31, 0xec
	ctx.r[30].s64 = ctx.r[31].s64 + 236;
	// 82A2715C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A27160: 4B936211  bl 0x8235d370
	ctx.lr = 0x82A27164;
	sub_8235D370(ctx, base);
	// 82A27164: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A27168: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2716C: 839F00EC  lwz r28, 0xec(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A27170: 4BAEAFA9  bl 0x82512118
	ctx.lr = 0x82A27174;
	sub_82512118(ctx, base);
	// 82A27174: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A27178: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A2717C: 483EDF35  bl 0x82e150b0
	ctx.lr = 0x82A27180;
	sub_82E150B0(ctx, base);
	// 82A27180: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A27184: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A27188: 388BAC10  addi r4, r11, -0x53f0
	ctx.r[4].s64 = ctx.r[11].s64 + -21488;
	// 82A2718C: 483CC87D  bl 0x82df3a08
	ctx.lr = 0x82A27190;
	sub_82DF3A08(ctx, base);
	// 82A27190: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A27194: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A27198: 809F00EC  lwz r4, 0xec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A2719C: 483EDE95  bl 0x82e15030
	ctx.lr = 0x82A271A0;
	sub_82E15030(ctx, base);
	// 82A271A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A271A4: 483CC285  bl 0x82df3428
	ctx.lr = 0x82A271A8;
	sub_82DF3428(ctx, base);
	// 82A271A8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A271AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A271B0: 419A0078  beq cr6, 0x82a27228
	if ctx.cr[6].eq {
	pc = 0x82A27228; continue 'dispatch;
	}
	// 82A271B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A271B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A271BC: 38A000B1  li r5, 0xb1
	ctx.r[5].s64 = 177;
	// 82A271C0: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82A271C4: 483CB225  bl 0x82df23e8
	ctx.lr = 0x82A271C8;
	sub_82DF23E8(ctx, base);
	// 82A271C8: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A271CC: 41820044  beq 0x82a27210
	if ctx.cr[0].eq {
	pc = 0x82A27210; continue 'dispatch;
	}
	// 82A271D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A271D4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A271D8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A271DC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A271E0: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A271E4: C1AA9524  lfs f13, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A271E8: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82A271EC: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82A271F0: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82A271F4: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82A271F8: 48454DE1  bl 0x82e7bfd8
	ctx.lr = 0x82A271FC;
	sub_82E7BFD8(ctx, base);
	// 82A271FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A27200: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A27204: 483EBEED  bl 0x82e130f0
	ctx.lr = 0x82A27208;
	sub_82E130F0(ctx, base);
	// 82A27208: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A2720C: 48000008  b 0x82a27214
	pc = 0x82A27214; continue 'dispatch;
	// 82A27210: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A27214: 387F010C  addi r3, r31, 0x10c
	ctx.r[3].s64 = ctx.r[31].s64 + 268;
	// 82A27218: 4B8BAB39  bl 0x822e1d50
	ctx.lr = 0x82A2721C;
	sub_822E1D50(ctx, base);
	// 82A2721C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A27220: 809F010C  lwz r4, 0x10c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 82A27224: 483EBC0D  bl 0x82e12e30
	ctx.lr = 0x82A27228;
	sub_82E12E30(ctx, base);
	// 82A27228: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A2722C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A27230: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A27234: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A27238: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A2723C: 4BAE991D  bl 0x82510b58
	ctx.lr = 0x82A27240;
	sub_82510B58(ctx, base);
	// 82A27240: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A27244: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A27248: 419A0008  beq cr6, 0x82a27250
	if ctx.cr[6].eq {
	pc = 0x82A27250; continue 'dispatch;
	}
	// 82A2724C: 4B899645  bl 0x822c0890
	ctx.lr = 0x82A27250;
	sub_822C0890(ctx, base);
	// 82A27250: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A27254: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A27258: 419A0008  beq cr6, 0x82a27260
	if ctx.cr[6].eq {
	pc = 0x82A27260; continue 'dispatch;
	}
	// 82A2725C: 4B899635  bl 0x822c0890
	ctx.lr = 0x82A27260;
	sub_822C0890(ctx, base);
	// 82A27260: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A27264: 4840389D  bl 0x82e2ab00
	ctx.lr = 0x82A27268;
	sub_82E2AB00(ctx, base);
	// 82A27268: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82A2726C: 48780F4C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A27270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A27270 size=280
    let mut pc: u32 = 0x82A27270;
    'dispatch: loop {
        match pc {
            0x82A27270 => {
    //   block [0x82A27270..0x82A27388)
	// 82A27270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A27274: 48780EF5  bl 0x831a8168
	ctx.lr = 0x82A27278;
	sub_831A8130(ctx, base);
	// 82A27278: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2727C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A27280: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A27284: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A27288: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A2728C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A27290: 388BAC30  addi r4, r11, -0x53d0
	ctx.r[4].s64 = ctx.r[11].s64 + -21456;
	// 82A27294: 38A000BC  li r5, 0xbc
	ctx.r[5].s64 = 188;
	// 82A27298: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 82A2729C: 483CB14D  bl 0x82df23e8
	ctx.lr = 0x82A272A0;
	sub_82DF23E8(ctx, base);
	// 82A272A0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A272A4: 41820040  beq 0x82a272e4
	if ctx.cr[0].eq {
	pc = 0x82A272E4; continue 'dispatch;
	}
	// 82A272A8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A272AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A272B0: 808B126C  lwz r4, 0x126c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4716 as u32) ) } as u64;
	// 82A272B4: 483CC755  bl 0x82df3a08
	ctx.lr = 0x82A272B8;
	sub_82DF3A08(ctx, base);
	// 82A272B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A272BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A272C0: 3BE00003  li r31, 3
	ctx.r[31].s64 = 3;
	// 82A272C4: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 82A272C8: 4BAE8201  bl 0x8250f4c8
	ctx.lr = 0x82A272CC;
	sub_8250F4C8(ctx, base);
	// 82A272CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A272D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A272D4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A272D8: 4818C929  bl 0x82bb3c00
	ctx.lr = 0x82A272DC;
	sub_82BB3C00(ctx, base);
	// 82A272DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A272E0: 48000008  b 0x82a272e8
	pc = 0x82A272E8; continue 'dispatch;
	// 82A272E4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A272E8: 3BDD00F4  addi r30, r29, 0xf4
	ctx.r[30].s64 = ctx.r[29].s64 + 244;
	// 82A272EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A272F0: 4B9360F1  bl 0x8235d3e0
	ctx.lr = 0x82A272F4;
	sub_8235D3E0(ctx, base);
	// 82A272F4: 57EB07BD  rlwinm. r11, r31, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A272F8: 41820010  beq 0x82a27308
	if ctx.cr[0].eq {
	pc = 0x82A27308; continue 'dispatch;
	}
	// 82A272FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A27300: 57FF07FA  rlwinm r31, r31, 0, 0x1f, 0x1d
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 82A27304: 483CA98D  bl 0x82df1c90
	ctx.lr = 0x82A27308;
	sub_82DF1C90(ctx, base);
	// 82A27308: 57EB07FF  clrlwi. r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2730C: 4182000C  beq 0x82a27318
	if ctx.cr[0].eq {
	pc = 0x82A27318; continue 'dispatch;
	}
	// 82A27310: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A27314: 483CC115  bl 0x82df3428
	ctx.lr = 0x82A27318;
	sub_82DF3428(ctx, base);
	// 82A27318: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A2731C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A27320: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82A27324: 388B1278  addi r4, r11, 0x1278
	ctx.r[4].s64 = ctx.r[11].s64 + 4728;
	// 82A27328: 4818DC39  bl 0x82bb4f60
	ctx.lr = 0x82A2732C;
	sub_82BB4F60(ctx, base);
	// 82A2732C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A27330: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A27334: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A27338: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A2733C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A27340: 419A0024  beq cr6, 0x82a27364
	if ctx.cr[6].eq {
	pc = 0x82A27364; continue 'dispatch;
	}
	// 82A27344: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A27348: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A2734C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A27350: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A27354: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A27358: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A2735C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A27360: 4082FFE8  bne 0x82a27348
	if !ctx.cr[0].eq {
	pc = 0x82A27348; continue 'dispatch;
	}
	// 82A27364: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A27368: 807D00EC  lwz r3, 0xec(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A2736C: 483EDC05  bl 0x82e14f70
	ctx.lr = 0x82A27370;
	sub_82E14F70(ctx, base);
	// 82A27370: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A27374: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A27378: 419A0008  beq cr6, 0x82a27380
	if ctx.cr[6].eq {
	pc = 0x82A27380; continue 'dispatch;
	}
	// 82A2737C: 4B899515  bl 0x822c0890
	ctx.lr = 0x82A27380;
	sub_822C0890(ctx, base);
	// 82A27380: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A27384: 48780E34  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A27388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A27388 size=908
    let mut pc: u32 = 0x82A27388;
    'dispatch: loop {
        match pc {
            0x82A27388 => {
    //   block [0x82A27388..0x82A27714)
	// 82A27388: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2738C: 48780DD9  bl 0x831a8164
	ctx.lr = 0x82A27390;
	sub_831A8130(ctx, base);
	// 82A27390: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A27394: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A27398: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82A2739C: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A273A0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A273A4: 817B0018  lwz r11, 0x18(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A273A8: 814ADDB4  lwz r10, -0x224c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8780 as u32) ) } as u64;
	// 82A273AC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A273B0: 409A033C  bne cr6, 0x82a276ec
	if !ctx.cr[6].eq {
	pc = 0x82A276EC; continue 'dispatch;
	}
	// 82A273B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A273B8: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 82A273BC: 396BA2F0  addi r11, r11, -0x5d10
	ctx.r[11].s64 = ctx.r[11].s64 + -23824;
	// 82A273C0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A27718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A27718 size=164
    let mut pc: u32 = 0x82A27718;
    'dispatch: loop {
        match pc {
            0x82A27718 => {
    //   block [0x82A27718..0x82A277BC)
	// 82A27718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2771C: 48780A4D  bl 0x831a8168
	ctx.lr = 0x82A27720;
	sub_831A8130(ctx, base);
	// 82A27720: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A27724: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A27728: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A2772C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A27730: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82A27734: 41820038  beq 0x82a2776c
	if ctx.cr[0].eq {
	pc = 0x82A2776C; continue 'dispatch;
	}
	// 82A27738: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2773C: 4878224D  bl 0x831a9988
	ctx.lr = 0x82A27740;
	sub_831A9988(ctx, base);
	// 82A27740: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A27744: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A27748: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 82A2774C: 487809AD  bl 0x831a80f8
	ctx.lr = 0x82A27750;
	sub_831A80F8(ctx, base);
	// 82A27750: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A27754: 41820018  beq 0x82a2776c
	if ctx.cr[0].eq {
	pc = 0x82A2776C; continue 'dispatch;
	}
	// 82A27758: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2775C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A27760: 4BFFFC29  bl 0x82a27388
	ctx.lr = 0x82A27764;
	sub_82A27388(ctx, base);
	// 82A27764: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A27768: 4800004C  b 0x82a277b4
	pc = 0x82A277B4; continue 'dispatch;
	// 82A2776C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A27770: 419A0034  beq cr6, 0x82a277a4
	if ctx.cr[6].eq {
	pc = 0x82A277A4; continue 'dispatch;
	}
	// 82A27774: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A27778: 48782211  bl 0x831a9988
	ctx.lr = 0x82A2777C;
	sub_831A9988(ctx, base);
	// 82A2777C: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82A27780: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A27784: 386B0B88  addi r3, r11, 0xb88
	ctx.r[3].s64 = ctx.r[11].s64 + 2952;
	// 82A27788: 48780971  bl 0x831a80f8
	ctx.lr = 0x82A2778C;
	sub_831A80F8(ctx, base);
	// 82A2778C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A27790: 41820014  beq 0x82a277a4
	if ctx.cr[0].eq {
	pc = 0x82A277A4; continue 'dispatch;
	}
	// 82A27794: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A27798: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A2779C: 4BFFF38D  bl 0x82a26b28
	ctx.lr = 0x82A277A0;
	sub_82A26B28(ctx, base);
	// 82A277A0: 4BFFFFC4  b 0x82a27764
	pc = 0x82A27764; continue 'dispatch;
	// 82A277A4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A277A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A277AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A277B0: 4BAEAE69  bl 0x82512618
	ctx.lr = 0x82A277B4;
	sub_82512618(ctx, base);
	// 82A277B4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A277B8: 48780A00  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A277C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A277C0 size=508
    let mut pc: u32 = 0x82A277C0;
    'dispatch: loop {
        match pc {
            0x82A277C0 => {
    //   block [0x82A277C0..0x82A279BC)
	// 82A277C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A277C4: 487809A1  bl 0x831a8164
	ctx.lr = 0x82A277C8;
	sub_831A8130(ctx, base);
	// 82A277C8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A277CC: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A277D0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A277D4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A277D8: 3BCBAC30  addi r30, r11, -0x53d0
	ctx.r[30].s64 = ctx.r[11].s64 + -21456;
	// 82A277DC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A277E0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A277E4: 38A00052  li r5, 0x52
	ctx.r[5].s64 = 82;
	// 82A277E8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82A277EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A277F0: 38600150  li r3, 0x150
	ctx.r[3].s64 = 336;
	// 82A277F4: 483CABF5  bl 0x82df23e8
	ctx.lr = 0x82A277F8;
	sub_82DF23E8(ctx, base);
	// 82A277F8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A277FC: 41820010  beq 0x82a2780c
	if ctx.cr[0].eq {
	pc = 0x82A2780C; continue 'dispatch;
	}
	// 82A27800: 4BFFF419  bl 0x82a26c18
	ctx.lr = 0x82A27804;
	sub_82A26C18(ctx, base);
	// 82A27804: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A27808: 48000008  b 0x82a27810
	pc = 0x82A27810; continue 'dispatch;
	// 82A2780C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A27810: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A27814: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A27818: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A2781C: 4BFFF335  bl 0x82a26b50
	ctx.lr = 0x82A27820;
	sub_82A26B50(ctx, base);
	// 82A27820: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A27824: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A27828: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A2782C: 4B8987D5  bl 0x822c0000
	ctx.lr = 0x82A27830;
	sub_822C0000(ctx, base);
	// 82A27830: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A27834: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A27838: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 82A2783C: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82A27840: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A27844: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A27848: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82A2784C: C00A08A8  lfs f0, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A27850: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82A27854: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82A27858: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82A2785C: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82A27860: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82A27864: D3E10094  stfs f31, 0x94(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82A27868: D3E10098  stfs f31, 0x98(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82A2786C: D3E1009C  stfs f31, 0x9c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82A27870: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82A27874: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82A27878: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82A2787C: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82A27880: 484558F9  bl 0x82e7d178
	ctx.lr = 0x82A27884;
	sub_82E7D178(ctx, base);
	// 82A27884: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A27888: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A2788C: 38A00059  li r5, 0x59
	ctx.r[5].s64 = 89;
	// 82A27890: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82A27894: 4B898B45  bl 0x822c03d8
	ctx.lr = 0x82A27898;
	sub_822C03D8(ctx, base);
	// 82A27898: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A2789C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A278A0: 418200AC  beq 0x82a2794c
	if ctx.cr[0].eq {
	pc = 0x82A2794C; continue 'dispatch;
	}
	// 82A278A4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A278A8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82A278AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A278B0: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 82A278B4: 409A0008  bne cr6, 0x82a278bc
	if !ctx.cr[6].eq {
	pc = 0x82A278BC; continue 'dispatch;
	}
	// 82A278B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A278BC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A278C0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A278C4: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82A278C8: 419A0024  beq cr6, 0x82a278ec
	if ctx.cr[6].eq {
	pc = 0x82A278EC; continue 'dispatch;
	}
	// 82A278CC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82A278D0: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82A278D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A278D8: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82A278DC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A278E0: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A278E4: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A278E8: 4082FFE8  bne 0x82a278d0
	if !ctx.cr[0].eq {
	pc = 0x82A278D0; continue 'dispatch;
	}
	// 82A278EC: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82A278F0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A278F4: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82A278F8: 419A0024  beq cr6, 0x82a2791c
	if ctx.cr[6].eq {
	pc = 0x82A2791C; continue 'dispatch;
	}
	// 82A278FC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82A27900: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A27904: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A27908: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A2790C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A27910: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A27914: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A27918: 4082FFE8  bne 0x82a27900
	if !ctx.cr[0].eq {
	pc = 0x82A27900; continue 'dispatch;
	}
	// 82A2791C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82A27920: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A27924: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 82A27928: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A2792C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A27930: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A27934: 4BD715FD  bl 0x82798f30
	ctx.lr = 0x82A27938;
	sub_82798F30(ctx, base);
	// 82A27938: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A2793C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A27940: 4BD73D29  bl 0x8279b668
	ctx.lr = 0x82A27944;
	sub_8279B668(ctx, base);
	// 82A27944: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A27948: 48000008  b 0x82a27950
	pc = 0x82A27950; continue 'dispatch;
	// 82A2794C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A27950: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A27954: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 82A27958: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2795C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A27960: 4BB702F1  bl 0x82597c50
	ctx.lr = 0x82A27964;
	sub_82597C50(ctx, base);
	// 82A27964: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A27968: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2796C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A27970: 4B898691  bl 0x822c0000
	ctx.lr = 0x82A27974;
	sub_822C0000(ctx, base);
	// 82A27974: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A27978: 41820024  beq 0x82a2799c
	if ctx.cr[0].eq {
	pc = 0x82A2799C; continue 'dispatch;
	}
	// 82A2797C: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A27980: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A27984: 419A0008  beq cr6, 0x82a2798c
	if ctx.cr[6].eq {
	pc = 0x82A2798C; continue 'dispatch;
	}
	// 82A27988: 4B898F09  bl 0x822c0890
	ctx.lr = 0x82A2798C;
	sub_822C0890(ctx, base);
	// 82A2798C: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A27990: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A27994: 419A0008  beq cr6, 0x82a2799c
	if ctx.cr[6].eq {
	pc = 0x82A2799C; continue 'dispatch;
	}
	// 82A27998: 4B898EF9  bl 0x822c0890
	ctx.lr = 0x82A2799C;
	sub_822C0890(ctx, base);
	// 82A2799C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A279A0: 419A000C  beq cr6, 0x82a279ac
	if ctx.cr[6].eq {
	pc = 0x82A279AC; continue 'dispatch;
	}
	// 82A279A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A279A8: 4B898EE9  bl 0x822c0890
	ctx.lr = 0x82A279AC;
	sub_822C0890(ctx, base);
	// 82A279AC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A279B0: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82A279B4: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A279B8: 487807FC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A279C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A279C0 size=1484
    let mut pc: u32 = 0x82A279C0;
    'dispatch: loop {
        match pc {
            0x82A279C0 => {
    //   block [0x82A279C0..0x82A27F8C)
	// 82A279C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A279C4: 48780791  bl 0x831a8154
	ctx.lr = 0x82A279C8;
	sub_831A8130(ctx, base);
	// 82A279C8: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82A279CC: 9421FDB0  stwu r1, -0x250(r1)
	ea = ctx.r[1].u32.wrapping_add(-592 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A279D0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A279D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A279D8: 4B8BD4E9  bl 0x822e4ec0
	ctx.lr = 0x82A279DC;
	sub_822E4EC0(ctx, base);
	// 82A279DC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A279E0: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82A279E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A279E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A279EC: 80AB6870  lwz r5, 0x6870(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26736 as u32) ) } as u64;
	// 82A279F0: 808A6750  lwz r4, 0x6750(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26448 as u32) ) } as u64;
	// 82A279F4: 4B8CFDAD  bl 0x822f77a0
	ctx.lr = 0x82A279F8;
	sub_822F77A0(ctx, base);
	// 82A279F8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82A279FC: E89F0000  ld r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 82A27A00: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A27A04: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82A27A08: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A27A0C: 4BA6487D  bl 0x8248c288
	ctx.lr = 0x82A27A10;
	sub_8248C288(ctx, base);
	// 82A27A10: 83AD0000  lwz r29, 0(r13)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A27A14: 3B800014  li r28, 0x14
	ctx.r[28].s64 = 20;
	// 82A27A18: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82A27A1C: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 82A27A20: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82A27A24: 7C7CE82E  lwzx r3, r28, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82A27A28: 48478D09  bl 0x82ea0730
	ctx.lr = 0x82A27A2C;
	sub_82EA0730(ctx, base);
	// 82A27A2C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A27A30: 3AE00030  li r23, 0x30
	ctx.r[23].s64 = 48;
	// 82A27A34: 3B4BACA0  addi r26, r11, -0x5360
	ctx.r[26].s64 = ctx.r[11].s64 + -21344;
	// 82A27A38: 39610120  addi r11, r1, 0x120
	ctx.r[11].s64 = ctx.r[1].s64 + 288;
	// 82A27A3C: B2E30004  sth r23, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[23].u16 ) };
	// 82A27A40: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 82A27A44: 38810120  addi r4, r1, 0x120
	ctx.r[4].s64 = ctx.r[1].s64 + 288;
	// 82A27A48: 13E0D0C7  vcmpequd (lvx128) v31, v0, v26
	tmp.u32 = ctx.r[26].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A27F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A27F90 size=316
    let mut pc: u32 = 0x82A27F90;
    'dispatch: loop {
        match pc {
            0x82A27F90 => {
    //   block [0x82A27F90..0x82A280CC)
	// 82A27F90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A27F94: 487801D9  bl 0x831a816c
	ctx.lr = 0x82A27F98;
	sub_831A8130(ctx, base);
	// 82A27F98: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A27F9C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A27FA0: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82A27FA4: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82A27FA8: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 82A27FAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A27FB0: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A27FB4: 4847877D  bl 0x82ea0730
	ctx.lr = 0x82A27FB8;
	sub_82EA0730(ctx, base);
	// 82A27FB8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A27FBC: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82A27FC0: 396BACB0  addi r11, r11, -0x5350
	ctx.r[11].s64 = ctx.r[11].s64 + -21328;
	// 82A27FC4: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82A27FC8: 3D008203  lis r8, -0x7dfd
	ctx.r[8].s64 = -2113732608;
	// 82A27FCC: B1230004  sth r9, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u16 ) };
	// 82A27FD0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A27FD4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A280D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A280D0 size=1120
    let mut pc: u32 = 0x82A280D0;
    'dispatch: loop {
        match pc {
            0x82A280D0 => {
    //   block [0x82A280D0..0x82A28530)
	// 82A280D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A280D4: 48780099  bl 0x831a816c
	ctx.lr = 0x82A280D8;
	sub_831A8130(ctx, base);
	// 82A280D8: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82A280DC: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A280E0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A280E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A280E8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A280EC: 4BAE861D  bl 0x82510708
	ctx.lr = 0x82A280F0;
	sub_82510708(ctx, base);
	// 82A280F0: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A280F4: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82A280F8: C1BF0138  lfs f13, 0x138(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A280FC: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82A28100: D01F0138  stfs f0, 0x138(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 82A28104: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82A28108: 41990418  bgt cr6, 0x82a28520
	if ctx.cr[6].gt {
	pc = 0x82A28520; continue 'dispatch;
	}
	// 82A2810C: 3D80820B  lis r12, -0x7df5
	ctx.r[12].s64 = -2113208320;
	// 82A28110: 398CAB10  addi r12, r12, -0x54f0
	ctx.r[12].s64 = ctx.r[12].s64 + -21744;
	// 82A28114: 7C0C58AE  lbzx r0, r12, r11
	ctx.r[0].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A28118: 5400103A  slwi r0, r0, 2
	ctx.r[0].u32 = ctx.r[0].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82A2811C: 3D8082A3  lis r12, -0x7d5d
	ctx.r[12].s64 = -2103246848;
	// 82A28120: 398C8134  addi r12, r12, -0x7ecc
	ctx.r[12].s64 = ctx.r[12].s64 + -32460;
	// 82A28124: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 82A28128: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 82A2812C: 60000000  nop
	// 82A28130: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
	// 82A28134: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A28138: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2813C: 419A03E4  beq cr6, 0x82a28520
	if ctx.cr[6].eq {
	pc = 0x82A28520; continue 'dispatch;
	}
	// 82A28140: 4818C6D9  bl 0x82bb4818
	ctx.lr = 0x82A28144;
	sub_82BB4818(ctx, base);
	// 82A28144: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A28148: 418203D8  beq 0x82a28520
	if ctx.cr[0].eq {
	pc = 0x82A28520; continue 'dispatch;
	}
	// 82A2814C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A28150: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A28154: 808B1278  lwz r4, 0x1278(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4728 as u32) ) } as u64;
	// 82A28158: 483CB8B1  bl 0x82df3a08
	ctx.lr = 0x82A2815C;
	sub_82DF3A08(ctx, base);
	// 82A2815C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A28160: 809F00F4  lwz r4, 0xf4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A28164: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A28168: 4818B1A9  bl 0x82bb3310
	ctx.lr = 0x82A2816C;
	sub_82BB3310(ctx, base);
	// 82A2816C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A28170: 395F00FC  addi r10, r31, 0xfc
	ctx.r[10].s64 = ctx.r[31].s64 + 252;
	// 82A28174: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A28178: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82A2817C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A28180: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 82A28184: 4B89C2DD  bl 0x822c4460
	ctx.lr = 0x82A28188;
	sub_822C4460(ctx, base);
	// 82A28188: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A2818C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A28190: 419A0008  beq cr6, 0x82a28198
	if ctx.cr[6].eq {
	pc = 0x82A28198; continue 'dispatch;
	}
	// 82A28194: 4B8986FD  bl 0x822c0890
	ctx.lr = 0x82A28198;
	sub_822C0890(ctx, base);
	// 82A28198: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2819C: 483CB28D  bl 0x82df3428
	ctx.lr = 0x82A281A0;
	sub_82DF3428(ctx, base);
	// 82A281A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A281A4: 4BFFFDED  bl 0x82a27f90
	ctx.lr = 0x82A281A8;
	sub_82A27F90(ctx, base);
	// 82A281A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A281AC: 4BFFEC35  bl 0x82a26de0
	ctx.lr = 0x82A281B0;
	sub_82A26DE0(ctx, base);
	// 82A281B0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A281B4: 40820364  bne 0x82a28518
	if !ctx.cr[0].eq {
	pc = 0x82A28518; continue 'dispatch;
	}
	// 82A281B8: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 82A281BC: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82A281C0: 48000360  b 0x82a28520
	pc = 0x82A28520; continue 'dispatch;
	// 82A281C4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82A281C8: C1AB6150  lfs f13, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A281CC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A281D0: 40990350  ble cr6, 0x82a28520
	if !ctx.cr[6].gt {
	pc = 0x82A28520; continue 'dispatch;
	}
	// 82A281D4: 817F0148  lwz r11, 0x148(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 82A281D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A281DC: 41990344  bgt cr6, 0x82a28520
	if ctx.cr[6].gt {
	pc = 0x82A28520; continue 'dispatch;
	}
	// 82A281E0: 389F0104  addi r4, r31, 0x104
	ctx.r[4].s64 = ctx.r[31].s64 + 260;
	// 82A281E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A281E8: 4BAE8B59  bl 0x82510d40
	ctx.lr = 0x82A281EC;
	sub_82510D40(ctx, base);
	// 82A281EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A281F0: 809F013C  lwz r4, 0x13c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82A281F4: 4BAE9ACD  bl 0x82511cc0
	ctx.lr = 0x82A281F8;
	sub_82511CC0(ctx, base);
	// 82A281F8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A281FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A28200: 38ABACD4  addi r5, r11, -0x532c
	ctx.r[5].s64 = ctx.r[11].s64 + -21292;
	// 82A28204: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A28208: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2820C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A28210: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A28214: 4E800421  bctrl
	ctx.lr = 0x82A28218;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A28218: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A2821C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A28220: 419A0008  beq cr6, 0x82a28228
	if ctx.cr[6].eq {
	pc = 0x82A28228; continue 'dispatch;
	}
	// 82A28224: 4B89866D  bl 0x822c0890
	ctx.lr = 0x82A28228;
	sub_822C0890(ctx, base);
	// 82A28228: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A2822C: 4BFFFF90  b 0x82a281bc
	pc = 0x82A281BC; continue 'dispatch;
	// 82A28230: 807F00FC  lwz r3, 0xfc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82A28234: 3BDF00FC  addi r30, r31, 0xfc
	ctx.r[30].s64 = ctx.r[31].s64 + 252;
	// 82A28238: 4818E2C9  bl 0x82bb6500
	ctx.lr = 0x82A2823C;
	sub_82BB6500(ctx, base);
	// 82A2823C: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82A28240: C03D0000  lfs f1, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A28244: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A28248: 4818D2A9  bl 0x82bb54f0
	ctx.lr = 0x82A2824C;
	sub_82BB54F0(ctx, base);
	// 82A2824C: 807F00FC  lwz r3, 0xfc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82A28250: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A28254: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A28258: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A2825C: 4E800421  bctrl
	ctx.lr = 0x82A28260;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A28260: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A28264: C00B1354  lfs f0, 0x1354(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4948 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A28268: EFE10032  fmuls f31, f1, f0
	ctx.f[31].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A2826C: FF1EF800  fcmpu cr6, f30, f31
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 82A28270: 40980080  bge cr6, 0x82a282f0
	if !ctx.cr[6].lt {
	pc = 0x82A282F0; continue 'dispatch;
	}
	// 82A28274: 817F0148  lwz r11, 0x148(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 82A28278: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2827C: 40990034  ble cr6, 0x82a282b0
	if !ctx.cr[6].gt {
	pc = 0x82A282B0; continue 'dispatch;
	}
	// 82A28280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A28284: 809F0140  lwz r4, 0x140(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 82A28288: 4BAE9A19  bl 0x82511ca0
	ctx.lr = 0x82A2828C;
	sub_82511CA0(ctx, base);
	// 82A2828C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A28290: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A28294: C02B9534  lfs f1, -0x6acc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A28298: 481907D9  bl 0x82bb8a70
	ctx.lr = 0x82A2829C;
	sub_82BB8A70(ctx, base);
	// 82A2829C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A282A0: 809F013C  lwz r4, 0x13c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82A282A4: 4BAE99FD  bl 0x82511ca0
	ctx.lr = 0x82A282A8;
	sub_82511CA0(ctx, base);
	// 82A282A8: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82A282AC: 4BFFFF10  b 0x82a281bc
	pc = 0x82A281BC; continue 'dispatch;
	// 82A282B0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A282B4: 4818E24D  bl 0x82bb6500
	ctx.lr = 0x82A282B8;
	sub_82BB6500(ctx, base);
	// 82A282B8: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 82A282BC: 41990034  bgt cr6, 0x82a282f0
	if ctx.cr[6].gt {
	pc = 0x82A282F0; continue 'dispatch;
	}
	// 82A282C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A282C4: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A282C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A282CC: 38AAACC0  addi r5, r10, -0x5340
	ctx.r[5].s64 = ctx.r[10].s64 + -21312;
	// 82A282D0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A282D4: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A282D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A282DC: 4E800421  bctrl
	ctx.lr = 0x82A282E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A282E0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A282E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A282E8: 419A0008  beq cr6, 0x82a282f0
	if ctx.cr[6].eq {
	pc = 0x82A282F0; continue 'dispatch;
	}
	// 82A282EC: 4B8985A5  bl 0x822c0890
	ctx.lr = 0x82A282F0;
	sub_822C0890(ctx, base);
	// 82A282F0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A282F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A282F8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A282FC: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A28300: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A28304: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A28308: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A2830C: 4E800421  bctrl
	ctx.lr = 0x82A28310;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A28310: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A28314: 4182020C  beq 0x82a28520
	if ctx.cr[0].eq {
	pc = 0x82A28520; continue 'dispatch;
	}
	// 82A28318: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2831C: 809F0140  lwz r4, 0x140(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 82A28320: 4BAE9981  bl 0x82511ca0
	ctx.lr = 0x82A28324;
	sub_82511CA0(ctx, base);
	// 82A28324: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A28328: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A2832C: 396B1278  addi r11, r11, 0x1278
	ctx.r[11].s64 = ctx.r[11].s64 + 4728;
	// 82A28330: 808B0030  lwz r4, 0x30(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A28334: 483CB6D5  bl 0x82df3a08
	ctx.lr = 0x82A28338;
	sub_82DF3A08(ctx, base);
	// 82A28338: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82A2833C: 809F00F4  lwz r4, 0xf4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A28340: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A28344: 4818AFCD  bl 0x82bb3310
	ctx.lr = 0x82A28348;
	sub_82BB3310(ctx, base);
	// 82A28348: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A2834C: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82A28350: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A28354: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A28358: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A2835C: 4B89C105  bl 0x822c4460
	ctx.lr = 0x82A28360;
	sub_822C4460(ctx, base);
	// 82A28360: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A28364: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A28368: 419A0008  beq cr6, 0x82a28370
	if ctx.cr[6].eq {
	pc = 0x82A28370; continue 'dispatch;
	}
	// 82A2836C: 4B898525  bl 0x822c0890
	ctx.lr = 0x82A28370;
	sub_822C0890(ctx, base);
	// 82A28370: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A28374: 483CB0B5  bl 0x82df3428
	ctx.lr = 0x82A28378;
	sub_82DF3428(ctx, base);
	// 82A28378: 897F014C  lbz r11, 0x14c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 82A2837C: D3FF0138  stfs f31, 0x138(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 82A28380: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 82A28384: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82A28388: 556B07BE  clrlwi r11, r11, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82A2838C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A28390: 4BFFFE2C  b 0x82a281bc
	pc = 0x82A281BC; continue 'dispatch;
	// 82A28394: C03D0000  lfs f1, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A28398: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A2839C: 4818D155  bl 0x82bb54f0
	ctx.lr = 0x82A283A0;
	sub_82BB54F0(ctx, base);
	// 82A283A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A283A4: 807F00FC  lwz r3, 0xfc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82A283A8: 3BDF00FC  addi r30, r31, 0xfc
	ctx.r[30].s64 = ctx.r[31].s64 + 252;
	// 82A283AC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A283B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A283B4: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82A283B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A283BC: 4E800421  bctrl
	ctx.lr = 0x82A283C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A283C0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A283C4: 4182015C  beq 0x82a28520
	if ctx.cr[0].eq {
	pc = 0x82A28520; continue 'dispatch;
	}
	// 82A283C8: 389F0104  addi r4, r31, 0x104
	ctx.r[4].s64 = ctx.r[31].s64 + 260;
	// 82A283CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A283D0: 4BAE82D9  bl 0x825106a8
	ctx.lr = 0x82A283D4;
	sub_825106A8(ctx, base);
	// 82A283D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A283D8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A283DC: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A283E0: 48190691  bl 0x82bb8a70
	ctx.lr = 0x82A283E4;
	sub_82BB8A70(ctx, base);
	// 82A283E4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A283E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A283EC: 808B1278  lwz r4, 0x1278(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4728 as u32) ) } as u64;
	// 82A283F0: 483CB619  bl 0x82df3a08
	ctx.lr = 0x82A283F4;
	sub_82DF3A08(ctx, base);
	// 82A283F4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A283F8: 809F00F4  lwz r4, 0xf4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A283FC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A28400: 4818AF11  bl 0x82bb3310
	ctx.lr = 0x82A28404;
	sub_82BB3310(ctx, base);
	// 82A28404: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A28408: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82A2840C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A28410: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A28414: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A28418: 4B89C049  bl 0x822c4460
	ctx.lr = 0x82A2841C;
	sub_822C4460(ctx, base);
	// 82A2841C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A28420: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A28424: 419A0008  beq cr6, 0x82a2842c
	if ctx.cr[6].eq {
	pc = 0x82A2842C; continue 'dispatch;
	}
	// 82A28428: 4B898469  bl 0x822c0890
	ctx.lr = 0x82A2842C;
	sub_822C0890(ctx, base);
	// 82A2842C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A28430: 483CAFF9  bl 0x82df3428
	ctx.lr = 0x82A28434;
	sub_82DF3428(ctx, base);
	// 82A28434: 480000E4  b 0x82a28518
	pc = 0x82A28518; continue 'dispatch;
	// 82A28438: C1BF0130  lfs f13, 0x130(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A2843C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A28440: 419900E0  bgt cr6, 0x82a28520
	if ctx.cr[6].gt {
	pc = 0x82A28520; continue 'dispatch;
	}
	// 82A28444: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A28448: 809F013C  lwz r4, 0x13c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82A2844C: 4BAE9855  bl 0x82511ca0
	ctx.lr = 0x82A28450;
	sub_82511CA0(ctx, base);
	// 82A28450: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82A28454: 4BFFFD68  b 0x82a281bc
	pc = 0x82A281BC; continue 'dispatch;
	// 82A28458: C03D0000  lfs f1, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A2845C: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A28460: 4818D091  bl 0x82bb54f0
	ctx.lr = 0x82A28464;
	sub_82BB54F0(ctx, base);
	// 82A28464: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A28468: 807F00FC  lwz r3, 0xfc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82A2846C: 3BDF00FC  addi r30, r31, 0xfc
	ctx.r[30].s64 = ctx.r[31].s64 + 252;
	// 82A28470: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A28474: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A28478: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2847C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A28480: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A28484: 4E800421  bctrl
	ctx.lr = 0x82A28488;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A28488: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2848C: 41820094  beq 0x82a28520
	if ctx.cr[0].eq {
	pc = 0x82A28520; continue 'dispatch;
	}
	// 82A28490: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A28494: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A28498: 808B1278  lwz r4, 0x1278(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4728 as u32) ) } as u64;
	// 82A2849C: 483CB56D  bl 0x82df3a08
	ctx.lr = 0x82A284A0;
	sub_82DF3A08(ctx, base);
	// 82A284A0: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82A284A4: 809F00F4  lwz r4, 0xf4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A284A8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A284AC: 4818AE65  bl 0x82bb3310
	ctx.lr = 0x82A284B0;
	sub_82BB3310(ctx, base);
	// 82A284B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A284B4: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82A284B8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A284BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A284C0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A284C4: 4B89BF9D  bl 0x822c4460
	ctx.lr = 0x82A284C8;
	sub_822C4460(ctx, base);
	// 82A284C8: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A284CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A284D0: 419A0008  beq cr6, 0x82a284d8
	if ctx.cr[6].eq {
	pc = 0x82A284D8; continue 'dispatch;
	}
	// 82A284D4: 4B8983BD  bl 0x822c0890
	ctx.lr = 0x82A284D8;
	sub_822C0890(ctx, base);
	// 82A284D8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A284DC: 483CAF4D  bl 0x82df3428
	ctx.lr = 0x82A284E0;
	sub_82DF3428(ctx, base);
	// 82A284E0: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 82A284E4: D3FF0138  stfs f31, 0x138(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 82A284E8: 389F0104  addi r4, r31, 0x104
	ctx.r[4].s64 = ctx.r[31].s64 + 260;
	// 82A284EC: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82A284F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A284F4: 4BAE81B5  bl 0x825106a8
	ctx.lr = 0x82A284F8;
	sub_825106A8(ctx, base);
	// 82A284F8: 48000028  b 0x82a28520
	pc = 0x82A28520; continue 'dispatch;
	// 82A284FC: C1BF0134  lfs f13, 0x134(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A28500: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A28504: 4199001C  bgt cr6, 0x82a28520
	if ctx.cr[6].gt {
	pc = 0x82A28520; continue 'dispatch;
	}
	// 82A28508: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2850C: 4BFFE8D5  bl 0x82a26de0
	ctx.lr = 0x82A28510;
	sub_82A26DE0(ctx, base);
	// 82A28510: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A28514: 4182000C  beq 0x82a28520
	if ctx.cr[0].eq {
	pc = 0x82A28520; continue 'dispatch;
	}
	// 82A28518: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2851C: 4BFFE5BD  bl 0x82a26ad8
	ctx.lr = 0x82A28520;
	sub_82A26AD8(ctx, base);
	// 82A28520: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A28524: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A28528: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82A2852C: 4877FC90  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A28530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A28530 size=360
    let mut pc: u32 = 0x82A28530;
    'dispatch: loop {
        match pc {
            0x82A28530 => {
    //   block [0x82A28530..0x82A28698)
	// 82A28530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A28534: 4877FC39  bl 0x831a816c
	ctx.lr = 0x82A28538;
	sub_831A8130(ctx, base);
	// 82A28538: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A2853C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A28540: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A28544: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A28548: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82A2854C: 4BAE948D  bl 0x825119d8
	ctx.lr = 0x82A28550;
	sub_825119D8(ctx, base);
	// 82A28550: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82A28554: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A28558: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82A2855C: 483CB4AD  bl 0x82df3a08
	ctx.lr = 0x82A28560;
	sub_82DF3A08(ctx, base);
	// 82A28560: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A28564: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A28568: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2856C: 4BAE0215  bl 0x82508780
	ctx.lr = 0x82A28570;
	sub_82508780(ctx, base);
	// 82A28570: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A28574: 483CAEB5  bl 0x82df3428
	ctx.lr = 0x82A28578;
	sub_82DF3428(ctx, base);
	// 82A28578: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A2857C: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82A28580: 409A0008  bne cr6, 0x82a28588
	if !ctx.cr[6].eq {
	pc = 0x82A28588; continue 'dispatch;
	}
	// 82A28584: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A28588: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2858C: 4BAE0215  bl 0x825087a0
	ctx.lr = 0x82A28590;
	sub_825087A0(ctx, base);
	// 82A28590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A28594: 3BDF0120  addi r30, r31, 0x120
	ctx.r[30].s64 = ctx.r[31].s64 + 288;
	// 82A28598: 4BAE95C1  bl 0x82511b58
	ctx.lr = 0x82A2859C;
	sub_82511B58(ctx, base);
	// 82A2859C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A285A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A285A4: 484538F5  bl 0x82e7be98
	ctx.lr = 0x82A285A8;
	sub_82E7BE98(ctx, base);
	// 82A285A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A285AC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A285B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A285B4: 48453795  bl 0x82e7bd48
	ctx.lr = 0x82A285B8;
	sub_82E7BD48(ctx, base);
	// 82A285B8: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A28698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A28698 size=72
    let mut pc: u32 = 0x82A28698;
    'dispatch: loop {
        match pc {
            0x82A28698 => {
    //   block [0x82A28698..0x82A286E0)
	// 82A28698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2869C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A286A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A286A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A286A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A286AC: 389F0110  addi r4, r31, 0x110
	ctx.r[4].s64 = ctx.r[31].s64 + 272;
	// 82A286B0: 4BAE8691  bl 0x82510d40
	ctx.lr = 0x82A286B4;
	sub_82510D40(ctx, base);
	// 82A286B4: 389F0108  addi r4, r31, 0x108
	ctx.r[4].s64 = ctx.r[31].s64 + 264;
	// 82A286B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A286BC: 4BAE8685  bl 0x82510d40
	ctx.lr = 0x82A286C0;
	sub_82510D40(ctx, base);
	// 82A286C0: 389F0118  addi r4, r31, 0x118
	ctx.r[4].s64 = ctx.r[31].s64 + 280;
	// 82A286C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A286C8: 4BAE8679  bl 0x82510d40
	ctx.lr = 0x82A286CC;
	sub_82510D40(ctx, base);
	// 82A286CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A286D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A286D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A286D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A286DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A286E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A286E0 size=72
    let mut pc: u32 = 0x82A286E0;
    'dispatch: loop {
        match pc {
            0x82A286E0 => {
    //   block [0x82A286E0..0x82A28728)
	// 82A286E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A286E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A286E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A286EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A286F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A286F4: 389F0110  addi r4, r31, 0x110
	ctx.r[4].s64 = ctx.r[31].s64 + 272;
	// 82A286F8: 4BAE7FB1  bl 0x825106a8
	ctx.lr = 0x82A286FC;
	sub_825106A8(ctx, base);
	// 82A286FC: 389F0108  addi r4, r31, 0x108
	ctx.r[4].s64 = ctx.r[31].s64 + 264;
	// 82A28700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A28704: 4BAE7FA5  bl 0x825106a8
	ctx.lr = 0x82A28708;
	sub_825106A8(ctx, base);
	// 82A28708: 389F0118  addi r4, r31, 0x118
	ctx.r[4].s64 = ctx.r[31].s64 + 280;
	// 82A2870C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A28710: 4BAE7F99  bl 0x825106a8
	ctx.lr = 0x82A28714;
	sub_825106A8(ctx, base);
	// 82A28714: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A28718: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2871C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A28720: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A28724: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A28728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A28728 size=48
    let mut pc: u32 = 0x82A28728;
    'dispatch: loop {
        match pc {
            0x82A28728 => {
    //   block [0x82A28728..0x82A28758)
	// 82A28728: C1040000  lfs f8, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82A2872C: FC000850  fneg f0, f1
	ctx.f[0].u64 = ctx.f[1].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A28730: EDA44028  fsubs f13, f4, f8
	ctx.f[13].f64 = (((ctx.f[4].f64 - ctx.f[8].f64) as f32) as f64);
	// 82A28734: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A28738: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A2873C: FF044000  fcmpu cr6, f4, f8
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[8].f64);
	// 82A28740: FD2D006E  fsel f9, f13, f1, f0
	ctx.f[9].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[1].f64 } else { ctx.f[0].f64 };
	// 82A28744: 409A0014  bne cr6, 0x82a28758
	if !ctx.cr[6].eq {
		sub_82A28758(ctx, base);
		return;
	}
	// 82A28748: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A2874C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A28750: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A28754: 480001E8  b 0x82a2893c
	sub_82A28908(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A28758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A28758 size=32
    let mut pc: u32 = 0x82A28758;
    'dispatch: loop {
        match pc {
            0x82A28758 => {
    //   block [0x82A28758..0x82A28778)
	// 82A28758: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A2875C: C16A08A4  lfs f11, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A28760: FF025800  fcmpu cr6, f2, f11
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[11].f64);
	// 82A28764: 419A0014  beq cr6, 0x82a28778
	if ctx.cr[6].eq {
		sub_82A28778(ctx, base);
		return;
	}
	// 82A28768: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A2876C: C00A08A8  lfs f0, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A28770: ECE01024  fdivs f7, f0, f2
	ctx.f[7].f64 = ((ctx.f[0].f64 / ctx.f[2].f64) as f32) as f64;
	// 82A28774: 48000008  b 0x82a2877c
	sub_82A28778(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A28778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A28778 size=32
    let mut pc: u32 = 0x82A28778;
    'dispatch: loop {
        match pc {
            0x82A28778 => {
    //   block [0x82A28778..0x82A28798)
	// 82A28778: FCE05890  fmr f7, f11
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[7].f64 = ctx.f[11].f64;
	// 82A2877C: FF095800  fcmpu cr6, f9, f11
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[11].f64);
	// 82A28780: 409A0098  bne cr6, 0x82a28818
	if !ctx.cr[6].eq {
		sub_82A28818(ctx, base);
		return;
	}
	// 82A28784: C1A50000  lfs f13, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A28788: FF0D1800  fcmpu cr6, f13, f3
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[3].f64);
	// 82A2878C: 4099000C  ble cr6, 0x82a28798
	if !ctx.cr[6].gt {
		sub_82A28798(ctx, base);
		return;
	}
	// 82A28790: D0650000  stfs f3, 0(r5)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A28794: 48000014  b 0x82a287a8
	sub_82A28798(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A28798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A28798 size=64
    let mut pc: u32 = 0x82A28798;
    'dispatch: loop {
        match pc {
            0x82A28798 => {
    //   block [0x82A28798..0x82A287D8)
	// 82A28798: FC001850  fneg f0, f3
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = ctx.f[3].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A2879C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A287A0: 40980008  bge cr6, 0x82a287a8
	if !ctx.cr[6].lt {
	pc = 0x82A287A8; continue 'dispatch;
	}
	// 82A287A4: D0050000  stfs f0, 0(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A287A8: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A287AC: EDA000B2  fmuls f13, f0, f2
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[2].f64) as f32) as f64);
	// 82A287B0: C1840000  lfs f12, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A287B4: EC046028  fsubs f0, f4, f12
	ctx.f[0].f64 = (((ctx.f[4].f64 - ctx.f[12].f64) as f32) as f64);
	// 82A287B8: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82A287BC: 4098001C  bge cr6, 0x82a287d8
	if !ctx.cr[6].lt {
		sub_82A287D8(ctx, base);
		return;
	}
	// 82A287C0: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82A287C4: 40980028  bge cr6, 0x82a287ec
	if !ctx.cr[6].lt {
		sub_82A287D8(ctx, base);
		return;
	}
	// 82A287C8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A287CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A287D0: 40990020  ble cr6, 0x82a287f0
	if !ctx.cr[6].gt {
		sub_82A287D8(ctx, base);
		return;
	}
	// 82A287D4: 48000018  b 0x82a287ec
	sub_82A287D8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A287D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A287D8 size=52
    let mut pc: u32 = 0x82A287D8;
    'dispatch: loop {
        match pc {
            0x82A287D8 => {
    //   block [0x82A287D8..0x82A2880C)
	// 82A287D8: FF005800  fcmpu cr6, f0, f11
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82A287DC: 41980010  blt cr6, 0x82a287ec
	if ctx.cr[6].lt {
	pc = 0x82A287EC; continue 'dispatch;
	}
	// 82A287E0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A287E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A287E8: 40980008  bge cr6, 0x82a287f0
	if !ctx.cr[6].lt {
	pc = 0x82A287F0; continue 'dispatch;
	}
	// 82A287EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A287F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A287F4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A287F8: 41820014  beq 0x82a2880c
	if ctx.cr[0].eq {
		sub_82A2880C(ctx, base);
		return;
	}
	// 82A287FC: EC0001F2  fmuls f0, f0, f7
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[7].f64) as f32) as f64);
	// 82A28800: D0840000  stfs f4, 0(r4)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A28804: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A28808: 48000134  b 0x82a2893c
	sub_82A28908(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2880C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A2880C size=12
    let mut pc: u32 = 0x82A2880C;
    'dispatch: loop {
        match pc {
            0x82A2880C => {
    //   block [0x82A2880C..0x82A28818)
	// 82A2880C: EC0C682A  fadds f0, f12, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82A28810: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A28814: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A28818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A28818 size=32
    let mut pc: u32 = 0x82A28818;
    'dispatch: loop {
        match pc {
            0x82A28818 => {
    //   block [0x82A28818..0x82A28838)
	// 82A28818: ED4900B2  fmuls f10, f9, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[10].f64 = (((ctx.f[9].f64 * ctx.f[2].f64) as f32) as f64);
	// 82A2881C: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A28820: EDA0502A  fadds f13, f0, f10
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64;
	// 82A28824: FF0D1800  fcmpu cr6, f13, f3
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[3].f64);
	// 82A28828: 40990010  ble cr6, 0x82a28838
	if !ctx.cr[6].gt {
		sub_82A28838(ctx, base);
		return;
	}
	// 82A2882C: ED830028  fsubs f12, f3, f0
	ctx.f[12].f64 = (((ctx.f[3].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A28830: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A28834: 4800001C  b 0x82a28850
	sub_82A2884C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A28838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A28838 size=20
    let mut pc: u32 = 0x82A28838;
    'dispatch: loop {
        match pc {
            0x82A28838 => {
    //   block [0x82A28838..0x82A2884C)
	// 82A28838: FD801850  fneg f12, f3
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = ctx.f[3].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A2883C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82A28840: 4098000C  bge cr6, 0x82a2884c
	if !ctx.cr[6].lt {
		sub_82A2884C(ctx, base);
		return;
	}
	// 82A28844: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A28848: 4BFFFFE8  b 0x82a28830
	sub_82A28818(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2884C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A2884C size=80
    let mut pc: u32 = 0x82A2884C;
    'dispatch: loop {
        match pc {
            0x82A2884C => {
    //   block [0x82A2884C..0x82A2889C)
	// 82A2884C: C181FFF0  lfs f12, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A28850: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A28854: EDA44028  fsubs f13, f4, f8
	ctx.f[13].f64 = (((ctx.f[4].f64 - ctx.f[8].f64) as f32) as f64);
	// 82A28858: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A2885C: 41820080  beq 0x82a288dc
	if ctx.cr[0].eq {
		sub_82A288DC(ctx, base);
		return;
	}
	// 82A28860: ED4C4824  fdivs f10, f12, f9
	ctx.f[10].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82A28864: ED2000B2  fmuls f9, f0, f2
	ctx.f[9].f64 = (((ctx.f[0].f64 * ctx.f[2].f64) as f32) as f64);
	// 82A28868: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A2886C: ED425028  fsubs f10, f2, f10
	ctx.f[10].f64 = (((ctx.f[2].f64 - ctx.f[10].f64) as f32) as f64);
	// 82A28870: ED4A102A  fadds f10, f10, f2
	ctx.f[10].f64 = ((ctx.f[10].f64 + ctx.f[2].f64) as f32) as f64;
	// 82A28874: ED4A0332  fmuls f10, f10, f12
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 82A28878: EC0A483A  fmadds f0, f10, f0, f9
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64);
	// 82A2887C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82A28880: 4098001C  bge cr6, 0x82a2889c
	if !ctx.cr[6].lt {
		sub_82A2889C(ctx, base);
		return;
	}
	// 82A28884: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82A28888: 40980028  bge cr6, 0x82a288b0
	if !ctx.cr[6].lt {
		sub_82A2889C(ctx, base);
		return;
	}
	// 82A2888C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A28890: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A28894: 40990020  ble cr6, 0x82a288b4
	if !ctx.cr[6].gt {
		sub_82A2889C(ctx, base);
		return;
	}
	// 82A28898: 48000018  b 0x82a288b0
	sub_82A2889C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2889C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A2889C size=44
    let mut pc: u32 = 0x82A2889C;
    'dispatch: loop {
        match pc {
            0x82A2889C => {
    //   block [0x82A2889C..0x82A288C8)
	// 82A2889C: FF0D5800  fcmpu cr6, f13, f11
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82A288A0: 41980010  blt cr6, 0x82a288b0
	if ctx.cr[6].lt {
	pc = 0x82A288B0; continue 'dispatch;
	}
	// 82A288A4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A288A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A288AC: 40980008  bge cr6, 0x82a288b4
	if !ctx.cr[6].lt {
	pc = 0x82A288B4; continue 'dispatch;
	}
	// 82A288B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A288B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A288B8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A288BC: 4182000C  beq 0x82a288c8
	if ctx.cr[0].eq {
		sub_82A288C8(ctx, base);
		return;
	}
	// 82A288C0: EC0D01F2  fmuls f0, f13, f7
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[7].f64) as f32) as f64);
	// 82A288C4: 4BFFFF3C  b 0x82a28800
	sub_82A287D8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A288C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A288C8 size=20
    let mut pc: u32 = 0x82A288C8;
    'dispatch: loop {
        match pc {
            0x82A288C8 => {
    //   block [0x82A288C8..0x82A288DC)
	// 82A288C8: EC08002A  fadds f0, f8, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A288CC: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A288D0: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A288D4: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82A288D8: 48000064  b 0x82a2893c
	sub_82A28908(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A288DC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A288DC size=44
    let mut pc: u32 = 0x82A288DC;
    'dispatch: loop {
        match pc {
            0x82A288DC => {
    //   block [0x82A288DC..0x82A28908)
	// 82A288DC: C18B9450  lfs f12, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A288E0: EC0A033A  fmadds f0, f10, f12, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82A288E4: EC0000B2  fmuls f0, f0, f2
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[2].f64) as f32) as f64);
	// 82A288E8: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82A288EC: 4098001C  bge cr6, 0x82a28908
	if !ctx.cr[6].lt {
		sub_82A28908(ctx, base);
		return;
	}
	// 82A288F0: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82A288F4: 40980028  bge cr6, 0x82a2891c
	if !ctx.cr[6].lt {
		sub_82A28908(ctx, base);
		return;
	}
	// 82A288F8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A288FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A28900: 40990020  ble cr6, 0x82a28920
	if !ctx.cr[6].gt {
		sub_82A28908(ctx, base);
		return;
	}
	// 82A28904: 48000018  b 0x82a2891c
	sub_82A28908(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A28908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A28908 size=60
    let mut pc: u32 = 0x82A28908;
    'dispatch: loop {
        match pc {
            0x82A28908 => {
    //   block [0x82A28908..0x82A28944)
	// 82A28908: FF0D5800  fcmpu cr6, f13, f11
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82A2890C: 41980010  blt cr6, 0x82a2891c
	if ctx.cr[6].lt {
	pc = 0x82A2891C; continue 'dispatch;
	}
	// 82A28910: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A28914: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A28918: 40980008  bge cr6, 0x82a28920
	if !ctx.cr[6].lt {
	pc = 0x82A28920; continue 'dispatch;
	}
	// 82A2891C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A28920: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A28924: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A28928: 4082FF98  bne 0x82a288c0
	if !ctx.cr[0].eq {
		sub_82A2889C(ctx, base);
		return;
	}
	// 82A2892C: EC08002A  fadds f0, f8, f0
	ctx.f[0].f64 = ((ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A28930: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A28934: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A28938: EC00502A  fadds f0, f0, f10
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64;
	// 82A2893C: D0050000  stfs f0, 0(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A28940: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A28948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A28948 size=32
    let mut pc: u32 = 0x82A28948;
    'dispatch: loop {
        match pc {
            0x82A28948 => {
    //   block [0x82A28948..0x82A28968)
	// 82A28948: 816300EC  lwz r11, 0xec(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A2894C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A28950: 394AAE40  addi r10, r10, -0x51c0
	ctx.r[10].s64 = ctx.r[10].s64 + -20928;
	// 82A28954: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A28958: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A2895C: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A28960: D0040018  stfs f0, 0x18(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A28964: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A28968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A28968 size=216
    let mut pc: u32 = 0x82A28968;
    'dispatch: loop {
        match pc {
            0x82A28968 => {
    //   block [0x82A28968..0x82A28A40)
	// 82A28968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2896C: 4877F7FD  bl 0x831a8168
	ctx.lr = 0x82A28970;
	sub_831A8130(ctx, base);
	// 82A28970: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A28974: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A28978: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A2897C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A28980: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A28984: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A28988: C1AB08A4  lfs f13, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A2898C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A28990: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A28994: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A28998: C1AB1640  lfs f13, 0x1640(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5696 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A2899C: 40980014  bge cr6, 0x82a289b0
	if !ctx.cr[6].lt {
	pc = 0x82A289B0; continue 'dispatch;
	}
	// 82A289A0: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A289A4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A289A8: 40980018  bge cr6, 0x82a289c0
	if !ctx.cr[6].lt {
	pc = 0x82A289C0; continue 'dispatch;
	}
	// 82A289AC: 4800000C  b 0x82a289b8
	pc = 0x82A289B8; continue 'dispatch;
	// 82A289B0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A289B4: 4099000C  ble cr6, 0x82a289c0
	if !ctx.cr[6].gt {
	pc = 0x82A289C0; continue 'dispatch;
	}
	// 82A289B8: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A289BC: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82A289C0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A289C4: C3FF0008  lfs f31, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A289C8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A289CC: 3BAB1480  addi r29, r11, 0x1480
	ctx.r[29].s64 = ctx.r[11].s64 + 5248;
	// 82A289D0: C05D0008  lfs f2, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A289D4: 4BFEABFD  bl 0x82a135d0
	ctx.lr = 0x82A289D8;
	sub_82A135D0(ctx, base);
	// 82A289D8: D03F0008  stfs f1, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A289DC: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 82A289E0: 419A0008  beq cr6, 0x82a289e8
	if ctx.cr[6].eq {
	pc = 0x82A289E8; continue 'dispatch;
	}
	// 82A289E4: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82A289E8: C05D0000  lfs f2, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A289EC: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A289F0: 4BFEABB1  bl 0x82a135a0
	ctx.lr = 0x82A289F4;
	sub_82A135A0(ctx, base);
	// 82A289F4: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A289F8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82A289FC: 409A0034  bne cr6, 0x82a28a30
	if !ctx.cr[6].eq {
	pc = 0x82A28A30; continue 'dispatch;
	}
	// 82A28A00: 817C00EC  lwz r11, 0xec(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A28A04: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A28A08: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A28A0C: 394A137C  addi r10, r10, 0x137c
	ctx.r[10].s64 = ctx.r[10].s64 + 4988;
	// 82A28A10: C03F0004  lfs f1, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A28A14: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A28A18: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A28A1C: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A28A20: EC4D002A  fadds f2, f13, f0
	ctx.f[2].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A28A24: 4BFEABDD  bl 0x82a13600
	ctx.lr = 0x82A28A28;
	sub_82A13600(ctx, base);
	// 82A28A28: D03F0004  stfs f1, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A28A2C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82A28A30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A28A34: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A28A38: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A28A3C: 4877F77C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A28A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A28A40 size=196
    let mut pc: u32 = 0x82A28A40;
    'dispatch: loop {
        match pc {
            0x82A28A40 => {
    //   block [0x82A28A40..0x82A28B04)
	// 82A28A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A28A44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A28A48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A28A4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A28A50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A28A54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A28A58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A28A5C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A28A60: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A28A64: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A28A68: 4B897ED1  bl 0x822c0938
	ctx.lr = 0x82A28A6C;
	sub_822C0938(ctx, base);
	// 82A28A6C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A28A70: 41820028  beq 0x82a28a98
	if ctx.cr[0].eq {
	pc = 0x82A28A98; continue 'dispatch;
	}
	// 82A28A74: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A28A78: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A28A7C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A28A80: 392BAE50  addi r9, r11, -0x51b0
	ctx.r[9].s64 = ctx.r[11].s64 + -20912;
	// 82A28A84: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A28A88: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A28A8C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A28A90: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A28A94: 48000008  b 0x82a28a9c
	pc = 0x82A28A9C; continue 'dispatch;
	// 82A28A98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A28A9C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A28AA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A28AA4: 409A0044  bne cr6, 0x82a28ae8
	if !ctx.cr[6].eq {
	pc = 0x82A28AE8; continue 'dispatch;
	}
	// 82A28AA8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A28AAC: 419A001C  beq cr6, 0x82a28ac8
	if ctx.cr[6].eq {
	pc = 0x82A28AC8; continue 'dispatch;
	}
	// 82A28AB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A28AB4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A28AB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A28ABC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A28AC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A28AC4: 4E800421  bctrl
	ctx.lr = 0x82A28AC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A28AC8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A28ACC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A28AD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A28AD4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A28AD8: 816B1388  lwz r11, 0x1388(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5000 as u32) ) } as u64;
	// 82A28ADC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A28AE0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A28AE4: 4B89751D  bl 0x822c0000
	ctx.lr = 0x82A28AE8;
	sub_822C0000(ctx, base);
	// 82A28AE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A28AEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A28AF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A28AF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A28AF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A28AFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A28B00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A28B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A28B08 size=236
    let mut pc: u32 = 0x82A28B08;
    'dispatch: loop {
        match pc {
            0x82A28B08 => {
    //   block [0x82A28B08..0x82A28BF4)
	// 82A28B08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A28B0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A28B10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A28B14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A28B18: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82A28B1C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A28B20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A28B24: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A28B28: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A28B2C: 807F0118  lwz r3, 0x118(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82A28B30: 4B8C4419  bl 0x822ecf48
	ctx.lr = 0x82A28B34;
	sub_822ECF48(ctx, base);
	// 82A28B34: C0010090  lfs f0, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A28B38: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A28B3C: C1A10094  lfs f13, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A28B40: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A28B44: C1810098  lfs f12, 0x98(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A28B48: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A28B4C: C161009C  lfs f11, 0x9c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A28B50: 38BF0138  addi r5, r31, 0x138
	ctx.r[5].s64 = ctx.r[31].s64 + 312;
	// 82A28B54: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A28B58: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A28B5C: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A28B60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A28B64: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82A28B68: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82A28B6C: D161005C  stfs f11, 0x5c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82A28B70: C08B08A4  lfs f4, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82A28B74: C06A9E20  lfs f3, -0x61e0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25056 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82A28B78: C0299E1C  lfs f1, -0x61e4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-25060 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A28B7C: 4BFFFBAD  bl 0x82a28728
	ctx.lr = 0x82A28B80;
	sub_82A28728(ctx, base);
	// 82A28B80: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A28B84: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A28B88: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A28B8C: 394A137C  addi r10, r10, 0x137c
	ctx.r[10].s64 = ctx.r[10].s64 + 4988;
	// 82A28B90: 3D20832E  lis r9, -0x7cd2
	ctx.r[9].s64 = -2094137344;
	// 82A28B94: 3D00832E  lis r8, -0x7cd2
	ctx.r[8].s64 = -2094137344;
	// 82A28B98: 39291480  addi r9, r9, 0x1480
	ctx.r[9].s64 = ctx.r[9].s64 + 5248;
	// 82A28B9C: 38E81640  addi r7, r8, 0x1640
	ctx.r[7].s64 = ctx.r[8].s64 + 5696;
	// 82A28BA0: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A28BA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A28BA8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A28BAC: 807F0118  lwz r3, 0x118(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82A28BB0: C0081640  lfs f0, 0x1640(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(5696 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A28BB4: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A28BB8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A28BBC: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A28BC0: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82A28BC4: C0070004  lfs f0, 4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A28BC8: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A28BCC: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A28BD0: 4B8C4B51  bl 0x822ed720
	ctx.lr = 0x82A28BD4;
	sub_822ED720(ctx, base);
	// 82A28BD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A28BD8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A28BDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A28BE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A28BE4: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A28BE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A28BEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A28BF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A28BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A28BF8 size=252
    let mut pc: u32 = 0x82A28BF8;
    'dispatch: loop {
        match pc {
            0x82A28BF8 => {
    //   block [0x82A28BF8..0x82A28CF4)
	// 82A28BF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A28BFC: 4877F56D  bl 0x831a8168
	ctx.lr = 0x82A28C00;
	sub_831A8130(ctx, base);
	// 82A28C00: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A28C04: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A28C08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A28C0C: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A28C10: 3D20832E  lis r9, -0x7cd2
	ctx.r[9].s64 = -2094137344;
	// 82A28C14: 3BAA137C  addi r29, r10, 0x137c
	ctx.r[29].s64 = ctx.r[10].s64 + 4988;
	// 82A28C18: 3B891480  addi r28, r9, 0x1480
	ctx.r[28].s64 = ctx.r[9].s64 + 5248;
	// 82A28C1C: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A28C20: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A28C24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A28C28: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A28C2C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A28C30: C01C0004  lfs f0, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A28C34: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A28C38: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A28C3C: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82A28C40: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A28C44: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A28C48: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A28C4C: FC400050  fneg f2, f0
	ctx.f[2].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A28C50: 484533C9  bl 0x82e7c018
	ctx.lr = 0x82A28C54;
	sub_82E7C018(ctx, base);
	// 82A28C54: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A28C58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A28C5C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A28C60: 4B89BCA1  bl 0x822c4900
	ctx.lr = 0x82A28C64;
	sub_822C4900(ctx, base);
	// 82A28C64: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A28C68: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A28C6C: C01C0004  lfs f0, 4(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A28C70: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A28C74: 83DF0110  lwz r30, 0x110(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82A28C78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A28C7C: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A28C80: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A28C84: C1AA9524  lfs f13, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A28C88: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82A28C8C: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A28C90: EC40637A  fmadds f2, f0, f13, f12
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82A28C94: 48453385  bl 0x82e7c018
	ctx.lr = 0x82A28C98;
	sub_82E7C018(ctx, base);
	// 82A28C98: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A28C9C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82A28CA0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82A28CA4: 4B89BC5D  bl 0x822c4900
	ctx.lr = 0x82A28CA8;
	sub_822C4900(ctx, base);
	// 82A28CA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A28CAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A28CB0: 4B8C4C71  bl 0x822ed920
	ctx.lr = 0x82A28CB4;
	sub_822ED920(ctx, base);
	// 82A28CB4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82A28CB8: C05C0004  lfs f2, 4(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82A28CBC: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82A28CC0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A28CC4: 83FF0108  lwz r31, 0x108(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 82A28CC8: 48453351  bl 0x82e7c018
	ctx.lr = 0x82A28CCC;
	sub_82E7C018(ctx, base);
	// 82A28CCC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A28CD0: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82A28CD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A28CD8: 4B89BC29  bl 0x822c4900
	ctx.lr = 0x82A28CDC;
	sub_822C4900(ctx, base);
	// 82A28CDC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A28CE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A28CE4: 4B8C4C3D  bl 0x822ed920
	ctx.lr = 0x82A28CE8;
	sub_822ED920(ctx, base);
	// 82A28CE8: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 82A28CEC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A28CF0: 4877F4C8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A28CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A28CF8 size=156
    let mut pc: u32 = 0x82A28CF8;
    'dispatch: loop {
        match pc {
            0x82A28CF8 => {
    //   block [0x82A28CF8..0x82A28D94)
	// 82A28CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A28CFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A28D00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A28D04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A28D08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A28D0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A28D10: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A28D14: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 82A28D18: 807F0118  lwz r3, 0x118(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82A28D1C: 4B8C4435  bl 0x822ed150
	ctx.lr = 0x82A28D20;
	sub_822ED150(ctx, base);
	// 82A28D20: 807F0168  lwz r3, 0x168(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82A28D24: 3BDF0168  addi r30, r31, 0x168
	ctx.r[30].s64 = ctx.r[31].s64 + 360;
	// 82A28D28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A28D2C: 419A0008  beq cr6, 0x82a28d34
	if ctx.cr[6].eq {
	pc = 0x82A28D34; continue 'dispatch;
	}
	// 82A28D30: 4811D999  bl 0x82b466c8
	ctx.lr = 0x82A28D34;
	sub_82B466C8(ctx, base);
	// 82A28D34: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A28D38: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A28D3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A28D40: 38AAAE60  addi r5, r10, -0x51a0
	ctx.r[5].s64 = ctx.r[10].s64 + -20896;
	// 82A28D44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A28D48: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82A28D4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A28D50: 4E800421  bctrl
	ctx.lr = 0x82A28D54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A28D54: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A28D58: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82A28D5C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A28D60: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A28D64: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A28D68: 4B89B6F9  bl 0x822c4460
	ctx.lr = 0x82A28D6C;
	sub_822C4460(ctx, base);
	// 82A28D6C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A28D70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A28D74: 419A0008  beq cr6, 0x82a28d7c
	if ctx.cr[6].eq {
	pc = 0x82A28D7C; continue 'dispatch;
	}
	// 82A28D78: 4B897B19  bl 0x822c0890
	ctx.lr = 0x82A28D7C;
	sub_822C0890(ctx, base);
	// 82A28D7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A28D80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A28D84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A28D88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A28D8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A28D90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A28D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A28D98 size=224
    let mut pc: u32 = 0x82A28D98;
    'dispatch: loop {
        match pc {
            0x82A28D98 => {
    //   block [0x82A28D98..0x82A28E78)
	// 82A28D98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A28D9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A28DA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A28DA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A28DA8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A28DAC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A28DB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A28DB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A28DB8: 808B13D0  lwz r4, 0x13d0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5072 as u32) ) } as u64;
	// 82A28DBC: 483CAC4D  bl 0x82df3a08
	ctx.lr = 0x82A28DC0;
	sub_82DF3A08(ctx, base);
	// 82A28DC0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A28DC4: 809F00F8  lwz r4, 0xf8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82A28DC8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A28DCC: 4818A545  bl 0x82bb3310
	ctx.lr = 0x82A28DD0;
	sub_82BB3310(ctx, base);
	// 82A28DD0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A28DD4: 395F0100  addi r10, r31, 0x100
	ctx.r[10].s64 = ctx.r[31].s64 + 256;
	// 82A28DD8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A28DDC: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82A28DE0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A28DE4: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 82A28DE8: 4B89B679  bl 0x822c4460
	ctx.lr = 0x82A28DEC;
	sub_822C4460(ctx, base);
	// 82A28DEC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A28DF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A28DF4: 419A0008  beq cr6, 0x82a28dfc
	if ctx.cr[6].eq {
	pc = 0x82A28DFC; continue 'dispatch;
	}
	// 82A28DF8: 4B897A99  bl 0x822c0890
	ctx.lr = 0x82A28DFC;
	sub_822C0890(ctx, base);
	// 82A28DFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A28E00: 483CA629  bl 0x82df3428
	ctx.lr = 0x82A28E04;
	sub_82DF3428(ctx, base);
	// 82A28E04: 807F0168  lwz r3, 0x168(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82A28E08: 3BDF0168  addi r30, r31, 0x168
	ctx.r[30].s64 = ctx.r[31].s64 + 360;
	// 82A28E0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A28E10: 419A0008  beq cr6, 0x82a28e18
	if ctx.cr[6].eq {
	pc = 0x82A28E18; continue 'dispatch;
	}
	// 82A28E14: 4811D8B5  bl 0x82b466c8
	ctx.lr = 0x82A28E18;
	sub_82B466C8(ctx, base);
	// 82A28E18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A28E1C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A28E20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A28E24: 38AAAE60  addi r5, r10, -0x51a0
	ctx.r[5].s64 = ctx.r[10].s64 + -20896;
	// 82A28E28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A28E2C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82A28E30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A28E34: 4E800421  bctrl
	ctx.lr = 0x82A28E38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A28E38: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A28E3C: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82A28E40: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A28E44: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A28E48: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A28E4C: 4B89B615  bl 0x822c4460
	ctx.lr = 0x82A28E50;
	sub_822C4460(ctx, base);
	// 82A28E50: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A28E54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A28E58: 419A0008  beq cr6, 0x82a28e60
	if ctx.cr[6].eq {
	pc = 0x82A28E60; continue 'dispatch;
	}
	// 82A28E5C: 4B897A35  bl 0x822c0890
	ctx.lr = 0x82A28E60;
	sub_822C0890(ctx, base);
	// 82A28E60: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A28E64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A28E68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A28E6C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A28E70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A28E74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A28E78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A28E78 size=104
    let mut pc: u32 = 0x82A28E78;
    'dispatch: loop {
        match pc {
            0x82A28E78 => {
    //   block [0x82A28E78..0x82A28EE0)
	// 82A28E78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A28E7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A28E80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A28E84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A28E88: 39630140  addi r11, r3, 0x140
	ctx.r[11].s64 = ctx.r[3].s64 + 320;
	// 82A28E8C: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 82A28E90: 3FE08338  lis r31, -0x7cc8
	ctx.r[31].s64 = -2093481984;
	// 82A28E94: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A28E98: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A28E9C: 13C450C7  vcmpequd (lvx128) v30, v4, v10
	tmp.u32 = ctx.r[4].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A28EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A28EE0 size=136
    let mut pc: u32 = 0x82A28EE0;
    'dispatch: loop {
        match pc {
            0x82A28EE0 => {
    //   block [0x82A28EE0..0x82A28F68)
	// 82A28EE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A28EE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A28EE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A28EEC: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A28F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A28F68 size=352
    let mut pc: u32 = 0x82A28F68;
    'dispatch: loop {
        match pc {
            0x82A28F68 => {
    //   block [0x82A28F68..0x82A290C8)
	// 82A28F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A28F6C: 4877F1FD  bl 0x831a8168
	ctx.lr = 0x82A28F70;
	sub_831A8130(ctx, base);
	// 82A28F70: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A28F74: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A28F78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A28F7C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A28F80: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A28F84: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82A28F88: 409A0134  bne cr6, 0x82a290bc
	if !ctx.cr[6].eq {
	pc = 0x82A290BC; continue 'dispatch;
	}
	// 82A28F8C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A28F90: 3B9E0050  addi r28, r30, 0x50
	ctx.r[28].s64 = ctx.r[30].s64 + 80;
	// 82A28F94: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 82A28F98: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A28F9C: 4BB2F14D  bl 0x825580e8
	ctx.lr = 0x82A28FA0;
	sub_825580E8(ctx, base);
	// 82A28FA0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A28FA4: 41820118  beq 0x82a290bc
	if ctx.cr[0].eq {
	pc = 0x82A290BC; continue 'dispatch;
	}
	// 82A28FA8: 3FA08200  lis r29, -0x7e00
	ctx.r[29].s64 = -2113929216;
	// 82A28FAC: C01C0000  lfs f0, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A28FB0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A28FB4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A28FB8: C1BE0058  lfs f13, 0x58(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A28FBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A28FC0: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A28FC4: 388BA0F4  addi r4, r11, -0x5f0c
	ctx.r[4].s64 = ctx.r[11].s64 + -24332;
	// 82A28FC8: C01D08A4  lfs f0, 0x8a4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A28FCC: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A28FD0: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A28FD4: 483CAA35  bl 0x82df3a08
	ctx.lr = 0x82A28FD8;
	sub_82DF3A08(ctx, base);
	// 82A28FD8: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82A28FDC: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 82A28FE0: 4BFE9EE9  bl 0x82a12ec8
	ctx.lr = 0x82A28FE4;
	sub_82A12EC8(ctx, base);
	// 82A28FE4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A28FE8: 483CA321  bl 0x82df3308
	ctx.lr = 0x82A28FEC;
	sub_82DF3308(ctx, base);
	// 82A28FEC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A28FF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A28FF4: 483CA435  bl 0x82df3428
	ctx.lr = 0x82A28FF8;
	sub_82DF3428(ctx, base);
	// 82A28FF8: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A28FFC: 4182000C  beq 0x82a29008
	if ctx.cr[0].eq {
	pc = 0x82A29008; continue 'dispatch;
	}
	// 82A29000: C01D08A4  lfs f0, 0x8a4(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A29004: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A29008: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82A2900C: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 82A29010: 485DFFA9  bl 0x83008fb8
	ctx.lr = 0x82A29014;
	sub_83008FB8(ctx, base);
	// 82A29014: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A29018: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2901C: 485DF10D  bl 0x83008128
	ctx.lr = 0x82A29020;
	sub_83008128(ctx, base);
	// 82A29020: 7F03E840  cmplw cr6, r3, r29
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A29024: 409A0014  bne cr6, 0x82a29038
	if !ctx.cr[6].eq {
	pc = 0x82A29038; continue 'dispatch;
	}
	// 82A29028: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A2902C: 807F0118  lwz r3, 0x118(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82A29030: 4B8C4121  bl 0x822ed150
	ctx.lr = 0x82A29034;
	sub_822ED150(ctx, base);
	// 82A29034: 48000058  b 0x82a2908c
	pc = 0x82A2908C; continue 'dispatch;
	// 82A29038: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82A2903C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A29040: 388BD0C8  addi r4, r11, -0x2f38
	ctx.r[4].s64 = ctx.r[11].s64 + -12088;
	// 82A29044: 483CA9C5  bl 0x82df3a08
	ctx.lr = 0x82A29048;
	sub_82DF3A08(ctx, base);
	// 82A29048: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A2904C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A29050: 809F00F8  lwz r4, 0xf8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82A29054: 4818A2BD  bl 0x82bb3310
	ctx.lr = 0x82A29058;
	sub_82BB3310(ctx, base);
	// 82A29058: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A2905C: 395F0100  addi r10, r31, 0x100
	ctx.r[10].s64 = ctx.r[31].s64 + 256;
	// 82A29060: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A29064: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82A29068: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2906C: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 82A29070: 4B89B3F1  bl 0x822c4460
	ctx.lr = 0x82A29074;
	sub_822C4460(ctx, base);
	// 82A29074: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A29078: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2907C: 419A0008  beq cr6, 0x82a29084
	if ctx.cr[6].eq {
	pc = 0x82A29084; continue 'dispatch;
	}
	// 82A29080: 4B897811  bl 0x822c0890
	ctx.lr = 0x82A29084;
	sub_822C0890(ctx, base);
	// 82A29084: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A29088: 483CA3A1  bl 0x82df3428
	ctx.lr = 0x82A2908C;
	sub_82DF3428(ctx, base);
	// 82A2908C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A29090: 809F0128  lwz r4, 0x128(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 82A29094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A29098: C3EB9450  lfs f31, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A2909C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A290A0: 4BAE8BE1  bl 0x82511c80
	ctx.lr = 0x82A290A4;
	sub_82511C80(ctx, base);
	// 82A290A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A290A8: D3FF0158  stfs f31, 0x158(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), tmp.u32 ) };
	// 82A290AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A290B0: 809F012C  lwz r4, 0x12c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 82A290B4: 997F0171  stb r11, 0x171(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(369 as u32), ctx.r[11].u8 ) };
	// 82A290B8: 4BAE8C09  bl 0x82511cc0
	ctx.lr = 0x82A290BC;
	sub_82511CC0(ctx, base);
	// 82A290BC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A290C0: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A290C4: 4877F0F4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A290C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A290C8 size=104
    let mut pc: u32 = 0x82A290C8;
    'dispatch: loop {
        match pc {
            0x82A290C8 => {
    //   block [0x82A290C8..0x82A29130)
	// 82A290C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A290CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A290D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A290D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A290D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A290DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A290E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A290E4: 48000014  b 0x82a290f8
	pc = 0x82A290F8; continue 'dispatch;
	// 82A290E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A290EC: 483DAEF5  bl 0x82e03fe0
	ctx.lr = 0x82A290F0;
	sub_82E03FE0(ctx, base);
	// 82A290F0: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 82A290F4: 483C94F5  bl 0x82df25e8
	ctx.lr = 0x82A290F8;
	sub_82DF25E8(ctx, base);
	// 82A290F8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A290FC: 4818B71D  bl 0x82bb4818
	ctx.lr = 0x82A29100;
	sub_82BB4818(ctx, base);
	// 82A29100: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A29104: 4182FFE4  beq 0x82a290e8
	if ctx.cr[0].eq {
	pc = 0x82A290E8; continue 'dispatch;
	}
	// 82A29108: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A2910C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A29110: 419A0008  beq cr6, 0x82a29118
	if ctx.cr[6].eq {
	pc = 0x82A29118; continue 'dispatch;
	}
	// 82A29114: 4B89777D  bl 0x822c0890
	ctx.lr = 0x82A29118;
	sub_822C0890(ctx, base);
	// 82A29118: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A2911C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A29120: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A29124: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A29128: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A2912C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A29130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A29130 size=292
    let mut pc: u32 = 0x82A29130;
    'dispatch: loop {
        match pc {
            0x82A29130 => {
    //   block [0x82A29130..0x82A29254)
	// 82A29130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A29134: 4877F039  bl 0x831a816c
	ctx.lr = 0x82A29138;
	sub_831A8130(ctx, base);
	// 82A29138: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82A2913C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A29140: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A29144: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A29148: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A2914C: 396B1470  addi r11, r11, 0x1470
	ctx.r[11].s64 = ctx.r[11].s64 + 5232;
	// 82A29150: 57C9103A  slwi r9, r30, 2
	ctx.r[9].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A29154: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82A29158: 3CE08332  lis r7, -0x7cce
	ctx.r[7].s64 = -2093875200;
	// 82A2915C: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A29160: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A29164: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A29168: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A2916C: 7DA95C2E  lfsx f13, r9, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A29170: 38A7BA80  addi r5, r7, -0x4580
	ctx.r[5].s64 = ctx.r[7].s64 + -17792;
	// 82A29174: C00808A8  lfs f0, 0x8a8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A29178: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2917C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A29180: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82A29184: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82A29188: 4BAE90D9  bl 0x82512260
	ctx.lr = 0x82A2918C;
	sub_82512260(ctx, base);
	// 82A2918C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A29190: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A29194: 93BF00E8  stw r29, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[29].u32 ) };
	// 82A29198: 394AAEA4  addi r10, r10, -0x515c
	ctx.r[10].s64 = ctx.r[10].s64 + -20828;
	// 82A2919C: 93DF00EC  stw r30, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[30].u32 ) };
	// 82A291A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A291A4: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82A291A8: 3929AE8C  addi r9, r9, -0x5174
	ctx.r[9].s64 = ctx.r[9].s64 + -20852;
	// 82A291AC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A291B0: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A291B4: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82A291B8: 39200140  li r9, 0x140
	ctx.r[9].s64 = 320;
	// 82A291BC: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 82A291C0: 394A6910  addi r10, r10, 0x6910
	ctx.r[10].s64 = ctx.r[10].s64 + 26896;
	// 82A291C4: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 82A291C8: 3D008338  lis r8, -0x7cc8
	ctx.r[8].s64 = -2093481984;
	// 82A291CC: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 82A291D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A291D4: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 82A291D8: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 82A291DC: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 82A291E0: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 82A291E4: 917F010C  stw r11, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 82A291E8: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82A291EC: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 82A291F0: 917F0118  stw r11, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 82A291F4: 917F011C  stw r11, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[11].u32 ) };
	// 82A291F8: 917F0120  stw r11, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 82A291FC: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 82A29200: 917F0128  stw r11, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 82A29204: 917F012C  stw r11, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[11].u32 ) };
	// 82A29208: 917F0130  stw r11, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 82A2920C: 917F0134  stw r11, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[11].u32 ) };
	// 82A29210: D3FF0138  stfs f31, 0x138(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 82A29214: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A29258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A29258 size=8
    let mut pc: u32 = 0x82A29258;
    'dispatch: loop {
        match pc {
            0x82A29258 => {
    //   block [0x82A29258..0x82A29260)
	// 82A29258: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82A2925C: 48000444  b 0x82a296a0
	sub_82A296A0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A29260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A29260 size=232
    let mut pc: u32 = 0x82A29260;
    'dispatch: loop {
        match pc {
            0x82A29260 => {
    //   block [0x82A29260..0x82A29348)
	// 82A29260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A29264: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A29268: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2926C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A29270: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A29274: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A29278: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A2927C: 396BAEA4  addi r11, r11, -0x515c
	ctx.r[11].s64 = ctx.r[11].s64 + -20828;
	// 82A29280: 394AAE8C  addi r10, r10, -0x5174
	ctx.r[10].s64 = ctx.r[10].s64 + -20852;
	// 82A29284: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A29288: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82A2928C: 807F016C  lwz r3, 0x16c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 82A29290: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A29294: 419A0008  beq cr6, 0x82a2929c
	if ctx.cr[6].eq {
	pc = 0x82A2929C; continue 'dispatch;
	}
	// 82A29298: 4B8975F9  bl 0x822c0890
	ctx.lr = 0x82A2929C;
	sub_822C0890(ctx, base);
	// 82A2929C: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82A292A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A292A4: 419A0008  beq cr6, 0x82a292ac
	if ctx.cr[6].eq {
	pc = 0x82A292AC; continue 'dispatch;
	}
	// 82A292A8: 4B8975E9  bl 0x822c0890
	ctx.lr = 0x82A292AC;
	sub_822C0890(ctx, base);
	// 82A292AC: 807F0134  lwz r3, 0x134(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82A292B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A292B4: 419A0008  beq cr6, 0x82a292bc
	if ctx.cr[6].eq {
	pc = 0x82A292BC; continue 'dispatch;
	}
	// 82A292B8: 4B8975D9  bl 0x822c0890
	ctx.lr = 0x82A292BC;
	sub_822C0890(ctx, base);
	// 82A292BC: 807F0124  lwz r3, 0x124(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 82A292C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A292C4: 419A0008  beq cr6, 0x82a292cc
	if ctx.cr[6].eq {
	pc = 0x82A292CC; continue 'dispatch;
	}
	// 82A292C8: 4B8975C9  bl 0x822c0890
	ctx.lr = 0x82A292CC;
	sub_822C0890(ctx, base);
	// 82A292CC: 807F011C  lwz r3, 0x11c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 82A292D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A292D4: 419A0008  beq cr6, 0x82a292dc
	if ctx.cr[6].eq {
	pc = 0x82A292DC; continue 'dispatch;
	}
	// 82A292D8: 4B8975B9  bl 0x822c0890
	ctx.lr = 0x82A292DC;
	sub_822C0890(ctx, base);
	// 82A292DC: 807F0114  lwz r3, 0x114(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 82A292E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A292E4: 419A0008  beq cr6, 0x82a292ec
	if ctx.cr[6].eq {
	pc = 0x82A292EC; continue 'dispatch;
	}
	// 82A292E8: 4B8975A9  bl 0x822c0890
	ctx.lr = 0x82A292EC;
	sub_822C0890(ctx, base);
	// 82A292EC: 807F010C  lwz r3, 0x10c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 82A292F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A292F4: 419A0008  beq cr6, 0x82a292fc
	if ctx.cr[6].eq {
	pc = 0x82A292FC; continue 'dispatch;
	}
	// 82A292F8: 4B897599  bl 0x822c0890
	ctx.lr = 0x82A292FC;
	sub_822C0890(ctx, base);
	// 82A292FC: 807F0104  lwz r3, 0x104(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A29300: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A29304: 419A0008  beq cr6, 0x82a2930c
	if ctx.cr[6].eq {
	pc = 0x82A2930C; continue 'dispatch;
	}
	// 82A29308: 4B897589  bl 0x822c0890
	ctx.lr = 0x82A2930C;
	sub_822C0890(ctx, base);
	// 82A2930C: 807F00FC  lwz r3, 0xfc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82A29310: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A29314: 419A0008  beq cr6, 0x82a2931c
	if ctx.cr[6].eq {
	pc = 0x82A2931C; continue 'dispatch;
	}
	// 82A29318: 4B897579  bl 0x822c0890
	ctx.lr = 0x82A2931C;
	sub_822C0890(ctx, base);
	// 82A2931C: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A29320: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A29324: 419A0008  beq cr6, 0x82a2932c
	if ctx.cr[6].eq {
	pc = 0x82A2932C; continue 'dispatch;
	}
	// 82A29328: 4B897569  bl 0x822c0890
	ctx.lr = 0x82A2932C;
	sub_822C0890(ctx, base);
	// 82A2932C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A29330: 4B926021  bl 0x8234f350
	ctx.lr = 0x82A29334;
	sub_8234F350(ctx, base);
	// 82A29334: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A29338: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2933C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A29340: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A29344: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A29348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A29348 size=188
    let mut pc: u32 = 0x82A29348;
    'dispatch: loop {
        match pc {
            0x82A29348 => {
    //   block [0x82A29348..0x82A29404)
	// 82A29348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2934C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A29350: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A29354: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A29358: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2935C: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82A29360: 807F0118  lwz r3, 0x118(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82A29364: 4B8C3BE5  bl 0x822ecf48
	ctx.lr = 0x82A29368;
	sub_822ECF48(ctx, base);
	// 82A29368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2936C: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82A29370: 4BFFF889  bl 0x82a28bf8
	ctx.lr = 0x82A29374;
	sub_82A28BF8(ctx, base);
	// 82A29374: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A29378: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A2937C: 394A1480  addi r10, r10, 0x1480
	ctx.r[10].s64 = ctx.r[10].s64 + 5248;
	// 82A29380: 396B137C  addi r11, r11, 0x137c
	ctx.r[11].s64 = ctx.r[11].s64 + 4988;
	// 82A29384: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A29388: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82A2938C: C00A0004  lfs f0, 4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A29390: C06908A4  lfs f3, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82A29394: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 82A29398: 815F00EC  lwz r10, 0xec(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A2939C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A293A0: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A293A4: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A293A8: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A293AC: FC400050  fneg f2, f0
	ctx.f[2].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82A293B0: 48452C69  bl 0x82e7c018
	ctx.lr = 0x82A293B4;
	sub_82E7C018(ctx, base);
	// 82A293B4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A293B8: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82A293BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A293C0: 4B89B541  bl 0x822c4900
	ctx.lr = 0x82A293C4;
	sub_822C4900(ctx, base);
	// 82A293C4: C0010090  lfs f0, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A293C8: C1A10094  lfs f13, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A293CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A293D0: C1810098  lfs f12, 0x98(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A293D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A293D8: C161009C  lfs f11, 0x9c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A293DC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A293E0: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A293E4: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82A293E8: D161005C  stfs f11, 0x5c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82A293EC: 4BAE8695  bl 0x82511a80
	ctx.lr = 0x82A293F0;
	sub_82511A80(ctx, base);
	// 82A293F0: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82A293F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A293F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A293FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A29400: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A29408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A29408 size=212
    let mut pc: u32 = 0x82A29408;
    'dispatch: loop {
        match pc {
            0x82A29408 => {
    //   block [0x82A29408..0x82A294DC)
	// 82A29408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2940C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A29410: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A29414: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A29418: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2941C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A29420: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 82A29424: 807F0118  lwz r3, 0x118(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82A29428: 4B8C3D29  bl 0x822ed150
	ctx.lr = 0x82A2942C;
	sub_822ED150(ctx, base);
	// 82A2942C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82A29430: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A29434: 388B0380  addi r4, r11, 0x380
	ctx.r[4].s64 = ctx.r[11].s64 + 896;
	// 82A29438: 483CA5D1  bl 0x82df3a08
	ctx.lr = 0x82A2943C;
	sub_82DF3A08(ctx, base);
	// 82A2943C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A29440: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A29444: 809F00F8  lwz r4, 0xf8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82A29448: 48189EC9  bl 0x82bb3310
	ctx.lr = 0x82A2944C;
	sub_82BB3310(ctx, base);
	// 82A2944C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A29450: 395F0100  addi r10, r31, 0x100
	ctx.r[10].s64 = ctx.r[31].s64 + 256;
	// 82A29454: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A29458: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82A2945C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A29460: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 82A29464: 4B89AFFD  bl 0x822c4460
	ctx.lr = 0x82A29468;
	sub_822C4460(ctx, base);
	// 82A29468: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A2946C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A29470: 419A0008  beq cr6, 0x82a29478
	if ctx.cr[6].eq {
	pc = 0x82A29478; continue 'dispatch;
	}
	// 82A29474: 4B89741D  bl 0x822c0890
	ctx.lr = 0x82A29478;
	sub_822C0890(ctx, base);
	// 82A29478: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2947C: 483C9FAD  bl 0x82df3428
	ctx.lr = 0x82A29480;
	sub_82DF3428(ctx, base);
	// 82A29480: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A29484: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A29488: 807F0118  lwz r3, 0x118(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82A2948C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A29490: 396B1470  addi r11, r11, 0x1470
	ctx.r[11].s64 = ctx.r[11].s64 + 5232;
	// 82A29494: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A29498: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A2949C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A294A0: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A294A4: C1A908A8  lfs f13, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A294A8: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A294AC: 815F00EC  lwz r10, 0xec(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A294B0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A294B4: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A294B8: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A294BC: 4B8C4265  bl 0x822ed720
	ctx.lr = 0x82A294C0;
	sub_822ED720(ctx, base);
	// 82A294C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A294C4: 4BFFFE85  bl 0x82a29348
	ctx.lr = 0x82A294C8;
	sub_82A29348(ctx, base);
	// 82A294C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A294CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A294D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A294D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A294D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A294E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A294E0 size=156
    let mut pc: u32 = 0x82A294E0;
    'dispatch: loop {
        match pc {
            0x82A294E0 => {
    //   block [0x82A294E0..0x82A2957C)
	// 82A294E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A294E4: 4877EC89  bl 0x831a816c
	ctx.lr = 0x82A294E8;
	sub_831A8130(ctx, base);
	// 82A294E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A294EC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A294F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A294F4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A294F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A294FC: 419A0068  beq cr6, 0x82a29564
	if ctx.cr[6].eq {
	pc = 0x82A29564; continue 'dispatch;
	}
	// 82A29500: 4818B319  bl 0x82bb4818
	ctx.lr = 0x82A29504;
	sub_82BB4818(ctx, base);
	// 82A29504: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A29508: 4082005C  bne 0x82a29564
	if !ctx.cr[0].eq {
	pc = 0x82A29564; continue 'dispatch;
	}
	// 82A2950C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A29510: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 82A29514: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A29518: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2951C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A29520: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A29524: 419A0024  beq cr6, 0x82a29548
	if ctx.cr[6].eq {
	pc = 0x82A29548; continue 'dispatch;
	}
	// 82A29528: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A2952C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A29530: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A29534: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A29538: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A2953C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A29540: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A29544: 4082FFE8  bne 0x82a2952c
	if !ctx.cr[0].eq {
	pc = 0x82A2952C; continue 'dispatch;
	}
	// 82A29548: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A2954C: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 82A29550: 4BAC0221  bl 0x824e9770
	ctx.lr = 0x82A29554;
	sub_824E9770(ctx, base);
	// 82A29554: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A29558: 4BFFFB71  bl 0x82a290c8
	ctx.lr = 0x82A2955C;
	sub_82A290C8(ctx, base);
	// 82A2955C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A29560: 48000008  b 0x82a29568
	pc = 0x82A29568; continue 'dispatch;
	// 82A29564: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A29568: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2956C: 419A0008  beq cr6, 0x82a29574
	if ctx.cr[6].eq {
	pc = 0x82A29574; continue 'dispatch;
	}
	// 82A29570: 4B897321  bl 0x822c0890
	ctx.lr = 0x82A29574;
	sub_822C0890(ctx, base);
	// 82A29574: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A29578: 4877EC44  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A29580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A29580 size=156
    let mut pc: u32 = 0x82A29580;
    'dispatch: loop {
        match pc {
            0x82A29580 => {
    //   block [0x82A29580..0x82A2961C)
	// 82A29580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A29584: 4877EBDD  bl 0x831a8160
	ctx.lr = 0x82A29588;
	sub_831A8130(ctx, base);
	// 82A29588: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2958C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A29590: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A29594: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A29598: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A2959C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82A295A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A295A4: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A295A8: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82A295AC: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 82A295B0: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82A295B4: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82A295B8: 483C8E31  bl 0x82df23e8
	ctx.lr = 0x82A295BC;
	sub_82DF23E8(ctx, base);
	// 82A295BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A295C0: 41820028  beq 0x82a295e8
	if ctx.cr[0].eq {
	pc = 0x82A295E8; continue 'dispatch;
	}
	// 82A295C4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A295C8: 80DD0000  lwz r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A295CC: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 82A295D0: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A295D4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A295D8: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A295DC: 48128E55  bl 0x82b52430
	ctx.lr = 0x82A295E0;
	sub_82B52430(ctx, base);
	// 82A295E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A295E4: 48000008  b 0x82a295ec
	pc = 0x82A295EC; continue 'dispatch;
	// 82A295E8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A295EC: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A295F0: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 82A295F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A295F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A295FC: 4B92FEA5  bl 0x823594a0
	ctx.lr = 0x82A29600;
	sub_823594A0(ctx, base);
	// 82A29600: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A29604: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A29608: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2960C: 4B8969F5  bl 0x822c0000
	ctx.lr = 0x82A29610;
	sub_822C0000(ctx, base);
	// 82A29610: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A29614: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A29618: 4877EB98  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A29620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A29620 size=128
    let mut pc: u32 = 0x82A29620;
    'dispatch: loop {
        match pc {
            0x82A29620 => {
    //   block [0x82A29620..0x82A296A0)
	// 82A29620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A29624: 4877EB49  bl 0x831a816c
	ctx.lr = 0x82A29628;
	sub_831A8130(ctx, base);
	// 82A29628: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2962C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A29630: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A29634: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A29638: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A2963C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A29640: 388BAEE0  addi r4, r11, -0x5120
	ctx.r[4].s64 = ctx.r[11].s64 + -20768;
	// 82A29644: 38A000AF  li r5, 0xaf
	ctx.r[5].s64 = 175;
	// 82A29648: 38600180  li r3, 0x180
	ctx.r[3].s64 = 384;
	// 82A2964C: 483C8D9D  bl 0x82df23e8
	ctx.lr = 0x82A29650;
	sub_82DF23E8(ctx, base);
	// 82A29650: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A29654: 41820018  beq 0x82a2966c
	if ctx.cr[0].eq {
	pc = 0x82A2966C; continue 'dispatch;
	}
	// 82A29658: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A2965C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A29660: 4BFFFAD1  bl 0x82a29130
	ctx.lr = 0x82A29664;
	sub_82A29130(ctx, base);
	// 82A29664: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A29668: 48000008  b 0x82a29670
	pc = 0x82A29670; continue 'dispatch;
	// 82A2966C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A29670: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A29674: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A29678: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2967C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A29680: 4BFFF3C1  bl 0x82a28a40
	ctx.lr = 0x82A29684;
	sub_82A28A40(ctx, base);
	// 82A29684: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A29688: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2968C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A29690: 4B896971  bl 0x822c0000
	ctx.lr = 0x82A29694;
	sub_822C0000(ctx, base);
	// 82A29694: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A29698: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A2969C: 4877EB20  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A296A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A296A0 size=76
    let mut pc: u32 = 0x82A296A0;
    'dispatch: loop {
        match pc {
            0x82A296A0 => {
    //   block [0x82A296A0..0x82A296EC)
	// 82A296A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A296A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A296A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A296AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A296B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A296B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A296B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A296BC: 4BFFFBA5  bl 0x82a29260
	ctx.lr = 0x82A296C0;
	sub_82A29260(ctx, base);
	// 82A296C0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A296C4: 4182000C  beq 0x82a296d0
	if ctx.cr[0].eq {
	pc = 0x82A296D0; continue 'dispatch;
	}
	// 82A296C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A296CC: 483C8D0D  bl 0x82df23d8
	ctx.lr = 0x82A296D0;
	sub_82DF23D8(ctx, base);
	// 82A296D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A296D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A296D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A296DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A296E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A296E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A296E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A296F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A296F0 size=528
    let mut pc: u32 = 0x82A296F0;
    'dispatch: loop {
        match pc {
            0x82A296F0 => {
    //   block [0x82A296F0..0x82A29900)
	// 82A296F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A296F4: 4877EA71  bl 0x831a8164
	ctx.lr = 0x82A296F8;
	sub_831A8130(ctx, base);
	// 82A296F8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A296FC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A29700: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A29704: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A29708: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A2970C: 3B8BAEE0  addi r28, r11, -0x5120
	ctx.r[28].s64 = ctx.r[11].s64 + -20768;
	// 82A29710: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A29714: 38A000EA  li r5, 0xea
	ctx.r[5].s64 = 234;
	// 82A29718: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A2971C: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 82A29720: 483C8CC9  bl 0x82df23e8
	ctx.lr = 0x82A29724;
	sub_82DF23E8(ctx, base);
	// 82A29724: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A29728: 41820040  beq 0x82a29768
	if ctx.cr[0].eq {
	pc = 0x82A29768; continue 'dispatch;
	}
	// 82A2972C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A29730: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A29734: 808B1378  lwz r4, 0x1378(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4984 as u32) ) } as u64;
	// 82A29738: 483CA2D1  bl 0x82df3a08
	ctx.lr = 0x82A2973C;
	sub_82DF3A08(ctx, base);
	// 82A2973C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A29740: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A29744: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 82A29748: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 82A2974C: 4BAE5D7D  bl 0x8250f4c8
	ctx.lr = 0x82A29750;
	sub_8250F4C8(ctx, base);
	// 82A29750: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A29754: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A29758: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A2975C: 4818A4A5  bl 0x82bb3c00
	ctx.lr = 0x82A29760;
	sub_82BB3C00(ctx, base);
	// 82A29760: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A29764: 48000008  b 0x82a2976c
	pc = 0x82A2976C; continue 'dispatch;
	// 82A29768: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A2976C: 3BFD00F8  addi r31, r29, 0xf8
	ctx.r[31].s64 = ctx.r[29].s64 + 248;
	// 82A29770: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A29774: 4B933C6D  bl 0x8235d3e0
	ctx.lr = 0x82A29778;
	sub_8235D3E0(ctx, base);
	// 82A29778: 57CB07BD  rlwinm. r11, r30, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2977C: 41820010  beq 0x82a2978c
	if ctx.cr[0].eq {
	pc = 0x82A2978C; continue 'dispatch;
	}
	// 82A29780: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A29784: 57DE07FA  rlwinm r30, r30, 0, 0x1f, 0x1d
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 82A29788: 483C8509  bl 0x82df1c90
	ctx.lr = 0x82A2978C;
	sub_82DF1C90(ctx, base);
	// 82A2978C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A29790: 4182000C  beq 0x82a2979c
	if ctx.cr[0].eq {
	pc = 0x82A2979C; continue 'dispatch;
	}
	// 82A29794: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A29798: 483C9C91  bl 0x82df3428
	ctx.lr = 0x82A2979C;
	sub_82DF3428(ctx, base);
	// 82A2979C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A297A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A297A4: 419A006C  beq cr6, 0x82a29810
	if ctx.cr[6].eq {
	pc = 0x82A29810; continue 'dispatch;
	}
	// 82A297A8: 4818B071  bl 0x82bb4818
	ctx.lr = 0x82A297AC;
	sub_82BB4818(ctx, base);
	// 82A297AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A297B0: 40820060  bne 0x82a29810
	if !ctx.cr[0].eq {
	pc = 0x82A29810; continue 'dispatch;
	}
	// 82A297B4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A297B8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A297BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A297C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A297C4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A297C8: 419A0024  beq cr6, 0x82a297ec
	if ctx.cr[6].eq {
	pc = 0x82A297EC; continue 'dispatch;
	}
	// 82A297CC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A297D0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A297D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A297D8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A297DC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A297E0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A297E4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A297E8: 4082FFE8  bne 0x82a297d0
	if !ctx.cr[0].eq {
	pc = 0x82A297D0; continue 'dispatch;
	}
	// 82A297EC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A297F0: 4BAC1299  bl 0x824eaa88
	ctx.lr = 0x82A297F4;
	sub_824EAA88(ctx, base);
	// 82A297F4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A297F8: 38C000EB  li r6, 0xeb
	ctx.r[6].s64 = 235;
	// 82A297FC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A29800: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A29804: 4BFFFCDD  bl 0x82a294e0
	ctx.lr = 0x82A29808;
	sub_82A294E0(ctx, base);
	// 82A29808: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A2980C: 483C8485  bl 0x82df1c90
	ctx.lr = 0x82A29810;
	sub_82DF1C90(ctx, base);
	// 82A29810: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A29814: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A29818: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82A2981C: 388B13D0  addi r4, r11, 0x13d0
	ctx.r[4].s64 = ctx.r[11].s64 + 5072;
	// 82A29820: 4818B741  bl 0x82bb4f60
	ctx.lr = 0x82A29824;
	sub_82BB4F60(ctx, base);
	// 82A29824: 817D00F0  lwz r11, 0xf0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(240 as u32) ) } as u64;
	// 82A29828: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A2982C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A29830: 419A0074  beq cr6, 0x82a298a4
	if ctx.cr[6].eq {
	pc = 0x82A298A4; continue 'dispatch;
	}
	// 82A29834: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A29838: 483D4FA9  bl 0x82dfe7e0
	ctx.lr = 0x82A2983C;
	sub_82DFE7E0(ctx, base);
	// 82A2983C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A29840: 40820064  bne 0x82a298a4
	if !ctx.cr[0].eq {
	pc = 0x82A298A4; continue 'dispatch;
	}
	// 82A29844: 817D00F0  lwz r11, 0xf0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(240 as u32) ) } as u64;
	// 82A29848: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A2984C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A29850: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A29854: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A29858: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A2985C: 419A0024  beq cr6, 0x82a29880
	if ctx.cr[6].eq {
	pc = 0x82A29880; continue 'dispatch;
	}
	// 82A29860: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 82A29864: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A29868: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A2986C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A29870: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A29874: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A29878: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A2987C: 4082FFE8  bne 0x82a29864
	if !ctx.cr[0].eq {
	pc = 0x82A29864; continue 'dispatch;
	}
	// 82A29880: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A29884: 4BAC1205  bl 0x824eaa88
	ctx.lr = 0x82A29888;
	sub_824EAA88(ctx, base);
	// 82A29888: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A2988C: 38C000ED  li r6, 0xed
	ctx.r[6].s64 = 237;
	// 82A29890: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A29894: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A29898: 481908E9  bl 0x82bba180
	ctx.lr = 0x82A2989C;
	sub_82BBA180(ctx, base);
	// 82A2989C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A298A0: 483C83F1  bl 0x82df1c90
	ctx.lr = 0x82A298A4;
	sub_82DF1C90(ctx, base);
	// 82A298A4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A298A8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A298AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A298B0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A298B4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A298B8: 419A0024  beq cr6, 0x82a298dc
	if ctx.cr[6].eq {
	pc = 0x82A298DC; continue 'dispatch;
	}
	// 82A298BC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A298C0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A298C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A298C8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A298CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A298D0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A298D4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A298D8: 4082FFE8  bne 0x82a298c0
	if !ctx.cr[0].eq {
	pc = 0x82A298C0; continue 'dispatch;
	}
	// 82A298DC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A298E0: 807D00F0  lwz r3, 0xf0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(240 as u32) ) } as u64;
	// 82A298E4: 483EB68D  bl 0x82e14f70
	ctx.lr = 0x82A298E8;
	sub_82E14F70(ctx, base);
	// 82A298E8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A298EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A298F0: 419A0008  beq cr6, 0x82a298f8
	if ctx.cr[6].eq {
	pc = 0x82A298F8; continue 'dispatch;
	}
	// 82A298F4: 4B896F9D  bl 0x822c0890
	ctx.lr = 0x82A298F8;
	sub_822C0890(ctx, base);
	// 82A298F8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A298FC: 4877E8B8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A29900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A29900 size=252
    let mut pc: u32 = 0x82A29900;
    'dispatch: loop {
        match pc {
            0x82A29900 => {
    //   block [0x82A29900..0x82A299FC)
	// 82A29900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A29904: 4877E869  bl 0x831a816c
	ctx.lr = 0x82A29908;
	sub_831A8130(ctx, base);
	// 82A29908: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2990C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A29910: 809F0130  lwz r4, 0x130(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 82A29914: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82A29918: 419A00DC  beq cr6, 0x82a299f4
	if ctx.cr[6].eq {
	pc = 0x82A299F4; continue 'dispatch;
	}
	// 82A2991C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A29920: 484011C9  bl 0x82e2aae8
	ctx.lr = 0x82A29924;
	sub_82E2AAE8(ctx, base);
	// 82A29924: 815F00EC  lwz r10, 0xec(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A29928: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A2992C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A29930: 396B1360  addi r11, r11, 0x1360
	ctx.r[11].s64 = ctx.r[11].s64 + 4960;
	// 82A29934: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A29938: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A2993C: 483CA0CD  bl 0x82df3a08
	ctx.lr = 0x82A29940;
	sub_82DF3A08(ctx, base);
	// 82A29940: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A29944: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A29948: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A2994C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A29950: 48405521  bl 0x82e2ee70
	ctx.lr = 0x82A29954;
	sub_82E2EE70(ctx, base);
	// 82A29954: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A29958: 483C9AD1  bl 0x82df3428
	ctx.lr = 0x82A2995C;
	sub_82DF3428(ctx, base);
	// 82A2995C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A29960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A29964: 419A0078  beq cr6, 0x82a299dc
	if ctx.cr[6].eq {
	pc = 0x82A299DC; continue 'dispatch;
	}
	// 82A29968: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A2996C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A29970: 388BAEE0  addi r4, r11, -0x5120
	ctx.r[4].s64 = ctx.r[11].s64 + -20768;
	// 82A29974: 38A00329  li r5, 0x329
	ctx.r[5].s64 = 809;
	// 82A29978: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82A2997C: 483C8A6D  bl 0x82df23e8
	ctx.lr = 0x82A29980;
	sub_82DF23E8(ctx, base);
	// 82A29980: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A29984: 41820014  beq 0x82a29998
	if ctx.cr[0].eq {
	pc = 0x82A29998; continue 'dispatch;
	}
	// 82A29988: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A2998C: 483ECF05  bl 0x82e16890
	ctx.lr = 0x82A29990;
	sub_82E16890(ctx, base);
	// 82A29990: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A29994: 48000008  b 0x82a2999c
	pc = 0x82A2999C; continue 'dispatch;
	// 82A29998: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A2999C: 3BDF00F0  addi r30, r31, 0xf0
	ctx.r[30].s64 = ctx.r[31].s64 + 240;
	// 82A299A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A299A4: 4B9339CD  bl 0x8235d370
	ctx.lr = 0x82A299A8;
	sub_8235D370(ctx, base);
	// 82A299A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A299AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A299B0: 83BF00F0  lwz r29, 0xf0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82A299B4: 4BAE8765  bl 0x82512118
	ctx.lr = 0x82A299B8;
	sub_82512118(ctx, base);
	// 82A299B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A299BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A299C0: 483EB6F1  bl 0x82e150b0
	ctx.lr = 0x82A299C4;
	sub_82E150B0(ctx, base);
	// 82A299C4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A299C8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A299CC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A299D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A299D4: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A299D8: 4BAE7181  bl 0x82510b58
	ctx.lr = 0x82A299DC;
	sub_82510B58(ctx, base);
	// 82A299DC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A299E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A299E4: 419A0008  beq cr6, 0x82a299ec
	if ctx.cr[6].eq {
	pc = 0x82A299EC; continue 'dispatch;
	}
	// 82A299E8: 4B896EA9  bl 0x822c0890
	ctx.lr = 0x82A299EC;
	sub_822C0890(ctx, base);
	// 82A299EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A299F0: 48401111  bl 0x82e2ab00
	ctx.lr = 0x82A299F4;
	sub_82E2AB00(ctx, base);
	// 82A299F4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A299F8: 4877E7C4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A29A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A29A00 size=392
    let mut pc: u32 = 0x82A29A00;
    'dispatch: loop {
        match pc {
            0x82A29A00 => {
    //   block [0x82A29A00..0x82A29B88)
	// 82A29A00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A29A04: 4877E769  bl 0x831a816c
	ctx.lr = 0x82A29A08;
	sub_831A8130(ctx, base);
	// 82A29A08: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A29A0C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A29A10: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A29A14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A29A18: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A29A1C: 816BDDC0  lwz r11, -0x2240(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8768 as u32) ) } as u64;
	// 82A29A20: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A29A24: 409A015C  bne cr6, 0x82a29b80
	if !ctx.cr[6].eq {
	pc = 0x82A29B80; continue 'dispatch;
	}
	// 82A29A28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A29A2C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A29A30: 4BAE5A99  bl 0x8250f4c8
	ctx.lr = 0x82A29A34;
	sub_8250F4C8(ctx, base);
	// 82A29A34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A29A38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A29A3C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82A29A40: 409A0008  bne cr6, 0x82a29a48
	if !ctx.cr[6].eq {
	pc = 0x82A29A48; continue 'dispatch;
	}
	// 82A29A44: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A29A48: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A29A4C: 4BADEFCD  bl 0x82508a18
	ctx.lr = 0x82A29A50;
	sub_82508A18(ctx, base);
	// 82A29A50: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A29A54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A29A58: 485DE6D1  bl 0x83008128
	ctx.lr = 0x82A29A5C;
	sub_83008128(ctx, base);
	// 82A29A5C: 7D63E850  subf r11, r3, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[3].s64;
	// 82A29A60: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A29A64: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82A29A68: 557DDFFE  rlwinm r29, r11, 0x1b, 0x1f, 0x1f
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82A29A6C: 483C8225  bl 0x82df1c90
	ctx.lr = 0x82A29A70;
	sub_82DF1C90(ctx, base);
	// 82A29A70: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A29A74: 4182010C  beq 0x82a29b80
	if ctx.cr[0].eq {
	pc = 0x82A29B80; continue 'dispatch;
	}
	// 82A29A78: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A29A7C: 809F0118  lwz r4, 0x118(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82A29A80: 4B8C3519  bl 0x822ecf98
	ctx.lr = 0x82A29A84;
	sub_822ECF98(ctx, base);
	// 82A29A84: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A29A88: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82A29A8C: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A29A90: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 82A29A94: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 82A29A98: 39600032  li r11, 0x32
	ctx.r[11].s64 = 50;
	// 82A29A9C: C00A0A94  lfs f0, 0xa94(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2708 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A29AA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A29AA4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A29AA8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A29AAC: 13C04C07  vcmpneb. (lvlx128) v30, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A29B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A29B88 size=344
    let mut pc: u32 = 0x82A29B88;
    'dispatch: loop {
        match pc {
            0x82A29B88 => {
    //   block [0x82A29B88..0x82A29CE0)
	// 82A29B88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A29B8C: 4877E5DD  bl 0x831a8168
	ctx.lr = 0x82A29B90;
	sub_831A8130(ctx, base);
	// 82A29B90: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A29B94: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A29B98: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A29B9C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A29BA0: 817E0134  lwz r11, 0x134(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(308 as u32) ) } as u64;
	// 82A29BA4: 556BF7FF  rlwinm. r11, r11, 0x1e, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A29BA8: 40820120  bne 0x82a29cc8
	if !ctx.cr[0].eq {
	pc = 0x82A29CC8; continue 'dispatch;
	}
	// 82A29BAC: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A29BB0: 41820038  beq 0x82a29be8
	if ctx.cr[0].eq {
	pc = 0x82A29BE8; continue 'dispatch;
	}
	// 82A29BB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A29BB8: 4877FDD1  bl 0x831a9988
	ctx.lr = 0x82A29BBC;
	sub_831A9988(ctx, base);
	// 82A29BBC: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 82A29BC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A29BC4: 386BA664  addi r3, r11, -0x599c
	ctx.r[3].s64 = ctx.r[11].s64 + -22940;
	// 82A29BC8: 4877E531  bl 0x831a80f8
	ctx.lr = 0x82A29BCC;
	sub_831A80F8(ctx, base);
	// 82A29BCC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A29BD0: 41820018  beq 0x82a29be8
	if ctx.cr[0].eq {
	pc = 0x82A29BE8; continue 'dispatch;
	}
	// 82A29BD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A29BD8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A29BDC: 4BFFF29D  bl 0x82a28e78
	ctx.lr = 0x82A29BE0;
	sub_82A28E78(ctx, base);
	// 82A29BE0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A29BE4: 480000F4  b 0x82a29cd8
	pc = 0x82A29CD8; continue 'dispatch;
	// 82A29BE8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A29BEC: 419A00DC  beq cr6, 0x82a29cc8
	if ctx.cr[6].eq {
	pc = 0x82A29CC8; continue 'dispatch;
	}
	// 82A29BF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A29BF4: 4877FD95  bl 0x831a9988
	ctx.lr = 0x82A29BF8;
	sub_831A9988(ctx, base);
	// 82A29BF8: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 82A29BFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A29C00: 386BFAF0  addi r3, r11, -0x510
	ctx.r[3].s64 = ctx.r[11].s64 + -1296;
	// 82A29C04: 4877E4F5  bl 0x831a80f8
	ctx.lr = 0x82A29C08;
	sub_831A80F8(ctx, base);
	// 82A29C08: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A29C0C: 41820014  beq 0x82a29c20
	if ctx.cr[0].eq {
	pc = 0x82A29C20; continue 'dispatch;
	}
	// 82A29C10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A29C14: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A29C18: 4BFFF2C9  bl 0x82a28ee0
	ctx.lr = 0x82A29C1C;
	sub_82A28EE0(ctx, base);
	// 82A29C1C: 4BFFFFC4  b 0x82a29be0
	pc = 0x82A29BE0; continue 'dispatch;
	// 82A29C20: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A29C24: 419A00A4  beq cr6, 0x82a29cc8
	if ctx.cr[6].eq {
	pc = 0x82A29CC8; continue 'dispatch;
	}
	// 82A29C28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A29C2C: 4877FD5D  bl 0x831a9988
	ctx.lr = 0x82A29C30;
	sub_831A9988(ctx, base);
	// 82A29C30: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 82A29C34: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A29C38: 386B21D0  addi r3, r11, 0x21d0
	ctx.r[3].s64 = ctx.r[11].s64 + 8656;
	// 82A29C3C: 4877E4BD  bl 0x831a80f8
	ctx.lr = 0x82A29C40;
	sub_831A80F8(ctx, base);
	// 82A29C40: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A29C44: 41820014  beq 0x82a29c58
	if ctx.cr[0].eq {
	pc = 0x82A29C58; continue 'dispatch;
	}
	// 82A29C48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A29C4C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A29C50: 4BFFECF9  bl 0x82a28948
	ctx.lr = 0x82A29C54;
	sub_82A28948(ctx, base);
	// 82A29C54: 4BFFFF8C  b 0x82a29be0
	pc = 0x82A29BE0; continue 'dispatch;
	// 82A29C58: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A29C5C: 419A006C  beq cr6, 0x82a29cc8
	if ctx.cr[6].eq {
	pc = 0x82A29CC8; continue 'dispatch;
	}
	// 82A29C60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A29C64: 4877FD25  bl 0x831a9988
	ctx.lr = 0x82A29C68;
	sub_831A9988(ctx, base);
	// 82A29C68: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82A29C6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A29C70: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 82A29C74: 4877E485  bl 0x831a80f8
	ctx.lr = 0x82A29C78;
	sub_831A80F8(ctx, base);
	// 82A29C78: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A29C7C: 41820014  beq 0x82a29c90
	if ctx.cr[0].eq {
	pc = 0x82A29C90; continue 'dispatch;
	}
	// 82A29C80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A29C84: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A29C88: 4BFFF2E1  bl 0x82a28f68
	ctx.lr = 0x82A29C8C;
	sub_82A28F68(ctx, base);
	// 82A29C8C: 4BFFFF54  b 0x82a29be0
	pc = 0x82A29BE0; continue 'dispatch;
	// 82A29C90: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A29C94: 419A0034  beq cr6, 0x82a29cc8
	if ctx.cr[6].eq {
	pc = 0x82A29CC8; continue 'dispatch;
	}
	// 82A29C98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A29C9C: 4877FCED  bl 0x831a9988
	ctx.lr = 0x82A29CA0;
	sub_831A9988(ctx, base);
	// 82A29CA0: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82A29CA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A29CA8: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 82A29CAC: 4877E44D  bl 0x831a80f8
	ctx.lr = 0x82A29CB0;
	sub_831A80F8(ctx, base);
	// 82A29CB0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A29CB4: 41820014  beq 0x82a29cc8
	if ctx.cr[0].eq {
	pc = 0x82A29CC8; continue 'dispatch;
	}
	// 82A29CB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A29CBC: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A29CC0: 4BFFFD41  bl 0x82a29a00
	ctx.lr = 0x82A29CC4;
	sub_82A29A00(ctx, base);
	// 82A29CC4: 4BFFFF1C  b 0x82a29be0
	pc = 0x82A29BE0; continue 'dispatch;
	// 82A29CC8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A29CCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A29CD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A29CD4: 4BAE8945  bl 0x82512618
	ctx.lr = 0x82A29CD8;
	sub_82512618(ctx, base);
	// 82A29CD8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A29CDC: 4877E4DC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A29CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A29CE0 size=28
    let mut pc: u32 = 0x82A29CE0;
    'dispatch: loop {
        match pc {
            0x82A29CE0 => {
    //   block [0x82A29CE0..0x82A29CFC)
	// 82A29CE0: 816300E4  lwz r11, 0xe4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A29CE4: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82A29CE8: 409A0014  bne cr6, 0x82a29cfc
	if !ctx.cr[6].eq {
		sub_82A29CFC(ctx, base);
		return;
	}
	// 82A29CEC: 8163015C  lwz r11, 0x15c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(348 as u32) ) } as u64;
	// 82A29CF0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A29CF4: 556BFFFF  rlwinm. r11, r11, 0x1f, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A29CF8: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A29CFC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A29CFC size=8
    let mut pc: u32 = 0x82A29CFC;
    'dispatch: loop {
        match pc {
            0x82A29CFC => {
    //   block [0x82A29CFC..0x82A29D04)
	// 82A29CFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A29D00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A29D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A29D08 size=12
    let mut pc: u32 = 0x82A29D08;
    'dispatch: loop {
        match pc {
            0x82A29D08 => {
    //   block [0x82A29D08..0x82A29D14)
	// 82A29D08: 8163015C  lwz r11, 0x15c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(348 as u32) ) } as u64;
	// 82A29D0C: 556307FE  clrlwi r3, r11, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82A29D10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A29D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A29D18 size=20
    let mut pc: u32 = 0x82A29D18;
    'dispatch: loop {
        match pc {
            0x82A29D18 => {
    //   block [0x82A29D18..0x82A29D2C)
	// 82A29D18: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A29D1C: 8163015C  lwz r11, 0x15c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(348 as u32) ) } as u64;
	// 82A29D20: 4182000C  beq 0x82a29d2c
	if ctx.cr[0].eq {
		sub_82A29D2C(ctx, base);
		return;
	}
	// 82A29D24: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82A29D28: 48000008  b 0x82a29d30
	sub_82A29D2C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A29D2C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A29D2C size=12
    let mut pc: u32 = 0x82A29D2C;
    'dispatch: loop {
        match pc {
            0x82A29D2C => {
    //   block [0x82A29D2C..0x82A29D38)
	// 82A29D2C: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A29D30: 9163015C  stw r11, 0x15c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(348 as u32), ctx.r[11].u32 ) };
	// 82A29D34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A29D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A29D38 size=20
    let mut pc: u32 = 0x82A29D38;
    'dispatch: loop {
        match pc {
            0x82A29D38 => {
    //   block [0x82A29D38..0x82A29D4C)
	// 82A29D38: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A29D3C: 8163015C  lwz r11, 0x15c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(348 as u32) ) } as u64;
	// 82A29D40: 4182000C  beq 0x82a29d4c
	if ctx.cr[0].eq {
		sub_82A29D4C(ctx, base);
		return;
	}
	// 82A29D44: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 82A29D48: 48000008  b 0x82a29d50
	sub_82A29D4C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A29D4C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A29D4C size=12
    let mut pc: u32 = 0x82A29D4C;
    'dispatch: loop {
        match pc {
            0x82A29D4C => {
    //   block [0x82A29D4C..0x82A29D58)
	// 82A29D4C: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A29D50: 9163015C  stw r11, 0x15c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(348 as u32), ctx.r[11].u32 ) };
	// 82A29D54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A29D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A29D58 size=236
    let mut pc: u32 = 0x82A29D58;
    'dispatch: loop {
        match pc {
            0x82A29D58 => {
    //   block [0x82A29D58..0x82A29E44)
	// 82A29D58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A29D5C: 4877E411  bl 0x831a816c
	ctx.lr = 0x82A29D60;
	sub_831A8130(ctx, base);
	// 82A29D60: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A29D64: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A29D68: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A29D6C: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82A29D70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A29D74: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A29D78: 4BA801F1  bl 0x824a9f68
	ctx.lr = 0x82A29D7C;
	sub_824A9F68(ctx, base);
	// 82A29D7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A29D80: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A29D84: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A29D88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A29D8C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A29D90: 419A0024  beq cr6, 0x82a29db4
	if ctx.cr[6].eq {
	pc = 0x82A29DB4; continue 'dispatch;
	}
	// 82A29D94: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A29D98: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A29D9C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A29DA0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A29DA4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A29DA8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A29DAC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A29DB0: 4082FFE8  bne 0x82a29d98
	if !ctx.cr[0].eq {
	pc = 0x82A29D98; continue 'dispatch;
	}
	// 82A29DB4: 3BFE0028  addi r31, r30, 0x28
	ctx.r[31].s64 = ctx.r[30].s64 + 40;
	// 82A29DB8: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 82A29DBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A29DC0: 485DF1F9  bl 0x83008fb8
	ctx.lr = 0x82A29DC4;
	sub_83008FB8(ctx, base);
	// 82A29DC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A29DC8: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A29DCC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A29DD0: 388AAEE0  addi r4, r10, -0x5120
	ctx.r[4].s64 = ctx.r[10].s64 + -20768;
	// 82A29DD4: 38A00333  li r5, 0x333
	ctx.r[5].s64 = 819;
	// 82A29DD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A29DDC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A29DE0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A29DE4: 4842EC5D  bl 0x82e58a40
	ctx.lr = 0x82A29DE8;
	sub_82E58A40(ctx, base);
	// 82A29DE8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A29DEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A29DF0: 419A0008  beq cr6, 0x82a29df8
	if ctx.cr[6].eq {
	pc = 0x82A29DF8; continue 'dispatch;
	}
	// 82A29DF4: 4B896A9D  bl 0x822c0890
	ctx.lr = 0x82A29DF8;
	sub_822C0890(ctx, base);
	// 82A29DF8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A29DFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A29E00: 419A0008  beq cr6, 0x82a29e08
	if ctx.cr[6].eq {
	pc = 0x82A29E08; continue 'dispatch;
	}
	// 82A29E04: 4B896A8D  bl 0x822c0890
	ctx.lr = 0x82A29E08;
	sub_822C0890(ctx, base);
	// 82A29E08: 817E015C  lwz r11, 0x15c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(348 as u32) ) } as u64;
	// 82A29E0C: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82A29E10: 917E015C  stw r11, 0x15c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(348 as u32), ctx.r[11].u32 ) };
	// 82A29E14: 807E0160  lwz r3, 0x160(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 82A29E18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A29E1C: 419A000C  beq cr6, 0x82a29e28
	if ctx.cr[6].eq {
	pc = 0x82A29E28; continue 'dispatch;
	}
	// 82A29E20: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A29E24: 4811C99D  bl 0x82b467c0
	ctx.lr = 0x82A29E28;
	sub_82B467C0(ctx, base);
	// 82A29E28: 807E0168  lwz r3, 0x168(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(360 as u32) ) } as u64;
	// 82A29E2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A29E30: 419A000C  beq cr6, 0x82a29e3c
	if ctx.cr[6].eq {
	pc = 0x82A29E3C; continue 'dispatch;
	}
	// 82A29E34: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A29E38: 4811C989  bl 0x82b467c0
	ctx.lr = 0x82A29E3C;
	sub_82B467C0(ctx, base);
	// 82A29E3C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A29E40: 4877E37C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A29E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A29E48 size=260
    let mut pc: u32 = 0x82A29E48;
    'dispatch: loop {
        match pc {
            0x82A29E48 => {
    //   block [0x82A29E48..0x82A29F4C)
	// 82A29E48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A29E4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A29E50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A29E54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A29E58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A29E5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A29E60: 807F0168  lwz r3, 0x168(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82A29E64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A29E68: 419A000C  beq cr6, 0x82a29e74
	if ctx.cr[6].eq {
	pc = 0x82A29E74; continue 'dispatch;
	}
	// 82A29E6C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A29E70: 4811C951  bl 0x82b467c0
	ctx.lr = 0x82A29E74;
	sub_82B467C0(ctx, base);
	// 82A29E74: 807F0160  lwz r3, 0x160(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82A29E78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A29E7C: 419A000C  beq cr6, 0x82a29e88
	if ctx.cr[6].eq {
	pc = 0x82A29E88; continue 'dispatch;
	}
	// 82A29E80: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A29E84: 4811C93D  bl 0x82b467c0
	ctx.lr = 0x82A29E88;
	sub_82B467C0(ctx, base);
	// 82A29E88: 817F015C  lwz r11, 0x15c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 82A29E8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A29E90: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A29E94: 556B07B8  rlwinm r11, r11, 0, 0x1e, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A29E98: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82A29E9C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A29EA0: 917F015C  stw r11, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[11].u32 ) };
	// 82A29EA4: 4BA800C5  bl 0x824a9f68
	ctx.lr = 0x82A29EA8;
	sub_824A9F68(ctx, base);
	// 82A29EA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A29EAC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A29EB0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A29EB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A29EB8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A29EBC: 419A0024  beq cr6, 0x82a29ee0
	if ctx.cr[6].eq {
	pc = 0x82A29EE0; continue 'dispatch;
	}
	// 82A29EC0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A29EC4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A29EC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A29ECC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A29ED0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A29ED4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A29ED8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A29EDC: 4082FFE8  bne 0x82a29ec4
	if !ctx.cr[0].eq {
	pc = 0x82A29EC4; continue 'dispatch;
	}
	// 82A29EE0: 3BFF0028  addi r31, r31, 0x28
	ctx.r[31].s64 = ctx.r[31].s64 + 40;
	// 82A29EE4: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82A29EE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A29EEC: 485DF0CD  bl 0x83008fb8
	ctx.lr = 0x82A29EF0;
	sub_83008FB8(ctx, base);
	// 82A29EF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A29EF4: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A29EF8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A29EFC: 388AAEE0  addi r4, r10, -0x5120
	ctx.r[4].s64 = ctx.r[10].s64 + -20768;
	// 82A29F00: 38A00346  li r5, 0x346
	ctx.r[5].s64 = 838;
	// 82A29F04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A29F08: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A29F0C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A29F10: 4842EB31  bl 0x82e58a40
	ctx.lr = 0x82A29F14;
	sub_82E58A40(ctx, base);
	// 82A29F14: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A29F18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A29F1C: 419A0008  beq cr6, 0x82a29f24
	if ctx.cr[6].eq {
	pc = 0x82A29F24; continue 'dispatch;
	}
	// 82A29F20: 4B896971  bl 0x822c0890
	ctx.lr = 0x82A29F24;
	sub_822C0890(ctx, base);
	// 82A29F24: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A29F28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A29F2C: 419A0008  beq cr6, 0x82a29f34
	if ctx.cr[6].eq {
	pc = 0x82A29F34; continue 'dispatch;
	}
	// 82A29F30: 4B896961  bl 0x822c0890
	ctx.lr = 0x82A29F34;
	sub_822C0890(ctx, base);
	// 82A29F34: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A29F38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A29F3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A29F40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A29F44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A29F48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A29F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A29F50 size=284
    let mut pc: u32 = 0x82A29F50;
    'dispatch: loop {
        match pc {
            0x82A29F50 => {
    //   block [0x82A29F50..0x82A2A06C)
	// 82A29F50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A29F54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A29F58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A29F5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A29F60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A29F64: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A29F68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A29F6C: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 82A29F70: 419A00D8  beq cr6, 0x82a2a048
	if ctx.cr[6].eq {
	pc = 0x82A2A048; continue 'dispatch;
	}
	// 82A29F74: 2F1E0005  cmpwi cr6, r30, 5
	ctx.cr[6].compare_i32(ctx.r[30].s32, 5, &mut ctx.xer);
	// 82A29F78: 419A00C4  beq cr6, 0x82a2a03c
	if ctx.cr[6].eq {
	pc = 0x82A2A03C; continue 'dispatch;
	}
	// 82A29F7C: 2F1E0006  cmpwi cr6, r30, 6
	ctx.cr[6].compare_i32(ctx.r[30].s32, 6, &mut ctx.xer);
	// 82A29F80: 419A00B0  beq cr6, 0x82a2a030
	if ctx.cr[6].eq {
	pc = 0x82A2A030; continue 'dispatch;
	}
	// 82A29F84: 2F1E0008  cmpwi cr6, r30, 8
	ctx.cr[6].compare_i32(ctx.r[30].s32, 8, &mut ctx.xer);
	// 82A29F88: 409A00C8  bne cr6, 0x82a2a050
	if !ctx.cr[6].eq {
	pc = 0x82A2A050; continue 'dispatch;
	}
	// 82A29F8C: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A29F90: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 82A29F94: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A29F98: 394A1470  addi r10, r10, 0x1470
	ctx.r[10].s64 = ctx.r[10].s64 + 5232;
	// 82A29F9C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A29FA0: 3D008202  lis r8, -0x7dfe
	ctx.r[8].s64 = -2113798144;
	// 82A29FA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A29FA8: C00908A4  lfs f0, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A29FAC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A29FB0: 7D8B542E  lfsx f12, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A29FB4: C1A86218  lfs f13, 0x6218(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(25112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A29FB8: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A29FBC: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82A29FC0: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82A29FC4: 4BAE7ABD  bl 0x82511a80
	ctx.lr = 0x82A29FC8;
	sub_82511A80(ctx, base);
	// 82A29FC8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A29FCC: 807F0118  lwz r3, 0x118(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82A29FD0: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 82A29FD4: 4B8C317D  bl 0x822ed150
	ctx.lr = 0x82A29FD8;
	sub_822ED150(ctx, base);
	// 82A29FD8: 807F0168  lwz r3, 0x168(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82A29FDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A29FE0: 419A0024  beq cr6, 0x82a2a004
	if ctx.cr[6].eq {
	pc = 0x82A2A004; continue 'dispatch;
	}
	// 82A29FE4: 4811C6E5  bl 0x82b466c8
	ctx.lr = 0x82A29FE8;
	sub_82B466C8(ctx, base);
	// 82A29FE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A29FEC: 917F0168  stw r11, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[11].u32 ) };
	// 82A29FF0: 807F016C  lwz r3, 0x16c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 82A29FF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A29FF8: 917F016C  stw r11, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[11].u32 ) };
	// 82A29FFC: 419A0008  beq cr6, 0x82a2a004
	if ctx.cr[6].eq {
	pc = 0x82A2A004; continue 'dispatch;
	}
	// 82A2A000: 4B896891  bl 0x822c0890
	ctx.lr = 0x82A2A004;
	sub_822C0890(ctx, base);
	// 82A2A004: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2A008: 4BFFE6D9  bl 0x82a286e0
	ctx.lr = 0x82A2A00C;
	sub_82A286E0(ctx, base);
	// 82A2A00C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2A010: 4BFFFD49  bl 0x82a29d58
	ctx.lr = 0x82A2A014;
	sub_82A29D58(ctx, base);
	// 82A2A014: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2A018: 809F012C  lwz r4, 0x12c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 82A2A01C: 4BAE7C85  bl 0x82511ca0
	ctx.lr = 0x82A2A020;
	sub_82511CA0(ctx, base);
	// 82A2A020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2A024: 809F0128  lwz r4, 0x128(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 82A2A028: 4BAE7C79  bl 0x82511ca0
	ctx.lr = 0x82A2A02C;
	sub_82511CA0(ctx, base);
	// 82A2A02C: 48000024  b 0x82a2a050
	pc = 0x82A2A050; continue 'dispatch;
	// 82A2A030: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2A034: 4BFFED65  bl 0x82a28d98
	ctx.lr = 0x82A2A038;
	sub_82A28D98(ctx, base);
	// 82A2A038: 48000018  b 0x82a2a050
	pc = 0x82A2A050; continue 'dispatch;
	// 82A2A03C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2A040: 4BFFECB9  bl 0x82a28cf8
	ctx.lr = 0x82A2A044;
	sub_82A28CF8(ctx, base);
	// 82A2A044: 4800000C  b 0x82a2a050
	pc = 0x82A2A050; continue 'dispatch;
	// 82A2A048: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2A04C: 4BFFF3BD  bl 0x82a29408
	ctx.lr = 0x82A2A050;
	sub_82A29408(ctx, base);
	// 82A2A050: 93DF00E4  stw r30, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[30].u32 ) };
	// 82A2A054: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A2A058: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2A05C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A2A060: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A2A064: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A2A068: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2A070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A2A070 size=284
    let mut pc: u32 = 0x82A2A070;
    'dispatch: loop {
        match pc {
            0x82A2A070 => {
    //   block [0x82A2A070..0x82A2A18C)
	// 82A2A070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2A074: 4877E0F9  bl 0x831a816c
	ctx.lr = 0x82A2A078;
	sub_831A8130(ctx, base);
	// 82A2A078: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2A07C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A2A080: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82A2A084: 396B6880  addi r11, r11, 0x6880
	ctx.r[11].s64 = ctx.r[11].s64 + 26752;
	// 82A2A088: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82A2A08C: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 82A2A090: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 82A2A094: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 82A2A098: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 82A2A09C: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A2A0A0: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 82A2A0A4: 13CA5C07  vcmpneb. (lvlx128) v30, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A2A0A8: 13BD5C07  vcmpneb. (lvlx128) v29, v29, v11
	tmp.u32 = ctx.r[29].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A2A0AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A2A0B0: 13895C07  vcmpneb. (lvlx128) v28, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A2A0B4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2A190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A2A190 size=2532
    let mut pc: u32 = 0x82A2A190;
    'dispatch: loop {
        match pc {
            0x82A2A190 => {
    //   block [0x82A2A190..0x82A2AB74)
	// 82A2A190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2A194: 4877DFA9  bl 0x831a813c
	ctx.lr = 0x82A2A198;
	sub_831A8130(ctx, base);
	// 82A2A198: 3981FF80  addi r12, r1, -0x80
	ctx.r[12].s64 = ctx.r[1].s64 + -128;
	// 82A2A19C: 4877E8DD  bl 0x831a8a78
	ctx.lr = 0x82A2A1A0;
	sub_831A8A40(ctx, base);
	// 82A2A1A0: 9421FBE0  stwu r1, -0x420(r1)
	ea = ctx.r[1].u32.wrapping_add(-1056 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2A1A4: 3E808335  lis r20, -0x7ccb
	ctx.r[20].s64 = -2093678592;
	// 82A2A1A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2A1AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2A1B0: 80946868  lwz r4, 0x6868(r20)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(26728 as u32) ) } as u64;
	// 82A2A1B4: 4B8BAD7D  bl 0x822e4f30
	ctx.lr = 0x82A2A1B8;
	sub_822E4F30(ctx, base);
	// 82A2A1B8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A2A1BC: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82A2A1C0: 3E608335  lis r19, -0x7ccb
	ctx.r[19].s64 = -2093678592;
	// 82A2A1C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A2A1C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A2A1CC: 80CB677C  lwz r6, 0x677c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26492 as u32) ) } as u64;
	// 82A2A1D0: 808A685C  lwz r4, 0x685c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26716 as u32) ) } as u64;
	// 82A2A1D4: 80B36750  lwz r5, 0x6750(r19)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(26448 as u32) ) } as u64;
	// 82A2A1D8: 4B8CD641  bl 0x822f7818
	ctx.lr = 0x82A2A1DC;
	sub_822F7818(ctx, base);
	// 82A2A1DC: 3EA08338  lis r21, -0x7cc8
	ctx.r[21].s64 = -2093481984;
	// 82A2A1E0: E89E0000  ld r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82A2A1E4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82A2A1E8: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82A2A1EC: 88D5DDBC  lbz r6, -0x2244(r21)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(-8772 as u32) ) } as u64;
	// 82A2A1F0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82A2A1F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A2A1F8: 5567063E  clrlwi r7, r11, 0x18
	ctx.r[7].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A2A1FC: 4BA6208D  bl 0x8248c288
	ctx.lr = 0x82A2A200;
	sub_8248C288(ctx, base);
	// 82A2A200: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A2A204: 815F00EC  lwz r10, 0xec(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A2A208: 3BA00014  li r29, 0x14
	ctx.r[29].s64 = 20;
	// 82A2A20C: 3A2B137C  addi r17, r11, 0x137c
	ctx.r[17].s64 = ctx.r[11].s64 + 4988;
	// 82A2A210: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2A214: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A2A218: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82A2A21C: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 82A2A220: 7C721B78  mr r18, r3
	ctx.r[18].u64 = ctx.r[3].u64;
	// 82A2A224: 7C7DF02E  lwzx r3, r29, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82A2A228: 7F8B882E  lwzx r28, r11, r17
	ctx.r[28].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[17].u32)) } as u64;
	// 82A2A22C: 48476505  bl 0x82ea0730
	ctx.lr = 0x82A2A230;
	sub_82EA0730(ctx, base);
	// 82A2A230: 3B000030  li r24, 0x30
	ctx.r[24].s64 = 48;
	// 82A2A234: 396102A0  addi r11, r1, 0x2a0
	ctx.r[11].s64 = ctx.r[1].s64 + 672;
	// 82A2A238: B3030004  sth r24, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[24].u16 ) };
	// 82A2A23C: C1BC0000  lfs f13, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A2A240: C19C0004  lfs f12, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A2A244: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A2A248: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82A2A24C: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A2A250: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A2A254: 3D008203  lis r8, -0x7dfd
	ctx.r[8].s64 = -2113732608;
	// 82A2A258: C3CA08A8  lfs f30, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A2A25C: 388102A0  addi r4, r1, 0x2a0
	ctx.r[4].s64 = ctx.r[1].s64 + 672;
	// 82A2A260: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A2A264: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A2A268: D3C1006C  stfs f30, 0x6c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A2A26C: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2AB78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A2AB78 size=340
    let mut pc: u32 = 0x82A2AB78;
    'dispatch: loop {
        match pc {
            0x82A2AB78 => {
    //   block [0x82A2AB78..0x82A2ACCC)
	// 82A2AB78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2AB7C: 4877D5F1  bl 0x831a816c
	ctx.lr = 0x82A2AB80;
	sub_831A8130(ctx, base);
	// 82A2AB80: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2AB84: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2AB88: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82A2AB8C: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82A2AB90: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 82A2AB94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2AB98: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A2AB9C: 48475B95  bl 0x82ea0730
	ctx.lr = 0x82A2ABA0;
	sub_82EA0730(ctx, base);
	// 82A2ABA0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A2ABA4: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82A2ABA8: 394B1480  addi r10, r11, 0x1480
	ctx.r[10].s64 = ctx.r[11].s64 + 5248;
	// 82A2ABAC: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82A2ABB0: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82A2ABB4: B1230004  sth r9, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u16 ) };
	// 82A2ABB8: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82A2ABBC: C1AB1480  lfs f13, 0x1480(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A2ABC0: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82A2ABC4: C1889524  lfs f12, -0x6adc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A2ABC8: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82A2ABCC: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A2ABD0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A2ABD4: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A2ABD8: EDA00332  fmuls f13, f0, f12
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82A2ABDC: C18A0008  lfs f12, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A2ABE0: C00708A8  lfs f0, 0x8a8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A2ABE4: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82A2ABE8: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A2ABEC: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A2ABF0: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2ACD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A2ACD0 size=1916
    let mut pc: u32 = 0x82A2ACD0;
    'dispatch: loop {
        match pc {
            0x82A2ACD0 => {
    //   block [0x82A2ACD0..0x82A2B44C)
	// 82A2ACD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2ACD4: 4877D491  bl 0x831a8164
	ctx.lr = 0x82A2ACD8;
	sub_831A8130(ctx, base);
	// 82A2ACD8: DBA1FFB8  stfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[29].u64 ) };
	// 82A2ACDC: DBC1FFC0  stfd f30, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82A2ACE0: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A2ACE4: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2B450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A2B450 size=156
    let mut pc: u32 = 0x82A2B450;
    'dispatch: loop {
        match pc {
            0x82A2B450 => {
    //   block [0x82A2B450..0x82A2B4EC)
	// 82A2B450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2B454: 4877CD19  bl 0x831a816c
	ctx.lr = 0x82A2B458;
	sub_831A8130(ctx, base);
	// 82A2B458: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2B45C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2B460: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A2B464: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82A2B468: 4BAE6571  bl 0x825119d8
	ctx.lr = 0x82A2B46C;
	sub_825119D8(ctx, base);
	// 82A2B46C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82A2B470: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2B474: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82A2B478: 483C8591  bl 0x82df3a08
	ctx.lr = 0x82A2B47C;
	sub_82DF3A08(ctx, base);
	// 82A2B47C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A2B480: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A2B484: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A2B488: 4BADD2F9  bl 0x82508780
	ctx.lr = 0x82A2B48C;
	sub_82508780(ctx, base);
	// 82A2B48C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2B490: 483C7F99  bl 0x82df3428
	ctx.lr = 0x82A2B494;
	sub_82DF3428(ctx, base);
	// 82A2B494: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A2B498: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82A2B49C: 409A0008  bne cr6, 0x82a2b4a4
	if !ctx.cr[6].eq {
	pc = 0x82A2B4A4; continue 'dispatch;
	}
	// 82A2B4A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A2B4A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A2B4A8: 4BADD2F9  bl 0x825087a0
	ctx.lr = 0x82A2B4AC;
	sub_825087A0(ctx, base);
	// 82A2B4AC: 397F0130  addi r11, r31, 0x130
	ctx.r[11].s64 = ctx.r[31].s64 + 304;
	// 82A2B4B0: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 82A2B4B4: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82A2B4B8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2B4BC: 917F0130  stw r11, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 82A2B4C0: 4B898FA1  bl 0x822c4460
	ctx.lr = 0x82A2B4C4;
	sub_822C4460(ctx, base);
	// 82A2B4C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2B4C8: 4BAE75D1  bl 0x82512a98
	ctx.lr = 0x82A2B4CC;
	sub_82512A98(ctx, base);
	// 82A2B4CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2B4D0: 4BFFE431  bl 0x82a29900
	ctx.lr = 0x82A2B4D4;
	sub_82A29900(ctx, base);
	// 82A2B4D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2B4D8: 4BFFE219  bl 0x82a296f0
	ctx.lr = 0x82A2B4DC;
	sub_82A296F0(ctx, base);
	// 82A2B4DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2B4E0: 4BFFECB1  bl 0x82a2a190
	ctx.lr = 0x82A2B4E4;
	sub_82A2A190(ctx, base);
	// 82A2B4E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A2B4E8: 4877CCD4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2B4F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A2B4F0 size=20
    let mut pc: u32 = 0x82A2B4F0;
    'dispatch: loop {
        match pc {
            0x82A2B4F0 => {
    //   block [0x82A2B4F0..0x82A2B504)
	// 82A2B4F0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A2B4F4: 396B1530  addi r11, r11, 0x1530
	ctx.r[11].s64 = ctx.r[11].s64 + 5424;
	// 82A2B4F8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2B508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A2B508 size=240
    let mut pc: u32 = 0x82A2B508;
    'dispatch: loop {
        match pc {
            0x82A2B508 => {
    //   block [0x82A2B508..0x82A2B5F8)
	// 82A2B508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2B50C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A2B510: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A2B514: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2B518: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2B51C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A2B520: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A2B524: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A2B528: 388B1530  addi r4, r11, 0x1530
	ctx.r[4].s64 = ctx.r[11].s64 + 5424;
	// 82A2B52C: 3BFE0110  addi r31, r30, 0x110
	ctx.r[31].s64 = ctx.r[30].s64 + 272;
	// 82A2B530: 48450AA9  bl 0x82e7bfd8
	ctx.lr = 0x82A2B534;
	sub_82E7BFD8(ctx, base);
	// 82A2B534: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82A2B538: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82A2B53C: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 82A2B540: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 82A2B544: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A2B548: 13E04407  vcmpneb. (lvlx128) v31, v0, v8
	tmp.u32 = ctx.r[8].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A2B54C: 13C94407  vcmpneb. (lvlx128) v30, v9, v8
	tmp.u32 = ctx.r[9].u32 + ctx.r[8].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A2B550: 13AA4407  vcmpneb. (lvlx128) v29, v10, v8
	tmp.u32 = ctx.r[10].u32 + ctx.r[8].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A2B554: 138B4407  vcmpneb. (lvlx128) v28, v11, v8
	tmp.u32 = ctx.r[11].u32 + ctx.r[8].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2B5F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A2B5F8 size=196
    let mut pc: u32 = 0x82A2B5F8;
    'dispatch: loop {
        match pc {
            0x82A2B5F8 => {
    //   block [0x82A2B5F8..0x82A2B6BC)
	// 82A2B5F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2B5FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A2B600: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A2B604: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2B608: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2B60C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A2B610: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A2B614: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A2B618: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A2B61C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A2B620: 4B895319  bl 0x822c0938
	ctx.lr = 0x82A2B624;
	sub_822C0938(ctx, base);
	// 82A2B624: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A2B628: 41820028  beq 0x82a2b650
	if ctx.cr[0].eq {
	pc = 0x82A2B650; continue 'dispatch;
	}
	// 82A2B62C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A2B630: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A2B634: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A2B638: 392BB07C  addi r9, r11, -0x4f84
	ctx.r[9].s64 = ctx.r[11].s64 + -20356;
	// 82A2B63C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A2B640: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A2B644: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A2B648: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A2B64C: 48000008  b 0x82a2b654
	pc = 0x82A2B654; continue 'dispatch;
	// 82A2B650: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A2B654: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A2B658: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2B65C: 409A0044  bne cr6, 0x82a2b6a0
	if !ctx.cr[6].eq {
	pc = 0x82A2B6A0; continue 'dispatch;
	}
	// 82A2B660: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A2B664: 419A001C  beq cr6, 0x82a2b680
	if ctx.cr[6].eq {
	pc = 0x82A2B680; continue 'dispatch;
	}
	// 82A2B668: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2B66C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A2B670: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2B674: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2B678: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A2B67C: 4E800421  bctrl
	ctx.lr = 0x82A2B680;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A2B680: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A2B684: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A2B688: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2B68C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A2B690: 816B1528  lwz r11, 0x1528(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5416 as u32) ) } as u64;
	// 82A2B694: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A2B698: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A2B69C: 4B894965  bl 0x822c0000
	ctx.lr = 0x82A2B6A0;
	sub_822C0000(ctx, base);
	// 82A2B6A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2B6A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A2B6A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2B6AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A2B6B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A2B6B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A2B6B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2B6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A2B6C0 size=136
    let mut pc: u32 = 0x82A2B6C0;
    'dispatch: loop {
        match pc {
            0x82A2B6C0 => {
    //   block [0x82A2B6C0..0x82A2B748)
	// 82A2B6C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2B6C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A2B6C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A2B6CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2B6D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2B6D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2B6D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A2B6DC: 4BAE6C55  bl 0x82512330
	ctx.lr = 0x82A2B6E0;
	sub_82512330(ctx, base);
	// 82A2B6E0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A2B6E4: 93DF00E8  stw r30, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[30].u32 ) };
	// 82A2B6E8: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A2B6EC: 392BB0BC  addi r9, r11, -0x4f44
	ctx.r[9].s64 = ctx.r[11].s64 + -20292;
	// 82A2B6F0: 394AB0A8  addi r10, r10, -0x4f58
	ctx.r[10].s64 = ctx.r[10].s64 + -20312;
	// 82A2B6F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A2B6F8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A2B6FC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82A2B700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2B704: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 82A2B708: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 82A2B70C: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 82A2B710: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 82A2B714: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 82A2B718: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 82A2B71C: 917F0150  stw r11, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 82A2B720: 917F0154  stw r11, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[11].u32 ) };
	// 82A2B724: 917F0158  stw r11, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 82A2B728: 917F015C  stw r11, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[11].u32 ) };
	// 82A2B72C: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82A2B730: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A2B734: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2B738: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A2B73C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A2B740: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A2B744: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2B748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A2B748 size=8
    let mut pc: u32 = 0x82A2B748;
    'dispatch: loop {
        match pc {
            0x82A2B748 => {
    //   block [0x82A2B748..0x82A2B750)
	// 82A2B748: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82A2B74C: 48000374  b 0x82a2bac0
	sub_82A2BAC0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2B750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A2B750 size=164
    let mut pc: u32 = 0x82A2B750;
    'dispatch: loop {
        match pc {
            0x82A2B750 => {
    //   block [0x82A2B750..0x82A2B7F4)
	// 82A2B750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2B754: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A2B758: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2B75C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2B760: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2B764: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A2B768: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A2B76C: 396BB0BC  addi r11, r11, -0x4f44
	ctx.r[11].s64 = ctx.r[11].s64 + -20292;
	// 82A2B770: 394AB0A8  addi r10, r10, -0x4f58
	ctx.r[10].s64 = ctx.r[10].s64 + -20312;
	// 82A2B774: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A2B778: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A2B77C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82A2B780: 386BDDC4  addi r3, r11, -0x223c
	ctx.r[3].s64 = ctx.r[11].s64 + -8764;
	// 82A2B784: 480019D5  bl 0x82a2d158
	ctx.lr = 0x82A2B788;
	sub_82A2D158(ctx, base);
	// 82A2B788: 807F015C  lwz r3, 0x15c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 82A2B78C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2B790: 419A0008  beq cr6, 0x82a2b798
	if ctx.cr[6].eq {
	pc = 0x82A2B798; continue 'dispatch;
	}
	// 82A2B794: 4B8950FD  bl 0x822c0890
	ctx.lr = 0x82A2B798;
	sub_822C0890(ctx, base);
	// 82A2B798: 807F0154  lwz r3, 0x154(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 82A2B79C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2B7A0: 419A0008  beq cr6, 0x82a2b7a8
	if ctx.cr[6].eq {
	pc = 0x82A2B7A8; continue 'dispatch;
	}
	// 82A2B7A4: 4B8950ED  bl 0x822c0890
	ctx.lr = 0x82A2B7A8;
	sub_822C0890(ctx, base);
	// 82A2B7A8: 807F0100  lwz r3, 0x100(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 82A2B7AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2B7B0: 419A0008  beq cr6, 0x82a2b7b8
	if ctx.cr[6].eq {
	pc = 0x82A2B7B8; continue 'dispatch;
	}
	// 82A2B7B4: 4B8950DD  bl 0x822c0890
	ctx.lr = 0x82A2B7B8;
	sub_822C0890(ctx, base);
	// 82A2B7B8: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82A2B7BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2B7C0: 419A0008  beq cr6, 0x82a2b7c8
	if ctx.cr[6].eq {
	pc = 0x82A2B7C8; continue 'dispatch;
	}
	// 82A2B7C4: 4B8950CD  bl 0x822c0890
	ctx.lr = 0x82A2B7C8;
	sub_822C0890(ctx, base);
	// 82A2B7C8: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82A2B7CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2B7D0: 419A0008  beq cr6, 0x82a2b7d8
	if ctx.cr[6].eq {
	pc = 0x82A2B7D8; continue 'dispatch;
	}
	// 82A2B7D4: 4B8950BD  bl 0x822c0890
	ctx.lr = 0x82A2B7D8;
	sub_822C0890(ctx, base);
	// 82A2B7D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2B7DC: 4B923B75  bl 0x8234f350
	ctx.lr = 0x82A2B7E0;
	sub_8234F350(ctx, base);
	// 82A2B7E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A2B7E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2B7E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A2B7EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A2B7F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2B7F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A2B7F8 size=204
    let mut pc: u32 = 0x82A2B7F8;
    'dispatch: loop {
        match pc {
            0x82A2B7F8 => {
    //   block [0x82A2B7F8..0x82A2B8C4)
	// 82A2B7F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2B7FC: 4877C96D  bl 0x831a8168
	ctx.lr = 0x82A2B800;
	sub_831A8130(ctx, base);
	// 82A2B800: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2B804: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A2B808: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A2B80C: 3BFD0150  addi r31, r29, 0x150
	ctx.r[31].s64 = ctx.r[29].s64 + 336;
	// 82A2B810: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A2B814: 817D0150  lwz r11, 0x150(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(336 as u32) ) } as u64;
	// 82A2B818: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2B81C: 419A0048  beq cr6, 0x82a2b864
	if ctx.cr[6].eq {
	pc = 0x82A2B864; continue 'dispatch;
	}
	// 82A2B820: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2B824: 4BADF12D  bl 0x8250a950
	ctx.lr = 0x82A2B828;
	sub_8250A950(ctx, base);
	// 82A2B828: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A2B82C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2B830: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82A2B834: 409A0008  bne cr6, 0x82a2b83c
	if !ctx.cr[6].eq {
	pc = 0x82A2B83C; continue 'dispatch;
	}
	// 82A2B838: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2B83C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2B840: 4BDA8131  bl 0x827d3970
	ctx.lr = 0x82A2B844;
	sub_827D3970(ctx, base);
	// 82A2B844: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A2B848: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A2B84C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2B850: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A2B854: 419A0008  beq cr6, 0x82a2b85c
	if ctx.cr[6].eq {
	pc = 0x82A2B85C; continue 'dispatch;
	}
	// 82A2B858: 4B895039  bl 0x822c0890
	ctx.lr = 0x82A2B85C;
	sub_822C0890(ctx, base);
	// 82A2B85C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2B860: 483C6431  bl 0x82df1c90
	ctx.lr = 0x82A2B864;
	sub_82DF1C90(ctx, base);
	// 82A2B864: 817D0158  lwz r11, 0x158(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(344 as u32) ) } as u64;
	// 82A2B868: 3BFD0158  addi r31, r29, 0x158
	ctx.r[31].s64 = ctx.r[29].s64 + 344;
	// 82A2B86C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2B870: 419A004C  beq cr6, 0x82a2b8bc
	if ctx.cr[6].eq {
	pc = 0x82A2B8BC; continue 'dispatch;
	}
	// 82A2B874: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A2B878: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A2B87C: 4BADF0D5  bl 0x8250a950
	ctx.lr = 0x82A2B880;
	sub_8250A950(ctx, base);
	// 82A2B880: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A2B884: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2B888: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82A2B88C: 409A0008  bne cr6, 0x82a2b894
	if !ctx.cr[6].eq {
	pc = 0x82A2B894; continue 'dispatch;
	}
	// 82A2B890: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2B894: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2B898: 4BDA80D9  bl 0x827d3970
	ctx.lr = 0x82A2B89C;
	sub_827D3970(ctx, base);
	// 82A2B89C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A2B8A0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A2B8A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2B8A8: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A2B8AC: 419A0008  beq cr6, 0x82a2b8b4
	if ctx.cr[6].eq {
	pc = 0x82A2B8B4; continue 'dispatch;
	}
	// 82A2B8B0: 4B894FE1  bl 0x822c0890
	ctx.lr = 0x82A2B8B4;
	sub_822C0890(ctx, base);
	// 82A2B8B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A2B8B8: 483C63D9  bl 0x82df1c90
	ctx.lr = 0x82A2B8BC;
	sub_82DF1C90(ctx, base);
	// 82A2B8BC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A2B8C0: 4877C8F8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2B8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A2B8C8 size=280
    let mut pc: u32 = 0x82A2B8C8;
    'dispatch: loop {
        match pc {
            0x82A2B8C8 => {
    //   block [0x82A2B8C8..0x82A2B9E0)
	// 82A2B8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2B8CC: 4877C8A1  bl 0x831a816c
	ctx.lr = 0x82A2B8D0;
	sub_831A8130(ctx, base);
	// 82A2B8D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2B8D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2B8D8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A2B8DC: 4BAE4E2D  bl 0x82510708
	ctx.lr = 0x82A2B8E0;
	sub_82510708(ctx, base);
	// 82A2B8E0: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A2B8E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2B8E8: 419A0088  beq cr6, 0x82a2b970
	if ctx.cr[6].eq {
	pc = 0x82A2B970; continue 'dispatch;
	}
	// 82A2B8EC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82A2B8F0: 409A00DC  bne cr6, 0x82a2b9cc
	if !ctx.cr[6].eq {
	pc = 0x82A2B9CC; continue 'dispatch;
	}
	// 82A2B8F4: 807F00FC  lwz r3, 0xfc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82A2B8F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A2B8FC: 3BDF00FC  addi r30, r31, 0xfc
	ctx.r[30].s64 = ctx.r[31].s64 + 252;
	// 82A2B900: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2B904: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A2B908: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A2B90C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A2B910: 4E800421  bctrl
	ctx.lr = 0x82A2B914;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A2B914: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2B918: 418200B4  beq 0x82a2b9cc
	if ctx.cr[0].eq {
	pc = 0x82A2B9CC; continue 'dispatch;
	}
	// 82A2B91C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82A2B920: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2B924: 388B0380  addi r4, r11, 0x380
	ctx.r[4].s64 = ctx.r[11].s64 + 896;
	// 82A2B928: 483C80E1  bl 0x82df3a08
	ctx.lr = 0x82A2B92C;
	sub_82DF3A08(ctx, base);
	// 82A2B92C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A2B930: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A2B934: 809F00F4  lwz r4, 0xf4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A2B938: 481879D9  bl 0x82bb3310
	ctx.lr = 0x82A2B93C;
	sub_82BB3310(ctx, base);
	// 82A2B93C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A2B940: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82A2B944: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A2B948: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2B94C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A2B950: 4B898B11  bl 0x822c4460
	ctx.lr = 0x82A2B954;
	sub_822C4460(ctx, base);
	// 82A2B954: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A2B958: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2B95C: 419A0008  beq cr6, 0x82a2b964
	if ctx.cr[6].eq {
	pc = 0x82A2B964; continue 'dispatch;
	}
	// 82A2B960: 4B894F31  bl 0x822c0890
	ctx.lr = 0x82A2B964;
	sub_822C0890(ctx, base);
	// 82A2B964: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2B968: 483C7AC1  bl 0x82df3428
	ctx.lr = 0x82A2B96C;
	sub_82DF3428(ctx, base);
	// 82A2B96C: 48000060  b 0x82a2b9cc
	pc = 0x82A2B9CC; continue 'dispatch;
	// 82A2B970: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82A2B974: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A2B978: 388B0380  addi r4, r11, 0x380
	ctx.r[4].s64 = ctx.r[11].s64 + 896;
	// 82A2B97C: 483C808D  bl 0x82df3a08
	ctx.lr = 0x82A2B980;
	sub_82DF3A08(ctx, base);
	// 82A2B980: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82A2B984: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A2B988: 809F00F4  lwz r4, 0xf4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A2B98C: 48187985  bl 0x82bb3310
	ctx.lr = 0x82A2B990;
	sub_82BB3310(ctx, base);
	// 82A2B990: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A2B994: 395F00FC  addi r10, r31, 0xfc
	ctx.r[10].s64 = ctx.r[31].s64 + 252;
	// 82A2B998: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A2B99C: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82A2B9A0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2B9A4: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 82A2B9A8: 4B898AB9  bl 0x822c4460
	ctx.lr = 0x82A2B9AC;
	sub_822C4460(ctx, base);
	// 82A2B9AC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A2B9B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2B9B4: 419A0008  beq cr6, 0x82a2b9bc
	if ctx.cr[6].eq {
	pc = 0x82A2B9BC; continue 'dispatch;
	}
	// 82A2B9B8: 4B894ED9  bl 0x822c0890
	ctx.lr = 0x82A2B9BC;
	sub_822C0890(ctx, base);
	// 82A2B9BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A2B9C0: 483C7A69  bl 0x82df3428
	ctx.lr = 0x82A2B9C4;
	sub_82DF3428(ctx, base);
	// 82A2B9C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A2B9C8: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82A2B9CC: C03D0000  lfs f1, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A2B9D0: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A2B9D4: 48189B1D  bl 0x82bb54f0
	ctx.lr = 0x82A2B9D8;
	sub_82BB54F0(ctx, base);
	// 82A2B9D8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A2B9DC: 4877C7E0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2B9E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A2B9E0 size=224
    let mut pc: u32 = 0x82A2B9E0;
    'dispatch: loop {
        match pc {
            0x82A2B9E0 => {
    //   block [0x82A2B9E0..0x82A2BAC0)
	// 82A2B9E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2B9E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A2B9E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A2B9EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2B9F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2B9F4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A2B9F8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A2B9FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A2BA00: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A2BA04: 388BB0F8  addi r4, r11, -0x4f08
	ctx.r[4].s64 = ctx.r[11].s64 + -20232;
	// 82A2BA08: 38A0003E  li r5, 0x3e
	ctx.r[5].s64 = 62;
	// 82A2BA0C: 38600160  li r3, 0x160
	ctx.r[3].s64 = 352;
	// 82A2BA10: 483C69D9  bl 0x82df23e8
	ctx.lr = 0x82A2BA14;
	sub_82DF23E8(ctx, base);
	// 82A2BA14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A2BA18: 41820014  beq 0x82a2ba2c
	if ctx.cr[0].eq {
	pc = 0x82A2BA2C; continue 'dispatch;
	}
	// 82A2BA1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2BA20: 4BFFFCA1  bl 0x82a2b6c0
	ctx.lr = 0x82A2BA24;
	sub_82A2B6C0(ctx, base);
	// 82A2BA24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2BA28: 48000008  b 0x82a2ba30
	pc = 0x82A2BA30; continue 'dispatch;
	// 82A2BA2C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A2BA30: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A2BA34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2BA38: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A2BA3C: 4BFFFBBD  bl 0x82a2b5f8
	ctx.lr = 0x82A2BA40;
	sub_82A2B5F8(ctx, base);
	// 82A2BA40: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A2BA44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2BA48: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A2BA4C: 4B8945B5  bl 0x822c0000
	ctx.lr = 0x82A2BA50;
	sub_822C0000(ctx, base);
	// 82A2BA50: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A2BA54: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A2BA58: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A2BA5C: 396ADDC4  addi r11, r10, -0x223c
	ctx.r[11].s64 = ctx.r[10].s64 + -8764;
	// 82A2BA60: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82A2BA64: 93EADDC4  stw r31, -0x223c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8764 as u32), ctx.r[31].u32 ) };
	// 82A2BA68: 4BACA849  bl 0x824f62b0
	ctx.lr = 0x82A2BA6C;
	sub_824F62B0(ctx, base);
	// 82A2BA6C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A2BA70: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A2BA74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2BA78: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82A2BA7C: 419A0028  beq cr6, 0x82a2baa4
	if ctx.cr[6].eq {
	pc = 0x82A2BAA4; continue 'dispatch;
	}
	// 82A2BA80: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 82A2BA84: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A2BA88: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A2BA8C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A2BA90: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A2BA94: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A2BA98: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A2BA9C: 4082FFE8  bne 0x82a2ba84
	if !ctx.cr[0].eq {
	pc = 0x82A2BA84; continue 'dispatch;
	}
	// 82A2BAA0: 4B894DF1  bl 0x822c0890
	ctx.lr = 0x82A2BAA4;
	sub_822C0890(ctx, base);
	// 82A2BAA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2BAA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A2BAAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2BAB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A2BAB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A2BAB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A2BABC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2BAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A2BAC0 size=76
    let mut pc: u32 = 0x82A2BAC0;
    'dispatch: loop {
        match pc {
            0x82A2BAC0 => {
    //   block [0x82A2BAC0..0x82A2BB0C)
	// 82A2BAC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2BAC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A2BAC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A2BACC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2BAD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2BAD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2BAD8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A2BADC: 4BFFFC75  bl 0x82a2b750
	ctx.lr = 0x82A2BAE0;
	sub_82A2B750(ctx, base);
	// 82A2BAE0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2BAE4: 4182000C  beq 0x82a2baf0
	if ctx.cr[0].eq {
	pc = 0x82A2BAF0; continue 'dispatch;
	}
	// 82A2BAE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2BAEC: 483C68ED  bl 0x82df23d8
	ctx.lr = 0x82A2BAF0;
	sub_82DF23D8(ctx, base);
	// 82A2BAF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2BAF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A2BAF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2BAFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A2BB00: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A2BB04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A2BB08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2BB10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A2BB10 size=320
    let mut pc: u32 = 0x82A2BB10;
    'dispatch: loop {
        match pc {
            0x82A2BB10 => {
    //   block [0x82A2BB10..0x82A2BC50)
	// 82A2BB10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2BB14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A2BB18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A2BB1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2BB20: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2BB24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2BB28: 80840000  lwz r4, 0(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2BB2C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A2BB30: 483FEFB9  bl 0x82e2aae8
	ctx.lr = 0x82A2BB34;
	sub_82E2AAE8(ctx, base);
	// 82A2BB34: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A2BB38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2BB3C: 808B1520  lwz r4, 0x1520(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5408 as u32) ) } as u64;
	// 82A2BB40: 483C7EC9  bl 0x82df3a08
	ctx.lr = 0x82A2BB44;
	sub_82DF3A08(ctx, base);
	// 82A2BB44: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A2BB48: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A2BB4C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82A2BB50: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A2BB54: 4840331D  bl 0x82e2ee70
	ctx.lr = 0x82A2BB58;
	sub_82E2EE70(ctx, base);
	// 82A2BB58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2BB5C: 483C78CD  bl 0x82df3428
	ctx.lr = 0x82A2BB60;
	sub_82DF3428(ctx, base);
	// 82A2BB60: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A2BB64: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A2BB68: 388BB0F8  addi r4, r11, -0x4f08
	ctx.r[4].s64 = ctx.r[11].s64 + -20232;
	// 82A2BB6C: 38A0009C  li r5, 0x9c
	ctx.r[5].s64 = 156;
	// 82A2BB70: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82A2BB74: 483C6875  bl 0x82df23e8
	ctx.lr = 0x82A2BB78;
	sub_82DF23E8(ctx, base);
	// 82A2BB78: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A2BB7C: 41820014  beq 0x82a2bb90
	if ctx.cr[0].eq {
	pc = 0x82A2BB90; continue 'dispatch;
	}
	// 82A2BB80: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A2BB84: 483EAD0D  bl 0x82e16890
	ctx.lr = 0x82A2BB88;
	sub_82E16890(ctx, base);
	// 82A2BB88: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A2BB8C: 48000008  b 0x82a2bb94
	pc = 0x82A2BB94; continue 'dispatch;
	// 82A2BB90: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A2BB94: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82A2BB98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A2BB9C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A2BBA0: 4B92D519  bl 0x823590b8
	ctx.lr = 0x82A2BBA4;
	sub_823590B8(ctx, base);
	// 82A2BBA4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A2BBA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A2BBAC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A2BBB0: 4B894451  bl 0x822c0000
	ctx.lr = 0x82A2BBB4;
	sub_822C0000(ctx, base);
	// 82A2BBB4: 397F00EC  addi r11, r31, 0xec
	ctx.r[11].s64 = ctx.r[31].s64 + 236;
	// 82A2BBB8: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82A2BBBC: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82A2BBC0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A2BBC4: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 82A2BBC8: 4B898899  bl 0x822c4460
	ctx.lr = 0x82A2BBCC;
	sub_822C4460(ctx, base);
	// 82A2BBCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2BBD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2BBD4: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A2BBD8: 4BAE6541  bl 0x82512118
	ctx.lr = 0x82A2BBDC;
	sub_82512118(ctx, base);
	// 82A2BBDC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A2BBE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2BBE4: 483E94CD  bl 0x82e150b0
	ctx.lr = 0x82A2BBE8;
	sub_82E150B0(ctx, base);
	// 82A2BBE8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82A2BBEC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82A2BBF0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A2BBF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2BBF8: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82A2BBFC: 4BAE4F5D  bl 0x82510b58
	ctx.lr = 0x82A2BC00;
	sub_82510B58(ctx, base);
	// 82A2BC00: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A2BC04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2BC08: 388B1530  addi r4, r11, 0x1530
	ctx.r[4].s64 = ctx.r[11].s64 + 5424;
	// 82A2BC0C: 4BAE5E75  bl 0x82511a80
	ctx.lr = 0x82A2BC10;
	sub_82511A80(ctx, base);
	// 82A2BC10: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A2BC14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2BC18: 419A0008  beq cr6, 0x82a2bc20
	if ctx.cr[6].eq {
	pc = 0x82A2BC20; continue 'dispatch;
	}
	// 82A2BC1C: 4B894C75  bl 0x822c0890
	ctx.lr = 0x82A2BC20;
	sub_822C0890(ctx, base);
	// 82A2BC20: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A2BC24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2BC28: 419A0008  beq cr6, 0x82a2bc30
	if ctx.cr[6].eq {
	pc = 0x82A2BC30; continue 'dispatch;
	}
	// 82A2BC2C: 4B894C65  bl 0x822c0890
	ctx.lr = 0x82A2BC30;
	sub_822C0890(ctx, base);
	// 82A2BC30: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A2BC34: 483FEECD  bl 0x82e2ab00
	ctx.lr = 0x82A2BC38;
	sub_82E2AB00(ctx, base);
	// 82A2BC38: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A2BC3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2BC40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A2BC44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A2BC48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A2BC4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2BC50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A2BC50 size=56
    let mut pc: u32 = 0x82A2BC50;
    'dispatch: loop {
        match pc {
            0x82A2BC50 => {
    //   block [0x82A2BC50..0x82A2BC88)
	// 82A2BC50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2BC54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A2BC58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2BC5C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2BC60: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A2BC64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2BC68: 388BDDC4  addi r4, r11, -0x223c
	ctx.r[4].s64 = ctx.r[11].s64 + -8764;
	// 82A2BC6C: 4BF9CAED  bl 0x829c8758
	ctx.lr = 0x82A2BC70;
	sub_829C8758(ctx, base);
	// 82A2BC70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2BC74: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A2BC78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2BC7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A2BC80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A2BC84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2BC88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A2BC88 size=400
    let mut pc: u32 = 0x82A2BC88;
    'dispatch: loop {
        match pc {
            0x82A2BC88 => {
    //   block [0x82A2BC88..0x82A2BE18)
	// 82A2BC88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2BC8C: 4877C4D9  bl 0x831a8164
	ctx.lr = 0x82A2BC90;
	sub_831A8130(ctx, base);
	// 82A2BC90: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2BC94: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A2BC98: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A2BC9C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A2BCA0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A2BCA4: 3B8BB0F8  addi r28, r11, -0x4f08
	ctx.r[28].s64 = ctx.r[11].s64 + -20232;
	// 82A2BCA8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A2BCAC: 38A000AB  li r5, 0xab
	ctx.r[5].s64 = 171;
	// 82A2BCB0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A2BCB4: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 82A2BCB8: 483C6731  bl 0x82df23e8
	ctx.lr = 0x82A2BCBC;
	sub_82DF23E8(ctx, base);
	// 82A2BCBC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A2BCC0: 41820040  beq 0x82a2bd00
	if ctx.cr[0].eq {
	pc = 0x82A2BD00; continue 'dispatch;
	}
	// 82A2BCC4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A2BCC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2BCCC: 808B1524  lwz r4, 0x1524(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5412 as u32) ) } as u64;
	// 82A2BCD0: 483C7D39  bl 0x82df3a08
	ctx.lr = 0x82A2BCD4;
	sub_82DF3A08(ctx, base);
	// 82A2BCD4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A2BCD8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A2BCDC: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 82A2BCE0: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 82A2BCE4: 4BAE37E5  bl 0x8250f4c8
	ctx.lr = 0x82A2BCE8;
	sub_8250F4C8(ctx, base);
	// 82A2BCE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A2BCEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2BCF0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A2BCF4: 48187F0D  bl 0x82bb3c00
	ctx.lr = 0x82A2BCF8;
	sub_82BB3C00(ctx, base);
	// 82A2BCF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A2BCFC: 48000008  b 0x82a2bd04
	pc = 0x82A2BD04; continue 'dispatch;
	// 82A2BD00: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A2BD04: 3BFD00F4  addi r31, r29, 0xf4
	ctx.r[31].s64 = ctx.r[29].s64 + 244;
	// 82A2BD08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2BD0C: 4B9316D5  bl 0x8235d3e0
	ctx.lr = 0x82A2BD10;
	sub_8235D3E0(ctx, base);
	// 82A2BD10: 57CB07BD  rlwinm. r11, r30, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2BD14: 41820010  beq 0x82a2bd24
	if ctx.cr[0].eq {
	pc = 0x82A2BD24; continue 'dispatch;
	}
	// 82A2BD18: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A2BD1C: 57DE07FA  rlwinm r30, r30, 0, 0x1f, 0x1d
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 82A2BD20: 483C5F71  bl 0x82df1c90
	ctx.lr = 0x82A2BD24;
	sub_82DF1C90(ctx, base);
	// 82A2BD24: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2BD28: 4182000C  beq 0x82a2bd34
	if ctx.cr[0].eq {
	pc = 0x82A2BD34; continue 'dispatch;
	}
	// 82A2BD2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2BD30: 483C76F9  bl 0x82df3428
	ctx.lr = 0x82A2BD34;
	sub_82DF3428(ctx, base);
	// 82A2BD34: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2BD38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2BD3C: 419A006C  beq cr6, 0x82a2bda8
	if ctx.cr[6].eq {
	pc = 0x82A2BDA8; continue 'dispatch;
	}
	// 82A2BD40: 48188AD9  bl 0x82bb4818
	ctx.lr = 0x82A2BD44;
	sub_82BB4818(ctx, base);
	// 82A2BD44: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2BD48: 40820060  bne 0x82a2bda8
	if !ctx.cr[0].eq {
	pc = 0x82A2BDA8; continue 'dispatch;
	}
	// 82A2BD4C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A2BD50: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2BD54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2BD58: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A2BD5C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A2BD60: 419A0024  beq cr6, 0x82a2bd84
	if ctx.cr[6].eq {
	pc = 0x82A2BD84; continue 'dispatch;
	}
	// 82A2BD64: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A2BD68: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A2BD6C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A2BD70: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A2BD74: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A2BD78: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A2BD7C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A2BD80: 4082FFE8  bne 0x82a2bd68
	if !ctx.cr[0].eq {
	pc = 0x82A2BD68; continue 'dispatch;
	}
	// 82A2BD84: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A2BD88: 4BABED01  bl 0x824eaa88
	ctx.lr = 0x82A2BD8C;
	sub_824EAA88(ctx, base);
	// 82A2BD8C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A2BD90: 38C000AD  li r6, 0xad
	ctx.r[6].s64 = 173;
	// 82A2BD94: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2BD98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A2BD9C: 4BFFD745  bl 0x82a294e0
	ctx.lr = 0x82A2BDA0;
	sub_82A294E0(ctx, base);
	// 82A2BDA0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A2BDA4: 483C5EED  bl 0x82df1c90
	ctx.lr = 0x82A2BDA8;
	sub_82DF1C90(ctx, base);
	// 82A2BDA8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A2BDAC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2BDB0: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82A2BDB4: 388B1540  addi r4, r11, 0x1540
	ctx.r[4].s64 = ctx.r[11].s64 + 5440;
	// 82A2BDB8: 481891A9  bl 0x82bb4f60
	ctx.lr = 0x82A2BDBC;
	sub_82BB4F60(ctx, base);
	// 82A2BDBC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A2BDC0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2BDC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2BDC8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A2BDCC: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A2BDD0: 419A0024  beq cr6, 0x82a2bdf4
	if ctx.cr[6].eq {
	pc = 0x82A2BDF4; continue 'dispatch;
	}
	// 82A2BDD4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A2BDD8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A2BDDC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A2BDE0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A2BDE4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A2BDE8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A2BDEC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A2BDF0: 4082FFE8  bne 0x82a2bdd8
	if !ctx.cr[0].eq {
	pc = 0x82A2BDD8; continue 'dispatch;
	}
	// 82A2BDF4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A2BDF8: 807D00EC  lwz r3, 0xec(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A2BDFC: 483E9175  bl 0x82e14f70
	ctx.lr = 0x82A2BE00;
	sub_82E14F70(ctx, base);
	// 82A2BE00: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A2BE04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2BE08: 419A0008  beq cr6, 0x82a2be10
	if ctx.cr[6].eq {
	pc = 0x82A2BE10; continue 'dispatch;
	}
	// 82A2BE0C: 4B894A85  bl 0x822c0890
	ctx.lr = 0x82A2BE10;
	sub_822C0890(ctx, base);
	// 82A2BE10: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A2BE14: 4877C3A0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2BE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A2BE18 size=328
    let mut pc: u32 = 0x82A2BE18;
    'dispatch: loop {
        match pc {
            0x82A2BE18 => {
    //   block [0x82A2BE18..0x82A2BF60)
	// 82A2BE18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2BE1C: 4877C351  bl 0x831a816c
	ctx.lr = 0x82A2BE20;
	sub_831A8130(ctx, base);
	// 82A2BE20: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2BE24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2BE28: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A2BE2C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82A2BE30: 4BAE5BA9  bl 0x825119d8
	ctx.lr = 0x82A2BE34;
	sub_825119D8(ctx, base);
	// 82A2BE34: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82A2BE38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2BE3C: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82A2BE40: 483C7BC9  bl 0x82df3a08
	ctx.lr = 0x82A2BE44;
	sub_82DF3A08(ctx, base);
	// 82A2BE44: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A2BE48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A2BE4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2BE50: 4BADC931  bl 0x82508780
	ctx.lr = 0x82A2BE54;
	sub_82508780(ctx, base);
	// 82A2BE54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2BE58: 483C75D1  bl 0x82df3428
	ctx.lr = 0x82A2BE5C;
	sub_82DF3428(ctx, base);
	// 82A2BE5C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A2BE60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2BE64: 4BFFFCAD  bl 0x82a2bb10
	ctx.lr = 0x82A2BE68;
	sub_82A2BB10(ctx, base);
	// 82A2BE68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2BE6C: 4BFFFE1D  bl 0x82a2bc88
	ctx.lr = 0x82A2BE70;
	sub_82A2BC88(ctx, base);
	// 82A2BE70: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A2BE74: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A2BE78: 388B1530  addi r4, r11, 0x1530
	ctx.r[4].s64 = ctx.r[11].s64 + 5424;
	// 82A2BE7C: 3BDF0110  addi r30, r31, 0x110
	ctx.r[30].s64 = ctx.r[31].s64 + 272;
	// 82A2BE80: 48450159  bl 0x82e7bfd8
	ctx.lr = 0x82A2BE84;
	sub_82E7BFD8(ctx, base);
	// 82A2BE84: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82A2BE88: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82A2BE8C: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 82A2BE90: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 82A2BE94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A2BE98: 13E04407  vcmpneb. (lvlx128) v31, v0, v8
	tmp.u32 = ctx.r[8].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A2BE9C: 13C94407  vcmpneb. (lvlx128) v30, v9, v8
	tmp.u32 = ctx.r[9].u32 + ctx.r[8].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A2BEA0: 13AA4407  vcmpneb. (lvlx128) v29, v10, v8
	tmp.u32 = ctx.r[10].u32 + ctx.r[8].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A2BEA4: 138B4407  vcmpneb. (lvlx128) v28, v11, v8
	tmp.u32 = ctx.r[11].u32 + ctx.r[8].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2BF60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A2BF60 size=80
    let mut pc: u32 = 0x82A2BF60;
    'dispatch: loop {
        match pc {
            0x82A2BF60 => {
    //   block [0x82A2BF60..0x82A2BFB0)
	// 82A2BF60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2BF64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A2BF68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A2BF6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2BF70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2BF74: 3BE300F4  addi r31, r3, 0xf4
	ctx.r[31].s64 = ctx.r[3].s64 + 244;
	// 82A2BF78: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 82A2BF7C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2BF80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2BF84: 419A0008  beq cr6, 0x82a2bf8c
	if ctx.cr[6].eq {
	pc = 0x82A2BF8C; continue 'dispatch;
	}
	// 82A2BF88: 4BFFDDD1  bl 0x82a29d58
	ctx.lr = 0x82A2BF8C;
	sub_82A29D58(ctx, base);
	// 82A2BF8C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A2BF90: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82A2BF94: 4082FFE8  bne 0x82a2bf7c
	if !ctx.cr[0].eq {
	pc = 0x82A2BF7C; continue 'dispatch;
	}
	// 82A2BF98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A2BF9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2BFA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A2BFA4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A2BFA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A2BFAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2BFB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A2BFB0 size=80
    let mut pc: u32 = 0x82A2BFB0;
    'dispatch: loop {
        match pc {
            0x82A2BFB0 => {
    //   block [0x82A2BFB0..0x82A2C000)
	// 82A2BFB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2BFB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A2BFB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A2BFBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2BFC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2BFC4: 3BE300F4  addi r31, r3, 0xf4
	ctx.r[31].s64 = ctx.r[3].s64 + 244;
	// 82A2BFC8: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 82A2BFCC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2BFD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2BFD4: 419A0008  beq cr6, 0x82a2bfdc
	if ctx.cr[6].eq {
	pc = 0x82A2BFDC; continue 'dispatch;
	}
	// 82A2BFD8: 4BFFDE71  bl 0x82a29e48
	ctx.lr = 0x82A2BFDC;
	sub_82A29E48(ctx, base);
	// 82A2BFDC: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A2BFE0: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82A2BFE4: 4082FFE8  bne 0x82a2bfcc
	if !ctx.cr[0].eq {
	pc = 0x82A2BFCC; continue 'dispatch;
	}
	// 82A2BFE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A2BFEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2BFF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A2BFF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A2BFF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A2BFFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2C000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A2C000 size=92
    let mut pc: u32 = 0x82A2C000;
    'dispatch: loop {
        match pc {
            0x82A2C000 => {
    //   block [0x82A2C000..0x82A2C05C)
	// 82A2C000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2C004: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A2C008: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2C00C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2C010: 54AB1838  slwi r11, r5, 3
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A2C014: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2C018: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82A2C01C: 806B00F4  lwz r3, 0xf4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A2C020: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2C024: 419A0010  beq cr6, 0x82a2c034
	if ctx.cr[6].eq {
	pc = 0x82A2C034; continue 'dispatch;
	}
	// 82A2C028: 4BAE5AC1  bl 0x82511ae8
	ctx.lr = 0x82A2C02C;
	sub_82511AE8(ctx, base);
	// 82A2C02C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A2C030: 4800000C  b 0x82a2c03c
	pc = 0x82A2C03C; continue 'dispatch;
	// 82A2C034: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A2C038: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82A2C03C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A2C040: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2C060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A2C060 size=84
    let mut pc: u32 = 0x82A2C060;
    'dispatch: loop {
        match pc {
            0x82A2C060 => {
    //   block [0x82A2C060..0x82A2C0B4)
	// 82A2C060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2C064: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A2C068: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2C06C: 548B1838  slwi r11, r4, 3
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A2C070: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82A2C074: 806B00F4  lwz r3, 0xf4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A2C078: 4BAE5A71  bl 0x82511ae8
	ctx.lr = 0x82A2C07C;
	sub_82511AE8(ctx, base);
	// 82A2C07C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A2C080: C1830000  lfs f12, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A2C084: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A2C088: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A2C08C: C00BDBA4  lfs f0, -0x245c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A2C090: C1AA9E10  lfs f13, -0x61f0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25072 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A2C094: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A2C098: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82A2C09C: 41990008  bgt cr6, 0x82a2c0a4
	if ctx.cr[6].gt {
	pc = 0x82A2C0A4; continue 'dispatch;
	}
	// 82A2C0A0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A2C0A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A2C0A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2C0AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A2C0B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2C0B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A2C0B8 size=24
    let mut pc: u32 = 0x82A2C0B8;
    'dispatch: loop {
        match pc {
            0x82A2C0B8 => {
    //   block [0x82A2C0B8..0x82A2C0D0)
	// 82A2C0B8: 548B1838  slwi r11, r4, 3
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A2C0BC: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82A2C0C0: 806B00F4  lwz r3, 0xf4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A2C0C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2C0C8: 419A0008  beq cr6, 0x82a2c0d0
	if ctx.cr[6].eq {
		sub_82A2C0D0(ctx, base);
		return;
	}
	// 82A2C0CC: 4BFFDC14  b 0x82a29ce0
	sub_82A29CE0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2C0D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A2C0D0 size=8
    let mut pc: u32 = 0x82A2C0D0;
    'dispatch: loop {
        match pc {
            0x82A2C0D0 => {
    //   block [0x82A2C0D0..0x82A2C0D8)
	// 82A2C0D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A2C0D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2C0D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A2C0D8 size=236
    let mut pc: u32 = 0x82A2C0D8;
    'dispatch: loop {
        match pc {
            0x82A2C0D8 => {
    //   block [0x82A2C0D8..0x82A2C1C4)
	// 82A2C0D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2C0DC: 4877C081  bl 0x831a815c
	ctx.lr = 0x82A2C0E0;
	sub_831A8130(ctx, base);
	// 82A2C0E0: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 82A2C0E4: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82A2C0E8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2C0EC: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82A2C0F0: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82A2C0F4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A2C0F8: 3BE300F4  addi r31, r3, 0xf4
	ctx.r[31].s64 = ctx.r[3].s64 + 244;
	// 82A2C0FC: 3FA0832E  lis r29, -0x7cd2
	ctx.r[29].s64 = -2094137344;
	// 82A2C100: 3F80832E  lis r28, -0x7cd2
	ctx.r[28].s64 = -2094137344;
	// 82A2C104: 3F60832E  lis r27, -0x7cd2
	ctx.r[27].s64 = -2094137344;
	// 82A2C108: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2C10C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2C110: 419A0074  beq cr6, 0x82a2c184
	if ctx.cr[6].eq {
	pc = 0x82A2C184; continue 'dispatch;
	}
	// 82A2C114: 4BDC004D  bl 0x827ec160
	ctx.lr = 0x82A2C118;
	sub_827EC160(ctx, base);
	// 82A2C118: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 82A2C11C: 419A0014  beq cr6, 0x82a2c130
	if ctx.cr[6].eq {
	pc = 0x82A2C130; continue 'dispatch;
	}
	// 82A2C120: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2C124: 4BDC003D  bl 0x827ec160
	ctx.lr = 0x82A2C128;
	sub_827EC160(ctx, base);
	// 82A2C128: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 82A2C12C: 409A0058  bne cr6, 0x82a2c184
	if !ctx.cr[6].eq {
	pc = 0x82A2C184; continue 'dispatch;
	}
	// 82A2C130: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2C134: 4BAE59B5  bl 0x82511ae8
	ctx.lr = 0x82A2C138;
	sub_82511AE8(ctx, base);
	// 82A2C138: C01C1650  lfs f0, 0x1650(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5712 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A2C13C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A2C140: C1BB1480  lfs f13, 0x1480(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(5248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A2C144: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A2C148: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82A2C14C: C01D1640  lfs f0, 0x1640(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(5696 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A2C150: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A2C154: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2C1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A2C1C8 size=108
    let mut pc: u32 = 0x82A2C1C8;
    'dispatch: loop {
        match pc {
            0x82A2C1C8 => {
    //   block [0x82A2C1C8..0x82A2C234)
	// 82A2C1C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2C1CC: 4877BF9D  bl 0x831a8168
	ctx.lr = 0x82A2C1D0;
	sub_831A8130(ctx, base);
	// 82A2C1D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2C1D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A2C1D8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A2C1DC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A2C1E0: 3BDD00F4  addi r30, r29, 0xf4
	ctx.r[30].s64 = ctx.r[29].s64 + 244;
	// 82A2C1E4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2C1E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2C1EC: 419A0018  beq cr6, 0x82a2c204
	if ctx.cr[6].eq {
	pc = 0x82A2C204; continue 'dispatch;
	}
	// 82A2C1F0: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 82A2C1F4: 485DCDC5  bl 0x83008fb8
	ctx.lr = 0x82A2C1F8;
	sub_83008FB8(ctx, base);
	// 82A2C1F8: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A2C1FC: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A2C200: 419A0018  beq cr6, 0x82a2c218
	if ctx.cr[6].eq {
	pc = 0x82A2C218; continue 'dispatch;
	}
	// 82A2C204: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82A2C208: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82A2C20C: 2B1F0003  cmplwi cr6, r31, 3
	ctx.cr[6].compare_u32(ctx.r[31].u32, 3 as u32, &mut ctx.xer);
	// 82A2C210: 4198FFD4  blt cr6, 0x82a2c1e4
	if ctx.cr[6].lt {
	pc = 0x82A2C1E4; continue 'dispatch;
	}
	// 82A2C214: 48000018  b 0x82a2c22c
	pc = 0x82A2C22C; continue 'dispatch;
	// 82A2C218: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A2C21C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A2C220: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82A2C224: 806B00F4  lwz r3, 0xf4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A2C228: 4BFFDE49  bl 0x82a2a070
	ctx.lr = 0x82A2C22C;
	sub_82A2A070(ctx, base);
	// 82A2C22C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A2C230: 4877BF88  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2C238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A2C238 size=108
    let mut pc: u32 = 0x82A2C238;
    'dispatch: loop {
        match pc {
            0x82A2C238 => {
    //   block [0x82A2C238..0x82A2C2A4)
	// 82A2C238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2C23C: 4877BF2D  bl 0x831a8168
	ctx.lr = 0x82A2C240;
	sub_831A8130(ctx, base);
	// 82A2C240: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2C244: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A2C248: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A2C24C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A2C250: 3BDD00F4  addi r30, r29, 0xf4
	ctx.r[30].s64 = ctx.r[29].s64 + 244;
	// 82A2C254: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2C258: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2C25C: 419A0018  beq cr6, 0x82a2c274
	if ctx.cr[6].eq {
	pc = 0x82A2C274; continue 'dispatch;
	}
	// 82A2C260: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 82A2C264: 485DCD55  bl 0x83008fb8
	ctx.lr = 0x82A2C268;
	sub_83008FB8(ctx, base);
	// 82A2C268: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A2C26C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A2C270: 419A0018  beq cr6, 0x82a2c288
	if ctx.cr[6].eq {
	pc = 0x82A2C288; continue 'dispatch;
	}
	// 82A2C274: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82A2C278: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82A2C27C: 2B1F0003  cmplwi cr6, r31, 3
	ctx.cr[6].compare_u32(ctx.r[31].u32, 3 as u32, &mut ctx.xer);
	// 82A2C280: 4198FFD4  blt cr6, 0x82a2c254
	if ctx.cr[6].lt {
	pc = 0x82A2C254; continue 'dispatch;
	}
	// 82A2C284: 48000018  b 0x82a2c29c
	pc = 0x82A2C29C; continue 'dispatch;
	// 82A2C288: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A2C28C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A2C290: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82A2C294: 806B00F4  lwz r3, 0xf4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A2C298: 4BFFDA81  bl 0x82a29d18
	ctx.lr = 0x82A2C29C;
	sub_82A29D18(ctx, base);
	// 82A2C29C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A2C2A0: 4877BF18  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2C2A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A2C2A8 size=104
    let mut pc: u32 = 0x82A2C2A8;
    'dispatch: loop {
        match pc {
            0x82A2C2A8 => {
    //   block [0x82A2C2A8..0x82A2C310)
	// 82A2C2A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2C2AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A2C2B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A2C2B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2C2B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2C2BC: 548B1838  slwi r11, r4, 3
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A2C2C0: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82A2C2C4: 806300E4  lwz r3, 0xe4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A2C2C8: 83EB00F4  lwz r31, 0xf4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A2C2CC: 4BFE73B5  bl 0x82a13680
	ctx.lr = 0x82A2C2D0;
	sub_82A13680(ctx, base);
	// 82A2C2D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A2C2D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2C2D8: 4BAE5811  bl 0x82511ae8
	ctx.lr = 0x82A2C2DC;
	sub_82511AE8(ctx, base);
	// 82A2C2DC: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A2C2E0: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82A2C2E4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2C310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A2C310 size=196
    let mut pc: u32 = 0x82A2C310;
    'dispatch: loop {
        match pc {
            0x82A2C310 => {
    //   block [0x82A2C310..0x82A2C3D4)
	// 82A2C310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2C314: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A2C318: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A2C31C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2C320: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2C324: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A2C328: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A2C32C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A2C330: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A2C334: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A2C338: 4B894601  bl 0x822c0938
	ctx.lr = 0x82A2C33C;
	sub_822C0938(ctx, base);
	// 82A2C33C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A2C340: 41820028  beq 0x82a2c368
	if ctx.cr[0].eq {
	pc = 0x82A2C368; continue 'dispatch;
	}
	// 82A2C344: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A2C348: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A2C34C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A2C350: 392BB194  addi r9, r11, -0x4e6c
	ctx.r[9].s64 = ctx.r[11].s64 + -20076;
	// 82A2C354: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A2C358: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A2C35C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A2C360: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A2C364: 48000008  b 0x82a2c36c
	pc = 0x82A2C36C; continue 'dispatch;
	// 82A2C368: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A2C36C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A2C370: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2C374: 409A0044  bne cr6, 0x82a2c3b8
	if !ctx.cr[6].eq {
	pc = 0x82A2C3B8; continue 'dispatch;
	}
	// 82A2C378: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A2C37C: 419A001C  beq cr6, 0x82a2c398
	if ctx.cr[6].eq {
	pc = 0x82A2C398; continue 'dispatch;
	}
	// 82A2C380: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2C384: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A2C388: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2C38C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2C390: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A2C394: 4E800421  bctrl
	ctx.lr = 0x82A2C398;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A2C398: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A2C39C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A2C3A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2C3A4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A2C3A8: 816B1630  lwz r11, 0x1630(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5680 as u32) ) } as u64;
	// 82A2C3AC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A2C3B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A2C3B4: 4B893C4D  bl 0x822c0000
	ctx.lr = 0x82A2C3B8;
	sub_822C0000(ctx, base);
	// 82A2C3B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2C3BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A2C3C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2C3C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A2C3C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A2C3CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A2C3D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2C3D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A2C3D8 size=196
    let mut pc: u32 = 0x82A2C3D8;
    'dispatch: loop {
        match pc {
            0x82A2C3D8 => {
    //   block [0x82A2C3D8..0x82A2C49C)
	// 82A2C3D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2C3DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A2C3E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A2C3E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2C3E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2C3EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A2C3F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A2C3F4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A2C3F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A2C3FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A2C400: 4B894539  bl 0x822c0938
	ctx.lr = 0x82A2C404;
	sub_822C0938(ctx, base);
	// 82A2C404: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A2C408: 41820028  beq 0x82a2c430
	if ctx.cr[0].eq {
	pc = 0x82A2C430; continue 'dispatch;
	}
	// 82A2C40C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A2C410: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A2C414: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A2C418: 392BB1A8  addi r9, r11, -0x4e58
	ctx.r[9].s64 = ctx.r[11].s64 + -20056;
	// 82A2C41C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A2C420: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A2C424: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A2C428: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A2C42C: 48000008  b 0x82a2c434
	pc = 0x82A2C434; continue 'dispatch;
	// 82A2C430: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A2C434: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A2C438: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2C43C: 409A0044  bne cr6, 0x82a2c480
	if !ctx.cr[6].eq {
	pc = 0x82A2C480; continue 'dispatch;
	}
	// 82A2C440: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A2C444: 419A001C  beq cr6, 0x82a2c460
	if ctx.cr[6].eq {
	pc = 0x82A2C460; continue 'dispatch;
	}
	// 82A2C448: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2C44C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A2C450: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2C454: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2C458: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A2C45C: 4E800421  bctrl
	ctx.lr = 0x82A2C460;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A2C460: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 82A2C464: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A2C468: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2C46C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82A2C470: 816B1630  lwz r11, 0x1630(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5680 as u32) ) } as u64;
	// 82A2C474: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A2C478: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A2C47C: 4B893B85  bl 0x822c0000
	ctx.lr = 0x82A2C480;
	sub_822C0000(ctx, base);
	// 82A2C480: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2C484: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A2C488: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2C48C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A2C490: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A2C494: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A2C498: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2C4A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A2C4A0 size=92
    let mut pc: u32 = 0x82A2C4A0;
    'dispatch: loop {
        match pc {
            0x82A2C4A0 => {
    //   block [0x82A2C4A0..0x82A2C4FC)
	// 82A2C4A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2C4A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A2C4A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2C4AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2C4B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2C4B4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A2C4B8: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A2C4BC: 396BB1D4  addi r11, r11, -0x4e2c
	ctx.r[11].s64 = ctx.r[11].s64 + -20012;
	// 82A2C4C0: 394AB1BC  addi r10, r10, -0x4e44
	ctx.r[10].s64 = ctx.r[10].s64 + -20036;
	// 82A2C4C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A2C4C8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A2C4CC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82A2C4D0: 386BDDCC  addi r3, r11, -0x2234
	ctx.r[3].s64 = ctx.r[11].s64 + -8756;
	// 82A2C4D4: 48000C85  bl 0x82a2d158
	ctx.lr = 0x82A2C4D8;
	sub_82A2D158(ctx, base);
	// 82A2C4D8: 387F00F4  addi r3, r31, 0xf4
	ctx.r[3].s64 = ctx.r[31].s64 + 244;
	// 82A2C4DC: 48000A0D  bl 0x82a2cee8
	ctx.lr = 0x82A2C4E0;
	sub_82A2CEE8(ctx, base);
	// 82A2C4E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2C4E4: 4B922E6D  bl 0x8234f350
	ctx.lr = 0x82A2C4E8;
	sub_8234F350(ctx, base);
	// 82A2C4E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A2C4EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2C4F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A2C4F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A2C4F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2C500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A2C500 size=8
    let mut pc: u32 = 0x82A2C500;
    'dispatch: loop {
        match pc {
            0x82A2C500 => {
    //   block [0x82A2C500..0x82A2C508)
	// 82A2C500: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82A2C504: 48000484  b 0x82a2c988
	sub_82A2C988(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2C508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A2C508 size=244
    let mut pc: u32 = 0x82A2C508;
    'dispatch: loop {
        match pc {
            0x82A2C508 => {
    //   block [0x82A2C508..0x82A2C5FC)
	// 82A2C508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2C50C: 4877BC59  bl 0x831a8164
	ctx.lr = 0x82A2C510;
	sub_831A8130(ctx, base);
	// 82A2C510: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2C514: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A2C518: 3B800002  li r28, 2
	ctx.r[28].s64 = 2;
	// 82A2C51C: 3BFD0104  addi r31, r29, 0x104
	ctx.r[31].s64 = ctx.r[29].s64 + 260;
	// 82A2C520: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A2C524: 80BD00E4  lwz r5, 0xe4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A2C528: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A2C52C: 4BFFD0F5  bl 0x82a29620
	ctx.lr = 0x82A2C530;
	sub_82A29620(ctx, base);
	// 82A2C530: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A2C534: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 82A2C538: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82A2C53C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2C540: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2C544: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A2C548: 4B897F19  bl 0x822c4460
	ctx.lr = 0x82A2C54C;
	sub_822C4460(ctx, base);
	// 82A2C54C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A2C550: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2C554: 419A0008  beq cr6, 0x82a2c55c
	if ctx.cr[6].eq {
	pc = 0x82A2C55C; continue 'dispatch;
	}
	// 82A2C558: 4B894339  bl 0x822c0890
	ctx.lr = 0x82A2C55C;
	sub_822C0890(ctx, base);
	// 82A2C55C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2C560: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2C564: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2C568: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A2C56C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A2C570: 419A0024  beq cr6, 0x82a2c594
	if ctx.cr[6].eq {
	pc = 0x82A2C594; continue 'dispatch;
	}
	// 82A2C574: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A2C578: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A2C57C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A2C580: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A2C584: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A2C588: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A2C58C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A2C590: 4082FFE8  bne 0x82a2c578
	if !ctx.cr[0].eq {
	pc = 0x82A2C578; continue 'dispatch;
	}
	// 82A2C594: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A2C598: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A2C59C: 4BAE2F2D  bl 0x8250f4c8
	ctx.lr = 0x82A2C5A0;
	sub_8250F4C8(ctx, base);
	// 82A2C5A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2C5A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2C5A8: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 82A2C5AC: 409A0008  bne cr6, 0x82a2c5b4
	if !ctx.cr[6].eq {
	pc = 0x82A2C5B4; continue 'dispatch;
	}
	// 82A2C5B0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A2C5B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A2C5B8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A2C5BC: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 82A2C5C0: 4BAE2F59  bl 0x8250f518
	ctx.lr = 0x82A2C5C4;
	sub_8250F518(ctx, base);
	// 82A2C5C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A2C5C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2C5CC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A2C5D0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A2C5D4: 4BAE0F35  bl 0x8250d508
	ctx.lr = 0x82A2C5D8;
	sub_8250D508(ctx, base);
	// 82A2C5D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A2C5DC: 483C56B5  bl 0x82df1c90
	ctx.lr = 0x82A2C5E0;
	sub_82DF1C90(ctx, base);
	// 82A2C5E0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A2C5E4: 483C56AD  bl 0x82df1c90
	ctx.lr = 0x82A2C5E8;
	sub_82DF1C90(ctx, base);
	// 82A2C5E8: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82A2C5EC: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 82A2C5F0: 4080FF30  bge 0x82a2c520
	if !ctx.cr[0].lt {
	pc = 0x82A2C520; continue 'dispatch;
	}
	// 82A2C5F4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A2C5F8: 4877BBBC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2C600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A2C600 size=392
    let mut pc: u32 = 0x82A2C600;
    'dispatch: loop {
        match pc {
            0x82A2C600 => {
    //   block [0x82A2C600..0x82A2C788)
	// 82A2C600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2C604: 4877BB65  bl 0x831a8168
	ctx.lr = 0x82A2C608;
	sub_831A8130(ctx, base);
	// 82A2C608: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2C60C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2C610: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A2C614: 4BAE40F5  bl 0x82510708
	ctx.lr = 0x82A2C618;
	sub_82510708(ctx, base);
	// 82A2C618: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A2C61C: 3BABB180  addi r29, r11, -0x4e80
	ctx.r[29].s64 = ctx.r[11].s64 + -20096;
	// 82A2C620: 897F0110  lbz r11, 0x110(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82A2C624: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A2C628: 4082004C  bne 0x82a2c674
	if !ctx.cr[0].eq {
	pc = 0x82A2C674; continue 'dispatch;
	}
	// 82A2C62C: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A2C630: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A2C634: C1BF010C  lfs f13, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A2C638: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A2C63C: D1BF010C  stfs f13, 0x10c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82A2C640: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A2C644: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A2C648: 4098002C  bge cr6, 0x82a2c674
	if !ctx.cr[6].lt {
	pc = 0x82A2C674; continue 'dispatch;
	}
	// 82A2C64C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A2C650: 807F00E4  lwz r3, 0xe4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82A2C654: 388BB210  addi r4, r11, -0x4df0
	ctx.r[4].s64 = ctx.r[11].s64 + -19952;
	// 82A2C658: 4BFEA569  bl 0x82a16bc0
	ctx.lr = 0x82A2C65C;
	sub_82A16BC0(ctx, base);
	// 82A2C65C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2C660: 41820014  beq 0x82a2c674
	if ctx.cr[0].eq {
	pc = 0x82A2C674; continue 'dispatch;
	}
	// 82A2C664: C1BF010C  lfs f13, 0x10c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A2C668: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A2C66C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A2C670: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82A2C674: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82A2C678: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A2C67C: 419800B4  blt cr6, 0x82a2c730
	if ctx.cr[6].lt {
	pc = 0x82A2C730; continue 'dispatch;
	}
	// 82A2C680: 409A0100  bne cr6, 0x82a2c780
	if !ctx.cr[6].eq {
	pc = 0x82A2C780; continue 'dispatch;
	}
	// 82A2C684: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A2C688: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A2C68C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2C690: 4BFFFA49  bl 0x82a2c0d8
	ctx.lr = 0x82A2C694;
	sub_82A2C0D8(ctx, base);
	// 82A2C694: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2C698: 4182001C  beq 0x82a2c6b4
	if ctx.cr[0].eq {
	pc = 0x82A2C6B4; continue 'dispatch;
	}
	// 82A2C69C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A2C6A0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82A2C6A4: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A2C6A8: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A2C6AC: 806B00F4  lwz r3, 0xf4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A2C6B0: 4BFFD8A1  bl 0x82a29f50
	ctx.lr = 0x82A2C6B4;
	sub_82A29F50(ctx, base);
	// 82A2C6B4: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A2C6B8: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A2C6BC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A2C6C0: 814B00F4  lwz r10, 0xf4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A2C6C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A2C6C8: 419A00B8  beq cr6, 0x82a2c780
	if ctx.cr[6].eq {
	pc = 0x82A2C780; continue 'dispatch;
	}
	// 82A2C6CC: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A2C6D0: 4BDBFA91  bl 0x827ec160
	ctx.lr = 0x82A2C6D4;
	sub_827EC160(ctx, base);
	// 82A2C6D4: 2F030008  cmpwi cr6, r3, 8
	ctx.cr[6].compare_i32(ctx.r[3].s32, 8, &mut ctx.xer);
	// 82A2C6D8: 419A0014  beq cr6, 0x82a2c6ec
	if ctx.cr[6].eq {
	pc = 0x82A2C6EC; continue 'dispatch;
	}
	// 82A2C6DC: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82A2C6E0: 419A000C  beq cr6, 0x82a2c6ec
	if ctx.cr[6].eq {
	pc = 0x82A2C6EC; continue 'dispatch;
	}
	// 82A2C6E4: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 82A2C6E8: 409A0098  bne cr6, 0x82a2c780
	if !ctx.cr[6].eq {
	pc = 0x82A2C780; continue 'dispatch;
	}
	// 82A2C6EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A2C6F0: 48001581  bl 0x82a2dc70
	ctx.lr = 0x82A2C6F4;
	sub_82A2DC70(ctx, base);
	// 82A2C6F4: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A2C6F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2C6FC: 419A0018  beq cr6, 0x82a2c714
	if ctx.cr[6].eq {
	pc = 0x82A2C714; continue 'dispatch;
	}
	// 82A2C700: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A2C704: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A2C708: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82A2C70C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2C710: 48000DE1  bl 0x82a2d4f0
	ctx.lr = 0x82A2C714;
	sub_82A2D4F0(ctx, base);
	// 82A2C714: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A2C718: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A2C71C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2C720: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82A2C724: 419A005C  beq cr6, 0x82a2c780
	if ctx.cr[6].eq {
	pc = 0x82A2C780; continue 'dispatch;
	}
	// 82A2C728: 4B894169  bl 0x822c0890
	ctx.lr = 0x82A2C72C;
	sub_822C0890(ctx, base);
	// 82A2C72C: 48000054  b 0x82a2c780
	pc = 0x82A2C780; continue 'dispatch;
	// 82A2C730: 3BDF00F0  addi r30, r31, 0xf0
	ctx.r[30].s64 = ctx.r[31].s64 + 240;
	// 82A2C734: 3BBF00EC  addi r29, r31, 0xec
	ctx.r[29].s64 = ctx.r[31].s64 + 236;
	// 82A2C738: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A2C73C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A2C740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2C744: 4BFFF995  bl 0x82a2c0d8
	ctx.lr = 0x82A2C748;
	sub_82A2C0D8(ctx, base);
	// 82A2C748: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2C74C: 41820034  beq 0x82a2c780
	if ctx.cr[0].eq {
	pc = 0x82A2C780; continue 'dispatch;
	}
	// 82A2C750: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2C754: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82A2C758: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2C75C: 9B9F0110  stb r28, 0x110(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[28].u8 ) };
	// 82A2C760: 409A0020  bne cr6, 0x82a2c780
	if !ctx.cr[6].eq {
	pc = 0x82A2C780; continue 'dispatch;
	}
	// 82A2C764: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2C768: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82A2C76C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A2C770: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A2C774: 806B00F4  lwz r3, 0xf4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A2C778: 4BFFD7D9  bl 0x82a29f50
	ctx.lr = 0x82A2C77C;
	sub_82A29F50(ctx, base);
	// 82A2C77C: 939F00E8  stw r28, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[28].u32 ) };
	// 82A2C780: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A2C784: 4877BA34  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2C788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A2C788 size=216
    let mut pc: u32 = 0x82A2C788;
    'dispatch: loop {
        match pc {
            0x82A2C788 => {
    //   block [0x82A2C788..0x82A2C860)
	// 82A2C788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2C78C: 4877B9D5  bl 0x831a8160
	ctx.lr = 0x82A2C790;
	sub_831A8130(ctx, base);
	// 82A2C790: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 82A2C794: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82A2C798: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2C79C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A2C7A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A2C7A4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82A2C7A8: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82A2C7AC: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 82A2C7B0: C3CB9534  lfs f30, -0x6acc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82A2C7B4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A2C7B8: 3B9E00F4  addi r28, r30, 0xf4
	ctx.r[28].s64 = ctx.r[30].s64 + 244;
	// 82A2C7BC: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	// 82A2C7C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2C7C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2C7C8: 4BFFF899  bl 0x82a2c060
	ctx.lr = 0x82A2C7CC;
	sub_82A2C060(ctx, base);
	// 82A2C7CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2C7D0: 41820048  beq 0x82a2c818
	if ctx.cr[0].eq {
	pc = 0x82A2C818; continue 'dispatch;
	}
	// 82A2C7D4: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2C7D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2C7DC: 419A000C  beq cr6, 0x82a2c7e8
	if ctx.cr[6].eq {
	pc = 0x82A2C7E8; continue 'dispatch;
	}
	// 82A2C7E0: 4BFFD501  bl 0x82a29ce0
	ctx.lr = 0x82A2C7E4;
	sub_82A29CE0(ctx, base);
	// 82A2C7E4: 48000008  b 0x82a2c7ec
	pc = 0x82A2C7EC; continue 'dispatch;
	// 82A2C7E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A2C7EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2C7F0: 41820028  beq 0x82a2c818
	if ctx.cr[0].eq {
	pc = 0x82A2C818; continue 'dispatch;
	}
	// 82A2C7F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2C7F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2C7FC: 4BFFFAAD  bl 0x82a2c2a8
	ctx.lr = 0x82A2C800;
	sub_82A2C2A8(ctx, base);
	// 82A2C800: FF1FF000  fcmpu cr6, f31, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 82A2C804: 419A000C  beq cr6, 0x82a2c810
	if ctx.cr[6].eq {
	pc = 0x82A2C810; continue 'dispatch;
	}
	// 82A2C808: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 82A2C80C: 4098000C  bge cr6, 0x82a2c818
	if !ctx.cr[6].lt {
	pc = 0x82A2C818; continue 'dispatch;
	}
	// 82A2C810: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82A2C814: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A2C818: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82A2C81C: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 82A2C820: 2B1F0003  cmplwi cr6, r31, 3
	ctx.cr[6].compare_u32(ctx.r[31].u32, 3 as u32, &mut ctx.xer);
	// 82A2C824: 4198FF9C  blt cr6, 0x82a2c7c0
	if ctx.cr[6].lt {
	pc = 0x82A2C7C0; continue 'dispatch;
	}
	// 82A2C828: 2F1DFFFF  cmpwi cr6, r29, -1
	ctx.cr[6].compare_i32(ctx.r[29].s32, -1, &mut ctx.xer);
	// 82A2C82C: 419A0020  beq cr6, 0x82a2c84c
	if ctx.cr[6].eq {
	pc = 0x82A2C84C; continue 'dispatch;
	}
	// 82A2C830: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A2C834: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A2C838: 806B00F4  lwz r3, 0xf4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A2C83C: 4BAE52AD  bl 0x82511ae8
	ctx.lr = 0x82A2C840;
	sub_82511AE8(ctx, base);
	// 82A2C840: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2C860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A2C860 size=140
    let mut pc: u32 = 0x82A2C860;
    'dispatch: loop {
        match pc {
            0x82A2C860 => {
    //   block [0x82A2C860..0x82A2C8EC)
	// 82A2C860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2C864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A2C868: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A2C86C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2C870: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2C874: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2C878: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A2C87C: 4BAE515D  bl 0x825119d8
	ctx.lr = 0x82A2C880;
	sub_825119D8(ctx, base);
	// 82A2C880: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A2C884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2C888: 4BAE2AE9  bl 0x8250f370
	ctx.lr = 0x82A2C88C;
	sub_8250F370(ctx, base);
	// 82A2C88C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82A2C890: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2C894: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82A2C898: 483C7171  bl 0x82df3a08
	ctx.lr = 0x82A2C89C;
	sub_82DF3A08(ctx, base);
	// 82A2C89C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A2C8A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A2C8A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2C8A8: 4BADBED9  bl 0x82508780
	ctx.lr = 0x82A2C8AC;
	sub_82508780(ctx, base);
	// 82A2C8AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2C8B0: 483C6B79  bl 0x82df3428
	ctx.lr = 0x82A2C8B4;
	sub_82DF3428(ctx, base);
	// 82A2C8B4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A2C8B8: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82A2C8BC: 409A0008  bne cr6, 0x82a2c8c4
	if !ctx.cr[6].eq {
	pc = 0x82A2C8C4; continue 'dispatch;
	}
	// 82A2C8C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A2C8C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2C8C8: 4BADBED9  bl 0x825087a0
	ctx.lr = 0x82A2C8CC;
	sub_825087A0(ctx, base);
	// 82A2C8CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2C8D0: 4BFFFC39  bl 0x82a2c508
	ctx.lr = 0x82A2C8D4;
	sub_82A2C508(ctx, base);
	// 82A2C8D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A2C8D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2C8DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A2C8E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A2C8E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A2C8E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2C8F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A2C8F0 size=152
    let mut pc: u32 = 0x82A2C8F0;
    'dispatch: loop {
        match pc {
            0x82A2C8F0 => {
    //   block [0x82A2C8F0..0x82A2C988)
	// 82A2C8F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2C8F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A2C8F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A2C8FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2C900: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2C904: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2C908: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A2C90C: 4BAE5A25  bl 0x82512330
	ctx.lr = 0x82A2C910;
	sub_82512330(ctx, base);
	// 82A2C910: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A2C914: 93DF00E4  stw r30, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[30].u32 ) };
	// 82A2C918: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 82A2C91C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82A2C920: 396BB1D4  addi r11, r11, -0x4e2c
	ctx.r[11].s64 = ctx.r[11].s64 + -20012;
	// 82A2C924: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A2C928: 915F00EC  stw r10, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[10].u32 ) };
	// 82A2C92C: 3908B1BC  addi r8, r8, -0x4e44
	ctx.r[8].s64 = ctx.r[8].s64 + -20036;
	// 82A2C930: 915F00F0  stw r10, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[10].u32 ) };
	// 82A2C934: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A2C938: 397F00F4  addi r11, r31, 0xf4
	ctx.r[11].s64 = ctx.r[31].s64 + 244;
	// 82A2C93C: 911F0028  stw r8, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[8].u32 ) };
	// 82A2C940: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82A2C944: 913F00E8  stw r9, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 82A2C948: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A2C94C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A2C950: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A2C954: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A2C958: 4080FFF0  bge 0x82a2c948
	if !ctx.cr[0].lt {
	pc = 0x82A2C948; continue 'dispatch;
	}
	// 82A2C95C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A2C960: 993F0110  stb r9, 0x110(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[9].u8 ) };
	// 82A2C964: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2C968: C00BB18C  lfs f0, -0x4e74(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20084 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A2C96C: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82A2C970: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A2C974: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2C978: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A2C97C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A2C980: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A2C984: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2C988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A2C988 size=76
    let mut pc: u32 = 0x82A2C988;
    'dispatch: loop {
        match pc {
            0x82A2C988 => {
    //   block [0x82A2C988..0x82A2C9D4)
	// 82A2C988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2C98C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A2C990: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A2C994: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2C998: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2C99C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2C9A0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A2C9A4: 4BFFFAFD  bl 0x82a2c4a0
	ctx.lr = 0x82A2C9A8;
	sub_82A2C4A0(ctx, base);
	// 82A2C9A8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2C9AC: 4182000C  beq 0x82a2c9b8
	if ctx.cr[0].eq {
	pc = 0x82A2C9B8; continue 'dispatch;
	}
	// 82A2C9B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2C9B4: 483C5A25  bl 0x82df23d8
	ctx.lr = 0x82A2C9B8;
	sub_82DF23D8(ctx, base);
	// 82A2C9B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2C9BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A2C9C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2C9C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A2C9C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A2C9CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A2C9D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2C9D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A2C9D8 size=56
    let mut pc: u32 = 0x82A2C9D8;
    'dispatch: loop {
        match pc {
            0x82A2C9D8 => {
    //   block [0x82A2C9D8..0x82A2CA10)
	// 82A2C9D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2C9DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A2C9E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2C9E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2C9E8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82A2C9EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2C9F0: 388BDDCC  addi r4, r11, -0x2234
	ctx.r[4].s64 = ctx.r[11].s64 + -8756;
	// 82A2C9F4: 4BF9BD65  bl 0x829c8758
	ctx.lr = 0x82A2C9F8;
	sub_829C8758(ctx, base);
	// 82A2C9F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2C9FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A2CA00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2CA04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A2CA08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A2CA0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2CA10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A2CA10 size=128
    let mut pc: u32 = 0x82A2CA10;
    'dispatch: loop {
        match pc {
            0x82A2CA10 => {
    //   block [0x82A2CA10..0x82A2CA90)
	// 82A2CA10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2CA14: 4877B759  bl 0x831a816c
	ctx.lr = 0x82A2CA18;
	sub_831A8130(ctx, base);
	// 82A2CA18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2CA1C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82A2CA20: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A2CA24: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A2CA28: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A2CA2C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A2CA30: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82A2CA34: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82A2CA38: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82A2CA3C: 483C59AD  bl 0x82df23e8
	ctx.lr = 0x82A2CA40;
	sub_82DF23E8(ctx, base);
	// 82A2CA40: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A2CA44: 41820018  beq 0x82a2ca5c
	if ctx.cr[0].eq {
	pc = 0x82A2CA5C; continue 'dispatch;
	}
	// 82A2CA48: 88BE0000  lbz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2CA4C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2CA50: 4BEE9099  bl 0x82915ae8
	ctx.lr = 0x82A2CA54;
	sub_82915AE8(ctx, base);
	// 82A2CA54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2CA58: 48000008  b 0x82a2ca60
	pc = 0x82A2CA60; continue 'dispatch;
	// 82A2CA5C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A2CA60: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A2CA64: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82A2CA68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2CA6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2CA70: 4BFFF969  bl 0x82a2c3d8
	ctx.lr = 0x82A2CA74;
	sub_82A2C3D8(ctx, base);
	// 82A2CA74: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A2CA78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2CA7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2CA80: 4B893581  bl 0x822c0000
	ctx.lr = 0x82A2CA84;
	sub_822C0000(ctx, base);
	// 82A2CA84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A2CA88: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A2CA8C: 4877B730  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2CA90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A2CA90 size=224
    let mut pc: u32 = 0x82A2CA90;
    'dispatch: loop {
        match pc {
            0x82A2CA90 => {
    //   block [0x82A2CA90..0x82A2CB70)
	// 82A2CA90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2CA94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A2CA98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A2CA9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2CAA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2CAA4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A2CAA8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A2CAAC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A2CAB0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A2CAB4: 388BB220  addi r4, r11, -0x4de0
	ctx.r[4].s64 = ctx.r[11].s64 + -19936;
	// 82A2CAB8: 38A00045  li r5, 0x45
	ctx.r[5].s64 = 69;
	// 82A2CABC: 38600114  li r3, 0x114
	ctx.r[3].s64 = 276;
	// 82A2CAC0: 483C5929  bl 0x82df23e8
	ctx.lr = 0x82A2CAC4;
	sub_82DF23E8(ctx, base);
	// 82A2CAC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82A2CAC8: 41820014  beq 0x82a2cadc
	if ctx.cr[0].eq {
	pc = 0x82A2CADC; continue 'dispatch;
	}
	// 82A2CACC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2CAD0: 4BFFFE21  bl 0x82a2c8f0
	ctx.lr = 0x82A2CAD4;
	sub_82A2C8F0(ctx, base);
	// 82A2CAD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A2CAD8: 48000008  b 0x82a2cae0
	pc = 0x82A2CAE0; continue 'dispatch;
	// 82A2CADC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A2CAE0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A2CAE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2CAE8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A2CAEC: 4BFFF825  bl 0x82a2c310
	ctx.lr = 0x82A2CAF0;
	sub_82A2C310(ctx, base);
	// 82A2CAF0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A2CAF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2CAF8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A2CAFC: 4B893505  bl 0x822c0000
	ctx.lr = 0x82A2CB00;
	sub_822C0000(ctx, base);
	// 82A2CB00: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A2CB04: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82A2CB08: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A2CB0C: 396ADDCC  addi r11, r10, -0x2234
	ctx.r[11].s64 = ctx.r[10].s64 + -8756;
	// 82A2CB10: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82A2CB14: 93EADDCC  stw r31, -0x2234(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8756 as u32), ctx.r[31].u32 ) };
	// 82A2CB18: 4BAC9799  bl 0x824f62b0
	ctx.lr = 0x82A2CB1C;
	sub_824F62B0(ctx, base);
	// 82A2CB1C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A2CB20: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A2CB24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2CB28: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82A2CB2C: 419A0028  beq cr6, 0x82a2cb54
	if ctx.cr[6].eq {
	pc = 0x82A2CB54; continue 'dispatch;
	}
	// 82A2CB30: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 82A2CB34: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A2CB38: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A2CB3C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A2CB40: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A2CB44: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A2CB48: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A2CB4C: 4082FFE8  bne 0x82a2cb34
	if !ctx.cr[0].eq {
	pc = 0x82A2CB34; continue 'dispatch;
	}
	// 82A2CB50: 4B893D41  bl 0x822c0890
	ctx.lr = 0x82A2CB54;
	sub_822C0890(ctx, base);
	// 82A2CB54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2CB58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A2CB5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2CB60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A2CB64: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A2CB68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A2CB6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2CB70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A2CB70 size=448
    let mut pc: u32 = 0x82A2CB70;
    'dispatch: loop {
        match pc {
            0x82A2CB70 => {
    //   block [0x82A2CB70..0x82A2CD30)
	// 82A2CB70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2CB74: 4877B5F1  bl 0x831a8164
	ctx.lr = 0x82A2CB78;
	sub_831A8130(ctx, base);
	// 82A2CB78: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2CB7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A2CB80: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A2CB84: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82A2CB88: 3BBE00F4  addi r29, r30, 0xf4
	ctx.r[29].s64 = ctx.r[30].s64 + 244;
	// 82A2CB8C: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82A2CB90: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2CB94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2CB98: 419A0020  beq cr6, 0x82a2cbb8
	if ctx.cr[6].eq {
	pc = 0x82A2CBB8; continue 'dispatch;
	}
	// 82A2CB9C: 4BFFD145  bl 0x82a29ce0
	ctx.lr = 0x82A2CBA0;
	sub_82A29CE0(ctx, base);
	// 82A2CBA0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2CBA4: 41820014  beq 0x82a2cbb8
	if ctx.cr[0].eq {
	pc = 0x82A2CBB8; continue 'dispatch;
	}
	// 82A2CBA8: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2CBAC: 4BFFD15D  bl 0x82a29d08
	ctx.lr = 0x82A2CBB0;
	sub_82A29D08(ctx, base);
	// 82A2CBB0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2CBB4: 418200C0  beq 0x82a2cc74
	if ctx.cr[0].eq {
	pc = 0x82A2CC74; continue 'dispatch;
	}
	// 82A2CBB8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82A2CBBC: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82A2CBC0: 2B1F0003  cmplwi cr6, r31, 3
	ctx.cr[6].compare_u32(ctx.r[31].u32, 3 as u32, &mut ctx.xer);
	// 82A2CBC4: 4198FFCC  blt cr6, 0x82a2cb90
	if ctx.cr[6].lt {
	pc = 0x82A2CB90; continue 'dispatch;
	}
	// 82A2CBC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A2CBCC: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82A2CBD0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A2CBD4: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82A2CBD8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A2CBDC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A2CBE0: 4BFFFE31  bl 0x82a2ca10
	ctx.lr = 0x82A2CBE4;
	sub_82A2CA10(ctx, base);
	// 82A2CBE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2CBE8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A2CBEC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A2CBF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2CBF4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A2CBF8: 419A0024  beq cr6, 0x82a2cc1c
	if ctx.cr[6].eq {
	pc = 0x82A2CC1C; continue 'dispatch;
	}
	// 82A2CBFC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A2CC00: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A2CC04: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A2CC08: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A2CC0C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A2CC10: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A2CC14: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A2CC18: 4082FFE8  bne 0x82a2cc00
	if !ctx.cr[0].eq {
	pc = 0x82A2CC00; continue 'dispatch;
	}
	// 82A2CC1C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A2CC20: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 82A2CC24: 485DB505  bl 0x83008128
	ctx.lr = 0x82A2CC28;
	sub_83008128(ctx, base);
	// 82A2CC28: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A2CC2C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A2CC30: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A2CC34: 388AB220  addi r4, r10, -0x4de0
	ctx.r[4].s64 = ctx.r[10].s64 + -19936;
	// 82A2CC38: 38A001B8  li r5, 0x1b8
	ctx.r[5].s64 = 440;
	// 82A2CC3C: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82A2CC40: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A2CC44: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A2CC48: 4842BDF9  bl 0x82e58a40
	ctx.lr = 0x82A2CC4C;
	sub_82E58A40(ctx, base);
	// 82A2CC4C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A2CC50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2CC54: 419A0008  beq cr6, 0x82a2cc5c
	if ctx.cr[6].eq {
	pc = 0x82A2CC5C; continue 'dispatch;
	}
	// 82A2CC58: 4B893C39  bl 0x822c0890
	ctx.lr = 0x82A2CC5C;
	sub_822C0890(ctx, base);
	// 82A2CC5C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A2CC60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2CC64: 419A0008  beq cr6, 0x82a2cc6c
	if ctx.cr[6].eq {
	pc = 0x82A2CC6C; continue 'dispatch;
	}
	// 82A2CC68: 4B893C29  bl 0x822c0890
	ctx.lr = 0x82A2CC6C;
	sub_822C0890(ctx, base);
	// 82A2CC6C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A2CC70: 4877B544  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
	// 82A2CC74: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A2CC78: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A2CC7C: 7FEBF214  add r31, r11, r30
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A2CC80: 397F00F4  addi r11, r31, 0xf4
	ctx.r[11].s64 = ctx.r[31].s64 + 244;
	// 82A2CC84: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A2CC88: 4BFFD091  bl 0x82a29d18
	ctx.lr = 0x82A2CC8C;
	sub_82A29D18(ctx, base);
	// 82A2CC8C: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A2CC90: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	// 82A2CC94: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 82A2CC98: 485DC321  bl 0x83008fb8
	ctx.lr = 0x82A2CC9C;
	sub_83008FB8(ctx, base);
	// 82A2CC9C: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82A2CCA0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A2CCA4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A2CCA8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A2CCAC: 4BFFFD65  bl 0x82a2ca10
	ctx.lr = 0x82A2CCB0;
	sub_82A2CA10(ctx, base);
	// 82A2CCB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2CCB4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A2CCB8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A2CCBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2CCC0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A2CCC4: 419A0024  beq cr6, 0x82a2cce8
	if ctx.cr[6].eq {
	pc = 0x82A2CCE8; continue 'dispatch;
	}
	// 82A2CCC8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A2CCCC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A2CCD0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A2CCD4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A2CCD8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A2CCDC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A2CCE0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A2CCE4: 4082FFE8  bne 0x82a2cccc
	if !ctx.cr[0].eq {
	pc = 0x82A2CCCC; continue 'dispatch;
	}
	// 82A2CCE8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A2CCEC: 3BE10058  addi r31, r1, 0x58
	ctx.r[31].s64 = ctx.r[1].s64 + 88;
	// 82A2CCF0: 485DB439  bl 0x83008128
	ctx.lr = 0x82A2CCF4;
	sub_83008128(ctx, base);
	// 82A2CCF4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A2CCF8: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A2CCFC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A2CD00: 388AB220  addi r4, r10, -0x4de0
	ctx.r[4].s64 = ctx.r[10].s64 + -19936;
	// 82A2CD04: 38A001B2  li r5, 0x1b2
	ctx.r[5].s64 = 434;
	// 82A2CD08: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82A2CD0C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A2CD10: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A2CD14: 4842BD2D  bl 0x82e58a40
	ctx.lr = 0x82A2CD18;
	sub_82E58A40(ctx, base);
	// 82A2CD18: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A2CD1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A2CD20: 419A0008  beq cr6, 0x82a2cd28
	if ctx.cr[6].eq {
	pc = 0x82A2CD28; continue 'dispatch;
	}
	// 82A2CD24: 4B893B6D  bl 0x822c0890
	ctx.lr = 0x82A2CD28;
	sub_822C0890(ctx, base);
	// 82A2CD28: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A2CD2C: 4BFFFF34  b 0x82a2cc60
	pc = 0x82A2CC60; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2CD30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A2CD30 size=220
    let mut pc: u32 = 0x82A2CD30;
    'dispatch: loop {
        match pc {
            0x82A2CD30 => {
    //   block [0x82A2CD30..0x82A2CE0C)
	// 82A2CD30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2CD34: 4877B435  bl 0x831a8168
	ctx.lr = 0x82A2CD38;
	sub_831A8130(ctx, base);
	// 82A2CD38: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2CD3C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A2CD40: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A2CD44: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A2CD48: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A2CD4C: 41820038  beq 0x82a2cd84
	if ctx.cr[0].eq {
	pc = 0x82A2CD84; continue 'dispatch;
	}
	// 82A2CD50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2CD54: 4877CC35  bl 0x831a9988
	ctx.lr = 0x82A2CD58;
	sub_831A9988(ctx, base);
	// 82A2CD58: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82A2CD5C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A2CD60: 386BE82C  addi r3, r11, -0x17d4
	ctx.r[3].s64 = ctx.r[11].s64 + -6100;
	// 82A2CD64: 4877B395  bl 0x831a80f8
	ctx.lr = 0x82A2CD68;
	sub_831A80F8(ctx, base);
	// 82A2CD68: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2CD6C: 41820018  beq 0x82a2cd84
	if ctx.cr[0].eq {
	pc = 0x82A2CD84; continue 'dispatch;
	}
	// 82A2CD70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2CD74: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A2CD78: 4BFFF451  bl 0x82a2c1c8
	ctx.lr = 0x82A2CD7C;
	sub_82A2C1C8(ctx, base);
	// 82A2CD7C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A2CD80: 48000084  b 0x82a2ce04
	pc = 0x82A2CE04; continue 'dispatch;
	// 82A2CD84: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A2CD88: 419A006C  beq cr6, 0x82a2cdf4
	if ctx.cr[6].eq {
	pc = 0x82A2CDF4; continue 'dispatch;
	}
	// 82A2CD8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2CD90: 4877CBF9  bl 0x831a9988
	ctx.lr = 0x82A2CD94;
	sub_831A9988(ctx, base);
	// 82A2CD94: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82A2CD98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A2CD9C: 386BE6CC  addi r3, r11, -0x1934
	ctx.r[3].s64 = ctx.r[11].s64 + -6452;
	// 82A2CDA0: 4877B359  bl 0x831a80f8
	ctx.lr = 0x82A2CDA4;
	sub_831A80F8(ctx, base);
	// 82A2CDA4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2CDA8: 41820014  beq 0x82a2cdbc
	if ctx.cr[0].eq {
	pc = 0x82A2CDBC; continue 'dispatch;
	}
	// 82A2CDAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2CDB0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A2CDB4: 4BFFFDBD  bl 0x82a2cb70
	ctx.lr = 0x82A2CDB8;
	sub_82A2CB70(ctx, base);
	// 82A2CDB8: 4BFFFFC4  b 0x82a2cd7c
	pc = 0x82A2CD7C; continue 'dispatch;
	// 82A2CDBC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A2CDC0: 419A0034  beq cr6, 0x82a2cdf4
	if ctx.cr[6].eq {
	pc = 0x82A2CDF4; continue 'dispatch;
	}
	// 82A2CDC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A2CDC8: 4877CBC1  bl 0x831a9988
	ctx.lr = 0x82A2CDCC;
	sub_831A9988(ctx, base);
	// 82A2CDCC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82A2CDD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A2CDD4: 386BE704  addi r3, r11, -0x18fc
	ctx.r[3].s64 = ctx.r[11].s64 + -6396;
	// 82A2CDD8: 4877B321  bl 0x831a80f8
	ctx.lr = 0x82A2CDDC;
	sub_831A80F8(ctx, base);
	// 82A2CDDC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2CDE0: 41820014  beq 0x82a2cdf4
	if ctx.cr[0].eq {
	pc = 0x82A2CDF4; continue 'dispatch;
	}
	// 82A2CDE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2CDE8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82A2CDEC: 4BFFF44D  bl 0x82a2c238
	ctx.lr = 0x82A2CDF0;
	sub_82A2C238(ctx, base);
	// 82A2CDF0: 4BFFFF8C  b 0x82a2cd7c
	pc = 0x82A2CD7C; continue 'dispatch;
	// 82A2CDF4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A2CDF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A2CDFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A2CE00: 4BAE5819  bl 0x82512618
	ctx.lr = 0x82A2CE04;
	sub_82512618(ctx, base);
	// 82A2CE04: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A2CE08: 4877B3B0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2CE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A2CE10 size=12
    let mut pc: u32 = 0x82A2CE10;
    'dispatch: loop {
        match pc {
            0x82A2CE10 => {
    //   block [0x82A2CE10..0x82A2CE1C)
	// 82A2CE10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A2CE14: 916300F4  stw r11, 0xf4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 82A2CE18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A2CE20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A2CE20 size=196
    let mut pc: u32 = 0x82A2CE20;
    'dispatch: loop {
        match pc {
            0x82A2CE20 => {
    //   block [0x82A2CE20..0x82A2CEE4)
	// 82A2CE20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2CE24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A2CE28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A2CE2C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2CE30: 83E300F4  lwz r31, 0xf4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A2CE34: 806300F0  lwz r3, 0xf0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(240 as u32) ) } as u64;
	// 82A2CE38: 4BFE6159  bl 0x82a12f90
	ctx.lr = 0x82A2CE3C;
	sub_82A12F90(ctx, base);
	// 82A2CE3C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A2CE40: 4082008C  bne 0x82a2cecc
	if !ctx.cr[0].eq {
	pc = 0x82A2CECC; continue 'dispatch;
	}
	// 82A2CE44: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A2CE48: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82A2CE4C: 396BB3C8  addi r11, r11, -0x4c38
	ctx.r[11].s64 = ctx.r[11].s64 + -19512;
	// 82A2CE50: 7FE907B4  extsw r9, r31
	ctx.r[9].s64 = ctx.r[31].s32 as i64;
	// 82A2CE54: 3D008202  lis r8, -0x7dfe
	ctx.r[8].s64 = -2113798144;
	// 82A2CE58: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82A2CE5C: C9A10050  lfd f13, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A2CE60: C00A9528  lfs f0, -0x6ad8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A2CE64: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82A2CE68: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2CE6C: C1886218  lfs f12, 0x6218(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(25112 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A2CE70: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82A2CE74: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A2CE78: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A2CE7C: ED6B0332  fmuls f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82A2CE80: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82A2CE84: 4099000C  ble cr6, 0x82a2ce90
	if !ctx.cr[6].gt {
	pc = 0x82A2CE90; continue 'dispatch;
	}
	// 82A2CE88: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A2CE8C: 48000044  b 0x82a2ced0
	pc = 0x82A2CED0; continue 'dispatch;
	// 82A2CE90: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A2CE94: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A2CE98: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A2CE9C: ED6B0332  fmuls f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82A2CEA0: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82A2CEA4: 4099000C  ble cr6, 0x82a2ceb0
	if !ctx.cr[6].gt {
	pc = 0x82A2CEB0; continue 'dispatch;
	}
	// 82A2CEA8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A2CEAC: 48000024  b 0x82a2ced0
	pc = 0x82A2CED0; continue 'dispatch;
	// 82A2CEB0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A2CEB4: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82A2CEB8: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A2CEBC: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A2CEC0: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82A2CEC4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A2CEC8: 41990008  bgt cr6, 0x82a2ced0
	if ctx.cr[6].gt {
	pc = 0x82A2CED0; continue 'dispatch;
	}
	// 82A2CECC: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 82A2CED0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A2CED4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A2CED8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A2CEDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A2CEE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


