pub fn sub_8285FCE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8285FCE0 size=72
    let mut pc: u32 = 0x8285FCE0;
    'dispatch: loop {
        match pc {
            0x8285FCE0 => {
    //   block [0x8285FCE0..0x8285FD28)
	// 8285FCE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285FCE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285FCE8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285FCEC: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 8285FCF0: 419A001C  beq cr6, 0x8285fd0c
	if ctx.cr[6].eq {
	pc = 0x8285FD0C; continue 'dispatch;
	}
	// 8285FCF4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8285FCF8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8285FCFC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 8285FD00: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8285FD04: 4BFFFB3D  bl 0x8285f840
	ctx.lr = 0x8285FD08;
	sub_8285F840(ctx, base);
	// 8285FD08: 48000010  b 0x8285fd18
	pc = 0x8285FD18; continue 'dispatch;
	// 8285FD0C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8285FD10: 396B4D88  addi r11, r11, 0x4d88
	ctx.r[11].s64 = ctx.r[11].s64 + 19848;
	// 8285FD14: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8285FD18: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8285FD1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285FD20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285FD24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285FD28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8285FD28 size=264
    let mut pc: u32 = 0x8285FD28;
    'dispatch: loop {
        match pc {
            0x8285FD28 => {
    //   block [0x8285FD28..0x8285FE30)
	// 8285FD28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285FD2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285FD30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285FD34: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285FD38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8285FD3C: 4BFB82AD  bl 0x82817fe8
	ctx.lr = 0x8285FD40;
	sub_82817FE8(ctx, base);
	// 8285FD40: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8285FD44: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8285FD48: 396BFF14  addi r11, r11, -0xec
	ctx.r[11].s64 = ctx.r[11].s64 + -236;
	// 8285FD4C: 394AFF00  addi r10, r10, -0x100
	ctx.r[10].s64 = ctx.r[10].s64 + -256;
	// 8285FD50: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8285FD54: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 8285FD58: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8285FD5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8285FD60: 3949FEB4  addi r10, r9, -0x14c
	ctx.r[10].s64 = ctx.r[9].s64 + -332;
	// 8285FD64: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8285FD68: 915F0208  stw r10, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[10].u32 ) };
	// 8285FD6C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8285FD70: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 8285FD74: 917F0254  stw r11, 0x254(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(596 as u32), ctx.r[11].u32 ) };
	// 8285FD78: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 8285FD7C: 917F0258  stw r11, 0x258(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(600 as u32), ctx.r[11].u32 ) };
	// 8285FD80: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 8285FD84: 917F025C  stw r11, 0x25c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(604 as u32), ctx.r[11].u32 ) };
	// 8285FD88: 3CA08202  lis r5, -0x7dfe
	ctx.r[5].s64 = -2113798144;
	// 8285FD8C: 917F0260  stw r11, 0x260(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(608 as u32), ctx.r[11].u32 ) };
	// 8285FD90: 3C808332  lis r4, -0x7cce
	ctx.r[4].s64 = -2093875200;
	// 8285FD94: 917F0264  stw r11, 0x264(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(612 as u32), ctx.r[11].u32 ) };
	// 8285FD98: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8285FD9C: 917F0268  stw r11, 0x268(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(616 as u32), ctx.r[11].u32 ) };
	// 8285FDA0: C00908AC  lfs f0, 0x8ac(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2220 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8285FDA4: 917F0270  stw r11, 0x270(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(624 as u32), ctx.r[11].u32 ) };
	// 8285FDA8: C1AA093C  lfs f13, 0x93c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2364 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8285FDAC: 907F026C  stw r3, 0x26c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(620 as u32), ctx.r[3].u32 ) };
	// 8285FDB0: C188A1C4  lfs f12, -0x5e3c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8285FDB4: 917F0274  stw r11, 0x274(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(628 as u32), ctx.r[11].u32 ) };
	// 8285FDB8: C1679524  lfs f11, -0x6adc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8285FDBC: 917F0290  stw r11, 0x290(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(656 as u32), ctx.r[11].u32 ) };
	// 8285FDC0: C14608A4  lfs f10, 0x8a4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2212 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8285FDC4: 917F0294  stw r11, 0x294(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(660 as u32), ctx.r[11].u32 ) };
	// 8285FDC8: C1256218  lfs f9, 0x6218(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(25112 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8285FDCC: 917F0298  stw r11, 0x298(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), ctx.r[11].u32 ) };
	// 8285FDD0: D01F0278  stfs f0, 0x278(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(632 as u32), tmp.u32 ) };
	// 8285FDD4: 917F029C  stw r11, 0x29c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(668 as u32), ctx.r[11].u32 ) };
	// 8285FDD8: D1BF027C  stfs f13, 0x27c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(636 as u32), tmp.u32 ) };
	// 8285FDDC: 917F02A0  stw r11, 0x2a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(672 as u32), ctx.r[11].u32 ) };
	// 8285FDE0: D19F0280  stfs f12, 0x280(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(640 as u32), tmp.u32 ) };
	// 8285FDE4: 3944BA80  addi r10, r4, -0x4580
	ctx.r[10].s64 = ctx.r[4].s64 + -17792;
	// 8285FDE8: D17F0284  stfs f11, 0x284(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(644 as u32), tmp.u32 ) };
	// 8285FDEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285FDF0: D15F0288  stfs f10, 0x288(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(648 as u32), tmp.u32 ) };
	// 8285FDF4: D13F028C  stfs f9, 0x28c(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(652 as u32), tmp.u32 ) };
	// 8285FDF8: C004BA80  lfs f0, -0x4580(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-17792 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8285FDFC: D01F02B0  stfs f0, 0x2b0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(688 as u32), tmp.u32 ) };
	// 8285FE00: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8285FE04: D01F02B4  stfs f0, 0x2b4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(692 as u32), tmp.u32 ) };
	// 8285FE08: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8285FE0C: D01F02B8  stfs f0, 0x2b8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(696 as u32), tmp.u32 ) };
	// 8285FE10: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8285FE14: D01F02BC  stfs f0, 0x2bc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(700 as u32), tmp.u32 ) };
	// 8285FE18: 917F02C0  stw r11, 0x2c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(704 as u32), ctx.r[11].u32 ) };
	// 8285FE1C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8285FE20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285FE24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285FE28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8285FE2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285FE30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8285FE30 size=76
    let mut pc: u32 = 0x8285FE30;
    'dispatch: loop {
        match pc {
            0x8285FE30 => {
    //   block [0x8285FE30..0x8285FE7C)
	// 8285FE30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285FE34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8285FE38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8285FE3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8285FE40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285FE44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8285FE48: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8285FE4C: 4BFFFDB5  bl 0x8285fc00
	ctx.lr = 0x8285FE50;
	sub_8285FC00(ctx, base);
	// 8285FE50: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8285FE54: 4182000C  beq 0x8285fe60
	if ctx.cr[0].eq {
	pc = 0x8285FE60; continue 'dispatch;
	}
	// 8285FE58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285FE5C: 4859257D  bl 0x82df23d8
	ctx.lr = 0x8285FE60;
	sub_82DF23D8(ctx, base);
	// 8285FE60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285FE64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8285FE68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8285FE6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8285FE70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8285FE74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8285FE78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8285FE80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8285FE80 size=752
    let mut pc: u32 = 0x8285FE80;
    'dispatch: loop {
        match pc {
            0x8285FE80 => {
    //   block [0x8285FE80..0x82860170)
	// 8285FE80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8285FE84: 489482E1  bl 0x831a8164
	ctx.lr = 0x8285FE88;
	sub_831A8130(ctx, base);
	// 8285FE88: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8285FE8C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 8285FE90: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8285FE94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8285FE98: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8285FE9C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 8285FEA0: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 8285FEA4: 4859330D  bl 0x82df31b0
	ctx.lr = 0x8285FEA8;
	sub_82DF31B0(ctx, base);
	// 8285FEA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8285FEAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285FEB0: 48593B59  bl 0x82df3a08
	ctx.lr = 0x8285FEB4;
	sub_82DF3A08(ctx, base);
	// 8285FEB4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8285FEB8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8285FEBC: 4BF8C70D  bl 0x827ec5c8
	ctx.lr = 0x8285FEC0;
	sub_827EC5C8(ctx, base);
	// 8285FEC0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8285FEC4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8285FEC8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8285FECC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285FED0: 485B5161  bl 0x82e15030
	ctx.lr = 0x8285FED4;
	sub_82E15030(ctx, base);
	// 8285FED4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8285FED8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8285FEDC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8285FEE0: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 8285FEE4: 4BF9E95D  bl 0x827fe840
	ctx.lr = 0x8285FEE8;
	sub_827FE840(ctx, base);
	// 8285FEE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285FEEC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8285FEF0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285FEF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285FEF8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8285FEFC: 419A0024  beq cr6, 0x8285ff20
	if ctx.cr[6].eq {
	pc = 0x8285FF20; continue 'dispatch;
	}
	// 8285FF00: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8285FF04: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8285FF08: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285FF0C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8285FF10: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8285FF14: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8285FF18: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285FF1C: 4082FFE8  bne 0x8285ff04
	if !ctx.cr[0].eq {
	pc = 0x8285FF04; continue 'dispatch;
	}
	// 8285FF20: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8285FF24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285FF28: 419A0008  beq cr6, 0x8285ff30
	if ctx.cr[6].eq {
	pc = 0x8285FF30; continue 'dispatch;
	}
	// 8285FF2C: 4BA60965  bl 0x822c0890
	ctx.lr = 0x8285FF30;
	sub_822C0890(ctx, base);
	// 8285FF30: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 8285FF34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285FF38: 419A0008  beq cr6, 0x8285ff40
	if ctx.cr[6].eq {
	pc = 0x8285FF40; continue 'dispatch;
	}
	// 8285FF3C: 4BA60955  bl 0x822c0890
	ctx.lr = 0x8285FF40;
	sub_822C0890(ctx, base);
	// 8285FF40: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 8285FF44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285FF48: 419A0008  beq cr6, 0x8285ff50
	if ctx.cr[6].eq {
	pc = 0x8285FF50; continue 'dispatch;
	}
	// 8285FF4C: 4BA60945  bl 0x822c0890
	ctx.lr = 0x8285FF50;
	sub_822C0890(ctx, base);
	// 8285FF50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285FF54: 485934D5  bl 0x82df3428
	ctx.lr = 0x8285FF58;
	sub_82DF3428(ctx, base);
	// 8285FF58: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8285FF5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285FF60: 419A0020  beq cr6, 0x8285ff80
	if ctx.cr[6].eq {
	pc = 0x8285FF80; continue 'dispatch;
	}
	// 8285FF64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8285FF68: 3BE10058  addi r31, r1, 0x58
	ctx.r[31].s64 = ctx.r[1].s64 + 88;
	// 8285FF6C: 48593245  bl 0x82df31b0
	ctx.lr = 0x8285FF70;
	sub_82DF31B0(ctx, base);
	// 8285FF70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8285FF74: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8285FF78: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8285FF7C: 4BFBA4E5  bl 0x8281a460
	ctx.lr = 0x8285FF80;
	sub_8281A460(ctx, base);
	// 8285FF80: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8285FF84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8285FF88: 419A0008  beq cr6, 0x8285ff90
	if ctx.cr[6].eq {
	pc = 0x8285FF90; continue 'dispatch;
	}
	// 8285FF8C: 4BA60905  bl 0x822c0890
	ctx.lr = 0x8285FF90;
	sub_822C0890(ctx, base);
	// 8285FF90: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 8285FF94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8285FF98: 48593219  bl 0x82df31b0
	ctx.lr = 0x8285FF9C;
	sub_82DF31B0(ctx, base);
	// 8285FF9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8285FFA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8285FFA4: 48593A65  bl 0x82df3a08
	ctx.lr = 0x8285FFA8;
	sub_82DF3A08(ctx, base);
	// 8285FFA8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8285FFAC: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8285FFB0: 4BF8C619  bl 0x827ec5c8
	ctx.lr = 0x8285FFB4;
	sub_827EC5C8(ctx, base);
	// 8285FFB4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8285FFB8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8285FFBC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8285FFC0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285FFC4: 485B506D  bl 0x82e15030
	ctx.lr = 0x8285FFC8;
	sub_82E15030(ctx, base);
	// 8285FFC8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8285FFCC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 8285FFD0: 4BF9E329  bl 0x827fe2f8
	ctx.lr = 0x8285FFD4;
	sub_827FE2F8(ctx, base);
	// 8285FFD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8285FFD8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8285FFDC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8285FFE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8285FFE4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8285FFE8: 419A0024  beq cr6, 0x8286000c
	if ctx.cr[6].eq {
	pc = 0x8286000C; continue 'dispatch;
	}
	// 8285FFEC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8285FFF0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8285FFF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8285FFF8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8285FFFC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82860000: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82860004: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82860008: 4082FFE8  bne 0x8285fff0
	if !ctx.cr[0].eq {
	pc = 0x8285FFF0; continue 'dispatch;
	}
	// 8286000C: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82860010: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82860014: 419A0008  beq cr6, 0x8286001c
	if ctx.cr[6].eq {
	pc = 0x8286001C; continue 'dispatch;
	}
	// 82860018: 4BA60879  bl 0x822c0890
	ctx.lr = 0x8286001C;
	sub_822C0890(ctx, base);
	// 8286001C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82860020: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82860024: 419A0008  beq cr6, 0x8286002c
	if ctx.cr[6].eq {
	pc = 0x8286002C; continue 'dispatch;
	}
	// 82860028: 4BA60869  bl 0x822c0890
	ctx.lr = 0x8286002C;
	sub_822C0890(ctx, base);
	// 8286002C: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82860030: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82860034: 419A0008  beq cr6, 0x8286003c
	if ctx.cr[6].eq {
	pc = 0x8286003C; continue 'dispatch;
	}
	// 82860038: 4BA60859  bl 0x822c0890
	ctx.lr = 0x8286003C;
	sub_822C0890(ctx, base);
	// 8286003C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860040: 485933E9  bl 0x82df3428
	ctx.lr = 0x82860044;
	sub_82DF3428(ctx, base);
	// 82860044: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82860048: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286004C: 419A0020  beq cr6, 0x8286006c
	if ctx.cr[6].eq {
	pc = 0x8286006C; continue 'dispatch;
	}
	// 82860050: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82860054: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 82860058: 48593159  bl 0x82df31b0
	ctx.lr = 0x8286005C;
	sub_82DF31B0(ctx, base);
	// 8286005C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82860060: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82860064: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82860068: 4BFBA3F9  bl 0x8281a460
	ctx.lr = 0x8286006C;
	sub_8281A460(ctx, base);
	// 8286006C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82860070: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82860074: 419A0008  beq cr6, 0x8286007c
	if ctx.cr[6].eq {
	pc = 0x8286007C; continue 'dispatch;
	}
	// 82860078: 4BA60819  bl 0x822c0890
	ctx.lr = 0x8286007C;
	sub_822C0890(ctx, base);
	// 8286007C: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 82860080: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82860084: 4859312D  bl 0x82df31b0
	ctx.lr = 0x82860088;
	sub_82DF31B0(ctx, base);
	// 82860088: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286008C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860090: 48593979  bl 0x82df3a08
	ctx.lr = 0x82860094;
	sub_82DF3A08(ctx, base);
	// 82860094: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82860098: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 8286009C: 4BF8C52D  bl 0x827ec5c8
	ctx.lr = 0x828600A0;
	sub_827EC5C8(ctx, base);
	// 828600A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828600A4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828600A8: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 828600AC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828600B0: 485B4F81  bl 0x82e15030
	ctx.lr = 0x828600B4;
	sub_82E15030(ctx, base);
	// 828600B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828600B8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828600BC: 4BF9E2CD  bl 0x827fe388
	ctx.lr = 0x828600C0;
	sub_827FE388(ctx, base);
	// 828600C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828600C4: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828600C8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828600CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828600D0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 828600D4: 419A0024  beq cr6, 0x828600f8
	if ctx.cr[6].eq {
	pc = 0x828600F8; continue 'dispatch;
	}
	// 828600D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828600DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828600E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828600E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828600E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828600EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828600F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828600F4: 4082FFE8  bne 0x828600dc
	if !ctx.cr[0].eq {
	pc = 0x828600DC; continue 'dispatch;
	}
	// 828600F8: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 828600FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82860100: 419A0008  beq cr6, 0x82860108
	if ctx.cr[6].eq {
	pc = 0x82860108; continue 'dispatch;
	}
	// 82860104: 4BA6078D  bl 0x822c0890
	ctx.lr = 0x82860108;
	sub_822C0890(ctx, base);
	// 82860108: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 8286010C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82860110: 419A0008  beq cr6, 0x82860118
	if ctx.cr[6].eq {
	pc = 0x82860118; continue 'dispatch;
	}
	// 82860114: 4BA6077D  bl 0x822c0890
	ctx.lr = 0x82860118;
	sub_822C0890(ctx, base);
	// 82860118: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 8286011C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82860120: 419A0008  beq cr6, 0x82860128
	if ctx.cr[6].eq {
	pc = 0x82860128; continue 'dispatch;
	}
	// 82860124: 4BA6076D  bl 0x822c0890
	ctx.lr = 0x82860128;
	sub_822C0890(ctx, base);
	// 82860128: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286012C: 485932FD  bl 0x82df3428
	ctx.lr = 0x82860130;
	sub_82DF3428(ctx, base);
	// 82860130: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82860134: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82860138: 419A0020  beq cr6, 0x82860158
	if ctx.cr[6].eq {
	pc = 0x82860158; continue 'dispatch;
	}
	// 8286013C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82860140: 3BE10068  addi r31, r1, 0x68
	ctx.r[31].s64 = ctx.r[1].s64 + 104;
	// 82860144: 4859306D  bl 0x82df31b0
	ctx.lr = 0x82860148;
	sub_82DF31B0(ctx, base);
	// 82860148: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286014C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82860150: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82860154: 4BFBA30D  bl 0x8281a460
	ctx.lr = 0x82860158;
	sub_8281A460(ctx, base);
	// 82860158: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8286015C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82860160: 419A0008  beq cr6, 0x82860168
	if ctx.cr[6].eq {
	pc = 0x82860168; continue 'dispatch;
	}
	// 82860164: 4BA6072D  bl 0x822c0890
	ctx.lr = 0x82860168;
	sub_822C0890(ctx, base);
	// 82860168: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 8286016C: 48948048  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82860170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82860170 size=268
    let mut pc: u32 = 0x82860170;
    'dispatch: loop {
        match pc {
            0x82860170 => {
    //   block [0x82860170..0x8286027C)
	// 82860170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82860174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82860178: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8286017C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82860180: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82860184: 817F0298  lwz r11, 0x298(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(664 as u32) ) } as u64;
	// 82860188: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 8286018C: 409A009C  bne cr6, 0x82860228
	if !ctx.cr[6].eq {
	pc = 0x82860228; continue 'dispatch;
	}
	// 82860190: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82860194: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860198: 388BFE64  addi r4, r11, -0x19c
	ctx.r[4].s64 = ctx.r[11].s64 + -412;
	// 8286019C: 4859386D  bl 0x82df3a08
	ctx.lr = 0x828601A0;
	sub_82DF3A08(ctx, base);
	// 828601A0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828601A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828601A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828601AC: C02B89AC  lfs f1, -0x7654(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828601B0: 48003589  bl 0x82863738
	ctx.lr = 0x828601B4;
	sub_82863738(ctx, base);
	// 828601B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828601B8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828601BC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828601C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828601C4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828601C8: 419A0024  beq cr6, 0x828601ec
	if ctx.cr[6].eq {
	pc = 0x828601EC; continue 'dispatch;
	}
	// 828601CC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828601D0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828601D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828601D8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828601DC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828601E0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828601E4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828601E8: 4082FFE8  bne 0x828601d0
	if !ctx.cr[0].eq {
	pc = 0x828601D0; continue 'dispatch;
	}
	// 828601EC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828601F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828601F4: 4BF8CB65  bl 0x827ecd58
	ctx.lr = 0x828601F8;
	sub_827ECD58(ctx, base);
	// 828601F8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828601FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82860200: 419A0008  beq cr6, 0x82860208
	if ctx.cr[6].eq {
	pc = 0x82860208; continue 'dispatch;
	}
	// 82860204: 4BA6068D  bl 0x822c0890
	ctx.lr = 0x82860208;
	sub_822C0890(ctx, base);
	// 82860208: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8286020C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82860210: 419A0008  beq cr6, 0x82860218
	if ctx.cr[6].eq {
	pc = 0x82860218; continue 'dispatch;
	}
	// 82860214: 4BA6067D  bl 0x822c0890
	ctx.lr = 0x82860218;
	sub_822C0890(ctx, base);
	// 82860218: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286021C: 4859320D  bl 0x82df3428
	ctx.lr = 0x82860220;
	sub_82DF3428(ctx, base);
	// 82860220: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82860224: 48000010  b 0x82860234
	pc = 0x82860234; continue 'dispatch;
	// 82860228: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286022C: 419A000C  beq cr6, 0x82860238
	if ctx.cr[6].eq {
	pc = 0x82860238; continue 'dispatch;
	}
	// 82860230: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82860234: 917F0298  stw r11, 0x298(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), ctx.r[11].u32 ) };
	// 82860238: 817F0298  lwz r11, 0x298(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(664 as u32) ) } as u64;
	// 8286023C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82860240: 409A0028  bne cr6, 0x82860268
	if !ctx.cr[6].eq {
	pc = 0x82860268; continue 'dispatch;
	}
	// 82860244: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82860248: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286024C: 388BCFB0  addi r4, r11, -0x3050
	ctx.r[4].s64 = ctx.r[11].s64 + -12368;
	// 82860250: 485937B9  bl 0x82df3a08
	ctx.lr = 0x82860254;
	sub_82DF3A08(ctx, base);
	// 82860254: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82860258: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286025C: 4BF8CA8D  bl 0x827ecce8
	ctx.lr = 0x82860260;
	sub_827ECCE8(ctx, base);
	// 82860260: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860264: 485931C5  bl 0x82df3428
	ctx.lr = 0x82860268;
	sub_82DF3428(ctx, base);
	// 82860268: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8286026C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82860270: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82860274: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82860278: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82860280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82860280 size=1240
    let mut pc: u32 = 0x82860280;
    'dispatch: loop {
        match pc {
            0x82860280 => {
    //   block [0x82860280..0x82860758)
	// 82860280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82860284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82860288: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286028C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82860290: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82860294: 8163029C  lwz r11, 0x29c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(668 as u32) ) } as u64;
	// 82860298: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8286029C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828602A0: 556A07FF  clrlwi. r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828602A4: 41820124  beq 0x828603c8
	if ctx.cr[0].eq {
	pc = 0x828603C8; continue 'dispatch;
	}
	// 828602A8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828602AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828602B0: 388BFE64  addi r4, r11, -0x19c
	ctx.r[4].s64 = ctx.r[11].s64 + -412;
	// 828602B4: 48593755  bl 0x82df3a08
	ctx.lr = 0x828602B8;
	sub_82DF3A08(ctx, base);
	// 828602B8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828602BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828602C0: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 828602C4: C02B9450  lfs f1, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828602C8: 48003471  bl 0x82863738
	ctx.lr = 0x828602CC;
	sub_82863738(ctx, base);
	// 828602CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828602D0: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 828602D4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828602D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828602DC: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 828602E0: 419A0024  beq cr6, 0x82860304
	if ctx.cr[6].eq {
	pc = 0x82860304; continue 'dispatch;
	}
	// 828602E4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828602E8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828602EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828602F0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828602F4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828602F8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828602FC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82860300: 4082FFE8  bne 0x828602e8
	if !ctx.cr[0].eq {
	pc = 0x828602E8; continue 'dispatch;
	}
	// 82860304: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82860308: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286030C: 4BF8E965  bl 0x827eec70
	ctx.lr = 0x82860310;
	sub_827EEC70(ctx, base);
	// 82860310: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82860314: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82860318: 419A0008  beq cr6, 0x82860320
	if ctx.cr[6].eq {
	pc = 0x82860320; continue 'dispatch;
	}
	// 8286031C: 4BA60575  bl 0x822c0890
	ctx.lr = 0x82860320;
	sub_822C0890(ctx, base);
	// 82860320: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82860324: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82860328: 419A0008  beq cr6, 0x82860330
	if ctx.cr[6].eq {
	pc = 0x82860330; continue 'dispatch;
	}
	// 8286032C: 4BA60565  bl 0x822c0890
	ctx.lr = 0x82860330;
	sub_822C0890(ctx, base);
	// 82860330: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860334: 485930F5  bl 0x82df3428
	ctx.lr = 0x82860338;
	sub_82DF3428(ctx, base);
	// 82860338: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8286033C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860340: 388BFE48  addi r4, r11, -0x1b8
	ctx.r[4].s64 = ctx.r[11].s64 + -440;
	// 82860344: 485936C5  bl 0x82df3a08
	ctx.lr = 0x82860348;
	sub_82DF3A08(ctx, base);
	// 82860348: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286034C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82860350: 48003371  bl 0x828636c0
	ctx.lr = 0x82860354;
	sub_828636C0(ctx, base);
	// 82860354: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82860358: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8286035C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860360: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82860364: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82860368: 419A0024  beq cr6, 0x8286038c
	if ctx.cr[6].eq {
	pc = 0x8286038C; continue 'dispatch;
	}
	// 8286036C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82860370: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82860374: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82860378: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8286037C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82860380: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82860384: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82860388: 4082FFE8  bne 0x82860370
	if !ctx.cr[0].eq {
	pc = 0x82860370; continue 'dispatch;
	}
	// 8286038C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82860390: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82860394: 4BF8F30D  bl 0x827ef6a0
	ctx.lr = 0x82860398;
	sub_827EF6A0(ctx, base);
	// 82860398: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8286039C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828603A0: 419A0008  beq cr6, 0x828603a8
	if ctx.cr[6].eq {
	pc = 0x828603A8; continue 'dispatch;
	}
	// 828603A4: 4BA604ED  bl 0x822c0890
	ctx.lr = 0x828603A8;
	sub_822C0890(ctx, base);
	// 828603A8: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 828603AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828603B0: 419A0008  beq cr6, 0x828603b8
	if ctx.cr[6].eq {
	pc = 0x828603B8; continue 'dispatch;
	}
	// 828603B4: 4BA604DD  bl 0x822c0890
	ctx.lr = 0x828603B8;
	sub_822C0890(ctx, base);
	// 828603B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828603BC: 4859306D  bl 0x82df3428
	ctx.lr = 0x828603C0;
	sub_82DF3428(ctx, base);
	// 828603C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828603C4: 48000378  b 0x8286073c
	pc = 0x8286073C; continue 'dispatch;
	// 828603C8: 556A07BD  rlwinm. r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828603CC: 41820124  beq 0x828604f0
	if ctx.cr[0].eq {
	pc = 0x828604F0; continue 'dispatch;
	}
	// 828603D0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828603D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828603D8: 388BFE64  addi r4, r11, -0x19c
	ctx.r[4].s64 = ctx.r[11].s64 + -412;
	// 828603DC: 4859362D  bl 0x82df3a08
	ctx.lr = 0x828603E0;
	sub_82DF3A08(ctx, base);
	// 828603E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828603E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828603E8: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828603EC: C02B9450  lfs f1, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828603F0: 48003349  bl 0x82863738
	ctx.lr = 0x828603F4;
	sub_82863738(ctx, base);
	// 828603F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828603F8: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 828603FC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860400: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82860404: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82860408: 419A0024  beq cr6, 0x8286042c
	if ctx.cr[6].eq {
	pc = 0x8286042C; continue 'dispatch;
	}
	// 8286040C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82860410: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82860414: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82860418: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8286041C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82860420: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82860424: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82860428: 4082FFE8  bne 0x82860410
	if !ctx.cr[0].eq {
	pc = 0x82860410; continue 'dispatch;
	}
	// 8286042C: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82860430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82860434: 4BF8E83D  bl 0x827eec70
	ctx.lr = 0x82860438;
	sub_827EEC70(ctx, base);
	// 82860438: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 8286043C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82860440: 419A0008  beq cr6, 0x82860448
	if ctx.cr[6].eq {
	pc = 0x82860448; continue 'dispatch;
	}
	// 82860444: 4BA6044D  bl 0x822c0890
	ctx.lr = 0x82860448;
	sub_822C0890(ctx, base);
	// 82860448: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 8286044C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82860450: 419A0008  beq cr6, 0x82860458
	if ctx.cr[6].eq {
	pc = 0x82860458; continue 'dispatch;
	}
	// 82860454: 4BA6043D  bl 0x822c0890
	ctx.lr = 0x82860458;
	sub_822C0890(ctx, base);
	// 82860458: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286045C: 48592FCD  bl 0x82df3428
	ctx.lr = 0x82860460;
	sub_82DF3428(ctx, base);
	// 82860460: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82860464: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860468: 388BFE48  addi r4, r11, -0x1b8
	ctx.r[4].s64 = ctx.r[11].s64 + -440;
	// 8286046C: 4859359D  bl 0x82df3a08
	ctx.lr = 0x82860470;
	sub_82DF3A08(ctx, base);
	// 82860470: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82860474: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82860478: 48003249  bl 0x828636c0
	ctx.lr = 0x8286047C;
	sub_828636C0(ctx, base);
	// 8286047C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82860480: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82860484: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860488: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286048C: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82860490: 419A0024  beq cr6, 0x828604b4
	if ctx.cr[6].eq {
	pc = 0x828604B4; continue 'dispatch;
	}
	// 82860494: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82860498: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8286049C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828604A0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828604A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828604A8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828604AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828604B0: 4082FFE8  bne 0x82860498
	if !ctx.cr[0].eq {
	pc = 0x82860498; continue 'dispatch;
	}
	// 828604B4: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 828604B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828604BC: 4BF8F1E5  bl 0x827ef6a0
	ctx.lr = 0x828604C0;
	sub_827EF6A0(ctx, base);
	// 828604C0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828604C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828604C8: 419A0008  beq cr6, 0x828604d0
	if ctx.cr[6].eq {
	pc = 0x828604D0; continue 'dispatch;
	}
	// 828604CC: 4BA603C5  bl 0x822c0890
	ctx.lr = 0x828604D0;
	sub_822C0890(ctx, base);
	// 828604D0: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 828604D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828604D8: 419A0008  beq cr6, 0x828604e0
	if ctx.cr[6].eq {
	pc = 0x828604E0; continue 'dispatch;
	}
	// 828604DC: 4BA603B5  bl 0x822c0890
	ctx.lr = 0x828604E0;
	sub_822C0890(ctx, base);
	// 828604E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828604E4: 48592F45  bl 0x82df3428
	ctx.lr = 0x828604E8;
	sub_82DF3428(ctx, base);
	// 828604E8: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 828604EC: 48000250  b 0x8286073c
	pc = 0x8286073C; continue 'dispatch;
	// 828604F0: 556A077B  rlwinm. r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828604F4: 41820124  beq 0x82860618
	if ctx.cr[0].eq {
	pc = 0x82860618; continue 'dispatch;
	}
	// 828604F8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828604FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860500: 388BFE64  addi r4, r11, -0x19c
	ctx.r[4].s64 = ctx.r[11].s64 + -412;
	// 82860504: 48593505  bl 0x82df3a08
	ctx.lr = 0x82860508;
	sub_82DF3A08(ctx, base);
	// 82860508: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8286050C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82860510: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82860514: C02B9450  lfs f1, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82860518: 48003221  bl 0x82863738
	ctx.lr = 0x8286051C;
	sub_82863738(ctx, base);
	// 8286051C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82860520: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82860524: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860528: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286052C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82860530: 419A0024  beq cr6, 0x82860554
	if ctx.cr[6].eq {
	pc = 0x82860554; continue 'dispatch;
	}
	// 82860534: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82860538: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8286053C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82860540: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82860544: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82860548: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8286054C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82860550: 4082FFE8  bne 0x82860538
	if !ctx.cr[0].eq {
	pc = 0x82860538; continue 'dispatch;
	}
	// 82860554: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82860558: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286055C: 4BF8E715  bl 0x827eec70
	ctx.lr = 0x82860560;
	sub_827EEC70(ctx, base);
	// 82860560: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82860564: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82860568: 419A0008  beq cr6, 0x82860570
	if ctx.cr[6].eq {
	pc = 0x82860570; continue 'dispatch;
	}
	// 8286056C: 4BA60325  bl 0x822c0890
	ctx.lr = 0x82860570;
	sub_822C0890(ctx, base);
	// 82860570: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82860574: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82860578: 419A0008  beq cr6, 0x82860580
	if ctx.cr[6].eq {
	pc = 0x82860580; continue 'dispatch;
	}
	// 8286057C: 4BA60315  bl 0x822c0890
	ctx.lr = 0x82860580;
	sub_822C0890(ctx, base);
	// 82860580: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860584: 48592EA5  bl 0x82df3428
	ctx.lr = 0x82860588;
	sub_82DF3428(ctx, base);
	// 82860588: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8286058C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860590: 388BFE58  addi r4, r11, -0x1a8
	ctx.r[4].s64 = ctx.r[11].s64 + -424;
	// 82860594: 48593475  bl 0x82df3a08
	ctx.lr = 0x82860598;
	sub_82DF3A08(ctx, base);
	// 82860598: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286059C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828605A0: 48003121  bl 0x828636c0
	ctx.lr = 0x828605A4;
	sub_828636C0(ctx, base);
	// 828605A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828605A8: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 828605AC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828605B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828605B4: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 828605B8: 419A0024  beq cr6, 0x828605dc
	if ctx.cr[6].eq {
	pc = 0x828605DC; continue 'dispatch;
	}
	// 828605BC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828605C0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828605C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828605C8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828605CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828605D0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828605D4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828605D8: 4082FFE8  bne 0x828605c0
	if !ctx.cr[0].eq {
	pc = 0x828605C0; continue 'dispatch;
	}
	// 828605DC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828605E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828605E4: 4BF8F0BD  bl 0x827ef6a0
	ctx.lr = 0x828605E8;
	sub_827EF6A0(ctx, base);
	// 828605E8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828605EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828605F0: 419A0008  beq cr6, 0x828605f8
	if ctx.cr[6].eq {
	pc = 0x828605F8; continue 'dispatch;
	}
	// 828605F4: 4BA6029D  bl 0x822c0890
	ctx.lr = 0x828605F8;
	sub_822C0890(ctx, base);
	// 828605F8: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 828605FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82860600: 419A0008  beq cr6, 0x82860608
	if ctx.cr[6].eq {
	pc = 0x82860608; continue 'dispatch;
	}
	// 82860604: 4BA6028D  bl 0x822c0890
	ctx.lr = 0x82860608;
	sub_822C0890(ctx, base);
	// 82860608: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286060C: 48592E1D  bl 0x82df3428
	ctx.lr = 0x82860610;
	sub_82DF3428(ctx, base);
	// 82860610: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82860614: 48000128  b 0x8286073c
	pc = 0x8286073C; continue 'dispatch;
	// 82860618: 556B0739  rlwinm. r11, r11, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286061C: 41820124  beq 0x82860740
	if ctx.cr[0].eq {
	pc = 0x82860740; continue 'dispatch;
	}
	// 82860620: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82860624: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860628: 388BFE64  addi r4, r11, -0x19c
	ctx.r[4].s64 = ctx.r[11].s64 + -412;
	// 8286062C: 485933DD  bl 0x82df3a08
	ctx.lr = 0x82860630;
	sub_82DF3A08(ctx, base);
	// 82860630: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82860634: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82860638: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8286063C: C02B9450  lfs f1, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82860640: 480030F9  bl 0x82863738
	ctx.lr = 0x82860644;
	sub_82863738(ctx, base);
	// 82860644: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82860648: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 8286064C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82860650: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82860654: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82860658: 419A0024  beq cr6, 0x8286067c
	if ctx.cr[6].eq {
	pc = 0x8286067C; continue 'dispatch;
	}
	// 8286065C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82860660: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82860664: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82860668: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8286066C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82860670: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82860674: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82860678: 4082FFE8  bne 0x82860660
	if !ctx.cr[0].eq {
	pc = 0x82860660; continue 'dispatch;
	}
	// 8286067C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82860680: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82860684: 4BF8E5ED  bl 0x827eec70
	ctx.lr = 0x82860688;
	sub_827EEC70(ctx, base);
	// 82860688: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 8286068C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82860690: 419A0008  beq cr6, 0x82860698
	if ctx.cr[6].eq {
	pc = 0x82860698; continue 'dispatch;
	}
	// 82860694: 4BA601FD  bl 0x822c0890
	ctx.lr = 0x82860698;
	sub_822C0890(ctx, base);
	// 82860698: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 8286069C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828606A0: 419A0008  beq cr6, 0x828606a8
	if ctx.cr[6].eq {
	pc = 0x828606A8; continue 'dispatch;
	}
	// 828606A4: 4BA601ED  bl 0x822c0890
	ctx.lr = 0x828606A8;
	sub_822C0890(ctx, base);
	// 828606A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828606AC: 48592D7D  bl 0x82df3428
	ctx.lr = 0x828606B0;
	sub_82DF3428(ctx, base);
	// 828606B0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828606B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828606B8: 388BFE58  addi r4, r11, -0x1a8
	ctx.r[4].s64 = ctx.r[11].s64 + -424;
	// 828606BC: 4859334D  bl 0x82df3a08
	ctx.lr = 0x828606C0;
	sub_82DF3A08(ctx, base);
	// 828606C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828606C4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828606C8: 48002FF9  bl 0x828636c0
	ctx.lr = 0x828606CC;
	sub_828636C0(ctx, base);
	// 828606CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828606D0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828606D4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828606D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828606DC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828606E0: 419A0024  beq cr6, 0x82860704
	if ctx.cr[6].eq {
	pc = 0x82860704; continue 'dispatch;
	}
	// 828606E4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828606E8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828606EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828606F0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828606F4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828606F8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828606FC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82860700: 4082FFE8  bne 0x828606e8
	if !ctx.cr[0].eq {
	pc = 0x828606E8; continue 'dispatch;
	}
	// 82860704: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82860708: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286070C: 4BF8EF95  bl 0x827ef6a0
	ctx.lr = 0x82860710;
	sub_827EF6A0(ctx, base);
	// 82860710: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82860714: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82860718: 419A0008  beq cr6, 0x82860720
	if ctx.cr[6].eq {
	pc = 0x82860720; continue 'dispatch;
	}
	// 8286071C: 4BA60175  bl 0x822c0890
	ctx.lr = 0x82860720;
	sub_822C0890(ctx, base);
	// 82860720: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82860724: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82860728: 419A0008  beq cr6, 0x82860730
	if ctx.cr[6].eq {
	pc = 0x82860730; continue 'dispatch;
	}
	// 8286072C: 4BA60165  bl 0x822c0890
	ctx.lr = 0x82860730;
	sub_822C0890(ctx, base);
	// 82860730: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860734: 48592CF5  bl 0x82df3428
	ctx.lr = 0x82860738;
	sub_82DF3428(ctx, base);
	// 82860738: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 8286073C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82860740: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82860744: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82860748: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286074C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82860750: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82860754: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82860758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82860758 size=104
    let mut pc: u32 = 0x82860758;
    'dispatch: loop {
        match pc {
            0x82860758 => {
    //   block [0x82860758..0x828607C0)
	// 82860758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286075C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82860760: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82860764: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82860768: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286076C: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82860770: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82860774: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 82860778: 409A0030  bne cr6, 0x828607a8
	if !ctx.cr[6].eq {
	pc = 0x828607A8; continue 'dispatch;
	}
	// 8286077C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82860780: 3BDF02A0  addi r30, r31, 0x2a0
	ctx.r[30].s64 = ctx.r[31].s64 + 672;
	// 82860784: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 82860788: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8286078C: 4E800421  bctrl
	ctx.lr = 0x82860790;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82860790: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82860794: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82860798: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8286079C: 4BFFFAE5  bl 0x82860280
	ctx.lr = 0x828607A0;
	sub_82860280(ctx, base);
	// 828607A0: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 828607A4: 917F0298  stw r11, 0x298(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), ctx.r[11].u32 ) };
	// 828607A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828607AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828607B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828607B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828607B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828607BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828607C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828607C0 size=112
    let mut pc: u32 = 0x828607C0;
    'dispatch: loop {
        match pc {
            0x828607C0 => {
    //   block [0x828607C0..0x82860830)
	// 828607C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828607C4: 489479A9  bl 0x831a816c
	ctx.lr = 0x828607C8;
	sub_831A8130(ctx, base);
	// 828607C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828607CC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828607D0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828607D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828607D8: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 828607DC: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 828607E0: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 828607E4: 48591C05  bl 0x82df23e8
	ctx.lr = 0x828607E8;
	sub_82DF23E8(ctx, base);
	// 828607E8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828607EC: 41820010  beq 0x828607fc
	if ctx.cr[0].eq {
	pc = 0x828607FC; continue 'dispatch;
	}
	// 828607F0: 482F2151  bl 0x82b52940
	ctx.lr = 0x828607F4;
	sub_82B52940(ctx, base);
	// 828607F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828607F8: 48000008  b 0x82860800
	pc = 0x82860800; continue 'dispatch;
	// 828607FC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82860800: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82860804: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82860808: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8286080C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82860810: 4BFFF329  bl 0x8285fb38
	ctx.lr = 0x82860814;
	sub_8285FB38(ctx, base);
	// 82860814: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82860818: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8286081C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82860820: 4BA5F7E1  bl 0x822c0000
	ctx.lr = 0x82860824;
	sub_822C0000(ctx, base);
	// 82860824: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82860828: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286082C: 48947990  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82860830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82860830 size=1872
    let mut pc: u32 = 0x82860830;
    'dispatch: loop {
        match pc {
            0x82860830 => {
    //   block [0x82860830..0x82860F80)
	// 82860830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82860834: 48947921  bl 0x831a8154
	ctx.lr = 0x82860838;
	sub_831A8130(ctx, base);
	// 82860838: DBC1FFA0  stfd f30, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[30].u64 ) };
	// 8286083C: DBE1FFA8  stfd f31, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82860840: 9421FDF0  stwu r1, -0x210(r1)
	ea = ctx.r[1].u32.wrapping_add(-528 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82860844: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82860848: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8286084C: 3B0B0070  addi r24, r11, 0x70
	ctx.r[24].s64 = ctx.r[11].s64 + 112;
	// 82860850: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 82860854: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82860858: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8286085C: 38A000E4  li r5, 0xe4
	ctx.r[5].s64 = 228;
	// 82860860: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 82860864: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82860868: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8286086C: 4BA5FB6D  bl 0x822c03d8
	ctx.lr = 0x82860870;
	sub_822C03D8(ctx, base);
	// 82860870: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82860874: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82860878: 3B8BD318  addi r28, r11, -0x2ce8
	ctx.r[28].s64 = ctx.r[11].s64 + -11496;
	// 8286087C: 41820030  beq 0x828608ac
	if ctx.cr[0].eq {
	pc = 0x828608AC; continue 'dispatch;
	}
	// 82860880: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82860884: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860888: 48593181  bl 0x82df3a08
	ctx.lr = 0x8286088C;
	sub_82DF3A08(ctx, base);
	// 8286088C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82860890: 38B90088  addi r5, r25, 0x88
	ctx.r[5].s64 = ctx.r[25].s64 + 136;
	// 82860894: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82860898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286089C: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 828608A0: 4BD4BB71  bl 0x825ac410
	ctx.lr = 0x828608A4;
	sub_825AC410(ctx, base);
	// 828608A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828608A8: 48000008  b 0x828608b0
	pc = 0x828608B0; continue 'dispatch;
	// 828608AC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828608B0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828608B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828608B8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828608BC: 4BC92AFD  bl 0x824f33b8
	ctx.lr = 0x828608C0;
	sub_824F33B8(ctx, base);
	// 828608C0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828608C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828608C8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828608CC: 4BA5F735  bl 0x822c0000
	ctx.lr = 0x828608D0;
	sub_822C0000(ctx, base);
	// 828608D0: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828608D4: 41820010  beq 0x828608e4
	if ctx.cr[0].eq {
	pc = 0x828608E4; continue 'dispatch;
	}
	// 828608D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828608DC: 577B003C  rlwinm r27, r27, 0, 0, 0x1e
	ctx.r[27].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 828608E0: 48592B49  bl 0x82df3428
	ctx.lr = 0x828608E4;
	sub_82DF3428(ctx, base);
	// 828608E4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828608E8: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828608EC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828608F0: 3B4BFE0C  addi r26, r11, -0x1f4
	ctx.r[26].s64 = ctx.r[11].s64 + -500;
	// 828608F4: 3BFA0008  addi r31, r26, 8
	ctx.r[31].s64 = ctx.r[26].s64 + 8;
	// 828608F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828608FC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82860900: 48593109  bl 0x82df3a08
	ctx.lr = 0x82860904;
	sub_82DF3A08(ctx, base);
	// 82860904: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82860908: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8286090C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82860910: 4BD4B4B1  bl 0x825abdc0
	ctx.lr = 0x82860914;
	sub_825ABDC0(ctx, base);
	// 82860914: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860918: 48592B11  bl 0x82df3428
	ctx.lr = 0x8286091C;
	sub_82DF3428(ctx, base);
	// 8286091C: 397A0008  addi r11, r26, 8
	ctx.r[11].s64 = ctx.r[26].s64 + 8;
	// 82860920: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82860924: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82860928: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 8286092C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82860930: 4198FFC8  blt cr6, 0x828608f8
	if ctx.cr[6].lt {
	pc = 0x828608F8; continue 'dispatch;
	}
	// 82860934: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82860938: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286093C: 485930CD  bl 0x82df3a08
	ctx.lr = 0x82860940;
	sub_82DF3A08(ctx, base);
	// 82860940: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82860944: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82860948: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8286094C: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82860950: 419A0024  beq cr6, 0x82860974
	if ctx.cr[6].eq {
	pc = 0x82860974; continue 'dispatch;
	}
	// 82860954: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82860958: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8286095C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82860960: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82860964: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82860968: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8286096C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82860970: 4082FFE8  bne 0x82860958
	if !ctx.cr[0].eq {
	pc = 0x82860958; continue 'dispatch;
	}
	// 82860974: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82860978: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286097C: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82860980: 4BD41791  bl 0x825a2110
	ctx.lr = 0x82860984;
	sub_825A2110(ctx, base);
	// 82860984: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860988: 48592AA1  bl 0x82df3428
	ctx.lr = 0x8286098C;
	sub_82DF3428(ctx, base);
	// 8286098C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82860990: 419A000C  beq cr6, 0x8286099c
	if ctx.cr[6].eq {
	pc = 0x8286099C; continue 'dispatch;
	}
	// 82860994: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82860998: 4BA5FEF9  bl 0x822c0890
	ctx.lr = 0x8286099C;
	sub_822C0890(ctx, base);
	// 8286099C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828609A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828609A4: 38A000EA  li r5, 0xea
	ctx.r[5].s64 = 234;
	// 828609A8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828609AC: 4BA5FA2D  bl 0x822c03d8
	ctx.lr = 0x828609B0;
	sub_822C03D8(ctx, base);
	// 828609B0: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 828609B4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828609B8: 3B8BB3A4  addi r28, r11, -0x4c5c
	ctx.r[28].s64 = ctx.r[11].s64 + -19548;
	// 828609BC: 41820030  beq 0x828609ec
	if ctx.cr[0].eq {
	pc = 0x828609EC; continue 'dispatch;
	}
	// 828609C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828609C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828609C8: 48593041  bl 0x82df3a08
	ctx.lr = 0x828609CC;
	sub_82DF3A08(ctx, base);
	// 828609CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828609D0: 38B9008C  addi r5, r25, 0x8c
	ctx.r[5].s64 = ctx.r[25].s64 + 140;
	// 828609D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828609D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828609DC: 637B0002  ori r27, r27, 2
	ctx.r[27].u64 = ctx.r[27].u64 | 2;
	// 828609E0: 4BD4BA31  bl 0x825ac410
	ctx.lr = 0x828609E4;
	sub_825AC410(ctx, base);
	// 828609E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828609E8: 48000008  b 0x828609f0
	pc = 0x828609F0; continue 'dispatch;
	// 828609EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828609F0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828609F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828609F8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828609FC: 4BC929BD  bl 0x824f33b8
	ctx.lr = 0x82860A00;
	sub_824F33B8(ctx, base);
	// 82860A00: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82860A04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82860A08: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82860A0C: 4BA5F5F5  bl 0x822c0000
	ctx.lr = 0x82860A10;
	sub_822C0000(ctx, base);
	// 82860A10: 576B07BD  rlwinm. r11, r27, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82860A14: 41820010  beq 0x82860a24
	if ctx.cr[0].eq {
	pc = 0x82860A24; continue 'dispatch;
	}
	// 82860A18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860A1C: 577B07FA  rlwinm r27, r27, 0, 0x1f, 0x1d
	ctx.r[27].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 82860A20: 48592A09  bl 0x82df3428
	ctx.lr = 0x82860A24;
	sub_82DF3428(ctx, base);
	// 82860A24: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82860A28: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 82860A2C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82860A30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860A34: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82860A38: 48592FD1  bl 0x82df3a08
	ctx.lr = 0x82860A3C;
	sub_82DF3A08(ctx, base);
	// 82860A3C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82860A40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82860A44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82860A48: 4BD4B379  bl 0x825abdc0
	ctx.lr = 0x82860A4C;
	sub_825ABDC0(ctx, base);
	// 82860A4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860A50: 485929D9  bl 0x82df3428
	ctx.lr = 0x82860A54;
	sub_82DF3428(ctx, base);
	// 82860A54: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82860A58: 397A0008  addi r11, r26, 8
	ctx.r[11].s64 = ctx.r[26].s64 + 8;
	// 82860A5C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82860A60: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82860A64: 4198FFCC  blt cr6, 0x82860a30
	if ctx.cr[6].lt {
	pc = 0x82860A30; continue 'dispatch;
	}
	// 82860A68: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82860A6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860A70: 48592F99  bl 0x82df3a08
	ctx.lr = 0x82860A74;
	sub_82DF3A08(ctx, base);
	// 82860A74: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82860A78: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82860A7C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82860A80: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82860A84: 419A0024  beq cr6, 0x82860aa8
	if ctx.cr[6].eq {
	pc = 0x82860AA8; continue 'dispatch;
	}
	// 82860A88: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82860A8C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82860A90: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82860A94: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82860A98: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82860A9C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82860AA0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82860AA4: 4082FFE8  bne 0x82860a8c
	if !ctx.cr[0].eq {
	pc = 0x82860A8C; continue 'dispatch;
	}
	// 82860AA8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82860AAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82860AB0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82860AB4: 4BD4165D  bl 0x825a2110
	ctx.lr = 0x82860AB8;
	sub_825A2110(ctx, base);
	// 82860AB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860ABC: 4859296D  bl 0x82df3428
	ctx.lr = 0x82860AC0;
	sub_82DF3428(ctx, base);
	// 82860AC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82860AC4: 419A000C  beq cr6, 0x82860ad0
	if ctx.cr[6].eq {
	pc = 0x82860AD0; continue 'dispatch;
	}
	// 82860AC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82860ACC: 4BA5FDC5  bl 0x822c0890
	ctx.lr = 0x82860AD0;
	sub_822C0890(ctx, base);
	// 82860AD0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82860AD4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82860AD8: 38A000F0  li r5, 0xf0
	ctx.r[5].s64 = 240;
	// 82860ADC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82860AE0: 4BA5F8F9  bl 0x822c03d8
	ctx.lr = 0x82860AE4;
	sub_822C03D8(ctx, base);
	// 82860AE4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82860AE8: 41820034  beq 0x82860b1c
	if ctx.cr[0].eq {
	pc = 0x82860B1C; continue 'dispatch;
	}
	// 82860AEC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82860AF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860AF4: 388B0058  addi r4, r11, 0x58
	ctx.r[4].s64 = ctx.r[11].s64 + 88;
	// 82860AF8: 48592F11  bl 0x82df3a08
	ctx.lr = 0x82860AFC;
	sub_82DF3A08(ctx, base);
	// 82860AFC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82860B00: 38B90068  addi r5, r25, 0x68
	ctx.r[5].s64 = ctx.r[25].s64 + 104;
	// 82860B04: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82860B08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82860B0C: 637B0004  ori r27, r27, 4
	ctx.r[27].u64 = ctx.r[27].u64 | 4;
	// 82860B10: 4BD4B901  bl 0x825ac410
	ctx.lr = 0x82860B14;
	sub_825AC410(ctx, base);
	// 82860B14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82860B18: 48000008  b 0x82860b20
	pc = 0x82860B20; continue 'dispatch;
	// 82860B1C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82860B20: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82860B24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82860B28: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82860B2C: 4BC9288D  bl 0x824f33b8
	ctx.lr = 0x82860B30;
	sub_824F33B8(ctx, base);
	// 82860B30: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82860B34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82860B38: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82860B3C: 4BA5F4C5  bl 0x822c0000
	ctx.lr = 0x82860B40;
	sub_822C0000(ctx, base);
	// 82860B40: 576B077B  rlwinm. r11, r27, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82860B44: 41820010  beq 0x82860b54
	if ctx.cr[0].eq {
	pc = 0x82860B54; continue 'dispatch;
	}
	// 82860B48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860B4C: 577B07B8  rlwinm r27, r27, 0, 0x1e, 0x1c
	ctx.r[27].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 82860B50: 485928D9  bl 0x82df3428
	ctx.lr = 0x82860B54;
	sub_82DF3428(ctx, base);
	// 82860B54: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82860B58: 3BDA0020  addi r30, r26, 0x20
	ctx.r[30].s64 = ctx.r[26].s64 + 32;
	// 82860B5C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82860B60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860B64: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82860B68: 48592EA1  bl 0x82df3a08
	ctx.lr = 0x82860B6C;
	sub_82DF3A08(ctx, base);
	// 82860B6C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82860B70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82860B74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82860B78: 4BD4B249  bl 0x825abdc0
	ctx.lr = 0x82860B7C;
	sub_825ABDC0(ctx, base);
	// 82860B7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860B80: 485928A9  bl 0x82df3428
	ctx.lr = 0x82860B84;
	sub_82DF3428(ctx, base);
	// 82860B84: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82860B88: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82860B8C: 2B1F0003  cmplwi cr6, r31, 3
	ctx.cr[6].compare_u32(ctx.r[31].u32, 3 as u32, &mut ctx.xer);
	// 82860B90: 4198FFD0  blt cr6, 0x82860b60
	if ctx.cr[6].lt {
	pc = 0x82860B60; continue 'dispatch;
	}
	// 82860B94: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82860B98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860B9C: 388B0048  addi r4, r11, 0x48
	ctx.r[4].s64 = ctx.r[11].s64 + 72;
	// 82860BA0: 48592E69  bl 0x82df3a08
	ctx.lr = 0x82860BA4;
	sub_82DF3A08(ctx, base);
	// 82860BA4: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82860BA8: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82860BAC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82860BB0: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82860BB4: 419A0024  beq cr6, 0x82860bd8
	if ctx.cr[6].eq {
	pc = 0x82860BD8; continue 'dispatch;
	}
	// 82860BB8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82860BBC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82860BC0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82860BC4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82860BC8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82860BCC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82860BD0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82860BD4: 4082FFE8  bne 0x82860bbc
	if !ctx.cr[0].eq {
	pc = 0x82860BBC; continue 'dispatch;
	}
	// 82860BD8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82860BDC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82860BE0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82860BE4: 4BD4152D  bl 0x825a2110
	ctx.lr = 0x82860BE8;
	sub_825A2110(ctx, base);
	// 82860BE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860BEC: 4859283D  bl 0x82df3428
	ctx.lr = 0x82860BF0;
	sub_82DF3428(ctx, base);
	// 82860BF0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82860BF4: 419A000C  beq cr6, 0x82860c00
	if ctx.cr[6].eq {
	pc = 0x82860C00; continue 'dispatch;
	}
	// 82860BF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82860BFC: 4BA5FC95  bl 0x822c0890
	ctx.lr = 0x82860C00;
	sub_822C0890(ctx, base);
	// 82860C00: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82860C04: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82860C08: 38A000F6  li r5, 0xf6
	ctx.r[5].s64 = 246;
	// 82860C0C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82860C10: 4BA5F7C9  bl 0x822c03d8
	ctx.lr = 0x82860C14;
	sub_822C03D8(ctx, base);
	// 82860C14: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82860C18: 41820034  beq 0x82860c4c
	if ctx.cr[0].eq {
	pc = 0x82860C4C; continue 'dispatch;
	}
	// 82860C1C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82860C20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860C24: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 82860C28: 48592DE1  bl 0x82df3a08
	ctx.lr = 0x82860C2C;
	sub_82DF3A08(ctx, base);
	// 82860C2C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82860C30: 38B9006C  addi r5, r25, 0x6c
	ctx.r[5].s64 = ctx.r[25].s64 + 108;
	// 82860C34: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82860C38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82860C3C: 637B0008  ori r27, r27, 8
	ctx.r[27].u64 = ctx.r[27].u64 | 8;
	// 82860C40: 4BD4B7D1  bl 0x825ac410
	ctx.lr = 0x82860C44;
	sub_825AC410(ctx, base);
	// 82860C44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82860C48: 48000008  b 0x82860c50
	pc = 0x82860C50; continue 'dispatch;
	// 82860C4C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82860C50: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82860C54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82860C58: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82860C5C: 4BC9275D  bl 0x824f33b8
	ctx.lr = 0x82860C60;
	sub_824F33B8(ctx, base);
	// 82860C60: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82860C64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82860C68: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82860C6C: 4BA5F395  bl 0x822c0000
	ctx.lr = 0x82860C70;
	sub_822C0000(ctx, base);
	// 82860C70: 576B0739  rlwinm. r11, r27, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82860C74: 4182000C  beq 0x82860c80
	if ctx.cr[0].eq {
	pc = 0x82860C80; continue 'dispatch;
	}
	// 82860C78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860C7C: 485927AD  bl 0x82df3428
	ctx.lr = 0x82860C80;
	sub_82DF3428(ctx, base);
	// 82860C80: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82860C84: 3BDA002C  addi r30, r26, 0x2c
	ctx.r[30].s64 = ctx.r[26].s64 + 44;
	// 82860C88: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82860C8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860C90: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82860C94: 48592D75  bl 0x82df3a08
	ctx.lr = 0x82860C98;
	sub_82DF3A08(ctx, base);
	// 82860C98: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82860C9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82860CA0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82860CA4: 4BD4B11D  bl 0x825abdc0
	ctx.lr = 0x82860CA8;
	sub_825ABDC0(ctx, base);
	// 82860CA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860CAC: 4859277D  bl 0x82df3428
	ctx.lr = 0x82860CB0;
	sub_82DF3428(ctx, base);
	// 82860CB0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82860CB4: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82860CB8: 2B1F0003  cmplwi cr6, r31, 3
	ctx.cr[6].compare_u32(ctx.r[31].u32, 3 as u32, &mut ctx.xer);
	// 82860CBC: 4198FFD0  blt cr6, 0x82860c8c
	if ctx.cr[6].lt {
	pc = 0x82860C8C; continue 'dispatch;
	}
	// 82860CC0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82860CC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860CC8: 388B0020  addi r4, r11, 0x20
	ctx.r[4].s64 = ctx.r[11].s64 + 32;
	// 82860CCC: 48592D3D  bl 0x82df3a08
	ctx.lr = 0x82860CD0;
	sub_82DF3A08(ctx, base);
	// 82860CD0: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82860CD4: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82860CD8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82860CDC: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82860CE0: 419A0024  beq cr6, 0x82860d04
	if ctx.cr[6].eq {
	pc = 0x82860D04; continue 'dispatch;
	}
	// 82860CE4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82860CE8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82860CEC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82860CF0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82860CF4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82860CF8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82860CFC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82860D00: 4082FFE8  bne 0x82860ce8
	if !ctx.cr[0].eq {
	pc = 0x82860CE8; continue 'dispatch;
	}
	// 82860D04: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82860D08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82860D0C: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82860D10: 4BD41401  bl 0x825a2110
	ctx.lr = 0x82860D14;
	sub_825A2110(ctx, base);
	// 82860D14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860D18: 48592711  bl 0x82df3428
	ctx.lr = 0x82860D1C;
	sub_82DF3428(ctx, base);
	// 82860D1C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82860D20: 419A000C  beq cr6, 0x82860d2c
	if ctx.cr[6].eq {
	pc = 0x82860D2C; continue 'dispatch;
	}
	// 82860D24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82860D28: 4BA5FB69  bl 0x822c0890
	ctx.lr = 0x82860D2C;
	sub_822C0890(ctx, base);
	// 82860D2C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82860D30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82860D34: 388B0014  addi r4, r11, 0x14
	ctx.r[4].s64 = ctx.r[11].s64 + 20;
	// 82860D38: 48592CD1  bl 0x82df3a08
	ctx.lr = 0x82860D3C;
	sub_82DF3A08(ctx, base);
	// 82860D3C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82860D40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860D44: 388BB6B8  addi r4, r11, -0x4948
	ctx.r[4].s64 = ctx.r[11].s64 + -18760;
	// 82860D48: 48592CC1  bl 0x82df3a08
	ctx.lr = 0x82860D4C;
	sub_82DF3A08(ctx, base);
	// 82860D4C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82860D50: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82860D54: 38B90070  addi r5, r25, 0x70
	ctx.r[5].s64 = ctx.r[25].s64 + 112;
	// 82860D58: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82860D5C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82860D60: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82860D64: C3CADD6C  lfs f30, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82860D68: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82860D6C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82860D70: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82860D74: 4BD42535  bl 0x825a32a8
	ctx.lr = 0x82860D78;
	sub_825A32A8(ctx, base);
	// 82860D78: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82860D7C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82860D80: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82860D84: 4BD409ED  bl 0x825a1770
	ctx.lr = 0x82860D88;
	sub_825A1770(ctx, base);
	// 82860D88: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82860D8C: 4859269D  bl 0x82df3428
	ctx.lr = 0x82860D90;
	sub_82DF3428(ctx, base);
	// 82860D90: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82860D94: 4BA67F25  bl 0x822c8cb8
	ctx.lr = 0x82860D98;
	sub_822C8CB8(ctx, base);
	// 82860D98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860D9C: 4859268D  bl 0x82df3428
	ctx.lr = 0x82860DA0;
	sub_82DF3428(ctx, base);
	// 82860DA0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82860DA4: 48592685  bl 0x82df3428
	ctx.lr = 0x82860DA8;
	sub_82DF3428(ctx, base);
	// 82860DA8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82860DAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860DB0: 388B0000  addi r4, r11, 0
	ctx.r[4].s64 = ctx.r[11].s64 + 0;
	// 82860DB4: 48592C55  bl 0x82df3a08
	ctx.lr = 0x82860DB8;
	sub_82DF3A08(ctx, base);
	// 82860DB8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82860DBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82860DC0: 388BFFEC  addi r4, r11, -0x14
	ctx.r[4].s64 = ctx.r[11].s64 + -20;
	// 82860DC4: 48592C45  bl 0x82df3a08
	ctx.lr = 0x82860DC8;
	sub_82DF3A08(ctx, base);
	// 82860DC8: 38B90078  addi r5, r25, 0x78
	ctx.r[5].s64 = ctx.r[25].s64 + 120;
	// 82860DCC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82860DD0: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82860DD4: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82860DD8: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82860DDC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82860DE0: 4BD424C9  bl 0x825a32a8
	ctx.lr = 0x82860DE4;
	sub_825A32A8(ctx, base);
	// 82860DE4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82860DE8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82860DEC: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82860DF0: 4BD40981  bl 0x825a1770
	ctx.lr = 0x82860DF4;
	sub_825A1770(ctx, base);
	// 82860DF4: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 82860DF8: 48592631  bl 0x82df3428
	ctx.lr = 0x82860DFC;
	sub_82DF3428(ctx, base);
	// 82860DFC: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 82860E00: 4BA67EB9  bl 0x822c8cb8
	ctx.lr = 0x82860E04;
	sub_822C8CB8(ctx, base);
	// 82860E04: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82860E08: 48592621  bl 0x82df3428
	ctx.lr = 0x82860E0C;
	sub_82DF3428(ctx, base);
	// 82860E0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860E10: 48592619  bl 0x82df3428
	ctx.lr = 0x82860E14;
	sub_82DF3428(ctx, base);
	// 82860E14: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82860E18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860E1C: 388BFFD4  addi r4, r11, -0x2c
	ctx.r[4].s64 = ctx.r[11].s64 + -44;
	// 82860E20: 48592BE9  bl 0x82df3a08
	ctx.lr = 0x82860E24;
	sub_82DF3A08(ctx, base);
	// 82860E24: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82860E28: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82860E2C: 388BFFC4  addi r4, r11, -0x3c
	ctx.r[4].s64 = ctx.r[11].s64 + -60;
	// 82860E30: 48592BD9  bl 0x82df3a08
	ctx.lr = 0x82860E34;
	sub_82DF3A08(ctx, base);
	// 82860E34: 38B90074  addi r5, r25, 0x74
	ctx.r[5].s64 = ctx.r[25].s64 + 116;
	// 82860E38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82860E3C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82860E40: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82860E44: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82860E48: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82860E4C: 4BD4245D  bl 0x825a32a8
	ctx.lr = 0x82860E50;
	sub_825A32A8(ctx, base);
	// 82860E50: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82860E54: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82860E58: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82860E5C: 4BD40915  bl 0x825a1770
	ctx.lr = 0x82860E60;
	sub_825A1770(ctx, base);
	// 82860E60: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 82860E64: 485925C5  bl 0x82df3428
	ctx.lr = 0x82860E68;
	sub_82DF3428(ctx, base);
	// 82860E68: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82860E6C: 4BA67E4D  bl 0x822c8cb8
	ctx.lr = 0x82860E70;
	sub_822C8CB8(ctx, base);
	// 82860E70: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82860E74: 485925B5  bl 0x82df3428
	ctx.lr = 0x82860E78;
	sub_82DF3428(ctx, base);
	// 82860E78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860E7C: 485925AD  bl 0x82df3428
	ctx.lr = 0x82860E80;
	sub_82DF3428(ctx, base);
	// 82860E80: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82860E84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860E88: 388BFFA4  addi r4, r11, -0x5c
	ctx.r[4].s64 = ctx.r[11].s64 + -92;
	// 82860E8C: 48592B7D  bl 0x82df3a08
	ctx.lr = 0x82860E90;
	sub_82DF3A08(ctx, base);
	// 82860E90: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82860E94: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82860E98: 388BFF94  addi r4, r11, -0x6c
	ctx.r[4].s64 = ctx.r[11].s64 + -108;
	// 82860E9C: 48592B6D  bl 0x82df3a08
	ctx.lr = 0x82860EA0;
	sub_82DF3A08(ctx, base);
	// 82860EA0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82860EA4: 38B9007C  addi r5, r25, 0x7c
	ctx.r[5].s64 = ctx.r[25].s64 + 124;
	// 82860EA8: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82860EAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82860EB0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82860EB4: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82860EB8: C04B6218  lfs f2, 0x6218(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82860EBC: 4BD423ED  bl 0x825a32a8
	ctx.lr = 0x82860EC0;
	sub_825A32A8(ctx, base);
	// 82860EC0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82860EC4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82860EC8: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82860ECC: 4BD408A5  bl 0x825a1770
	ctx.lr = 0x82860ED0;
	sub_825A1770(ctx, base);
	// 82860ED0: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 82860ED4: 48592555  bl 0x82df3428
	ctx.lr = 0x82860ED8;
	sub_82DF3428(ctx, base);
	// 82860ED8: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 82860EDC: 4BA67DDD  bl 0x822c8cb8
	ctx.lr = 0x82860EE0;
	sub_822C8CB8(ctx, base);
	// 82860EE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82860EE4: 48592545  bl 0x82df3428
	ctx.lr = 0x82860EE8;
	sub_82DF3428(ctx, base);
	// 82860EE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860EEC: 4859253D  bl 0x82df3428
	ctx.lr = 0x82860EF0;
	sub_82DF3428(ctx, base);
	// 82860EF0: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82860EF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860EF8: 388BD970  addi r4, r11, -0x2690
	ctx.r[4].s64 = ctx.r[11].s64 + -9872;
	// 82860EFC: 48592B0D  bl 0x82df3a08
	ctx.lr = 0x82860F00;
	sub_82DF3A08(ctx, base);
	// 82860F00: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82860F04: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82860F08: 388B71AC  addi r4, r11, 0x71ac
	ctx.r[4].s64 = ctx.r[11].s64 + 29100;
	// 82860F0C: 48592AFD  bl 0x82df3a08
	ctx.lr = 0x82860F10;
	sub_82DF3A08(ctx, base);
	// 82860F10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82860F14: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82860F18: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82860F1C: 38B90084  addi r5, r25, 0x84
	ctx.r[5].s64 = ctx.r[25].s64 + 132;
	// 82860F20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82860F24: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 82860F28: C06B08A8  lfs f3, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82860F2C: C02A08A4  lfs f1, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82860F30: 4BD42379  bl 0x825a32a8
	ctx.lr = 0x82860F34;
	sub_825A32A8(ctx, base);
	// 82860F34: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82860F38: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82860F3C: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82860F40: 4BD40831  bl 0x825a1770
	ctx.lr = 0x82860F44;
	sub_825A1770(ctx, base);
	// 82860F44: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 82860F48: 485924E1  bl 0x82df3428
	ctx.lr = 0x82860F4C;
	sub_82DF3428(ctx, base);
	// 82860F4C: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 82860F50: 4BA67D69  bl 0x822c8cb8
	ctx.lr = 0x82860F54;
	sub_822C8CB8(ctx, base);
	// 82860F54: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82860F58: 485924D1  bl 0x82df3428
	ctx.lr = 0x82860F5C;
	sub_82DF3428(ctx, base);
	// 82860F5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82860F60: 485924C9  bl 0x82df3428
	ctx.lr = 0x82860F64;
	sub_82DF3428(ctx, base);
	// 82860F64: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82860F68: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82860F6C: 4BFB79FD  bl 0x82818968
	ctx.lr = 0x82860F70;
	sub_82818968(ctx, base);
	// 82860F70: 38210210  addi r1, r1, 0x210
	ctx.r[1].s64 = ctx.r[1].s64 + 528;
	// 82860F74: CBC1FFA0  lfd f30, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 82860F78: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82860F7C: 48947228  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82860F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82860F80 size=1068
    let mut pc: u32 = 0x82860F80;
    'dispatch: loop {
        match pc {
            0x82860F80 => {
    //   block [0x82860F80..0x828613AC)
	// 82860F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82860F84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82860F88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82860F8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82860F90: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82860F94: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82860F98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82860F9C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82860FA0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82860FA4: C01F0288  lfs f0, 0x288(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(648 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82860FA8: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82860FAC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82860FB0: 419A000C  beq cr6, 0x82860fbc
	if ctx.cr[6].eq {
	pc = 0x82860FBC; continue 'dispatch;
	}
	// 82860FB4: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82860FB8: D01F0288  stfs f0, 0x288(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(648 as u32), tmp.u32 ) };
	// 82860FBC: 817F0298  lwz r11, 0x298(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(664 as u32) ) } as u64;
	// 82860FC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82860FC4: 419A000C  beq cr6, 0x82860fd0
	if ctx.cr[6].eq {
	pc = 0x82860FD0; continue 'dispatch;
	}
	// 82860FC8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82860FCC: 409A0130  bne cr6, 0x828610fc
	if !ctx.cr[6].eq {
	pc = 0x828610FC; continue 'dispatch;
	}
	// 82860FD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82860FD4: C03F027C  lfs f1, 0x27c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(636 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82860FD8: 4BF8CD69  bl 0x827edd40
	ctx.lr = 0x82860FDC;
	sub_827EDD40(ctx, base);
	// 82860FDC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82860FE0: 41820040  beq 0x82861020
	if ctx.cr[0].eq {
	pc = 0x82861020; continue 'dispatch;
	}
	// 82860FE4: 817F029C  lwz r11, 0x29c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(668 as u32) ) } as u64;
	// 82860FE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82860FEC: 419A0034  beq cr6, 0x82861020
	if ctx.cr[6].eq {
	pc = 0x82861020; continue 'dispatch;
	}
	// 82860FF0: C01F0288  lfs f0, 0x288(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(648 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82860FF4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82860FF8: 41990104  bgt cr6, 0x828610fc
	if ctx.cr[6].gt {
	pc = 0x828610FC; continue 'dispatch;
	}
	// 82860FFC: 38BF02A0  addi r5, r31, 0x2a0
	ctx.r[5].s64 = ctx.r[31].s64 + 672;
	// 82861000: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82861004: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82861008: 4BFFF279  bl 0x82860280
	ctx.lr = 0x8286100C;
	sub_82860280(ctx, base);
	// 8286100C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82861010: C01F0284  lfs f0, 0x284(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82861014: D01F0288  stfs f0, 0x288(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(648 as u32), tmp.u32 ) };
	// 82861018: 917F0298  stw r11, 0x298(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), ctx.r[11].u32 ) };
	// 8286101C: 480000E0  b 0x828610fc
	pc = 0x828610FC; continue 'dispatch;
	// 82861020: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82861024: C03F0280  lfs f1, 0x280(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(640 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82861028: 4BF8CD19  bl 0x827edd40
	ctx.lr = 0x8286102C;
	sub_827EDD40(ctx, base);
	// 8286102C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82861030: 418200CC  beq 0x828610fc
	if ctx.cr[0].eq {
	pc = 0x828610FC; continue 'dispatch;
	}
	// 82861034: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82861038: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286103C: 388BFE6C  addi r4, r11, -0x194
	ctx.r[4].s64 = ctx.r[11].s64 + -404;
	// 82861040: 485929C9  bl 0x82df3a08
	ctx.lr = 0x82861044;
	sub_82DF3A08(ctx, base);
	// 82861044: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82861048: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8286104C: 48002675  bl 0x828636c0
	ctx.lr = 0x82861050;
	sub_828636C0(ctx, base);
	// 82861050: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82861054: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82861058: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286105C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82861060: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82861064: 419A0024  beq cr6, 0x82861088
	if ctx.cr[6].eq {
	pc = 0x82861088; continue 'dispatch;
	}
	// 82861068: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8286106C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82861070: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82861074: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82861078: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8286107C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82861080: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82861084: 4082FFE8  bne 0x8286106c
	if !ctx.cr[0].eq {
	pc = 0x8286106C; continue 'dispatch;
	}
	// 82861088: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8286108C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82861090: 4BF8DBE1  bl 0x827eec70
	ctx.lr = 0x82861094;
	sub_827EEC70(ctx, base);
	// 82861094: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82861098: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286109C: 419A0008  beq cr6, 0x828610a4
	if ctx.cr[6].eq {
	pc = 0x828610A4; continue 'dispatch;
	}
	// 828610A0: 4BA5F7F1  bl 0x822c0890
	ctx.lr = 0x828610A4;
	sub_822C0890(ctx, base);
	// 828610A4: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828610A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828610AC: 419A0008  beq cr6, 0x828610b4
	if ctx.cr[6].eq {
	pc = 0x828610B4; continue 'dispatch;
	}
	// 828610B0: 4BA5F7E1  bl 0x822c0890
	ctx.lr = 0x828610B4;
	sub_822C0890(ctx, base);
	// 828610B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828610B8: 48592371  bl 0x82df3428
	ctx.lr = 0x828610BC;
	sub_82DF3428(ctx, base);
	// 828610BC: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 828610C0: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828610C4: 917F0298  stw r11, 0x298(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), ctx.r[11].u32 ) };
	// 828610C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828610CC: 38AA00E0  addi r5, r10, 0xe0
	ctx.r[5].s64 = ctx.r[10].s64 + 224;
	// 828610D0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828610D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828610D8: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828610DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828610E0: 4E800421  bctrl
	ctx.lr = 0x828610E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828610E4: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 828610E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828610EC: 419A0008  beq cr6, 0x828610f4
	if ctx.cr[6].eq {
	pc = 0x828610F4; continue 'dispatch;
	}
	// 828610F0: 4BA5F7A1  bl 0x822c0890
	ctx.lr = 0x828610F4;
	sub_822C0890(ctx, base);
	// 828610F4: 807F0264  lwz r3, 0x264(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(612 as u32) ) } as u64;
	// 828610F8: 480FE459  bl 0x8295f550
	ctx.lr = 0x828610FC;
	sub_8295F550(ctx, base);
	// 828610FC: 817F0298  lwz r11, 0x298(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(664 as u32) ) } as u64;
	// 82861100: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82861104: 409A0140  bne cr6, 0x82861244
	if !ctx.cr[6].eq {
	pc = 0x82861244; continue 'dispatch;
	}
	// 82861108: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8286110C: C03F0278  lfs f1, 0x278(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(632 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82861110: 4BF8CC31  bl 0x827edd40
	ctx.lr = 0x82861114;
	sub_827EDD40(ctx, base);
	// 82861114: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82861118: 41820124  beq 0x8286123c
	if ctx.cr[0].eq {
	pc = 0x8286123C; continue 'dispatch;
	}
	// 8286111C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82861120: 4BF8E649  bl 0x827ef768
	ctx.lr = 0x82861124;
	sub_827EF768(ctx, base);
	// 82861124: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82861128: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286112C: 388B9B40  addi r4, r11, -0x64c0
	ctx.r[4].s64 = ctx.r[11].s64 + -25792;
	// 82861130: 485928D9  bl 0x82df3a08
	ctx.lr = 0x82861134;
	sub_82DF3A08(ctx, base);
	// 82861134: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82861138: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8286113C: 48002585  bl 0x828636c0
	ctx.lr = 0x82861140;
	sub_828636C0(ctx, base);
	// 82861140: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82861144: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82861148: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286114C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82861150: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82861154: 419A0024  beq cr6, 0x82861178
	if ctx.cr[6].eq {
	pc = 0x82861178; continue 'dispatch;
	}
	// 82861158: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8286115C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82861160: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82861164: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82861168: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8286116C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82861170: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82861174: 4082FFE8  bne 0x8286115c
	if !ctx.cr[0].eq {
	pc = 0x8286115C; continue 'dispatch;
	}
	// 82861178: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8286117C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82861180: 4BF8E521  bl 0x827ef6a0
	ctx.lr = 0x82861184;
	sub_827EF6A0(ctx, base);
	// 82861184: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82861188: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286118C: 419A0008  beq cr6, 0x82861194
	if ctx.cr[6].eq {
	pc = 0x82861194; continue 'dispatch;
	}
	// 82861190: 4BA5F701  bl 0x822c0890
	ctx.lr = 0x82861194;
	sub_822C0890(ctx, base);
	// 82861194: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82861198: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286119C: 419A0008  beq cr6, 0x828611a4
	if ctx.cr[6].eq {
	pc = 0x828611A4; continue 'dispatch;
	}
	// 828611A0: 4BA5F6F1  bl 0x822c0890
	ctx.lr = 0x828611A4;
	sub_822C0890(ctx, base);
	// 828611A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828611A8: 48592281  bl 0x82df3428
	ctx.lr = 0x828611AC;
	sub_82DF3428(ctx, base);
	// 828611AC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828611B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828611B4: 388BFE64  addi r4, r11, -0x19c
	ctx.r[4].s64 = ctx.r[11].s64 + -412;
	// 828611B8: 48592851  bl 0x82df3a08
	ctx.lr = 0x828611BC;
	sub_82DF3A08(ctx, base);
	// 828611BC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828611C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828611C4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 828611C8: C02B89AC  lfs f1, -0x7654(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828611CC: 4800256D  bl 0x82863738
	ctx.lr = 0x828611D0;
	sub_82863738(ctx, base);
	// 828611D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828611D4: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828611D8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828611DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828611E0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 828611E4: 419A0024  beq cr6, 0x82861208
	if ctx.cr[6].eq {
	pc = 0x82861208; continue 'dispatch;
	}
	// 828611E8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828611EC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828611F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828611F4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828611F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828611FC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82861200: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82861204: 4082FFE8  bne 0x828611ec
	if !ctx.cr[0].eq {
	pc = 0x828611EC; continue 'dispatch;
	}
	// 82861208: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8286120C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82861210: 4BF8E491  bl 0x827ef6a0
	ctx.lr = 0x82861214;
	sub_827EF6A0(ctx, base);
	// 82861214: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82861218: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286121C: 419A0008  beq cr6, 0x82861224
	if ctx.cr[6].eq {
	pc = 0x82861224; continue 'dispatch;
	}
	// 82861220: 4BA5F671  bl 0x822c0890
	ctx.lr = 0x82861224;
	sub_822C0890(ctx, base);
	// 82861224: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82861228: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286122C: 419A0008  beq cr6, 0x82861234
	if ctx.cr[6].eq {
	pc = 0x82861234; continue 'dispatch;
	}
	// 82861230: 4BA5F661  bl 0x822c0890
	ctx.lr = 0x82861234;
	sub_822C0890(ctx, base);
	// 82861234: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82861238: 485921F1  bl 0x82df3428
	ctx.lr = 0x8286123C;
	sub_82DF3428(ctx, base);
	// 8286123C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82861240: 4800014C  b 0x8286138c
	pc = 0x8286138C; continue 'dispatch;
	// 82861244: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82861248: 409A0148  bne cr6, 0x82861390
	if !ctx.cr[6].eq {
	pc = 0x82861390; continue 'dispatch;
	}
	// 8286124C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82861250: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82861254: 4BFFE6FD  bl 0x8285f950
	ctx.lr = 0x82861258;
	sub_8285F950(ctx, base);
	// 82861258: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 8286125C: 4198008C  blt cr6, 0x828612e8
	if ctx.cr[6].lt {
	pc = 0x828612E8; continue 'dispatch;
	}
	// 82861260: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82861264: C00BFE44  lfs f0, -0x1bc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-444 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82861268: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8286126C: 4099007C  ble cr6, 0x828612e8
	if !ctx.cr[6].gt {
	pc = 0x828612E8; continue 'dispatch;
	}
	// 82861270: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82861274: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82861278: 388BFE80  addi r4, r11, -0x180
	ctx.r[4].s64 = ctx.r[11].s64 + -384;
	// 8286127C: 4859278D  bl 0x82df3a08
	ctx.lr = 0x82861280;
	sub_82DF3A08(ctx, base);
	// 82861280: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82861284: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82861288: 48002439  bl 0x828636c0
	ctx.lr = 0x8286128C;
	sub_828636C0(ctx, base);
	// 8286128C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82861290: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82861294: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82861298: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286129C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 828612A0: 419A0024  beq cr6, 0x828612c4
	if ctx.cr[6].eq {
	pc = 0x828612C4; continue 'dispatch;
	}
	// 828612A4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828612A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828612AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828612B0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828612B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828612B8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828612BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828612C0: 4082FFE8  bne 0x828612a8
	if !ctx.cr[0].eq {
	pc = 0x828612A8; continue 'dispatch;
	}
	// 828612C4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828612C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828612CC: 4BF8D9A5  bl 0x827eec70
	ctx.lr = 0x828612D0;
	sub_827EEC70(ctx, base);
	// 828612D0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828612D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828612D8: 419A0008  beq cr6, 0x828612e0
	if ctx.cr[6].eq {
	pc = 0x828612E0; continue 'dispatch;
	}
	// 828612DC: 4BA5F5B5  bl 0x822c0890
	ctx.lr = 0x828612E0;
	sub_822C0890(ctx, base);
	// 828612E0: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 828612E4: 48000090  b 0x82861374
	pc = 0x82861374; continue 'dispatch;
	// 828612E8: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 828612EC: 409800A4  bge cr6, 0x82861390
	if !ctx.cr[6].lt {
	pc = 0x82861390; continue 'dispatch;
	}
	// 828612F0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828612F4: C00B00DC  lfs f0, 0xdc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(220 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828612F8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828612FC: 40980094  bge cr6, 0x82861390
	if !ctx.cr[6].lt {
	pc = 0x82861390; continue 'dispatch;
	}
	// 82861300: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82861304: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82861308: 388BFE78  addi r4, r11, -0x188
	ctx.r[4].s64 = ctx.r[11].s64 + -392;
	// 8286130C: 485926FD  bl 0x82df3a08
	ctx.lr = 0x82861310;
	sub_82DF3A08(ctx, base);
	// 82861310: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82861314: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82861318: 480023A9  bl 0x828636c0
	ctx.lr = 0x8286131C;
	sub_828636C0(ctx, base);
	// 8286131C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82861320: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82861324: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82861328: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286132C: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82861330: 419A0024  beq cr6, 0x82861354
	if ctx.cr[6].eq {
	pc = 0x82861354; continue 'dispatch;
	}
	// 82861334: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82861338: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8286133C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82861340: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82861344: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82861348: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8286134C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82861350: 4082FFE8  bne 0x82861338
	if !ctx.cr[0].eq {
	pc = 0x82861338; continue 'dispatch;
	}
	// 82861354: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82861358: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8286135C: 4BF8D915  bl 0x827eec70
	ctx.lr = 0x82861360;
	sub_827EEC70(ctx, base);
	// 82861360: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82861364: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82861368: 419A0008  beq cr6, 0x82861370
	if ctx.cr[6].eq {
	pc = 0x82861370; continue 'dispatch;
	}
	// 8286136C: 4BA5F525  bl 0x822c0890
	ctx.lr = 0x82861370;
	sub_822C0890(ctx, base);
	// 82861370: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82861374: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82861378: 419A0008  beq cr6, 0x82861380
	if ctx.cr[6].eq {
	pc = 0x82861380; continue 'dispatch;
	}
	// 8286137C: 4BA5F515  bl 0x822c0890
	ctx.lr = 0x82861380;
	sub_822C0890(ctx, base);
	// 82861380: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82861384: 485920A5  bl 0x82df3428
	ctx.lr = 0x82861388;
	sub_82DF3428(ctx, base);
	// 82861388: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 8286138C: 917F0298  stw r11, 0x298(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), ctx.r[11].u32 ) };
	// 82861390: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82861394: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82861398: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286139C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828613A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828613A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828613A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828613B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828613B0 size=228
    let mut pc: u32 = 0x828613B0;
    'dispatch: loop {
        match pc {
            0x828613B0 => {
    //   block [0x828613B0..0x82861494)
	// 828613B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828613B4: 48946DB5  bl 0x831a8168
	ctx.lr = 0x828613B8;
	sub_831A8130(ctx, base);
	// 828613B8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828613BC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 828613C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828613C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828613C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828613CC: 48591DE5  bl 0x82df31b0
	ctx.lr = 0x828613D0;
	sub_82DF31B0(ctx, base);
	// 828613D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828613D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828613D8: 4BFB90D1  bl 0x8281a4a8
	ctx.lr = 0x828613DC;
	sub_8281A4A8(ctx, base);
	// 828613DC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828613E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828613E4: 4BFFF3DD  bl 0x828607c0
	ctx.lr = 0x828613E8;
	sub_828607C0(ctx, base);
	// 828613E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828613EC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828613F0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828613F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828613F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828613FC: 419A0024  beq cr6, 0x82861420
	if ctx.cr[6].eq {
	pc = 0x82861420; continue 'dispatch;
	}
	// 82861400: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82861404: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82861408: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286140C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82861410: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82861414: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82861418: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286141C: 4082FFE8  bne 0x82861404
	if !ctx.cr[0].eq {
	pc = 0x82861404; continue 'dispatch;
	}
	// 82861420: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82861424: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82861428: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8286142C: 388A0070  addi r4, r10, 0x70
	ctx.r[4].s64 = ctx.r[10].s64 + 112;
	// 82861430: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82861434: 38A00229  li r5, 0x229
	ctx.r[5].s64 = 553;
	// 82861438: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8286143C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82861440: 485F7601  bl 0x82e58a40
	ctx.lr = 0x82861444;
	sub_82E58A40(ctx, base);
	// 82861444: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82861448: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286144C: 419A0008  beq cr6, 0x82861454
	if ctx.cr[6].eq {
	pc = 0x82861454; continue 'dispatch;
	}
	// 82861450: 4BA5F441  bl 0x822c0890
	ctx.lr = 0x82861454;
	sub_822C0890(ctx, base);
	// 82861454: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82861458: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286145C: 419A0008  beq cr6, 0x82861464
	if ctx.cr[6].eq {
	pc = 0x82861464; continue 'dispatch;
	}
	// 82861460: 4BA5F431  bl 0x822c0890
	ctx.lr = 0x82861464;
	sub_822C0890(ctx, base);
	// 82861464: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 82861468: 48591D49  bl 0x82df31b0
	ctx.lr = 0x8286146C;
	sub_82DF31B0(ctx, base);
	// 8286146C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82861470: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82861474: 4BFB9035  bl 0x8281a4a8
	ctx.lr = 0x82861478;
	sub_8281A4A8(ctx, base);
	// 82861478: 387D0008  addi r3, r29, 8
	ctx.r[3].s64 = ctx.r[29].s64 + 8;
	// 8286147C: 48591D35  bl 0x82df31b0
	ctx.lr = 0x82861480;
	sub_82DF31B0(ctx, base);
	// 82861480: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82861484: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82861488: 4BFB9021  bl 0x8281a4a8
	ctx.lr = 0x8286148C;
	sub_8281A4A8(ctx, base);
	// 8286148C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82861490: 48946D28  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82861498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82861498 size=132
    let mut pc: u32 = 0x82861498;
    'dispatch: loop {
        match pc {
            0x82861498 => {
    //   block [0x82861498..0x8286151C)
	// 82861498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286149C: 48946CD1  bl 0x831a816c
	ctx.lr = 0x828614A0;
	sub_831A8130(ctx, base);
	// 828614A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828614A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828614A8: 480FF0B9  bl 0x82960560
	ctx.lr = 0x828614AC;
	sub_82960560(ctx, base);
	// 828614AC: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828614B0: 41820064  beq 0x82861514
	if ctx.cr[0].eq {
	pc = 0x82861514; continue 'dispatch;
	}
	// 828614B4: 815F02A0  lwz r10, 0x2a0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(672 as u32) ) } as u64;
	// 828614B8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828614BC: 554A07FF  clrlwi. r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828614C0: 3BCBB854  addi r30, r11, -0x47ac
	ctx.r[30].s64 = ctx.r[11].s64 + -18348;
	// 828614C4: 41820020  beq 0x828614e4
	if ctx.cr[0].eq {
	pc = 0x828614E4; continue 'dispatch;
	}
	// 828614C8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828614CC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828614D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828614D4: 4BFFFEDD  bl 0x828613b0
	ctx.lr = 0x828614D8;
	sub_828613B0(ctx, base);
	// 828614D8: 817F029C  lwz r11, 0x29c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(668 as u32) ) } as u64;
	// 828614DC: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 828614E0: 917F029C  stw r11, 0x29c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(668 as u32), ctx.r[11].u32 ) };
	// 828614E4: 817F02A0  lwz r11, 0x2a0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(672 as u32) ) } as u64;
	// 828614E8: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828614EC: 41820020  beq 0x8286150c
	if ctx.cr[0].eq {
	pc = 0x8286150C; continue 'dispatch;
	}
	// 828614F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828614F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828614F8: 38BE000C  addi r5, r30, 0xc
	ctx.r[5].s64 = ctx.r[30].s64 + 12;
	// 828614FC: 4BFFFEB5  bl 0x828613b0
	ctx.lr = 0x82861500;
	sub_828613B0(ctx, base);
	// 82861500: 817F029C  lwz r11, 0x29c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(668 as u32) ) } as u64;
	// 82861504: 696B0002  xori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 ^ 2;
	// 82861508: 917F029C  stw r11, 0x29c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(668 as u32), ctx.r[11].u32 ) };
	// 8286150C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82861510: 917F02A0  stw r11, 0x2a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(672 as u32), ctx.r[11].u32 ) };
	// 82861514: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82861518: 48946CA4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82861520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82861520 size=132
    let mut pc: u32 = 0x82861520;
    'dispatch: loop {
        match pc {
            0x82861520 => {
    //   block [0x82861520..0x828615A4)
	// 82861520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82861524: 48946C49  bl 0x831a816c
	ctx.lr = 0x82861528;
	sub_831A8130(ctx, base);
	// 82861528: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286152C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82861530: 480FF031  bl 0x82960560
	ctx.lr = 0x82861534;
	sub_82960560(ctx, base);
	// 82861534: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82861538: 41820064  beq 0x8286159c
	if ctx.cr[0].eq {
	pc = 0x8286159C; continue 'dispatch;
	}
	// 8286153C: 815F02A0  lwz r10, 0x2a0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(672 as u32) ) } as u64;
	// 82861540: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82861544: 554A077B  rlwinm. r10, r10, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82861548: 3BCBB854  addi r30, r11, -0x47ac
	ctx.r[30].s64 = ctx.r[11].s64 + -18348;
	// 8286154C: 41820020  beq 0x8286156c
	if ctx.cr[0].eq {
	pc = 0x8286156C; continue 'dispatch;
	}
	// 82861550: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82861554: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82861558: 38BE0018  addi r5, r30, 0x18
	ctx.r[5].s64 = ctx.r[30].s64 + 24;
	// 8286155C: 4BFFFE55  bl 0x828613b0
	ctx.lr = 0x82861560;
	sub_828613B0(ctx, base);
	// 82861560: 817F029C  lwz r11, 0x29c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(668 as u32) ) } as u64;
	// 82861564: 696B0004  xori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 ^ 4;
	// 82861568: 917F029C  stw r11, 0x29c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(668 as u32), ctx.r[11].u32 ) };
	// 8286156C: 817F02A0  lwz r11, 0x2a0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(672 as u32) ) } as u64;
	// 82861570: 556B0739  rlwinm. r11, r11, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82861574: 41820020  beq 0x82861594
	if ctx.cr[0].eq {
	pc = 0x82861594; continue 'dispatch;
	}
	// 82861578: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8286157C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82861580: 38BE0024  addi r5, r30, 0x24
	ctx.r[5].s64 = ctx.r[30].s64 + 36;
	// 82861584: 4BFFFE2D  bl 0x828613b0
	ctx.lr = 0x82861588;
	sub_828613B0(ctx, base);
	// 82861588: 817F029C  lwz r11, 0x29c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(668 as u32) ) } as u64;
	// 8286158C: 696B0008  xori r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 ^ 8;
	// 82861590: 917F029C  stw r11, 0x29c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(668 as u32), ctx.r[11].u32 ) };
	// 82861594: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82861598: 917F02A0  stw r11, 0x2a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(672 as u32), ctx.r[11].u32 ) };
	// 8286159C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828615A0: 48946C1C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828615A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828615A8 size=180
    let mut pc: u32 = 0x828615A8;
    'dispatch: loop {
        match pc {
            0x828615A8 => {
    //   block [0x828615A8..0x8286165C)
	// 828615A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828615AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828615B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828615B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828615B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828615BC: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 828615C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828615C4: 394A0F80  addi r10, r10, 0xf80
	ctx.r[10].s64 = ctx.r[10].s64 + 3968;
	// 828615C8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828615CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828615D0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828615D4: 3D00822C  lis r8, -0x7dd4
	ctx.r[8].s64 = -2111045632;
	// 828615D8: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828615DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828615E0: 39080000  addi r8, r8, 0
	ctx.r[8].s64 = ctx.r[8].s64 + 0;
	// 828615E4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828615E8: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828615EC: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 828615F0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828615F4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 828615F8: 81290070  lwz r9, 0x70(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(112 as u32) ) } as u64;
	// 828615FC: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82861600: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82861604: 4E800421  bctrl
	ctx.lr = 0x82861608;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82861608: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 8286160C: 4182002C  beq 0x82861638
	if ctx.cr[0].eq {
	pc = 0x82861638; continue 'dispatch;
	}
	// 82861610: 817F0294  lwz r11, 0x294(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(660 as u32) ) } as u64;
	// 82861614: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 82861618: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 8286161C: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82861620: 55681838  slwi r8, r11, 3
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82861624: 7D68502E  lwzx r11, r8, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82861628: 7D48482E  lwzx r10, r8, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8286162C: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82861630: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82861634: 4E800421  bctrl
	ctx.lr = 0x82861638;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82861638: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8286163C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82861640: 4BFB6049  bl 0x82817688
	ctx.lr = 0x82861644;
	sub_82817688(ctx, base);
	// 82861644: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82861648: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286164C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82861650: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82861654: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82861658: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82861660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82861660 size=460
    let mut pc: u32 = 0x82861660;
    'dispatch: loop {
        match pc {
            0x82861660 => {
    //   block [0x82861660..0x8286182C)
	// 82861660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82861664: 48946B05  bl 0x831a8168
	ctx.lr = 0x82861668;
	sub_831A8130(ctx, base);
	// 82861668: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8286166C: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82861670: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82861674: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82861678: 3BCB0070  addi r30, r11, 0x70
	ctx.r[30].s64 = ctx.r[11].s64 + 112;
	// 8286167C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82861680: 38A0008E  li r5, 0x8e
	ctx.r[5].s64 = 142;
	// 82861684: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82861688: 386002D0  li r3, 0x2d0
	ctx.r[3].s64 = 720;
	// 8286168C: 48590D5D  bl 0x82df23e8
	ctx.lr = 0x82861690;
	sub_82DF23E8(ctx, base);
	// 82861690: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82861694: 41820010  beq 0x828616a4
	if ctx.cr[0].eq {
	pc = 0x828616A4; continue 'dispatch;
	}
	// 82861698: 4BFFE691  bl 0x8285fd28
	ctx.lr = 0x8286169C;
	sub_8285FD28(ctx, base);
	// 8286169C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828616A0: 48000008  b 0x828616a8
	pc = 0x828616A8; continue 'dispatch;
	// 828616A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828616A8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828616AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828616B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828616B4: 4BFFE3BD  bl 0x8285fa70
	ctx.lr = 0x828616B8;
	sub_8285FA70(ctx, base);
	// 828616B8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828616BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828616C0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828616C4: 4BA5E93D  bl 0x822c0000
	ctx.lr = 0x828616C8;
	sub_822C0000(ctx, base);
	// 828616C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828616CC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828616D0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828616D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828616D8: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828616DC: 396A0208  addi r11, r10, 0x208
	ctx.r[11].s64 = ctx.r[10].s64 + 520;
	// 828616E0: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828616E4: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828616E8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828616EC: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828616F0: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828616F4: 409A0008  bne cr6, 0x828616fc
	if !ctx.cr[6].eq {
	pc = 0x828616FC; continue 'dispatch;
	}
	// 828616F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828616FC: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82861700: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82861704: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82861708: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 8286170C: 419A0024  beq cr6, 0x82861730
	if ctx.cr[6].eq {
	pc = 0x82861730; continue 'dispatch;
	}
	// 82861710: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82861714: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82861718: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286171C: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82861720: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82861724: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82861728: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286172C: 4082FFE8  bne 0x82861714
	if !ctx.cr[0].eq {
	pc = 0x82861714; continue 'dispatch;
	}
	// 82861730: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82861734: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82861738: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 8286173C: 419A0024  beq cr6, 0x82861760
	if ctx.cr[6].eq {
	pc = 0x82861760; continue 'dispatch;
	}
	// 82861740: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82861744: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82861748: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286174C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82861750: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82861754: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82861758: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286175C: 4082FFE8  bne 0x82861744
	if !ctx.cr[0].eq {
	pc = 0x82861744; continue 'dispatch;
	}
	// 82861760: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82861764: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82861768: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8286176C: C02B7590  lfs f1, 0x7590(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82861770: 4861B4D1  bl 0x82e7cc40
	ctx.lr = 0x82861774;
	sub_82E7CC40(ctx, base);
	// 82861774: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82861778: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8286177C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82861780: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82861784: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82861788: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8286178C: 4BF377A5  bl 0x82798f30
	ctx.lr = 0x82861790;
	sub_82798F30(ctx, base);
	// 82861790: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82861794: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82861798: 996100BC  stb r11, 0xbc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[11].u8 ) };
	// 8286179C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828617A0: 38A00094  li r5, 0x94
	ctx.r[5].s64 = 148;
	// 828617A4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828617A8: 4BA5EC31  bl 0x822c03d8
	ctx.lr = 0x828617AC;
	sub_822C03D8(ctx, base);
	// 828617AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828617B0: 41820014  beq 0x828617c4
	if ctx.cr[0].eq {
	pc = 0x828617C4; continue 'dispatch;
	}
	// 828617B4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828617B8: 4BF39EB1  bl 0x8279b668
	ctx.lr = 0x828617BC;
	sub_8279B668(ctx, base);
	// 828617BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828617C0: 48000008  b 0x828617c8
	pc = 0x828617C8; continue 'dispatch;
	// 828617C4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828617C8: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828617CC: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 828617D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828617D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828617D8: 4BD36479  bl 0x82597c50
	ctx.lr = 0x828617DC;
	sub_82597C50(ctx, base);
	// 828617DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828617E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828617E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828617E8: 4BA5E819  bl 0x822c0000
	ctx.lr = 0x828617EC;
	sub_822C0000(ctx, base);
	// 828617EC: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 828617F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828617F4: 419A0008  beq cr6, 0x828617fc
	if ctx.cr[6].eq {
	pc = 0x828617FC; continue 'dispatch;
	}
	// 828617F8: 4BA5F099  bl 0x822c0890
	ctx.lr = 0x828617FC;
	sub_822C0890(ctx, base);
	// 828617FC: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82861800: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82861804: 419A0008  beq cr6, 0x8286180c
	if ctx.cr[6].eq {
	pc = 0x8286180C; continue 'dispatch;
	}
	// 82861808: 4BA5F089  bl 0x822c0890
	ctx.lr = 0x8286180C;
	sub_822C0890(ctx, base);
	// 8286180C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82861810: 419A000C  beq cr6, 0x8286181c
	if ctx.cr[6].eq {
	pc = 0x8286181C; continue 'dispatch;
	}
	// 82861814: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82861818: 4BA5F079  bl 0x822c0890
	ctx.lr = 0x8286181C;
	sub_822C0890(ctx, base);
	// 8286181C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82861820: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82861824: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82861828: 48946990  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82861830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82861830 size=128
    let mut pc: u32 = 0x82861830;
    'dispatch: loop {
        match pc {
            0x82861830 => {
    //   block [0x82861830..0x828618B0)
	// 82861830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82861834: 48946939  bl 0x831a816c
	ctx.lr = 0x82861838;
	sub_831A8130(ctx, base);
	// 82861838: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286183C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82861840: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82861844: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82861848: 3BEBB838  addi r31, r11, -0x47c8
	ctx.r[31].s64 = ctx.r[11].s64 + -18376;
	// 8286184C: 816AB840  lwz r11, -0x47c0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-18368 as u32) ) } as u64;
	// 82861850: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82861854: 40820024  bne 0x82861878
	if !ctx.cr[0].eq {
	pc = 0x82861878; continue 'dispatch;
	}
	// 82861858: 3D208271  lis r9, -0x7d8f
	ctx.r[9].s64 = -2106523648;
	// 8286185C: 3D008286  lis r8, -0x7d7a
	ctx.r[8].s64 = -2105147392;
	// 82861860: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82861864: 39298E48  addi r9, r9, -0x71b8
	ctx.r[9].s64 = ctx.r[9].s64 + -29112;
	// 82861868: 3908FC98  addi r8, r8, -0x368
	ctx.r[8].s64 = ctx.r[8].s64 + -872;
	// 8286186C: 916AB840  stw r11, -0x47c0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-18368 as u32), ctx.r[11].u32 ) };
	// 82861870: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82861874: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82861878: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8286187C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82861880: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82861884: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82861888: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 8286188C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82861890: 4BDF2D31  bl 0x826545c0
	ctx.lr = 0x82861894;
	sub_826545C0(ctx, base);
	// 82861894: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82861898: 4182000C  beq 0x828618a4
	if ctx.cr[0].eq {
	pc = 0x828618A4; continue 'dispatch;
	}
	// 8286189C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828618A0: 48000008  b 0x828618a8
	pc = 0x828618A8; continue 'dispatch;
	// 828618A4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828618A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828618AC: 48946910  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828618B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828618B0 size=128
    let mut pc: u32 = 0x828618B0;
    'dispatch: loop {
        match pc {
            0x828618B0 => {
    //   block [0x828618B0..0x82861930)
	// 828618B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828618B4: 489468B9  bl 0x831a816c
	ctx.lr = 0x828618B8;
	sub_831A8130(ctx, base);
	// 828618B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828618BC: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 828618C0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828618C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828618C8: 3BEBB844  addi r31, r11, -0x47bc
	ctx.r[31].s64 = ctx.r[11].s64 + -18364;
	// 828618CC: 816AB84C  lwz r11, -0x47b4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-18356 as u32) ) } as u64;
	// 828618D0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828618D4: 40820024  bne 0x828618f8
	if !ctx.cr[0].eq {
	pc = 0x828618F8; continue 'dispatch;
	}
	// 828618D8: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 828618DC: 3D008286  lis r8, -0x7d7a
	ctx.r[8].s64 = -2105147392;
	// 828618E0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828618E4: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 828618E8: 3908FCE0  addi r8, r8, -0x320
	ctx.r[8].s64 = ctx.r[8].s64 + -800;
	// 828618EC: 916AB84C  stw r11, -0x47b4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-18356 as u32), ctx.r[11].u32 ) };
	// 828618F0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828618F4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828618F8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828618FC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82861900: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82861904: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82861908: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 8286190C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82861910: 4BDF2CB1  bl 0x826545c0
	ctx.lr = 0x82861914;
	sub_826545C0(ctx, base);
	// 82861914: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82861918: 4182000C  beq 0x82861924
	if ctx.cr[0].eq {
	pc = 0x82861924; continue 'dispatch;
	}
	// 8286191C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82861920: 48000008  b 0x82861928
	pc = 0x82861928; continue 'dispatch;
	// 82861924: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82861928: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8286192C: 48946890  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82861930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82861930 size=1636
    let mut pc: u32 = 0x82861930;
    'dispatch: loop {
        match pc {
            0x82861930 => {
    //   block [0x82861930..0x82861F94)
	// 82861930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82861934: 48946825  bl 0x831a8158
	ctx.lr = 0x82861938;
	sub_831A8130(ctx, base);
	// 82861938: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 8286193C: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82861940: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82861944: 4BFB88F5  bl 0x8281a238
	ctx.lr = 0x82861948;
	sub_8281A238(ctx, base);
	// 82861948: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8286194C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82861950: 4BF8AC79  bl 0x827ec5c8
	ctx.lr = 0x82861954;
	sub_827EC5C8(ctx, base);
	// 82861954: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82861958: 3B4B3F2C  addi r26, r11, 0x3f2c
	ctx.r[26].s64 = ctx.r[11].s64 + 16172;
	// 8286195C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82861960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82861964: 419A0054  beq cr6, 0x828619b8
	if ctx.cr[6].eq {
	pc = 0x828619B8; continue 'dispatch;
	}
	// 82861968: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8286196C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82861970: 48592099  bl 0x82df3a08
	ctx.lr = 0x82861974;
	sub_82DF3A08(ctx, base);
	// 82861974: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82861978: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8286197C: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82861980: 485B36B1  bl 0x82e15030
	ctx.lr = 0x82861984;
	sub_82E15030(ctx, base);
	// 82861984: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82861988: 395F025C  addi r10, r31, 0x25c
	ctx.r[10].s64 = ctx.r[31].s64 + 604;
	// 8286198C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82861990: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82861994: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82861998: 917F025C  stw r11, 0x25c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(604 as u32), ctx.r[11].u32 ) };
	// 8286199C: 4BA62AC5  bl 0x822c4460
	ctx.lr = 0x828619A0;
	sub_822C4460(ctx, base);
	// 828619A0: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 828619A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828619A8: 419A0008  beq cr6, 0x828619b0
	if ctx.cr[6].eq {
	pc = 0x828619B0; continue 'dispatch;
	}
	// 828619AC: 4BA5EEE5  bl 0x822c0890
	ctx.lr = 0x828619B0;
	sub_822C0890(ctx, base);
	// 828619B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828619B4: 48591A75  bl 0x82df3428
	ctx.lr = 0x828619B8;
	sub_82DF3428(ctx, base);
	// 828619B8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828619BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828619C0: 419A0008  beq cr6, 0x828619c8
	if ctx.cr[6].eq {
	pc = 0x828619C8; continue 'dispatch;
	}
	// 828619C4: 4BA5EECD  bl 0x822c0890
	ctx.lr = 0x828619C8;
	sub_822C0890(ctx, base);
	// 828619C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828619CC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828619D0: 4BF8ABF9  bl 0x827ec5c8
	ctx.lr = 0x828619D4;
	sub_827EC5C8(ctx, base);
	// 828619D4: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828619D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828619DC: 419A0058  beq cr6, 0x82861a34
	if ctx.cr[6].eq {
	pc = 0x82861A34; continue 'dispatch;
	}
	// 828619E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828619E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828619E8: 388B1EDC  addi r4, r11, 0x1edc
	ctx.r[4].s64 = ctx.r[11].s64 + 7900;
	// 828619EC: 4859201D  bl 0x82df3a08
	ctx.lr = 0x828619F0;
	sub_82DF3A08(ctx, base);
	// 828619F0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828619F4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828619F8: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828619FC: 485B3635  bl 0x82e15030
	ctx.lr = 0x82861A00;
	sub_82E15030(ctx, base);
	// 82861A00: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82861A04: 395F0254  addi r10, r31, 0x254
	ctx.r[10].s64 = ctx.r[31].s64 + 596;
	// 82861A08: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82861A0C: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82861A10: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82861A14: 917F0254  stw r11, 0x254(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(596 as u32), ctx.r[11].u32 ) };
	// 82861A18: 4BA62A49  bl 0x822c4460
	ctx.lr = 0x82861A1C;
	sub_822C4460(ctx, base);
	// 82861A1C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82861A20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82861A24: 419A0008  beq cr6, 0x82861a2c
	if ctx.cr[6].eq {
	pc = 0x82861A2C; continue 'dispatch;
	}
	// 82861A28: 4BA5EE69  bl 0x822c0890
	ctx.lr = 0x82861A2C;
	sub_822C0890(ctx, base);
	// 82861A2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82861A30: 485919F9  bl 0x82df3428
	ctx.lr = 0x82861A34;
	sub_82DF3428(ctx, base);
	// 82861A34: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82861A38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82861A3C: 419A0008  beq cr6, 0x82861a44
	if ctx.cr[6].eq {
	pc = 0x82861A44; continue 'dispatch;
	}
	// 82861A40: 4BA5EE51  bl 0x822c0890
	ctx.lr = 0x82861A44;
	sub_822C0890(ctx, base);
	// 82861A44: 817F0254  lwz r11, 0x254(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(596 as u32) ) } as u64;
	// 82861A48: 3BDF0254  addi r30, r31, 0x254
	ctx.r[30].s64 = ctx.r[31].s64 + 596;
	// 82861A4C: 3B600060  li r27, 0x60
	ctx.r[27].s64 = 96;
	// 82861A50: 3F808332  lis r28, -0x7cce
	ctx.r[28].s64 = -2093875200;
	// 82861A54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82861A58: 419A00F8  beq cr6, 0x82861b50
	if ctx.cr[6].eq {
	pc = 0x82861B50; continue 'dispatch;
	}
	// 82861A5C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82861A60: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82861A64: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82861A68: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 82861A6C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82861A70: 4863ECC1  bl 0x82ea0730
	ctx.lr = 0x82861A74;
	sub_82EA0730(ctx, base);
	// 82861A74: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82861A78: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82861A7C: 396BC4C0  addi r11, r11, -0x3b40
	ctx.r[11].s64 = ctx.r[11].s64 + -15168;
	// 82861A80: 394A5930  addi r10, r10, 0x5930
	ctx.r[10].s64 = ctx.r[10].s64 + 22832;
	// 82861A84: 39210100  addi r9, r1, 0x100
	ctx.r[9].s64 = ctx.r[1].s64 + 256;
	// 82861A88: 39010110  addi r8, r1, 0x110
	ctx.r[8].s64 = ctx.r[1].s64 + 272;
	// 82861A8C: B3630004  sth r27, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[27].u16 ) };
	// 82861A90: 3CE08203  lis r7, -0x7dfd
	ctx.r[7].s64 = -2113732608;
	// 82861A94: C05CF614  lfs f2, -0x9ec(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-2540 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82861A98: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82861A9C: 38A10100  addi r5, r1, 0x100
	ctx.r[5].s64 = ctx.r[1].s64 + 256;
	// 82861AA0: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82861AA4: 38810110  addi r4, r1, 0x110
	ctx.r[4].s64 = ctx.r[1].s64 + 272;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82861F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82861F98 size=276
    let mut pc: u32 = 0x82861F98;
    'dispatch: loop {
        match pc {
            0x82861F98 => {
    //   block [0x82861F98..0x828620AC)
	// 82861F98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82861F9C: 489461CD  bl 0x831a8168
	ctx.lr = 0x82861FA0;
	sub_831A8130(ctx, base);
	// 82861FA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82861FA4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82861FA8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82861FAC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82861FB0: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82861FB4: 41820038  beq 0x82861fec
	if ctx.cr[0].eq {
	pc = 0x82861FEC; continue 'dispatch;
	}
	// 82861FB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82861FBC: 489479CD  bl 0x831a9988
	ctx.lr = 0x82861FC0;
	sub_831A9988(ctx, base);
	// 82861FC0: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82861FC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82861FC8: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 82861FCC: 4894612D  bl 0x831a80f8
	ctx.lr = 0x82861FD0;
	sub_831A80F8(ctx, base);
	// 82861FD0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82861FD4: 41820018  beq 0x82861fec
	if ctx.cr[0].eq {
	pc = 0x82861FEC; continue 'dispatch;
	}
	// 82861FD8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82861FDC: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82861FE0: 48008F41  bl 0x8286af20
	ctx.lr = 0x82861FE4;
	sub_8286AF20(ctx, base);
	// 82861FE4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82861FE8: 480000BC  b 0x828620a4
	pc = 0x828620A4; continue 'dispatch;
	// 82861FEC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82861FF0: 419A00A4  beq cr6, 0x82862094
	if ctx.cr[6].eq {
	pc = 0x82862094; continue 'dispatch;
	}
	// 82861FF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82861FF8: 48947991  bl 0x831a9988
	ctx.lr = 0x82861FFC;
	sub_831A9988(ctx, base);
	// 82861FFC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82862000: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82862004: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 82862008: 489460F1  bl 0x831a80f8
	ctx.lr = 0x8286200C;
	sub_831A80F8(ctx, base);
	// 8286200C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82862010: 41820014  beq 0x82862024
	if ctx.cr[0].eq {
	pc = 0x82862024; continue 'dispatch;
	}
	// 82862014: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82862018: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8286201C: 4BFFE73D  bl 0x82860758
	ctx.lr = 0x82862020;
	sub_82860758(ctx, base);
	// 82862020: 4BFFFFC4  b 0x82861fe4
	pc = 0x82861FE4; continue 'dispatch;
	// 82862024: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82862028: 419A006C  beq cr6, 0x82862094
	if ctx.cr[6].eq {
	pc = 0x82862094; continue 'dispatch;
	}
	// 8286202C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82862030: 48947959  bl 0x831a9988
	ctx.lr = 0x82862034;
	sub_831A9988(ctx, base);
	// 82862034: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82862038: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286203C: 386BCAE8  addi r3, r11, -0x3518
	ctx.r[3].s64 = ctx.r[11].s64 + -13592;
	// 82862040: 489460B9  bl 0x831a80f8
	ctx.lr = 0x82862044;
	sub_831A80F8(ctx, base);
	// 82862044: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82862048: 41820014  beq 0x8286205c
	if ctx.cr[0].eq {
	pc = 0x8286205C; continue 'dispatch;
	}
	// 8286204C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82862050: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82862054: 4BFCD7AD  bl 0x8282f800
	ctx.lr = 0x82862058;
	sub_8282F800(ctx, base);
	// 82862058: 4BFFFF8C  b 0x82861fe4
	pc = 0x82861FE4; continue 'dispatch;
	// 8286205C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82862060: 419A0034  beq cr6, 0x82862094
	if ctx.cr[6].eq {
	pc = 0x82862094; continue 'dispatch;
	}
	// 82862064: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82862068: 48947921  bl 0x831a9988
	ctx.lr = 0x8286206C;
	sub_831A9988(ctx, base);
	// 8286206C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82862070: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82862074: 386BDBD4  addi r3, r11, -0x242c
	ctx.r[3].s64 = ctx.r[11].s64 + -9260;
	// 82862078: 48946081  bl 0x831a80f8
	ctx.lr = 0x8286207C;
	sub_831A80F8(ctx, base);
	// 8286207C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82862080: 41820014  beq 0x82862094
	if ctx.cr[0].eq {
	pc = 0x82862094; continue 'dispatch;
	}
	// 82862084: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82862088: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8286208C: 4BFFD915  bl 0x8285f9a0
	ctx.lr = 0x82862090;
	sub_8285F9A0(ctx, base);
	// 82862090: 4BFFFF54  b 0x82861fe4
	pc = 0x82861FE4; continue 'dispatch;
	// 82862094: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82862098: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8286209C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828620A0: 4BFB7791  bl 0x82819830
	ctx.lr = 0x828620A4;
	sub_82819830(ctx, base);
	// 828620A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828620A8: 48946110  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828620B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828620B0 size=116
    let mut pc: u32 = 0x828620B0;
    'dispatch: loop {
        match pc {
            0x828620B0 => {
    //   block [0x828620B0..0x82862124)
	// 828620B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828620B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828620B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828620BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828620C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828620C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828620C8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828620CC: 4BF8D6B5  bl 0x827ef780
	ctx.lr = 0x828620D0;
	sub_827EF780(ctx, base);
	// 828620D0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828620D4: 41820038  beq 0x8286210c
	if ctx.cr[0].eq {
	pc = 0x8286210C; continue 'dispatch;
	}
	// 828620D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828620DC: 4BF88235  bl 0x827ea310
	ctx.lr = 0x828620E0;
	sub_827EA310(ctx, base);
	// 828620E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828620E4: 40820018  bne 0x828620fc
	if !ctx.cr[0].eq {
	pc = 0x828620FC; continue 'dispatch;
	}
	// 828620E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828620EC: 4BF8821D  bl 0x827ea308
	ctx.lr = 0x828620F0;
	sub_827EA308(ctx, base);
	// 828620F0: C01E0068  lfs f0, 0x68(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828620F4: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828620F8: 40980010  bge cr6, 0x82862108
	if !ctx.cr[6].lt {
	pc = 0x82862108; continue 'dispatch;
	}
	// 828620FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82862100: 997E0064  stb r11, 0x64(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u8 ) };
	// 82862104: 48000008  b 0x8286210c
	pc = 0x8286210C; continue 'dispatch;
	// 82862108: D03E0068  stfs f1, 0x68(r30)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8286210C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82862110: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82862114: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82862118: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8286211C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82862120: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82862128 size=80
    let mut pc: u32 = 0x82862128;
    'dispatch: loop {
        match pc {
            0x82862128 => {
    //   block [0x82862128..0x82862178)
	// 82862128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286212C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82862130: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82862134: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82862138: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286213C: 480009DD  bl 0x82862b18
	ctx.lr = 0x82862140;
	sub_82862B18(ctx, base);
	// 82862140: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82862144: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82862148: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8286214C: 394A01AC  addi r10, r10, 0x1ac
	ctx.r[10].s64 = ctx.r[10].s64 + 428;
	// 82862150: 993F0064  stb r9, 0x64(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[9].u8 ) };
	// 82862154: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82862158: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8286215C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82862160: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82862164: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82862168: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286216C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82862170: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82862174: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82862178 size=88
    let mut pc: u32 = 0x82862178;
    'dispatch: loop {
        match pc {
            0x82862178 => {
    //   block [0x82862178..0x828621D0)
	// 82862178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286217C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82862180: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82862184: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82862188: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286218C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82862190: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82862194: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82862198: 396B01AC  addi r11, r11, 0x1ac
	ctx.r[11].s64 = ctx.r[11].s64 + 428;
	// 8286219C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828621A0: 485FA3E9  bl 0x82e5c588
	ctx.lr = 0x828621A4;
	sub_82E5C588(ctx, base);
	// 828621A4: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828621A8: 4182000C  beq 0x828621b4
	if ctx.cr[0].eq {
	pc = 0x828621B4; continue 'dispatch;
	}
	// 828621AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828621B0: 48590229  bl 0x82df23d8
	ctx.lr = 0x828621B4;
	sub_82DF23D8(ctx, base);
	// 828621B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828621B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828621BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828621C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828621C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828621C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828621CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828621D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828621D0 size=132
    let mut pc: u32 = 0x828621D0;
    'dispatch: loop {
        match pc {
            0x828621D0 => {
    //   block [0x828621D0..0x82862254)
	// 828621D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828621D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828621D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828621DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828621E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828621E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828621E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828621EC: 4BF8C5A5  bl 0x827ee790
	ctx.lr = 0x828621F0;
	sub_827EE790(ctx, base);
	// 828621F0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828621F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828621F8: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828621FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82862200: 4E800421  bctrl
	ctx.lr = 0x82862204;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82862204: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82862208: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286220C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82862210: 419A000C  beq cr6, 0x8286221c
	if ctx.cr[6].eq {
	pc = 0x8286221C; continue 'dispatch;
	}
	// 82862214: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82862218: 4BA5E679  bl 0x822c0890
	ctx.lr = 0x8286221C;
	sub_822C0890(ctx, base);
	// 8286221C: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82862220: 4182000C  beq 0x8286222c
	if ctx.cr[0].eq {
	pc = 0x8286222C; continue 'dispatch;
	}
	// 82862224: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82862228: 48000014  b 0x8286223c
	pc = 0x8286223C; continue 'dispatch;
	// 8286222C: 897E0064  lbz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 82862230: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82862234: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82862238: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 8286223C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82862240: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82862244: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82862248: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8286224C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82862250: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82862258 size=292
    let mut pc: u32 = 0x82862258;
    'dispatch: loop {
        match pc {
            0x82862258 => {
    //   block [0x82862258..0x8286237C)
	// 82862258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286225C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82862260: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82862264: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82862268: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286226C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82862270: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82862274: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82862278: 388B9B24  addi r4, r11, -0x64dc
	ctx.r[4].s64 = ctx.r[11].s64 + -25820;
	// 8286227C: 4BFD431D  bl 0x82836598
	ctx.lr = 0x82862280;
	sub_82836598(ctx, base);
	// 82862280: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862284: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82862288: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286228C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82862290: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82862294: 419A0024  beq cr6, 0x828622b8
	if ctx.cr[6].eq {
	pc = 0x828622B8; continue 'dispatch;
	}
	// 82862298: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8286229C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828622A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828622A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828622A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828622AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828622B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828622B4: 4082FFE8  bne 0x8286229c
	if !ctx.cr[0].eq {
	pc = 0x8286229C; continue 'dispatch;
	}
	// 828622B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828622BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828622C0: 4BF8BF69  bl 0x827ee228
	ctx.lr = 0x828622C4;
	sub_827EE228(ctx, base);
	// 828622C4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828622C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828622CC: 419A0008  beq cr6, 0x828622d4
	if ctx.cr[6].eq {
	pc = 0x828622D4; continue 'dispatch;
	}
	// 828622D0: 4BA5E5C1  bl 0x822c0890
	ctx.lr = 0x828622D4;
	sub_822C0890(ctx, base);
	// 828622D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828622D8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828622DC: 4BF8C4B5  bl 0x827ee790
	ctx.lr = 0x828622E0;
	sub_827EE790(ctx, base);
	// 828622E0: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828622E4: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828622E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828622EC: 419A000C  beq cr6, 0x828622f8
	if ctx.cr[6].eq {
	pc = 0x828622F8; continue 'dispatch;
	}
	// 828622F0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828622F4: 4BA5E59D  bl 0x822c0890
	ctx.lr = 0x828622F8;
	sub_822C0890(ctx, base);
	// 828622F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828622FC: 419A0068  beq cr6, 0x82862364
	if ctx.cr[6].eq {
	pc = 0x82862364; continue 'dispatch;
	}
	// 82862300: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82862304: 4BF8B52D  bl 0x827ed830
	ctx.lr = 0x82862308;
	sub_827ED830(ctx, base);
	// 82862308: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8286230C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82862310: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82862314: 4BF8C6D5  bl 0x827ee9e8
	ctx.lr = 0x82862318;
	sub_827EE9E8(ctx, base);
	// 82862318: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8286231C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82862320: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82862324: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82862328: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 8286232C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82862330: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82862334: 486091CD  bl 0x82e6b500
	ctx.lr = 0x82862338;
	sub_82E6B500(ctx, base);
	// 82862338: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286233C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82862340: 4BF90B19  bl 0x827f2e58
	ctx.lr = 0x82862344;
	sub_827F2E58(ctx, base);
	// 82862344: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862348: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8286234C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82862350: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82862354: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82862358: 4E800421  bctrl
	ctx.lr = 0x8286235C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286235C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82862360: 4BC07CA1  bl 0x8246a000
	ctx.lr = 0x82862364;
	sub_8246A000(ctx, base);
	// 82862364: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82862368: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286236C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82862370: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82862374: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82862378: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82862380 size=68
    let mut pc: u32 = 0x82862380;
    'dispatch: loop {
        match pc {
            0x82862380 => {
    //   block [0x82862380..0x828623C4)
	// 82862380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82862384: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82862388: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8286238C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82862390: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82862394: 48000785  bl 0x82862b18
	ctx.lr = 0x82862398;
	sub_82862B18(ctx, base);
	// 82862398: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8286239C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828623A0: 396B01EC  addi r11, r11, 0x1ec
	ctx.r[11].s64 = ctx.r[11].s64 + 492;
	// 828623A4: 915F0064  stw r10, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828623A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828623AC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828623B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828623B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828623B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828623BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828623C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828623C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828623C8 size=88
    let mut pc: u32 = 0x828623C8;
    'dispatch: loop {
        match pc {
            0x828623C8 => {
    //   block [0x828623C8..0x82862420)
	// 828623C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828623CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828623D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828623D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828623D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828623DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828623E0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828623E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828623E8: 396B01EC  addi r11, r11, 0x1ec
	ctx.r[11].s64 = ctx.r[11].s64 + 492;
	// 828623EC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828623F0: 485FA199  bl 0x82e5c588
	ctx.lr = 0x828623F4;
	sub_82E5C588(ctx, base);
	// 828623F4: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828623F8: 4182000C  beq 0x82862404
	if ctx.cr[0].eq {
	pc = 0x82862404; continue 'dispatch;
	}
	// 828623FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82862400: 4858FFD9  bl 0x82df23d8
	ctx.lr = 0x82862404;
	sub_82DF23D8(ctx, base);
	// 82862404: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82862408: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286240C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82862410: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82862414: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82862418: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286241C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82862420 size=128
    let mut pc: u32 = 0x82862420;
    'dispatch: loop {
        match pc {
            0x82862420 => {
    //   block [0x82862420..0x828624A0)
	// 82862420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82862424: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82862428: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286242C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82862430: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82862434: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82862438: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286243C: 4BF8C355  bl 0x827ee790
	ctx.lr = 0x82862440;
	sub_827EE790(ctx, base);
	// 82862440: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862444: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862448: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8286244C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82862450: 4E800421  bctrl
	ctx.lr = 0x82862454;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82862454: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82862458: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286245C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82862460: 419A000C  beq cr6, 0x8286246c
	if ctx.cr[6].eq {
	pc = 0x8286246C; continue 'dispatch;
	}
	// 82862464: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82862468: 4BA5E429  bl 0x822c0890
	ctx.lr = 0x8286246C;
	sub_822C0890(ctx, base);
	// 8286246C: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82862470: 41820014  beq 0x82862484
	if ctx.cr[0].eq {
	pc = 0x82862484; continue 'dispatch;
	}
	// 82862474: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 82862478: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8286247C: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82862480: 48000008  b 0x82862488
	pc = 0x82862488; continue 'dispatch;
	// 82862484: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82862488: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286248C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82862490: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82862494: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82862498: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286249C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828624A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828624A0 size=196
    let mut pc: u32 = 0x828624A0;
    'dispatch: loop {
        match pc {
            0x828624A0 => {
    //   block [0x828624A0..0x82862564)
	// 828624A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828624A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828624A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828624AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828624B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828624B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828624B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828624BC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828624C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828624C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828624C8: 4BA5E471  bl 0x822c0938
	ctx.lr = 0x828624CC;
	sub_822C0938(ctx, base);
	// 828624CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828624D0: 41820028  beq 0x828624f8
	if ctx.cr[0].eq {
	pc = 0x828624F8; continue 'dispatch;
	}
	// 828624D4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828624D8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828624DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828624E0: 392B022C  addi r9, r11, 0x22c
	ctx.r[9].s64 = ctx.r[11].s64 + 556;
	// 828624E4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828624E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828624EC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828624F0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828624F4: 48000008  b 0x828624fc
	pc = 0x828624FC; continue 'dispatch;
	// 828624F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828624FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82862500: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82862504: 409A0044  bne cr6, 0x82862548
	if !ctx.cr[6].eq {
	pc = 0x82862548; continue 'dispatch;
	}
	// 82862508: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8286250C: 419A001C  beq cr6, 0x82862528
	if ctx.cr[6].eq {
	pc = 0x82862528; continue 'dispatch;
	}
	// 82862510: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862514: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82862518: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286251C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862520: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82862524: 4E800421  bctrl
	ctx.lr = 0x82862528;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82862528: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8286252C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82862530: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82862534: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82862538: 816B4EA0  lwz r11, 0x4ea0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20128 as u32) ) } as u64;
	// 8286253C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82862540: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82862544: 4BA5DABD  bl 0x822c0000
	ctx.lr = 0x82862548;
	sub_822C0000(ctx, base);
	// 82862548: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8286254C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82862550: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82862554: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82862558: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8286255C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82862560: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82862568 size=196
    let mut pc: u32 = 0x82862568;
    'dispatch: loop {
        match pc {
            0x82862568 => {
    //   block [0x82862568..0x8286262C)
	// 82862568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286256C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82862570: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82862574: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82862578: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286257C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82862580: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82862584: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82862588: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8286258C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82862590: 4BA5E3A9  bl 0x822c0938
	ctx.lr = 0x82862594;
	sub_822C0938(ctx, base);
	// 82862594: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82862598: 41820028  beq 0x828625c0
	if ctx.cr[0].eq {
	pc = 0x828625C0; continue 'dispatch;
	}
	// 8286259C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828625A0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828625A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828625A8: 392B0240  addi r9, r11, 0x240
	ctx.r[9].s64 = ctx.r[11].s64 + 576;
	// 828625AC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828625B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828625B4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828625B8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828625BC: 48000008  b 0x828625c4
	pc = 0x828625C4; continue 'dispatch;
	// 828625C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828625C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828625C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828625CC: 409A0044  bne cr6, 0x82862610
	if !ctx.cr[6].eq {
	pc = 0x82862610; continue 'dispatch;
	}
	// 828625D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828625D4: 419A001C  beq cr6, 0x828625f0
	if ctx.cr[6].eq {
	pc = 0x828625F0; continue 'dispatch;
	}
	// 828625D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828625DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828625E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828625E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828625E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828625EC: 4E800421  bctrl
	ctx.lr = 0x828625F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828625F0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828625F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828625F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828625FC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82862600: 816B4EA0  lwz r11, 0x4ea0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20128 as u32) ) } as u64;
	// 82862604: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82862608: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8286260C: 4BA5D9F5  bl 0x822c0000
	ctx.lr = 0x82862610;
	sub_822C0000(ctx, base);
	// 82862610: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82862614: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82862618: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286261C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82862620: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82862624: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82862628: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82862630 size=120
    let mut pc: u32 = 0x82862630;
    'dispatch: loop {
        match pc {
            0x82862630 => {
    //   block [0x82862630..0x828626A8)
	// 82862630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82862634: 48945B39  bl 0x831a816c
	ctx.lr = 0x82862638;
	sub_831A8130(ctx, base);
	// 82862638: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286263C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82862640: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82862644: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82862648: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8286264C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82862650: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82862654: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 82862658: 4858FD91  bl 0x82df23e8
	ctx.lr = 0x8286265C;
	sub_82DF23E8(ctx, base);
	// 8286265C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82862660: 41820014  beq 0x82862674
	if ctx.cr[0].eq {
	pc = 0x82862674; continue 'dispatch;
	}
	// 82862664: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862668: 480B38E1  bl 0x82915f48
	ctx.lr = 0x8286266C;
	sub_82915F48(ctx, base);
	// 8286266C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82862670: 48000008  b 0x82862678
	pc = 0x82862678; continue 'dispatch;
	// 82862674: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82862678: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8286267C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82862680: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82862684: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82862688: 4BFFFE19  bl 0x828624a0
	ctx.lr = 0x8286268C;
	sub_828624A0(ctx, base);
	// 8286268C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82862690: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82862694: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82862698: 4BA5D969  bl 0x822c0000
	ctx.lr = 0x8286269C;
	sub_822C0000(ctx, base);
	// 8286269C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828626A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828626A4: 48945B18  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828626A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828626A8 size=112
    let mut pc: u32 = 0x828626A8;
    'dispatch: loop {
        match pc {
            0x828626A8 => {
    //   block [0x828626A8..0x82862718)
	// 828626A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828626AC: 48945AC1  bl 0x831a816c
	ctx.lr = 0x828626B0;
	sub_831A8130(ctx, base);
	// 828626B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828626B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828626B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828626BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828626C0: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 828626C4: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 828626C8: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 828626CC: 4858FD1D  bl 0x82df23e8
	ctx.lr = 0x828626D0;
	sub_82DF23E8(ctx, base);
	// 828626D0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828626D4: 41820010  beq 0x828626e4
	if ctx.cr[0].eq {
	pc = 0x828626E4; continue 'dispatch;
	}
	// 828626D8: 480B30D1  bl 0x829157a8
	ctx.lr = 0x828626DC;
	sub_829157A8(ctx, base);
	// 828626DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828626E0: 48000008  b 0x828626e8
	pc = 0x828626E8; continue 'dispatch;
	// 828626E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828626E8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828626EC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828626F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828626F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828626F8: 4BFFFE71  bl 0x82862568
	ctx.lr = 0x828626FC;
	sub_82862568(ctx, base);
	// 828626FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82862700: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82862704: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82862708: 4BA5D8F9  bl 0x822c0000
	ctx.lr = 0x8286270C;
	sub_822C0000(ctx, base);
	// 8286270C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82862710: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82862714: 48945AA8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82862718 size=292
    let mut pc: u32 = 0x82862718;
    'dispatch: loop {
        match pc {
            0x82862718 => {
    //   block [0x82862718..0x8286283C)
	// 82862718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286271C: 48945A4D  bl 0x831a8168
	ctx.lr = 0x82862720;
	sub_831A8130(ctx, base);
	// 82862720: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82862724: 90A100A4  stw r5, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[5].u32 ) };
	// 82862728: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286272C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82862730: 388100A4  addi r4, r1, 0xa4
	ctx.r[4].s64 = ctx.r[1].s64 + 164;
	// 82862734: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82862738: 4BFFFEF9  bl 0x82862630
	ctx.lr = 0x8286273C;
	sub_82862630(ctx, base);
	// 8286273C: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82862740: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82862744: 419A00A8  beq cr6, 0x828627ec
	if ctx.cr[6].eq {
	pc = 0x828627EC; continue 'dispatch;
	}
	// 82862748: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8286274C: 4BFB7C55  bl 0x8281a3a0
	ctx.lr = 0x82862750;
	sub_8281A3A0(ctx, base);
	// 82862750: 7C661B79  or. r6, r3, r3
	ctx.r[6].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82862754: 41820098  beq 0x828627ec
	if ctx.cr[0].eq {
	pc = 0x828627EC; continue 'dispatch;
	}
	// 82862758: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8286275C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82862760: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82862764: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82862768: 419A0024  beq cr6, 0x8286278c
	if ctx.cr[6].eq {
	pc = 0x8286278C; continue 'dispatch;
	}
	// 8286276C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82862770: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82862774: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82862778: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8286277C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82862780: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82862784: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82862788: 4082FFE8  bne 0x82862770
	if !ctx.cr[0].eq {
	pc = 0x82862770; continue 'dispatch;
	}
	// 8286278C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82862790: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82862794: 388B0250  addi r4, r11, 0x250
	ctx.r[4].s64 = ctx.r[11].s64 + 592;
	// 82862798: 38A0003F  li r5, 0x3f
	ctx.r[5].s64 = 63;
	// 8286279C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828627A0: 4BF8D489  bl 0x827efc28
	ctx.lr = 0x828627A4;
	sub_827EFC28(ctx, base);
	// 828627A4: 397E0020  addi r11, r30, 0x20
	ctx.r[11].s64 = ctx.r[30].s64 + 32;
	// 828627A8: 815E0030  lwz r10, 0x30(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 828627AC: C01E0040  lfs f0, 0x40(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828627B0: 813E0038  lwz r9, 0x38(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 828627B4: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 828627B8: 811E003C  lwz r8, 0x3c(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 828627BC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828627C0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82862840 size=308
    let mut pc: u32 = 0x82862840;
    'dispatch: loop {
        match pc {
            0x82862840 => {
    //   block [0x82862840..0x82862974)
	// 82862840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82862844: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82862848: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8286284C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82862850: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82862854: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 82862858: 392B6910  addi r9, r11, 0x6910
	ctx.r[9].s64 = ctx.r[11].s64 + 26896;
	// 8286285C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82862860: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82862864: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 82862868: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8286286C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82862870: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82862874: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82862978 size=288
    let mut pc: u32 = 0x82862978;
    'dispatch: loop {
        match pc {
            0x82862978 => {
    //   block [0x82862978..0x82862A98)
	// 82862978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286297C: 489457E9  bl 0x831a8164
	ctx.lr = 0x82862980;
	sub_831A8130(ctx, base);
	// 82862980: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82862984: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82862988: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286298C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82862990: 4BFFFD19  bl 0x828626a8
	ctx.lr = 0x82862994;
	sub_828626A8(ctx, base);
	// 82862994: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82862998: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8286299C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828629A0: 419A0070  beq cr6, 0x82862a10
	if ctx.cr[6].eq {
	pc = 0x82862A10; continue 'dispatch;
	}
	// 828629A4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828629A8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828629AC: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828629B0: 419A0024  beq cr6, 0x828629d4
	if ctx.cr[6].eq {
	pc = 0x828629D4; continue 'dispatch;
	}
	// 828629B4: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828629B8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828629BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828629C0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828629C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828629C8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828629CC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828629D0: 4082FFE8  bne 0x828629b8
	if !ctx.cr[0].eq {
	pc = 0x828629B8; continue 'dispatch;
	}
	// 828629D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828629D8: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 828629DC: 4BF8AE45  bl 0x827ed820
	ctx.lr = 0x828629E0;
	sub_827ED820(ctx, base);
	// 828629E0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828629E4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828629E8: 388B0250  addi r4, r11, 0x250
	ctx.r[4].s64 = ctx.r[11].s64 + 592;
	// 828629EC: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828629F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828629F4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828629F8: 4BF8D231  bl 0x827efc28
	ctx.lr = 0x828629FC;
	sub_827EFC28(ctx, base);
	// 828629FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82862A00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82862A04: 80BF0018  lwz r5, 0x18(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82862A08: 4BFFFE39  bl 0x82862840
	ctx.lr = 0x82862A0C;
	sub_82862840(ctx, base);
	// 82862A0C: 907D0064  stw r3, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 82862A10: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82862A14: 419A000C  beq cr6, 0x82862a20
	if ctx.cr[6].eq {
	pc = 0x82862A20; continue 'dispatch;
	}
	// 82862A18: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82862A1C: 4BA5DE75  bl 0x822c0890
	ctx.lr = 0x82862A20;
	sub_822C0890(ctx, base);
	// 82862A20: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 82862A24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82862A28: 419A0068  beq cr6, 0x82862a90
	if ctx.cr[6].eq {
	pc = 0x82862A90; continue 'dispatch;
	}
	// 82862A2C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82862A30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82862A34: 388B9B24  addi r4, r11, -0x64dc
	ctx.r[4].s64 = ctx.r[11].s64 + -25820;
	// 82862A38: 4BFD3B61  bl 0x82836598
	ctx.lr = 0x82862A3C;
	sub_82836598(ctx, base);
	// 82862A3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862A40: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82862A44: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82862A48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82862A4C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82862A50: 419A0024  beq cr6, 0x82862a74
	if ctx.cr[6].eq {
	pc = 0x82862A74; continue 'dispatch;
	}
	// 82862A54: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82862A58: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82862A5C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82862A60: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82862A64: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82862A68: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82862A6C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82862A70: 4082FFE8  bne 0x82862a58
	if !ctx.cr[0].eq {
	pc = 0x82862A58; continue 'dispatch;
	}
	// 82862A74: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82862A78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82862A7C: 4BF8B7AD  bl 0x827ee228
	ctx.lr = 0x82862A80;
	sub_827EE228(ctx, base);
	// 82862A80: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82862A84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82862A88: 419A0008  beq cr6, 0x82862a90
	if ctx.cr[6].eq {
	pc = 0x82862A90; continue 'dispatch;
	}
	// 82862A8C: 4BA5DE05  bl 0x822c0890
	ctx.lr = 0x82862A90;
	sub_822C0890(ctx, base);
	// 82862A90: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82862A94: 48945720  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82862A98 size=116
    let mut pc: u32 = 0x82862A98;
    'dispatch: loop {
        match pc {
            0x82862A98 => {
    //   block [0x82862A98..0x82862B0C)
	// 82862A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82862A9C: 489456D1  bl 0x831a816c
	ctx.lr = 0x82862AA0;
	sub_831A8130(ctx, base);
	// 82862AA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82862AA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82862AA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82862AAC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82862AB0: 4BF8BCE1  bl 0x827ee790
	ctx.lr = 0x82862AB4;
	sub_827EE790(ctx, base);
	// 82862AB4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862AB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862ABC: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82862AC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82862AC4: 4E800421  bctrl
	ctx.lr = 0x82862AC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82862AC8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82862ACC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82862AD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82862AD4: 419A000C  beq cr6, 0x82862ae0
	if ctx.cr[6].eq {
	pc = 0x82862AE0; continue 'dispatch;
	}
	// 82862AD8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82862ADC: 4BA5DDB5  bl 0x822c0890
	ctx.lr = 0x82862AE0;
	sub_822C0890(ctx, base);
	// 82862AE0: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82862AE4: 41820020  beq 0x82862b04
	if ctx.cr[0].eq {
	pc = 0x82862B04; continue 'dispatch;
	}
	// 82862AE8: 80BF0064  lwz r5, 0x64(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82862AEC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82862AF0: 419A0014  beq cr6, 0x82862b04
	if ctx.cr[6].eq {
	pc = 0x82862B04; continue 'dispatch;
	}
	// 82862AF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82862AF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82862AFC: 4BFFFD45  bl 0x82862840
	ctx.lr = 0x82862B00;
	sub_82862840(ctx, base);
	// 82862B00: 907F0064  stw r3, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 82862B04: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82862B08: 489456B4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82862B10 size=8
    let mut pc: u32 = 0x82862B10;
    'dispatch: loop {
        match pc {
            0x82862B10 => {
    //   block [0x82862B10..0x82862B18)
	// 82862B10: C0230060  lfs f1, 0x60(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82862B14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82862B18 size=72
    let mut pc: u32 = 0x82862B18;
    'dispatch: loop {
        match pc {
            0x82862B18 => {
    //   block [0x82862B18..0x82862B60)
	// 82862B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82862B1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82862B20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82862B24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82862B28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82862B2C: 485F9DFD  bl 0x82e5c928
	ctx.lr = 0x82862B30;
	sub_82E5C928(ctx, base);
	// 82862B30: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82862B34: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82862B38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82862B3C: 394A02AC  addi r10, r10, 0x2ac
	ctx.r[10].s64 = ctx.r[10].s64 + 684;
	// 82862B40: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82862B44: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82862B48: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82862B4C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82862B50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82862B54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82862B58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82862B5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82862B60 size=60
    let mut pc: u32 = 0x82862B60;
    'dispatch: loop {
        match pc {
            0x82862B60 => {
    //   block [0x82862B60..0x82862B9C)
	// 82862B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82862B64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82862B68: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82862B6C: 488F1A95  bl 0x83154600
	ctx.lr = 0x82862B70;
	sub_83154600(ctx, base);
	// 82862B70: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82862B74: 41820010  beq 0x82862b84
	if ctx.cr[0].eq {
	pc = 0x82862B84; continue 'dispatch;
	}
	// 82862B78: 4BF8B199  bl 0x827edd10
	ctx.lr = 0x82862B7C;
	sub_827EDD10(ctx, base);
	// 82862B7C: C0230000  lfs f1, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82862B80: 4800000C  b 0x82862b8c
	pc = 0x82862B8C; continue 'dispatch;
	// 82862B84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82862B88: C02B08A8  lfs f1, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82862B8C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82862B90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82862B94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82862B98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82862BA0 size=144
    let mut pc: u32 = 0x82862BA0;
    'dispatch: loop {
        match pc {
            0x82862BA0 => {
    //   block [0x82862BA0..0x82862C30)
	// 82862BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82862BA4: 489455C9  bl 0x831a816c
	ctx.lr = 0x82862BA8;
	sub_831A8130(ctx, base);
	// 82862BA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82862BAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82862BB0: 488F1A51  bl 0x83154600
	ctx.lr = 0x82862BB4;
	sub_83154600(ctx, base);
	// 82862BB4: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82862BB8: 4182005C  beq 0x82862c14
	if ctx.cr[0].eq {
	pc = 0x82862C14; continue 'dispatch;
	}
	// 82862BBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82862BC0: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862BC4: 485F6BB5  bl 0x82e59778
	ctx.lr = 0x82862BC8;
	sub_82E59778(ctx, base);
	// 82862BC8: 817D0028  lwz r11, 0x28(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 82862BCC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82862BD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82862BD4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82862BD8: 4E800421  bctrl
	ctx.lr = 0x82862BDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82862BDC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862BE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82862BE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82862BE8: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82862BEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82862BF0: 4E800421  bctrl
	ctx.lr = 0x82862BF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82862BF4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82862BF8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82862BFC: 409A0018  bne cr6, 0x82862c14
	if !ctx.cr[6].eq {
	pc = 0x82862C14; continue 'dispatch;
	}
	// 82862C00: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82862C04: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82862C08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82862C0C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82862C10: 485F9E29  bl 0x82e5ca38
	ctx.lr = 0x82862C14;
	sub_82E5CA38(ctx, base);
	// 82862C14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82862C18: 485F6B61  bl 0x82e59778
	ctx.lr = 0x82862C1C;
	sub_82E59778(ctx, base);
	// 82862C1C: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82862C20: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82862C24: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82862C28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82862C2C: 48945590  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82862C30 size=136
    let mut pc: u32 = 0x82862C30;
    'dispatch: loop {
        match pc {
            0x82862C30 => {
    //   block [0x82862C30..0x82862CB8)
	// 82862C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82862C34: 48945539  bl 0x831a816c
	ctx.lr = 0x82862C38;
	sub_831A8130(ctx, base);
	// 82862C38: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82862C3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82862C40: 488F19C1  bl 0x83154600
	ctx.lr = 0x82862C44;
	sub_83154600(ctx, base);
	// 82862C44: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82862C48: 4182005C  beq 0x82862ca4
	if ctx.cr[0].eq {
	pc = 0x82862CA4; continue 'dispatch;
	}
	// 82862C4C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82862C50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82862C54: 4BF8BB3D  bl 0x827ee790
	ctx.lr = 0x82862C58;
	sub_827EE790(ctx, base);
	// 82862C58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862C5C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82862C60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82862C64: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82862C68: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862C6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82862C70: 4E800421  bctrl
	ctx.lr = 0x82862C74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82862C74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82862C78: 4BF77371  bl 0x827d9fe8
	ctx.lr = 0x82862C7C;
	sub_827D9FE8(ctx, base);
	// 82862C7C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82862C80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82862C84: 419A0008  beq cr6, 0x82862c8c
	if ctx.cr[6].eq {
	pc = 0x82862C8C; continue 'dispatch;
	}
	// 82862C88: 4BA5DC09  bl 0x822c0890
	ctx.lr = 0x82862C8C;
	sub_822C0890(ctx, base);
	// 82862C8C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862C90: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82862C94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82862C98: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82862C9C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82862CA0: 4E800421  bctrl
	ctx.lr = 0x82862CA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82862CA4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82862CA8: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82862CAC: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82862CB0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82862CB4: 48945508  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862CB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82862CB8 size=236
    let mut pc: u32 = 0x82862CB8;
    'dispatch: loop {
        match pc {
            0x82862CB8 => {
    //   block [0x82862CB8..0x82862DA4)
	// 82862CB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82862CBC: 489454B1  bl 0x831a816c
	ctx.lr = 0x82862CC0;
	sub_831A8130(ctx, base);
	// 82862CC0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82862CC4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82862CC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82862CCC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82862CD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82862CD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82862CD8: 4BF8CAA9  bl 0x827ef780
	ctx.lr = 0x82862CDC;
	sub_827EF780(ctx, base);
	// 82862CDC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82862CE0: 418200B4  beq 0x82862d94
	if ctx.cr[0].eq {
	pc = 0x82862D94; continue 'dispatch;
	}
	// 82862CE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82862CE8: 4BF87621  bl 0x827ea308
	ctx.lr = 0x82862CEC;
	sub_827EA308(ctx, base);
	// 82862CEC: C01F006C  lfs f0, 0x6c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82862CF0: C1BF0070  lfs f13, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82862CF4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82862CF8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82862CFC: 41990024  bgt cr6, 0x82862d20
	if ctx.cr[6].gt {
	pc = 0x82862D20; continue 'dispatch;
	}
	// 82862D00: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82862D04: 4098001C  bge cr6, 0x82862d20
	if !ctx.cr[6].lt {
	pc = 0x82862D20; continue 'dispatch;
	}
	// 82862D08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862D0C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82862D10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82862D14: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82862D18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82862D1C: 4E800421  bctrl
	ctx.lr = 0x82862D20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82862D20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82862D24: 4BF875F5  bl 0x827ea318
	ctx.lr = 0x82862D28;
	sub_827EA318(ctx, base);
	// 82862D28: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82862D2C: 546A063F  clrlwi. r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82862D30: C3CB08A4  lfs f30, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82862D34: 4082002C  bne 0x82862d60
	if !ctx.cr[0].eq {
	pc = 0x82862D60; continue 'dispatch;
	}
	// 82862D38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82862D3C: 4BF875D5  bl 0x827ea310
	ctx.lr = 0x82862D40;
	sub_827EA310(ctx, base);
	// 82862D40: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82862D44: 4182001C  beq 0x82862d60
	if ctx.cr[0].eq {
	pc = 0x82862D60; continue 'dispatch;
	}
	// 82862D48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82862D4C: 4BF8755D  bl 0x827ea2a8
	ctx.lr = 0x82862D50;
	sub_827EA2A8(ctx, base);
	// 82862D50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82862D54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82862D58: 4BF87789  bl 0x827ea4e0
	ctx.lr = 0x82862D5C;
	sub_827EA4E0(ctx, base);
	// 82862D5C: FFE0F090  fmr f31, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[30].f64;
	// 82862D60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82862D64: 4BF8760D  bl 0x827ea370
	ctx.lr = 0x82862D68;
	sub_827EA370(ctx, base);
	// 82862D68: C01F0070  lfs f0, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82862D6C: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82862D70: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82862D74: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82862D78: 40980018  bge cr6, 0x82862d90
	if !ctx.cr[6].lt {
	pc = 0x82862D90; continue 'dispatch;
	}
	// 82862D7C: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82862D80: D3DF0070  stfs f30, 0x70(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82862D84: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82862D88: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82862D8C: 48000008  b 0x82862d94
	pc = 0x82862D94; continue 'dispatch;
	// 82862D90: D3FF0070  stfs f31, 0x70(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82862D94: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82862D98: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82862D9C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82862DA0: 4894541C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862DA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82862DA8 size=56
    let mut pc: u32 = 0x82862DA8;
    'dispatch: loop {
        match pc {
            0x82862DA8 => {
    //   block [0x82862DA8..0x82862DE0)
	// 82862DA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82862DAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82862DB0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82862DB4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82862DB8: 4BF8C9C9  bl 0x827ef780
	ctx.lr = 0x82862DBC;
	sub_827EF780(ctx, base);
	// 82862DBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82862DC0: 41820010  beq 0x82862dd0
	if ctx.cr[0].eq {
	pc = 0x82862DD0; continue 'dispatch;
	}
	// 82862DC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82862DC8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82862DCC: 4BF874E5  bl 0x827ea2b0
	ctx.lr = 0x82862DD0;
	sub_827EA2B0(ctx, base);
	// 82862DD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82862DD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82862DD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82862DDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82862DE0 size=16
    let mut pc: u32 = 0x82862DE0;
    'dispatch: loop {
        match pc {
            0x82862DE0 => {
    //   block [0x82862DE0..0x82862DF0)
	// 82862DE0: 81630068  lwz r11, 0x68(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) } as u64;
	// 82862DE4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82862DE8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82862DEC: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82862DF0 size=8
    let mut pc: u32 = 0x82862DF0;
    'dispatch: loop {
        match pc {
            0x82862DF0 => {
    //   block [0x82862DF0..0x82862DF8)
	// 82862DF0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82862DF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82862DF8 size=116
    let mut pc: u32 = 0x82862DF8;
    'dispatch: loop {
        match pc {
            0x82862DF8 => {
    //   block [0x82862DF8..0x82862E6C)
	// 82862DF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82862DFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82862E00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82862E04: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82862E08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82862E0C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82862E10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82862E14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82862E18: C01F0070  lfs f0, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82862E1C: EDA0F828  fsubs f13, f0, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82862E20: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82862E24: D1BF0070  stfs f13, 0x70(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82862E28: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82862E2C: 4199001C  bgt cr6, 0x82862e48
	if ctx.cr[6].gt {
	pc = 0x82862E48; continue 'dispatch;
	}
	// 82862E30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82862E34: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82862E38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82862E3C: 4E800421  bctrl
	ctx.lr = 0x82862E40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82862E40: C01F0068  lfs f0, 0x68(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82862E44: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82862E48: C01F006C  lfs f0, 0x6c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82862E4C: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82862E50: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82862E54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82862E58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82862E5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82862E60: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82862E64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82862E68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82862E70 size=24
    let mut pc: u32 = 0x82862E70;
    'dispatch: loop {
        match pc {
            0x82862E70 => {
    //   block [0x82862E70..0x82862E88)
	// 82862E70: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82862E74: C1A3006C  lfs f13, 0x6c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82862E78: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82862E7C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82862E80: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82862E84: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82862E88 size=8
    let mut pc: u32 = 0x82862E88;
    'dispatch: loop {
        match pc {
            0x82862E88 => {
    //   block [0x82862E88..0x82862E90)
	// 82862E88: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82862E8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82862E90 size=68
    let mut pc: u32 = 0x82862E90;
    'dispatch: loop {
        match pc {
            0x82862E90 => {
    //   block [0x82862E90..0x82862ED4)
	// 82862E90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82862E94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82862E98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82862E9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82862EA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82862EA4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82862EA8: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 82862EAC: 396B02EC  addi r11, r11, 0x2ec
	ctx.r[11].s64 = ctx.r[11].s64 + 748;
	// 82862EB0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82862EB4: 48590575  bl 0x82df3428
	ctx.lr = 0x82862EB8;
	sub_82DF3428(ctx, base);
	// 82862EB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82862EBC: 485F96CD  bl 0x82e5c588
	ctx.lr = 0x82862EC0;
	sub_82E5C588(ctx, base);
	// 82862EC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82862EC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82862EC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82862ECC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82862ED0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82862ED8 size=128
    let mut pc: u32 = 0x82862ED8;
    'dispatch: loop {
        match pc {
            0x82862ED8 => {
    //   block [0x82862ED8..0x82862F58)
	// 82862ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82862EDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82862EE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82862EE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82862EE8: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82862EEC: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82862EF0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82862EF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82862EF8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82862EFC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82862F00: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82862F04: 4BFFFC15  bl 0x82862b18
	ctx.lr = 0x82862F08;
	sub_82862B18(ctx, base);
	// 82862F08: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82862F0C: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 82862F10: 396B0334  addi r11, r11, 0x334
	ctx.r[11].s64 = ctx.r[11].s64 + 820;
	// 82862F14: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82862F18: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82862F1C: 48590AED  bl 0x82df3a08
	ctx.lr = 0x82862F20;
	sub_82DF3A08(ctx, base);
	// 82862F20: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82862F24: D3DF0068  stfs f30, 0x68(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82862F28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82862F2C: D3FF006C  stfs f31, 0x6c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82862F30: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82862F34: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82862F38: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82862F3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82862F40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82862F44: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82862F48: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82862F4C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82862F50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82862F54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82862F58 size=68
    let mut pc: u32 = 0x82862F58;
    'dispatch: loop {
        match pc {
            0x82862F58 => {
    //   block [0x82862F58..0x82862F9C)
	// 82862F58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82862F5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82862F60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82862F64: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82862F68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82862F6C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82862F70: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 82862F74: 396B0334  addi r11, r11, 0x334
	ctx.r[11].s64 = ctx.r[11].s64 + 820;
	// 82862F78: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82862F7C: 485904AD  bl 0x82df3428
	ctx.lr = 0x82862F80;
	sub_82DF3428(ctx, base);
	// 82862F80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82862F84: 485F9605  bl 0x82e5c588
	ctx.lr = 0x82862F88;
	sub_82E5C588(ctx, base);
	// 82862F88: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82862F8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82862F90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82862F94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82862F98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82862FA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82862FA0 size=96
    let mut pc: u32 = 0x82862FA0;
    'dispatch: loop {
        match pc {
            0x82862FA0 => {
    //   block [0x82862FA0..0x82863000)
	// 82862FA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82862FA4: 489451C9  bl 0x831a816c
	ctx.lr = 0x82862FA8;
	sub_831A8130(ctx, base);
	// 82862FA8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82862FAC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82862FB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82862FB4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82862FB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82862FBC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82862FC0: 4BFFFB59  bl 0x82862b18
	ctx.lr = 0x82862FC4;
	sub_82862B18(ctx, base);
	// 82862FC4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82862FC8: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 82862FCC: 396B02EC  addi r11, r11, 0x2ec
	ctx.r[11].s64 = ctx.r[11].s64 + 748;
	// 82862FD0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82862FD4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82862FD8: 48590A31  bl 0x82df3a08
	ctx.lr = 0x82862FDC;
	sub_82DF3A08(ctx, base);
	// 82862FDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82862FE0: D3FF006C  stfs f31, 0x6c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82862FE4: 93BF0068  stw r29, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82862FE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82862FEC: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82862FF0: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82862FF4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82862FF8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82862FFC: 489451C0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863000 size=76
    let mut pc: u32 = 0x82863000;
    'dispatch: loop {
        match pc {
            0x82863000 => {
    //   block [0x82863000..0x8286304C)
	// 82863000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82863004: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863008: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286300C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863010: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863014: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82863018: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8286301C: 4BFFFE75  bl 0x82862e90
	ctx.lr = 0x82863020;
	sub_82862E90(ctx, base);
	// 82863020: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82863024: 4182000C  beq 0x82863030
	if ctx.cr[0].eq {
	pc = 0x82863030; continue 'dispatch;
	}
	// 82863028: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286302C: 4858F3AD  bl 0x82df23d8
	ctx.lr = 0x82863030;
	sub_82DF23D8(ctx, base);
	// 82863030: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863034: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82863038: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286303C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82863040: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82863044: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82863048: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863050 size=76
    let mut pc: u32 = 0x82863050;
    'dispatch: loop {
        match pc {
            0x82863050 => {
    //   block [0x82863050..0x8286309C)
	// 82863050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82863054: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863058: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286305C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863060: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863064: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82863068: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8286306C: 4BFFFEED  bl 0x82862f58
	ctx.lr = 0x82863070;
	sub_82862F58(ctx, base);
	// 82863070: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82863074: 4182000C  beq 0x82863080
	if ctx.cr[0].eq {
	pc = 0x82863080; continue 'dispatch;
	}
	// 82863078: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286307C: 4858F35D  bl 0x82df23d8
	ctx.lr = 0x82863080;
	sub_82DF23D8(ctx, base);
	// 82863080: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863084: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82863088: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286308C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82863090: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82863094: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82863098: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828630A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828630A0 size=120
    let mut pc: u32 = 0x828630A0;
    'dispatch: loop {
        match pc {
            0x828630A0 => {
    //   block [0x828630A0..0x82863118)
	// 828630A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828630A4: 489450C9  bl 0x831a816c
	ctx.lr = 0x828630A8;
	sub_831A8130(ctx, base);
	// 828630A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828630AC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828630B0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828630B4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828630B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828630BC: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 828630C0: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 828630C4: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828630C8: 4858F321  bl 0x82df23e8
	ctx.lr = 0x828630CC;
	sub_82DF23E8(ctx, base);
	// 828630CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828630D0: 41820014  beq 0x828630e4
	if ctx.cr[0].eq {
	pc = 0x828630E4; continue 'dispatch;
	}
	// 828630D4: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828630D8: 482EF949  bl 0x82b52a20
	ctx.lr = 0x828630DC;
	sub_82B52A20(ctx, base);
	// 828630DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828630E0: 48000008  b 0x828630e8
	pc = 0x828630E8; continue 'dispatch;
	// 828630E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828630E8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828630EC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828630F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828630F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828630F8: 4BFB4CB9  bl 0x82817db0
	ctx.lr = 0x828630FC;
	sub_82817DB0(ctx, base);
	// 828630FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82863100: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82863104: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82863108: 4BA5CEF9  bl 0x822c0000
	ctx.lr = 0x8286310C;
	sub_822C0000(ctx, base);
	// 8286310C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82863110: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82863114: 489450A8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863118 size=148
    let mut pc: u32 = 0x82863118;
    'dispatch: loop {
        match pc {
            0x82863118 => {
    //   block [0x82863118..0x828631AC)
	// 82863118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286311C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863120: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863124: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863128: 38630064  addi r3, r3, 0x64
	ctx.r[3].s64 = ctx.r[3].s64 + 100;
	// 8286312C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82863130: 48590081  bl 0x82df31b0
	ctx.lr = 0x82863134;
	sub_82DF31B0(ctx, base);
	// 82863134: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82863138: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286313C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82863140: 4BFFFF61  bl 0x828630a0
	ctx.lr = 0x82863144;
	sub_828630A0(ctx, base);
	// 82863144: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82863148: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8286314C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863150: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82863154: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82863158: 419A0024  beq cr6, 0x8286317c
	if ctx.cr[6].eq {
	pc = 0x8286317C; continue 'dispatch;
	}
	// 8286315C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82863160: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82863164: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82863168: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8286316C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82863170: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82863174: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82863178: 4082FFE8  bne 0x82863160
	if !ctx.cr[0].eq {
	pc = 0x82863160; continue 'dispatch;
	}
	// 8286317C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82863180: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863184: 4BF8B0A5  bl 0x827ee228
	ctx.lr = 0x82863188;
	sub_827EE228(ctx, base);
	// 82863188: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8286318C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82863190: 419A0008  beq cr6, 0x82863198
	if ctx.cr[6].eq {
	pc = 0x82863198; continue 'dispatch;
	}
	// 82863194: 4BA5D6FD  bl 0x822c0890
	ctx.lr = 0x82863198;
	sub_822C0890(ctx, base);
	// 82863198: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8286319C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828631A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828631A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828631A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828631B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828631B0 size=40
    let mut pc: u32 = 0x828631B0;
    'dispatch: loop {
        match pc {
            0x828631B0 => {
    //   block [0x828631B0..0x828631D8)
	// 828631B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828631B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828631B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828631BC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828631C0: 4BF8C5C1  bl 0x827ef780
	ctx.lr = 0x828631C4;
	sub_827EF780(ctx, base);
	// 828631C4: 4BF8714D  bl 0x827ea310
	ctx.lr = 0x828631C8;
	sub_827EA310(ctx, base);
	// 828631C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828631CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828631D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828631D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828631D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828631D8 size=16
    let mut pc: u32 = 0x828631D8;
    'dispatch: loop {
        match pc {
            0x828631D8 => {
    //   block [0x828631D8..0x828631E8)
	// 828631D8: C0030068  lfs f0, 0x68(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828631DC: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 828631E0: D0030068  stfs f0, 0x68(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828631E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828631E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828631E8 size=24
    let mut pc: u32 = 0x828631E8;
    'dispatch: loop {
        match pc {
            0x828631E8 => {
    //   block [0x828631E8..0x82863200)
	// 828631E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828631EC: C1A30068  lfs f13, 0x68(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828631F0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828631F4: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828631F8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828631FC: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82863200 size=8
    let mut pc: u32 = 0x82863200;
    'dispatch: loop {
        match pc {
            0x82863200 => {
    //   block [0x82863200..0x82863208)
	// 82863200: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82863204: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863208 size=124
    let mut pc: u32 = 0x82863208;
    'dispatch: loop {
        match pc {
            0x82863208 => {
    //   block [0x82863208..0x82863284)
	// 82863208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286320C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863210: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82863214: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863218: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286321C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82863220: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82863224: 4BFFF8F5  bl 0x82862b18
	ctx.lr = 0x82863228;
	sub_82862B18(ctx, base);
	// 82863228: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8286322C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82863230: 396BCFA4  addi r11, r11, -0x305c
	ctx.r[11].s64 = ctx.r[11].s64 + -12380;
	// 82863234: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 82863238: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8286323C: 485909C5  bl 0x82df3c00
	ctx.lr = 0x82863240;
	sub_82DF3C00(ctx, base);
	// 82863240: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82863244: 4858FF6D  bl 0x82df31b0
	ctx.lr = 0x82863248;
	sub_82DF31B0(ctx, base);
	// 82863248: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286324C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82863250: 485907B9  bl 0x82df3a08
	ctx.lr = 0x82863254;
	sub_82DF3A08(ctx, base);
	// 82863254: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863258: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286325C: 485F648D  bl 0x82e596e8
	ctx.lr = 0x82863260;
	sub_82E596E8(ctx, base);
	// 82863260: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82863264: 485901C5  bl 0x82df3428
	ctx.lr = 0x82863268;
	sub_82DF3428(ctx, base);
	// 82863268: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286326C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82863270: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82863274: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82863278: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8286327C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82863280: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82863288 size=140
    let mut pc: u32 = 0x82863288;
    'dispatch: loop {
        match pc {
            0x82863288 => {
    //   block [0x82863288..0x82863314)
	// 82863288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286328C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863290: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82863294: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863298: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8286329C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828632A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828632A4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828632A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828632AC: 4BFFF86D  bl 0x82862b18
	ctx.lr = 0x828632B0;
	sub_82862B18(ctx, base);
	// 828632B0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828632B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828632B8: 396B037C  addi r11, r11, 0x37c
	ctx.r[11].s64 = ctx.r[11].s64 + 892;
	// 828632BC: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 828632C0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828632C4: 4859093D  bl 0x82df3c00
	ctx.lr = 0x828632C8;
	sub_82DF3C00(ctx, base);
	// 828632C8: D3FF0068  stfs f31, 0x68(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828632CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828632D0: 4858FEE1  bl 0x82df31b0
	ctx.lr = 0x828632D4;
	sub_82DF31B0(ctx, base);
	// 828632D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828632D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828632DC: 4859072D  bl 0x82df3a08
	ctx.lr = 0x828632E0;
	sub_82DF3A08(ctx, base);
	// 828632E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828632E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828632E8: 485F6401  bl 0x82e596e8
	ctx.lr = 0x828632EC;
	sub_82E596E8(ctx, base);
	// 828632EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828632F0: 48590139  bl 0x82df3428
	ctx.lr = 0x828632F4;
	sub_82DF3428(ctx, base);
	// 828632F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828632F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828632FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82863300: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82863304: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82863308: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8286330C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82863310: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863318 size=100
    let mut pc: u32 = 0x82863318;
    'dispatch: loop {
        match pc {
            0x82863318 => {
    //   block [0x82863318..0x8286337C)
	// 82863318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286331C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863320: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82863324: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863328: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286332C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82863330: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82863334: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 82863338: 396B037C  addi r11, r11, 0x37c
	ctx.r[11].s64 = ctx.r[11].s64 + 892;
	// 8286333C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82863340: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82863344: 485900E5  bl 0x82df3428
	ctx.lr = 0x82863348;
	sub_82DF3428(ctx, base);
	// 82863348: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286334C: 485F923D  bl 0x82e5c588
	ctx.lr = 0x82863350;
	sub_82E5C588(ctx, base);
	// 82863350: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82863354: 4182000C  beq 0x82863360
	if ctx.cr[0].eq {
	pc = 0x82863360; continue 'dispatch;
	}
	// 82863358: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286335C: 4858F07D  bl 0x82df23d8
	ctx.lr = 0x82863360;
	sub_82DF23D8(ctx, base);
	// 82863360: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863364: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82863368: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286336C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82863370: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82863374: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82863378: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863380 size=124
    let mut pc: u32 = 0x82863380;
    'dispatch: loop {
        match pc {
            0x82863380 => {
    //   block [0x82863380..0x828633FC)
	// 82863380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82863384: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863388: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286338C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863390: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863394: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82863398: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8286339C: 4BFFF77D  bl 0x82862b18
	ctx.lr = 0x828633A0;
	sub_82862B18(ctx, base);
	// 828633A0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828633A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828633A8: 396B03BC  addi r11, r11, 0x3bc
	ctx.r[11].s64 = ctx.r[11].s64 + 956;
	// 828633AC: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 828633B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828633B4: 4859084D  bl 0x82df3c00
	ctx.lr = 0x828633B8;
	sub_82DF3C00(ctx, base);
	// 828633B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828633BC: 4858FDF5  bl 0x82df31b0
	ctx.lr = 0x828633C0;
	sub_82DF31B0(ctx, base);
	// 828633C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828633C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828633C8: 48590641  bl 0x82df3a08
	ctx.lr = 0x828633CC;
	sub_82DF3A08(ctx, base);
	// 828633CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828633D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828633D4: 485F6315  bl 0x82e596e8
	ctx.lr = 0x828633D8;
	sub_82E596E8(ctx, base);
	// 828633D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828633DC: 4859004D  bl 0x82df3428
	ctx.lr = 0x828633E0;
	sub_82DF3428(ctx, base);
	// 828633E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828633E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828633E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828633EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828633F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828633F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828633F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863400 size=100
    let mut pc: u32 = 0x82863400;
    'dispatch: loop {
        match pc {
            0x82863400 => {
    //   block [0x82863400..0x82863464)
	// 82863400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82863404: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863408: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286340C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863410: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863414: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82863418: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8286341C: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 82863420: 396B03BC  addi r11, r11, 0x3bc
	ctx.r[11].s64 = ctx.r[11].s64 + 956;
	// 82863424: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82863428: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8286342C: 4858FFFD  bl 0x82df3428
	ctx.lr = 0x82863430;
	sub_82DF3428(ctx, base);
	// 82863430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863434: 485F9155  bl 0x82e5c588
	ctx.lr = 0x82863438;
	sub_82E5C588(ctx, base);
	// 82863438: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286343C: 4182000C  beq 0x82863448
	if ctx.cr[0].eq {
	pc = 0x82863448; continue 'dispatch;
	}
	// 82863440: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863444: 4858EF95  bl 0x82df23d8
	ctx.lr = 0x82863448;
	sub_82DF23D8(ctx, base);
	// 82863448: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286344C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82863450: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82863454: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82863458: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8286345C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82863460: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863468 size=196
    let mut pc: u32 = 0x82863468;
    'dispatch: loop {
        match pc {
            0x82863468 => {
    //   block [0x82863468..0x8286352C)
	// 82863468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286346C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863470: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82863474: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863478: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286347C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82863480: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82863484: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82863488: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8286348C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82863490: 4BA5D4A9  bl 0x822c0938
	ctx.lr = 0x82863494;
	sub_822C0938(ctx, base);
	// 82863494: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82863498: 41820028  beq 0x828634c0
	if ctx.cr[0].eq {
	pc = 0x828634C0; continue 'dispatch;
	}
	// 8286349C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828634A0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828634A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828634A8: 392B03FC  addi r9, r11, 0x3fc
	ctx.r[9].s64 = ctx.r[11].s64 + 1020;
	// 828634AC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828634B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828634B4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828634B8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828634BC: 48000008  b 0x828634c4
	pc = 0x828634C4; continue 'dispatch;
	// 828634C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828634C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828634C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828634CC: 409A0044  bne cr6, 0x82863510
	if !ctx.cr[6].eq {
	pc = 0x82863510; continue 'dispatch;
	}
	// 828634D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828634D4: 419A001C  beq cr6, 0x828634f0
	if ctx.cr[6].eq {
	pc = 0x828634F0; continue 'dispatch;
	}
	// 828634D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828634DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828634E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828634E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828634E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828634EC: 4E800421  bctrl
	ctx.lr = 0x828634F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828634F0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828634F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828634F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828634FC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82863500: 816B4FC4  lwz r11, 0x4fc4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20420 as u32) ) } as u64;
	// 82863504: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82863508: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8286350C: 4BA5CAF5  bl 0x822c0000
	ctx.lr = 0x82863510;
	sub_822C0000(ctx, base);
	// 82863510: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82863514: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82863518: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286351C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82863520: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82863524: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82863528: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863530 size=196
    let mut pc: u32 = 0x82863530;
    'dispatch: loop {
        match pc {
            0x82863530 => {
    //   block [0x82863530..0x828635F4)
	// 82863530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82863534: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863538: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286353C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863540: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863544: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82863548: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8286354C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82863550: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82863554: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82863558: 4BA5D3E1  bl 0x822c0938
	ctx.lr = 0x8286355C;
	sub_822C0938(ctx, base);
	// 8286355C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82863560: 41820028  beq 0x82863588
	if ctx.cr[0].eq {
	pc = 0x82863588; continue 'dispatch;
	}
	// 82863564: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82863568: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8286356C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82863570: 392B0410  addi r9, r11, 0x410
	ctx.r[9].s64 = ctx.r[11].s64 + 1040;
	// 82863574: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82863578: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8286357C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82863580: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82863584: 48000008  b 0x8286358c
	pc = 0x8286358C; continue 'dispatch;
	// 82863588: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8286358C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82863590: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82863594: 409A0044  bne cr6, 0x828635d8
	if !ctx.cr[6].eq {
	pc = 0x828635D8; continue 'dispatch;
	}
	// 82863598: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8286359C: 419A001C  beq cr6, 0x828635b8
	if ctx.cr[6].eq {
	pc = 0x828635B8; continue 'dispatch;
	}
	// 828635A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828635A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828635A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828635AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828635B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828635B4: 4E800421  bctrl
	ctx.lr = 0x828635B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828635B8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828635BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828635C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828635C4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828635C8: 816B4FC4  lwz r11, 0x4fc4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20420 as u32) ) } as u64;
	// 828635CC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828635D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828635D4: 4BA5CA2D  bl 0x822c0000
	ctx.lr = 0x828635D8;
	sub_822C0000(ctx, base);
	// 828635D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828635DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828635E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828635E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828635E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828635EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828635F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828635F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828635F8 size=196
    let mut pc: u32 = 0x828635F8;
    'dispatch: loop {
        match pc {
            0x828635F8 => {
    //   block [0x828635F8..0x828636BC)
	// 828635F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828635FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863600: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82863604: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863608: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286360C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82863610: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82863614: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82863618: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8286361C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82863620: 4BA5D319  bl 0x822c0938
	ctx.lr = 0x82863624;
	sub_822C0938(ctx, base);
	// 82863624: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82863628: 41820028  beq 0x82863650
	if ctx.cr[0].eq {
	pc = 0x82863650; continue 'dispatch;
	}
	// 8286362C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82863630: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82863634: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82863638: 392B0424  addi r9, r11, 0x424
	ctx.r[9].s64 = ctx.r[11].s64 + 1060;
	// 8286363C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82863640: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82863644: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82863648: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8286364C: 48000008  b 0x82863654
	pc = 0x82863654; continue 'dispatch;
	// 82863650: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82863654: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82863658: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286365C: 409A0044  bne cr6, 0x828636a0
	if !ctx.cr[6].eq {
	pc = 0x828636A0; continue 'dispatch;
	}
	// 82863660: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82863664: 419A001C  beq cr6, 0x82863680
	if ctx.cr[6].eq {
	pc = 0x82863680; continue 'dispatch;
	}
	// 82863668: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286366C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82863670: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863674: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863678: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8286367C: 4E800421  bctrl
	ctx.lr = 0x82863680;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82863680: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82863684: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82863688: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286368C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82863690: 816B4FC4  lwz r11, 0x4fc4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20420 as u32) ) } as u64;
	// 82863694: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82863698: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8286369C: 4BA5C965  bl 0x822c0000
	ctx.lr = 0x828636A0;
	sub_822C0000(ctx, base);
	// 828636A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828636A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828636A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828636AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828636B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828636B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828636B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828636C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828636C0 size=120
    let mut pc: u32 = 0x828636C0;
    'dispatch: loop {
        match pc {
            0x828636C0 => {
    //   block [0x828636C0..0x82863738)
	// 828636C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828636C4: 48944AA9  bl 0x831a816c
	ctx.lr = 0x828636C8;
	sub_831A8130(ctx, base);
	// 828636C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828636CC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828636D0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828636D4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828636D8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828636DC: 388B0438  addi r4, r11, 0x438
	ctx.r[4].s64 = ctx.r[11].s64 + 1080;
	// 828636E0: 38A0002A  li r5, 0x2a
	ctx.r[5].s64 = 42;
	// 828636E4: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 828636E8: 4858ED01  bl 0x82df23e8
	ctx.lr = 0x828636EC;
	sub_82DF23E8(ctx, base);
	// 828636EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828636F0: 41820014  beq 0x82863704
	if ctx.cr[0].eq {
	pc = 0x82863704; continue 'dispatch;
	}
	// 828636F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828636F8: 4BFFFB11  bl 0x82863208
	ctx.lr = 0x828636FC;
	sub_82863208(ctx, base);
	// 828636FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82863700: 48000008  b 0x82863708
	pc = 0x82863708; continue 'dispatch;
	// 82863704: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82863708: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8286370C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82863710: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82863714: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82863718: 4BFFFD51  bl 0x82863468
	ctx.lr = 0x8286371C;
	sub_82863468(ctx, base);
	// 8286371C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82863720: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82863724: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82863728: 4BA5C8D9  bl 0x822c0000
	ctx.lr = 0x8286372C;
	sub_822C0000(ctx, base);
	// 8286372C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82863730: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82863734: 48944A88  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863738 size=136
    let mut pc: u32 = 0x82863738;
    'dispatch: loop {
        match pc {
            0x82863738 => {
    //   block [0x82863738..0x828637C0)
	// 82863738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286373C: 48944A31  bl 0x831a816c
	ctx.lr = 0x82863740;
	sub_831A8130(ctx, base);
	// 82863740: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82863744: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863748: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8286374C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82863750: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82863754: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82863758: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8286375C: 388B0438  addi r4, r11, 0x438
	ctx.r[4].s64 = ctx.r[11].s64 + 1080;
	// 82863760: 38A00050  li r5, 0x50
	ctx.r[5].s64 = 80;
	// 82863764: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 82863768: 4858EC81  bl 0x82df23e8
	ctx.lr = 0x8286376C;
	sub_82DF23E8(ctx, base);
	// 8286376C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82863770: 41820018  beq 0x82863788
	if ctx.cr[0].eq {
	pc = 0x82863788; continue 'dispatch;
	}
	// 82863774: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82863778: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8286377C: 4BFFFB0D  bl 0x82863288
	ctx.lr = 0x82863780;
	sub_82863288(ctx, base);
	// 82863780: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82863784: 48000008  b 0x8286378c
	pc = 0x8286378C; continue 'dispatch;
	// 82863788: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8286378C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82863790: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82863794: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82863798: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8286379C: 4BFFFD95  bl 0x82863530
	ctx.lr = 0x828637A0;
	sub_82863530(ctx, base);
	// 828637A0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828637A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828637A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828637AC: 4BA5C855  bl 0x822c0000
	ctx.lr = 0x828637B0;
	sub_822C0000(ctx, base);
	// 828637B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828637B4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828637B8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828637BC: 48944A00  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828637C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828637C0 size=120
    let mut pc: u32 = 0x828637C0;
    'dispatch: loop {
        match pc {
            0x828637C0 => {
    //   block [0x828637C0..0x82863838)
	// 828637C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828637C4: 489449A9  bl 0x831a816c
	ctx.lr = 0x828637C8;
	sub_831A8130(ctx, base);
	// 828637C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828637CC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828637D0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828637D4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828637D8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828637DC: 388B0438  addi r4, r11, 0x438
	ctx.r[4].s64 = ctx.r[11].s64 + 1080;
	// 828637E0: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 828637E4: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 828637E8: 4858EC01  bl 0x82df23e8
	ctx.lr = 0x828637EC;
	sub_82DF23E8(ctx, base);
	// 828637EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828637F0: 41820014  beq 0x82863804
	if ctx.cr[0].eq {
	pc = 0x82863804; continue 'dispatch;
	}
	// 828637F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828637F8: 4BFFFB89  bl 0x82863380
	ctx.lr = 0x828637FC;
	sub_82863380(ctx, base);
	// 828637FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82863800: 48000008  b 0x82863808
	pc = 0x82863808; continue 'dispatch;
	// 82863804: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82863808: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8286380C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82863810: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82863814: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82863818: 4BFFFDE1  bl 0x828635f8
	ctx.lr = 0x8286381C;
	sub_828635F8(ctx, base);
	// 8286381C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82863820: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82863824: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82863828: 4BA5C7D9  bl 0x822c0000
	ctx.lr = 0x8286382C;
	sub_822C0000(ctx, base);
	// 8286382C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82863830: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82863834: 48944988  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863838 size=196
    let mut pc: u32 = 0x82863838;
    'dispatch: loop {
        match pc {
            0x82863838 => {
    //   block [0x82863838..0x828638FC)
	// 82863838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286383C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863840: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82863844: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863848: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286384C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82863850: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82863854: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863858: 4BF8BF29  bl 0x827ef780
	ctx.lr = 0x8286385C;
	sub_827EF780(ctx, base);
	// 8286385C: 4BF86AB5  bl 0x827ea310
	ctx.lr = 0x82863860;
	sub_827EA310(ctx, base);
	// 82863860: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82863864: 387E0064  addi r3, r30, 0x64
	ctx.r[3].s64 = ctx.r[30].s64 + 100;
	// 82863868: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8286386C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82863870: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 82863874: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82863878: 4858F939  bl 0x82df31b0
	ctx.lr = 0x8286387C;
	sub_82DF31B0(ctx, base);
	// 8286387C: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82863880: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82863884: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82863888: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8286388C: 4BFB505D  bl 0x828188e8
	ctx.lr = 0x82863890;
	sub_828188E8(ctx, base);
	// 82863890: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82863894: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82863898: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286389C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828638A0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828638A4: 419A0024  beq cr6, 0x828638c8
	if ctx.cr[6].eq {
	pc = 0x828638C8; continue 'dispatch;
	}
	// 828638A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828638AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828638B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828638B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828638B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828638BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828638C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828638C4: 4082FFE8  bne 0x828638ac
	if !ctx.cr[0].eq {
	pc = 0x828638AC; continue 'dispatch;
	}
	// 828638C8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828638CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828638D0: 4BF8A959  bl 0x827ee228
	ctx.lr = 0x828638D4;
	sub_827EE228(ctx, base);
	// 828638D4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828638D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828638DC: 419A0008  beq cr6, 0x828638e4
	if ctx.cr[6].eq {
	pc = 0x828638E4; continue 'dispatch;
	}
	// 828638E0: 4BA5CFB1  bl 0x822c0890
	ctx.lr = 0x828638E4;
	sub_822C0890(ctx, base);
	// 828638E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828638E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828638EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828638F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828638F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828638F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863900 size=192
    let mut pc: u32 = 0x82863900;
    'dispatch: loop {
        match pc {
            0x82863900 => {
    //   block [0x82863900..0x828639C0)
	// 82863900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82863904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863908: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286390C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863910: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863914: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82863918: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286391C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82863920: 4BF8BE61  bl 0x827ef780
	ctx.lr = 0x82863924;
	sub_827EF780(ctx, base);
	// 82863924: 4BF869ED  bl 0x827ea310
	ctx.lr = 0x82863928;
	sub_827EA310(ctx, base);
	// 82863928: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286392C: 4182007C  beq 0x828639a8
	if ctx.cr[0].eq {
	pc = 0x828639A8; continue 'dispatch;
	}
	// 82863930: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82863934: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 82863938: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 8286393C: 4858F875  bl 0x82df31b0
	ctx.lr = 0x82863940;
	sub_82DF31B0(ctx, base);
	// 82863940: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82863944: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82863948: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 8286394C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82863950: 4BFB4F99  bl 0x828188e8
	ctx.lr = 0x82863954;
	sub_828188E8(ctx, base);
	// 82863954: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82863958: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8286395C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82863964: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82863968: 419A0024  beq cr6, 0x8286398c
	if ctx.cr[6].eq {
	pc = 0x8286398C; continue 'dispatch;
	}
	// 8286396C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82863970: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82863974: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82863978: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8286397C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82863980: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82863984: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82863988: 4082FFE8  bne 0x82863970
	if !ctx.cr[0].eq {
	pc = 0x82863970; continue 'dispatch;
	}
	// 8286398C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82863990: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82863994: 4BF8A895  bl 0x827ee228
	ctx.lr = 0x82863998;
	sub_827EE228(ctx, base);
	// 82863998: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8286399C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828639A0: 419A0008  beq cr6, 0x828639a8
	if ctx.cr[6].eq {
	pc = 0x828639A8; continue 'dispatch;
	}
	// 828639A4: 4BA5CEED  bl 0x822c0890
	ctx.lr = 0x828639A8;
	sub_822C0890(ctx, base);
	// 828639A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828639AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828639B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828639B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828639B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828639BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828639C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828639C0 size=16
    let mut pc: u32 = 0x828639C0;
    'dispatch: loop {
        match pc {
            0x828639C0 => {
    //   block [0x828639C0..0x828639D0)
	// 828639C0: 81630064  lwz r11, 0x64(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) } as u64;
	// 828639C4: 81430068  lwz r10, 0x68(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) } as u64;
	// 828639C8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828639CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828639D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828639D0 size=28
    let mut pc: u32 = 0x828639D0;
    'dispatch: loop {
        match pc {
            0x828639D0 => {
    //   block [0x828639D0..0x828639EC)
	// 828639D0: 81630064  lwz r11, 0x64(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) } as u64;
	// 828639D4: 81430068  lwz r10, 0x68(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) } as u64;
	// 828639D8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828639DC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828639E0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828639E4: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828639E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828639F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828639F0 size=88
    let mut pc: u32 = 0x828639F0;
    'dispatch: loop {
        match pc {
            0x828639F0 => {
    //   block [0x828639F0..0x82863A48)
	// 828639F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828639F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828639F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828639FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863A00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863A04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82863A08: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82863A0C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82863A10: 396B049C  addi r11, r11, 0x49c
	ctx.r[11].s64 = ctx.r[11].s64 + 1180;
	// 82863A14: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82863A18: 485F8B71  bl 0x82e5c588
	ctx.lr = 0x82863A1C;
	sub_82E5C588(ctx, base);
	// 82863A1C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82863A20: 4182000C  beq 0x82863a2c
	if ctx.cr[0].eq {
	pc = 0x82863A2C; continue 'dispatch;
	}
	// 82863A24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863A28: 4858E9B1  bl 0x82df23d8
	ctx.lr = 0x82863A2C;
	sub_82DF23D8(ctx, base);
	// 82863A2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863A30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82863A34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82863A38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82863A3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82863A40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82863A44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863A48 size=196
    let mut pc: u32 = 0x82863A48;
    'dispatch: loop {
        match pc {
            0x82863A48 => {
    //   block [0x82863A48..0x82863B0C)
	// 82863A48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82863A4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863A50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82863A54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863A58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863A5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82863A60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82863A64: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82863A68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82863A6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82863A70: 4BA5CEC9  bl 0x822c0938
	ctx.lr = 0x82863A74;
	sub_822C0938(ctx, base);
	// 82863A74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82863A78: 41820028  beq 0x82863aa0
	if ctx.cr[0].eq {
	pc = 0x82863AA0; continue 'dispatch;
	}
	// 82863A7C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82863A80: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82863A84: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82863A88: 392B04DC  addi r9, r11, 0x4dc
	ctx.r[9].s64 = ctx.r[11].s64 + 1244;
	// 82863A8C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82863A90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82863A94: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82863A98: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82863A9C: 48000008  b 0x82863aa4
	pc = 0x82863AA4; continue 'dispatch;
	// 82863AA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82863AA4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82863AA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82863AAC: 409A0044  bne cr6, 0x82863af0
	if !ctx.cr[6].eq {
	pc = 0x82863AF0; continue 'dispatch;
	}
	// 82863AB0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82863AB4: 419A001C  beq cr6, 0x82863ad0
	if ctx.cr[6].eq {
	pc = 0x82863AD0; continue 'dispatch;
	}
	// 82863AB8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82863ABC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82863AC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863AC4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863AC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82863ACC: 4E800421  bctrl
	ctx.lr = 0x82863AD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82863AD0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82863AD4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82863AD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82863ADC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82863AE0: 816B5130  lwz r11, 0x5130(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20784 as u32) ) } as u64;
	// 82863AE4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82863AE8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82863AEC: 4BA5C515  bl 0x822c0000
	ctx.lr = 0x82863AF0;
	sub_822C0000(ctx, base);
	// 82863AF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82863AF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82863AF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82863AFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82863B00: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82863B04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82863B08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863B10 size=140
    let mut pc: u32 = 0x82863B10;
    'dispatch: loop {
        match pc {
            0x82863B10 => {
    //   block [0x82863B10..0x82863B9C)
	// 82863B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82863B14: 48944655  bl 0x831a8168
	ctx.lr = 0x82863B18;
	sub_831A8130(ctx, base);
	// 82863B18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863B1C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82863B20: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82863B24: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82863B28: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82863B2C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82863B30: 388B04F0  addi r4, r11, 0x4f0
	ctx.r[4].s64 = ctx.r[11].s64 + 1264;
	// 82863B34: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82863B38: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 82863B3C: 4858E8AD  bl 0x82df23e8
	ctx.lr = 0x82863B40;
	sub_82DF23E8(ctx, base);
	// 82863B40: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82863B44: 41820024  beq 0x82863b68
	if ctx.cr[0].eq {
	pc = 0x82863B68; continue 'dispatch;
	}
	// 82863B48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863B4C: 4BFFEFCD  bl 0x82862b18
	ctx.lr = 0x82863B50;
	sub_82862B18(ctx, base);
	// 82863B50: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82863B54: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82863B58: 396B049C  addi r11, r11, 0x49c
	ctx.r[11].s64 = ctx.r[11].s64 + 1180;
	// 82863B5C: 939F0068  stw r28, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 82863B60: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82863B64: 48000008  b 0x82863b6c
	pc = 0x82863B6C; continue 'dispatch;
	// 82863B68: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82863B6C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82863B70: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82863B74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82863B78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82863B7C: 4BFFFECD  bl 0x82863a48
	ctx.lr = 0x82863B80;
	sub_82863A48(ctx, base);
	// 82863B80: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82863B84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82863B88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82863B8C: 4BA5C475  bl 0x822c0000
	ctx.lr = 0x82863B90;
	sub_822C0000(ctx, base);
	// 82863B90: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82863B94: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82863B98: 48944620  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863BA0 size=84
    let mut pc: u32 = 0x82863BA0;
    'dispatch: loop {
        match pc {
            0x82863BA0 => {
    //   block [0x82863BA0..0x82863BF4)
	// 82863BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82863BA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863BA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863BAC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863BB0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82863BB4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82863BB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82863BBC: 388B0380  addi r4, r11, 0x380
	ctx.r[4].s64 = ctx.r[11].s64 + 896;
	// 82863BC0: 4858FE49  bl 0x82df3a08
	ctx.lr = 0x82863BC4;
	sub_82DF3A08(ctx, base);
	// 82863BC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863BC8: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 82863BCC: 4BF8BBB5  bl 0x827ef780
	ctx.lr = 0x82863BD0;
	sub_827EF780(ctx, base);
	// 82863BD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82863BD4: 4BF8690D  bl 0x827ea4e0
	ctx.lr = 0x82863BD8;
	sub_827EA4E0(ctx, base);
	// 82863BD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82863BDC: 4858F84D  bl 0x82df3428
	ctx.lr = 0x82863BE0;
	sub_82DF3428(ctx, base);
	// 82863BE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82863BE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82863BE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82863BEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82863BF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863BF8 size=60
    let mut pc: u32 = 0x82863BF8;
    'dispatch: loop {
        match pc {
            0x82863BF8 => {
    //   block [0x82863BF8..0x82863C34)
	// 82863BF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82863BFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863C00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863C04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863C08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82863C0C: 4BFFEF0D  bl 0x82862b18
	ctx.lr = 0x82863C10;
	sub_82862B18(ctx, base);
	// 82863C10: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82863C14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863C18: 396B0554  addi r11, r11, 0x554
	ctx.r[11].s64 = ctx.r[11].s64 + 1364;
	// 82863C1C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82863C20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82863C24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82863C28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82863C2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82863C30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863C38 size=88
    let mut pc: u32 = 0x82863C38;
    'dispatch: loop {
        match pc {
            0x82863C38 => {
    //   block [0x82863C38..0x82863C90)
	// 82863C38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82863C3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863C40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82863C44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863C48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863C4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82863C50: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82863C54: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82863C58: 396B0554  addi r11, r11, 0x554
	ctx.r[11].s64 = ctx.r[11].s64 + 1364;
	// 82863C5C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82863C60: 485F8929  bl 0x82e5c588
	ctx.lr = 0x82863C64;
	sub_82E5C588(ctx, base);
	// 82863C64: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82863C68: 4182000C  beq 0x82863c74
	if ctx.cr[0].eq {
	pc = 0x82863C74; continue 'dispatch;
	}
	// 82863C6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863C70: 4858E769  bl 0x82df23d8
	ctx.lr = 0x82863C74;
	sub_82DF23D8(ctx, base);
	// 82863C74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863C78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82863C7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82863C80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82863C84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82863C88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82863C8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82863C90 size=8
    let mut pc: u32 = 0x82863C90;
    'dispatch: loop {
        match pc {
            0x82863C90 => {
    //   block [0x82863C90..0x82863C98)
	// 82863C90: 38630064  addi r3, r3, 0x64
	ctx.r[3].s64 = ctx.r[3].s64 + 100;
	// 82863C94: 485F8A04  b 0x82e5c698
	sub_82E5C698(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82863C98 size=88
    let mut pc: u32 = 0x82863C98;
    'dispatch: loop {
        match pc {
            0x82863C98 => {
    //   block [0x82863C98..0x82863CF0)
	// 82863C98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82863C9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863CA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863CA4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82863CA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863CAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82863CB0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82863CB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82863CB8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82863CBC: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82863CC0: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82863CC4: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82863CC8: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82863CCC: 4858F425  bl 0x82df30f0
	ctx.lr = 0x82863CD0;
	sub_82DF30F0(ctx, base);
	// 82863CD0: D3FF0000  stfs f31, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82863CD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863CD8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82863CDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82863CE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82863CE4: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82863CE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82863CEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863CF0 size=116
    let mut pc: u32 = 0x82863CF0;
    'dispatch: loop {
        match pc {
            0x82863CF0 => {
    //   block [0x82863CF0..0x82863D64)
	// 82863CF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82863CF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863CF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863CFC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82863D00: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863D04: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82863D08: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82863D0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82863D10: 3BEB0064  addi r31, r11, 0x64
	ctx.r[31].s64 = ctx.r[11].s64 + 100;
	// 82863D14: 4BFFFF85  bl 0x82863c98
	ctx.lr = 0x82863D18;
	sub_82863C98(ctx, base);
	// 82863D18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82863D1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863D20: 485F59A1  bl 0x82e596c0
	ctx.lr = 0x82863D24;
	sub_82E596C0(ctx, base);
	// 82863D24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82863D28: 4858F701  bl 0x82df3428
	ctx.lr = 0x82863D2C;
	sub_82DF3428(ctx, base);
	// 82863D2C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82863D30: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82863D34: 4BFFFF65  bl 0x82863c98
	ctx.lr = 0x82863D38;
	sub_82863C98(ctx, base);
	// 82863D38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82863D3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863D40: 485F9351  bl 0x82e5d090
	ctx.lr = 0x82863D44;
	sub_82E5D090(ctx, base);
	// 82863D44: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82863D48: 4858F6E1  bl 0x82df3428
	ctx.lr = 0x82863D4C;
	sub_82DF3428(ctx, base);
	// 82863D4C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82863D50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82863D54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82863D58: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82863D5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82863D60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863D68 size=116
    let mut pc: u32 = 0x82863D68;
    'dispatch: loop {
        match pc {
            0x82863D68 => {
    //   block [0x82863D68..0x82863DDC)
	// 82863D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82863D6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863D70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863D74: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82863D78: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863D7C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82863D80: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82863D84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82863D88: 3BEB0064  addi r31, r11, 0x64
	ctx.r[31].s64 = ctx.r[11].s64 + 100;
	// 82863D8C: 4BFFFF0D  bl 0x82863c98
	ctx.lr = 0x82863D90;
	sub_82863C98(ctx, base);
	// 82863D90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82863D94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863D98: 485F5929  bl 0x82e596c0
	ctx.lr = 0x82863D9C;
	sub_82E596C0(ctx, base);
	// 82863D9C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82863DA0: 4858F689  bl 0x82df3428
	ctx.lr = 0x82863DA4;
	sub_82DF3428(ctx, base);
	// 82863DA4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82863DA8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82863DAC: 4BFFFEED  bl 0x82863c98
	ctx.lr = 0x82863DB0;
	sub_82863C98(ctx, base);
	// 82863DB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82863DB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863DB8: 4BF884E1  bl 0x827ec298
	ctx.lr = 0x82863DBC;
	sub_827EC298(ctx, base);
	// 82863DBC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82863DC0: 4858F669  bl 0x82df3428
	ctx.lr = 0x82863DC4;
	sub_82DF3428(ctx, base);
	// 82863DC4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82863DC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82863DCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82863DD0: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82863DD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82863DD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863DE0 size=84
    let mut pc: u32 = 0x82863DE0;
    'dispatch: loop {
        match pc {
            0x82863DE0 => {
    //   block [0x82863DE0..0x82863E34)
	// 82863DE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82863DE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863DE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863DEC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863DF0: 38830064  addi r4, r3, 0x64
	ctx.r[4].s64 = ctx.r[3].s64 + 100;
	// 82863DF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82863DF8: 485F6729  bl 0x82e5a520
	ctx.lr = 0x82863DFC;
	sub_82E5A520(ctx, base);
	// 82863DFC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82863E00: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82863E04: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82863E08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82863E0C: 555FDFFE  rlwinm r31, r10, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82863E10: 419A000C  beq cr6, 0x82863e1c
	if ctx.cr[6].eq {
	pc = 0x82863E1C; continue 'dispatch;
	}
	// 82863E14: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82863E18: 4BA5CA79  bl 0x822c0890
	ctx.lr = 0x82863E1C;
	sub_822C0890(ctx, base);
	// 82863E1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863E20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82863E24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82863E28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82863E2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82863E30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82863E38 size=196
    let mut pc: u32 = 0x82863E38;
    'dispatch: loop {
        match pc {
            0x82863E38 => {
    //   block [0x82863E38..0x82863EFC)
	// 82863E38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82863E3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863E40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82863E44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863E48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863E4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82863E50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82863E54: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82863E58: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82863E5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82863E60: 4BA5CAD9  bl 0x822c0938
	ctx.lr = 0x82863E64;
	sub_822C0938(ctx, base);
	// 82863E64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82863E68: 41820028  beq 0x82863e90
	if ctx.cr[0].eq {
	pc = 0x82863E90; continue 'dispatch;
	}
	// 82863E6C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82863E70: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82863E74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82863E78: 392B0594  addi r9, r11, 0x594
	ctx.r[9].s64 = ctx.r[11].s64 + 1428;
	// 82863E7C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82863E80: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82863E84: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82863E88: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82863E8C: 48000008  b 0x82863e94
	pc = 0x82863E94; continue 'dispatch;
	// 82863E90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82863E94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82863E98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82863E9C: 409A0044  bne cr6, 0x82863ee0
	if !ctx.cr[6].eq {
	pc = 0x82863EE0; continue 'dispatch;
	}
	// 82863EA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82863EA4: 419A001C  beq cr6, 0x82863ec0
	if ctx.cr[6].eq {
	pc = 0x82863EC0; continue 'dispatch;
	}
	// 82863EA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82863EAC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82863EB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82863EB4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82863EB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82863EBC: 4E800421  bctrl
	ctx.lr = 0x82863EC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82863EC0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82863EC4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82863EC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82863ECC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82863ED0: 816B51E4  lwz r11, 0x51e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20964 as u32) ) } as u64;
	// 82863ED4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82863ED8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82863EDC: 4BA5C125  bl 0x822c0000
	ctx.lr = 0x82863EE0;
	sub_822C0000(ctx, base);
	// 82863EE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82863EE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82863EE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82863EEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82863EF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82863EF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82863EF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82863F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82863F00 size=320
    let mut pc: u32 = 0x82863F00;
    'dispatch: loop {
        match pc {
            0x82863F00 => {
    //   block [0x82863F00..0x82864040)
	// 82863F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82863F04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82863F08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82863F0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82863F10: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82863F14: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82863F18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82863F1C: 3BDF0064  addi r30, r31, 0x64
	ctx.r[30].s64 = ctx.r[31].s64 + 100;
	// 82863F20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82863F24: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82863F28: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82863F2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82863F30: 4E800421  bctrl
	ctx.lr = 0x82863F34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82863F34: 817F00D0  lwz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 82863F38: 815F00CC  lwz r10, 0xcc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82863F3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82863F40: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82863F44: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82863F48: 419A0024  beq cr6, 0x82863f6c
	if ctx.cr[6].eq {
	pc = 0x82863F6C; continue 'dispatch;
	}
	// 82863F4C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82863F50: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82863F54: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82863F58: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82863F5C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82863F60: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82863F64: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82863F68: 4082FFE8  bne 0x82863f50
	if !ctx.cr[0].eq {
	pc = 0x82863F50; continue 'dispatch;
	}
	// 82863F6C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82863F70: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82863F74: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82863F78: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82863F7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82863F80: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82863F84: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82863F88: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82863F8C: 485FA7F5  bl 0x82e5e780
	ctx.lr = 0x82863F90;
	sub_82E5E780(ctx, base);
	// 82863F90: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82863F94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82863F98: 419A0008  beq cr6, 0x82863fa0
	if ctx.cr[6].eq {
	pc = 0x82863FA0; continue 'dispatch;
	}
	// 82863F9C: 4BA5C8F5  bl 0x822c0890
	ctx.lr = 0x82863FA0;
	sub_822C0890(ctx, base);
	// 82863FA0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82863FA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82863FA8: 419A0008  beq cr6, 0x82863fb0
	if ctx.cr[6].eq {
	pc = 0x82863FB0; continue 'dispatch;
	}
	// 82863FAC: 4BA5C8E5  bl 0x822c0890
	ctx.lr = 0x82863FB0;
	sub_822C0890(ctx, base);
	// 82863FB0: 817F00D8  lwz r11, 0xd8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 82863FB4: 815F00D4  lwz r10, 0xd4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82863FB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82863FBC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82863FC0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82863FC4: 419A0024  beq cr6, 0x82863fe8
	if ctx.cr[6].eq {
	pc = 0x82863FE8; continue 'dispatch;
	}
	// 82863FC8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82863FCC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82863FD0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82863FD4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82863FD8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82863FDC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82863FE0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82863FE4: 4082FFE8  bne 0x82863fcc
	if !ctx.cr[0].eq {
	pc = 0x82863FCC; continue 'dispatch;
	}
	// 82863FE8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82863FEC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82863FF0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82863FF4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82863FF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82863FFC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82864000: 485FA781  bl 0x82e5e780
	ctx.lr = 0x82864004;
	sub_82E5E780(ctx, base);
	// 82864004: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82864008: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286400C: 419A0008  beq cr6, 0x82864014
	if ctx.cr[6].eq {
	pc = 0x82864014; continue 'dispatch;
	}
	// 82864010: 4BA5C881  bl 0x822c0890
	ctx.lr = 0x82864014;
	sub_822C0890(ctx, base);
	// 82864014: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82864018: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286401C: 419A0008  beq cr6, 0x82864024
	if ctx.cr[6].eq {
	pc = 0x82864024; continue 'dispatch;
	}
	// 82864020: 4BA5C871  bl 0x822c0890
	ctx.lr = 0x82864024;
	sub_822C0890(ctx, base);
	// 82864024: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82864028: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286402C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82864030: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82864034: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82864038: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286403C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82864040 size=204
    let mut pc: u32 = 0x82864040;
    'dispatch: loop {
        match pc {
            0x82864040 => {
    //   block [0x82864040..0x8286410C)
	// 82864040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82864044: 48944129  bl 0x831a816c
	ctx.lr = 0x82864048;
	sub_831A8130(ctx, base);
	// 82864048: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286404C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82864050: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82864054: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82864058: 4BFFEAC1  bl 0x82862b18
	ctx.lr = 0x8286405C;
	sub_82862B18(ctx, base);
	// 8286405C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82864060: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 82864064: 396B05AC  addi r11, r11, 0x5ac
	ctx.r[11].s64 = ctx.r[11].s64 + 1452;
	// 82864068: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8286406C: 485F9865  bl 0x82e5d8d0
	ctx.lr = 0x82864070;
	sub_82E5D8D0(ctx, base);
	// 82864070: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82864074: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82864078: 392B5DA0  addi r9, r11, 0x5da0
	ctx.r[9].s64 = ctx.r[11].s64 + 23968;
	// 8286407C: 397F00CC  addi r11, r31, 0xcc
	ctx.r[11].s64 = ctx.r[31].s64 + 204;
	// 82864080: 913F0064  stw r9, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82864084: 915F00C4  stw r10, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[10].u32 ) };
	// 82864088: 915F00C8  stw r10, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[10].u32 ) };
	// 8286408C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864090: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 82864094: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864098: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286409C: 917F00D0  stw r11, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 828640A0: 419A0024  beq cr6, 0x828640c4
	if ctx.cr[6].eq {
	pc = 0x828640C4; continue 'dispatch;
	}
	// 828640A4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828640A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828640AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828640B0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828640B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828640B8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828640BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828640C0: 4082FFE8  bne 0x828640a8
	if !ctx.cr[0].eq {
	pc = 0x828640A8; continue 'dispatch;
	}
	// 828640C4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828640C8: 397F00D4  addi r11, r31, 0xd4
	ctx.r[11].s64 = ctx.r[31].s64 + 212;
	// 828640CC: 915F00D4  stw r10, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[10].u32 ) };
	// 828640D0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828640D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828640D8: 917F00D8  stw r11, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[11].u32 ) };
	// 828640DC: 419A0024  beq cr6, 0x82864100
	if ctx.cr[6].eq {
	pc = 0x82864100; continue 'dispatch;
	}
	// 828640E0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828640E4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828640E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828640EC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828640F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828640F4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828640F8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828640FC: 4082FFE8  bne 0x828640e4
	if !ctx.cr[0].eq {
	pc = 0x828640E4; continue 'dispatch;
	}
	// 82864100: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82864104: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82864108: 489440B4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82864110 size=128
    let mut pc: u32 = 0x82864110;
    'dispatch: loop {
        match pc {
            0x82864110 => {
    //   block [0x82864110..0x82864190)
	// 82864110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82864114: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82864118: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286411C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82864120: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82864124: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82864128: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8286412C: 396B05AC  addi r11, r11, 0x5ac
	ctx.r[11].s64 = ctx.r[11].s64 + 1452;
	// 82864130: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82864134: 807F00D8  lwz r3, 0xd8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 82864138: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286413C: 419A0008  beq cr6, 0x82864144
	if ctx.cr[6].eq {
	pc = 0x82864144; continue 'dispatch;
	}
	// 82864140: 4BA5C751  bl 0x822c0890
	ctx.lr = 0x82864144;
	sub_822C0890(ctx, base);
	// 82864144: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 82864148: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286414C: 419A0008  beq cr6, 0x82864154
	if ctx.cr[6].eq {
	pc = 0x82864154; continue 'dispatch;
	}
	// 82864150: 4BA5C741  bl 0x822c0890
	ctx.lr = 0x82864154;
	sub_822C0890(ctx, base);
	// 82864154: 807F00C8  lwz r3, 0xc8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 82864158: 3BDF0064  addi r30, r31, 0x64
	ctx.r[30].s64 = ctx.r[31].s64 + 100;
	// 8286415C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82864160: 419A0008  beq cr6, 0x82864168
	if ctx.cr[6].eq {
	pc = 0x82864168; continue 'dispatch;
	}
	// 82864164: 4BA5C72D  bl 0x822c0890
	ctx.lr = 0x82864168;
	sub_822C0890(ctx, base);
	// 82864168: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8286416C: 485F96DD  bl 0x82e5d848
	ctx.lr = 0x82864170;
	sub_82E5D848(ctx, base);
	// 82864170: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82864174: 485F8415  bl 0x82e5c588
	ctx.lr = 0x82864178;
	sub_82E5C588(ctx, base);
	// 82864178: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286417C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82864180: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82864184: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82864188: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286418C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82864190 size=76
    let mut pc: u32 = 0x82864190;
    'dispatch: loop {
        match pc {
            0x82864190 => {
    //   block [0x82864190..0x828641DC)
	// 82864190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82864194: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82864198: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286419C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828641A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828641A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828641A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828641AC: 4BFFFF65  bl 0x82864110
	ctx.lr = 0x828641B0;
	sub_82864110(ctx, base);
	// 828641B0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828641B4: 4182000C  beq 0x828641c0
	if ctx.cr[0].eq {
	pc = 0x828641C0; continue 'dispatch;
	}
	// 828641B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828641BC: 4858E21D  bl 0x82df23d8
	ctx.lr = 0x828641C0;
	sub_82DF23D8(ctx, base);
	// 828641C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828641C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828641C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828641CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828641D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828641D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828641D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828641E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828641E0 size=128
    let mut pc: u32 = 0x828641E0;
    'dispatch: loop {
        match pc {
            0x828641E0 => {
    //   block [0x828641E0..0x82864260)
	// 828641E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828641E4: 48943F89  bl 0x831a816c
	ctx.lr = 0x828641E8;
	sub_831A8130(ctx, base);
	// 828641E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828641EC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828641F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828641F4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828641F8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828641FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82864200: 388B05E8  addi r4, r11, 0x5e8
	ctx.r[4].s64 = ctx.r[11].s64 + 1512;
	// 82864204: 38A00028  li r5, 0x28
	ctx.r[5].s64 = 40;
	// 82864208: 386000DC  li r3, 0xdc
	ctx.r[3].s64 = 220;
	// 8286420C: 4858E1DD  bl 0x82df23e8
	ctx.lr = 0x82864210;
	sub_82DF23E8(ctx, base);
	// 82864210: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82864214: 41820018  beq 0x8286422c
	if ctx.cr[0].eq {
	pc = 0x8286422C; continue 'dispatch;
	}
	// 82864218: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8286421C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82864220: 4BFFFE21  bl 0x82864040
	ctx.lr = 0x82864224;
	sub_82864040(ctx, base);
	// 82864224: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82864228: 48000008  b 0x82864230
	pc = 0x82864230; continue 'dispatch;
	// 8286422C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82864230: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82864234: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82864238: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8286423C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82864240: 4BFFFBF9  bl 0x82863e38
	ctx.lr = 0x82864244;
	sub_82863E38(ctx, base);
	// 82864244: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82864248: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8286424C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82864250: 4BA5BDB1  bl 0x822c0000
	ctx.lr = 0x82864254;
	sub_822C0000(ctx, base);
	// 82864254: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82864258: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286425C: 48943F60  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82864260 size=8
    let mut pc: u32 = 0x82864260;
    'dispatch: loop {
        match pc {
            0x82864260 => {
    //   block [0x82864260..0x82864268)
	// 82864260: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82864264: 4BF895D4  b 0x827ed838
	sub_827ED838(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82864268 size=12
    let mut pc: u32 = 0x82864268;
    'dispatch: loop {
        match pc {
            0x82864268 => {
    //   block [0x82864268..0x82864274)
	// 82864268: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 8286426C: C02B7BC8  lfs f1, 0x7bc8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31688 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82864270: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82864278 size=204
    let mut pc: u32 = 0x82864278;
    'dispatch: loop {
        match pc {
            0x82864278 => {
    //   block [0x82864278..0x82864344)
	// 82864278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286427C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82864280: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82864284: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82864288: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286428C: 81630094  lwz r11, 0x94(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) } as u64;
	// 82864290: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82864294: 3BC30094  addi r30, r3, 0x94
	ctx.r[30].s64 = ctx.r[3].s64 + 148;
	// 82864298: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286429C: 419A0060  beq cr6, 0x828642fc
	if ctx.cr[6].eq {
	pc = 0x828642FC; continue 'dispatch;
	}
	// 828642A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828642A4: 4BF89575  bl 0x827ed818
	ctx.lr = 0x828642A8;
	sub_827ED818(ctx, base);
	// 828642A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828642AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828642B0: 4BCAB219  bl 0x8250f4c8
	ctx.lr = 0x828642B4;
	sub_8250F4C8(ctx, base);
	// 828642B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828642B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828642BC: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 828642C0: 409A0008  bne cr6, 0x828642c8
	if !ctx.cr[6].eq {
	pc = 0x828642C8; continue 'dispatch;
	}
	// 828642C4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828642C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828642CC: 4BCA6685  bl 0x8250a950
	ctx.lr = 0x828642D0;
	sub_8250A950(ctx, base);
	// 828642D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828642D4: 4858D9BD  bl 0x82df1c90
	ctx.lr = 0x828642D8;
	sub_82DF1C90(ctx, base);
	// 828642D8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828642DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828642E0: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 828642E4: 409A0008  bne cr6, 0x828642ec
	if !ctx.cr[6].eq {
	pc = 0x828642EC; continue 'dispatch;
	}
	// 828642E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828642EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828642F0: 4BF6F711  bl 0x827d3a00
	ctx.lr = 0x828642F4;
	sub_827D3A00(ctx, base);
	// 828642F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828642F8: 4858D999  bl 0x82df1c90
	ctx.lr = 0x828642FC;
	sub_82DF1C90(ctx, base);
	// 828642FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82864300: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82864304: 4BF8A48D  bl 0x827ee790
	ctx.lr = 0x82864308;
	sub_827EE790(ctx, base);
	// 82864308: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286430C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864310: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82864314: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82864318: 4E800421  bctrl
	ctx.lr = 0x8286431C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286431C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82864320: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82864324: 419A0008  beq cr6, 0x8286432c
	if ctx.cr[6].eq {
	pc = 0x8286432C; continue 'dispatch;
	}
	// 82864328: 4BA5C569  bl 0x822c0890
	ctx.lr = 0x8286432C;
	sub_822C0890(ctx, base);
	// 8286432C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82864330: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82864334: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82864338: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8286433C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82864340: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82864348 size=184
    let mut pc: u32 = 0x82864348;
    'dispatch: loop {
        match pc {
            0x82864348 => {
    //   block [0x82864348..0x82864400)
	// 82864348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286434C: 48943E21  bl 0x831a816c
	ctx.lr = 0x82864350;
	sub_831A8130(ctx, base);
	// 82864350: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82864354: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82864358: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286435C: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82864360: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82864364: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82864368: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286436C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82864370: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82864374: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82864400 size=140
    let mut pc: u32 = 0x82864400;
    'dispatch: loop {
        match pc {
            0x82864400 => {
    //   block [0x82864400..0x8286448C)
	// 82864400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82864404: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82864408: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8286440C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82864410: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82864414: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82864418: 396B069C  addi r11, r11, 0x69c
	ctx.r[11].s64 = ctx.r[11].s64 + 1692;
	// 8286441C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82864420: 807F0098  lwz r3, 0x98(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82864424: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82864428: 419A0008  beq cr6, 0x82864430
	if ctx.cr[6].eq {
	pc = 0x82864430; continue 'dispatch;
	}
	// 8286442C: 4BA5C465  bl 0x822c0890
	ctx.lr = 0x82864430;
	sub_822C0890(ctx, base);
	// 82864430: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 82864434: 4BC05BCD  bl 0x8246a000
	ctx.lr = 0x82864438;
	sub_8246A000(ctx, base);
	// 82864438: 807F007C  lwz r3, 0x7c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 8286443C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82864440: 419A0008  beq cr6, 0x82864448
	if ctx.cr[6].eq {
	pc = 0x82864448; continue 'dispatch;
	}
	// 82864444: 4BA5C44D  bl 0x822c0890
	ctx.lr = 0x82864448;
	sub_822C0890(ctx, base);
	// 82864448: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 8286444C: 4858EFDD  bl 0x82df3428
	ctx.lr = 0x82864450;
	sub_82DF3428(ctx, base);
	// 82864450: 807F0070  lwz r3, 0x70(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82864454: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82864458: 419A0008  beq cr6, 0x82864460
	if ctx.cr[6].eq {
	pc = 0x82864460; continue 'dispatch;
	}
	// 8286445C: 4BA5C435  bl 0x822c0890
	ctx.lr = 0x82864460;
	sub_822C0890(ctx, base);
	// 82864460: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82864464: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82864468: 419A0008  beq cr6, 0x82864470
	if ctx.cr[6].eq {
	pc = 0x82864470; continue 'dispatch;
	}
	// 8286446C: 4BA5C425  bl 0x822c0890
	ctx.lr = 0x82864470;
	sub_822C0890(ctx, base);
	// 82864470: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82864474: 485F8115  bl 0x82e5c588
	ctx.lr = 0x82864478;
	sub_82E5C588(ctx, base);
	// 82864478: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8286447C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82864480: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82864484: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82864488: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82864490 size=76
    let mut pc: u32 = 0x82864490;
    'dispatch: loop {
        match pc {
            0x82864490 => {
    //   block [0x82864490..0x828644DC)
	// 82864490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82864494: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82864498: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286449C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828644A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828644A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828644A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828644AC: 4BFFFF55  bl 0x82864400
	ctx.lr = 0x828644B0;
	sub_82864400(ctx, base);
	// 828644B0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828644B4: 4182000C  beq 0x828644c0
	if ctx.cr[0].eq {
	pc = 0x828644C0; continue 'dispatch;
	}
	// 828644B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828644BC: 4858DF1D  bl 0x82df23d8
	ctx.lr = 0x828644C0;
	sub_82DF23D8(ctx, base);
	// 828644C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828644C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828644C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828644CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828644D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828644D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828644D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828644E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828644E0 size=144
    let mut pc: u32 = 0x828644E0;
    'dispatch: loop {
        match pc {
            0x828644E0 => {
    //   block [0x828644E0..0x82864570)
	// 828644E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828644E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828644E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828644EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828644F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828644F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828644F8: 4BFFE621  bl 0x82862b18
	ctx.lr = 0x828644FC;
	sub_82862B18(ctx, base);
	// 828644FC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82864500: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82864504: 396B069C  addi r11, r11, 0x69c
	ctx.r[11].s64 = ctx.r[11].s64 + 1692;
	// 82864508: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 8286450C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82864510: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 82864514: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82864518: 388AF818  addi r4, r10, -0x7e8
	ctx.r[4].s64 = ctx.r[10].s64 + -2024;
	// 8286451C: 93DF0068  stw r30, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82864520: 93DF006C  stw r30, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82864524: 93DF0070  stw r30, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82864528: 4858F4E1  bl 0x82df3a08
	ctx.lr = 0x8286452C;
	sub_82DF3A08(ctx, base);
	// 8286452C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82864530: 93DF0078  stw r30, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 82864534: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82864538: 93DF007C  stw r30, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 8286453C: 93DF0084  stw r30, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 82864540: 93DF0088  stw r30, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	// 82864544: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82864548: 93DF008C  stw r30, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 8286454C: D01F0090  stfs f0, 0x90(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82864550: 93DF0094  stw r30, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 82864554: 93DF0098  stw r30, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[30].u32 ) };
	// 82864558: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286455C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82864560: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82864564: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82864568: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286456C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82864570 size=688
    let mut pc: u32 = 0x82864570;
    'dispatch: loop {
        match pc {
            0x82864570 => {
    //   block [0x82864570..0x82864820)
	// 82864570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82864574: 48943BE9  bl 0x831a815c
	ctx.lr = 0x82864578;
	sub_831A8130(ctx, base);
	// 82864578: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 8286457C: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82864580: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82864584: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864588: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8286458C: 396B06E0  addi r11, r11, 0x6e0
	ctx.r[11].s64 = ctx.r[11].s64 + 1760;
	// 82864590: 3929C4C0  addi r9, r9, -0x3b40
	ctx.r[9].s64 = ctx.r[9].s64 + -15168;
	// 82864594: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 82864598: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 8286459C: 38C00014  li r6, 0x14
	ctx.r[6].s64 = 20;
	// 828645A0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828645A4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828645A8: 13C048C7  vcmpequd (lvx128) v30, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828645AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82864820 size=272
    let mut pc: u32 = 0x82864820;
    'dispatch: loop {
        match pc {
            0x82864820 => {
    //   block [0x82864820..0x82864930)
	// 82864820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82864824: 48943945  bl 0x831a8168
	ctx.lr = 0x82864828;
	sub_831A8130(ctx, base);
	// 82864828: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286482C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82864830: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82864834: 93C100AC  stw r30, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[30].u32 ) };
	// 82864838: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 8286483C: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82864840: 48000014  b 0x82864854
	pc = 0x82864854; continue 'dispatch;
	// 82864844: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864848: 7F09F040  cmplw cr6, r9, r30
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[30].u32, &mut ctx.xer);
	// 8286484C: 419A00DC  beq cr6, 0x82864928
	if ctx.cr[6].eq {
	pc = 0x82864928; continue 'dispatch;
	}
	// 82864850: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82864854: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82864858: 4198FFEC  blt cr6, 0x82864844
	if ctx.cr[6].lt {
	pc = 0x82864844; continue 'dispatch;
	}
	// 8286485C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82864860: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82864864: 408200BC  bne 0x82864920
	if !ctx.cr[0].eq {
	pc = 0x82864920; continue 'dispatch;
	}
	// 82864868: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 8286486C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82864870: 388BB8D0  addi r4, r11, -0x4730
	ctx.r[4].s64 = ctx.r[11].s64 + -18224;
	// 82864874: 816AB8D4  lwz r11, -0x472c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-18220 as u32) ) } as u64;
	// 82864878: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8286487C: 40820018  bne 0x82864894
	if !ctx.cr[0].eq {
	pc = 0x82864894; continue 'dispatch;
	}
	// 82864880: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 82864884: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82864888: 916AB8D4  stw r11, -0x472c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-18220 as u32), ctx.r[11].u32 ) };
	// 8286488C: 8169861C  lwz r11, -0x79e4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-31204 as u32) ) } as u64;
	// 82864890: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82864894: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82864898: 4BFA75F9  bl 0x8280be90
	ctx.lr = 0x8286489C;
	sub_8280BE90(ctx, base);
	// 8286489C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828648A0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828648A4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828648A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828648AC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828648B0: 419A0024  beq cr6, 0x828648d4
	if ctx.cr[6].eq {
	pc = 0x828648D4; continue 'dispatch;
	}
	// 828648B4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828648B8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828648BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828648C0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828648C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828648C8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828648CC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828648D0: 4082FFE8  bne 0x828648b8
	if !ctx.cr[0].eq {
	pc = 0x828648B8; continue 'dispatch;
	}
	// 828648D4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828648D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828648DC: 3BAB0640  addi r29, r11, 0x640
	ctx.r[29].s64 = ctx.r[11].s64 + 1600;
	// 828648E0: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 828648E4: 481ABF8D  bl 0x82a10870
	ctx.lr = 0x828648E8;
	sub_82A10870(ctx, base);
	// 828648E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828648EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828648F0: 38A000D5  li r5, 0xd5
	ctx.r[5].s64 = 213;
	// 828648F4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 828648F8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828648FC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82864900: 4BF8B259  bl 0x827efb58
	ctx.lr = 0x82864904;
	sub_827EFB58(ctx, base);
	// 82864904: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82864908: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286490C: 419A0008  beq cr6, 0x82864914
	if ctx.cr[6].eq {
	pc = 0x82864914; continue 'dispatch;
	}
	// 82864910: 4BA5BF81  bl 0x822c0890
	ctx.lr = 0x82864914;
	sub_822C0890(ctx, base);
	// 82864914: 388100AC  addi r4, r1, 0xac
	ctx.r[4].s64 = ctx.r[1].s64 + 172;
	// 82864918: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 8286491C: 4BC547F5  bl 0x824b9110
	ctx.lr = 0x82864920;
	sub_824B9110(ctx, base);
	// 82864920: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82864924: 48943894  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
	// 82864928: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8286492C: 4BFFFF34  b 0x82864860
	pc = 0x82864860; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82864930 size=656
    let mut pc: u32 = 0x82864930;
    'dispatch: loop {
        match pc {
            0x82864930 => {
    //   block [0x82864930..0x82864BC0)
	// 82864930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82864934: 48943831  bl 0x831a8164
	ctx.lr = 0x82864938;
	sub_831A8130(ctx, base);
	// 82864938: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286493C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82864940: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82864944: 807E0064  lwz r3, 0x64(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 82864948: 4BA94E59  bl 0x822f97a0
	ctx.lr = 0x8286494C;
	sub_822F97A0(ctx, base);
	// 8286494C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82864950: C00BD7BC  lfs f0, -0x2844(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82864954: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82864958: 41980260  blt cr6, 0x82864bb8
	if ctx.cr[6].lt {
	pc = 0x82864BB8; continue 'dispatch;
	}
	// 8286495C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82864960: C00B0A98  lfs f0, 0xa98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82864964: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82864968: 41990250  bgt cr6, 0x82864bb8
	if ctx.cr[6].gt {
	pc = 0x82864BB8; continue 'dispatch;
	}
	// 8286496C: 817E0094  lwz r11, 0x94(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) } as u64;
	// 82864970: 3BFE0094  addi r31, r30, 0x94
	ctx.r[31].s64 = ctx.r[30].s64 + 148;
	// 82864974: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82864978: 409A00AC  bne cr6, 0x82864a24
	if !ctx.cr[6].eq {
	pc = 0x82864A24; continue 'dispatch;
	}
	// 8286497C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82864980: 4BF88E99  bl 0x827ed818
	ctx.lr = 0x82864984;
	sub_827ED818(ctx, base);
	// 82864984: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82864988: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8286498C: 4BCAAB3D  bl 0x8250f4c8
	ctx.lr = 0x82864990;
	sub_8250F4C8(ctx, base);
	// 82864990: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864994: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82864998: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 8286499C: 409A0008  bne cr6, 0x828649a4
	if !ctx.cr[6].eq {
	pc = 0x828649A4; continue 'dispatch;
	}
	// 828649A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828649A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828649A8: 4BCA5FA9  bl 0x8250a950
	ctx.lr = 0x828649AC;
	sub_8250A950(ctx, base);
	// 828649AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828649B0: 4858D2E1  bl 0x82df1c90
	ctx.lr = 0x828649B4;
	sub_82DF1C90(ctx, base);
	// 828649B4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828649B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828649BC: 388B06F0  addi r4, r11, 0x6f0
	ctx.r[4].s64 = ctx.r[11].s64 + 1776;
	// 828649C0: 4858F049  bl 0x82df3a08
	ctx.lr = 0x828649C4;
	sub_82DF3A08(ctx, base);
	// 828649C4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828649C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828649CC: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 828649D0: 409A0008  bne cr6, 0x828649d8
	if !ctx.cr[6].eq {
	pc = 0x828649D8; continue 'dispatch;
	}
	// 828649D4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828649D8: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828649DC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828649E0: 38BE0078  addi r5, r30, 0x78
	ctx.r[5].s64 = ctx.r[30].s64 + 120;
	// 828649E4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828649E8: 4BF702C9  bl 0x827d4cb0
	ctx.lr = 0x828649EC;
	sub_827D4CB0(ctx, base);
	// 828649EC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828649F0: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 828649F4: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 828649F8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828649FC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82864A00: 4BA5FA61  bl 0x822c4460
	ctx.lr = 0x82864A04;
	sub_822C4460(ctx, base);
	// 82864A04: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82864A08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82864A0C: 419A0008  beq cr6, 0x82864a14
	if ctx.cr[6].eq {
	pc = 0x82864A14; continue 'dispatch;
	}
	// 82864A10: 4BA5BE81  bl 0x822c0890
	ctx.lr = 0x82864A14;
	sub_822C0890(ctx, base);
	// 82864A14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82864A18: 4858EA11  bl 0x82df3428
	ctx.lr = 0x82864A1C;
	sub_82DF3428(ctx, base);
	// 82864A1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82864A20: 4858D271  bl 0x82df1c90
	ctx.lr = 0x82864A24;
	sub_82DF1C90(ctx, base);
	// 82864A24: 807E0078  lwz r3, 0x78(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) } as u64;
	// 82864A28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864A2C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82864A30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82864A34: 4E800421  bctrl
	ctx.lr = 0x82864A38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82864A38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82864A3C: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 82864A40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82864A44: C01F003C  lfs f0, 0x3c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82864A48: C1BF0038  lfs f13, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82864A4C: C19F0034  lfs f12, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82864A50: C17F0030  lfs f11, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82864A54: D1610080  stfs f11, 0x80(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82864A58: D1810084  stfs f12, 0x84(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82864A5C: D1A10088  stfs f13, 0x88(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82864A60: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82864A64: 419A0074  beq cr6, 0x82864ad8
	if ctx.cr[6].eq {
	pc = 0x82864AD8; continue 'dispatch;
	}
	// 82864A68: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82864A6C: 4BF88DC5  bl 0x827ed830
	ctx.lr = 0x82864A70;
	sub_827ED830(ctx, base);
	// 82864A70: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82864A74: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82864A78: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82864A7C: 4BF8A02D  bl 0x827eeaa8
	ctx.lr = 0x82864A80;
	sub_827EEAA8(ctx, base);
	// 82864A80: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82864A84: C1A10094  lfs f13, 0x94(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82864A88: C00B9524  lfs f0, -0x6adc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82864A8C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82864A90: 4099000C  ble cr6, 0x82864a9c
	if !ctx.cr[6].gt {
	pc = 0x82864A9C; continue 'dispatch;
	}
	// 82864A94: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82864A98: 48000014  b 0x82864aac
	pc = 0x82864AAC; continue 'dispatch;
	// 82864A9C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82864AA0: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82864AA4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82864AA8: 41980008  blt cr6, 0x82864ab0
	if ctx.cr[6].lt {
	pc = 0x82864AB0; continue 'dispatch;
	}
	// 82864AAC: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82864AB0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82864AB4: C19E0090  lfs f12, 0x90(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82864AB8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82864ABC: 807E0064  lwz r3, 0x64(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 82864AC0: C1AB9450  lfs f13, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82864AC4: EDA06378  fmsubs f13, f0, f13, f12
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82864AC8: C00A964C  lfs f0, -0x69b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82864ACC: EC2D603A  fmadds f1, f13, f0, f12
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82864AD0: D03E0090  stfs f1, 0x90(r30)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82864AD4: 4BA9A36D  bl 0x822fee40
	ctx.lr = 0x82864AD8;
	sub_822FEE40(ctx, base);
	// 82864AD8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82864ADC: 4BC019FD  bl 0x824664d8
	ctx.lr = 0x82864AE0;
	sub_824664D8(ctx, base);
	// 82864AE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82864AE4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82864AE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82864AEC: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82864AF0: 807E006C  lwz r3, 0x6c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82864AF4: 4BC2D49D  bl 0x82491f90
	ctx.lr = 0x82864AF8;
	sub_82491F90(ctx, base);
	// 82864AF8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82864AFC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82864B00: 807E006C  lwz r3, 0x6c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82864B04: 4BC2D44D  bl 0x82491f50
	ctx.lr = 0x82864B08;
	sub_82491F50(ctx, base);
	// 82864B08: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82864B0C: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 82864B10: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864B14: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82864B18: 419A0088  beq cr6, 0x82864ba0
	if ctx.cr[6].eq {
	pc = 0x82864BA0; continue 'dispatch;
	}
	// 82864B1C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82864B20: 3B8B6910  addi r28, r11, 0x6910
	ctx.r[28].s64 = ctx.r[11].s64 + 26896;
	// 82864B24: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82864B28: 4BF754A9  bl 0x827d9fd0
	ctx.lr = 0x82864B2C;
	sub_827D9FD0(ctx, base);
	// 82864B2C: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82864B30: 41820064  beq 0x82864b94
	if ctx.cr[0].eq {
	pc = 0x82864B94; continue 'dispatch;
	}
	// 82864B34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82864B38: 487A4481  bl 0x83008fb8
	ctx.lr = 0x82864B3C;
	sub_83008FB8(ctx, base);
	// 82864B3C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82864B40: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82864B44: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82864B48: 4BFFF801  bl 0x82864348
	ctx.lr = 0x82864B4C;
	sub_82864348(ctx, base);
	// 82864B4C: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 82864B50: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 82864B54: 392100B0  addi r9, r1, 0xb0
	ctx.r[9].s64 = ctx.r[1].s64 + 176;
	// 82864B58: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82864B5C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82864B60: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82864B64: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82864BC0 size=12
    let mut pc: u32 = 0x82864BC0;
    'dispatch: loop {
        match pc {
            0x82864BC0 => {
    //   block [0x82864BC0..0x82864BCC)
	// 82864BC0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82864BC4: 386BB8D8  addi r3, r11, -0x4728
	ctx.r[3].s64 = ctx.r[11].s64 + -18216;
	// 82864BC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82864BD0 size=196
    let mut pc: u32 = 0x82864BD0;
    'dispatch: loop {
        match pc {
            0x82864BD0 => {
    //   block [0x82864BD0..0x82864C94)
	// 82864BD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82864BD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82864BD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82864BDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82864BE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82864BE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82864BE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82864BEC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82864BF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82864BF4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82864BF8: 4BA5BD41  bl 0x822c0938
	ctx.lr = 0x82864BFC;
	sub_822C0938(ctx, base);
	// 82864BFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82864C00: 41820028  beq 0x82864c28
	if ctx.cr[0].eq {
	pc = 0x82864C28; continue 'dispatch;
	}
	// 82864C04: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82864C08: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82864C0C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82864C10: 392B0704  addi r9, r11, 0x704
	ctx.r[9].s64 = ctx.r[11].s64 + 1796;
	// 82864C14: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82864C18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82864C1C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82864C20: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82864C24: 48000008  b 0x82864c2c
	pc = 0x82864C2C; continue 'dispatch;
	// 82864C28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82864C2C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82864C30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82864C34: 409A0044  bne cr6, 0x82864c78
	if !ctx.cr[6].eq {
	pc = 0x82864C78; continue 'dispatch;
	}
	// 82864C38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82864C3C: 419A001C  beq cr6, 0x82864c58
	if ctx.cr[6].eq {
	pc = 0x82864C58; continue 'dispatch;
	}
	// 82864C40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864C44: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82864C48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82864C4C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864C50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82864C54: 4E800421  bctrl
	ctx.lr = 0x82864C58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82864C58: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82864C5C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82864C60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82864C64: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82864C68: 816B527C  lwz r11, 0x527c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(21116 as u32) ) } as u64;
	// 82864C6C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82864C70: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82864C74: 4BA5B38D  bl 0x822c0000
	ctx.lr = 0x82864C78;
	sub_822C0000(ctx, base);
	// 82864C78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82864C7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82864C80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82864C84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82864C88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82864C8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82864C90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82864C98 size=196
    let mut pc: u32 = 0x82864C98;
    'dispatch: loop {
        match pc {
            0x82864C98 => {
    //   block [0x82864C98..0x82864D5C)
	// 82864C98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82864C9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82864CA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82864CA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82864CA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82864CAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82864CB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82864CB4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82864CB8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82864CBC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82864CC0: 4BA5BC79  bl 0x822c0938
	ctx.lr = 0x82864CC4;
	sub_822C0938(ctx, base);
	// 82864CC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82864CC8: 41820028  beq 0x82864cf0
	if ctx.cr[0].eq {
	pc = 0x82864CF0; continue 'dispatch;
	}
	// 82864CCC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82864CD0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82864CD4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82864CD8: 392B0718  addi r9, r11, 0x718
	ctx.r[9].s64 = ctx.r[11].s64 + 1816;
	// 82864CDC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82864CE0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82864CE4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82864CE8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82864CEC: 48000008  b 0x82864cf4
	pc = 0x82864CF4; continue 'dispatch;
	// 82864CF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82864CF4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82864CF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82864CFC: 409A0044  bne cr6, 0x82864d40
	if !ctx.cr[6].eq {
	pc = 0x82864D40; continue 'dispatch;
	}
	// 82864D00: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82864D04: 419A001C  beq cr6, 0x82864d20
	if ctx.cr[6].eq {
	pc = 0x82864D20; continue 'dispatch;
	}
	// 82864D08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864D0C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82864D10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82864D14: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864D18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82864D1C: 4E800421  bctrl
	ctx.lr = 0x82864D20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82864D20: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82864D24: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82864D28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82864D2C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82864D30: 816B527C  lwz r11, 0x527c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(21116 as u32) ) } as u64;
	// 82864D34: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82864D38: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82864D3C: 4BA5B2C5  bl 0x822c0000
	ctx.lr = 0x82864D40;
	sub_822C0000(ctx, base);
	// 82864D40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82864D44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82864D48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82864D4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82864D50: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82864D54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82864D58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864D60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82864D60 size=196
    let mut pc: u32 = 0x82864D60;
    'dispatch: loop {
        match pc {
            0x82864D60 => {
    //   block [0x82864D60..0x82864E24)
	// 82864D60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82864D64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82864D68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82864D6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82864D70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82864D74: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82864D78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82864D7C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82864D80: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82864D84: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82864D88: 4BA5BBB1  bl 0x822c0938
	ctx.lr = 0x82864D8C;
	sub_822C0938(ctx, base);
	// 82864D8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82864D90: 41820028  beq 0x82864db8
	if ctx.cr[0].eq {
	pc = 0x82864DB8; continue 'dispatch;
	}
	// 82864D94: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82864D98: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82864D9C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82864DA0: 392B072C  addi r9, r11, 0x72c
	ctx.r[9].s64 = ctx.r[11].s64 + 1836;
	// 82864DA4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82864DA8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82864DAC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82864DB0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82864DB4: 48000008  b 0x82864dbc
	pc = 0x82864DBC; continue 'dispatch;
	// 82864DB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82864DBC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82864DC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82864DC4: 409A0044  bne cr6, 0x82864e08
	if !ctx.cr[6].eq {
	pc = 0x82864E08; continue 'dispatch;
	}
	// 82864DC8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82864DCC: 419A001C  beq cr6, 0x82864de8
	if ctx.cr[6].eq {
	pc = 0x82864DE8; continue 'dispatch;
	}
	// 82864DD0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864DD4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82864DD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82864DDC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864DE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82864DE4: 4E800421  bctrl
	ctx.lr = 0x82864DE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82864DE8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82864DEC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82864DF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82864DF4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82864DF8: 816B527C  lwz r11, 0x527c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(21116 as u32) ) } as u64;
	// 82864DFC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82864E00: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82864E04: 4BA5B1FD  bl 0x822c0000
	ctx.lr = 0x82864E08;
	sub_822C0000(ctx, base);
	// 82864E08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82864E0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82864E10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82864E14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82864E18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82864E1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82864E20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82864E28 size=196
    let mut pc: u32 = 0x82864E28;
    'dispatch: loop {
        match pc {
            0x82864E28 => {
    //   block [0x82864E28..0x82864EEC)
	// 82864E28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82864E2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82864E30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82864E34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82864E38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82864E3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82864E40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82864E44: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82864E48: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82864E4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82864E50: 4BA5BAE9  bl 0x822c0938
	ctx.lr = 0x82864E54;
	sub_822C0938(ctx, base);
	// 82864E54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82864E58: 41820028  beq 0x82864e80
	if ctx.cr[0].eq {
	pc = 0x82864E80; continue 'dispatch;
	}
	// 82864E5C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82864E60: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82864E64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82864E68: 392B0740  addi r9, r11, 0x740
	ctx.r[9].s64 = ctx.r[11].s64 + 1856;
	// 82864E6C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82864E70: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82864E74: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82864E78: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82864E7C: 48000008  b 0x82864e84
	pc = 0x82864E84; continue 'dispatch;
	// 82864E80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82864E84: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82864E88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82864E8C: 409A0044  bne cr6, 0x82864ed0
	if !ctx.cr[6].eq {
	pc = 0x82864ED0; continue 'dispatch;
	}
	// 82864E90: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82864E94: 419A001C  beq cr6, 0x82864eb0
	if ctx.cr[6].eq {
	pc = 0x82864EB0; continue 'dispatch;
	}
	// 82864E98: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864E9C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82864EA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82864EA4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864EA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82864EAC: 4E800421  bctrl
	ctx.lr = 0x82864EB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82864EB0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82864EB4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82864EB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82864EBC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82864EC0: 816B527C  lwz r11, 0x527c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(21116 as u32) ) } as u64;
	// 82864EC4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82864EC8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82864ECC: 4BA5B135  bl 0x822c0000
	ctx.lr = 0x82864ED0;
	sub_822C0000(ctx, base);
	// 82864ED0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82864ED4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82864ED8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82864EDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82864EE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82864EE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82864EE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82864EF0 size=196
    let mut pc: u32 = 0x82864EF0;
    'dispatch: loop {
        match pc {
            0x82864EF0 => {
    //   block [0x82864EF0..0x82864FB4)
	// 82864EF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82864EF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82864EF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82864EFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82864F00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82864F04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82864F08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82864F0C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82864F10: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82864F14: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82864F18: 4BA5BA21  bl 0x822c0938
	ctx.lr = 0x82864F1C;
	sub_822C0938(ctx, base);
	// 82864F1C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82864F20: 41820028  beq 0x82864f48
	if ctx.cr[0].eq {
	pc = 0x82864F48; continue 'dispatch;
	}
	// 82864F24: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82864F28: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82864F2C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82864F30: 392B0754  addi r9, r11, 0x754
	ctx.r[9].s64 = ctx.r[11].s64 + 1876;
	// 82864F34: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82864F38: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82864F3C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82864F40: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82864F44: 48000008  b 0x82864f4c
	pc = 0x82864F4C; continue 'dispatch;
	// 82864F48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82864F4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82864F50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82864F54: 409A0044  bne cr6, 0x82864f98
	if !ctx.cr[6].eq {
	pc = 0x82864F98; continue 'dispatch;
	}
	// 82864F58: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82864F5C: 419A001C  beq cr6, 0x82864f78
	if ctx.cr[6].eq {
	pc = 0x82864F78; continue 'dispatch;
	}
	// 82864F60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82864F64: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82864F68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82864F6C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82864F70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82864F74: 4E800421  bctrl
	ctx.lr = 0x82864F78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82864F78: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82864F7C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82864F80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82864F84: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82864F88: 816B527C  lwz r11, 0x527c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(21116 as u32) ) } as u64;
	// 82864F8C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82864F90: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82864F94: 4BA5B06D  bl 0x822c0000
	ctx.lr = 0x82864F98;
	sub_822C0000(ctx, base);
	// 82864F98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82864F9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82864FA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82864FA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82864FA8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82864FAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82864FB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82864FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82864FB8 size=196
    let mut pc: u32 = 0x82864FB8;
    'dispatch: loop {
        match pc {
            0x82864FB8 => {
    //   block [0x82864FB8..0x8286507C)
	// 82864FB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82864FBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82864FC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82864FC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82864FC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82864FCC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82864FD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82864FD4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82864FD8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82864FDC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82864FE0: 4BA5B959  bl 0x822c0938
	ctx.lr = 0x82864FE4;
	sub_822C0938(ctx, base);
	// 82864FE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82864FE8: 41820028  beq 0x82865010
	if ctx.cr[0].eq {
	pc = 0x82865010; continue 'dispatch;
	}
	// 82864FEC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82864FF0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82864FF4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82864FF8: 392B0768  addi r9, r11, 0x768
	ctx.r[9].s64 = ctx.r[11].s64 + 1896;
	// 82864FFC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82865000: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82865004: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82865008: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8286500C: 48000008  b 0x82865014
	pc = 0x82865014; continue 'dispatch;
	// 82865010: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82865014: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82865018: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286501C: 409A0044  bne cr6, 0x82865060
	if !ctx.cr[6].eq {
	pc = 0x82865060; continue 'dispatch;
	}
	// 82865020: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82865024: 419A001C  beq cr6, 0x82865040
	if ctx.cr[6].eq {
	pc = 0x82865040; continue 'dispatch;
	}
	// 82865028: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286502C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82865030: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82865034: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82865038: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8286503C: 4E800421  bctrl
	ctx.lr = 0x82865040;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82865040: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82865044: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82865048: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286504C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82865050: 816B527C  lwz r11, 0x527c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(21116 as u32) ) } as u64;
	// 82865054: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82865058: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8286505C: 4BA5AFA5  bl 0x822c0000
	ctx.lr = 0x82865060;
	sub_822C0000(ctx, base);
	// 82865060: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82865064: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82865068: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286506C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82865070: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82865074: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82865078: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82865080 size=196
    let mut pc: u32 = 0x82865080;
    'dispatch: loop {
        match pc {
            0x82865080 => {
    //   block [0x82865080..0x82865144)
	// 82865080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82865084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82865088: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286508C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82865090: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82865094: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82865098: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8286509C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828650A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828650A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828650A8: 4BA5B891  bl 0x822c0938
	ctx.lr = 0x828650AC;
	sub_822C0938(ctx, base);
	// 828650AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828650B0: 41820028  beq 0x828650d8
	if ctx.cr[0].eq {
	pc = 0x828650D8; continue 'dispatch;
	}
	// 828650B4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828650B8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828650BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828650C0: 392B077C  addi r9, r11, 0x77c
	ctx.r[9].s64 = ctx.r[11].s64 + 1916;
	// 828650C4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828650C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828650CC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828650D0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828650D4: 48000008  b 0x828650dc
	pc = 0x828650DC; continue 'dispatch;
	// 828650D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828650DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828650E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828650E4: 409A0044  bne cr6, 0x82865128
	if !ctx.cr[6].eq {
	pc = 0x82865128; continue 'dispatch;
	}
	// 828650E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828650EC: 419A001C  beq cr6, 0x82865108
	if ctx.cr[6].eq {
	pc = 0x82865108; continue 'dispatch;
	}
	// 828650F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828650F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828650F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828650FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82865100: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82865104: 4E800421  bctrl
	ctx.lr = 0x82865108;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82865108: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8286510C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82865110: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82865114: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82865118: 816B527C  lwz r11, 0x527c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(21116 as u32) ) } as u64;
	// 8286511C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82865120: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82865124: 4BA5AEDD  bl 0x822c0000
	ctx.lr = 0x82865128;
	sub_822C0000(ctx, base);
	// 82865128: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8286512C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82865130: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82865134: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82865138: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8286513C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82865140: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82865148 size=112
    let mut pc: u32 = 0x82865148;
    'dispatch: loop {
        match pc {
            0x82865148 => {
    //   block [0x82865148..0x828651B8)
	// 82865148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286514C: 48943021  bl 0x831a816c
	ctx.lr = 0x82865150;
	sub_831A8130(ctx, base);
	// 82865150: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82865154: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82865158: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8286515C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82865160: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82865164: 38A00053  li r5, 0x53
	ctx.r[5].s64 = 83;
	// 82865168: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 8286516C: 4858D27D  bl 0x82df23e8
	ctx.lr = 0x82865170;
	sub_82DF23E8(ctx, base);
	// 82865170: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82865174: 41820010  beq 0x82865184
	if ctx.cr[0].eq {
	pc = 0x82865184; continue 'dispatch;
	}
	// 82865178: 4BFFEA81  bl 0x82863bf8
	ctx.lr = 0x8286517C;
	sub_82863BF8(ctx, base);
	// 8286517C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82865180: 48000008  b 0x82865188
	pc = 0x82865188; continue 'dispatch;
	// 82865184: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82865188: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8286518C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82865190: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82865194: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82865198: 4BFFFA39  bl 0x82864bd0
	ctx.lr = 0x8286519C;
	sub_82864BD0(ctx, base);
	// 8286519C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828651A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828651A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828651A8: 4BA5AE59  bl 0x822c0000
	ctx.lr = 0x828651AC;
	sub_822C0000(ctx, base);
	// 828651AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828651B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828651B4: 48943008  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828651B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828651B8 size=112
    let mut pc: u32 = 0x828651B8;
    'dispatch: loop {
        match pc {
            0x828651B8 => {
    //   block [0x828651B8..0x82865228)
	// 828651B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828651BC: 48942FB1  bl 0x831a816c
	ctx.lr = 0x828651C0;
	sub_831A8130(ctx, base);
	// 828651C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828651C4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828651C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828651CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828651D0: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828651D4: 38A00053  li r5, 0x53
	ctx.r[5].s64 = 83;
	// 828651D8: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828651DC: 4858D20D  bl 0x82df23e8
	ctx.lr = 0x828651E0;
	sub_82DF23E8(ctx, base);
	// 828651E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828651E4: 41820010  beq 0x828651f4
	if ctx.cr[0].eq {
	pc = 0x828651F4; continue 'dispatch;
	}
	// 828651E8: 48000429  bl 0x82865610
	ctx.lr = 0x828651EC;
	sub_82865610(ctx, base);
	// 828651EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828651F0: 48000008  b 0x828651f8
	pc = 0x828651F8; continue 'dispatch;
	// 828651F4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828651F8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828651FC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82865200: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82865204: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82865208: 4BFFFA91  bl 0x82864c98
	ctx.lr = 0x8286520C;
	sub_82864C98(ctx, base);
	// 8286520C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82865210: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82865214: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82865218: 4BA5ADE9  bl 0x822c0000
	ctx.lr = 0x8286521C;
	sub_822C0000(ctx, base);
	// 8286521C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82865220: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82865224: 48942F98  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82865228 size=112
    let mut pc: u32 = 0x82865228;
    'dispatch: loop {
        match pc {
            0x82865228 => {
    //   block [0x82865228..0x82865298)
	// 82865228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286522C: 48942F41  bl 0x831a816c
	ctx.lr = 0x82865230;
	sub_831A8130(ctx, base);
	// 82865230: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82865234: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82865238: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8286523C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82865240: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82865244: 38A00053  li r5, 0x53
	ctx.r[5].s64 = 83;
	// 82865248: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 8286524C: 4858D19D  bl 0x82df23e8
	ctx.lr = 0x82865250;
	sub_82DF23E8(ctx, base);
	// 82865250: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82865254: 41820010  beq 0x82865264
	if ctx.cr[0].eq {
	pc = 0x82865264; continue 'dispatch;
	}
	// 82865258: 4BFFCED1  bl 0x82862128
	ctx.lr = 0x8286525C;
	sub_82862128(ctx, base);
	// 8286525C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82865260: 48000008  b 0x82865268
	pc = 0x82865268; continue 'dispatch;
	// 82865264: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82865268: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8286526C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82865270: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82865274: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82865278: 4BFFFAE9  bl 0x82864d60
	ctx.lr = 0x8286527C;
	sub_82864D60(ctx, base);
	// 8286527C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82865280: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82865284: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82865288: 4BA5AD79  bl 0x822c0000
	ctx.lr = 0x8286528C;
	sub_822C0000(ctx, base);
	// 8286528C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82865290: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82865294: 48942F28  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82865298 size=112
    let mut pc: u32 = 0x82865298;
    'dispatch: loop {
        match pc {
            0x82865298 => {
    //   block [0x82865298..0x82865308)
	// 82865298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286529C: 48942ED1  bl 0x831a816c
	ctx.lr = 0x828652A0;
	sub_831A8130(ctx, base);
	// 828652A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828652A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828652A8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828652AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828652B0: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828652B4: 38A00053  li r5, 0x53
	ctx.r[5].s64 = 83;
	// 828652B8: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 828652BC: 4858D12D  bl 0x82df23e8
	ctx.lr = 0x828652C0;
	sub_82DF23E8(ctx, base);
	// 828652C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828652C4: 41820010  beq 0x828652d4
	if ctx.cr[0].eq {
	pc = 0x828652D4; continue 'dispatch;
	}
	// 828652C8: 4BFFD0B9  bl 0x82862380
	ctx.lr = 0x828652CC;
	sub_82862380(ctx, base);
	// 828652CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828652D0: 48000008  b 0x828652d8
	pc = 0x828652D8; continue 'dispatch;
	// 828652D4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828652D8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828652DC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828652E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828652E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828652E8: 4BFFFB41  bl 0x82864e28
	ctx.lr = 0x828652EC;
	sub_82864E28(ctx, base);
	// 828652EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828652F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828652F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828652F8: 4BA5AD09  bl 0x822c0000
	ctx.lr = 0x828652FC;
	sub_822C0000(ctx, base);
	// 828652FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82865300: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82865304: 48942EB8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82865308 size=112
    let mut pc: u32 = 0x82865308;
    'dispatch: loop {
        match pc {
            0x82865308 => {
    //   block [0x82865308..0x82865378)
	// 82865308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286530C: 48942E61  bl 0x831a816c
	ctx.lr = 0x82865310;
	sub_831A8130(ctx, base);
	// 82865310: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82865314: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82865318: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8286531C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82865320: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82865324: 38A00053  li r5, 0x53
	ctx.r[5].s64 = 83;
	// 82865328: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 8286532C: 4858D0BD  bl 0x82df23e8
	ctx.lr = 0x82865330;
	sub_82DF23E8(ctx, base);
	// 82865330: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82865334: 41820010  beq 0x82865344
	if ctx.cr[0].eq {
	pc = 0x82865344; continue 'dispatch;
	}
	// 82865338: 48000EB1  bl 0x828661e8
	ctx.lr = 0x8286533C;
	sub_828661E8(ctx, base);
	// 8286533C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82865340: 48000008  b 0x82865348
	pc = 0x82865348; continue 'dispatch;
	// 82865344: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82865348: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8286534C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82865350: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82865354: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82865358: 4BFFFB99  bl 0x82864ef0
	ctx.lr = 0x8286535C;
	sub_82864EF0(ctx, base);
	// 8286535C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82865360: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82865364: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82865368: 4BA5AC99  bl 0x822c0000
	ctx.lr = 0x8286536C;
	sub_822C0000(ctx, base);
	// 8286536C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82865370: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82865374: 48942E48  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82865378 size=112
    let mut pc: u32 = 0x82865378;
    'dispatch: loop {
        match pc {
            0x82865378 => {
    //   block [0x82865378..0x828653E8)
	// 82865378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286537C: 48942DF1  bl 0x831a816c
	ctx.lr = 0x82865380;
	sub_831A8130(ctx, base);
	// 82865380: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82865384: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82865388: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8286538C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82865390: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82865394: 38A00053  li r5, 0x53
	ctx.r[5].s64 = 83;
	// 82865398: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 8286539C: 4858D04D  bl 0x82df23e8
	ctx.lr = 0x828653A0;
	sub_82DF23E8(ctx, base);
	// 828653A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828653A4: 41820010  beq 0x828653b4
	if ctx.cr[0].eq {
	pc = 0x828653B4; continue 'dispatch;
	}
	// 828653A8: 48000ED9  bl 0x82866280
	ctx.lr = 0x828653AC;
	sub_82866280(ctx, base);
	// 828653AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828653B0: 48000008  b 0x828653b8
	pc = 0x828653B8; continue 'dispatch;
	// 828653B4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828653B8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828653BC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828653C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828653C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828653C8: 4BFFFBF1  bl 0x82864fb8
	ctx.lr = 0x828653CC;
	sub_82864FB8(ctx, base);
	// 828653CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828653D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828653D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828653D8: 4BA5AC29  bl 0x822c0000
	ctx.lr = 0x828653DC;
	sub_822C0000(ctx, base);
	// 828653DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828653E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828653E4: 48942DD8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828653E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828653E8 size=112
    let mut pc: u32 = 0x828653E8;
    'dispatch: loop {
        match pc {
            0x828653E8 => {
    //   block [0x828653E8..0x82865458)
	// 828653E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828653EC: 48942D81  bl 0x831a816c
	ctx.lr = 0x828653F0;
	sub_831A8130(ctx, base);
	// 828653F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828653F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828653F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828653FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82865400: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82865404: 38A00053  li r5, 0x53
	ctx.r[5].s64 = 83;
	// 82865408: 3860009C  li r3, 0x9c
	ctx.r[3].s64 = 156;
	// 8286540C: 4858CFDD  bl 0x82df23e8
	ctx.lr = 0x82865410;
	sub_82DF23E8(ctx, base);
	// 82865410: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82865414: 41820010  beq 0x82865424
	if ctx.cr[0].eq {
	pc = 0x82865424; continue 'dispatch;
	}
	// 82865418: 4BFFF0C9  bl 0x828644e0
	ctx.lr = 0x8286541C;
	sub_828644E0(ctx, base);
	// 8286541C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82865420: 48000008  b 0x82865428
	pc = 0x82865428; continue 'dispatch;
	// 82865424: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82865428: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8286542C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82865430: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82865434: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82865438: 4BFFFC49  bl 0x82865080
	ctx.lr = 0x8286543C;
	sub_82865080(ctx, base);
	// 8286543C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82865440: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82865444: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82865448: 4BA5ABB9  bl 0x822c0000
	ctx.lr = 0x8286544C;
	sub_822C0000(ctx, base);
	// 8286544C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82865450: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82865454: 48942D68  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82865458 size=104
    let mut pc: u32 = 0x82865458;
    'dispatch: loop {
        match pc {
            0x82865458 => {
    //   block [0x82865458..0x828654C0)
	// 82865458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286545C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82865460: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82865464: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82865468: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286546C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82865470: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82865474: 4BFFD6A5  bl 0x82862b18
	ctx.lr = 0x82865478;
	sub_82862B18(ctx, base);
	// 82865478: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8286547C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82865480: 396B07B4  addi r11, r11, 0x7b4
	ctx.r[11].s64 = ctx.r[11].s64 + 1972;
	// 82865484: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82865488: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8286548C: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82865490: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82865494: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82865498: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8286549C: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828654A0: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828654A4: D01F007C  stfs f0, 0x7c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 828654A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828654AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828654B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828654B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828654B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828654BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828654C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828654C0 size=160
    let mut pc: u32 = 0x828654C0;
    'dispatch: loop {
        match pc {
            0x828654C0 => {
    //   block [0x828654C0..0x82865560)
	// 828654C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828654C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828654C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828654CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828654D0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828654D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828654D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828654DC: 4BFFD63D  bl 0x82862b18
	ctx.lr = 0x828654E0;
	sub_82862B18(ctx, base);
	// 828654E0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828654E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828654E8: 396B07B4  addi r11, r11, 0x7b4
	ctx.r[11].s64 = ctx.r[11].s64 + 1972;
	// 828654EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828654F0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828654F4: 48617F5D  bl 0x82e7d450
	ctx.lr = 0x828654F8;
	sub_82E7D450(ctx, base);
	// 828654F8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828654FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82865500: 3BCBCA90  addi r30, r11, -0x3570
	ctx.r[30].s64 = ctx.r[11].s64 + -13680;
	// 82865504: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82865508: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8286550C: 48617E15  bl 0x82e7d320
	ctx.lr = 0x82865510;
	sub_82E7D320(ctx, base);
	// 82865510: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82865514: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82865518: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8286551C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82865520: 48617B41  bl 0x82e7d060
	ctx.lr = 0x82865524;
	sub_82E7D060(ctx, base);
	// 82865524: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82865528: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8286552C: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82865530: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82865534: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82865538: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8286553C: C003000C  lfs f0, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82865540: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82865544: D01F007C  stfs f0, 0x7c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82865548: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8286554C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82865550: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82865554: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82865558: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286555C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82865560 size=88
    let mut pc: u32 = 0x82865560;
    'dispatch: loop {
        match pc {
            0x82865560 => {
    //   block [0x82865560..0x828655B8)
	// 82865560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82865564: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82865568: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286556C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82865570: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82865574: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82865578: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8286557C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82865580: 396B07B4  addi r11, r11, 0x7b4
	ctx.r[11].s64 = ctx.r[11].s64 + 1972;
	// 82865584: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82865588: 485F7001  bl 0x82e5c588
	ctx.lr = 0x8286558C;
	sub_82E5C588(ctx, base);
	// 8286558C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82865590: 4182000C  beq 0x8286559c
	if ctx.cr[0].eq {
	pc = 0x8286559C; continue 'dispatch;
	}
	// 82865594: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82865598: 4858CE41  bl 0x82df23d8
	ctx.lr = 0x8286559C;
	sub_82DF23D8(ctx, base);
	// 8286559C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828655A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828655A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828655A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828655AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828655B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828655B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828655B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828655B8 size=88
    let mut pc: u32 = 0x828655B8;
    'dispatch: loop {
        match pc {
            0x828655B8 => {
    //   block [0x828655B8..0x82865610)
	// 828655B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828655BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828655C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828655C4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828655C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828655CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828655D0: 4BF891C1  bl 0x827ee790
	ctx.lr = 0x828655D4;
	sub_827EE790(ctx, base);
	// 828655D4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828655D8: 389F0070  addi r4, r31, 0x70
	ctx.r[4].s64 = ctx.r[31].s64 + 112;
	// 828655DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828655E0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828655E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828655E8: 4E800421  bctrl
	ctx.lr = 0x828655EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828655EC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828655F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828655F4: 419A0008  beq cr6, 0x828655fc
	if ctx.cr[6].eq {
	pc = 0x828655FC; continue 'dispatch;
	}
	// 828655F8: 4BA5B299  bl 0x822c0890
	ctx.lr = 0x828655FC;
	sub_822C0890(ctx, base);
	// 828655FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82865600: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82865604: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82865608: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286560C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82865610 size=60
    let mut pc: u32 = 0x82865610;
    'dispatch: loop {
        match pc {
            0x82865610 => {
    //   block [0x82865610..0x8286564C)
	// 82865610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82865614: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82865618: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8286561C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82865620: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82865624: 4BFFD4F5  bl 0x82862b18
	ctx.lr = 0x82865628;
	sub_82862B18(ctx, base);
	// 82865628: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8286562C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82865630: 396B07F4  addi r11, r11, 0x7f4
	ctx.r[11].s64 = ctx.r[11].s64 + 2036;
	// 82865634: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82865638: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8286563C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82865640: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82865644: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82865648: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82865650 size=88
    let mut pc: u32 = 0x82865650;
    'dispatch: loop {
        match pc {
            0x82865650 => {
    //   block [0x82865650..0x828656A8)
	// 82865650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82865654: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82865658: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286565C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82865660: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82865664: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82865668: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8286566C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82865670: 396B07F4  addi r11, r11, 0x7f4
	ctx.r[11].s64 = ctx.r[11].s64 + 2036;
	// 82865674: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82865678: 485F6F11  bl 0x82e5c588
	ctx.lr = 0x8286567C;
	sub_82E5C588(ctx, base);
	// 8286567C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82865680: 4182000C  beq 0x8286568c
	if ctx.cr[0].eq {
	pc = 0x8286568C; continue 'dispatch;
	}
	// 82865684: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82865688: 4858CD51  bl 0x82df23d8
	ctx.lr = 0x8286568C;
	sub_82DF23D8(ctx, base);
	// 8286568C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82865690: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82865694: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82865698: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286569C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828656A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828656A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828656A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828656A8 size=128
    let mut pc: u32 = 0x828656A8;
    'dispatch: loop {
        match pc {
            0x828656A8 => {
    //   block [0x828656A8..0x82865728)
	// 828656A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828656AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828656B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828656B4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828656B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828656BC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828656C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828656C4: 4BF890CD  bl 0x827ee790
	ctx.lr = 0x828656C8;
	sub_827EE790(ctx, base);
	// 828656C8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828656CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828656D0: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 828656D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828656D8: 4E800421  bctrl
	ctx.lr = 0x828656DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828656DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828656E0: 41820018  beq 0x828656f8
	if ctx.cr[0].eq {
	pc = 0x828656F8; continue 'dispatch;
	}
	// 828656E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828656E8: 4BF88151  bl 0x827ed838
	ctx.lr = 0x828656EC;
	sub_827ED838(ctx, base);
	// 828656EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828656F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828656F4: 40820008  bne 0x828656fc
	if !ctx.cr[0].eq {
	pc = 0x828656FC; continue 'dispatch;
	}
	// 828656F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828656FC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82865700: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82865704: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82865708: 419A0008  beq cr6, 0x82865710
	if ctx.cr[6].eq {
	pc = 0x82865710; continue 'dispatch;
	}
	// 8286570C: 4BA5B185  bl 0x822c0890
	ctx.lr = 0x82865710;
	sub_822C0890(ctx, base);
	// 82865710: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82865714: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82865718: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286571C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82865720: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82865724: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82865728 size=160
    let mut pc: u32 = 0x82865728;
    'dispatch: loop {
        match pc {
            0x82865728 => {
    //   block [0x82865728..0x828657C8)
	// 82865728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286572C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82865730: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82865734: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82865738: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8286573C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82865740: 4BF880F1  bl 0x827ed830
	ctx.lr = 0x82865744;
	sub_827ED830(ctx, base);
	// 82865744: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82865748: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8286574C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82865750: 4BF89359  bl 0x827eeaa8
	ctx.lr = 0x82865754;
	sub_827EEAA8(ctx, base);
	// 82865754: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82865758: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286575C: 4BF89035  bl 0x827ee790
	ctx.lr = 0x82865760;
	sub_827EE790(ctx, base);
	// 82865760: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82865764: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82865768: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286576C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82865770: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82865774: 4E800421  bctrl
	ctx.lr = 0x82865778;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82865778: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8286577C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82865780: 419A0008  beq cr6, 0x82865788
	if ctx.cr[6].eq {
	pc = 0x82865788; continue 'dispatch;
	}
	// 82865784: 4BA5B10D  bl 0x822c0890
	ctx.lr = 0x82865788;
	sub_822C0890(ctx, base);
	// 82865788: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8286578C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82865790: 388B0380  addi r4, r11, 0x380
	ctx.r[4].s64 = ctx.r[11].s64 + 896;
	// 82865794: 4858E275  bl 0x82df3a08
	ctx.lr = 0x82865798;
	sub_82DF3A08(ctx, base);
	// 82865798: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286579C: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 828657A0: 4BF89FE1  bl 0x827ef780
	ctx.lr = 0x828657A4;
	sub_827EF780(ctx, base);
	// 828657A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828657A8: 4BF84D39  bl 0x827ea4e0
	ctx.lr = 0x828657AC;
	sub_827EA4E0(ctx, base);
	// 828657AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828657B0: 4858DC79  bl 0x82df3428
	ctx.lr = 0x828657B4;
	sub_82DF3428(ctx, base);
	// 828657B4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828657B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828657BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828657C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828657C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828657C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828657C8 size=88
    let mut pc: u32 = 0x828657C8;
    'dispatch: loop {
        match pc {
            0x828657C8 => {
    //   block [0x828657C8..0x82865820)
	// 828657C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828657CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828657D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828657D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828657D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828657DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828657E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828657E4: 4858E41D  bl 0x82df3c00
	ctx.lr = 0x828657E8;
	sub_82DF3C00(ctx, base);
	// 828657E8: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 828657EC: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 828657F0: 4858E411  bl 0x82df3c00
	ctx.lr = 0x828657F4;
	sub_82DF3C00(ctx, base);
	// 828657F4: C01E0008  lfs f0, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828657F8: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 828657FC: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82865800: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82865804: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82865808: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286580C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82865810: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82865814: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82865818: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286581C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82865820 size=104
    let mut pc: u32 = 0x82865820;
    'dispatch: loop {
        match pc {
            0x82865820 => {
    //   block [0x82865820..0x82865888)
	// 82865820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82865824: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82865828: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286582C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82865830: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82865834: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82865838: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8286583C: 3BDF007C  addi r30, r31, 0x7c
	ctx.r[30].s64 = ctx.r[31].s64 + 124;
	// 82865840: 396B085C  addi r11, r11, 0x85c
	ctx.r[11].s64 = ctx.r[11].s64 + 2140;
	// 82865844: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82865848: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8286584C: 4858DBDD  bl 0x82df3428
	ctx.lr = 0x82865850;
	sub_82DF3428(ctx, base);
	// 82865850: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82865854: 4858DBD5  bl 0x82df3428
	ctx.lr = 0x82865858;
	sub_82DF3428(ctx, base);
	// 82865858: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 8286585C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82865860: 419A0008  beq cr6, 0x82865868
	if ctx.cr[6].eq {
	pc = 0x82865868; continue 'dispatch;
	}
	// 82865864: 4BA5B02D  bl 0x822c0890
	ctx.lr = 0x82865868;
	sub_822C0890(ctx, base);
	// 82865868: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286586C: 4BFFD625  bl 0x82862e90
	ctx.lr = 0x82865870;
	sub_82862E90(ctx, base);
	// 82865870: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82865874: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82865878: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286587C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82865880: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82865884: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82865888 size=104
    let mut pc: u32 = 0x82865888;
    'dispatch: loop {
        match pc {
            0x82865888 => {
    //   block [0x82865888..0x828658F0)
	// 82865888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286588C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82865890: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82865894: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82865898: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286589C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828658A0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828658A4: 3BDF007C  addi r30, r31, 0x7c
	ctx.r[30].s64 = ctx.r[31].s64 + 124;
	// 828658A8: 396B08A4  addi r11, r11, 0x8a4
	ctx.r[11].s64 = ctx.r[11].s64 + 2212;
	// 828658AC: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 828658B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828658B4: 4858DB75  bl 0x82df3428
	ctx.lr = 0x828658B8;
	sub_82DF3428(ctx, base);
	// 828658B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828658BC: 4858DB6D  bl 0x82df3428
	ctx.lr = 0x828658C0;
	sub_82DF3428(ctx, base);
	// 828658C0: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 828658C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828658C8: 419A0008  beq cr6, 0x828658d0
	if ctx.cr[6].eq {
	pc = 0x828658D0; continue 'dispatch;
	}
	// 828658CC: 4BA5AFC5  bl 0x822c0890
	ctx.lr = 0x828658D0;
	sub_822C0890(ctx, base);
	// 828658D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828658D4: 4BFFD685  bl 0x82862f58
	ctx.lr = 0x828658D8;
	sub_82862F58(ctx, base);
	// 828658D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828658DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828658E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828658E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828658E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828658EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828658F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828658F0 size=160
    let mut pc: u32 = 0x828658F0;
    'dispatch: loop {
        match pc {
            0x828658F0 => {
    //   block [0x828658F0..0x82865990)
	// 828658F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828658F4: 48942875  bl 0x831a8168
	ctx.lr = 0x828658F8;
	sub_831A8130(ctx, base);
	// 828658F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828658FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82865900: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82865904: 387E0080  addi r3, r30, 0x80
	ctx.r[3].s64 = ctx.r[30].s64 + 128;
	// 82865908: 4858D8A9  bl 0x82df31b0
	ctx.lr = 0x8286590C;
	sub_82DF31B0(ctx, base);
	// 8286590C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82865910: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82865914: 4858E0F5  bl 0x82df3a08
	ctx.lr = 0x82865918;
	sub_82DF3A08(ctx, base);
	// 82865918: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8286591C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82865920: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82865924: 4BF88EFD  bl 0x827ee820
	ctx.lr = 0x82865928;
	sub_827EE820(ctx, base);
	// 82865928: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8286592C: 3BFE0074  addi r31, r30, 0x74
	ctx.r[31].s64 = ctx.r[30].s64 + 116;
	// 82865930: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82865934: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82865938: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286593C: 917E0074  stw r11, 0x74(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82865940: 4BA5EB21  bl 0x822c4460
	ctx.lr = 0x82865944;
	sub_822C4460(ctx, base);
	// 82865944: 817E0074  lwz r11, 0x74(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) } as u64;
	// 82865948: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8286594C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82865950: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82865954: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82865958: 697C0001  xori r28, r11, 1
	ctx.r[28].u64 = ctx.r[11].u64 ^ 1;
	// 8286595C: 419A0008  beq cr6, 0x82865964
	if ctx.cr[6].eq {
	pc = 0x82865964; continue 'dispatch;
	}
	// 82865960: 4BA5AF31  bl 0x822c0890
	ctx.lr = 0x82865964;
	sub_822C0890(ctx, base);
	// 82865964: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82865968: 4858DAC1  bl 0x82df3428
	ctx.lr = 0x8286596C;
	sub_82DF3428(ctx, base);
	// 8286596C: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82865970: 4182000C  beq 0x8286597c
	if ctx.cr[0].eq {
	pc = 0x8286597C; continue 'dispatch;
	}
	// 82865974: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82865978: 485ACD99  bl 0x82e12710
	ctx.lr = 0x8286597C;
	sub_82E12710(ctx, base);
	// 8286597C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82865980: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82865984: 4BFFD795  bl 0x82863118
	ctx.lr = 0x82865988;
	sub_82863118(ctx, base);
	// 82865988: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8286598C: 4894282C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82865990 size=196
    let mut pc: u32 = 0x82865990;
    'dispatch: loop {
        match pc {
            0x82865990 => {
    //   block [0x82865990..0x82865A54)
	// 82865990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82865994: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82865998: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286599C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828659A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828659A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828659A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828659AC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828659B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828659B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828659B8: 4BA5AF81  bl 0x822c0938
	ctx.lr = 0x828659BC;
	sub_822C0938(ctx, base);
	// 828659BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828659C0: 41820028  beq 0x828659e8
	if ctx.cr[0].eq {
	pc = 0x828659E8; continue 'dispatch;
	}
	// 828659C4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828659C8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828659CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828659D0: 392B0834  addi r9, r11, 0x834
	ctx.r[9].s64 = ctx.r[11].s64 + 2100;
	// 828659D4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828659D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828659DC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828659E0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828659E4: 48000008  b 0x828659ec
	pc = 0x828659EC; continue 'dispatch;
	// 828659E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828659EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828659F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828659F4: 409A0044  bne cr6, 0x82865a38
	if !ctx.cr[6].eq {
	pc = 0x82865A38; continue 'dispatch;
	}
	// 828659F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828659FC: 419A001C  beq cr6, 0x82865a18
	if ctx.cr[6].eq {
	pc = 0x82865A18; continue 'dispatch;
	}
	// 82865A00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82865A04: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82865A08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82865A0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82865A10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82865A14: 4E800421  bctrl
	ctx.lr = 0x82865A18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82865A18: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82865A1C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82865A20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82865A24: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82865A28: 816B54D4  lwz r11, 0x54d4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(21716 as u32) ) } as u64;
	// 82865A2C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82865A30: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82865A34: 4BA5A5CD  bl 0x822c0000
	ctx.lr = 0x82865A38;
	sub_822C0000(ctx, base);
	// 82865A38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82865A3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82865A40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82865A44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82865A48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82865A4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82865A50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865A58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82865A58 size=196
    let mut pc: u32 = 0x82865A58;
    'dispatch: loop {
        match pc {
            0x82865A58 => {
    //   block [0x82865A58..0x82865B1C)
	// 82865A58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82865A5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82865A60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82865A64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82865A68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82865A6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82865A70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82865A74: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82865A78: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82865A7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82865A80: 4BA5AEB9  bl 0x822c0938
	ctx.lr = 0x82865A84;
	sub_822C0938(ctx, base);
	// 82865A84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82865A88: 41820028  beq 0x82865ab0
	if ctx.cr[0].eq {
	pc = 0x82865AB0; continue 'dispatch;
	}
	// 82865A8C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82865A90: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82865A94: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82865A98: 392B0848  addi r9, r11, 0x848
	ctx.r[9].s64 = ctx.r[11].s64 + 2120;
	// 82865A9C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82865AA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82865AA4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82865AA8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82865AAC: 48000008  b 0x82865ab4
	pc = 0x82865AB4; continue 'dispatch;
	// 82865AB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82865AB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82865AB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82865ABC: 409A0044  bne cr6, 0x82865b00
	if !ctx.cr[6].eq {
	pc = 0x82865B00; continue 'dispatch;
	}
	// 82865AC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82865AC4: 419A001C  beq cr6, 0x82865ae0
	if ctx.cr[6].eq {
	pc = 0x82865AE0; continue 'dispatch;
	}
	// 82865AC8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82865ACC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82865AD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82865AD4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82865AD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82865ADC: 4E800421  bctrl
	ctx.lr = 0x82865AE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82865AE0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82865AE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82865AE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82865AEC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82865AF0: 816B54D4  lwz r11, 0x54d4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(21716 as u32) ) } as u64;
	// 82865AF4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82865AF8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82865AFC: 4BA5A505  bl 0x822c0000
	ctx.lr = 0x82865B00;
	sub_822C0000(ctx, base);
	// 82865B00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82865B04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82865B08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82865B0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82865B10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82865B14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82865B18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82865B20 size=100
    let mut pc: u32 = 0x82865B20;
    'dispatch: loop {
        match pc {
            0x82865B20 => {
    //   block [0x82865B20..0x82865B84)
	// 82865B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82865B24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82865B28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82865B2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82865B30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82865B34: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82865B38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82865B3C: 80DE000C  lwz r6, 0xc(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82865B40: 4BFFD461  bl 0x82862fa0
	ctx.lr = 0x82865B44;
	sub_82862FA0(ctx, base);
	// 82865B44: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82865B48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82865B4C: 394A085C  addi r10, r10, 0x85c
	ctx.r[10].s64 = ctx.r[10].s64 + 2140;
	// 82865B50: 387F007C  addi r3, r31, 0x7c
	ctx.r[3].s64 = ctx.r[31].s64 + 124;
	// 82865B54: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82865B58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82865B5C: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82865B60: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82865B64: 4BFFFC65  bl 0x828657c8
	ctx.lr = 0x82865B68;
	sub_828657C8(ctx, base);
	// 82865B68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82865B6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82865B70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82865B74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82865B78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82865B7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82865B80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82865B88 size=76
    let mut pc: u32 = 0x82865B88;
    'dispatch: loop {
        match pc {
            0x82865B88 => {
    //   block [0x82865B88..0x82865BD4)
	// 82865B88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82865B8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82865B90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82865B94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82865B98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82865B9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82865BA0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82865BA4: 4BFFFC7D  bl 0x82865820
	ctx.lr = 0x82865BA8;
	sub_82865820(ctx, base);
	// 82865BA8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82865BAC: 4182000C  beq 0x82865bb8
	if ctx.cr[0].eq {
	pc = 0x82865BB8; continue 'dispatch;
	}
	// 82865BB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82865BB4: 4858C825  bl 0x82df23d8
	ctx.lr = 0x82865BB8;
	sub_82DF23D8(ctx, base);
	// 82865BB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82865BBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82865BC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82865BC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82865BC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82865BCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82865BD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82865BD8 size=100
    let mut pc: u32 = 0x82865BD8;
    'dispatch: loop {
        match pc {
            0x82865BD8 => {
    //   block [0x82865BD8..0x82865C3C)
	// 82865BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82865BDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82865BE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82865BE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82865BE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82865BEC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82865BF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82865BF4: C05E0008  lfs f2, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82865BF8: 4BFFD2E1  bl 0x82862ed8
	ctx.lr = 0x82865BFC;
	sub_82862ED8(ctx, base);
	// 82865BFC: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82865C00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82865C04: 394A08A4  addi r10, r10, 0x8a4
	ctx.r[10].s64 = ctx.r[10].s64 + 2212;
	// 82865C08: 387F007C  addi r3, r31, 0x7c
	ctx.r[3].s64 = ctx.r[31].s64 + 124;
	// 82865C0C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82865C10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82865C14: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82865C18: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82865C1C: 4BFFFBAD  bl 0x828657c8
	ctx.lr = 0x82865C20;
	sub_828657C8(ctx, base);
	// 82865C20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82865C24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82865C28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82865C2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82865C30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82865C34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82865C38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82865C40 size=76
    let mut pc: u32 = 0x82865C40;
    'dispatch: loop {
        match pc {
            0x82865C40 => {
    //   block [0x82865C40..0x82865C8C)
	// 82865C40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82865C44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82865C48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82865C4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82865C50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82865C54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82865C58: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82865C5C: 4BFFFC2D  bl 0x82865888
	ctx.lr = 0x82865C60;
	sub_82865888(ctx, base);
	// 82865C60: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82865C64: 4182000C  beq 0x82865c70
	if ctx.cr[0].eq {
	pc = 0x82865C70; continue 'dispatch;
	}
	// 82865C68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82865C6C: 4858C76D  bl 0x82df23d8
	ctx.lr = 0x82865C70;
	sub_82DF23D8(ctx, base);
	// 82865C70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82865C74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82865C78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82865C7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82865C80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82865C84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82865C88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82865C90 size=84
    let mut pc: u32 = 0x82865C90;
    'dispatch: loop {
        match pc {
            0x82865C90 => {
    //   block [0x82865C90..0x82865CE4)
	// 82865C90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82865C94: 489424D9  bl 0x831a816c
	ctx.lr = 0x82865C98;
	sub_831A8130(ctx, base);
	// 82865C98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82865C9C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82865CA0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82865CA4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82865CA8: 397F0058  addi r11, r31, 0x58
	ctx.r[11].s64 = ctx.r[31].s64 + 88;
	// 82865CAC: 409A0008  bne cr6, 0x82865cb4
	if !ctx.cr[6].eq {
	pc = 0x82865CB4; continue 'dispatch;
	}
	// 82865CB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82865CB4: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82865CB8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82865CBC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82865CC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82865CC4: 4BFAFAE5  bl 0x828157a8
	ctx.lr = 0x82865CC8;
	sub_828157A8(ctx, base);
	// 82865CC8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82865CCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82865CD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82865CD4: 4BA5A32D  bl 0x822c0000
	ctx.lr = 0x82865CD8;
	sub_822C0000(ctx, base);
	// 82865CD8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82865CDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82865CE0: 489424DC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82865CE8 size=144
    let mut pc: u32 = 0x82865CE8;
    'dispatch: loop {
        match pc {
            0x82865CE8 => {
    //   block [0x82865CE8..0x82865D78)
	// 82865CE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82865CEC: 48942481  bl 0x831a816c
	ctx.lr = 0x82865CF0;
	sub_831A8130(ctx, base);
	// 82865CF0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82865CF4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82865CF8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82865CFC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82865D00: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82865D04: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82865D08: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82865D0C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82865D10: 388B08E8  addi r4, r11, 0x8e8
	ctx.r[4].s64 = ctx.r[11].s64 + 2280;
	// 82865D14: 38A00029  li r5, 0x29
	ctx.r[5].s64 = 41;
	// 82865D18: 3860008C  li r3, 0x8c
	ctx.r[3].s64 = 140;
	// 82865D1C: 4858C6CD  bl 0x82df23e8
	ctx.lr = 0x82865D20;
	sub_82DF23E8(ctx, base);
	// 82865D20: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82865D24: 4182001C  beq 0x82865d40
	if ctx.cr[0].eq {
	pc = 0x82865D40; continue 'dispatch;
	}
	// 82865D28: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82865D2C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82865D30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82865D34: 4BFFFDED  bl 0x82865b20
	ctx.lr = 0x82865D38;
	sub_82865B20(ctx, base);
	// 82865D38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82865D3C: 48000008  b 0x82865d44
	pc = 0x82865D44; continue 'dispatch;
	// 82865D40: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82865D44: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82865D48: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82865D4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82865D50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82865D54: 4BFFFC3D  bl 0x82865990
	ctx.lr = 0x82865D58;
	sub_82865990(ctx, base);
	// 82865D58: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82865D5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82865D60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82865D64: 4BA5A29D  bl 0x822c0000
	ctx.lr = 0x82865D68;
	sub_822C0000(ctx, base);
	// 82865D68: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82865D6C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82865D70: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82865D74: 48942448  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82865D78 size=424
    let mut pc: u32 = 0x82865D78;
    'dispatch: loop {
        match pc {
            0x82865D78 => {
    //   block [0x82865D78..0x82865F20)
	// 82865D78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82865D7C: 489423D9  bl 0x831a8154
	ctx.lr = 0x82865D80;
	sub_831A8130(ctx, base);
	// 82865D80: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82865D84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82865D88: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82865D8C: 807E0074  lwz r3, 0x74(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) } as u64;
	// 82865D90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82865D94: 419A0184  beq cr6, 0x82865f18
	if ctx.cr[6].eq {
	pc = 0x82865F18; continue 'dispatch;
	}
	// 82865D98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82865D9C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82865DA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82865DA4: 4E800421  bctrl
	ctx.lr = 0x82865DA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82865DA8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82865DAC: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 82865DB0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82865DB4: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82865DB8: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82865DBC: C1AB0034  lfs f13, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82865DC0: C18B0038  lfs f12, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82865DC4: C16B003C  lfs f11, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82865DC8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82865DCC: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82865DD0: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82865DD4: D161006C  stfs f11, 0x6c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82865DD8: 48617031  bl 0x82e7ce08
	ctx.lr = 0x82865DDC;
	sub_82E7CE08(ctx, base);
	// 82865DDC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82865DE0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82865DE4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82865DE8: 4BAA1991  bl 0x82307778
	ctx.lr = 0x82865DEC;
	sub_82307778(ctx, base);
	// 82865DEC: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 82865DF0: 39410100  addi r10, r1, 0x100
	ctx.r[10].s64 = ctx.r[1].s64 + 256;
	// 82865DF4: C0010080  lfs f0, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82865DF8: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 82865DFC: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82865E00: 38E10110  addi r7, r1, 0x110
	ctx.r[7].s64 = ctx.r[1].s64 + 272;
	// 82865E04: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 82865E08: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82865E0C: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 82865E10: 38810120  addi r4, r1, 0x120
	ctx.r[4].s64 = ctx.r[1].s64 + 288;
	// 82865E14: 3C608338  lis r3, -0x7cc8
	ctx.r[3].s64 = -2093481984;
	// 82865E18: 3BA10130  addi r29, r1, 0x130
	ctx.r[29].s64 = ctx.r[1].s64 + 304;
	// 82865E1C: 3B8100F0  addi r28, r1, 0xf0
	ctx.r[28].s64 = ctx.r[1].s64 + 240;
	// 82865E20: 3B610140  addi r27, r1, 0x140
	ctx.r[27].s64 = ctx.r[1].s64 + 320;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865F20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82865F20 size=144
    let mut pc: u32 = 0x82865F20;
    'dispatch: loop {
        match pc {
            0x82865F20 => {
    //   block [0x82865F20..0x82865FB0)
	// 82865F20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82865F24: 48942249  bl 0x831a816c
	ctx.lr = 0x82865F28;
	sub_831A8130(ctx, base);
	// 82865F28: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82865F2C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82865F30: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82865F34: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82865F38: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82865F3C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82865F40: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82865F44: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82865F48: 388B08E8  addi r4, r11, 0x8e8
	ctx.r[4].s64 = ctx.r[11].s64 + 2280;
	// 82865F4C: 38A00066  li r5, 0x66
	ctx.r[5].s64 = 102;
	// 82865F50: 3860008C  li r3, 0x8c
	ctx.r[3].s64 = 140;
	// 82865F54: 4858C495  bl 0x82df23e8
	ctx.lr = 0x82865F58;
	sub_82DF23E8(ctx, base);
	// 82865F58: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82865F5C: 4182001C  beq 0x82865f78
	if ctx.cr[0].eq {
	pc = 0x82865F78; continue 'dispatch;
	}
	// 82865F60: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82865F64: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82865F68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82865F6C: 4BFFFC6D  bl 0x82865bd8
	ctx.lr = 0x82865F70;
	sub_82865BD8(ctx, base);
	// 82865F70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82865F74: 48000008  b 0x82865f7c
	pc = 0x82865F7C; continue 'dispatch;
	// 82865F78: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82865F7C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82865F80: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82865F84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82865F88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82865F8C: 4BFFFACD  bl 0x82865a58
	ctx.lr = 0x82865F90;
	sub_82865A58(ctx, base);
	// 82865F90: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82865F94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82865F98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82865F9C: 4BA5A065  bl 0x822c0000
	ctx.lr = 0x82865FA0;
	sub_822C0000(ctx, base);
	// 82865FA0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82865FA4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82865FA8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82865FAC: 48942210  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82865FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82865FB0 size=564
    let mut pc: u32 = 0x82865FB0;
    'dispatch: loop {
        match pc {
            0x82865FB0 => {
    //   block [0x82865FB0..0x828661E4)
	// 82865FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82865FB4: 489421A1  bl 0x831a8154
	ctx.lr = 0x82865FB8;
	sub_831A8130(ctx, base);
	// 82865FB8: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82865FBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82865FC0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82865FC4: 807F0074  lwz r3, 0x74(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82865FC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82865FCC: 419A0210  beq cr6, 0x828661dc
	if ctx.cr[6].eq {
	pc = 0x828661DC; continue 'dispatch;
	}
	// 82865FD0: 485AC741  bl 0x82e12710
	ctx.lr = 0x82865FD4;
	sub_82E12710(ctx, base);
	// 82865FD4: 807F0074  lwz r3, 0x74(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82865FD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82865FDC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82865FE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82865FE4: 4E800421  bctrl
	ctx.lr = 0x82865FE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82865FE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82865FEC: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 82865FF0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82865FF4: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 82865FF8: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82865FFC: C1AB0034  lfs f13, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82866000: C18B0038  lfs f12, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82866004: C16B003C  lfs f11, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82866008: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8286600C: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82866010: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82866014: D161005C  stfs f11, 0x5c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82866018: 48616DF1  bl 0x82e7ce08
	ctx.lr = 0x8286601C;
	sub_82E7CE08(ctx, base);
	// 8286601C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82866020: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82866024: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82866028: 4BAA1751  bl 0x82307778
	ctx.lr = 0x8286602C;
	sub_82307778(ctx, base);
	// 8286602C: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 82866030: 394100F0  addi r10, r1, 0xf0
	ctx.r[10].s64 = ctx.r[1].s64 + 240;
	// 82866034: C0010070  lfs f0, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82866038: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 8286603C: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82866040: 38E10100  addi r7, r1, 0x100
	ctx.r[7].s64 = ctx.r[1].s64 + 256;
	// 82866044: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 82866048: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8286604C: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 82866050: 38810110  addi r4, r1, 0x110
	ctx.r[4].s64 = ctx.r[1].s64 + 272;
	// 82866054: 3C608338  lis r3, -0x7cc8
	ctx.r[3].s64 = -2093481984;
	// 82866058: 3BA10120  addi r29, r1, 0x120
	ctx.r[29].s64 = ctx.r[1].s64 + 288;
	// 8286605C: 3B8100E0  addi r28, r1, 0xe0
	ctx.r[28].s64 = ctx.r[1].s64 + 224;
	// 82866060: 3B610130  addi r27, r1, 0x130
	ctx.r[27].s64 = ctx.r[1].s64 + 304;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828661E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828661E8 size=60
    let mut pc: u32 = 0x828661E8;
    'dispatch: loop {
        match pc {
            0x828661E8 => {
    //   block [0x828661E8..0x82866224)
	// 828661E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828661EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828661F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828661F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828661F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828661FC: 4BFFC91D  bl 0x82862b18
	ctx.lr = 0x82866200;
	sub_82862B18(ctx, base);
	// 82866200: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82866204: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866208: 396B0944  addi r11, r11, 0x944
	ctx.r[11].s64 = ctx.r[11].s64 + 2372;
	// 8286620C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82866210: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82866214: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82866218: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286621C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82866220: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82866228 size=88
    let mut pc: u32 = 0x82866228;
    'dispatch: loop {
        match pc {
            0x82866228 => {
    //   block [0x82866228..0x82866280)
	// 82866228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286622C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82866230: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82866234: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82866238: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286623C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82866240: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82866244: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82866248: 396B0944  addi r11, r11, 0x944
	ctx.r[11].s64 = ctx.r[11].s64 + 2372;
	// 8286624C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82866250: 485F6339  bl 0x82e5c588
	ctx.lr = 0x82866254;
	sub_82E5C588(ctx, base);
	// 82866254: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82866258: 4182000C  beq 0x82866264
	if ctx.cr[0].eq {
	pc = 0x82866264; continue 'dispatch;
	}
	// 8286625C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866260: 4858C179  bl 0x82df23d8
	ctx.lr = 0x82866264;
	sub_82DF23D8(ctx, base);
	// 82866264: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866268: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286626C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82866270: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82866274: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82866278: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286627C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82866280 size=60
    let mut pc: u32 = 0x82866280;
    'dispatch: loop {
        match pc {
            0x82866280 => {
    //   block [0x82866280..0x828662BC)
	// 82866280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82866284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82866288: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8286628C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82866290: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82866294: 4BFFC885  bl 0x82862b18
	ctx.lr = 0x82866298;
	sub_82862B18(ctx, base);
	// 82866298: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8286629C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828662A0: 396B0984  addi r11, r11, 0x984
	ctx.r[11].s64 = ctx.r[11].s64 + 2436;
	// 828662A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828662A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828662AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828662B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828662B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828662B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828662C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828662C0 size=88
    let mut pc: u32 = 0x828662C0;
    'dispatch: loop {
        match pc {
            0x828662C0 => {
    //   block [0x828662C0..0x82866318)
	// 828662C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828662C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828662C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828662CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828662D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828662D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828662D8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828662DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828662E0: 396B0984  addi r11, r11, 0x984
	ctx.r[11].s64 = ctx.r[11].s64 + 2436;
	// 828662E4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828662E8: 485F62A1  bl 0x82e5c588
	ctx.lr = 0x828662EC;
	sub_82E5C588(ctx, base);
	// 828662EC: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828662F0: 4182000C  beq 0x828662fc
	if ctx.cr[0].eq {
	pc = 0x828662FC; continue 'dispatch;
	}
	// 828662F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828662F8: 4858C0E1  bl 0x82df23d8
	ctx.lr = 0x828662FC;
	sub_82DF23D8(ctx, base);
	// 828662FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866300: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82866304: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82866308: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286630C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82866310: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82866314: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82866318 size=104
    let mut pc: u32 = 0x82866318;
    'dispatch: loop {
        match pc {
            0x82866318 => {
    //   block [0x82866318..0x82866380)
	// 82866318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286631C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82866320: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82866324: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82866328: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286632C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82866330: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82866334: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866338: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 8286633C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82866340: 4E800421  bctrl
	ctx.lr = 0x82866344;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82866344: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82866348: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286634C: 4858D6BD  bl 0x82df3a08
	ctx.lr = 0x82866350;
	sub_82DF3A08(ctx, base);
	// 82866350: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82866354: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82866358: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 8286635C: 480A7AF5  bl 0x8290de50
	ctx.lr = 0x82866360;
	sub_8290DE50(ctx, base);
	// 82866360: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82866364: 4858D0C5  bl 0x82df3428
	ctx.lr = 0x82866368;
	sub_82DF3428(ctx, base);
	// 82866368: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286636C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82866370: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82866374: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82866378: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286637C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82866380 size=64
    let mut pc: u32 = 0x82866380;
    'dispatch: loop {
        match pc {
            0x82866380 => {
    //   block [0x82866380..0x828663C0)
	// 82866380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82866384: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82866388: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8286638C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82866390: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82866394: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82866398: 4BF85E51  bl 0x827ec1e8
	ctx.lr = 0x8286639C;
	sub_827EC1E8(ctx, base);
	// 8286639C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828663A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828663A4: 4BA86BF5  bl 0x822ecf98
	ctx.lr = 0x828663A8;
	sub_822ECF98(ctx, base);
	// 828663A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828663AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828663B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828663B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828663B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828663BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828663C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828663C0 size=160
    let mut pc: u32 = 0x828663C0;
    'dispatch: loop {
        match pc {
            0x828663C0 => {
    //   block [0x828663C0..0x82866460)
	// 828663C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828663C4: 48941DA9  bl 0x831a816c
	ctx.lr = 0x828663C8;
	sub_831A8130(ctx, base);
	// 828663C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828663CC: 8163FFF0  lwz r11, -0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-16 as u32) ) } as u64;
	// 828663D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828663D4: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828663D8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828663DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828663E0: 4E800421  bctrl
	ctx.lr = 0x828663E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828663E4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828663E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828663EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828663F0: 808B0B88  lwz r4, 0xb88(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2952 as u32) ) } as u64;
	// 828663F4: 4858D615  bl 0x82df3a08
	ctx.lr = 0x828663F8;
	sub_82DF3A08(ctx, base);
	// 828663F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828663FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866400: 4858CF09  bl 0x82df3308
	ctx.lr = 0x82866404;
	sub_82DF3308(ctx, base);
	// 82866404: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82866408: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286640C: 4858D01D  bl 0x82df3428
	ctx.lr = 0x82866410;
	sub_82DF3428(ctx, base);
	// 82866410: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82866414: 4182000C  beq 0x82866420
	if ctx.cr[0].eq {
	pc = 0x82866420; continue 'dispatch;
	}
	// 82866418: 387E0014  addi r3, r30, 0x14
	ctx.r[3].s64 = ctx.r[30].s64 + 20;
	// 8286641C: 4800003C  b 0x82866458
	pc = 0x82866458; continue 'dispatch;
	// 82866420: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82866424: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82866428: 808B0B8C  lwz r4, 0xb8c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2956 as u32) ) } as u64;
	// 8286642C: 4858D5DD  bl 0x82df3a08
	ctx.lr = 0x82866430;
	sub_82DF3A08(ctx, base);
	// 82866430: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82866434: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866438: 4858CED1  bl 0x82df3308
	ctx.lr = 0x8286643C;
	sub_82DF3308(ctx, base);
	// 8286643C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82866440: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82866444: 4858CFE5  bl 0x82df3428
	ctx.lr = 0x82866448;
	sub_82DF3428(ctx, base);
	// 82866448: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286644C: 387E0024  addi r3, r30, 0x24
	ctx.r[3].s64 = ctx.r[30].s64 + 36;
	// 82866450: 40820008  bne 0x82866458
	if !ctx.cr[0].eq {
	pc = 0x82866458; continue 'dispatch;
	}
	// 82866454: 387E0034  addi r3, r30, 0x34
	ctx.r[3].s64 = ctx.r[30].s64 + 52;
	// 82866458: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8286645C: 48941D60  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82866460 size=20
    let mut pc: u32 = 0x82866460;
    'dispatch: loop {
        match pc {
            0x82866460 => {
    //   block [0x82866460..0x82866474)
	// 82866460: 8163FFF0  lwz r11, -0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82866464: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82866468: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 8286646C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82866470: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82866478 size=8
    let mut pc: u32 = 0x82866478;
    'dispatch: loop {
        match pc {
            0x82866478 => {
    //   block [0x82866478..0x82866480)
	// 82866478: 3863038C  addi r3, r3, 0x38c
	ctx.r[3].s64 = ctx.r[3].s64 + 908;
	// 8286647C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82866480 size=8
    let mut pc: u32 = 0x82866480;
    'dispatch: loop {
        match pc {
            0x82866480 => {
    //   block [0x82866480..0x82866488)
	// 82866480: 80630390  lwz r3, 0x390(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(912 as u32) ) } as u64;
	// 82866484: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82866488 size=8
    let mut pc: u32 = 0x82866488;
    'dispatch: loop {
        match pc {
            0x82866488 => {
    //   block [0x82866488..0x82866490)
	// 82866488: 38630398  addi r3, r3, 0x398
	ctx.r[3].s64 = ctx.r[3].s64 + 920;
	// 8286648C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82866490 size=12
    let mut pc: u32 = 0x82866490;
    'dispatch: loop {
        match pc {
            0x82866490 => {
    //   block [0x82866490..0x8286649C)
	// 82866490: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82866494: 386BBA50  addi r3, r11, -0x45b0
	ctx.r[3].s64 = ctx.r[11].s64 + -17840;
	// 82866498: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828664A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828664A0 size=12
    let mut pc: u32 = 0x828664A0;
    'dispatch: loop {
        match pc {
            0x828664A0 => {
    //   block [0x828664A0..0x828664AC)
	// 828664A0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828664A4: 386BBAE0  addi r3, r11, -0x4520
	ctx.r[3].s64 = ctx.r[11].s64 + -17696;
	// 828664A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828664B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828664B0 size=24
    let mut pc: u32 = 0x828664B0;
    'dispatch: loop {
        match pc {
            0x828664B0 => {
    //   block [0x828664B0..0x828664C8)
	// 828664B0: 81430394  lwz r10, 0x394(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(916 as u32) ) } as u64;
	// 828664B4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828664B8: 396BBB68  addi r11, r11, -0x4498
	ctx.r[11].s64 = ctx.r[11].s64 + -17560;
	// 828664BC: 1D4A00C0  mulli r10, r10, 0xc0
	ctx.r[10].s64 = ctx.r[10].s64 * 192;
	// 828664C0: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828664C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828664C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828664C8 size=12
    let mut pc: u32 = 0x828664C8;
    'dispatch: loop {
        match pc {
            0x828664C8 => {
    //   block [0x828664C8..0x828664D4)
	// 828664C8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828664CC: 806B5DF8  lwz r3, 0x5df8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24056 as u32) ) } as u64;
	// 828664D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828664D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828664D8 size=12
    let mut pc: u32 = 0x828664D8;
    'dispatch: loop {
        match pc {
            0x828664D8 => {
    //   block [0x828664D8..0x828664E4)
	// 828664D8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828664DC: 386B09F0  addi r3, r11, 0x9f0
	ctx.r[3].s64 = ctx.r[11].s64 + 2544;
	// 828664E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828664E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828664E8 size=12
    let mut pc: u32 = 0x828664E8;
    'dispatch: loop {
        match pc {
            0x828664E8 => {
    //   block [0x828664E8..0x828664F4)
	// 828664E8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828664EC: 386BC2E8  addi r3, r11, -0x3d18
	ctx.r[3].s64 = ctx.r[11].s64 + -15640;
	// 828664F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828664F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828664F8 size=24
    let mut pc: u32 = 0x828664F8;
    'dispatch: loop {
        match pc {
            0x828664F8 => {
    //   block [0x828664F8..0x82866510)
	// 828664F8: 81430394  lwz r10, 0x394(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(916 as u32) ) } as u64;
	// 828664FC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82866500: 396BC370  addi r11, r11, -0x3c90
	ctx.r[11].s64 = ctx.r[11].s64 + -15504;
	// 82866504: 1D4A00C0  mulli r10, r10, 0xc0
	ctx.r[10].s64 = ctx.r[10].s64 * 192;
	// 82866508: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8286650C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82866510 size=12
    let mut pc: u32 = 0x82866510;
    'dispatch: loop {
        match pc {
            0x82866510 => {
    //   block [0x82866510..0x8286651C)
	// 82866510: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82866514: 806B5DFC  lwz r3, 0x5dfc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24060 as u32) ) } as u64;
	// 82866518: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82866520 size=12
    let mut pc: u32 = 0x82866520;
    'dispatch: loop {
        match pc {
            0x82866520 => {
    //   block [0x82866520..0x8286652C)
	// 82866520: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82866524: 386B0A0C  addi r3, r11, 0xa0c
	ctx.r[3].s64 = ctx.r[11].s64 + 2572;
	// 82866528: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82866530 size=116
    let mut pc: u32 = 0x82866530;
    'dispatch: loop {
        match pc {
            0x82866530 => {
    //   block [0x82866530..0x828665A4)
	// 82866530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82866534: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82866538: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286653C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82866540: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82866544: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82866548: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8286654C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82866550: 409A000C  bne cr6, 0x8286655c
	if !ctx.cr[6].eq {
	pc = 0x8286655C; continue 'dispatch;
	}
	// 82866554: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866558: 48000030  b 0x82866588
	pc = 0x82866588; continue 'dispatch;
	// 8286655C: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82866560: 419A0024  beq cr6, 0x82866584
	if ctx.cr[6].eq {
	pc = 0x82866584; continue 'dispatch;
	}
	// 82866564: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82866568: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286656C: 388B59A8  addi r4, r11, 0x59a8
	ctx.r[4].s64 = ctx.r[11].s64 + 22952;
	// 82866570: 48941B89  bl 0x831a80f8
	ctx.lr = 0x82866574;
	sub_831A80F8(ctx, base);
	// 82866574: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82866578: 4182000C  beq 0x82866584
	if ctx.cr[0].eq {
	pc = 0x82866584; continue 'dispatch;
	}
	// 8286657C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82866580: 4800000C  b 0x8286658c
	pc = 0x8286658C; continue 'dispatch;
	// 82866584: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82866588: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8286658C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82866590: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82866594: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82866598: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8286659C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828665A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828665A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828665A8 size=116
    let mut pc: u32 = 0x828665A8;
    'dispatch: loop {
        match pc {
            0x828665A8 => {
    //   block [0x828665A8..0x8286661C)
	// 828665A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828665AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828665B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828665B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828665B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828665BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828665C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828665C4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828665C8: 409A000C  bne cr6, 0x828665d4
	if !ctx.cr[6].eq {
	pc = 0x828665D4; continue 'dispatch;
	}
	// 828665CC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828665D0: 48000030  b 0x82866600
	pc = 0x82866600; continue 'dispatch;
	// 828665D4: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828665D8: 419A0024  beq cr6, 0x828665fc
	if ctx.cr[6].eq {
	pc = 0x828665FC; continue 'dispatch;
	}
	// 828665DC: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828665E0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828665E4: 388B59F8  addi r4, r11, 0x59f8
	ctx.r[4].s64 = ctx.r[11].s64 + 23032;
	// 828665E8: 48941B11  bl 0x831a80f8
	ctx.lr = 0x828665EC;
	sub_831A80F8(ctx, base);
	// 828665EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828665F0: 4182000C  beq 0x828665fc
	if ctx.cr[0].eq {
	pc = 0x828665FC; continue 'dispatch;
	}
	// 828665F4: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828665F8: 4800000C  b 0x82866604
	pc = 0x82866604; continue 'dispatch;
	// 828665FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82866600: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82866604: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82866608: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286660C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82866610: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82866614: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82866618: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82866620 size=144
    let mut pc: u32 = 0x82866620;
    'dispatch: loop {
        match pc {
            0x82866620 => {
    //   block [0x82866620..0x828666B0)
	// 82866620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82866624: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82866628: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286662C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82866630: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82866634: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82866638: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8286663C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82866640: 409A0028  bne cr6, 0x82866668
	if !ctx.cr[6].eq {
	pc = 0x82866668; continue 'dispatch;
	}
	// 82866644: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82866648: 419A0050  beq cr6, 0x82866698
	if ctx.cr[6].eq {
	pc = 0x82866698; continue 'dispatch;
	}
	// 8286664C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82866650: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82866654: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 82866658: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8286665C: E97E0010  ld r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	// 82866660: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 82866664: 48000034  b 0x82866698
	pc = 0x82866698; continue 'dispatch;
	// 82866668: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 8286666C: 419A002C  beq cr6, 0x82866698
	if ctx.cr[6].eq {
	pc = 0x82866698; continue 'dispatch;
	}
	// 82866670: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82866674: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866678: 388B5A40  addi r4, r11, 0x5a40
	ctx.r[4].s64 = ctx.r[11].s64 + 23104;
	// 8286667C: 48941A7D  bl 0x831a80f8
	ctx.lr = 0x82866680;
	sub_831A80F8(ctx, base);
	// 82866680: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82866684: 4182000C  beq 0x82866690
	if ctx.cr[0].eq {
	pc = 0x82866690; continue 'dispatch;
	}
	// 82866688: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8286668C: 4800000C  b 0x82866698
	pc = 0x82866698; continue 'dispatch;
	// 82866690: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82866694: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82866698: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286669C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828666A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828666A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828666A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828666AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828666B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828666B0 size=136
    let mut pc: u32 = 0x828666B0;
    'dispatch: loop {
        match pc {
            0x828666B0 => {
    //   block [0x828666B0..0x82866738)
	// 828666B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828666B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828666B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828666BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828666C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828666C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828666C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828666CC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828666D0: 409A0020  bne cr6, 0x828666f0
	if !ctx.cr[6].eq {
	pc = 0x828666F0; continue 'dispatch;
	}
	// 828666D4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828666D8: 419A0048  beq cr6, 0x82866720
	if ctx.cr[6].eq {
	pc = 0x82866720; continue 'dispatch;
	}
	// 828666DC: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828666E0: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828666E4: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828666E8: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828666EC: 48000034  b 0x82866720
	pc = 0x82866720; continue 'dispatch;
	// 828666F0: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828666F4: 419A002C  beq cr6, 0x82866720
	if ctx.cr[6].eq {
	pc = 0x82866720; continue 'dispatch;
	}
	// 828666F8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828666FC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866700: 388B5B08  addi r4, r11, 0x5b08
	ctx.r[4].s64 = ctx.r[11].s64 + 23304;
	// 82866704: 489419F5  bl 0x831a80f8
	ctx.lr = 0x82866708;
	sub_831A80F8(ctx, base);
	// 82866708: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286670C: 4182000C  beq 0x82866718
	if ctx.cr[0].eq {
	pc = 0x82866718; continue 'dispatch;
	}
	// 82866710: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82866714: 4800000C  b 0x82866720
	pc = 0x82866720; continue 'dispatch;
	// 82866718: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8286671C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82866720: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82866724: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82866728: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286672C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82866730: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82866734: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82866738 size=16
    let mut pc: u32 = 0x82866738;
    'dispatch: loop {
        match pc {
            0x82866738 => {
    //   block [0x82866738..0x82866748)
	// 82866738: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286673C: 816C0064  lwz r11, 0x64(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(100 as u32) ) } as u64;
	// 82866740: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82866744: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82866748 size=124
    let mut pc: u32 = 0x82866748;
    'dispatch: loop {
        match pc {
            0x82866748 => {
    //   block [0x82866748..0x828667C4)
	// 82866748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286674C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82866750: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82866754: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82866758: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286675C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82866760: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82866764: 480AA15D  bl 0x829108c0
	ctx.lr = 0x82866768;
	sub_829108C0(ctx, base);
	// 82866768: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286676C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866770: 40820034  bne 0x828667a4
	if !ctx.cr[0].eq {
	pc = 0x828667A4; continue 'dispatch;
	}
	// 82866774: 4BF859AD  bl 0x827ec120
	ctx.lr = 0x82866778;
	sub_827EC120(ctx, base);
	// 82866778: 807F0360  lwz r3, 0x360(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(864 as u32) ) } as u64;
	// 8286677C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866780: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82866784: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82866788: 4E800421  bctrl
	ctx.lr = 0x8286678C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286678C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82866790: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866794: 480A799D  bl 0x8290e130
	ctx.lr = 0x82866798;
	sub_8290E130(ctx, base);
	// 82866798: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286679C: 480A64D5  bl 0x8290cc70
	ctx.lr = 0x828667A0;
	sub_8290CC70(ctx, base);
	// 828667A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828667A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828667A8: 480AA9D9  bl 0x82911180
	ctx.lr = 0x828667AC;
	sub_82911180(ctx, base);
	// 828667AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828667B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828667B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828667B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828667BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828667C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828667C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828667C8 size=8
    let mut pc: u32 = 0x828667C8;
    'dispatch: loop {
        match pc {
            0x828667C8 => {
    //   block [0x828667C8..0x828667D0)
	// 828667C8: 80630370  lwz r3, 0x370(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(880 as u32) ) } as u64;
	// 828667CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828667D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828667D0 size=112
    let mut pc: u32 = 0x828667D0;
    'dispatch: loop {
        match pc {
            0x828667D0 => {
    //   block [0x828667D0..0x82866840)
	// 828667D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828667D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828667D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828667DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828667E0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828667E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828667E8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828667EC: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 828667F0: 4BF859F9  bl 0x827ec1e8
	ctx.lr = 0x828667F4;
	sub_827EC1E8(ctx, base);
	// 828667F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828667F8: 4BA86E41  bl 0x822ed638
	ctx.lr = 0x828667FC;
	sub_822ED638(ctx, base);
	// 828667FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82866800: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866804: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82866808: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8286680C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82866810: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82866814: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82866818: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8286681C: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82866820: 486154A9  bl 0x82e7bcc8
	ctx.lr = 0x82866824;
	sub_82E7BCC8(ctx, base);
	// 82866824: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866828: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8286682C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82866830: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82866834: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82866838: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286683C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82866840 size=84
    let mut pc: u32 = 0x82866840;
    'dispatch: loop {
        match pc {
            0x82866840 => {
    //   block [0x82866840..0x82866894)
	// 82866840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82866844: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82866848: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286684C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82866850: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82866854: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82866858: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 8286685C: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82866860: 4BF85989  bl 0x827ec1e8
	ctx.lr = 0x82866864;
	sub_827EC1E8(ctx, base);
	// 82866864: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82866868: 4BA86DD1  bl 0x822ed638
	ctx.lr = 0x8286686C;
	sub_822ED638(ctx, base);
	// 8286686C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866870: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82866874: 48616595  bl 0x82e7ce08
	ctx.lr = 0x82866878;
	sub_82E7CE08(ctx, base);
	// 82866878: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286687C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82866880: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82866884: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82866888: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8286688C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82866890: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82866898 size=152
    let mut pc: u32 = 0x82866898;
    'dispatch: loop {
        match pc {
            0x82866898 => {
    //   block [0x82866898..0x82866930)
	// 82866898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286689C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828668A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828668A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828668A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828668AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828668B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828668B4: 807F0360  lwz r3, 0x360(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(864 as u32) ) } as u64;
	// 828668B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828668BC: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 828668C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828668C4: 4E800421  bctrl
	ctx.lr = 0x828668C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828668C8: 807F0360  lwz r3, 0x360(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(864 as u32) ) } as u64;
	// 828668CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828668D0: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828668D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828668D8: 4E800421  bctrl
	ctx.lr = 0x828668DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828668DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828668E0: 41820038  beq 0x82866918
	if ctx.cr[0].eq {
	pc = 0x82866918; continue 'dispatch;
	}
	// 828668E4: 807F0360  lwz r3, 0x360(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(864 as u32) ) } as u64;
	// 828668E8: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828668EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828668F0: 41820018  beq 0x82866908
	if ctx.cr[0].eq {
	pc = 0x82866908; continue 'dispatch;
	}
	// 828668F4: 480047ED  bl 0x8286b0e0
	ctx.lr = 0x828668F8;
	sub_8286B0E0(ctx, base);
	// 828668F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828668FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866900: 4BCAB3C1  bl 0x82511cc0
	ctx.lr = 0x82866904;
	sub_82511CC0(ctx, base);
	// 82866904: 48000014  b 0x82866918
	pc = 0x82866918; continue 'dispatch;
	// 82866908: 480047D9  bl 0x8286b0e0
	ctx.lr = 0x8286690C;
	sub_8286B0E0(ctx, base);
	// 8286690C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82866910: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866914: 4BCAB38D  bl 0x82511ca0
	ctx.lr = 0x82866918;
	sub_82511CA0(ctx, base);
	// 82866918: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286691C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82866920: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82866924: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82866928: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286692C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82866930 size=84
    let mut pc: u32 = 0x82866930;
    'dispatch: loop {
        match pc {
            0x82866930 => {
    //   block [0x82866930..0x82866984)
	// 82866930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82866934: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82866938: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286693C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82866940: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82866944: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82866948: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8286694C: 807F01DC  lwz r3, 0x1dc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(476 as u32) ) } as u64;
	// 82866950: 4BF83A19  bl 0x827ea368
	ctx.lr = 0x82866954;
	sub_827EA368(ctx, base);
	// 82866954: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82866958: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 8286695C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82866960: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 82866964: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82866968: 4E800421  bctrl
	ctx.lr = 0x8286696C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286696C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82866970: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82866974: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82866978: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8286697C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82866980: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82866988 size=196
    let mut pc: u32 = 0x82866988;
    'dispatch: loop {
        match pc {
            0x82866988 => {
    //   block [0x82866988..0x82866A4C)
	// 82866988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286698C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82866990: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82866994: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82866998: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286699C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828669A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828669A4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828669A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828669AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828669B0: 4BA59F89  bl 0x822c0938
	ctx.lr = 0x828669B4;
	sub_822C0938(ctx, base);
	// 828669B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828669B8: 41820028  beq 0x828669e0
	if ctx.cr[0].eq {
	pc = 0x828669E0; continue 'dispatch;
	}
	// 828669BC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828669C0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828669C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828669C8: 392B0A2C  addi r9, r11, 0xa2c
	ctx.r[9].s64 = ctx.r[11].s64 + 2604;
	// 828669CC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828669D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828669D4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828669D8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828669DC: 48000008  b 0x828669e4
	pc = 0x828669E4; continue 'dispatch;
	// 828669E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828669E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828669E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828669EC: 409A0044  bne cr6, 0x82866a30
	if !ctx.cr[6].eq {
	pc = 0x82866A30; continue 'dispatch;
	}
	// 828669F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828669F4: 419A001C  beq cr6, 0x82866a10
	if ctx.cr[6].eq {
	pc = 0x82866A10; continue 'dispatch;
	}
	// 828669F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828669FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82866A00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866A04: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866A08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82866A0C: 4E800421  bctrl
	ctx.lr = 0x82866A10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82866A10: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82866A14: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82866A18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82866A1C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82866A20: 816B5618  lwz r11, 0x5618(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22040 as u32) ) } as u64;
	// 82866A24: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82866A28: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82866A2C: 4BA595D5  bl 0x822c0000
	ctx.lr = 0x82866A30;
	sub_822C0000(ctx, base);
	// 82866A30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82866A34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82866A38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82866A3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82866A40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82866A44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82866A48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82866A50 size=196
    let mut pc: u32 = 0x82866A50;
    'dispatch: loop {
        match pc {
            0x82866A50 => {
    //   block [0x82866A50..0x82866B14)
	// 82866A50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82866A54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82866A58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82866A5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82866A60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82866A64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82866A68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82866A6C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82866A70: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82866A74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82866A78: 4BA59EC1  bl 0x822c0938
	ctx.lr = 0x82866A7C;
	sub_822C0938(ctx, base);
	// 82866A7C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82866A80: 41820028  beq 0x82866aa8
	if ctx.cr[0].eq {
	pc = 0x82866AA8; continue 'dispatch;
	}
	// 82866A84: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82866A88: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82866A8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82866A90: 392B0A40  addi r9, r11, 0xa40
	ctx.r[9].s64 = ctx.r[11].s64 + 2624;
	// 82866A94: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82866A98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82866A9C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82866AA0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82866AA4: 48000008  b 0x82866aac
	pc = 0x82866AAC; continue 'dispatch;
	// 82866AA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82866AAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82866AB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82866AB4: 409A0044  bne cr6, 0x82866af8
	if !ctx.cr[6].eq {
	pc = 0x82866AF8; continue 'dispatch;
	}
	// 82866AB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82866ABC: 419A001C  beq cr6, 0x82866ad8
	if ctx.cr[6].eq {
	pc = 0x82866AD8; continue 'dispatch;
	}
	// 82866AC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866AC4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82866AC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866ACC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866AD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82866AD4: 4E800421  bctrl
	ctx.lr = 0x82866AD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82866AD8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82866ADC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82866AE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82866AE4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82866AE8: 816B5618  lwz r11, 0x5618(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22040 as u32) ) } as u64;
	// 82866AEC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82866AF0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82866AF4: 4BA5950D  bl 0x822c0000
	ctx.lr = 0x82866AF8;
	sub_822C0000(ctx, base);
	// 82866AF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82866AFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82866B00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82866B04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82866B08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82866B0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82866B10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82866B18 size=196
    let mut pc: u32 = 0x82866B18;
    'dispatch: loop {
        match pc {
            0x82866B18 => {
    //   block [0x82866B18..0x82866BDC)
	// 82866B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82866B1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82866B20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82866B24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82866B28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82866B2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82866B30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82866B34: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82866B38: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82866B3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82866B40: 4BA59DF9  bl 0x822c0938
	ctx.lr = 0x82866B44;
	sub_822C0938(ctx, base);
	// 82866B44: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82866B48: 41820028  beq 0x82866b70
	if ctx.cr[0].eq {
	pc = 0x82866B70; continue 'dispatch;
	}
	// 82866B4C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82866B50: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82866B54: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82866B58: 392B0A54  addi r9, r11, 0xa54
	ctx.r[9].s64 = ctx.r[11].s64 + 2644;
	// 82866B5C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82866B60: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82866B64: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82866B68: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82866B6C: 48000008  b 0x82866b74
	pc = 0x82866B74; continue 'dispatch;
	// 82866B70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82866B74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82866B78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82866B7C: 409A0044  bne cr6, 0x82866bc0
	if !ctx.cr[6].eq {
	pc = 0x82866BC0; continue 'dispatch;
	}
	// 82866B80: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82866B84: 419A001C  beq cr6, 0x82866ba0
	if ctx.cr[6].eq {
	pc = 0x82866BA0; continue 'dispatch;
	}
	// 82866B88: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866B8C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82866B90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866B94: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866B98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82866B9C: 4E800421  bctrl
	ctx.lr = 0x82866BA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82866BA0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82866BA4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82866BA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82866BAC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82866BB0: 816B5618  lwz r11, 0x5618(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22040 as u32) ) } as u64;
	// 82866BB4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82866BB8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82866BBC: 4BA59445  bl 0x822c0000
	ctx.lr = 0x82866BC0;
	sub_822C0000(ctx, base);
	// 82866BC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82866BC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82866BC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82866BCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82866BD0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82866BD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82866BD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82866BE0 size=196
    let mut pc: u32 = 0x82866BE0;
    'dispatch: loop {
        match pc {
            0x82866BE0 => {
    //   block [0x82866BE0..0x82866CA4)
	// 82866BE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82866BE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82866BE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82866BEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82866BF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82866BF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82866BF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82866BFC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82866C00: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82866C04: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82866C08: 4BA59D31  bl 0x822c0938
	ctx.lr = 0x82866C0C;
	sub_822C0938(ctx, base);
	// 82866C0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82866C10: 41820028  beq 0x82866c38
	if ctx.cr[0].eq {
	pc = 0x82866C38; continue 'dispatch;
	}
	// 82866C14: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82866C18: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82866C1C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82866C20: 392B0A68  addi r9, r11, 0xa68
	ctx.r[9].s64 = ctx.r[11].s64 + 2664;
	// 82866C24: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82866C28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82866C2C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82866C30: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82866C34: 48000008  b 0x82866c3c
	pc = 0x82866C3C; continue 'dispatch;
	// 82866C38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82866C3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82866C40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82866C44: 409A0044  bne cr6, 0x82866c88
	if !ctx.cr[6].eq {
	pc = 0x82866C88; continue 'dispatch;
	}
	// 82866C48: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82866C4C: 419A001C  beq cr6, 0x82866c68
	if ctx.cr[6].eq {
	pc = 0x82866C68; continue 'dispatch;
	}
	// 82866C50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866C54: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82866C58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866C5C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82866C60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82866C64: 4E800421  bctrl
	ctx.lr = 0x82866C68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82866C68: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82866C6C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82866C70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82866C74: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82866C78: 816B5618  lwz r11, 0x5618(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22040 as u32) ) } as u64;
	// 82866C7C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82866C80: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82866C84: 4BA5937D  bl 0x822c0000
	ctx.lr = 0x82866C88;
	sub_822C0000(ctx, base);
	// 82866C88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82866C8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82866C90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82866C94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82866C98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82866C9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82866CA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82866CA8 size=196
    let mut pc: u32 = 0x82866CA8;
    'dispatch: loop {
        match pc {
            0x82866CA8 => {
    //   block [0x82866CA8..0x82866D6C)
	// 82866CA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82866CAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82866CB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82866CB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82866CB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82866CBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82866CC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82866CC4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82866CC8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82866CCC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82866CD0: 4BA59C69  bl 0x822c0938
	ctx.lr = 0x82866CD4;
	sub_822C0938(ctx, base);
	// 82866CD4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82866CD8: 41820028  beq 0x82866d00
	if ctx.cr[0].eq {
	pc = 0x82866D00; continue 'dispatch;
	}
	// 82866CDC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82866CE0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82866CE4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82866CE8: 392B0A7C  addi r9, r11, 0xa7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2684;
	// 82866CEC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82866CF0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82866CF4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82866CF8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82866CFC: 48000008  b 0x82866d04
	pc = 0x82866D04; continue 'dispatch;
	// 82866D00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82866D04: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82866D08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82866D0C: 409A0044  bne cr6, 0x82866d50
	if !ctx.cr[6].eq {
	pc = 0x82866D50; continue 'dispatch;
	}
	// 82866D10: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82866D14: 419A001C  beq cr6, 0x82866d30
	if ctx.cr[6].eq {
	pc = 0x82866D30; continue 'dispatch;
	}
	// 82866D18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866D1C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82866D20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866D24: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866D28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82866D2C: 4E800421  bctrl
	ctx.lr = 0x82866D30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82866D30: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82866D34: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82866D38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82866D3C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82866D40: 816B5618  lwz r11, 0x5618(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22040 as u32) ) } as u64;
	// 82866D44: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82866D48: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82866D4C: 4BA592B5  bl 0x822c0000
	ctx.lr = 0x82866D50;
	sub_822C0000(ctx, base);
	// 82866D50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82866D54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82866D58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82866D5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82866D60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82866D64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82866D68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82866D70 size=196
    let mut pc: u32 = 0x82866D70;
    'dispatch: loop {
        match pc {
            0x82866D70 => {
    //   block [0x82866D70..0x82866E34)
	// 82866D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82866D74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82866D78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82866D7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82866D80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82866D84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82866D88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82866D8C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82866D90: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82866D94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82866D98: 4BA59BA1  bl 0x822c0938
	ctx.lr = 0x82866D9C;
	sub_822C0938(ctx, base);
	// 82866D9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82866DA0: 41820028  beq 0x82866dc8
	if ctx.cr[0].eq {
	pc = 0x82866DC8; continue 'dispatch;
	}
	// 82866DA4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82866DA8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82866DAC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82866DB0: 392B0AA4  addi r9, r11, 0xaa4
	ctx.r[9].s64 = ctx.r[11].s64 + 2724;
	// 82866DB4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82866DB8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82866DBC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82866DC0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82866DC4: 48000008  b 0x82866dcc
	pc = 0x82866DCC; continue 'dispatch;
	// 82866DC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82866DCC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82866DD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82866DD4: 409A0044  bne cr6, 0x82866e18
	if !ctx.cr[6].eq {
	pc = 0x82866E18; continue 'dispatch;
	}
	// 82866DD8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82866DDC: 419A001C  beq cr6, 0x82866df8
	if ctx.cr[6].eq {
	pc = 0x82866DF8; continue 'dispatch;
	}
	// 82866DE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866DE4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82866DE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866DEC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866DF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82866DF4: 4E800421  bctrl
	ctx.lr = 0x82866DF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82866DF8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82866DFC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82866E00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82866E04: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82866E08: 816B5618  lwz r11, 0x5618(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22040 as u32) ) } as u64;
	// 82866E0C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82866E10: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82866E14: 4BA591ED  bl 0x822c0000
	ctx.lr = 0x82866E18;
	sub_822C0000(ctx, base);
	// 82866E18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82866E1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82866E20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82866E24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82866E28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82866E2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82866E30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82866E38 size=196
    let mut pc: u32 = 0x82866E38;
    'dispatch: loop {
        match pc {
            0x82866E38 => {
    //   block [0x82866E38..0x82866EFC)
	// 82866E38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82866E3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82866E40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82866E44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82866E48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82866E4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82866E50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82866E54: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82866E58: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82866E5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82866E60: 4BA59AD9  bl 0x822c0938
	ctx.lr = 0x82866E64;
	sub_822C0938(ctx, base);
	// 82866E64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82866E68: 41820028  beq 0x82866e90
	if ctx.cr[0].eq {
	pc = 0x82866E90; continue 'dispatch;
	}
	// 82866E6C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82866E70: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82866E74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82866E78: 392B0AB8  addi r9, r11, 0xab8
	ctx.r[9].s64 = ctx.r[11].s64 + 2744;
	// 82866E7C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82866E80: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82866E84: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82866E88: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82866E8C: 48000008  b 0x82866e94
	pc = 0x82866E94; continue 'dispatch;
	// 82866E90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82866E94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82866E98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82866E9C: 409A0044  bne cr6, 0x82866ee0
	if !ctx.cr[6].eq {
	pc = 0x82866EE0; continue 'dispatch;
	}
	// 82866EA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82866EA4: 419A001C  beq cr6, 0x82866ec0
	if ctx.cr[6].eq {
	pc = 0x82866EC0; continue 'dispatch;
	}
	// 82866EA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866EAC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82866EB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866EB4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866EB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82866EBC: 4E800421  bctrl
	ctx.lr = 0x82866EC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82866EC0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82866EC4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82866EC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82866ECC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82866ED0: 816B5618  lwz r11, 0x5618(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22040 as u32) ) } as u64;
	// 82866ED4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82866ED8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82866EDC: 4BA59125  bl 0x822c0000
	ctx.lr = 0x82866EE0;
	sub_822C0000(ctx, base);
	// 82866EE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82866EE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82866EE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82866EEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82866EF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82866EF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82866EF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82866F00 size=196
    let mut pc: u32 = 0x82866F00;
    'dispatch: loop {
        match pc {
            0x82866F00 => {
    //   block [0x82866F00..0x82866FC4)
	// 82866F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82866F04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82866F08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82866F0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82866F10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82866F14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82866F18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82866F1C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82866F20: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82866F24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82866F28: 4BA59A11  bl 0x822c0938
	ctx.lr = 0x82866F2C;
	sub_822C0938(ctx, base);
	// 82866F2C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82866F30: 41820028  beq 0x82866f58
	if ctx.cr[0].eq {
	pc = 0x82866F58; continue 'dispatch;
	}
	// 82866F34: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82866F38: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82866F3C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82866F40: 392B0ACC  addi r9, r11, 0xacc
	ctx.r[9].s64 = ctx.r[11].s64 + 2764;
	// 82866F44: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82866F48: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82866F4C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82866F50: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82866F54: 48000008  b 0x82866f5c
	pc = 0x82866F5C; continue 'dispatch;
	// 82866F58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82866F5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82866F60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82866F64: 409A0044  bne cr6, 0x82866fa8
	if !ctx.cr[6].eq {
	pc = 0x82866FA8; continue 'dispatch;
	}
	// 82866F68: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82866F6C: 419A001C  beq cr6, 0x82866f88
	if ctx.cr[6].eq {
	pc = 0x82866F88; continue 'dispatch;
	}
	// 82866F70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866F74: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82866F78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82866F7C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82866F80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82866F84: 4E800421  bctrl
	ctx.lr = 0x82866F88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82866F88: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82866F8C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82866F90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82866F94: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82866F98: 816B5618  lwz r11, 0x5618(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22040 as u32) ) } as u64;
	// 82866F9C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82866FA0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82866FA4: 4BA5905D  bl 0x822c0000
	ctx.lr = 0x82866FA8;
	sub_822C0000(ctx, base);
	// 82866FA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82866FAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82866FB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82866FB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82866FB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82866FBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82866FC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82866FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82866FC8 size=196
    let mut pc: u32 = 0x82866FC8;
    'dispatch: loop {
        match pc {
            0x82866FC8 => {
    //   block [0x82866FC8..0x8286708C)
	// 82866FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82866FCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82866FD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82866FD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82866FD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82866FDC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82866FE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82866FE4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82866FE8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82866FEC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82866FF0: 4BA59949  bl 0x822c0938
	ctx.lr = 0x82866FF4;
	sub_822C0938(ctx, base);
	// 82866FF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82866FF8: 41820028  beq 0x82867020
	if ctx.cr[0].eq {
	pc = 0x82867020; continue 'dispatch;
	}
	// 82866FFC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82867000: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82867004: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82867008: 392B0AE0  addi r9, r11, 0xae0
	ctx.r[9].s64 = ctx.r[11].s64 + 2784;
	// 8286700C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82867010: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82867014: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82867018: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8286701C: 48000008  b 0x82867024
	pc = 0x82867024; continue 'dispatch;
	// 82867020: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82867024: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82867028: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286702C: 409A0044  bne cr6, 0x82867070
	if !ctx.cr[6].eq {
	pc = 0x82867070; continue 'dispatch;
	}
	// 82867030: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82867034: 419A001C  beq cr6, 0x82867050
	if ctx.cr[6].eq {
	pc = 0x82867050; continue 'dispatch;
	}
	// 82867038: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286703C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82867040: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867044: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82867048: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8286704C: 4E800421  bctrl
	ctx.lr = 0x82867050;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82867050: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82867054: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82867058: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286705C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82867060: 816B5618  lwz r11, 0x5618(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22040 as u32) ) } as u64;
	// 82867064: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82867068: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8286706C: 4BA58F95  bl 0x822c0000
	ctx.lr = 0x82867070;
	sub_822C0000(ctx, base);
	// 82867070: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82867074: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82867078: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286707C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82867080: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82867084: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82867088: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82867090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82867090 size=72
    let mut pc: u32 = 0x82867090;
    'dispatch: loop {
        match pc {
            0x82867090 => {
    //   block [0x82867090..0x828670D8)
	// 82867090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82867094: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82867098: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286709C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828670A0: 419A001C  beq cr6, 0x828670bc
	if ctx.cr[6].eq {
	pc = 0x828670BC; continue 'dispatch;
	}
	// 828670A4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828670A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828670AC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828670B0: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828670B4: 4BFFF47D  bl 0x82866530
	ctx.lr = 0x828670B8;
	sub_82866530(ctx, base);
	// 828670B8: 48000010  b 0x828670c8
	pc = 0x828670C8; continue 'dispatch;
	// 828670BC: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828670C0: 396B59A8  addi r11, r11, 0x59a8
	ctx.r[11].s64 = ctx.r[11].s64 + 22952;
	// 828670C4: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828670C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828670CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828670D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828670D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828670D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828670D8 size=72
    let mut pc: u32 = 0x828670D8;
    'dispatch: loop {
        match pc {
            0x828670D8 => {
    //   block [0x828670D8..0x82867120)
	// 828670D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828670DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828670E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828670E4: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828670E8: 419A001C  beq cr6, 0x82867104
	if ctx.cr[6].eq {
	pc = 0x82867104; continue 'dispatch;
	}
	// 828670EC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828670F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828670F4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828670F8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828670FC: 4BFFF4AD  bl 0x828665a8
	ctx.lr = 0x82867100;
	sub_828665A8(ctx, base);
	// 82867100: 48000010  b 0x82867110
	pc = 0x82867110; continue 'dispatch;
	// 82867104: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82867108: 396B59F8  addi r11, r11, 0x59f8
	ctx.r[11].s64 = ctx.r[11].s64 + 23032;
	// 8286710C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82867110: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82867114: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82867118: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286711C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82867120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82867120 size=172
    let mut pc: u32 = 0x82867120;
    'dispatch: loop {
        match pc {
            0x82867120 => {
    //   block [0x82867120..0x828671CC)
	// 82867120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82867124: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82867128: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286712C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82867130: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82867134: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82867138: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8286713C: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 82867140: 396B0CCC  addi r11, r11, 0xccc
	ctx.r[11].s64 = ctx.r[11].s64 + 3276;
	// 82867144: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82867148: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 8286714C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82867150: 394A0B0C  addi r10, r10, 0xb0c
	ctx.r[10].s64 = ctx.r[10].s64 + 2828;
	// 82867154: 807F0388  lwz r3, 0x388(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(904 as u32) ) } as u64;
	// 82867158: 39290AF4  addi r9, r9, 0xaf4
	ctx.r[9].s64 = ctx.r[9].s64 + 2804;
	// 8286715C: 39680CB0  addi r11, r8, 0xcb0
	ctx.r[11].s64 = ctx.r[8].s64 + 3248;
	// 82867160: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82867164: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 82867168: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 8286716C: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 82867170: 4BA590F9  bl 0x822c0268
	ctx.lr = 0x82867174;
	sub_822C0268(ctx, base);
	// 82867174: 807F0384  lwz r3, 0x384(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(900 as u32) ) } as u64;
	// 82867178: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286717C: 419A0008  beq cr6, 0x82867184
	if ctx.cr[6].eq {
	pc = 0x82867184; continue 'dispatch;
	}
	// 82867180: 4BA59711  bl 0x822c0890
	ctx.lr = 0x82867184;
	sub_822C0890(ctx, base);
	// 82867184: 807F037C  lwz r3, 0x37c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(892 as u32) ) } as u64;
	// 82867188: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286718C: 419A0008  beq cr6, 0x82867194
	if ctx.cr[6].eq {
	pc = 0x82867194; continue 'dispatch;
	}
	// 82867190: 4BA59701  bl 0x822c0890
	ctx.lr = 0x82867194;
	sub_822C0890(ctx, base);
	// 82867194: 807F0374  lwz r3, 0x374(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(884 as u32) ) } as u64;
	// 82867198: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286719C: 419A0008  beq cr6, 0x828671a4
	if ctx.cr[6].eq {
	pc = 0x828671A4; continue 'dispatch;
	}
	// 828671A0: 4BA596F1  bl 0x822c0890
	ctx.lr = 0x828671A4;
	sub_822C0890(ctx, base);
	// 828671A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828671A8: 480A9AE9  bl 0x82910c90
	ctx.lr = 0x828671AC;
	sub_82910C90(ctx, base);
	// 828671AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828671B0: 4BF404A9  bl 0x827a7658
	ctx.lr = 0x828671B4;
	sub_827A7658(ctx, base);
	// 828671B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828671B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828671BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828671C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828671C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828671C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828671D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828671D0 size=8
    let mut pc: u32 = 0x828671D0;
    'dispatch: loop {
        match pc {
            0x828671D0 => {
    //   block [0x828671D0..0x828671D8)
	// 828671D0: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828671D4: 48000934  b 0x82867b08
	sub_82867B08(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828671D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828671D8 size=8
    let mut pc: u32 = 0x828671D8;
    'dispatch: loop {
        match pc {
            0x828671D8 => {
    //   block [0x828671D8..0x828671E0)
	// 828671D8: 3863FFC8  addi r3, r3, -0x38
	ctx.r[3].s64 = ctx.r[3].s64 + -56;
	// 828671DC: 4800092C  b 0x82867b08
	sub_82867B08(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828671E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828671E0 size=8
    let mut pc: u32 = 0x828671E0;
    'dispatch: loop {
        match pc {
            0x828671E0 => {
    //   block [0x828671E0..0x828671E8)
	// 828671E0: 3863FDE8  addi r3, r3, -0x218
	ctx.r[3].s64 = ctx.r[3].s64 + -536;
	// 828671E4: 48000924  b 0x82867b08
	sub_82867B08(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828671E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828671E8 size=60
    let mut pc: u32 = 0x828671E8;
    'dispatch: loop {
        match pc {
            0x828671E8 => {
    //   block [0x828671E8..0x82867224)
	// 828671E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828671EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828671F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828671F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828671F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828671FC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82867200: 4BF84FE9  bl 0x827ec1e8
	ctx.lr = 0x82867204;
	sub_827EC1E8(ctx, base);
	// 82867204: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82867208: 4BA86431  bl 0x822ed638
	ctx.lr = 0x8286720C;
	sub_822ED638(ctx, base);
	// 8286720C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867210: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82867214: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82867218: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286721C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82867220: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82867228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82867228 size=8
    let mut pc: u32 = 0x82867228;
    'dispatch: loop {
        match pc {
            0x82867228 => {
    //   block [0x82867228..0x82867230)
	// 82867228: 3863FDE8  addi r3, r3, -0x218
	ctx.r[3].s64 = ctx.r[3].s64 + -536;
	// 8286722C: 48000DF4  b 0x82868020
	sub_82868020(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82867230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82867230 size=8
    let mut pc: u32 = 0x82867230;
    'dispatch: loop {
        match pc {
            0x82867230 => {
    //   block [0x82867230..0x82867238)
	// 82867230: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82867234: 48000DEC  b 0x82868020
	sub_82868020(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82867238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82867238 size=8
    let mut pc: u32 = 0x82867238;
    'dispatch: loop {
        match pc {
            0x82867238 => {
    //   block [0x82867238..0x82867240)
	// 82867238: 3863FFC8  addi r3, r3, -0x38
	ctx.r[3].s64 = ctx.r[3].s64 + -56;
	// 8286723C: 48000DE4  b 0x82868020
	sub_82868020(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82867240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82867240 size=396
    let mut pc: u32 = 0x82867240;
    'dispatch: loop {
        match pc {
            0x82867240 => {
    //   block [0x82867240..0x828673CC)
	// 82867240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82867244: 48940F21  bl 0x831a8164
	ctx.lr = 0x82867248;
	sub_831A8130(ctx, base);
	// 82867248: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286724C: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 82867250: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82867254: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82867258: 388B77C4  addi r4, r11, 0x77c4
	ctx.r[4].s64 = ctx.r[11].s64 + 30660;
	// 8286725C: 4858C7AD  bl 0x82df3a08
	ctx.lr = 0x82867260;
	sub_82DF3A08(ctx, base);
	// 82867260: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82867264: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82867268: 388B0F90  addi r4, r11, 0xf90
	ctx.r[4].s64 = ctx.r[11].s64 + 3984;
	// 8286726C: 4858C79D  bl 0x82df3a08
	ctx.lr = 0x82867270;
	sub_82DF3A08(ctx, base);
	// 82867270: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82867274: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82867278: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8286727C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82867280: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82867284: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82867288: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8286728C: 4E800421  bctrl
	ctx.lr = 0x82867290;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82867290: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82867294: 4858C195  bl 0x82df3428
	ctx.lr = 0x82867298;
	sub_82DF3428(ctx, base);
	// 82867298: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286729C: 4858C18D  bl 0x82df3428
	ctx.lr = 0x828672A0;
	sub_82DF3428(ctx, base);
	// 828672A0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828672A4: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828672A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828672AC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828672B0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828672B4: 419A0024  beq cr6, 0x828672d8
	if ctx.cr[6].eq {
	pc = 0x828672D8; continue 'dispatch;
	}
	// 828672B8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828672BC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828672C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828672C4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828672C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828672CC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828672D0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828672D4: 4082FFE8  bne 0x828672bc
	if !ctx.cr[0].eq {
	pc = 0x828672BC; continue 'dispatch;
	}
	// 828672D8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828672DC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828672E0: 386BBAE0  addi r3, r11, -0x4520
	ctx.r[3].s64 = ctx.r[11].s64 + -17696;
	// 828672E4: 4800450D  bl 0x8286b7f0
	ctx.lr = 0x828672E8;
	sub_8286B7F0(ctx, base);
	// 828672E8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828672EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828672F0: 3BCBBB68  addi r30, r11, -0x4498
	ctx.r[30].s64 = ctx.r[11].s64 + -17560;
	// 828672F4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828672F8: 3BA0000A  li r29, 0xa
	ctx.r[29].s64 = 10;
	// 828672FC: 3B8B0F7C  addi r28, r11, 0xf7c
	ctx.r[28].s64 = ctx.r[11].s64 + 3964;
	// 82867300: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82867304: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82867308: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8286730C: 489417CD  bl 0x831a8ad8
	ctx.lr = 0x82867310;
	sub_831A8AD8(ctx, base);
	// 82867310: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82867314: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82867318: 4858C6F1  bl 0x82df3a08
	ctx.lr = 0x8286731C;
	sub_82DF3A08(ctx, base);
	// 8286731C: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82867320: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82867324: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82867328: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286732C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82867330: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82867334: 4E800421  bctrl
	ctx.lr = 0x82867338;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82867338: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286733C: 4858C0ED  bl 0x82df3428
	ctx.lr = 0x82867340;
	sub_82DF3428(ctx, base);
	// 82867340: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82867344: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82867348: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286734C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82867350: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82867354: 419A0024  beq cr6, 0x82867378
	if ctx.cr[6].eq {
	pc = 0x82867378; continue 'dispatch;
	}
	// 82867358: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8286735C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82867360: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82867364: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82867368: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8286736C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82867370: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82867374: 4082FFE8  bne 0x8286735c
	if !ctx.cr[0].eq {
	pc = 0x8286735C; continue 'dispatch;
	}
	// 82867378: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286737C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82867380: 48004A29  bl 0x8286bda8
	ctx.lr = 0x82867384;
	sub_8286BDA8(ctx, base);
	// 82867384: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82867388: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286738C: 419A0008  beq cr6, 0x82867394
	if ctx.cr[6].eq {
	pc = 0x82867394; continue 'dispatch;
	}
	// 82867390: 4BA59501  bl 0x822c0890
	ctx.lr = 0x82867394;
	sub_822C0890(ctx, base);
	// 82867394: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82867398: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 8286739C: 3BDE00C0  addi r30, r30, 0xc0
	ctx.r[30].s64 = ctx.r[30].s64 + 192;
	// 828673A0: 4082FF60  bne 0x82867300
	if !ctx.cr[0].eq {
	pc = 0x82867300; continue 'dispatch;
	}
	// 828673A4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828673A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828673AC: 419A0008  beq cr6, 0x828673b4
	if ctx.cr[6].eq {
	pc = 0x828673B4; continue 'dispatch;
	}
	// 828673B0: 4BA594E1  bl 0x822c0890
	ctx.lr = 0x828673B4;
	sub_822C0890(ctx, base);
	// 828673B4: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828673B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828673BC: 419A0008  beq cr6, 0x828673c4
	if ctx.cr[6].eq {
	pc = 0x828673C4; continue 'dispatch;
	}
	// 828673C0: 4BA594D1  bl 0x822c0890
	ctx.lr = 0x828673C4;
	sub_822C0890(ctx, base);
	// 828673C4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828673C8: 48940DEC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828673D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828673D0 size=8
    let mut pc: u32 = 0x828673D0;
    'dispatch: loop {
        match pc {
            0x828673D0 => {
    //   block [0x828673D0..0x828673D8)
	// 828673D0: 3863FFC8  addi r3, r3, -0x38
	ctx.r[3].s64 = ctx.r[3].s64 + -56;
	// 828673D4: 48000DB4  b 0x82868188
	sub_82868188(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828673D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828673D8 size=8
    let mut pc: u32 = 0x828673D8;
    'dispatch: loop {
        match pc {
            0x828673D8 => {
    //   block [0x828673D8..0x828673E0)
	// 828673D8: 3863FDE8  addi r3, r3, -0x218
	ctx.r[3].s64 = ctx.r[3].s64 + -536;
	// 828673DC: 48000DAC  b 0x82868188
	sub_82868188(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828673E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828673E0 size=8
    let mut pc: u32 = 0x828673E0;
    'dispatch: loop {
        match pc {
            0x828673E0 => {
    //   block [0x828673E0..0x828673E8)
	// 828673E0: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828673E4: 48000DA4  b 0x82868188
	sub_82868188(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828673E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828673E8 size=396
    let mut pc: u32 = 0x828673E8;
    'dispatch: loop {
        match pc {
            0x828673E8 => {
    //   block [0x828673E8..0x82867574)
	// 828673E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828673EC: 48940D79  bl 0x831a8164
	ctx.lr = 0x828673F0;
	sub_831A8130(ctx, base);
	// 828673F0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828673F4: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 828673F8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828673FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82867400: 388B7540  addi r4, r11, 0x7540
	ctx.r[4].s64 = ctx.r[11].s64 + 30016;
	// 82867404: 4858C605  bl 0x82df3a08
	ctx.lr = 0x82867408;
	sub_82DF3A08(ctx, base);
	// 82867408: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8286740C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82867410: 388B11E4  addi r4, r11, 0x11e4
	ctx.r[4].s64 = ctx.r[11].s64 + 4580;
	// 82867414: 4858C5F5  bl 0x82df3a08
	ctx.lr = 0x82867418;
	sub_82DF3A08(ctx, base);
	// 82867418: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286741C: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82867420: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82867424: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82867428: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286742C: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82867430: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82867434: 4E800421  bctrl
	ctx.lr = 0x82867438;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82867438: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286743C: 4858BFED  bl 0x82df3428
	ctx.lr = 0x82867440;
	sub_82DF3428(ctx, base);
	// 82867440: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82867444: 4858BFE5  bl 0x82df3428
	ctx.lr = 0x82867448;
	sub_82DF3428(ctx, base);
	// 82867448: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8286744C: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82867450: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82867454: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82867458: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 8286745C: 419A0024  beq cr6, 0x82867480
	if ctx.cr[6].eq {
	pc = 0x82867480; continue 'dispatch;
	}
	// 82867460: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82867464: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82867468: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286746C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82867470: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82867474: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82867478: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286747C: 4082FFE8  bne 0x82867464
	if !ctx.cr[0].eq {
	pc = 0x82867464; continue 'dispatch;
	}
	// 82867480: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82867484: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82867488: 386BC2E8  addi r3, r11, -0x3d18
	ctx.r[3].s64 = ctx.r[11].s64 + -15640;
	// 8286748C: 48004365  bl 0x8286b7f0
	ctx.lr = 0x82867490;
	sub_8286B7F0(ctx, base);
	// 82867490: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82867494: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82867498: 3BCBC370  addi r30, r11, -0x3c90
	ctx.r[30].s64 = ctx.r[11].s64 + -15504;
	// 8286749C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828674A0: 3BA0000A  li r29, 0xa
	ctx.r[29].s64 = 10;
	// 828674A4: 3B8B0F7C  addi r28, r11, 0xf7c
	ctx.r[28].s64 = ctx.r[11].s64 + 3964;
	// 828674A8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828674AC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828674B0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828674B4: 48941625  bl 0x831a8ad8
	ctx.lr = 0x828674B8;
	sub_831A8AD8(ctx, base);
	// 828674B8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828674BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828674C0: 4858C549  bl 0x82df3a08
	ctx.lr = 0x828674C4;
	sub_82DF3A08(ctx, base);
	// 828674C4: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828674C8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828674CC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828674D0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828674D4: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828674D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828674DC: 4E800421  bctrl
	ctx.lr = 0x828674E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828674E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828674E4: 4858BF45  bl 0x82df3428
	ctx.lr = 0x828674E8;
	sub_82DF3428(ctx, base);
	// 828674E8: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828674EC: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828674F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828674F4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828674F8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828674FC: 419A0024  beq cr6, 0x82867520
	if ctx.cr[6].eq {
	pc = 0x82867520; continue 'dispatch;
	}
	// 82867500: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82867504: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82867508: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286750C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82867510: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82867514: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82867518: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286751C: 4082FFE8  bne 0x82867504
	if !ctx.cr[0].eq {
	pc = 0x82867504; continue 'dispatch;
	}
	// 82867520: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82867524: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82867528: 48004881  bl 0x8286bda8
	ctx.lr = 0x8286752C;
	sub_8286BDA8(ctx, base);
	// 8286752C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82867530: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82867534: 419A0008  beq cr6, 0x8286753c
	if ctx.cr[6].eq {
	pc = 0x8286753C; continue 'dispatch;
	}
	// 82867538: 4BA59359  bl 0x822c0890
	ctx.lr = 0x8286753C;
	sub_822C0890(ctx, base);
	// 8286753C: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82867540: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82867544: 3BDE00C0  addi r30, r30, 0xc0
	ctx.r[30].s64 = ctx.r[30].s64 + 192;
	// 82867548: 4082FF60  bne 0x828674a8
	if !ctx.cr[0].eq {
	pc = 0x828674A8; continue 'dispatch;
	}
	// 8286754C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82867550: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82867554: 419A0008  beq cr6, 0x8286755c
	if ctx.cr[6].eq {
	pc = 0x8286755C; continue 'dispatch;
	}
	// 82867558: 4BA59339  bl 0x822c0890
	ctx.lr = 0x8286755C;
	sub_822C0890(ctx, base);
	// 8286755C: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82867560: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82867564: 419A0008  beq cr6, 0x8286756c
	if ctx.cr[6].eq {
	pc = 0x8286756C; continue 'dispatch;
	}
	// 82867568: 4BA59329  bl 0x822c0890
	ctx.lr = 0x8286756C;
	sub_822C0890(ctx, base);
	// 8286756C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82867570: 48940C44  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82867578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82867578 size=84
    let mut pc: u32 = 0x82867578;
    'dispatch: loop {
        match pc {
            0x82867578 => {
    //   block [0x82867578..0x828675CC)
	// 82867578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286757C: 48940BF1  bl 0x831a816c
	ctx.lr = 0x82867580;
	sub_831A8130(ctx, base);
	// 82867580: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82867584: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82867588: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8286758C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82867590: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 82867594: 409A0008  bne cr6, 0x8286759c
	if !ctx.cr[6].eq {
	pc = 0x8286759C; continue 'dispatch;
	}
	// 82867598: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8286759C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828675A0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828675A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828675A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828675AC: 4BFFF4A5  bl 0x82866a50
	ctx.lr = 0x828675B0;
	sub_82866A50(ctx, base);
	// 828675B0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828675B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828675B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828675BC: 4BA58A45  bl 0x822c0000
	ctx.lr = 0x828675C0;
	sub_822C0000(ctx, base);
	// 828675C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828675C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828675C8: 48940BF4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828675D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828675D0 size=84
    let mut pc: u32 = 0x828675D0;
    'dispatch: loop {
        match pc {
            0x828675D0 => {
    //   block [0x828675D0..0x82867624)
	// 828675D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828675D4: 48940B99  bl 0x831a816c
	ctx.lr = 0x828675D8;
	sub_831A8130(ctx, base);
	// 828675D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828675DC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828675E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828675E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828675E8: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 828675EC: 409A0008  bne cr6, 0x828675f4
	if !ctx.cr[6].eq {
	pc = 0x828675F4; continue 'dispatch;
	}
	// 828675F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828675F4: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828675F8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828675FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82867600: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82867604: 4BFFF515  bl 0x82866b18
	ctx.lr = 0x82867608;
	sub_82866B18(ctx, base);
	// 82867608: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8286760C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82867610: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82867614: 4BA589ED  bl 0x822c0000
	ctx.lr = 0x82867618;
	sub_822C0000(ctx, base);
	// 82867618: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286761C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82867620: 48940B9C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82867628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82867628 size=188
    let mut pc: u32 = 0x82867628;
    'dispatch: loop {
        match pc {
            0x82867628 => {
    //   block [0x82867628..0x828676E4)
	// 82867628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286762C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82867630: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82867634: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82867638: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286763C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82867640: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82867644: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82867648: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8286764C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82867650: 4BA592E9  bl 0x822c0938
	ctx.lr = 0x82867654;
	sub_822C0938(ctx, base);
	// 82867654: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82867658: 41820028  beq 0x82867680
	if ctx.cr[0].eq {
	pc = 0x82867680; continue 'dispatch;
	}
	// 8286765C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82867660: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82867664: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82867668: 392B0A90  addi r9, r11, 0xa90
	ctx.r[9].s64 = ctx.r[11].s64 + 2704;
	// 8286766C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82867670: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82867674: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82867678: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8286767C: 48000008  b 0x82867684
	pc = 0x82867684; continue 'dispatch;
	// 82867680: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82867684: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82867688: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286768C: 409A003C  bne cr6, 0x828676c8
	if !ctx.cr[6].eq {
	pc = 0x828676C8; continue 'dispatch;
	}
	// 82867690: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82867694: 419A0014  beq cr6, 0x828676a8
	if ctx.cr[6].eq {
	pc = 0x828676A8; continue 'dispatch;
	}
	// 82867698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286769C: 480BB17D  bl 0x82922818
	ctx.lr = 0x828676A0;
	sub_82922818(ctx, base);
	// 828676A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828676A4: 4BA58BC5  bl 0x822c0268
	ctx.lr = 0x828676A8;
	sub_822C0268(ctx, base);
	// 828676A8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828676AC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828676B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828676B4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828676B8: 816B5618  lwz r11, 0x5618(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22040 as u32) ) } as u64;
	// 828676BC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828676C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828676C4: 4BA5893D  bl 0x822c0000
	ctx.lr = 0x828676C8;
	sub_822C0000(ctx, base);
	// 828676C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828676CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828676D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828676D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828676D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828676DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828676E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828676E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828676E8 size=64
    let mut pc: u32 = 0x828676E8;
    'dispatch: loop {
        match pc {
            0x828676E8 => {
    //   block [0x828676E8..0x82867728)
	// 828676E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828676EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828676F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828676F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828676F8: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 828676FC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82867700: 419A0014  beq cr6, 0x82867714
	if ctx.cr[6].eq {
	pc = 0x82867714; continue 'dispatch;
	}
	// 82867704: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867708: 480BB111  bl 0x82922818
	ctx.lr = 0x8286770C;
	sub_82922818(ctx, base);
	// 8286770C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867710: 4BA58B59  bl 0x822c0268
	ctx.lr = 0x82867714;
	sub_822C0268(ctx, base);
	// 82867714: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82867718: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286771C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82867720: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82867724: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82867728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82867728 size=72
    let mut pc: u32 = 0x82867728;
    'dispatch: loop {
        match pc {
            0x82867728 => {
    //   block [0x82867728..0x82867770)
	// 82867728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286772C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82867730: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82867734: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82867738: 419A001C  beq cr6, 0x82867754
	if ctx.cr[6].eq {
	pc = 0x82867754; continue 'dispatch;
	}
	// 8286773C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82867740: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82867744: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82867748: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8286774C: 4BFFEED5  bl 0x82866620
	ctx.lr = 0x82867750;
	sub_82866620(ctx, base);
	// 82867750: 48000010  b 0x82867760
	pc = 0x82867760; continue 'dispatch;
	// 82867754: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82867758: 396B5A40  addi r11, r11, 0x5a40
	ctx.r[11].s64 = ctx.r[11].s64 + 23104;
	// 8286775C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82867760: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82867764: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82867768: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286776C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82867770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82867770 size=72
    let mut pc: u32 = 0x82867770;
    'dispatch: loop {
        match pc {
            0x82867770 => {
    //   block [0x82867770..0x828677B8)
	// 82867770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82867774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82867778: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286777C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82867780: 419A001C  beq cr6, 0x8286779c
	if ctx.cr[6].eq {
	pc = 0x8286779C; continue 'dispatch;
	}
	// 82867784: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82867788: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8286778C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82867790: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82867794: 4BFFEF1D  bl 0x828666b0
	ctx.lr = 0x82867798;
	sub_828666B0(ctx, base);
	// 82867798: 48000010  b 0x828677a8
	pc = 0x828677A8; continue 'dispatch;
	// 8286779C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828677A0: 396B5B08  addi r11, r11, 0x5b08
	ctx.r[11].s64 = ctx.r[11].s64 + 23304;
	// 828677A4: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828677A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828677AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828677B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828677B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828677B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828677B8 size=612
    let mut pc: u32 = 0x828677B8;
    'dispatch: loop {
        match pc {
            0x828677B8 => {
    //   block [0x828677B8..0x82867A1C)
	// 828677B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828677BC: 489409AD  bl 0x831a8168
	ctx.lr = 0x828677C0;
	sub_831A8130(ctx, base);
	// 828677C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828677C4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828677C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828677CC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828677D0: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828677D4: 41820038  beq 0x8286780c
	if ctx.cr[0].eq {
	pc = 0x8286780C; continue 'dispatch;
	}
	// 828677D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828677DC: 489421AD  bl 0x831a9988
	ctx.lr = 0x828677E0;
	sub_831A9988(ctx, base);
	// 828677E0: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 828677E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828677E8: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 828677EC: 4894090D  bl 0x831a80f8
	ctx.lr = 0x828677F0;
	sub_831A80F8(ctx, base);
	// 828677F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828677F4: 41820018  beq 0x8286780c
	if ctx.cr[0].eq {
	pc = 0x8286780C; continue 'dispatch;
	}
	// 828677F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828677FC: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 82867800: 4BDF9ED9  bl 0x826616d8
	ctx.lr = 0x82867804;
	sub_826616D8(ctx, base);
	// 82867804: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82867808: 4800020C  b 0x82867a14
	pc = 0x82867A14; continue 'dispatch;
	// 8286780C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82867810: 419A01F4  beq cr6, 0x82867a04
	if ctx.cr[6].eq {
	pc = 0x82867A04; continue 'dispatch;
	}
	// 82867814: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867818: 48942171  bl 0x831a9988
	ctx.lr = 0x8286781C;
	sub_831A9988(ctx, base);
	// 8286781C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82867820: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82867824: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 82867828: 489408D1  bl 0x831a80f8
	ctx.lr = 0x8286782C;
	sub_831A80F8(ctx, base);
	// 8286782C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82867830: 41820014  beq 0x82867844
	if ctx.cr[0].eq {
	pc = 0x82867844; continue 'dispatch;
	}
	// 82867834: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82867838: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8286783C: 480726A5  bl 0x828d9ee0
	ctx.lr = 0x82867840;
	sub_828D9EE0(ctx, base);
	// 82867840: 4BFFFFC4  b 0x82867804
	pc = 0x82867804; continue 'dispatch;
	// 82867844: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82867848: 419A01BC  beq cr6, 0x82867a04
	if ctx.cr[6].eq {
	pc = 0x82867A04; continue 'dispatch;
	}
	// 8286784C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867850: 48942139  bl 0x831a9988
	ctx.lr = 0x82867854;
	sub_831A9988(ctx, base);
	// 82867854: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82867858: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286785C: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 82867860: 48940899  bl 0x831a80f8
	ctx.lr = 0x82867864;
	sub_831A80F8(ctx, base);
	// 82867864: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82867868: 41820014  beq 0x8286787c
	if ctx.cr[0].eq {
	pc = 0x8286787C; continue 'dispatch;
	}
	// 8286786C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82867870: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 82867874: 4BDF9E95  bl 0x82661708
	ctx.lr = 0x82867878;
	sub_82661708(ctx, base);
	// 82867878: 4BFFFF8C  b 0x82867804
	pc = 0x82867804; continue 'dispatch;
	// 8286787C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82867880: 419A0184  beq cr6, 0x82867a04
	if ctx.cr[6].eq {
	pc = 0x82867A04; continue 'dispatch;
	}
	// 82867884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867888: 48942101  bl 0x831a9988
	ctx.lr = 0x8286788C;
	sub_831A9988(ctx, base);
	// 8286788C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82867890: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82867894: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 82867898: 48940861  bl 0x831a80f8
	ctx.lr = 0x8286789C;
	sub_831A80F8(ctx, base);
	// 8286789C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828678A0: 41820014  beq 0x828678b4
	if ctx.cr[0].eq {
	pc = 0x828678B4; continue 'dispatch;
	}
	// 828678A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828678A8: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828678AC: 4806736D  bl 0x828cec18
	ctx.lr = 0x828678B0;
	sub_828CEC18(ctx, base);
	// 828678B0: 4BFFFF54  b 0x82867804
	pc = 0x82867804; continue 'dispatch;
	// 828678B4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828678B8: 419A014C  beq cr6, 0x82867a04
	if ctx.cr[6].eq {
	pc = 0x82867A04; continue 'dispatch;
	}
	// 828678BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828678C0: 489420C9  bl 0x831a9988
	ctx.lr = 0x828678C4;
	sub_831A9988(ctx, base);
	// 828678C4: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828678C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828678CC: 386B5CEC  addi r3, r11, 0x5cec
	ctx.r[3].s64 = ctx.r[11].s64 + 23788;
	// 828678D0: 48940829  bl 0x831a80f8
	ctx.lr = 0x828678D4;
	sub_831A80F8(ctx, base);
	// 828678D4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828678D8: 41820014  beq 0x828678ec
	if ctx.cr[0].eq {
	pc = 0x828678EC; continue 'dispatch;
	}
	// 828678DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828678E0: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828678E4: 4BFFEE55  bl 0x82866738
	ctx.lr = 0x828678E8;
	sub_82866738(ctx, base);
	// 828678E8: 4BFFFF1C  b 0x82867804
	pc = 0x82867804; continue 'dispatch;
	// 828678EC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828678F0: 419A0114  beq cr6, 0x82867a04
	if ctx.cr[6].eq {
	pc = 0x82867A04; continue 'dispatch;
	}
	// 828678F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828678F8: 48942091  bl 0x831a9988
	ctx.lr = 0x828678FC;
	sub_831A9988(ctx, base);
	// 828678FC: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82867900: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82867904: 386B5CC4  addi r3, r11, 0x5cc4
	ctx.r[3].s64 = ctx.r[11].s64 + 23748;
	// 82867908: 489407F1  bl 0x831a80f8
	ctx.lr = 0x8286790C;
	sub_831A80F8(ctx, base);
	// 8286790C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82867910: 41820014  beq 0x82867924
	if ctx.cr[0].eq {
	pc = 0x82867924; continue 'dispatch;
	}
	// 82867914: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82867918: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 8286791C: 48067105  bl 0x828cea20
	ctx.lr = 0x82867920;
	sub_828CEA20(ctx, base);
	// 82867920: 4BFFFEE4  b 0x82867804
	pc = 0x82867804; continue 'dispatch;
	// 82867924: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82867928: 419A00DC  beq cr6, 0x82867a04
	if ctx.cr[6].eq {
	pc = 0x82867A04; continue 'dispatch;
	}
	// 8286792C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867930: 48942059  bl 0x831a9988
	ctx.lr = 0x82867934;
	sub_831A9988(ctx, base);
	// 82867934: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82867938: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286793C: 386B3A18  addi r3, r11, 0x3a18
	ctx.r[3].s64 = ctx.r[11].s64 + 14872;
	// 82867940: 489407B9  bl 0x831a80f8
	ctx.lr = 0x82867944;
	sub_831A80F8(ctx, base);
	// 82867944: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82867948: 41820014  beq 0x8286795c
	if ctx.cr[0].eq {
	pc = 0x8286795C; continue 'dispatch;
	}
	// 8286794C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82867950: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 82867954: 4806737D  bl 0x828cecd0
	ctx.lr = 0x82867958;
	sub_828CECD0(ctx, base);
	// 82867958: 4BFFFEAC  b 0x82867804
	pc = 0x82867804; continue 'dispatch;
	// 8286795C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82867960: 419A00A4  beq cr6, 0x82867a04
	if ctx.cr[6].eq {
	pc = 0x82867A04; continue 'dispatch;
	}
	// 82867964: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867968: 48942021  bl 0x831a9988
	ctx.lr = 0x8286796C;
	sub_831A9988(ctx, base);
	// 8286796C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82867970: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82867974: 386B3A44  addi r3, r11, 0x3a44
	ctx.r[3].s64 = ctx.r[11].s64 + 14916;
	// 82867978: 48940781  bl 0x831a80f8
	ctx.lr = 0x8286797C;
	sub_831A80F8(ctx, base);
	// 8286797C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82867980: 41820014  beq 0x82867994
	if ctx.cr[0].eq {
	pc = 0x82867994; continue 'dispatch;
	}
	// 82867984: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82867988: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 8286798C: 4808B54D  bl 0x828f2ed8
	ctx.lr = 0x82867990;
	sub_828F2ED8(ctx, base);
	// 82867990: 4BFFFE74  b 0x82867804
	pc = 0x82867804; continue 'dispatch;
	// 82867994: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82867998: 419A006C  beq cr6, 0x82867a04
	if ctx.cr[6].eq {
	pc = 0x82867A04; continue 'dispatch;
	}
	// 8286799C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828679A0: 48941FE9  bl 0x831a9988
	ctx.lr = 0x828679A4;
	sub_831A9988(ctx, base);
	// 828679A4: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 828679A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828679AC: 386B1FA4  addi r3, r11, 0x1fa4
	ctx.r[3].s64 = ctx.r[11].s64 + 8100;
	// 828679B0: 48940749  bl 0x831a80f8
	ctx.lr = 0x828679B4;
	sub_831A80F8(ctx, base);
	// 828679B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828679B8: 41820014  beq 0x828679cc
	if ctx.cr[0].eq {
	pc = 0x828679CC; continue 'dispatch;
	}
	// 828679BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828679C0: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828679C4: 480566BD  bl 0x828be080
	ctx.lr = 0x828679C8;
	sub_828BE080(ctx, base);
	// 828679C8: 4BFFFE3C  b 0x82867804
	pc = 0x82867804; continue 'dispatch;
	// 828679CC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828679D0: 419A0034  beq cr6, 0x82867a04
	if ctx.cr[6].eq {
	pc = 0x82867A04; continue 'dispatch;
	}
	// 828679D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828679D8: 48941FB1  bl 0x831a9988
	ctx.lr = 0x828679DC;
	sub_831A9988(ctx, base);
	// 828679DC: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 828679E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828679E4: 386B2380  addi r3, r11, 0x2380
	ctx.r[3].s64 = ctx.r[11].s64 + 9088;
	// 828679E8: 48940711  bl 0x831a80f8
	ctx.lr = 0x828679EC;
	sub_831A80F8(ctx, base);
	// 828679EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828679F0: 41820014  beq 0x82867a04
	if ctx.cr[0].eq {
	pc = 0x82867A04; continue 'dispatch;
	}
	// 828679F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828679F8: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828679FC: 48067355  bl 0x828ced50
	ctx.lr = 0x82867A00;
	sub_828CED50(ctx, base);
	// 82867A00: 4BFFFE04  b 0x82867804
	pc = 0x82867804; continue 'dispatch;
	// 82867A04: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82867A08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82867A0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82867A10: 480A8081  bl 0x8290fa90
	ctx.lr = 0x82867A14;
	sub_8290FA90(ctx, base);
	// 82867A14: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82867A18: 489407A0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82867A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82867A20 size=232
    let mut pc: u32 = 0x82867A20;
    'dispatch: loop {
        match pc {
            0x82867A20 => {
    //   block [0x82867A20..0x82867B08)
	// 82867A20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82867A24: 48940745  bl 0x831a8168
	ctx.lr = 0x82867A28;
	sub_831A8130(ctx, base);
	// 82867A28: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82867A2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82867A30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82867A34: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82867A38: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 82867A3C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82867A40: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82867A44: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 82867A48: 480A90D1  bl 0x82910b18
	ctx.lr = 0x82867A4C;
	sub_82910B18(ctx, base);
	// 82867A4C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82867A50: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 82867A54: 396B0CCC  addi r11, r11, 0xccc
	ctx.r[11].s64 = ctx.r[11].s64 + 3276;
	// 82867A58: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82867A5C: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82867A60: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82867A64: 39680CB0  addi r11, r8, 0xcb0
	ctx.r[11].s64 = ctx.r[8].s64 + 3248;
	// 82867A68: 394A0B0C  addi r10, r10, 0xb0c
	ctx.r[10].s64 = ctx.r[10].s64 + 2828;
	// 82867A6C: 39290AF4  addi r9, r9, 0xaf4
	ctx.r[9].s64 = ctx.r[9].s64 + 2804;
	// 82867A70: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 82867A74: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82867A78: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82867A7C: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 82867A80: 387F0398  addi r3, r31, 0x398
	ctx.r[3].s64 = ctx.r[31].s64 + 920;
	// 82867A84: 93DF0370  stw r30, 0x370(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(880 as u32), ctx.r[30].u32 ) };
	// 82867A88: 57CB003E  slwi r11, r30, 0
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82867A8C: 93DF0374  stw r30, 0x374(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(884 as u32), ctx.r[30].u32 ) };
	// 82867A90: 93DF0378  stw r30, 0x378(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(888 as u32), ctx.r[30].u32 ) };
	// 82867A94: 556B07BE  clrlwi r11, r11, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82867A98: 93DF037C  stw r30, 0x37c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), ctx.r[30].u32 ) };
	// 82867A9C: 93DF0380  stw r30, 0x380(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(896 as u32), ctx.r[30].u32 ) };
	// 82867AA0: 93DF0384  stw r30, 0x384(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(900 as u32), ctx.r[30].u32 ) };
	// 82867AA4: 93DF0388  stw r30, 0x388(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(904 as u32), ctx.r[30].u32 ) };
	// 82867AA8: 93DF038C  stw r30, 0x38c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(908 as u32), ctx.r[30].u32 ) };
	// 82867AAC: 93DF038C  stw r30, 0x38c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(908 as u32), ctx.r[30].u32 ) };
	// 82867AB0: 917F038C  stw r11, 0x38c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(908 as u32), ctx.r[11].u32 ) };
	// 82867AB4: 939F0390  stw r28, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[28].u32 ) };
	// 82867AB8: 48003D19  bl 0x8286b7d0
	ctx.lr = 0x82867ABC;
	sub_8286B7D0(ctx, base);
	// 82867ABC: 2B1D000A  cmplwi cr6, r29, 0xa
	ctx.cr[6].compare_u32(ctx.r[29].u32, 10 as u32, &mut ctx.xer);
	// 82867AC0: 40990008  ble cr6, 0x82867ac8
	if !ctx.cr[6].gt {
	pc = 0x82867AC8; continue 'dispatch;
	}
	// 82867AC4: 3BA0000A  li r29, 0xa
	ctx.r[29].s64 = 10;
	// 82867AC8: 93BF0394  stw r29, 0x394(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), ctx.r[29].u32 ) };
	// 82867ACC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82867AD0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82867AD4: 388B11F0  addi r4, r11, 0x11f0
	ctx.r[4].s64 = ctx.r[11].s64 + 4592;
	// 82867AD8: 38A0008A  li r5, 0x8a
	ctx.r[5].s64 = 138;
	// 82867ADC: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82867AE0: 4BA588F9  bl 0x822c03d8
	ctx.lr = 0x82867AE4;
	sub_822C03D8(ctx, base);
	// 82867AE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82867AE8: 4182000C  beq 0x82867af4
	if ctx.cr[0].eq {
	pc = 0x82867AF4; continue 'dispatch;
	}
	// 82867AEC: 48003A5D  bl 0x8286b548
	ctx.lr = 0x82867AF0;
	sub_8286B548(ctx, base);
	// 82867AF0: 48000008  b 0x82867af8
	pc = 0x82867AF8; continue 'dispatch;
	// 82867AF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82867AF8: 907F0388  stw r3, 0x388(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(904 as u32), ctx.r[3].u32 ) };
	// 82867AFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867B00: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82867B04: 489406B4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82867B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82867B08 size=76
    let mut pc: u32 = 0x82867B08;
    'dispatch: loop {
        match pc {
            0x82867B08 => {
    //   block [0x82867B08..0x82867B54)
	// 82867B08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82867B0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82867B10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82867B14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82867B18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82867B1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82867B20: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82867B24: 4BFFF5FD  bl 0x82867120
	ctx.lr = 0x82867B28;
	sub_82867120(ctx, base);
	// 82867B28: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82867B2C: 4182000C  beq 0x82867b38
	if ctx.cr[0].eq {
	pc = 0x82867B38; continue 'dispatch;
	}
	// 82867B30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867B34: 4858A8A5  bl 0x82df23d8
	ctx.lr = 0x82867B38;
	sub_82DF23D8(ctx, base);
	// 82867B38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867B3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82867B40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82867B44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82867B48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82867B4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82867B50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82867B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82867B58 size=436
    let mut pc: u32 = 0x82867B58;
    'dispatch: loop {
        match pc {
            0x82867B58 => {
    //   block [0x82867B58..0x82867D0C)
	// 82867B58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82867B5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82867B60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82867B64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82867B68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82867B6C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82867B70: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82867B74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82867B78: 388B1258  addi r4, r11, 0x1258
	ctx.r[4].s64 = ctx.r[11].s64 + 4696;
	// 82867B7C: 4858BE8D  bl 0x82df3a08
	ctx.lr = 0x82867B80;
	sub_82DF3A08(ctx, base);
	// 82867B80: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82867B84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82867B88: 388BD3AC  addi r4, r11, -0x2c54
	ctx.r[4].s64 = ctx.r[11].s64 + -11348;
	// 82867B8C: 4858BE7D  bl 0x82df3a08
	ctx.lr = 0x82867B90;
	sub_82DF3A08(ctx, base);
	// 82867B90: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82867B94: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82867B98: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82867B9C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82867BA0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82867BA4: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82867BA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82867BAC: 4E800421  bctrl
	ctx.lr = 0x82867BB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82867BB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82867BB4: 4858B875  bl 0x82df3428
	ctx.lr = 0x82867BB8;
	sub_82DF3428(ctx, base);
	// 82867BB8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82867BBC: 4858B86D  bl 0x82df3428
	ctx.lr = 0x82867BC0;
	sub_82DF3428(ctx, base);
	// 82867BC0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82867BC4: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82867BC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82867BCC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82867BD0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82867BD4: 419A0024  beq cr6, 0x82867bf8
	if ctx.cr[6].eq {
	pc = 0x82867BF8; continue 'dispatch;
	}
	// 82867BD8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82867BDC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82867BE0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82867BE4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82867BE8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82867BEC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82867BF0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82867BF4: 4082FFE8  bne 0x82867bdc
	if !ctx.cr[0].eq {
	pc = 0x82867BDC; continue 'dispatch;
	}
	// 82867BF8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82867BFC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82867C00: 386BBA50  addi r3, r11, -0x45b0
	ctx.r[3].s64 = ctx.r[11].s64 + -17840;
	// 82867C04: 48004655  bl 0x8286c258
	ctx.lr = 0x82867C08;
	sub_8286C258(ctx, base);
	// 82867C08: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82867C0C: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82867C10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82867C14: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82867C18: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82867C1C: 419A0024  beq cr6, 0x82867c40
	if ctx.cr[6].eq {
	pc = 0x82867C40; continue 'dispatch;
	}
	// 82867C20: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82867C24: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82867C28: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82867C2C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82867C30: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82867C34: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82867C38: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82867C3C: 4082FFE8  bne 0x82867c24
	if !ctx.cr[0].eq {
	pc = 0x82867C24; continue 'dispatch;
	}
	// 82867C40: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82867C44: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82867C48: 386B5D14  addi r3, r11, 0x5d14
	ctx.r[3].s64 = ctx.r[11].s64 + 23828;
	// 82867C4C: 480AD475  bl 0x829150c0
	ctx.lr = 0x82867C50;
	sub_829150C0(ctx, base);
	// 82867C50: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82867C54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82867C58: 419A0008  beq cr6, 0x82867c60
	if ctx.cr[6].eq {
	pc = 0x82867C60; continue 'dispatch;
	}
	// 82867C5C: 4BA58C35  bl 0x822c0890
	ctx.lr = 0x82867C60;
	sub_822C0890(ctx, base);
	// 82867C60: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82867C64: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 82867C68: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82867C6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82867C70: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82867C74: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82867C78: 419A0024  beq cr6, 0x82867c9c
	if ctx.cr[6].eq {
	pc = 0x82867C9C; continue 'dispatch;
	}
	// 82867C7C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82867C80: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82867C84: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82867C88: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82867C8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82867C90: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82867C94: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82867C98: 4082FFE8  bne 0x82867c80
	if !ctx.cr[0].eq {
	pc = 0x82867C80; continue 'dispatch;
	}
	// 82867C9C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82867CA0: 4BFFF5A1  bl 0x82867240
	ctx.lr = 0x82867CA4;
	sub_82867240(ctx, base);
	// 82867CA4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82867CA8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82867CAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82867CB0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82867CB4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82867CB8: 419A0024  beq cr6, 0x82867cdc
	if ctx.cr[6].eq {
	pc = 0x82867CDC; continue 'dispatch;
	}
	// 82867CBC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82867CC0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82867CC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82867CC8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82867CCC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82867CD0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82867CD4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82867CD8: 4082FFE8  bne 0x82867cc0
	if !ctx.cr[0].eq {
	pc = 0x82867CC0; continue 'dispatch;
	}
	// 82867CDC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82867CE0: 4BFFF709  bl 0x828673e8
	ctx.lr = 0x82867CE4;
	sub_828673E8(ctx, base);
	// 82867CE4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82867CE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82867CEC: 419A0008  beq cr6, 0x82867cf4
	if ctx.cr[6].eq {
	pc = 0x82867CF4; continue 'dispatch;
	}
	// 82867CF0: 4BA58BA1  bl 0x822c0890
	ctx.lr = 0x82867CF4;
	sub_822C0890(ctx, base);
	// 82867CF4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82867CF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82867CFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82867D00: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82867D04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82867D08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82867D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82867D10 size=276
    let mut pc: u32 = 0x82867D10;
    'dispatch: loop {
        match pc {
            0x82867D10 => {
    //   block [0x82867D10..0x82867E24)
	// 82867D10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82867D14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82867D18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82867D1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82867D20: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82867D24: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82867D28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82867D2C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82867D30: 480A94F1  bl 0x82911220
	ctx.lr = 0x82867D34;
	sub_82911220(ctx, base);
	// 82867D34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867D38: 4BF84429  bl 0x827ec160
	ctx.lr = 0x82867D3C;
	sub_827EC160(ctx, base);
	// 82867D3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82867D40: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82867D44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82867D48: 4E800421  bctrl
	ctx.lr = 0x82867D4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82867D4C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82867D50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867D54: 4825A23D  bl 0x82ac1f90
	ctx.lr = 0x82867D58;
	sub_82AC1F90(ctx, base);
	// 82867D58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867D5C: 4BF84405  bl 0x827ec160
	ctx.lr = 0x82867D60;
	sub_827EC160(ctx, base);
	// 82867D60: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82867D64: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82867D68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82867D6C: 4E800421  bctrl
	ctx.lr = 0x82867D70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82867D70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82867D74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867D78: 48243761  bl 0x82aab4d8
	ctx.lr = 0x82867D7C;
	sub_82AAB4D8(ctx, base);
	// 82867D7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82867D80: 807F01CC  lwz r3, 0x1cc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 82867D84: 4BF8240D  bl 0x827ea190
	ctx.lr = 0x82867D88;
	sub_827EA190(ctx, base);
	// 82867D88: 807F0360  lwz r3, 0x360(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(864 as u32) ) } as u64;
	// 82867D8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82867D90: 419A0018  beq cr6, 0x82867da8
	if ctx.cr[6].eq {
	pc = 0x82867DA8; continue 'dispatch;
	}
	// 82867D94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82867D98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82867D9C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82867DA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82867DA4: 4E800421  bctrl
	ctx.lr = 0x82867DA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82867DA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82867DAC: 807F0368  lwz r3, 0x368(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(872 as u32) ) } as u64;
	// 82867DB0: 480BABC9  bl 0x82922978
	ctx.lr = 0x82867DB4;
	sub_82922978(ctx, base);
	// 82867DB4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82867DB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867DBC: 816B00C4  lwz r11, 0xc4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) } as u64;
	// 82867DC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82867DC4: 4E800421  bctrl
	ctx.lr = 0x82867DC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82867DC8: 817F0380  lwz r11, 0x380(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(896 as u32) ) } as u64;
	// 82867DCC: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82867DD0: 409A0038  bne cr6, 0x82867e08
	if !ctx.cr[6].eq {
	pc = 0x82867E08; continue 'dispatch;
	}
	// 82867DD4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82867DD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867DDC: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 82867DE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82867DE4: 4E800421  bctrl
	ctx.lr = 0x82867DE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82867DE8: C3E30014  lfs f31, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82867DEC: 387FFFF0  addi r3, r31, -0x10
	ctx.r[3].s64 = ctx.r[31].s64 + -16;
	// 82867DF0: 4808B5A1  bl 0x828f3390
	ctx.lr = 0x82867DF4;
	sub_828F3390(ctx, base);
	// 82867DF4: EC1F07F2  fmuls f0, f31, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[31].f64) as f32) as f64);
	// 82867DF8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82867DFC: 4099000C  ble cr6, 0x82867e08
	if !ctx.cr[6].gt {
	pc = 0x82867E08; continue 'dispatch;
	}
	// 82867E00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867E04: 4BCA87CD  bl 0x825105d0
	ctx.lr = 0x82867E08;
	sub_825105D0(ctx, base);
	// 82867E08: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82867E0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82867E10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82867E14: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82867E18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82867E1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82867E20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82867E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82867E28 size=276
    let mut pc: u32 = 0x82867E28;
    'dispatch: loop {
        match pc {
            0x82867E28 => {
    //   block [0x82867E28..0x82867F3C)
	// 82867E28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82867E2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82867E30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82867E34: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82867E38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82867E3C: 480A0EED  bl 0x82908d28
	ctx.lr = 0x82867E40;
	sub_82908D28(ctx, base);
	// 82867E40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82867E44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867E48: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 82867E4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82867E50: 4E800421  bctrl
	ctx.lr = 0x82867E54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82867E54: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82867E58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867E5C: 480A66F5  bl 0x8290e550
	ctx.lr = 0x82867E60;
	sub_8290E550(ctx, base);
	// 82867E60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867E64: 480A852D  bl 0x82910390
	ctx.lr = 0x82867E68;
	sub_82910390(ctx, base);
	// 82867E68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867E6C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82867E70: 4BF84401  bl 0x827ec270
	ctx.lr = 0x82867E74;
	sub_827EC270(ctx, base);
	// 82867E74: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82867E78: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82867E7C: 388B1280  addi r4, r11, 0x1280
	ctx.r[4].s64 = ctx.r[11].s64 + 4736;
	// 82867E80: 4858BB89  bl 0x82df3a08
	ctx.lr = 0x82867E84;
	sub_82DF3A08(ctx, base);
	// 82867E84: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82867E88: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82867E8C: 388B1268  addi r4, r11, 0x1268
	ctx.r[4].s64 = ctx.r[11].s64 + 4712;
	// 82867E90: 4858BB79  bl 0x82df3a08
	ctx.lr = 0x82867E94;
	sub_82DF3A08(ctx, base);
	// 82867E94: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82867E98: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82867E9C: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 82867EA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867EA4: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 82867EA8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82867EAC: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82867EB0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82867EB4: C02A08A8  lfs f1, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82867EB8: D0210084  stfs f1, 0x84(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82867EBC: D0210088  stfs f1, 0x88(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82867EC0: D021008C  stfs f1, 0x8c(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82867EC4: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82867EC8: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82867ECC: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82867ED0: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82867ED4: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82867ED8: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82867EDC: 4BF8472D  bl 0x827ec608
	ctx.lr = 0x82867EE0;
	sub_827EC608(ctx, base);
	// 82867EE0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82867EE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82867EE8: 38AB9704  addi r5, r11, -0x68fc
	ctx.r[5].s64 = ctx.r[11].s64 + -26876;
	// 82867EEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82867EF0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82867EF4: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82867EF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82867EFC: 4E800421  bctrl
	ctx.lr = 0x82867F00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82867F00: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82867F04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82867F08: 419A0008  beq cr6, 0x82867f10
	if ctx.cr[6].eq {
	pc = 0x82867F10; continue 'dispatch;
	}
	// 82867F0C: 4BA58985  bl 0x822c0890
	ctx.lr = 0x82867F10;
	sub_822C0890(ctx, base);
	// 82867F10: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82867F14: 4858B515  bl 0x82df3428
	ctx.lr = 0x82867F18;
	sub_82DF3428(ctx, base);
	// 82867F18: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82867F1C: 4858B50D  bl 0x82df3428
	ctx.lr = 0x82867F20;
	sub_82DF3428(ctx, base);
	// 82867F20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867F24: 4BCA86AD  bl 0x825105d0
	ctx.lr = 0x82867F28;
	sub_825105D0(ctx, base);
	// 82867F28: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82867F2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82867F30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82867F34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82867F38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82867F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82867F40 size=112
    let mut pc: u32 = 0x82867F40;
    'dispatch: loop {
        match pc {
            0x82867F40 => {
    //   block [0x82867F40..0x82867FB0)
	// 82867F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82867F44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82867F48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82867F4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82867F50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82867F54: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82867F58: 419A0028  beq cr6, 0x82867f80
	if ctx.cr[6].eq {
	pc = 0x82867F80; continue 'dispatch;
	}
	// 82867F5C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82867F60: 419A0014  beq cr6, 0x82867f74
	if ctx.cr[6].eq {
	pc = 0x82867F74; continue 'dispatch;
	}
	// 82867F64: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82867F68: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82867F6C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82867F70: 4800002C  b 0x82867f9c
	pc = 0x82867F9C; continue 'dispatch;
	// 82867F74: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82867F78: 38AA1298  addi r5, r10, 0x1298
	ctx.r[5].s64 = ctx.r[10].s64 + 4760;
	// 82867F7C: 4800000C  b 0x82867f88
	pc = 0x82867F88; continue 'dispatch;
	// 82867F80: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82867F84: 38AA1288  addi r5, r10, 0x1288
	ctx.r[5].s64 = ctx.r[10].s64 + 4744;
	// 82867F88: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82867F8C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82867F90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82867F94: 4E800421  bctrl
	ctx.lr = 0x82867F98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82867F98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82867F9C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82867FA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82867FA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82867FA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82867FAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82867FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82867FB0 size=108
    let mut pc: u32 = 0x82867FB0;
    'dispatch: loop {
        match pc {
            0x82867FB0 => {
    //   block [0x82867FB0..0x8286801C)
	// 82867FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82867FB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82867FB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82867FBC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82867FC0: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 82867FC4: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 82867FC8: 38C0000A  li r6, 0xa
	ctx.r[6].s64 = 10;
	// 82867FCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82867FD0: 4BFFFA51  bl 0x82867a20
	ctx.lr = 0x82867FD4;
	sub_82867A20(ctx, base);
	// 82867FD4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82867FD8: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82867FDC: 396B0F14  addi r11, r11, 0xf14
	ctx.r[11].s64 = ctx.r[11].s64 + 3860;
	// 82867FE0: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82867FE4: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 82867FE8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82867FEC: 394A0D6C  addi r10, r10, 0xd6c
	ctx.r[10].s64 = ctx.r[10].s64 + 3436;
	// 82867FF0: 39290D54  addi r9, r9, 0xd54
	ctx.r[9].s64 = ctx.r[9].s64 + 3412;
	// 82867FF4: 39680D38  addi r11, r8, 0xd38
	ctx.r[11].s64 = ctx.r[8].s64 + 3384;
	// 82867FF8: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82867FFC: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 82868000: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82868004: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 82868008: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8286800C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82868010: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82868014: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82868018: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82868020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82868020 size=124
    let mut pc: u32 = 0x82868020;
    'dispatch: loop {
        match pc {
            0x82868020 => {
    //   block [0x82868020..0x8286809C)
	// 82868020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82868024: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82868028: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286802C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82868030: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82868034: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82868038: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8286803C: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 82868040: 396B0F14  addi r11, r11, 0xf14
	ctx.r[11].s64 = ctx.r[11].s64 + 3860;
	// 82868044: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82868048: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 8286804C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82868050: 394A0D6C  addi r10, r10, 0xd6c
	ctx.r[10].s64 = ctx.r[10].s64 + 3436;
	// 82868054: 39290D54  addi r9, r9, 0xd54
	ctx.r[9].s64 = ctx.r[9].s64 + 3412;
	// 82868058: 39680D38  addi r11, r8, 0xd38
	ctx.r[11].s64 = ctx.r[8].s64 + 3384;
	// 8286805C: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82868060: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 82868064: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82868068: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 8286806C: 4BFFF0B5  bl 0x82867120
	ctx.lr = 0x82868070;
	sub_82867120(ctx, base);
	// 82868070: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82868074: 4182000C  beq 0x82868080
	if ctx.cr[0].eq {
	pc = 0x82868080; continue 'dispatch;
	}
	// 82868078: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286807C: 4858A35D  bl 0x82df23d8
	ctx.lr = 0x82868080;
	sub_82DF23D8(ctx, base);
	// 82868080: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82868084: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82868088: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286808C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82868090: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82868094: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82868098: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828680A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828680A0 size=116
    let mut pc: u32 = 0x828680A0;
    'dispatch: loop {
        match pc {
            0x828680A0 => {
    //   block [0x828680A0..0x82868114)
	// 828680A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828680A4: 489400C1  bl 0x831a8164
	ctx.lr = 0x828680A8;
	sub_831A8130(ctx, base);
	// 828680A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828680AC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828680B0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828680B4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828680B8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828680BC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828680C0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828680C4: 388B11F0  addi r4, r11, 0x11f0
	ctx.r[4].s64 = ctx.r[11].s64 + 4592;
	// 828680C8: 38A0042D  li r5, 0x42d
	ctx.r[5].s64 = 1069;
	// 828680CC: 386003A0  li r3, 0x3a0
	ctx.r[3].s64 = 928;
	// 828680D0: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 828680D4: 4858A315  bl 0x82df23e8
	ctx.lr = 0x828680D8;
	sub_82DF23E8(ctx, base);
	// 828680D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828680DC: 41820020  beq 0x828680fc
	if ctx.cr[0].eq {
	pc = 0x828680FC; continue 'dispatch;
	}
	// 828680E0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828680E4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828680E8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828680EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828680F0: 4BFFFEC1  bl 0x82867fb0
	ctx.lr = 0x828680F4;
	sub_82867FB0(ctx, base);
	// 828680F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828680F8: 48000008  b 0x82868100
	pc = 0x82868100; continue 'dispatch;
	// 828680FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82868100: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82868104: 4BFFF475  bl 0x82867578
	ctx.lr = 0x82868108;
	sub_82867578(ctx, base);
	// 82868108: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286810C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82868110: 489400A4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82868118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82868118 size=108
    let mut pc: u32 = 0x82868118;
    'dispatch: loop {
        match pc {
            0x82868118 => {
    //   block [0x82868118..0x82868184)
	// 82868118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286811C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82868120: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82868124: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82868128: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 8286812C: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 82868130: 38C0000B  li r6, 0xb
	ctx.r[6].s64 = 11;
	// 82868134: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82868138: 4BFFF8E9  bl 0x82867a20
	ctx.lr = 0x8286813C;
	sub_82867A20(ctx, base);
	// 8286813C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82868140: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82868144: 396B117C  addi r11, r11, 0x117c
	ctx.r[11].s64 = ctx.r[11].s64 + 4476;
	// 82868148: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 8286814C: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 82868150: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82868154: 394A0FD4  addi r10, r10, 0xfd4
	ctx.r[10].s64 = ctx.r[10].s64 + 4052;
	// 82868158: 39290FC0  addi r9, r9, 0xfc0
	ctx.r[9].s64 = ctx.r[9].s64 + 4032;
	// 8286815C: 39680FA4  addi r11, r8, 0xfa4
	ctx.r[11].s64 = ctx.r[8].s64 + 4004;
	// 82868160: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82868164: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 82868168: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286816C: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 82868170: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82868174: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82868178: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286817C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82868180: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82868188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82868188 size=124
    let mut pc: u32 = 0x82868188;
    'dispatch: loop {
        match pc {
            0x82868188 => {
    //   block [0x82868188..0x82868204)
	// 82868188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286818C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82868190: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82868194: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82868198: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286819C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828681A0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828681A4: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 828681A8: 396B117C  addi r11, r11, 0x117c
	ctx.r[11].s64 = ctx.r[11].s64 + 4476;
	// 828681AC: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828681B0: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 828681B4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828681B8: 394A0FD4  addi r10, r10, 0xfd4
	ctx.r[10].s64 = ctx.r[10].s64 + 4052;
	// 828681BC: 39290FC0  addi r9, r9, 0xfc0
	ctx.r[9].s64 = ctx.r[9].s64 + 4032;
	// 828681C0: 39680FA4  addi r11, r8, 0xfa4
	ctx.r[11].s64 = ctx.r[8].s64 + 4004;
	// 828681C4: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828681C8: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828681CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828681D0: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828681D4: 4BFFEF4D  bl 0x82867120
	ctx.lr = 0x828681D8;
	sub_82867120(ctx, base);
	// 828681D8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828681DC: 4182000C  beq 0x828681e8
	if ctx.cr[0].eq {
	pc = 0x828681E8; continue 'dispatch;
	}
	// 828681E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828681E4: 4858A1F5  bl 0x82df23d8
	ctx.lr = 0x828681E8;
	sub_82DF23D8(ctx, base);
	// 828681E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828681EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828681F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828681F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828681F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828681FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82868200: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82868208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82868208 size=116
    let mut pc: u32 = 0x82868208;
    'dispatch: loop {
        match pc {
            0x82868208 => {
    //   block [0x82868208..0x8286827C)
	// 82868208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286820C: 4893FF59  bl 0x831a8164
	ctx.lr = 0x82868210;
	sub_831A8130(ctx, base);
	// 82868210: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82868214: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82868218: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8286821C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82868220: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82868224: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82868228: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8286822C: 388B11F0  addi r4, r11, 0x11f0
	ctx.r[4].s64 = ctx.r[11].s64 + 4592;
	// 82868230: 38A0047E  li r5, 0x47e
	ctx.r[5].s64 = 1150;
	// 82868234: 386003A0  li r3, 0x3a0
	ctx.r[3].s64 = 928;
	// 82868238: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 8286823C: 4858A1AD  bl 0x82df23e8
	ctx.lr = 0x82868240;
	sub_82DF23E8(ctx, base);
	// 82868240: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82868244: 41820020  beq 0x82868264
	if ctx.cr[0].eq {
	pc = 0x82868264; continue 'dispatch;
	}
	// 82868248: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 8286824C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82868250: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82868254: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82868258: 4BFFFEC1  bl 0x82868118
	ctx.lr = 0x8286825C;
	sub_82868118(ctx, base);
	// 8286825C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82868260: 48000008  b 0x82868268
	pc = 0x82868268; continue 'dispatch;
	// 82868264: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82868268: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286826C: 4BFFF365  bl 0x828675d0
	ctx.lr = 0x82868270;
	sub_828675D0(ctx, base);
	// 82868270: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82868274: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82868278: 4893FF3C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82868280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82868280 size=112
    let mut pc: u32 = 0x82868280;
    'dispatch: loop {
        match pc {
            0x82868280 => {
    //   block [0x82868280..0x828682F0)
	// 82868280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82868284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82868288: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286828C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82868290: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82868294: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82868298: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286829C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828682A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828682A4: 4BFFE93D  bl 0x82866be0
	ctx.lr = 0x828682A8;
	sub_82866BE0(ctx, base);
	// 828682A8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828682AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828682B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828682B4: 4BA57D4D  bl 0x822c0000
	ctx.lr = 0x828682B8;
	sub_822C0000(ctx, base);
	// 828682B8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828682BC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828682C0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828682C4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828682C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828682CC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828682D0: 419A0008  beq cr6, 0x828682d8
	if ctx.cr[6].eq {
	pc = 0x828682D8; continue 'dispatch;
	}
	// 828682D4: 4BA585BD  bl 0x822c0890
	ctx.lr = 0x828682D8;
	sub_822C0890(ctx, base);
	// 828682D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828682DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828682E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828682E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828682E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828682EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828682F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828682F0 size=112
    let mut pc: u32 = 0x828682F0;
    'dispatch: loop {
        match pc {
            0x828682F0 => {
    //   block [0x828682F0..0x82868360)
	// 828682F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828682F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828682F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828682FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82868300: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82868304: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82868308: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286830C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82868310: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82868314: 4BFFE995  bl 0x82866ca8
	ctx.lr = 0x82868318;
	sub_82866CA8(ctx, base);
	// 82868318: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8286831C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82868320: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82868324: 4BA57CDD  bl 0x822c0000
	ctx.lr = 0x82868328;
	sub_822C0000(ctx, base);
	// 82868328: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8286832C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82868330: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82868334: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82868338: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286833C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82868340: 419A0008  beq cr6, 0x82868348
	if ctx.cr[6].eq {
	pc = 0x82868348; continue 'dispatch;
	}
	// 82868344: 4BA5854D  bl 0x822c0890
	ctx.lr = 0x82868348;
	sub_822C0890(ctx, base);
	// 82868348: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286834C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82868350: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82868354: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82868358: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286835C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82868360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82868360 size=112
    let mut pc: u32 = 0x82868360;
    'dispatch: loop {
        match pc {
            0x82868360 => {
    //   block [0x82868360..0x828683D0)
	// 82868360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82868364: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82868368: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286836C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82868370: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82868374: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82868378: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286837C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82868380: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82868384: 4BFFE9ED  bl 0x82866d70
	ctx.lr = 0x82868388;
	sub_82866D70(ctx, base);
	// 82868388: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8286838C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82868390: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82868394: 4BA57C6D  bl 0x822c0000
	ctx.lr = 0x82868398;
	sub_822C0000(ctx, base);
	// 82868398: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8286839C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828683A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828683A4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828683A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828683AC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828683B0: 419A0008  beq cr6, 0x828683b8
	if ctx.cr[6].eq {
	pc = 0x828683B8; continue 'dispatch;
	}
	// 828683B4: 4BA584DD  bl 0x822c0890
	ctx.lr = 0x828683B8;
	sub_822C0890(ctx, base);
	// 828683B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828683BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828683C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828683C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828683C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828683CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828683D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828683D0 size=120
    let mut pc: u32 = 0x828683D0;
    'dispatch: loop {
        match pc {
            0x828683D0 => {
    //   block [0x828683D0..0x82868448)
	// 828683D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828683D4: 4893FD99  bl 0x831a816c
	ctx.lr = 0x828683D8;
	sub_831A8130(ctx, base);
	// 828683D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828683DC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828683E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828683E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828683E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828683EC: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 828683F0: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 828683F4: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828683F8: 48589FF1  bl 0x82df23e8
	ctx.lr = 0x828683FC;
	sub_82DF23E8(ctx, base);
	// 828683FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82868400: 41820014  beq 0x82868414
	if ctx.cr[0].eq {
	pc = 0x82868414; continue 'dispatch;
	}
	// 82868404: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82868408: 480DD8F1  bl 0x82945cf8
	ctx.lr = 0x8286840C;
	sub_82945CF8(ctx, base);
	// 8286840C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82868410: 48000008  b 0x82868418
	pc = 0x82868418; continue 'dispatch;
	// 82868414: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82868418: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8286841C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82868420: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82868424: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82868428: 4BFFEA11  bl 0x82866e38
	ctx.lr = 0x8286842C;
	sub_82866E38(ctx, base);
	// 8286842C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82868430: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82868434: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82868438: 4BA57BC9  bl 0x822c0000
	ctx.lr = 0x8286843C;
	sub_822C0000(ctx, base);
	// 8286843C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82868440: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82868444: 4893FD78  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82868448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82868448 size=112
    let mut pc: u32 = 0x82868448;
    'dispatch: loop {
        match pc {
            0x82868448 => {
    //   block [0x82868448..0x828684B8)
	// 82868448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286844C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82868450: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82868454: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82868458: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286845C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82868460: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82868464: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82868468: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8286846C: 4BFFEA95  bl 0x82866f00
	ctx.lr = 0x82868470;
	sub_82866F00(ctx, base);
	// 82868470: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82868474: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82868478: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8286847C: 4BA57B85  bl 0x822c0000
	ctx.lr = 0x82868480;
	sub_822C0000(ctx, base);
	// 82868480: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82868484: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82868488: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8286848C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82868490: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82868494: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82868498: 419A0008  beq cr6, 0x828684a0
	if ctx.cr[6].eq {
	pc = 0x828684A0; continue 'dispatch;
	}
	// 8286849C: 4BA583F5  bl 0x822c0890
	ctx.lr = 0x828684A0;
	sub_822C0890(ctx, base);
	// 828684A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828684A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828684A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828684AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828684B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828684B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828684B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828684B8 size=120
    let mut pc: u32 = 0x828684B8;
    'dispatch: loop {
        match pc {
            0x828684B8 => {
    //   block [0x828684B8..0x82868530)
	// 828684B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828684BC: 4893FCB1  bl 0x831a816c
	ctx.lr = 0x828684C0;
	sub_831A8130(ctx, base);
	// 828684C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828684C4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828684C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828684CC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828684D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828684D4: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 828684D8: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 828684DC: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 828684E0: 48589F09  bl 0x82df23e8
	ctx.lr = 0x828684E4;
	sub_82DF23E8(ctx, base);
	// 828684E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828684E8: 41820014  beq 0x828684fc
	if ctx.cr[0].eq {
	pc = 0x828684FC; continue 'dispatch;
	}
	// 828684EC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828684F0: 480DD6E9  bl 0x82945bd8
	ctx.lr = 0x828684F4;
	sub_82945BD8(ctx, base);
	// 828684F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828684F8: 48000008  b 0x82868500
	pc = 0x82868500; continue 'dispatch;
	// 828684FC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82868500: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82868504: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82868508: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8286850C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82868510: 4BFFEAB9  bl 0x82866fc8
	ctx.lr = 0x82868514;
	sub_82866FC8(ctx, base);
	// 82868514: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82868518: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8286851C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82868520: 4BA57AE1  bl 0x822c0000
	ctx.lr = 0x82868524;
	sub_822C0000(ctx, base);
	// 82868524: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82868528: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286852C: 4893FC90  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82868530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82868530 size=560
    let mut pc: u32 = 0x82868530;
    'dispatch: loop {
        match pc {
            0x82868530 => {
    //   block [0x82868530..0x82868760)
	// 82868530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82868534: 4893FC35  bl 0x831a8168
	ctx.lr = 0x82868538;
	sub_831A8130(ctx, base);
	// 82868538: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286853C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82868540: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82868544: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82868548: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8286854C: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82868550: 419A0208  beq cr6, 0x82868758
	if ctx.cr[6].eq {
	pc = 0x82868758; continue 'dispatch;
	}
	// 82868554: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82868558: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8286855C: 388B11F0  addi r4, r11, 0x11f0
	ctx.r[4].s64 = ctx.r[11].s64 + 4592;
	// 82868560: 38A001E3  li r5, 0x1e3
	ctx.r[5].s64 = 483;
	// 82868564: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82868568: 4BA57E71  bl 0x822c03d8
	ctx.lr = 0x8286856C;
	sub_822C03D8(ctx, base);
	// 8286856C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82868570: 41820034  beq 0x828685a4
	if ctx.cr[0].eq {
	pc = 0x828685A4; continue 'dispatch;
	}
	// 82868574: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82868578: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286857C: 388B1CAC  addi r4, r11, 0x1cac
	ctx.r[4].s64 = ctx.r[11].s64 + 7340;
	// 82868580: 4858B489  bl 0x82df3a08
	ctx.lr = 0x82868584;
	sub_82DF3A08(ctx, base);
	// 82868584: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82868588: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286858C: 80BD0388  lwz r5, 0x388(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(904 as u32) ) } as u64;
	// 82868590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82868594: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82868598: 4BD43E79  bl 0x825ac410
	ctx.lr = 0x8286859C;
	sub_825AC410(ctx, base);
	// 8286859C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828685A0: 48000008  b 0x828685a8
	pc = 0x828685A8; continue 'dispatch;
	// 828685A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828685A8: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828685AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828685B0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828685B4: 4BC8AE05  bl 0x824f33b8
	ctx.lr = 0x828685B8;
	sub_824F33B8(ctx, base);
	// 828685B8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828685BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828685C0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828685C4: 4BA57A3D  bl 0x822c0000
	ctx.lr = 0x828685C8;
	sub_822C0000(ctx, base);
	// 828685C8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828685CC: 4182000C  beq 0x828685d8
	if ctx.cr[0].eq {
	pc = 0x828685D8; continue 'dispatch;
	}
	// 828685D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828685D4: 4858AE55  bl 0x82df3428
	ctx.lr = 0x828685D8;
	sub_82DF3428(ctx, base);
	// 828685D8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828685DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828685E0: 388B12F8  addi r4, r11, 0x12f8
	ctx.r[4].s64 = ctx.r[11].s64 + 4856;
	// 828685E4: 4858B425  bl 0x82df3a08
	ctx.lr = 0x828685E8;
	sub_82DF3A08(ctx, base);
	// 828685E8: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828685EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828685F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828685F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828685F8: 4BD437C9  bl 0x825abdc0
	ctx.lr = 0x828685FC;
	sub_825ABDC0(ctx, base);
	// 828685FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82868600: 4858AE29  bl 0x82df3428
	ctx.lr = 0x82868604;
	sub_82DF3428(ctx, base);
	// 82868604: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82868608: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286860C: 388B12E8  addi r4, r11, 0x12e8
	ctx.r[4].s64 = ctx.r[11].s64 + 4840;
	// 82868610: 4858B3F9  bl 0x82df3a08
	ctx.lr = 0x82868614;
	sub_82DF3A08(ctx, base);
	// 82868614: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82868618: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8286861C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82868620: 4BD437A1  bl 0x825abdc0
	ctx.lr = 0x82868624;
	sub_825ABDC0(ctx, base);
	// 82868624: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82868628: 4858AE01  bl 0x82df3428
	ctx.lr = 0x8286862C;
	sub_82DF3428(ctx, base);
	// 8286862C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82868630: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82868634: 388B12D4  addi r4, r11, 0x12d4
	ctx.r[4].s64 = ctx.r[11].s64 + 4820;
	// 82868638: 4858B3D1  bl 0x82df3a08
	ctx.lr = 0x8286863C;
	sub_82DF3A08(ctx, base);
	// 8286863C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82868640: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82868644: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82868648: 4BD43779  bl 0x825abdc0
	ctx.lr = 0x8286864C;
	sub_825ABDC0(ctx, base);
	// 8286864C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82868650: 4858ADD9  bl 0x82df3428
	ctx.lr = 0x82868654;
	sub_82DF3428(ctx, base);
	// 82868654: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82868658: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286865C: 388B12B8  addi r4, r11, 0x12b8
	ctx.r[4].s64 = ctx.r[11].s64 + 4792;
	// 82868660: 4858B3A9  bl 0x82df3a08
	ctx.lr = 0x82868664;
	sub_82DF3A08(ctx, base);
	// 82868664: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82868668: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 8286866C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82868670: 4BD43751  bl 0x825abdc0
	ctx.lr = 0x82868674;
	sub_825ABDC0(ctx, base);
	// 82868674: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82868678: 4858ADB1  bl 0x82df3428
	ctx.lr = 0x8286867C;
	sub_82DF3428(ctx, base);
	// 8286867C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82868680: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82868684: 388B4858  addi r4, r11, 0x4858
	ctx.r[4].s64 = ctx.r[11].s64 + 18520;
	// 82868688: 4858B381  bl 0x82df3a08
	ctx.lr = 0x8286868C;
	sub_82DF3A08(ctx, base);
	// 8286868C: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82868690: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82868694: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82868698: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 8286869C: 419A0024  beq cr6, 0x828686c0
	if ctx.cr[6].eq {
	pc = 0x828686C0; continue 'dispatch;
	}
	// 828686A0: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 828686A4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828686A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828686AC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828686B0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828686B4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828686B8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828686BC: 4082FFE8  bne 0x828686a4
	if !ctx.cr[0].eq {
	pc = 0x828686A4; continue 'dispatch;
	}
	// 828686C0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828686C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828686C8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828686CC: 4BD39A45  bl 0x825a2110
	ctx.lr = 0x828686D0;
	sub_825A2110(ctx, base);
	// 828686D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828686D4: 4858AD55  bl 0x82df3428
	ctx.lr = 0x828686D8;
	sub_82DF3428(ctx, base);
	// 828686D8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828686DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828686E0: 388B12B0  addi r4, r11, 0x12b0
	ctx.r[4].s64 = ctx.r[11].s64 + 4784;
	// 828686E4: 4858B325  bl 0x82df3a08
	ctx.lr = 0x828686E8;
	sub_82DF3A08(ctx, base);
	// 828686E8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 828686EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828686F0: 388BBE80  addi r4, r11, -0x4180
	ctx.r[4].s64 = ctx.r[11].s64 + -16768;
	// 828686F4: 4858B315  bl 0x82df3a08
	ctx.lr = 0x828686F8;
	sub_82DF3A08(ctx, base);
	// 828686F8: 817D0388  lwz r11, 0x388(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(904 as u32) ) } as u64;
	// 828686FC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82868700: 38E0000A  li r7, 0xa
	ctx.r[7].s64 = 10;
	// 82868704: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82868708: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8286870C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82868710: 38AB0004  addi r5, r11, 4
	ctx.r[5].s64 = ctx.r[11].s64 + 4;
	// 82868714: 4BD4547D  bl 0x825adb90
	ctx.lr = 0x82868718;
	sub_825ADB90(ctx, base);
	// 82868718: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8286871C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82868720: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82868724: 4BD39695  bl 0x825a1db8
	ctx.lr = 0x82868728;
	sub_825A1DB8(ctx, base);
	// 82868728: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 8286872C: 4858ACFD  bl 0x82df3428
	ctx.lr = 0x82868730;
	sub_82DF3428(ctx, base);
	// 82868730: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82868734: 4BA60585  bl 0x822c8cb8
	ctx.lr = 0x82868738;
	sub_822C8CB8(ctx, base);
	// 82868738: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286873C: 4858ACED  bl 0x82df3428
	ctx.lr = 0x82868740;
	sub_82DF3428(ctx, base);
	// 82868740: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82868744: 4858ACE5  bl 0x82df3428
	ctx.lr = 0x82868748;
	sub_82DF3428(ctx, base);
	// 82868748: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8286874C: 419A000C  beq cr6, 0x82868758
	if ctx.cr[6].eq {
	pc = 0x82868758; continue 'dispatch;
	}
	// 82868750: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82868754: 4BA5813D  bl 0x822c0890
	ctx.lr = 0x82868758;
	sub_822C0890(ctx, base);
	// 82868758: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 8286875C: 4893FA5C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82868760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82868760 size=396
    let mut pc: u32 = 0x82868760;
    'dispatch: loop {
        match pc {
            0x82868760 => {
    //   block [0x82868760..0x828688EC)
	// 82868760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82868764: 4893F9F5  bl 0x831a8158
	ctx.lr = 0x82868768;
	sub_831A8130(ctx, base);
	// 82868768: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 8286876C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82868770: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82868774: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82868778: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286877C: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82868780: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82868784: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 82868788: 409A0008  bne cr6, 0x82868790
	if !ctx.cr[6].eq {
	pc = 0x82868790; continue 'dispatch;
	}
	// 8286878C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82868790: 4BCBF8F9  bl 0x82528088
	ctx.lr = 0x82868794;
	sub_82528088(ctx, base);
	// 82868794: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 82868798: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8286879C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828687A0: 4BF839C1  bl 0x827ec160
	ctx.lr = 0x828687A4;
	sub_827EC160(ctx, base);
	// 828687A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828687A8: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 828687AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828687B0: 4E800421  bctrl
	ctx.lr = 0x828687B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828687B4: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 828687B8: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828687BC: C3E30000  lfs f31, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828687C0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828687C4: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 828687C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828687CC: 817C6810  lwz r11, 0x6810(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26640 as u32) ) } as u64;
	// 828687D0: 388811F0  addi r4, r8, 0x11f0
	ctx.r[4].s64 = ctx.r[8].s64 + 4592;
	// 828687D4: C00A09C8  lfs f0, 0x9c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828687D8: 38A0034E  li r5, 0x34e
	ctx.r[5].s64 = 846;
	// 828687DC: EDBF002A  fadds f13, f31, f0
	ctx.f[13].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 828687E0: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828687E4: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828687E8: 38600200  li r3, 0x200
	ctx.r[3].s64 = 512;
	// 828687EC: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828687F0: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828687F4: 917F0258  stw r11, 0x258(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(600 as u32), ctx.r[11].u32 ) };
	// 828687F8: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828687FC: 48589BED  bl 0x82df23e8
	ctx.lr = 0x82868800;
	sub_82DF23E8(ctx, base);
	// 82868800: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82868804: 41820080  beq 0x82868884
	if ctx.cr[0].eq {
	pc = 0x82868884; continue 'dispatch;
	}
	// 82868808: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286880C: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82868810: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82868814: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82868818: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8286881C: 48637F15  bl 0x82ea0730
	ctx.lr = 0x82868820;
	sub_82EA0730(ctx, base);
	// 82868820: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 82868824: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82868828: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 8286882C: 486B19C5  bl 0x82f1a1f0
	ctx.lr = 0x82868830;
	sub_82F1A1F0(ctx, base);
	// 82868830: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82868834: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82868838: 839C6810  lwz r28, 0x6810(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26640 as u32) ) } as u64;
	// 8286883C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82868840: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82868844: 3BCBBA80  addi r30, r11, -0x4580
	ctx.r[30].s64 = ctx.r[11].s64 + -17792;
	// 82868848: 3B400003  li r26, 3
	ctx.r[26].s64 = 3;
	// 8286884C: 3B210060  addi r25, r1, 0x60
	ctx.r[25].s64 = ctx.r[1].s64 + 96;
	// 82868850: 3B010050  addi r24, r1, 0x50
	ctx.r[24].s64 = ctx.r[1].s64 + 80;
	// 82868854: 4BCA6CC5  bl 0x8250f518
	ctx.lr = 0x82868858;
	sub_8250F518(ctx, base);
	// 82868858: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8286885C: 389F0038  addi r4, r31, 0x38
	ctx.r[4].s64 = ctx.r[31].s64 + 56;
	// 82868860: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82868864: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 82868868: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 8286886C: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82868870: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82868874: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 82868878: 4827EA69  bl 0x82ae72e0
	ctx.lr = 0x8286887C;
	sub_82AE72E0(ctx, base);
	// 8286887C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82868880: 48000008  b 0x82868888
	pc = 0x82868888; continue 'dispatch;
	// 82868884: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82868888: 3BFF01E4  addi r31, r31, 0x1e4
	ctx.r[31].s64 = ctx.r[31].s64 + 484;
	// 8286888C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82868890: 4BB0B9C9  bl 0x82374258
	ctx.lr = 0x82868894;
	sub_82374258(ctx, base);
	// 82868894: 574B07BD  rlwinm. r11, r26, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82868898: 41820010  beq 0x828688a8
	if ctx.cr[0].eq {
	pc = 0x828688A8; continue 'dispatch;
	}
	// 8286889C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828688A0: 575A07FA  rlwinm r26, r26, 0, 0x1f, 0x1d
	ctx.r[26].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 828688A4: 485893ED  bl 0x82df1c90
	ctx.lr = 0x828688A8;
	sub_82DF1C90(ctx, base);
	// 828688A8: 574B07FF  clrlwi. r11, r26, 0x1f
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828688AC: 41820014  beq 0x828688c0
	if ctx.cr[0].eq {
	pc = 0x828688C0; continue 'dispatch;
	}
	// 828688B0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828688B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828688B8: 419A0008  beq cr6, 0x828688c0
	if ctx.cr[6].eq {
	pc = 0x828688C0; continue 'dispatch;
	}
	// 828688BC: 4BA7F9AD  bl 0x822e8268
	ctx.lr = 0x828688C0;
	sub_822E8268(ctx, base);
	// 828688C0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828688C4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828688C8: C02BEE7C  lfs f1, -0x1184(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4484 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828688CC: 4827AA85  bl 0x82ae3350
	ctx.lr = 0x828688D0;
	sub_82AE3350(ctx, base);
	// 828688D0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828688D4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828688D8: 38802012  li r4, 0x2012
	ctx.r[4].s64 = 8210;
	// 828688DC: 4BC268D5  bl 0x8248f1b0
	ctx.lr = 0x828688E0;
	sub_8248F1B0(ctx, base);
	// 828688E0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828688E4: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 828688E8: 4893F8C0  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828688F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828688F0 size=740
    let mut pc: u32 = 0x828688F0;
    'dispatch: loop {
        match pc {
            0x828688F0 => {
    //   block [0x828688F0..0x82868BD4)
	// 828688F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828688F4: 4893F871  bl 0x831a8164
	ctx.lr = 0x828688F8;
	sub_831A8130(ctx, base);
	// 828688F8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828688FC: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82868900: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82868904: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82868908: 807B0370  lwz r3, 0x370(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(880 as u32) ) } as u64;
	// 8286890C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82868910: 419A02B8  beq cr6, 0x82868bc8
	if ctx.cr[6].eq {
	pc = 0x82868BC8; continue 'dispatch;
	}
	// 82868914: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82868918: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 8286891C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82868920: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82868924: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82868928: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8286892C: 4E800421  bctrl
	ctx.lr = 0x82868930;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82868930: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82868934: 41820294  beq 0x82868bc8
	if ctx.cr[0].eq {
	pc = 0x82868BC8; continue 'dispatch;
	}
	// 82868938: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286893C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82868940: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 82868944: 4858B0C5  bl 0x82df3a08
	ctx.lr = 0x82868948;
	sub_82DF3A08(ctx, base);
	// 82868948: 3BDB010C  addi r30, r27, 0x10c
	ctx.r[30].s64 = ctx.r[27].s64 + 268;
	// 8286894C: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 82868950: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82868954: 485F1D7D  bl 0x82e5a6d0
	ctx.lr = 0x82868958;
	sub_82E5A6D0(ctx, base);
	// 82868958: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8286895C: 4858A945  bl 0x82df32a0
	ctx.lr = 0x82868960;
	sub_82DF32A0(ctx, base);
	// 82868960: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82868964: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82868968: 4858AAC1  bl 0x82df3428
	ctx.lr = 0x8286896C;
	sub_82DF3428(ctx, base);
	// 8286896C: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82868970: 41820258  beq 0x82868bc8
	if ctx.cr[0].eq {
	pc = 0x82868BC8; continue 'dispatch;
	}
	// 82868974: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82868978: 83FB0378  lwz r31, 0x378(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(888 as u32) ) } as u64;
	// 8286897C: 485F1D55  bl 0x82e5a6d0
	ctx.lr = 0x82868980;
	sub_82E5A6D0(ctx, base);
	// 82868980: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82868984: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82868988: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8286898C: 480B9705  bl 0x82922090
	ctx.lr = 0x82868990;
	sub_82922090(ctx, base);
	// 82868990: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82868994: 41820234  beq 0x82868bc8
	if ctx.cr[0].eq {
	pc = 0x82868BC8; continue 'dispatch;
	}
	// 82868998: 3BBB0010  addi r29, r27, 0x10
	ctx.r[29].s64 = ctx.r[27].s64 + 16;
	// 8286899C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828689A0: 4BF837C1  bl 0x827ec160
	ctx.lr = 0x828689A4;
	sub_827EC160(ctx, base);
	// 828689A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828689A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828689AC: 480AE3ED  bl 0x82916d98
	ctx.lr = 0x828689B0;
	sub_82916D98(ctx, base);
	// 828689B0: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	// 828689B4: 80E10060  lwz r7, 0x60(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828689B8: 394000D0  li r10, 0xd0
	ctx.r[10].s64 = 208;
	// 828689BC: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 828689C0: 390000E0  li r8, 0xe0
	ctx.r[8].s64 = 224;
	// 828689C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828689C8: 13FC58C7  vcmpequd (lvx128) v31, v28, v11
	tmp.u32 = ctx.r[28].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828689CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82868BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82868BD8 size=400
    let mut pc: u32 = 0x82868BD8;
    'dispatch: loop {
        match pc {
            0x82868BD8 => {
    //   block [0x82868BD8..0x82868D68)
	// 82868BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82868BDC: 4893F589  bl 0x831a8164
	ctx.lr = 0x82868BE0;
	sub_831A8130(ctx, base);
	// 82868BE0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82868BE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82868BE8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82868BEC: 480A1655  bl 0x8290a240
	ctx.lr = 0x82868BF0;
	sub_8290A240(ctx, base);
	// 82868BF0: 807F0360  lwz r3, 0x360(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(864 as u32) ) } as u64;
	// 82868BF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82868BF8: 419A0168  beq cr6, 0x82868d60
	if ctx.cr[6].eq {
	pc = 0x82868D60; continue 'dispatch;
	}
	// 82868BFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82868C00: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82868C04: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82868C08: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82868C0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82868C10: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82868C14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82868C18: 4E800421  bctrl
	ctx.lr = 0x82868C1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82868C1C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82868C20: 41820140  beq 0x82868d60
	if ctx.cr[0].eq {
	pc = 0x82868D60; continue 'dispatch;
	}
	// 82868C24: 897C001C  lbz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 82868C28: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82868C2C: 41820018  beq 0x82868c44
	if ctx.cr[0].eq {
	pc = 0x82868C44; continue 'dispatch;
	}
	// 82868C30: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 82868C34: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82868C38: 13FC58C7  vcmpequd (lvx128) v31, v28, v11
	tmp.u32 = ctx.r[28].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82868D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82868D68 size=592
    let mut pc: u32 = 0x82868D68;
    'dispatch: loop {
        match pc {
            0x82868D68 => {
    //   block [0x82868D68..0x82868FB8)
	// 82868D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82868D6C: 4893F3F5  bl 0x831a8160
	ctx.lr = 0x82868D70;
	sub_831A8130(ctx, base);
	// 82868D70: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82868D74: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82868D78: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82868D7C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82868D80: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82868D84: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82868D88: 808B0B7C  lwz r4, 0xb7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2940 as u32) ) } as u64;
	// 82868D8C: 4858AC7D  bl 0x82df3a08
	ctx.lr = 0x82868D90;
	sub_82DF3A08(ctx, base);
	// 82868D90: 3BFC010C  addi r31, r28, 0x10c
	ctx.r[31].s64 = ctx.r[28].s64 + 268;
	// 82868D94: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82868D98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82868D9C: 3BA10054  addi r29, r1, 0x54
	ctx.r[29].s64 = ctx.r[1].s64 + 84;
	// 82868DA0: 485F1931  bl 0x82e5a6d0
	ctx.lr = 0x82868DA4;
	sub_82E5A6D0(ctx, base);
	// 82868DA4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82868DA8: 4858A561  bl 0x82df3308
	ctx.lr = 0x82868DAC;
	sub_82DF3308(ctx, base);
	// 82868DAC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82868DB0: 40820038  bne 0x82868de8
	if !ctx.cr[0].eq {
	pc = 0x82868DE8; continue 'dispatch;
	}
	// 82868DB4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82868DB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82868DBC: 808B0B98  lwz r4, 0xb98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2968 as u32) ) } as u64;
	// 82868DC0: 4858AC49  bl 0x82df3a08
	ctx.lr = 0x82868DC4;
	sub_82DF3A08(ctx, base);
	// 82868DC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82868DC8: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 82868DCC: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 82868DD0: 485F1901  bl 0x82e5a6d0
	ctx.lr = 0x82868DD4;
	sub_82E5A6D0(ctx, base);
	// 82868DD4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82868DD8: 4858A531  bl 0x82df3308
	ctx.lr = 0x82868DDC;
	sub_82DF3308(ctx, base);
	// 82868DDC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82868DE0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82868DE4: 41820008  beq 0x82868dec
	if ctx.cr[0].eq {
	pc = 0x82868DEC; continue 'dispatch;
	}
	// 82868DE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82868DEC: 57CA07BD  rlwinm. r10, r30, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82868DF0: 557D063E  clrlwi r29, r11, 0x18
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82868DF4: 41820010  beq 0x82868e04
	if ctx.cr[0].eq {
	pc = 0x82868E04; continue 'dispatch;
	}
	// 82868DF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82868DFC: 57DE07FA  rlwinm r30, r30, 0, 0x1f, 0x1d
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 82868E00: 4858A629  bl 0x82df3428
	ctx.lr = 0x82868E04;
	sub_82DF3428(ctx, base);
	// 82868E04: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82868E08: 4182000C  beq 0x82868e14
	if ctx.cr[0].eq {
	pc = 0x82868E14; continue 'dispatch;
	}
	// 82868E0C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82868E10: 4858A619  bl 0x82df3428
	ctx.lr = 0x82868E14;
	sub_82DF3428(ctx, base);
	// 82868E14: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82868E18: 40820198  bne 0x82868fb0
	if !ctx.cr[0].eq {
	pc = 0x82868FB0; continue 'dispatch;
	}
	// 82868E1C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82868E20: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82868E24: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82868E28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82868E2C: 4E800421  bctrl
	ctx.lr = 0x82868E30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82868E30: C0030088  lfs f0, 0x88(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82868E34: C1830090  lfs f12, 0x90(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82868E38: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82868E3C: ED4C002A  fadds f10, f12, f0
	ctx.f[10].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82868E40: C183008C  lfs f12, 0x8c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82868E44: C1BB0018  lfs f13, 0x18(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82868E48: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82868E4C: C16B08A8  lfs f11, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82868E50: ED4A602A  fadds f10, f10, f12
	ctx.f[10].f64 = ((ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64;
	// 82868E54: ED6B5024  fdivs f11, f11, f10
	ctx.f[11].f64 = ((ctx.f[11].f64 / ctx.f[10].f64) as f32) as f64;
	// 82868E58: ED4002F2  fmuls f10, f0, f11
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82868E5C: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 82868E60: 40980038  bge cr6, 0x82868e98
	if !ctx.cr[6].lt {
	pc = 0x82868E98; continue 'dispatch;
	}
	// 82868E64: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82868E68: 808B0B88  lwz r4, 0xb88(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2952 as u32) ) } as u64;
	// 82868E6C: 4858AB9D  bl 0x82df3a08
	ctx.lr = 0x82868E70;
	sub_82DF3A08(ctx, base);
	// 82868E70: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82868E74: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82868E78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82868E7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82868E80: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82868E84: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82868E88: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82868E8C: 485F5AD5  bl 0x82e5e960
	ctx.lr = 0x82868E90;
	sub_82E5E960(ctx, base);
	// 82868E90: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82868E94: 48000078  b 0x82868f0c
	pc = 0x82868F0C; continue 'dispatch;
	// 82868E98: EC00602A  fadds f0, f0, f12
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82868E9C: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82868EA0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82868EA4: 40980038  bge cr6, 0x82868edc
	if !ctx.cr[6].lt {
	pc = 0x82868EDC; continue 'dispatch;
	}
	// 82868EA8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82868EAC: 808B0B8C  lwz r4, 0xb8c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2956 as u32) ) } as u64;
	// 82868EB0: 4858AB59  bl 0x82df3a08
	ctx.lr = 0x82868EB4;
	sub_82DF3A08(ctx, base);
	// 82868EB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82868EB8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82868EBC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82868EC0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82868EC4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82868EC8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82868ECC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82868ED0: 485F5A91  bl 0x82e5e960
	ctx.lr = 0x82868ED4;
	sub_82E5E960(ctx, base);
	// 82868ED4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82868ED8: 48000034  b 0x82868f0c
	pc = 0x82868F0C; continue 'dispatch;
	// 82868EDC: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82868EE0: 808B689C  lwz r4, 0x689c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26780 as u32) ) } as u64;
	// 82868EE4: 4858AB25  bl 0x82df3a08
	ctx.lr = 0x82868EE8;
	sub_82DF3A08(ctx, base);
	// 82868EE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82868EEC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82868EF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82868EF4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82868EF8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82868EFC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82868F00: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82868F04: 485F5A5D  bl 0x82e5e960
	ctx.lr = 0x82868F08;
	sub_82E5E960(ctx, base);
	// 82868F08: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82868F0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82868F10: 419A0008  beq cr6, 0x82868f18
	if ctx.cr[6].eq {
	pc = 0x82868F18; continue 'dispatch;
	}
	// 82868F14: 4BA5797D  bl 0x822c0890
	ctx.lr = 0x82868F18;
	sub_822C0890(ctx, base);
	// 82868F18: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82868F1C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82868F20: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82868F24: 4BFFF595  bl 0x828684b8
	ctx.lr = 0x82868F28;
	sub_828684B8(ctx, base);
	// 82868F28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82868F2C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82868F30: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82868F34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82868F38: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82868F3C: 419A0024  beq cr6, 0x82868f60
	if ctx.cr[6].eq {
	pc = 0x82868F60; continue 'dispatch;
	}
	// 82868F40: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82868F44: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82868F48: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82868F4C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82868F50: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82868F54: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82868F58: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82868F5C: 4082FFE8  bne 0x82868f44
	if !ctx.cr[0].eq {
	pc = 0x82868F44; continue 'dispatch;
	}
	// 82868F60: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82868F64: 3BE10058  addi r31, r1, 0x58
	ctx.r[31].s64 = ctx.r[1].s64 + 88;
	// 82868F68: 4879F1C1  bl 0x83008128
	ctx.lr = 0x82868F6C;
	sub_83008128(ctx, base);
	// 82868F6C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82868F70: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82868F74: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82868F78: 388A11F0  addi r4, r10, 0x11f0
	ctx.r[4].s64 = ctx.r[10].s64 + 4592;
	// 82868F7C: 38A003F0  li r5, 0x3f0
	ctx.r[5].s64 = 1008;
	// 82868F80: 387C0038  addi r3, r28, 0x38
	ctx.r[3].s64 = ctx.r[28].s64 + 56;
	// 82868F84: C02B09D0  lfs f1, 0x9d0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2512 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82868F88: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82868F8C: 485EFAB5  bl 0x82e58a40
	ctx.lr = 0x82868F90;
	sub_82E58A40(ctx, base);
	// 82868F90: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82868F94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82868F98: 419A0008  beq cr6, 0x82868fa0
	if ctx.cr[6].eq {
	pc = 0x82868FA0; continue 'dispatch;
	}
	// 82868F9C: 4BA578F5  bl 0x822c0890
	ctx.lr = 0x82868FA0;
	sub_822C0890(ctx, base);
	// 82868FA0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82868FA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82868FA8: 419A0008  beq cr6, 0x82868fb0
	if ctx.cr[6].eq {
	pc = 0x82868FB0; continue 'dispatch;
	}
	// 82868FAC: 4BA578E5  bl 0x822c0890
	ctx.lr = 0x82868FB0;
	sub_822C0890(ctx, base);
	// 82868FB0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82868FB4: 4893F1FC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82868FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82868FB8 size=112
    let mut pc: u32 = 0x82868FB8;
    'dispatch: loop {
        match pc {
            0x82868FB8 => {
    //   block [0x82868FB8..0x82869028)
	// 82868FB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82868FBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82868FC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82868FC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82868FC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82868FCC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82868FD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82868FD4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82868FD8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82868FDC: 4BFFE64D  bl 0x82867628
	ctx.lr = 0x82868FE0;
	sub_82867628(ctx, base);
	// 82868FE0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82868FE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82868FE8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82868FEC: 4BA57015  bl 0x822c0000
	ctx.lr = 0x82868FF0;
	sub_822C0000(ctx, base);
	// 82868FF0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82868FF4: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82868FF8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82868FFC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82869000: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82869004: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82869008: 419A0008  beq cr6, 0x82869010
	if ctx.cr[6].eq {
	pc = 0x82869010; continue 'dispatch;
	}
	// 8286900C: 4BA57885  bl 0x822c0890
	ctx.lr = 0x82869010;
	sub_822C0890(ctx, base);
	// 82869010: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82869014: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82869018: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286901C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82869020: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82869024: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82869028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82869028 size=128
    let mut pc: u32 = 0x82869028;
    'dispatch: loop {
        match pc {
            0x82869028 => {
    //   block [0x82869028..0x828690A8)
	// 82869028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286902C: 4893F141  bl 0x831a816c
	ctx.lr = 0x82869030;
	sub_831A8130(ctx, base);
	// 82869030: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82869034: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82869038: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8286903C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82869040: 3BEBBA18  addi r31, r11, -0x45e8
	ctx.r[31].s64 = ctx.r[11].s64 + -17896;
	// 82869044: 816ABA20  lwz r11, -0x45e0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17888 as u32) ) } as u64;
	// 82869048: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8286904C: 40820024  bne 0x82869070
	if !ctx.cr[0].eq {
	pc = 0x82869070; continue 'dispatch;
	}
	// 82869050: 3D208236  lis r9, -0x7dca
	ctx.r[9].s64 = -2110390272;
	// 82869054: 3D008286  lis r8, -0x7d7a
	ctx.r[8].s64 = -2105147392;
	// 82869058: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8286905C: 3929A778  addi r9, r9, -0x5888
	ctx.r[9].s64 = ctx.r[9].s64 + -22664;
	// 82869060: 39087090  addi r8, r8, 0x7090
	ctx.r[8].s64 = ctx.r[8].s64 + 28816;
	// 82869064: 916ABA20  stw r11, -0x45e0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17888 as u32), ctx.r[11].u32 ) };
	// 82869068: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8286906C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82869070: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82869074: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82869078: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286907C: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 82869080: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82869084: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82869088: 4805E851  bl 0x828c78d8
	ctx.lr = 0x8286908C;
	sub_828C78D8(ctx, base);
	// 8286908C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82869090: 4182000C  beq 0x8286909c
	if ctx.cr[0].eq {
	pc = 0x8286909C; continue 'dispatch;
	}
	// 82869094: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82869098: 48000008  b 0x828690a0
	pc = 0x828690A0; continue 'dispatch;
	// 8286909C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828690A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828690A4: 4893F118  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828690A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828690A8 size=128
    let mut pc: u32 = 0x828690A8;
    'dispatch: loop {
        match pc {
            0x828690A8 => {
    //   block [0x828690A8..0x82869128)
	// 828690A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828690AC: 4893F0C1  bl 0x831a816c
	ctx.lr = 0x828690B0;
	sub_831A8130(ctx, base);
	// 828690B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828690B4: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 828690B8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828690BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828690C0: 3BEBBA24  addi r31, r11, -0x45dc
	ctx.r[31].s64 = ctx.r[11].s64 + -17884;
	// 828690C4: 816ABA2C  lwz r11, -0x45d4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17876 as u32) ) } as u64;
	// 828690C8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828690CC: 40820024  bne 0x828690f0
	if !ctx.cr[0].eq {
	pc = 0x828690F0; continue 'dispatch;
	}
	// 828690D0: 3D208236  lis r9, -0x7dca
	ctx.r[9].s64 = -2110390272;
	// 828690D4: 3D008286  lis r8, -0x7d7a
	ctx.r[8].s64 = -2105147392;
	// 828690D8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828690DC: 3929A778  addi r9, r9, -0x5888
	ctx.r[9].s64 = ctx.r[9].s64 + -22664;
	// 828690E0: 390870D8  addi r8, r8, 0x70d8
	ctx.r[8].s64 = ctx.r[8].s64 + 28888;
	// 828690E4: 916ABA2C  stw r11, -0x45d4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17876 as u32), ctx.r[11].u32 ) };
	// 828690E8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828690EC: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828690F0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828690F4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828690F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828690FC: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 82869100: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82869104: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82869108: 4805E7D1  bl 0x828c78d8
	ctx.lr = 0x8286910C;
	sub_828C78D8(ctx, base);
	// 8286910C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82869110: 4182000C  beq 0x8286911c
	if ctx.cr[0].eq {
	pc = 0x8286911C; continue 'dispatch;
	}
	// 82869114: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82869118: 48000008  b 0x82869120
	pc = 0x82869120; continue 'dispatch;
	// 8286911C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82869120: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82869124: 4893F098  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82869128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82869128 size=484
    let mut pc: u32 = 0x82869128;
    'dispatch: loop {
        match pc {
            0x82869128 => {
    //   block [0x82869128..0x8286930C)
	// 82869128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286912C: 4893F035  bl 0x831a8160
	ctx.lr = 0x82869130;
	sub_831A8130(ctx, base);
	// 82869130: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82869134: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82869138: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8286913C: 3BAB11F0  addi r29, r11, 0x11f0
	ctx.r[29].s64 = ctx.r[11].s64 + 4592;
	// 82869140: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82869144: 38A00421  li r5, 0x421
	ctx.r[5].s64 = 1057;
	// 82869148: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8286914C: 386003A0  li r3, 0x3a0
	ctx.r[3].s64 = 928;
	// 82869150: 48589299  bl 0x82df23e8
	ctx.lr = 0x82869154;
	sub_82DF23E8(ctx, base);
	// 82869154: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82869158: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8286915C: 3B8BBA80  addi r28, r11, -0x4580
	ctx.r[28].s64 = ctx.r[11].s64 + -17792;
	// 82869160: 41820024  beq 0x82869184
	if ctx.cr[0].eq {
	pc = 0x82869184; continue 'dispatch;
	}
	// 82869164: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82869168: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8286916C: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 82869170: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82869174: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82869178: 4BFFEE39  bl 0x82867fb0
	ctx.lr = 0x8286917C;
	sub_82867FB0(ctx, base);
	// 8286917C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82869180: 48000008  b 0x82869188
	pc = 0x82869188; continue 'dispatch;
	// 82869184: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82869188: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8286918C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82869190: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82869194: 4BFFD8BD  bl 0x82866a50
	ctx.lr = 0x82869198;
	sub_82866A50(ctx, base);
	// 82869198: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8286919C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828691A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828691A4: 4BA56E5D  bl 0x822c0000
	ctx.lr = 0x828691A8;
	sub_822C0000(ctx, base);
	// 828691A8: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828691AC: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828691B0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828691B4: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 828691B8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828691BC: 419A0024  beq cr6, 0x828691e0
	if ctx.cr[6].eq {
	pc = 0x828691E0; continue 'dispatch;
	}
	// 828691C0: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 828691C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828691C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828691CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828691D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828691D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828691D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828691DC: 4082FFE8  bne 0x828691c4
	if !ctx.cr[0].eq {
	pc = 0x828691C4; continue 'dispatch;
	}
	// 828691E0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828691E4: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 828691E8: 409A0008  bne cr6, 0x828691f0
	if !ctx.cr[6].eq {
	pc = 0x828691F0; continue 'dispatch;
	}
	// 828691EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828691F0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828691F4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828691F8: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 828691FC: 419A0024  beq cr6, 0x82869220
	if ctx.cr[6].eq {
	pc = 0x82869220; continue 'dispatch;
	}
	// 82869200: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 82869204: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82869208: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286920C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82869210: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82869214: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82869218: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286921C: 4082FFE8  bne 0x82869204
	if !ctx.cr[0].eq {
	pc = 0x82869204; continue 'dispatch;
	}
	// 82869220: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82869224: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82869228: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8286922C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82869230: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82869234: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82869238: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8286923C: 4BF2FCF5  bl 0x82798f30
	ctx.lr = 0x82869240;
	sub_82798F30(ctx, base);
	// 82869240: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82869244: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 82869248: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286924C: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 82869250: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82869254: 4E800421  bctrl
	ctx.lr = 0x82869258;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82869258: C0030010  lfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8286925C: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82869260: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82869264: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82869268: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 8286926C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82869270: 4E800421  bctrl
	ctx.lr = 0x82869274;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82869274: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82869278: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8286927C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82869280: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82869284: 38A00426  li r5, 0x426
	ctx.r[5].s64 = 1062;
	// 82869288: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8286928C: 4BA5714D  bl 0x822c03d8
	ctx.lr = 0x82869290;
	sub_822C03D8(ctx, base);
	// 82869290: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82869294: 41820014  beq 0x828692a8
	if ctx.cr[0].eq {
	pc = 0x828692A8; continue 'dispatch;
	}
	// 82869298: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8286929C: 4BF323CD  bl 0x8279b668
	ctx.lr = 0x828692A0;
	sub_8279B668(ctx, base);
	// 828692A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828692A4: 48000008  b 0x828692ac
	pc = 0x828692AC; continue 'dispatch;
	// 828692A8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828692AC: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828692B0: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 828692B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828692B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828692BC: 4BD2E995  bl 0x82597c50
	ctx.lr = 0x828692C0;
	sub_82597C50(ctx, base);
	// 828692C0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828692C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828692C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828692CC: 4BA56D35  bl 0x822c0000
	ctx.lr = 0x828692D0;
	sub_822C0000(ctx, base);
	// 828692D0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828692D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828692D8: 419A0008  beq cr6, 0x828692e0
	if ctx.cr[6].eq {
	pc = 0x828692E0; continue 'dispatch;
	}
	// 828692DC: 4BA575B5  bl 0x822c0890
	ctx.lr = 0x828692E0;
	sub_822C0890(ctx, base);
	// 828692E0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828692E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828692E8: 419A0008  beq cr6, 0x828692f0
	if ctx.cr[6].eq {
	pc = 0x828692F0; continue 'dispatch;
	}
	// 828692EC: 4BA575A5  bl 0x822c0890
	ctx.lr = 0x828692F0;
	sub_822C0890(ctx, base);
	// 828692F0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828692F4: 419A000C  beq cr6, 0x82869300
	if ctx.cr[6].eq {
	pc = 0x82869300; continue 'dispatch;
	}
	// 828692F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828692FC: 4BA57595  bl 0x822c0890
	ctx.lr = 0x82869300;
	sub_822C0890(ctx, base);
	// 82869300: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82869304: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82869308: 4893EEA8  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82869310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82869310 size=484
    let mut pc: u32 = 0x82869310;
    'dispatch: loop {
        match pc {
            0x82869310 => {
    //   block [0x82869310..0x828694F4)
	// 82869310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82869314: 4893EE4D  bl 0x831a8160
	ctx.lr = 0x82869318;
	sub_831A8130(ctx, base);
	// 82869318: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286931C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82869320: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82869324: 3BAB11F0  addi r29, r11, 0x11f0
	ctx.r[29].s64 = ctx.r[11].s64 + 4592;
	// 82869328: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8286932C: 38A00472  li r5, 0x472
	ctx.r[5].s64 = 1138;
	// 82869330: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82869334: 386003A0  li r3, 0x3a0
	ctx.r[3].s64 = 928;
	// 82869338: 485890B1  bl 0x82df23e8
	ctx.lr = 0x8286933C;
	sub_82DF23E8(ctx, base);
	// 8286933C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82869340: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82869344: 3B8BBA80  addi r28, r11, -0x4580
	ctx.r[28].s64 = ctx.r[11].s64 + -17792;
	// 82869348: 41820024  beq 0x8286936c
	if ctx.cr[0].eq {
	pc = 0x8286936C; continue 'dispatch;
	}
	// 8286934C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82869350: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82869354: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 82869358: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8286935C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82869360: 4BFFEDB9  bl 0x82868118
	ctx.lr = 0x82869364;
	sub_82868118(ctx, base);
	// 82869364: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82869368: 48000008  b 0x82869370
	pc = 0x82869370; continue 'dispatch;
	// 8286936C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82869370: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82869374: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82869378: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8286937C: 4BFFD79D  bl 0x82866b18
	ctx.lr = 0x82869380;
	sub_82866B18(ctx, base);
	// 82869380: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82869384: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82869388: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8286938C: 4BA56C75  bl 0x822c0000
	ctx.lr = 0x82869390;
	sub_822C0000(ctx, base);
	// 82869390: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82869394: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82869398: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8286939C: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 828693A0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828693A4: 419A0024  beq cr6, 0x828693c8
	if ctx.cr[6].eq {
	pc = 0x828693C8; continue 'dispatch;
	}
	// 828693A8: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 828693AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828693B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828693B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828693B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828693BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828693C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828693C4: 4082FFE8  bne 0x828693ac
	if !ctx.cr[0].eq {
	pc = 0x828693AC; continue 'dispatch;
	}
	// 828693C8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828693CC: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 828693D0: 409A0008  bne cr6, 0x828693d8
	if !ctx.cr[6].eq {
	pc = 0x828693D8; continue 'dispatch;
	}
	// 828693D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828693D8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828693DC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828693E0: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 828693E4: 419A0024  beq cr6, 0x82869408
	if ctx.cr[6].eq {
	pc = 0x82869408; continue 'dispatch;
	}
	// 828693E8: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 828693EC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828693F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828693F4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828693F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828693FC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82869400: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82869404: 4082FFE8  bne 0x828693ec
	if !ctx.cr[0].eq {
	pc = 0x828693EC; continue 'dispatch;
	}
	// 82869408: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8286940C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82869410: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82869414: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82869418: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8286941C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82869420: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82869424: 4BF2FB0D  bl 0x82798f30
	ctx.lr = 0x82869428;
	sub_82798F30(ctx, base);
	// 82869428: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 8286942C: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 82869430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82869434: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 82869438: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8286943C: 4E800421  bctrl
	ctx.lr = 0x82869440;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82869440: C0030010  lfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82869444: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82869448: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 8286944C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82869450: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 82869454: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82869458: 4E800421  bctrl
	ctx.lr = 0x8286945C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286945C: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82869460: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82869464: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82869468: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8286946C: 38A00477  li r5, 0x477
	ctx.r[5].s64 = 1143;
	// 82869470: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82869474: 4BA56F65  bl 0x822c03d8
	ctx.lr = 0x82869478;
	sub_822C03D8(ctx, base);
	// 82869478: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8286947C: 41820014  beq 0x82869490
	if ctx.cr[0].eq {
	pc = 0x82869490; continue 'dispatch;
	}
	// 82869480: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82869484: 4BF321E5  bl 0x8279b668
	ctx.lr = 0x82869488;
	sub_8279B668(ctx, base);
	// 82869488: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286948C: 48000008  b 0x82869494
	pc = 0x82869494; continue 'dispatch;
	// 82869490: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82869494: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82869498: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 8286949C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828694A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828694A4: 4BD2E7AD  bl 0x82597c50
	ctx.lr = 0x828694A8;
	sub_82597C50(ctx, base);
	// 828694A8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828694AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828694B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828694B4: 4BA56B4D  bl 0x822c0000
	ctx.lr = 0x828694B8;
	sub_822C0000(ctx, base);
	// 828694B8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828694BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828694C0: 419A0008  beq cr6, 0x828694c8
	if ctx.cr[6].eq {
	pc = 0x828694C8; continue 'dispatch;
	}
	// 828694C4: 4BA573CD  bl 0x822c0890
	ctx.lr = 0x828694C8;
	sub_822C0890(ctx, base);
	// 828694C8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828694CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828694D0: 419A0008  beq cr6, 0x828694d8
	if ctx.cr[6].eq {
	pc = 0x828694D8; continue 'dispatch;
	}
	// 828694D4: 4BA573BD  bl 0x822c0890
	ctx.lr = 0x828694D8;
	sub_822C0890(ctx, base);
	// 828694D8: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828694DC: 419A000C  beq cr6, 0x828694e8
	if ctx.cr[6].eq {
	pc = 0x828694E8; continue 'dispatch;
	}
	// 828694E0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828694E4: 4BA573AD  bl 0x822c0890
	ctx.lr = 0x828694E8;
	sub_822C0890(ctx, base);
	// 828694E8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828694EC: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828694F0: 4893ECC0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828694F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828694F8 size=128
    let mut pc: u32 = 0x828694F8;
    'dispatch: loop {
        match pc {
            0x828694F8 => {
    //   block [0x828694F8..0x82869578)
	// 828694F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828694FC: 4893EC71  bl 0x831a816c
	ctx.lr = 0x82869500;
	sub_831A8130(ctx, base);
	// 82869500: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82869504: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82869508: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8286950C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82869510: 3BEBBA30  addi r31, r11, -0x45d0
	ctx.r[31].s64 = ctx.r[11].s64 + -17872;
	// 82869514: 816ABA38  lwz r11, -0x45c8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) } as u64;
	// 82869518: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8286951C: 40820024  bne 0x82869540
	if !ctx.cr[0].eq {
	pc = 0x82869540; continue 'dispatch;
	}
	// 82869520: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 82869524: 3D008286  lis r8, -0x7d7a
	ctx.r[8].s64 = -2105147392;
	// 82869528: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8286952C: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 82869530: 39087770  addi r8, r8, 0x7770
	ctx.r[8].s64 = ctx.r[8].s64 + 30576;
	// 82869534: 916ABA38  stw r11, -0x45c8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17864 as u32), ctx.r[11].u32 ) };
	// 82869538: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8286953C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82869540: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82869544: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82869548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286954C: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82869550: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82869554: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82869558: 4BDEB069  bl 0x826545c0
	ctx.lr = 0x8286955C;
	sub_826545C0(ctx, base);
	// 8286955C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82869560: 4182000C  beq 0x8286956c
	if ctx.cr[0].eq {
	pc = 0x8286956C; continue 'dispatch;
	}
	// 82869564: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82869568: 48000008  b 0x82869570
	pc = 0x82869570; continue 'dispatch;
	// 8286956C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82869570: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82869574: 4893EC48  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82869578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82869578 size=92
    let mut pc: u32 = 0x82869578;
    'dispatch: loop {
        match pc {
            0x82869578 => {
    //   block [0x82869578..0x828695D4)
	// 82869578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286957C: 4893EBF1  bl 0x831a816c
	ctx.lr = 0x82869580;
	sub_831A8130(ctx, base);
	// 82869580: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82869584: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82869588: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286958C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82869590: 2B1E0002  cmplwi cr6, r30, 2
	ctx.cr[6].compare_u32(ctx.r[30].u32, 2 as u32, &mut ctx.xer);
	// 82869594: 41980008  blt cr6, 0x8286959c
	if ctx.cr[6].lt {
	pc = 0x8286959C; continue 'dispatch;
	}
	// 82869598: 4BAB7271  bl 0x82320808
	ctx.lr = 0x8286959C;
	sub_82320808(ctx, base);
	// 8286959C: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828695A0: 57CBE8FA  rlwinm r11, r30, 0x1d, 3, 0x1d
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000007u64;
	// 828695A4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 828695A8: 57CA06FE  clrlwi r10, r30, 0x1b
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x0000001Fu64;
	// 828695AC: 7D2A5030  slw r10, r9, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[9].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 828695B0: 7D2BF82E  lwzx r9, r11, r31
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 828695B4: 4182000C  beq 0x828695c0
	if ctx.cr[0].eq {
	pc = 0x828695C0; continue 'dispatch;
	}
	// 828695B8: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 828695BC: 48000008  b 0x828695c4
	pc = 0x828695C4; continue 'dispatch;
	// 828695C0: 7D2A5078  andc r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 & !ctx.r[10].u64;
	// 828695C4: 7D4BF92E  stwx r10, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[10].u32) };
	// 828695C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828695CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828695D0: 4893EBEC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828695D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828695D8 size=100
    let mut pc: u32 = 0x828695D8;
    'dispatch: loop {
        match pc {
            0x828695D8 => {
    //   block [0x828695D8..0x8286963C)
	// 828695D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828695DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828695E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828695E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828695E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828695EC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828695F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828695F4: 2B1F0002  cmplwi cr6, r31, 2
	ctx.cr[6].compare_u32(ctx.r[31].u32, 2 as u32, &mut ctx.xer);
	// 828695F8: 41980008  blt cr6, 0x82869600
	if ctx.cr[6].lt {
	pc = 0x82869600; continue 'dispatch;
	}
	// 828695FC: 4BAB720D  bl 0x82320808
	ctx.lr = 0x82869600;
	sub_82320808(ctx, base);
	// 82869600: 57EBE8FA  rlwinm r11, r31, 0x1d, 3, 0x1d
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000007u64;
	// 82869604: 57EA06FE  clrlwi r10, r31, 0x1b
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x0000001Fu64;
	// 82869608: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8286960C: 7D2A5030  slw r10, r9, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[9].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 82869610: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82869614: 7D4B5838  and r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 & ctx.r[11].u64;
	// 82869618: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8286961C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82869620: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82869624: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82869628: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286962C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82869630: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82869634: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82869638: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82869640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82869640 size=128
    let mut pc: u32 = 0x82869640;
    'dispatch: loop {
        match pc {
            0x82869640 => {
    //   block [0x82869640..0x828696C0)
	// 82869640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82869644: 4893EB29  bl 0x831a816c
	ctx.lr = 0x82869648;
	sub_831A8130(ctx, base);
	// 82869648: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286964C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82869650: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82869654: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82869658: 3BEBBA3C  addi r31, r11, -0x45c4
	ctx.r[31].s64 = ctx.r[11].s64 + -17860;
	// 8286965C: 816ABA44  lwz r11, -0x45bc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17852 as u32) ) } as u64;
	// 82869660: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82869664: 40820024  bne 0x82869688
	if !ctx.cr[0].eq {
	pc = 0x82869688; continue 'dispatch;
	}
	// 82869668: 3D20828F  lis r9, -0x7d71
	ctx.r[9].s64 = -2104557568;
	// 8286966C: 3D008286  lis r8, -0x7d7a
	ctx.r[8].s64 = -2105147392;
	// 82869670: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82869674: 39294708  addi r9, r9, 0x4708
	ctx.r[9].s64 = ctx.r[9].s64 + 18184;
	// 82869678: 39087728  addi r8, r8, 0x7728
	ctx.r[8].s64 = ctx.r[8].s64 + 30504;
	// 8286967C: 916ABA44  stw r11, -0x45bc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17852 as u32), ctx.r[11].u32 ) };
	// 82869680: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82869684: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82869688: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8286968C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82869690: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82869694: 38FE0008  addi r7, r30, 8
	ctx.r[7].s64 = ctx.r[30].s64 + 8;
	// 82869698: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 8286969C: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828696A0: 4807A331  bl 0x828e39d0
	ctx.lr = 0x828696A4;
	sub_828E39D0(ctx, base);
	// 828696A4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828696A8: 4182000C  beq 0x828696b4
	if ctx.cr[0].eq {
	pc = 0x828696B4; continue 'dispatch;
	}
	// 828696AC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828696B0: 48000008  b 0x828696b8
	pc = 0x828696B8; continue 'dispatch;
	// 828696B4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828696B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828696BC: 4893EB00  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828696C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828696C0 size=240
    let mut pc: u32 = 0x828696C0;
    'dispatch: loop {
        match pc {
            0x828696C0 => {
    //   block [0x828696C0..0x828697B0)
	// 828696C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828696C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828696C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828696CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828696D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828696D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828696D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828696DC: 2F050005  cmpwi cr6, r5, 5
	ctx.cr[6].compare_i32(ctx.r[5].s32, 5, &mut ctx.xer);
	// 828696E0: 419A0094  beq cr6, 0x82869774
	if ctx.cr[6].eq {
	pc = 0x82869774; continue 'dispatch;
	}
	// 828696E4: 2F050006  cmpwi cr6, r5, 6
	ctx.cr[6].compare_i32(ctx.r[5].s32, 6, &mut ctx.xer);
	// 828696E8: 419A0044  beq cr6, 0x8286972c
	if ctx.cr[6].eq {
	pc = 0x8286972C; continue 'dispatch;
	}
	// 828696EC: 2F050007  cmpwi cr6, r5, 7
	ctx.cr[6].compare_i32(ctx.r[5].s32, 7, &mut ctx.xer);
	// 828696F0: 419A0030  beq cr6, 0x82869720
	if ctx.cr[6].eq {
	pc = 0x82869720; continue 'dispatch;
	}
	// 828696F4: 2F050008  cmpwi cr6, r5, 8
	ctx.cr[6].compare_i32(ctx.r[5].s32, 8, &mut ctx.xer);
	// 828696F8: 409A006C  bne cr6, 0x82869764
	if !ctx.cr[6].eq {
	pc = 0x82869764; continue 'dispatch;
	}
	// 828696FC: 817F037C  lwz r11, 0x37c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(892 as u32) ) } as u64;
	// 82869700: 556BFFFF  rlwinm. r11, r11, 0x1f, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82869704: 40820060  bne 0x82869764
	if !ctx.cr[0].eq {
	pc = 0x82869764; continue 'dispatch;
	}
	// 82869708: 817F037C  lwz r11, 0x37c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(892 as u32) ) } as u64;
	// 8286970C: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82869710: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 82869714: 38AA1344  addi r5, r10, 0x1344
	ctx.r[5].s64 = ctx.r[10].s64 + 4932;
	// 82869718: 917F037C  stw r11, 0x37c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), ctx.r[11].u32 ) };
	// 8286971C: 48000060  b 0x8286977c
	pc = 0x8286977C; continue 'dispatch;
	// 82869720: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82869724: 38AA1330  addi r5, r10, 0x1330
	ctx.r[5].s64 = ctx.r[10].s64 + 4912;
	// 82869728: 48000054  b 0x8286977c
	pc = 0x8286977C; continue 'dispatch;
	// 8286972C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82869730: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869734: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82869738: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8286973C: 816A0080  lwz r11, 0x80(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 82869740: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82869744: 4E800421  bctrl
	ctx.lr = 0x82869748;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82869748: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8286974C: C00B9450  lfs f0, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82869750: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82869754: 40980010  bge cr6, 0x82869764
	if !ctx.cr[6].lt {
	pc = 0x82869764; continue 'dispatch;
	}
	// 82869758: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8286975C: 38AA131C  addi r5, r10, 0x131c
	ctx.r[5].s64 = ctx.r[10].s64 + 4892;
	// 82869760: 4800001C  b 0x8286977c
	pc = 0x8286977C; continue 'dispatch;
	// 82869764: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82869768: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8286976C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82869770: 48000024  b 0x82869794
	pc = 0x82869794; continue 'dispatch;
	// 82869774: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82869778: 38AA130C  addi r5, r10, 0x130c
	ctx.r[5].s64 = ctx.r[10].s64 + 4876;
	// 8286977C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869780: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82869784: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82869788: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8286978C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82869790: 4E800421  bctrl
	ctx.lr = 0x82869794;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82869794: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82869798: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286979C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828697A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828697A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828697A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828697AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828697B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828697B0 size=6000
    let mut pc: u32 = 0x828697B0;
    'dispatch: loop {
        match pc {
            0x828697B0 => {
    //   block [0x828697B0..0x8286AF20)
	// 828697B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828697B4: 4893E985  bl 0x831a8138
	ctx.lr = 0x828697B8;
	sub_831A8130(ctx, base);
	// 828697B8: DBE1FF70  stfd f31, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[31].u64 ) };
	// 828697BC: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828697C0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828697C4: 7C932378  mr r19, r4
	ctx.r[19].u64 = ctx.r[4].u64;
	// 828697C8: 7CB22B78  mr r18, r5
	ctx.r[18].u64 = ctx.r[5].u64;
	// 828697CC: 7CD43378  mr r20, r6
	ctx.r[20].u64 = ctx.r[6].u64;
	// 828697D0: 480A75C1  bl 0x82910d90
	ctx.lr = 0x828697D4;
	sub_82910D90(ctx, base);
	// 828697D4: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828697D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828697DC: 4BCA5B95  bl 0x8250f370
	ctx.lr = 0x828697E0;
	sub_8250F370(ctx, base);
	// 828697E0: 363CFFF0  addic. r17, r28, -0x10
	ctx.xer.ca = (ctx.r[28].u32 > (!(-16 as u32)));
	ctx.r[17].s64 = ctx.r[28].s64 + -16;
	ctx.cr[0].compare_i32(ctx.r[17].s32, 0, &mut ctx.xer);
	// 828697E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828697E8: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 828697EC: 40820008  bne 0x828697f4
	if !ctx.cr[0].eq {
	pc = 0x828697F4; continue 'dispatch;
	}
	// 828697F0: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 828697F4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828697F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828697FC: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82869800: 4858A209  bl 0x82df3a08
	ctx.lr = 0x82869804;
	sub_82DF3A08(ctx, base);
	// 82869804: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82869808: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286980C: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 82869810: 4BC9EF71  bl 0x82508780
	ctx.lr = 0x82869814;
	sub_82508780(ctx, base);
	// 82869814: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869818: 48589C11  bl 0x82df3428
	ctx.lr = 0x8286981C;
	sub_82DF3428(ctx, base);
	// 8286981C: 2B110000  cmplwi cr6, r17, 0
	ctx.cr[6].compare_u32(ctx.r[17].u32, 0 as u32, &mut ctx.xer);
	// 82869820: 389C0028  addi r4, r28, 0x28
	ctx.r[4].s64 = ctx.r[28].s64 + 40;
	// 82869824: 409A0008  bne cr6, 0x8286982c
	if !ctx.cr[6].eq {
	pc = 0x8286982C; continue 'dispatch;
	}
	// 82869828: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8286982C: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 82869830: 4BC9EF71  bl 0x825087a0
	ctx.lr = 0x82869834;
	sub_825087A0(ctx, base);
	// 82869834: 817CFFF0  lwz r11, -0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82869838: 3B7CFFF0  addi r27, r28, -0x10
	ctx.r[27].s64 = ctx.r[28].s64 + -16;
	// 8286983C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82869840: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82869844: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82869848: 4E800421  bctrl
	ctx.lr = 0x8286984C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286984C: 817C02E0  lwz r11, 0x2e0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(736 as u32) ) } as u64;
	// 82869850: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82869854: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82869858: 409A0018  bne cr6, 0x82869870
	if !ctx.cr[6].eq {
	pc = 0x82869870; continue 'dispatch;
	}
	// 8286985C: 817C0378  lwz r11, 0x378(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(888 as u32) ) } as u64;
	// 82869860: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869864: 915C0380  stw r10, 0x380(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(896 as u32), ctx.r[10].u32 ) };
	// 82869868: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286986C: 917C0384  stw r11, 0x384(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(900 as u32), ctx.r[11].u32 ) };
	// 82869870: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869874: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82869878: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 8286987C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82869880: 4E800421  bctrl
	ctx.lr = 0x82869884;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82869884: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82869888: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286988C: 4858A17D  bl 0x82df3a08
	ctx.lr = 0x82869890;
	sub_82DF3A08(ctx, base);
	// 82869890: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82869894: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82869898: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8286989C: 480A6D65  bl 0x82910600
	ctx.lr = 0x828698A0;
	sub_82910600(ctx, base);
	// 828698A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828698A4: 48589B85  bl 0x82df3428
	ctx.lr = 0x828698A8;
	sub_82DF3428(ctx, base);
	// 828698A8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828698AC: 480A7015  bl 0x829108c0
	ctx.lr = 0x828698B0;
	sub_829108C0(ctx, base);
	// 828698B0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828698B4: 41820010  beq 0x828698c4
	if ctx.cr[0].eq {
	pc = 0x828698C4; continue 'dispatch;
	}
	// 828698B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828698BC: 4BCA6D15  bl 0x825105d0
	ctx.lr = 0x828698C0;
	sub_825105D0(ctx, base);
	// 828698C0: 48001654  b 0x8286af14
	pc = 0x8286AF14; continue 'dispatch;
	// 828698C4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828698C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828698CC: 3AAB11F0  addi r21, r11, 0x11f0
	ctx.r[21].s64 = ctx.r[11].s64 + 4592;
	// 828698D0: 38A000B8  li r5, 0xb8
	ctx.r[5].s64 = 184;
	// 828698D4: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828698D8: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828698DC: 4BA56AFD  bl 0x822c03d8
	ctx.lr = 0x828698E0;
	sub_822C03D8(ctx, base);
	// 828698E0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828698E4: 41820020  beq 0x82869904
	if ctx.cr[0].eq {
	pc = 0x82869904; continue 'dispatch;
	}
	// 828698E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828698EC: 4BF813C5  bl 0x827eacb0
	ctx.lr = 0x828698F0;
	sub_827EACB0(ctx, base);
	// 828698F0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828698F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828698F8: 396B09D8  addi r11, r11, 0x9d8
	ctx.r[11].s64 = ctx.r[11].s64 + 2520;
	// 828698FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82869900: 48000008  b 0x82869908
	pc = 0x82869908; continue 'dispatch;
	// 82869904: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82869908: 3BDC01CC  addi r30, r28, 0x1cc
	ctx.r[30].s64 = ctx.r[28].s64 + 460;
	// 8286990C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82869910: 4BFFE971  bl 0x82868280
	ctx.lr = 0x82869914;
	sub_82868280(ctx, base);
	// 82869914: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82869918: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286991C: 808B5E00  lwz r4, 0x5e00(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24064 as u32) ) } as u64;
	// 82869920: 4858A0E9  bl 0x82df3a08
	ctx.lr = 0x82869924;
	sub_82DF3A08(ctx, base);
	// 82869924: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82869928: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8286992C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82869930: 3AEBBA50  addi r23, r11, -0x45b0
	ctx.r[23].s64 = ctx.r[11].s64 + -17840;
	// 82869934: 3B410050  addi r26, r1, 0x50
	ctx.r[26].s64 = ctx.r[1].s64 + 80;
	// 82869938: 833C01CC  lwz r25, 0x1cc(r28)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(460 as u32) ) } as u64;
	// 8286993C: C3EBBA50  lfs f31, -0x45b0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17840 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82869940: 4BCA5B89  bl 0x8250f4c8
	ctx.lr = 0x82869944;
	sub_8250F4C8(ctx, base);
	// 82869944: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82869948: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8286994C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869950: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82869954: 4BF81015  bl 0x827ea968
	ctx.lr = 0x82869958;
	sub_827EA968(ctx, base);
	// 82869958: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8286995C: 48588335  bl 0x82df1c90
	ctx.lr = 0x82869960;
	sub_82DF1C90(ctx, base);
	// 82869960: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869964: 48589AC5  bl 0x82df3428
	ctx.lr = 0x82869968;
	sub_82DF3428(ctx, base);
	// 82869968: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8286996C: 3D40832B  lis r10, -0x7cd5
	ctx.r[10].s64 = -2094333952;
	// 82869970: 807C01CC  lwz r3, 0x1cc(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(460 as u32) ) } as u64;
	// 82869974: 388A5E08  addi r4, r10, 0x5e08
	ctx.r[4].s64 = ctx.r[10].s64 + 24072;
	// 82869978: 80AB14A0  lwz r5, 0x14a0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5280 as u32) ) } as u64;
	// 8286997C: 4BF80D45  bl 0x827ea6c0
	ctx.lr = 0x82869980;
	sub_827EA6C0(ctx, base);
	// 82869980: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82869984: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82869988: 4BF82C41  bl 0x827ec5c8
	ctx.lr = 0x8286998C;
	sub_827EC5C8(ctx, base);
	// 8286998C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82869990: 807C01CC  lwz r3, 0x1cc(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(460 as u32) ) } as u64;
	// 82869994: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869998: 4BF80D31  bl 0x827ea6c8
	ctx.lr = 0x8286999C;
	sub_827EA6C8(ctx, base);
	// 8286999C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828699A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828699A4: 419A0008  beq cr6, 0x828699ac
	if ctx.cr[6].eq {
	pc = 0x828699AC; continue 'dispatch;
	}
	// 828699A8: 4BA56EE9  bl 0x822c0890
	ctx.lr = 0x828699AC;
	sub_822C0890(ctx, base);
	// 828699AC: 3F40832B  lis r26, -0x7cd5
	ctx.r[26].s64 = -2094333952;
	// 828699B0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828699B4: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 828699B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828699BC: 396B6930  addi r11, r11, 0x6930
	ctx.r[11].s64 = ctx.r[11].s64 + 26928;
	// 828699C0: 809A67FC  lwz r4, 0x67fc(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(26620 as u32) ) } as u64;
	// 828699C4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828699C8: 4858A041  bl 0x82df3a08
	ctx.lr = 0x828699CC;
	sub_82DF3A08(ctx, base);
	// 828699CC: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 828699D0: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828699D4: C01D0048  lfs f0, 0x48(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828699D8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828699DC: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 828699E0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828699E4: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828699E8: 99610060  stb r11, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 828699EC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828699F0: 914100AC  stw r10, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[10].u32 ) };
	// 828699F4: 936100A8  stw r27, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[27].u32 ) };
	// 828699F8: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 828699FC: E8C100B0  ld r6, 0xb0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82869A00: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 82869A04: 93E100C0  stw r31, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[31].u32 ) };
	// 82869A08: 4BFFFC39  bl 0x82869640
	ctx.lr = 0x82869A0C;
	sub_82869640(ctx, base);
	// 82869A0C: 38C100C0  addi r6, r1, 0xc0
	ctx.r[6].s64 = ctx.r[1].s64 + 192;
	// 82869A10: C03D0050  lfs f1, 0x50(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82869A14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869A18: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869A1C: 4BF80D95  bl 0x827ea7b0
	ctx.lr = 0x82869A20;
	sub_827EA7B0(ctx, base);
	// 82869A20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869A24: 48589A05  bl 0x82df3428
	ctx.lr = 0x82869A28;
	sub_82DF3428(ctx, base);
	// 82869A28: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 82869A2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869A30: 809A67FC  lwz r4, 0x67fc(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(26620 as u32) ) } as u64;
	// 82869A34: 396B6930  addi r11, r11, 0x6930
	ctx.r[11].s64 = ctx.r[11].s64 + 26928;
	// 82869A38: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82869A3C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82869A40: 48589FC9  bl 0x82df3a08
	ctx.lr = 0x82869A44;
	sub_82DF3A08(ctx, base);
	// 82869A44: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82869A48: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82869A4C: C01D004C  lfs f0, 0x4c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82869A50: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82869A54: 996100A8  stb r11, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u8 ) };
	// 82869A58: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82869A5C: 816100A8  lwz r11, 0xa8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 82869A60: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82869A64: 914100CC  stw r10, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[10].u32 ) };
	// 82869A68: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 82869A6C: 936100C8  stw r27, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[27].u32 ) };
	// 82869A70: E8C100D0  ld r6, 0xd0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	// 82869A74: E8A100C8  ld r5, 0xc8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	// 82869A78: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 82869A7C: 4BFFFBC5  bl 0x82869640
	ctx.lr = 0x82869A80;
	sub_82869640(ctx, base);
	// 82869A80: 38C100F0  addi r6, r1, 0xf0
	ctx.r[6].s64 = ctx.r[1].s64 + 240;
	// 82869A84: C03D0054  lfs f1, 0x54(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82869A88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869A8C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869A90: 4BF80D21  bl 0x827ea7b0
	ctx.lr = 0x82869A94;
	sub_827EA7B0(ctx, base);
	// 82869A94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869A98: 48589991  bl 0x82df3428
	ctx.lr = 0x82869A9C;
	sub_82DF3428(ctx, base);
	// 82869A9C: 3F20832B  lis r25, -0x7cd5
	ctx.r[25].s64 = -2094333952;
	// 82869AA0: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 82869AA4: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82869AA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869AAC: 396B6930  addi r11, r11, 0x6930
	ctx.r[11].s64 = ctx.r[11].s64 + 26928;
	// 82869AB0: 80996800  lwz r4, 0x6800(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(26624 as u32) ) } as u64;
	// 82869AB4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82869AB8: 48589F51  bl 0x82df3a08
	ctx.lr = 0x82869ABC;
	sub_82DF3A08(ctx, base);
	// 82869ABC: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 82869AC0: 996100A8  stb r11, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u8 ) };
	// 82869AC4: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82869AC8: C01D0064  lfs f0, 0x64(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82869ACC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82869AD0: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82869AD4: 914100CC  stw r10, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[10].u32 ) };
	// 82869AD8: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82869ADC: 816100A8  lwz r11, 0xa8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 82869AE0: 936100C8  stw r27, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[27].u32 ) };
	// 82869AE4: E8A100C8  ld r5, 0xc8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	// 82869AE8: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 82869AEC: E8C100D0  ld r6, 0xd0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	// 82869AF0: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 82869AF4: 4BFFFB4D  bl 0x82869640
	ctx.lr = 0x82869AF8;
	sub_82869640(ctx, base);
	// 82869AF8: 38C100F0  addi r6, r1, 0xf0
	ctx.r[6].s64 = ctx.r[1].s64 + 240;
	// 82869AFC: C03D006C  lfs f1, 0x6c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(108 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82869B00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869B04: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869B08: 4BF80CA9  bl 0x827ea7b0
	ctx.lr = 0x82869B0C;
	sub_827EA7B0(ctx, base);
	// 82869B0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869B10: 48589919  bl 0x82df3428
	ctx.lr = 0x82869B14;
	sub_82DF3428(ctx, base);
	// 82869B14: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 82869B18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869B1C: 80996800  lwz r4, 0x6800(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(26624 as u32) ) } as u64;
	// 82869B20: 396B6930  addi r11, r11, 0x6930
	ctx.r[11].s64 = ctx.r[11].s64 + 26928;
	// 82869B24: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82869B28: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82869B2C: 48589EDD  bl 0x82df3a08
	ctx.lr = 0x82869B30;
	sub_82DF3A08(ctx, base);
	// 82869B30: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82869B34: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82869B38: C01D0068  lfs f0, 0x68(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82869B3C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82869B40: 996100A8  stb r11, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u8 ) };
	// 82869B44: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82869B48: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82869B4C: 914100CC  stw r10, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[10].u32 ) };
	// 82869B50: 816100A8  lwz r11, 0xa8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 82869B54: 936100C8  stw r27, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[27].u32 ) };
	// 82869B58: E8A100C8  ld r5, 0xc8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	// 82869B5C: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 82869B60: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 82869B64: E8C100D0  ld r6, 0xd0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	// 82869B68: 4BFFFAD9  bl 0x82869640
	ctx.lr = 0x82869B6C;
	sub_82869640(ctx, base);
	// 82869B6C: 38C100F0  addi r6, r1, 0xf0
	ctx.r[6].s64 = ctx.r[1].s64 + 240;
	// 82869B70: C03D0070  lfs f1, 0x70(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(112 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82869B74: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869B78: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869B7C: 4BF80C35  bl 0x827ea7b0
	ctx.lr = 0x82869B80;
	sub_827EA7B0(ctx, base);
	// 82869B80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869B84: 485898A5  bl 0x82df3428
	ctx.lr = 0x82869B88;
	sub_82DF3428(ctx, base);
	// 82869B88: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82869B8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869B90: 388B1378  addi r4, r11, 0x1378
	ctx.r[4].s64 = ctx.r[11].s64 + 4984;
	// 82869B94: 48589E75  bl 0x82df3a08
	ctx.lr = 0x82869B98;
	sub_82DF3A08(ctx, base);
	// 82869B98: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82869B9C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82869BA0: 80940000  lwz r4, 0(r20)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869BA4: 480A7D7D  bl 0x82911920
	ctx.lr = 0x82869BA8;
	sub_82911920(ctx, base);
	// 82869BA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869BAC: 4858987D  bl 0x82df3428
	ctx.lr = 0x82869BB0;
	sub_82DF3428(ctx, base);
	// 82869BB0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82869BB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869BB8: 808B686C  lwz r4, 0x686c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26732 as u32) ) } as u64;
	// 82869BBC: 48589E4D  bl 0x82df3a08
	ctx.lr = 0x82869BC0;
	sub_82DF3A08(ctx, base);
	// 82869BC0: 3FA08201  lis r29, -0x7dff
	ctx.r[29].s64 = -2113863680;
	// 82869BC4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869BC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869BCC: C03D9450  lfs f1, -0x6bb0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82869BD0: 4BF80769  bl 0x827ea338
	ctx.lr = 0x82869BD4;
	sub_827EA338(ctx, base);
	// 82869BD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869BD8: 48589851  bl 0x82df3428
	ctx.lr = 0x82869BDC;
	sub_82DF3428(ctx, base);
	// 82869BDC: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82869BE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869BE4: 808B6878  lwz r4, 0x6878(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26744 as u32) ) } as u64;
	// 82869BE8: 48589E21  bl 0x82df3a08
	ctx.lr = 0x82869BEC;
	sub_82DF3A08(ctx, base);
	// 82869BEC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82869BF0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869BF4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869BF8: C02B0A90  lfs f1, 0xa90(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2704 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82869BFC: 4BF8073D  bl 0x827ea338
	ctx.lr = 0x82869C00;
	sub_827EA338(ctx, base);
	// 82869C00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869C04: 48589825  bl 0x82df3428
	ctx.lr = 0x82869C08;
	sub_82DF3428(ctx, base);
	// 82869C08: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82869C0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869C10: 808BF3FC  lwz r4, -0xc04(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3076 as u32) ) } as u64;
	// 82869C14: 48589DF5  bl 0x82df3a08
	ctx.lr = 0x82869C18;
	sub_82DF3A08(ctx, base);
	// 82869C18: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82869C1C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869C20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869C24: C3EB6150  lfs f31, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82869C28: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869C2C: 4BF8070D  bl 0x827ea338
	ctx.lr = 0x82869C30;
	sub_827EA338(ctx, base);
	// 82869C30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869C34: 485897F5  bl 0x82df3428
	ctx.lr = 0x82869C38;
	sub_82DF3428(ctx, base);
	// 82869C38: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82869C3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869C40: 808B6864  lwz r4, 0x6864(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26724 as u32) ) } as u64;
	// 82869C44: 48589DC5  bl 0x82df3a08
	ctx.lr = 0x82869C48;
	sub_82DF3A08(ctx, base);
	// 82869C48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869C4C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869C50: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869C54: 4BF806E5  bl 0x827ea338
	ctx.lr = 0x82869C58;
	sub_827EA338(ctx, base);
	// 82869C58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869C5C: 485897CD  bl 0x82df3428
	ctx.lr = 0x82869C60;
	sub_82DF3428(ctx, base);
	// 82869C60: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82869C64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869C68: 808B6870  lwz r4, 0x6870(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26736 as u32) ) } as u64;
	// 82869C6C: 48589D9D  bl 0x82df3a08
	ctx.lr = 0x82869C70;
	sub_82DF3A08(ctx, base);
	// 82869C70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869C74: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869C78: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869C7C: 4BF806BD  bl 0x827ea338
	ctx.lr = 0x82869C80;
	sub_827EA338(ctx, base);
	// 82869C80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869C84: 485897A5  bl 0x82df3428
	ctx.lr = 0x82869C88;
	sub_82DF3428(ctx, base);
	// 82869C88: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82869C8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869C90: 808B6874  lwz r4, 0x6874(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26740 as u32) ) } as u64;
	// 82869C94: 48589D75  bl 0x82df3a08
	ctx.lr = 0x82869C98;
	sub_82DF3A08(ctx, base);
	// 82869C98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869C9C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869CA0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869CA4: 4BF80695  bl 0x827ea338
	ctx.lr = 0x82869CA8;
	sub_827EA338(ctx, base);
	// 82869CA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869CAC: 4858977D  bl 0x82df3428
	ctx.lr = 0x82869CB0;
	sub_82DF3428(ctx, base);
	// 82869CB0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82869CB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869CB8: 808B6840  lwz r4, 0x6840(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26688 as u32) ) } as u64;
	// 82869CBC: 48589D4D  bl 0x82df3a08
	ctx.lr = 0x82869CC0;
	sub_82DF3A08(ctx, base);
	// 82869CC0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82869CC4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869CC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869CCC: 3B0B09C0  addi r24, r11, 0x9c0
	ctx.r[24].s64 = ctx.r[11].s64 + 2496;
	// 82869CD0: C3F80008  lfs f31, 8(r24)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82869CD4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869CD8: 4BF80661  bl 0x827ea338
	ctx.lr = 0x82869CDC;
	sub_827EA338(ctx, base);
	// 82869CDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869CE0: 48589749  bl 0x82df3428
	ctx.lr = 0x82869CE4;
	sub_82DF3428(ctx, base);
	// 82869CE4: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82869CE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869CEC: 808B6844  lwz r4, 0x6844(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26692 as u32) ) } as u64;
	// 82869CF0: 48589D19  bl 0x82df3a08
	ctx.lr = 0x82869CF4;
	sub_82DF3A08(ctx, base);
	// 82869CF4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869CF8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869CFC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869D00: 4BF80639  bl 0x827ea338
	ctx.lr = 0x82869D04;
	sub_827EA338(ctx, base);
	// 82869D04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869D08: 48589721  bl 0x82df3428
	ctx.lr = 0x82869D0C;
	sub_82DF3428(ctx, base);
	// 82869D0C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82869D10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869D14: 808B6848  lwz r4, 0x6848(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26696 as u32) ) } as u64;
	// 82869D18: 48589CF1  bl 0x82df3a08
	ctx.lr = 0x82869D1C;
	sub_82DF3A08(ctx, base);
	// 82869D1C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869D20: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869D24: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869D28: 4BF80611  bl 0x827ea338
	ctx.lr = 0x82869D2C;
	sub_827EA338(ctx, base);
	// 82869D2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869D30: 485896F9  bl 0x82df3428
	ctx.lr = 0x82869D34;
	sub_82DF3428(ctx, base);
	// 82869D34: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82869D38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869D3C: 808B684C  lwz r4, 0x684c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26700 as u32) ) } as u64;
	// 82869D40: 48589CC9  bl 0x82df3a08
	ctx.lr = 0x82869D44;
	sub_82DF3A08(ctx, base);
	// 82869D44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869D48: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869D4C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869D50: 4BF805E9  bl 0x827ea338
	ctx.lr = 0x82869D54;
	sub_827EA338(ctx, base);
	// 82869D54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869D58: 485896D1  bl 0x82df3428
	ctx.lr = 0x82869D5C;
	sub_82DF3428(ctx, base);
	// 82869D5C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82869D60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869D64: 808B6850  lwz r4, 0x6850(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26704 as u32) ) } as u64;
	// 82869D68: 48589CA1  bl 0x82df3a08
	ctx.lr = 0x82869D6C;
	sub_82DF3A08(ctx, base);
	// 82869D6C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869D70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869D74: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869D78: 4BF805C1  bl 0x827ea338
	ctx.lr = 0x82869D7C;
	sub_827EA338(ctx, base);
	// 82869D7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869D80: 485896A9  bl 0x82df3428
	ctx.lr = 0x82869D84;
	sub_82DF3428(ctx, base);
	// 82869D84: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82869D88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869D8C: 808B6854  lwz r4, 0x6854(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26708 as u32) ) } as u64;
	// 82869D90: 48589C79  bl 0x82df3a08
	ctx.lr = 0x82869D94;
	sub_82DF3A08(ctx, base);
	// 82869D94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869D98: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869D9C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869DA0: 4BF80599  bl 0x827ea338
	ctx.lr = 0x82869DA4;
	sub_827EA338(ctx, base);
	// 82869DA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869DA8: 48589681  bl 0x82df3428
	ctx.lr = 0x82869DAC;
	sub_82DF3428(ctx, base);
	// 82869DAC: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82869DB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869DB4: 808B6858  lwz r4, 0x6858(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26712 as u32) ) } as u64;
	// 82869DB8: 48589C51  bl 0x82df3a08
	ctx.lr = 0x82869DBC;
	sub_82DF3A08(ctx, base);
	// 82869DBC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869DC0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869DC4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869DC8: 4BF80571  bl 0x827ea338
	ctx.lr = 0x82869DCC;
	sub_827EA338(ctx, base);
	// 82869DCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869DD0: 48589659  bl 0x82df3428
	ctx.lr = 0x82869DD4;
	sub_82DF3428(ctx, base);
	// 82869DD4: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82869DD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869DDC: 808B685C  lwz r4, 0x685c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26716 as u32) ) } as u64;
	// 82869DE0: 48589C29  bl 0x82df3a08
	ctx.lr = 0x82869DE4;
	sub_82DF3A08(ctx, base);
	// 82869DE4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869DE8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869DEC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869DF0: 4BF80549  bl 0x827ea338
	ctx.lr = 0x82869DF4;
	sub_827EA338(ctx, base);
	// 82869DF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869DF8: 48589631  bl 0x82df3428
	ctx.lr = 0x82869DFC;
	sub_82DF3428(ctx, base);
	// 82869DFC: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82869E00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869E04: 808B6860  lwz r4, 0x6860(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26720 as u32) ) } as u64;
	// 82869E08: 48589C01  bl 0x82df3a08
	ctx.lr = 0x82869E0C;
	sub_82DF3A08(ctx, base);
	// 82869E0C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869E10: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869E14: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869E18: 4BF80521  bl 0x827ea338
	ctx.lr = 0x82869E1C;
	sub_827EA338(ctx, base);
	// 82869E1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869E20: 48589609  bl 0x82df3428
	ctx.lr = 0x82869E24;
	sub_82DF3428(ctx, base);
	// 82869E24: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82869E28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869E2C: 808B6818  lwz r4, 0x6818(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26648 as u32) ) } as u64;
	// 82869E30: 48589BD9  bl 0x82df3a08
	ctx.lr = 0x82869E34;
	sub_82DF3A08(ctx, base);
	// 82869E34: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869E38: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869E3C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869E40: 4BF804F9  bl 0x827ea338
	ctx.lr = 0x82869E44;
	sub_827EA338(ctx, base);
	// 82869E44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869E48: 485895E1  bl 0x82df3428
	ctx.lr = 0x82869E4C;
	sub_82DF3428(ctx, base);
	// 82869E4C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82869E50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869E54: 808B681C  lwz r4, 0x681c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26652 as u32) ) } as u64;
	// 82869E58: 48589BB1  bl 0x82df3a08
	ctx.lr = 0x82869E5C;
	sub_82DF3A08(ctx, base);
	// 82869E5C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869E60: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869E64: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869E68: 4BF804D1  bl 0x827ea338
	ctx.lr = 0x82869E6C;
	sub_827EA338(ctx, base);
	// 82869E6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869E70: 485895B9  bl 0x82df3428
	ctx.lr = 0x82869E74;
	sub_82DF3428(ctx, base);
	// 82869E74: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82869E78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869E7C: 808B6838  lwz r4, 0x6838(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26680 as u32) ) } as u64;
	// 82869E80: 48589B89  bl 0x82df3a08
	ctx.lr = 0x82869E84;
	sub_82DF3A08(ctx, base);
	// 82869E84: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869E88: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869E8C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869E90: 4BF804A9  bl 0x827ea338
	ctx.lr = 0x82869E94;
	sub_827EA338(ctx, base);
	// 82869E94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869E98: 48589591  bl 0x82df3428
	ctx.lr = 0x82869E9C;
	sub_82DF3428(ctx, base);
	// 82869E9C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82869EA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869EA4: 808BF460  lwz r4, -0xba0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2976 as u32) ) } as u64;
	// 82869EA8: 48589B61  bl 0x82df3a08
	ctx.lr = 0x82869EAC;
	sub_82DF3A08(ctx, base);
	// 82869EAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869EB0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869EB4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869EB8: 4BF80481  bl 0x827ea338
	ctx.lr = 0x82869EBC;
	sub_827EA338(ctx, base);
	// 82869EBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869EC0: 48589569  bl 0x82df3428
	ctx.lr = 0x82869EC4;
	sub_82DF3428(ctx, base);
	// 82869EC4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82869EC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869ECC: 808BF45C  lwz r4, -0xba4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2980 as u32) ) } as u64;
	// 82869ED0: 48589B39  bl 0x82df3a08
	ctx.lr = 0x82869ED4;
	sub_82DF3A08(ctx, base);
	// 82869ED4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869ED8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869EDC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869EE0: 4BF80459  bl 0x827ea338
	ctx.lr = 0x82869EE4;
	sub_827EA338(ctx, base);
	// 82869EE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869EE8: 48589541  bl 0x82df3428
	ctx.lr = 0x82869EEC;
	sub_82DF3428(ctx, base);
	// 82869EEC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82869EF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869EF4: 808BF464  lwz r4, -0xb9c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2972 as u32) ) } as u64;
	// 82869EF8: 48589B11  bl 0x82df3a08
	ctx.lr = 0x82869EFC;
	sub_82DF3A08(ctx, base);
	// 82869EFC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869F00: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869F04: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869F08: 4BF80431  bl 0x827ea338
	ctx.lr = 0x82869F0C;
	sub_827EA338(ctx, base);
	// 82869F0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869F10: 48589519  bl 0x82df3428
	ctx.lr = 0x82869F14;
	sub_82DF3428(ctx, base);
	// 82869F14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869F18: 809A67FC  lwz r4, 0x67fc(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(26620 as u32) ) } as u64;
	// 82869F1C: 48589AED  bl 0x82df3a08
	ctx.lr = 0x82869F20;
	sub_82DF3A08(ctx, base);
	// 82869F20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869F24: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869F28: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869F2C: 4BF8040D  bl 0x827ea338
	ctx.lr = 0x82869F30;
	sub_827EA338(ctx, base);
	// 82869F30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869F34: 485894F5  bl 0x82df3428
	ctx.lr = 0x82869F38;
	sub_82DF3428(ctx, base);
	// 82869F38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869F3C: 80996800  lwz r4, 0x6800(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(26624 as u32) ) } as u64;
	// 82869F40: 48589AC9  bl 0x82df3a08
	ctx.lr = 0x82869F44;
	sub_82DF3A08(ctx, base);
	// 82869F44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869F48: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869F4C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869F50: 4BF803E9  bl 0x827ea338
	ctx.lr = 0x82869F54;
	sub_827EA338(ctx, base);
	// 82869F54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869F58: 485894D1  bl 0x82df3428
	ctx.lr = 0x82869F5C;
	sub_82DF3428(ctx, base);
	// 82869F5C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82869F60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869F64: 808B6804  lwz r4, 0x6804(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26628 as u32) ) } as u64;
	// 82869F68: 48589AA1  bl 0x82df3a08
	ctx.lr = 0x82869F6C;
	sub_82DF3A08(ctx, base);
	// 82869F6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869F70: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869F74: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869F78: 4BF803C1  bl 0x827ea338
	ctx.lr = 0x82869F7C;
	sub_827EA338(ctx, base);
	// 82869F7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869F80: 485894A9  bl 0x82df3428
	ctx.lr = 0x82869F84;
	sub_82DF3428(ctx, base);
	// 82869F84: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82869F88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869F8C: 808B680C  lwz r4, 0x680c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26636 as u32) ) } as u64;
	// 82869F90: 48589A79  bl 0x82df3a08
	ctx.lr = 0x82869F94;
	sub_82DF3A08(ctx, base);
	// 82869F94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869F98: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869F9C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869FA0: 4BF80399  bl 0x827ea338
	ctx.lr = 0x82869FA4;
	sub_827EA338(ctx, base);
	// 82869FA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869FA8: 48589481  bl 0x82df3428
	ctx.lr = 0x82869FAC;
	sub_82DF3428(ctx, base);
	// 82869FAC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82869FB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869FB4: 808BF46C  lwz r4, -0xb94(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2964 as u32) ) } as u64;
	// 82869FB8: 48589A51  bl 0x82df3a08
	ctx.lr = 0x82869FBC;
	sub_82DF3A08(ctx, base);
	// 82869FBC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869FC0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869FC4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869FC8: 4BF80371  bl 0x827ea338
	ctx.lr = 0x82869FCC;
	sub_827EA338(ctx, base);
	// 82869FCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869FD0: 48589459  bl 0x82df3428
	ctx.lr = 0x82869FD4;
	sub_82DF3428(ctx, base);
	// 82869FD4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82869FD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869FDC: 808BF470  lwz r4, -0xb90(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2960 as u32) ) } as u64;
	// 82869FE0: 48589A29  bl 0x82df3a08
	ctx.lr = 0x82869FE4;
	sub_82DF3A08(ctx, base);
	// 82869FE4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82869FE8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82869FEC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82869FF0: 4BF80349  bl 0x827ea338
	ctx.lr = 0x82869FF4;
	sub_827EA338(ctx, base);
	// 82869FF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82869FF8: 48589431  bl 0x82df3428
	ctx.lr = 0x82869FFC;
	sub_82DF3428(ctx, base);
	// 82869FFC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A000: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A004: 808BF47C  lwz r4, -0xb84(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2948 as u32) ) } as u64;
	// 8286A008: 48589A01  bl 0x82df3a08
	ctx.lr = 0x8286A00C;
	sub_82DF3A08(ctx, base);
	// 8286A00C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286A010: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286A014: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8286A018: 4BF80321  bl 0x827ea338
	ctx.lr = 0x8286A01C;
	sub_827EA338(ctx, base);
	// 8286A01C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A020: 48589409  bl 0x82df3428
	ctx.lr = 0x8286A024;
	sub_82DF3428(ctx, base);
	// 8286A024: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A028: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A02C: 808BF468  lwz r4, -0xb98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2968 as u32) ) } as u64;
	// 8286A030: 485899D9  bl 0x82df3a08
	ctx.lr = 0x8286A034;
	sub_82DF3A08(ctx, base);
	// 8286A034: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286A038: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286A03C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8286A040: 4BF802F9  bl 0x827ea338
	ctx.lr = 0x8286A044;
	sub_827EA338(ctx, base);
	// 8286A044: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A048: 485893E1  bl 0x82df3428
	ctx.lr = 0x8286A04C;
	sub_82DF3428(ctx, base);
	// 8286A04C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A050: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A054: 808BF480  lwz r4, -0xb80(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2944 as u32) ) } as u64;
	// 8286A058: 485899B1  bl 0x82df3a08
	ctx.lr = 0x8286A05C;
	sub_82DF3A08(ctx, base);
	// 8286A05C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286A060: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286A064: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8286A068: 4BF802D1  bl 0x827ea338
	ctx.lr = 0x8286A06C;
	sub_827EA338(ctx, base);
	// 8286A06C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A070: 485893B9  bl 0x82df3428
	ctx.lr = 0x8286A074;
	sub_82DF3428(ctx, base);
	// 8286A074: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A078: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A07C: 808BF450  lwz r4, -0xbb0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2992 as u32) ) } as u64;
	// 8286A080: 48589989  bl 0x82df3a08
	ctx.lr = 0x8286A084;
	sub_82DF3A08(ctx, base);
	// 8286A084: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286A088: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286A08C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8286A090: 4BF802A9  bl 0x827ea338
	ctx.lr = 0x8286A094;
	sub_827EA338(ctx, base);
	// 8286A094: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A098: 48589391  bl 0x82df3428
	ctx.lr = 0x8286A09C;
	sub_82DF3428(ctx, base);
	// 8286A09C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A0A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A0A4: 808BF40C  lwz r4, -0xbf4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3060 as u32) ) } as u64;
	// 8286A0A8: 48589961  bl 0x82df3a08
	ctx.lr = 0x8286A0AC;
	sub_82DF3A08(ctx, base);
	// 8286A0AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286A0B0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286A0B4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8286A0B8: 4BF80281  bl 0x827ea338
	ctx.lr = 0x8286A0BC;
	sub_827EA338(ctx, base);
	// 8286A0BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A0C0: 48589369  bl 0x82df3428
	ctx.lr = 0x8286A0C4;
	sub_82DF3428(ctx, base);
	// 8286A0C4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A0C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A0CC: 808BF410  lwz r4, -0xbf0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3056 as u32) ) } as u64;
	// 8286A0D0: 48589939  bl 0x82df3a08
	ctx.lr = 0x8286A0D4;
	sub_82DF3A08(ctx, base);
	// 8286A0D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286A0D8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286A0DC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8286A0E0: 4BF80259  bl 0x827ea338
	ctx.lr = 0x8286A0E4;
	sub_827EA338(ctx, base);
	// 8286A0E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286A0E8: 48589341  bl 0x82df3428
	ctx.lr = 0x8286A0EC;
	sub_82DF3428(ctx, base);
	// 8286A0EC: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 8286A0F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8286A0F4: 38A000F7  li r5, 0xf7
	ctx.r[5].s64 = 247;
	// 8286A0F8: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 8286A0FC: 4BA562DD  bl 0x822c03d8
	ctx.lr = 0x8286A100;
	sub_822C03D8(ctx, base);
	// 8286A100: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8286A104: 41820020  beq 0x8286a124
	if ctx.cr[0].eq {
	pc = 0x8286A124; continue 'dispatch;
	}
	// 8286A108: 2B110000  cmplwi cr6, r17, 0
	ctx.cr[6].compare_u32(ctx.r[17].u32, 0 as u32, &mut ctx.xer);
	// 8286A10C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8286A110: 409A0008  bne cr6, 0x8286a118
	if !ctx.cr[6].eq {
	pc = 0x8286A118; continue 'dispatch;
	}
	// 8286A114: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8286A118: 480012E1  bl 0x8286b3f8
	ctx.lr = 0x8286A11C;
	sub_8286B3F8(ctx, base);
	// 8286A11C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A120: 48000008  b 0x8286a128
	pc = 0x8286A128; continue 'dispatch;
	// 8286A124: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8286A128: 3B5C00E4  addi r26, r28, 0xe4
	ctx.r[26].s64 = ctx.r[28].s64 + 228;
	// 8286A12C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8286A130: 4BFFE1C1  bl 0x828682f0
	ctx.lr = 0x8286A134;
	sub_828682F0(ctx, base);
	// 8286A134: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8286A138: 4BF82029  bl 0x827ec160
	ctx.lr = 0x8286A13C;
	sub_827EC160(ctx, base);
	// 8286A13C: 7C701B78  mr r16, r3
	ctx.r[16].u64 = ctx.r[3].u64;
	// 8286A140: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8286A144: 83300000  lwz r25, 0(r16)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286A148: 481A9539  bl 0x82a13680
	ctx.lr = 0x8286A14C;
	sub_82A13680(ctx, base);
	// 8286A14C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A150: 81790010  lwz r11, 0x10(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) } as u64;
	// 8286A154: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 8286A158: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8286A15C: 4E800421  bctrl
	ctx.lr = 0x8286A160;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286A160: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8286A164: 83300000  lwz r25, 0(r16)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286A168: 481A9521  bl 0x82a13688
	ctx.lr = 0x8286A16C;
	sub_82A13688(ctx, base);
	// 8286A16C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A170: 81790014  lwz r11, 0x14(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) } as u64;
	// 8286A174: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 8286A178: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8286A17C: 4E800421  bctrl
	ctx.lr = 0x8286A180;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286A180: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8286A184: 480B71F5  bl 0x82921378
	ctx.lr = 0x8286A188;
	sub_82921378(ctx, base);
	// 8286A188: C19D9450  lfs f12, -0x6bb0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8286A18C: C1B70000  lfs f13, 0(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8286A190: 81700000  lwz r11, 0(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286A194: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 8286A198: C018000C  lfs f0, 0xc(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8286A19C: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8286A1A0: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 8286A1A4: D1A100A0  stfs f13, 0xa0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8286A1A8: 93E100AC  stw r31, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[31].u32 ) };
	// 8286A1AC: 9AC100B2  stb r22, 0xb2(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(178 as u32), ctx.r[22].u8 ) };
	// 8286A1B0: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8286A1B4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8286A1B8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8286A1BC: D00100A4  stfs f0, 0xa4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8286A1C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8286A1C4: 4E800421  bctrl
	ctx.lr = 0x8286A1C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286A1C8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8286A1CC: 4BF863C5  bl 0x827f0590
	ctx.lr = 0x8286A1D0;
	sub_827F0590(ctx, base);
	// 8286A1D0: 81700000  lwz r11, 0(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286A1D4: C0170024  lfs f0, 0x24(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8286A1D8: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 8286A1DC: C1B70028  lfs f13, 0x28(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8286A1E0: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 8286A1E4: D00100C0  stfs f0, 0xc0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 8286A1E8: D1A100C4  stfs f13, 0xc4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8286A1EC: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 8286A1F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8286A1F4: 4E800421  bctrl
	ctx.lr = 0x8286A1F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286A1F8: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 8286A1FC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286A200: 4BFFE561  bl 0x82868760
	ctx.lr = 0x8286A204;
	sub_82868760(ctx, base);
	// 8286A204: 817C00FC  lwz r11, 0xfc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(252 as u32) ) } as u64;
	// 8286A208: 3BBC00FC  addi r29, r28, 0xfc
	ctx.r[29].s64 = ctx.r[28].s64 + 252;
	// 8286A20C: 809C00E4  lwz r4, 0xe4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(228 as u32) ) } as u64;
	// 8286A210: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A214: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286A218: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8286A21C: 4E800421  bctrl
	ctx.lr = 0x8286A220;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286A220: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A224: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8286A228: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A22C: 388B19B0  addi r4, r11, 0x19b0
	ctx.r[4].s64 = ctx.r[11].s64 + 6576;
	// 8286A230: 4BFFEDF9  bl 0x82869028
	ctx.lr = 0x8286A234;
	sub_82869028(ctx, base);
	// 8286A234: 3F20832D  lis r25, -0x7cd3
	ctx.r[25].s64 = -2094202880;
	// 8286A238: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A23C: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A240: 80990AF0  lwz r4, 0xaf0(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(2800 as u32) ) } as u64;
	// 8286A244: 485897C5  bl 0x82df3a08
	ctx.lr = 0x8286A248;
	sub_82DF3A08(ctx, base);
	// 8286A248: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A24C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A250: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A254: 485F1F05  bl 0x82e5c158
	ctx.lr = 0x8286A258;
	sub_82E5C158(ctx, base);
	// 8286A258: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A25C: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8286A260: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A264: 388B1A20  addi r4, r11, 0x1a20
	ctx.r[4].s64 = ctx.r[11].s64 + 6688;
	// 8286A268: 4BFFEDC1  bl 0x82869028
	ctx.lr = 0x8286A26C;
	sub_82869028(ctx, base);
	// 8286A26C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8286A270: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A274: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A278: 808B6884  lwz r4, 0x6884(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26756 as u32) ) } as u64;
	// 8286A27C: 4858978D  bl 0x82df3a08
	ctx.lr = 0x8286A280;
	sub_82DF3A08(ctx, base);
	// 8286A280: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A284: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A288: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A28C: 485F1ECD  bl 0x82e5c158
	ctx.lr = 0x8286A290;
	sub_82E5C158(ctx, base);
	// 8286A290: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A294: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8286A298: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A29C: 388B1A90  addi r4, r11, 0x1a90
	ctx.r[4].s64 = ctx.r[11].s64 + 6800;
	// 8286A2A0: 4BFFED89  bl 0x82869028
	ctx.lr = 0x8286A2A4;
	sub_82869028(ctx, base);
	// 8286A2A4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A2A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A2AC: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A2B0: 808B0AF8  lwz r4, 0xaf8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2808 as u32) ) } as u64;
	// 8286A2B4: 48589755  bl 0x82df3a08
	ctx.lr = 0x8286A2B8;
	sub_82DF3A08(ctx, base);
	// 8286A2B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A2BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A2C0: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A2C4: 485F1E95  bl 0x82e5c158
	ctx.lr = 0x8286A2C8;
	sub_82E5C158(ctx, base);
	// 8286A2C8: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A2CC: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8286A2D0: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A2D4: 388B17F0  addi r4, r11, 0x17f0
	ctx.r[4].s64 = ctx.r[11].s64 + 6128;
	// 8286A2D8: 4BFFED51  bl 0x82869028
	ctx.lr = 0x8286A2DC;
	sub_82869028(ctx, base);
	// 8286A2DC: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8286A2E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A2E4: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A2E8: 808B6888  lwz r4, 0x6888(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26760 as u32) ) } as u64;
	// 8286A2EC: 4858971D  bl 0x82df3a08
	ctx.lr = 0x8286A2F0;
	sub_82DF3A08(ctx, base);
	// 8286A2F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A2F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A2F8: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A2FC: 485F1E5D  bl 0x82e5c158
	ctx.lr = 0x8286A300;
	sub_82E5C158(ctx, base);
	// 8286A300: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A304: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8286A308: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A30C: 388B1860  addi r4, r11, 0x1860
	ctx.r[4].s64 = ctx.r[11].s64 + 6240;
	// 8286A310: 4BFFED19  bl 0x82869028
	ctx.lr = 0x8286A314;
	sub_82869028(ctx, base);
	// 8286A314: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8286A318: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A31C: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A320: 808B688C  lwz r4, 0x688c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26764 as u32) ) } as u64;
	// 8286A324: 485896E5  bl 0x82df3a08
	ctx.lr = 0x8286A328;
	sub_82DF3A08(ctx, base);
	// 8286A328: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A32C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A330: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A334: 485F1E25  bl 0x82e5c158
	ctx.lr = 0x8286A338;
	sub_82E5C158(ctx, base);
	// 8286A338: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A33C: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8286A340: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A344: 388B1940  addi r4, r11, 0x1940
	ctx.r[4].s64 = ctx.r[11].s64 + 6464;
	// 8286A348: 4BFFECE1  bl 0x82869028
	ctx.lr = 0x8286A34C;
	sub_82869028(ctx, base);
	// 8286A34C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8286A350: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A354: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A358: 808B6890  lwz r4, 0x6890(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26768 as u32) ) } as u64;
	// 8286A35C: 485896AD  bl 0x82df3a08
	ctx.lr = 0x8286A360;
	sub_82DF3A08(ctx, base);
	// 8286A360: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A364: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A368: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A36C: 485F1DED  bl 0x82e5c158
	ctx.lr = 0x8286A370;
	sub_82E5C158(ctx, base);
	// 8286A370: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A374: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8286A378: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A37C: 388B18D0  addi r4, r11, 0x18d0
	ctx.r[4].s64 = ctx.r[11].s64 + 6352;
	// 8286A380: 4BFFECA9  bl 0x82869028
	ctx.lr = 0x8286A384;
	sub_82869028(ctx, base);
	// 8286A384: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8286A388: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A38C: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A390: 808B6894  lwz r4, 0x6894(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26772 as u32) ) } as u64;
	// 8286A394: 48589675  bl 0x82df3a08
	ctx.lr = 0x8286A398;
	sub_82DF3A08(ctx, base);
	// 8286A398: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A39C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A3A0: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A3A4: 485F1DB5  bl 0x82e5c158
	ctx.lr = 0x8286A3A8;
	sub_82E5C158(ctx, base);
	// 8286A3A8: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A3AC: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8286A3B0: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A3B4: 388BD3E0  addi r4, r11, -0x2c20
	ctx.r[4].s64 = ctx.r[11].s64 + -11296;
	// 8286A3B8: 4BFFEC71  bl 0x82869028
	ctx.lr = 0x8286A3BC;
	sub_82869028(ctx, base);
	// 8286A3BC: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8286A3C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A3C4: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A3C8: 808B6898  lwz r4, 0x6898(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26776 as u32) ) } as u64;
	// 8286A3CC: 4858963D  bl 0x82df3a08
	ctx.lr = 0x8286A3D0;
	sub_82DF3A08(ctx, base);
	// 8286A3D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A3D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A3D8: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A3DC: 485F1D7D  bl 0x82e5c158
	ctx.lr = 0x8286A3E0;
	sub_82E5C158(ctx, base);
	// 8286A3E0: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A3E4: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8286A3E8: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A3EC: 388B35B8  addi r4, r11, 0x35b8
	ctx.r[4].s64 = ctx.r[11].s64 + 13752;
	// 8286A3F0: 4BFFEC39  bl 0x82869028
	ctx.lr = 0x8286A3F4;
	sub_82869028(ctx, base);
	// 8286A3F4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A3F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A3FC: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A400: 808B0AFC  lwz r4, 0xafc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2812 as u32) ) } as u64;
	// 8286A404: 48589605  bl 0x82df3a08
	ctx.lr = 0x8286A408;
	sub_82DF3A08(ctx, base);
	// 8286A408: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A40C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A410: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A414: 485F1D45  bl 0x82e5c158
	ctx.lr = 0x8286A418;
	sub_82E5C158(ctx, base);
	// 8286A418: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A41C: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8286A420: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A424: 388B37B0  addi r4, r11, 0x37b0
	ctx.r[4].s64 = ctx.r[11].s64 + 14256;
	// 8286A428: 4BFFEC01  bl 0x82869028
	ctx.lr = 0x8286A42C;
	sub_82869028(ctx, base);
	// 8286A42C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A430: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A434: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A438: 808B0B10  lwz r4, 0xb10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2832 as u32) ) } as u64;
	// 8286A43C: 485895CD  bl 0x82df3a08
	ctx.lr = 0x8286A440;
	sub_82DF3A08(ctx, base);
	// 8286A440: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A444: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A448: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A44C: 485F1D0D  bl 0x82e5c158
	ctx.lr = 0x8286A450;
	sub_82E5C158(ctx, base);
	// 8286A450: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A454: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8286A458: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A45C: 388BEEF8  addi r4, r11, -0x1108
	ctx.r[4].s64 = ctx.r[11].s64 + -4360;
	// 8286A460: 4BFFEBC9  bl 0x82869028
	ctx.lr = 0x8286A464;
	sub_82869028(ctx, base);
	// 8286A464: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A468: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A46C: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A470: 808B0B08  lwz r4, 0xb08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2824 as u32) ) } as u64;
	// 8286A474: 48589595  bl 0x82df3a08
	ctx.lr = 0x8286A478;
	sub_82DF3A08(ctx, base);
	// 8286A478: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A47C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A480: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A484: 485F1CD5  bl 0x82e5c158
	ctx.lr = 0x8286A488;
	sub_82E5C158(ctx, base);
	// 8286A488: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A48C: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8286A490: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A494: 388B24D8  addi r4, r11, 0x24d8
	ctx.r[4].s64 = ctx.r[11].s64 + 9432;
	// 8286A498: 4BFFEB91  bl 0x82869028
	ctx.lr = 0x8286A49C;
	sub_82869028(ctx, base);
	// 8286A49C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A4A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A4A4: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A4A8: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 8286A4AC: 4858955D  bl 0x82df3a08
	ctx.lr = 0x8286A4B0;
	sub_82DF3A08(ctx, base);
	// 8286A4B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A4B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A4B8: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A4BC: 485F1C9D  bl 0x82e5c158
	ctx.lr = 0x8286A4C0;
	sub_82E5C158(ctx, base);
	// 8286A4C0: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A4C4: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8286A4C8: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A4CC: 388BF3A0  addi r4, r11, -0xc60
	ctx.r[4].s64 = ctx.r[11].s64 + -3168;
	// 8286A4D0: 4BFFEB59  bl 0x82869028
	ctx.lr = 0x8286A4D4;
	sub_82869028(ctx, base);
	// 8286A4D4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A4D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A4DC: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A4E0: 808B0B30  lwz r4, 0xb30(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2864 as u32) ) } as u64;
	// 8286A4E4: 48589525  bl 0x82df3a08
	ctx.lr = 0x8286A4E8;
	sub_82DF3A08(ctx, base);
	// 8286A4E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A4EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A4F0: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A4F4: 485F1C65  bl 0x82e5c158
	ctx.lr = 0x8286A4F8;
	sub_82E5C158(ctx, base);
	// 8286A4F8: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A4FC: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8286A500: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A504: 388BF410  addi r4, r11, -0xbf0
	ctx.r[4].s64 = ctx.r[11].s64 + -3056;
	// 8286A508: 4BFFEB21  bl 0x82869028
	ctx.lr = 0x8286A50C;
	sub_82869028(ctx, base);
	// 8286A50C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A510: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A514: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A518: 808B0B88  lwz r4, 0xb88(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2952 as u32) ) } as u64;
	// 8286A51C: 485894ED  bl 0x82df3a08
	ctx.lr = 0x8286A520;
	sub_82DF3A08(ctx, base);
	// 8286A520: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A524: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A528: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A52C: 485F1C2D  bl 0x82e5c158
	ctx.lr = 0x8286A530;
	sub_82E5C158(ctx, base);
	// 8286A530: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A534: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8286A538: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A53C: 388BF480  addi r4, r11, -0xb80
	ctx.r[4].s64 = ctx.r[11].s64 + -2944;
	// 8286A540: 4BFFEAE9  bl 0x82869028
	ctx.lr = 0x8286A544;
	sub_82869028(ctx, base);
	// 8286A544: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A548: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A54C: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A550: 808B0B8C  lwz r4, 0xb8c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2956 as u32) ) } as u64;
	// 8286A554: 485894B5  bl 0x82df3a08
	ctx.lr = 0x8286A558;
	sub_82DF3A08(ctx, base);
	// 8286A558: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A55C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A560: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A564: 485F1BF5  bl 0x82e5c158
	ctx.lr = 0x8286A568;
	sub_82E5C158(ctx, base);
	// 8286A568: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A56C: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8286A570: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A574: 388BF560  addi r4, r11, -0xaa0
	ctx.r[4].s64 = ctx.r[11].s64 + -2720;
	// 8286A578: 4BFFEAB1  bl 0x82869028
	ctx.lr = 0x8286A57C;
	sub_82869028(ctx, base);
	// 8286A57C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8286A580: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A584: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A588: 808B689C  lwz r4, 0x689c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26780 as u32) ) } as u64;
	// 8286A58C: 4858947D  bl 0x82df3a08
	ctx.lr = 0x8286A590;
	sub_82DF3A08(ctx, base);
	// 8286A590: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A594: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A598: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A59C: 485F1BBD  bl 0x82e5c158
	ctx.lr = 0x8286A5A0;
	sub_82E5C158(ctx, base);
	// 8286A5A0: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A5A4: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8286A5A8: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A5AC: 388BF7C0  addi r4, r11, -0x840
	ctx.r[4].s64 = ctx.r[11].s64 + -2112;
	// 8286A5B0: 4BFFEA79  bl 0x82869028
	ctx.lr = 0x8286A5B4;
	sub_82869028(ctx, base);
	// 8286A5B4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A5B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A5BC: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A5C0: 808B0B28  lwz r4, 0xb28(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2856 as u32) ) } as u64;
	// 8286A5C4: 48589445  bl 0x82df3a08
	ctx.lr = 0x8286A5C8;
	sub_82DF3A08(ctx, base);
	// 8286A5C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A5CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A5D0: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A5D4: 485F1B85  bl 0x82e5c158
	ctx.lr = 0x8286A5D8;
	sub_82E5C158(ctx, base);
	// 8286A5D8: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A5DC: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8286A5E0: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A5E4: 388BF750  addi r4, r11, -0x8b0
	ctx.r[4].s64 = ctx.r[11].s64 + -2224;
	// 8286A5E8: 4BFFEA41  bl 0x82869028
	ctx.lr = 0x8286A5EC;
	sub_82869028(ctx, base);
	// 8286A5EC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A5F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A5F4: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A5F8: 808B0B34  lwz r4, 0xb34(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2868 as u32) ) } as u64;
	// 8286A5FC: 4858940D  bl 0x82df3a08
	ctx.lr = 0x8286A600;
	sub_82DF3A08(ctx, base);
	// 8286A600: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A604: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A608: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A60C: 485F1B4D  bl 0x82e5c158
	ctx.lr = 0x8286A610;
	sub_82E5C158(ctx, base);
	// 8286A610: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A614: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8286A618: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A61C: 388BF8A0  addi r4, r11, -0x760
	ctx.r[4].s64 = ctx.r[11].s64 + -1888;
	// 8286A620: 4BFFEA89  bl 0x828690a8
	ctx.lr = 0x8286A624;
	sub_828690A8(ctx, base);
	// 8286A624: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A628: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A62C: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A630: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 8286A634: 485893D5  bl 0x82df3a08
	ctx.lr = 0x8286A638;
	sub_82DF3A08(ctx, base);
	// 8286A638: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A63C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A640: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A644: 485F1B15  bl 0x82e5c158
	ctx.lr = 0x8286A648;
	sub_82E5C158(ctx, base);
	// 8286A648: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A64C: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 8286A650: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A654: 388BC038  addi r4, r11, -0x3fc8
	ctx.r[4].s64 = ctx.r[11].s64 + -16328;
	// 8286A658: 4BFFEA51  bl 0x828690a8
	ctx.lr = 0x8286A65C;
	sub_828690A8(ctx, base);
	// 8286A65C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A660: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A664: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A668: 808B0B70  lwz r4, 0xb70(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2928 as u32) ) } as u64;
	// 8286A66C: 4858939D  bl 0x82df3a08
	ctx.lr = 0x8286A670;
	sub_82DF3A08(ctx, base);
	// 8286A670: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A674: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A678: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A67C: 485F1ADD  bl 0x82e5c158
	ctx.lr = 0x8286A680;
	sub_82E5C158(ctx, base);
	// 8286A680: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A684: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 8286A688: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A68C: 388B10F8  addi r4, r11, 0x10f8
	ctx.r[4].s64 = ctx.r[11].s64 + 4344;
	// 8286A690: 4BFFEA19  bl 0x828690a8
	ctx.lr = 0x8286A694;
	sub_828690A8(ctx, base);
	// 8286A694: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A698: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A69C: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A6A0: 808B0B7C  lwz r4, 0xb7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2940 as u32) ) } as u64;
	// 8286A6A4: 48589365  bl 0x82df3a08
	ctx.lr = 0x8286A6A8;
	sub_82DF3A08(ctx, base);
	// 8286A6A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A6AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A6B0: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A6B4: 485F1AA5  bl 0x82e5c158
	ctx.lr = 0x8286A6B8;
	sub_82E5C158(ctx, base);
	// 8286A6B8: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A6BC: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 8286A6C0: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A6C4: 388BBFA0  addi r4, r11, -0x4060
	ctx.r[4].s64 = ctx.r[11].s64 + -16480;
	// 8286A6C8: 4BFFE9E1  bl 0x828690a8
	ctx.lr = 0x8286A6CC;
	sub_828690A8(ctx, base);
	// 8286A6CC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A6D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A6D4: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A6D8: 808B0B98  lwz r4, 0xb98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2968 as u32) ) } as u64;
	// 8286A6DC: 4858932D  bl 0x82df3a08
	ctx.lr = 0x8286A6E0;
	sub_82DF3A08(ctx, base);
	// 8286A6E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A6E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A6E8: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A6EC: 485F1A6D  bl 0x82e5c158
	ctx.lr = 0x8286A6F0;
	sub_82E5C158(ctx, base);
	// 8286A6F0: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A6F4: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8286A6F8: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A6FC: 388B1CA8  addi r4, r11, 0x1ca8
	ctx.r[4].s64 = ctx.r[11].s64 + 7336;
	// 8286A700: 4BFFE9A9  bl 0x828690a8
	ctx.lr = 0x8286A704;
	sub_828690A8(ctx, base);
	// 8286A704: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A708: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A70C: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A710: 808B0B50  lwz r4, 0xb50(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2896 as u32) ) } as u64;
	// 8286A714: 485892F5  bl 0x82df3a08
	ctx.lr = 0x8286A718;
	sub_82DF3A08(ctx, base);
	// 8286A718: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A71C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A720: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A724: 485F1A35  bl 0x82e5c158
	ctx.lr = 0x8286A728;
	sub_82E5C158(ctx, base);
	// 8286A728: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A72C: 3D608292  lis r11, -0x7d6e
	ctx.r[11].s64 = -2104360960;
	// 8286A730: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A734: 388B4378  addi r4, r11, 0x4378
	ctx.r[4].s64 = ctx.r[11].s64 + 17272;
	// 8286A738: 4BFFE971  bl 0x828690a8
	ctx.lr = 0x8286A73C;
	sub_828690A8(ctx, base);
	// 8286A73C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A740: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A744: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A748: 808B0B58  lwz r4, 0xb58(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2904 as u32) ) } as u64;
	// 8286A74C: 485892BD  bl 0x82df3a08
	ctx.lr = 0x8286A750;
	sub_82DF3A08(ctx, base);
	// 8286A750: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A754: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A758: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A75C: 485F19FD  bl 0x82e5c158
	ctx.lr = 0x8286A760;
	sub_82E5C158(ctx, base);
	// 8286A760: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A764: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 8286A768: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A76C: 388B55E8  addi r4, r11, 0x55e8
	ctx.r[4].s64 = ctx.r[11].s64 + 21992;
	// 8286A770: 4BFFE939  bl 0x828690a8
	ctx.lr = 0x8286A774;
	sub_828690A8(ctx, base);
	// 8286A774: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A778: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A77C: 808B0B5C  lwz r4, 0xb5c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2908 as u32) ) } as u64;
	// 8286A780: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A784: 48589285  bl 0x82df3a08
	ctx.lr = 0x8286A788;
	sub_82DF3A08(ctx, base);
	// 8286A788: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A78C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A790: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A794: 485F19C5  bl 0x82e5c158
	ctx.lr = 0x8286A798;
	sub_82E5C158(ctx, base);
	// 8286A798: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A79C: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 8286A7A0: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A7A4: 388B8DD8  addi r4, r11, -0x7228
	ctx.r[4].s64 = ctx.r[11].s64 + -29224;
	// 8286A7A8: 4BFFE901  bl 0x828690a8
	ctx.lr = 0x8286A7AC;
	sub_828690A8(ctx, base);
	// 8286A7AC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A7B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A7B4: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A7B8: 808B0B60  lwz r4, 0xb60(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2912 as u32) ) } as u64;
	// 8286A7BC: 4858924D  bl 0x82df3a08
	ctx.lr = 0x8286A7C0;
	sub_82DF3A08(ctx, base);
	// 8286A7C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A7C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A7C8: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A7CC: 485F198D  bl 0x82e5c158
	ctx.lr = 0x8286A7D0;
	sub_82E5C158(ctx, base);
	// 8286A7D0: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A7D4: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 8286A7D8: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A7DC: 388B9EF8  addi r4, r11, -0x6108
	ctx.r[4].s64 = ctx.r[11].s64 + -24840;
	// 8286A7E0: 4BFFE8C9  bl 0x828690a8
	ctx.lr = 0x8286A7E4;
	sub_828690A8(ctx, base);
	// 8286A7E4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A7E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A7EC: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A7F0: 808B0B64  lwz r4, 0xb64(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2916 as u32) ) } as u64;
	// 8286A7F4: 48589215  bl 0x82df3a08
	ctx.lr = 0x8286A7F8;
	sub_82DF3A08(ctx, base);
	// 8286A7F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A7FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A800: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A804: 485F1955  bl 0x82e5c158
	ctx.lr = 0x8286A808;
	sub_82E5C158(ctx, base);
	// 8286A808: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A80C: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 8286A810: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A814: 388B4700  addi r4, r11, 0x4700
	ctx.r[4].s64 = ctx.r[11].s64 + 18176;
	// 8286A818: 4BFFE891  bl 0x828690a8
	ctx.lr = 0x8286A81C;
	sub_828690A8(ctx, base);
	// 8286A81C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A820: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A824: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A828: 808B0B68  lwz r4, 0xb68(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2920 as u32) ) } as u64;
	// 8286A82C: 485891DD  bl 0x82df3a08
	ctx.lr = 0x8286A830;
	sub_82DF3A08(ctx, base);
	// 8286A830: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A834: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A838: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A83C: 485F191D  bl 0x82e5c158
	ctx.lr = 0x8286A840;
	sub_82E5C158(ctx, base);
	// 8286A840: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A844: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 8286A848: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A84C: 388B9260  addi r4, r11, -0x6da0
	ctx.r[4].s64 = ctx.r[11].s64 + -28064;
	// 8286A850: 4BFFE859  bl 0x828690a8
	ctx.lr = 0x8286A854;
	sub_828690A8(ctx, base);
	// 8286A854: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A858: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A85C: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A860: 808B0B4C  lwz r4, 0xb4c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2892 as u32) ) } as u64;
	// 8286A864: 485891A5  bl 0x82df3a08
	ctx.lr = 0x8286A868;
	sub_82DF3A08(ctx, base);
	// 8286A868: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A86C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A870: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A874: 485F18E5  bl 0x82e5c158
	ctx.lr = 0x8286A878;
	sub_82E5C158(ctx, base);
	// 8286A878: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A87C: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 8286A880: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A884: 388B8D88  addi r4, r11, -0x7278
	ctx.r[4].s64 = ctx.r[11].s64 + -29304;
	// 8286A888: 4BFFE821  bl 0x828690a8
	ctx.lr = 0x8286A88C;
	sub_828690A8(ctx, base);
	// 8286A88C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A890: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A894: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A898: 808B0B6C  lwz r4, 0xb6c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2924 as u32) ) } as u64;
	// 8286A89C: 4858916D  bl 0x82df3a08
	ctx.lr = 0x8286A8A0;
	sub_82DF3A08(ctx, base);
	// 8286A8A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A8A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A8A8: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A8AC: 485F18AD  bl 0x82e5c158
	ctx.lr = 0x8286A8B0;
	sub_82E5C158(ctx, base);
	// 8286A8B0: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 8286A8B4: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A8B8: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A8BC: 388B8648  addi r4, r11, -0x79b8
	ctx.r[4].s64 = ctx.r[11].s64 + -31160;
	// 8286A8C0: 4BFFE7E9  bl 0x828690a8
	ctx.lr = 0x8286A8C4;
	sub_828690A8(ctx, base);
	// 8286A8C4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A8C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A8CC: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A8D0: 808B0BA4  lwz r4, 0xba4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2980 as u32) ) } as u64;
	// 8286A8D4: 48589135  bl 0x82df3a08
	ctx.lr = 0x8286A8D8;
	sub_82DF3A08(ctx, base);
	// 8286A8D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A8DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A8E0: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A8E4: 485F1875  bl 0x82e5c158
	ctx.lr = 0x8286A8E8;
	sub_82E5C158(ctx, base);
	// 8286A8E8: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A8EC: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 8286A8F0: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A8F4: 388B8420  addi r4, r11, -0x7be0
	ctx.r[4].s64 = ctx.r[11].s64 + -31712;
	// 8286A8F8: 4BFFE7B1  bl 0x828690a8
	ctx.lr = 0x8286A8FC;
	sub_828690A8(ctx, base);
	// 8286A8FC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A900: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A904: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A908: 808B0BA8  lwz r4, 0xba8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2984 as u32) ) } as u64;
	// 8286A90C: 485890FD  bl 0x82df3a08
	ctx.lr = 0x8286A910;
	sub_82DF3A08(ctx, base);
	// 8286A910: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A914: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A918: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A91C: 485F183D  bl 0x82e5c158
	ctx.lr = 0x8286A920;
	sub_82E5C158(ctx, base);
	// 8286A920: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A924: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 8286A928: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A92C: 388BB190  addi r4, r11, -0x4e70
	ctx.r[4].s64 = ctx.r[11].s64 + -20080;
	// 8286A930: 4BFFE779  bl 0x828690a8
	ctx.lr = 0x8286A934;
	sub_828690A8(ctx, base);
	// 8286A934: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A938: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A93C: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A940: 808B0B14  lwz r4, 0xb14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2836 as u32) ) } as u64;
	// 8286A944: 485890C5  bl 0x82df3a08
	ctx.lr = 0x8286A948;
	sub_82DF3A08(ctx, base);
	// 8286A948: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A94C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A950: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A954: 485F1805  bl 0x82e5c158
	ctx.lr = 0x8286A958;
	sub_82E5C158(ctx, base);
	// 8286A958: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A95C: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8286A960: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A964: 388BF830  addi r4, r11, -0x7d0
	ctx.r[4].s64 = ctx.r[11].s64 + -2000;
	// 8286A968: 4BFFE6C1  bl 0x82869028
	ctx.lr = 0x8286A96C;
	sub_82869028(ctx, base);
	// 8286A96C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286A970: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A974: 3A0100F0  addi r16, r1, 0xf0
	ctx.r[16].s64 = ctx.r[1].s64 + 240;
	// 8286A978: 808B0BC0  lwz r4, 0xbc0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3008 as u32) ) } as u64;
	// 8286A97C: 4858908D  bl 0x82df3a08
	ctx.lr = 0x8286A980;
	sub_82DF3A08(ctx, base);
	// 8286A980: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286A984: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A988: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 8286A98C: 485F17CD  bl 0x82e5c158
	ctx.lr = 0x8286A990;
	sub_82E5C158(ctx, base);
	// 8286A990: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286A994: 80990AF0  lwz r4, 0xaf0(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(2800 as u32) ) } as u64;
	// 8286A998: 48589071  bl 0x82df3a08
	ctx.lr = 0x8286A99C;
	sub_82DF3A08(ctx, base);
	// 8286A99C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8286A9A0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8286A9A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8286A9A8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8286A9AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8286A9B0: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8286A9B4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8286A9B8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8286A9BC: 485F3FA5  bl 0x82e5e960
	ctx.lr = 0x8286A9C0;
	sub_82E5E960(ctx, base);
	// 8286A9C0: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 8286A9C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286A9C8: 419A0008  beq cr6, 0x8286a9d0
	if ctx.cr[6].eq {
	pc = 0x8286A9D0; continue 'dispatch;
	}
	// 8286A9CC: 4BA55EC5  bl 0x822c0890
	ctx.lr = 0x8286A9D0;
	sub_822C0890(ctx, base);
	// 8286A9D0: 817C0164  lwz r11, 0x164(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(356 as u32) ) } as u64;
	// 8286A9D4: 3BBC0164  addi r29, r28, 0x164
	ctx.r[29].s64 = ctx.r[28].s64 + 356;
	// 8286A9D8: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286A9DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286A9E0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286A9E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8286A9E8: 4E800421  bctrl
	ctx.lr = 0x8286A9EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286A9EC: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286A9F0: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 8286A9F4: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286A9F8: 388BD8C8  addi r4, r11, -0x2738
	ctx.r[4].s64 = ctx.r[11].s64 + -10040;
	// 8286A9FC: 4BFFE6AD  bl 0x828690a8
	ctx.lr = 0x8286AA00;
	sub_828690A8(ctx, base);
	// 8286AA00: 3F40832D  lis r26, -0x7cd3
	ctx.r[26].s64 = -2094202880;
	// 8286AA04: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286AA08: 3B2100F0  addi r25, r1, 0xf0
	ctx.r[25].s64 = ctx.r[1].s64 + 240;
	// 8286AA0C: 809A0BD8  lwz r4, 0xbd8(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(3032 as u32) ) } as u64;
	// 8286AA10: 48588FF9  bl 0x82df3a08
	ctx.lr = 0x8286AA14;
	sub_82DF3A08(ctx, base);
	// 8286AA14: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286AA18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286AA1C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 8286AA20: 485F1739  bl 0x82e5c158
	ctx.lr = 0x8286AA24;
	sub_82E5C158(ctx, base);
	// 8286AA24: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286AA28: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 8286AA2C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286AA30: 388BE1E0  addi r4, r11, -0x1e20
	ctx.r[4].s64 = ctx.r[11].s64 + -7712;
	// 8286AA34: 4BFFE675  bl 0x828690a8
	ctx.lr = 0x8286AA38;
	sub_828690A8(ctx, base);
	// 8286AA38: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286AA3C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286AA40: 3B2100F0  addi r25, r1, 0xf0
	ctx.r[25].s64 = ctx.r[1].s64 + 240;
	// 8286AA44: 808B0BDC  lwz r4, 0xbdc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3036 as u32) ) } as u64;
	// 8286AA48: 48588FC1  bl 0x82df3a08
	ctx.lr = 0x8286AA4C;
	sub_82DF3A08(ctx, base);
	// 8286AA4C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286AA50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286AA54: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 8286AA58: 485F1701  bl 0x82e5c158
	ctx.lr = 0x8286AA5C;
	sub_82E5C158(ctx, base);
	// 8286AA5C: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286AA60: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 8286AA64: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286AA68: 388BDE20  addi r4, r11, -0x21e0
	ctx.r[4].s64 = ctx.r[11].s64 + -8672;
	// 8286AA6C: 4BFFE63D  bl 0x828690a8
	ctx.lr = 0x8286AA70;
	sub_828690A8(ctx, base);
	// 8286AA70: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286AA74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286AA78: 3B2100F0  addi r25, r1, 0xf0
	ctx.r[25].s64 = ctx.r[1].s64 + 240;
	// 8286AA7C: 808B0BE0  lwz r4, 0xbe0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3040 as u32) ) } as u64;
	// 8286AA80: 48588F89  bl 0x82df3a08
	ctx.lr = 0x8286AA84;
	sub_82DF3A08(ctx, base);
	// 8286AA84: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286AA88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286AA8C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 8286AA90: 485F16C9  bl 0x82e5c158
	ctx.lr = 0x8286AA94;
	sub_82E5C158(ctx, base);
	// 8286AA94: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286AA98: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 8286AA9C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286AAA0: 388BE810  addi r4, r11, -0x17f0
	ctx.r[4].s64 = ctx.r[11].s64 + -6128;
	// 8286AAA4: 4BFFE605  bl 0x828690a8
	ctx.lr = 0x8286AAA8;
	sub_828690A8(ctx, base);
	// 8286AAA8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 8286AAAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286AAB0: 3B2100F0  addi r25, r1, 0xf0
	ctx.r[25].s64 = ctx.r[1].s64 + 240;
	// 8286AAB4: 808B0BE8  lwz r4, 0xbe8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3048 as u32) ) } as u64;
	// 8286AAB8: 48588F51  bl 0x82df3a08
	ctx.lr = 0x8286AABC;
	sub_82DF3A08(ctx, base);
	// 8286AABC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286AAC0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286AAC4: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 8286AAC8: 485F1691  bl 0x82e5c158
	ctx.lr = 0x8286AACC;
	sub_82E5C158(ctx, base);
	// 8286AACC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286AAD0: 809A0BD8  lwz r4, 0xbd8(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(3032 as u32) ) } as u64;
	// 8286AAD4: 48588F35  bl 0x82df3a08
	ctx.lr = 0x8286AAD8;
	sub_82DF3A08(ctx, base);
	// 8286AAD8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8286AADC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8286AAE0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8286AAE4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 8286AAE8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8286AAEC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8286AAF0: 485F3E71  bl 0x82e5e960
	ctx.lr = 0x8286AAF4;
	sub_82E5E960(ctx, base);
	// 8286AAF4: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 8286AAF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286AAFC: 419A0008  beq cr6, 0x8286ab04
	if ctx.cr[6].eq {
	pc = 0x8286AB04; continue 'dispatch;
	}
	// 8286AB00: 4BA55D91  bl 0x822c0890
	ctx.lr = 0x8286AB04;
	sub_822C0890(ctx, base);
	// 8286AB04: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 8286AB08: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8286AB0C: 38A00168  li r5, 0x168
	ctx.r[5].s64 = 360;
	// 8286AB10: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 8286AB14: 4BA558C5  bl 0x822c03d8
	ctx.lr = 0x8286AB18;
	sub_822C03D8(ctx, base);
	// 8286AB18: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8286AB1C: 41820040  beq 0x8286ab5c
	if ctx.cr[0].eq {
	pc = 0x8286AB5C; continue 'dispatch;
	}
	// 8286AB20: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8286AB24: 4BF8163D  bl 0x827ec160
	ctx.lr = 0x8286AB28;
	sub_827EC160(ctx, base);
	// 8286AB28: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286AB2C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8286AB30: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8286AB34: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 8286AB38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8286AB3C: 4E800421  bctrl
	ctx.lr = 0x8286AB40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286AB40: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8286AB44: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 8286AB48: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286AB4C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 8286AB50: 480B7C71  bl 0x829227c0
	ctx.lr = 0x8286AB54;
	sub_829227C0(ctx, base);
	// 8286AB54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286AB58: 48000008  b 0x8286ab60
	pc = 0x8286AB60; continue 'dispatch;
	// 8286AB5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8286AB60: 387C0368  addi r3, r28, 0x368
	ctx.r[3].s64 = ctx.r[28].s64 + 872;
	// 8286AB64: 4BFFE455  bl 0x82868fb8
	ctx.lr = 0x8286AB68;
	sub_82868FB8(ctx, base);
	// 8286AB68: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8286AB6C: 4BCA7F2D  bl 0x82512a98
	ctx.lr = 0x8286AB70;
	sub_82512A98(ctx, base);
	// 8286AB70: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 8286AB74: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8286AB78: 38A0016E  li r5, 0x16e
	ctx.r[5].s64 = 366;
	// 8286AB7C: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 8286AB80: 4BA55859  bl 0x822c03d8
	ctx.lr = 0x8286AB84;
	sub_822C03D8(ctx, base);
	// 8286AB84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8286AB88: 41820020  beq 0x8286aba8
	if ctx.cr[0].eq {
	pc = 0x8286ABA8; continue 'dispatch;
	}
	// 8286AB8C: 2B110000  cmplwi cr6, r17, 0
	ctx.cr[6].compare_u32(ctx.r[17].u32, 0 as u32, &mut ctx.xer);
	// 8286AB90: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8286AB94: 409A0008  bne cr6, 0x8286ab9c
	if !ctx.cr[6].eq {
	pc = 0x8286AB9C; continue 'dispatch;
	}
	// 8286AB98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8286AB9C: 480003B5  bl 0x8286af50
	ctx.lr = 0x8286ABA0;
	sub_8286AF50(ctx, base);
	// 8286ABA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286ABA4: 48000008  b 0x8286abac
	pc = 0x8286ABAC; continue 'dispatch;
	// 8286ABA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8286ABAC: 387C0360  addi r3, r28, 0x360
	ctx.r[3].s64 = ctx.r[28].s64 + 864;
	// 8286ABB0: 4BFFD7B1  bl 0x82868360
	ctx.lr = 0x8286ABB4;
	sub_82868360(ctx, base);
	// 8286ABB4: 807C0360  lwz r3, 0x360(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(864 as u32) ) } as u64;
	// 8286ABB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286ABBC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286ABC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8286ABC4: 4E800421  bctrl
	ctx.lr = 0x8286ABC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286ABC8: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 8286ABCC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8286ABD0: 480A3431  bl 0x8290e000
	ctx.lr = 0x8286ABD4;
	sub_8290E000(ctx, base);
	// 8286ABD4: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 8286ABD8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8286ABDC: 38A00176  li r5, 0x176
	ctx.r[5].s64 = 374;
	// 8286ABE0: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8286ABE4: 4BA557F5  bl 0x822c03d8
	ctx.lr = 0x8286ABE8;
	sub_822C03D8(ctx, base);
	// 8286ABE8: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8286ABEC: 41820040  beq 0x8286ac2c
	if ctx.cr[0].eq {
	pc = 0x8286AC2C; continue 'dispatch;
	}
	// 8286ABF0: 2B110000  cmplwi cr6, r17, 0
	ctx.cr[6].compare_u32(ctx.r[17].u32, 0 as u32, &mut ctx.xer);
	// 8286ABF4: 7F9AE378  mr r26, r28
	ctx.r[26].u64 = ctx.r[28].u64;
	// 8286ABF8: 409A0008  bne cr6, 0x8286ac00
	if !ctx.cr[6].eq {
	pc = 0x8286AC00; continue 'dispatch;
	}
	// 8286ABFC: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 8286AC00: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286AC04: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8286AC08: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 8286AC0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8286AC10: 4E800421  bctrl
	ctx.lr = 0x8286AC14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286AC14: 38A30034  addi r5, r3, 0x34
	ctx.r[5].s64 = ctx.r[3].s64 + 52;
	// 8286AC18: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8286AC1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286AC20: 480D9001  bl 0x82943c20
	ctx.lr = 0x8286AC24;
	sub_82943C20(ctx, base);
	// 8286AC24: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8286AC28: 48000008  b 0x8286ac30
	pc = 0x8286AC30; continue 'dispatch;
	// 8286AC2C: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 8286AC30: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 8286AC34: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8286AC38: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 8286AC3C: 4BFFBD4D  bl 0x82866988
	ctx.lr = 0x8286AC40;
	sub_82866988(ctx, base);
	// 8286AC40: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8286AC44: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8286AC48: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 8286AC4C: 4BA553B5  bl 0x822c0000
	ctx.lr = 0x8286AC50;
	sub_822C0000(ctx, base);
	// 8286AC50: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8286AC54: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8286AC58: 4BFFD779  bl 0x828683d0
	ctx.lr = 0x8286AC5C;
	sub_828683D0(ctx, base);
	// 8286AC5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286AC60: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8286AC64: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286AC68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286AC6C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8286AC70: 419A0024  beq cr6, 0x8286ac94
	if ctx.cr[6].eq {
	pc = 0x8286AC94; continue 'dispatch;
	}
	// 8286AC74: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8286AC78: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8286AC7C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286AC80: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8286AC84: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8286AC88: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8286AC8C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8286AC90: 4082FFE8  bne 0x8286ac78
	if !ctx.cr[0].eq {
	pc = 0x8286AC78; continue 'dispatch;
	}
	// 8286AC94: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8286AC98: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8286AC9C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8286ACA0: 480A0849  bl 0x8290b4e8
	ctx.lr = 0x8286ACA4;
	sub_8290B4E8(ctx, base);
	// 8286ACA4: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 8286ACA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286ACAC: 419A0008  beq cr6, 0x8286acb4
	if ctx.cr[6].eq {
	pc = 0x8286ACB4; continue 'dispatch;
	}
	// 8286ACB0: 4BA55BE1  bl 0x822c0890
	ctx.lr = 0x8286ACB4;
	sub_822C0890(ctx, base);
	// 8286ACB4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8286ACB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286ACBC: 419A0008  beq cr6, 0x8286acc4
	if ctx.cr[6].eq {
	pc = 0x8286ACC4; continue 'dispatch;
	}
	// 8286ACC0: 4BA55BD1  bl 0x822c0890
	ctx.lr = 0x8286ACC4;
	sub_822C0890(ctx, base);
	// 8286ACC4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286ACC8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8286ACCC: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 8286ACD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8286ACD4: 4E800421  bctrl
	ctx.lr = 0x8286ACD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286ACD8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8286ACDC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8286ACE0: C02B0000  lfs f1, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8286ACE4: 480A376D  bl 0x8290e450
	ctx.lr = 0x8286ACE8;
	sub_8290E450(ctx, base);
	// 8286ACE8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8286ACEC: 4BF81475  bl 0x827ec160
	ctx.lr = 0x8286ACF0;
	sub_827EC160(ctx, base);
	// 8286ACF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286ACF4: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 8286ACF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8286ACFC: 4E800421  bctrl
	ctx.lr = 0x8286AD00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286AD00: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8286AD04: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8286AD08: C097000C  lfs f4, 0xc(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8286AD0C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8286AD10: C0770008  lfs f3, 8(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8286AD14: C0570004  lfs f2, 4(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8286AD18: C0380000  lfs f1, 0(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8286AD1C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8286AD20: C00AFD2C  lfs f0, -0x2d4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-724 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8286AD24: ECAD002A  fadds f5, f13, f0
	ctx.f[5].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8286AD28: 480A5581  bl 0x829102a8
	ctx.lr = 0x8286AD2C;
	sub_829102A8(ctx, base);
	// 8286AD2C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8286AD30: 480D4239  bl 0x8293ef68
	ctx.lr = 0x8286AD34;
	sub_8293EF68(ctx, base);
	// 8286AD34: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 8286AD38: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8286AD3C: 38A00183  li r5, 0x183
	ctx.r[5].s64 = 387;
	// 8286AD40: 386000A0  li r3, 0xa0
	ctx.r[3].s64 = 160;
	// 8286AD44: 4BA55695  bl 0x822c03d8
	ctx.lr = 0x8286AD48;
	sub_822C03D8(ctx, base);
	// 8286AD48: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8286AD4C: 41820024  beq 0x8286ad70
	if ctx.cr[0].eq {
	pc = 0x8286AD70; continue 'dispatch;
	}
	// 8286AD50: 2B110000  cmplwi cr6, r17, 0
	ctx.cr[6].compare_u32(ctx.r[17].u32, 0 as u32, &mut ctx.xer);
	// 8286AD54: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8286AD58: 409A0008  bne cr6, 0x8286ad60
	if !ctx.cr[6].eq {
	pc = 0x8286AD60; continue 'dispatch;
	}
	// 8286AD5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8286AD60: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 8286AD64: 480D536D  bl 0x829400d0
	ctx.lr = 0x8286AD68;
	sub_829400D0(ctx, base);
	// 8286AD68: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286AD6C: 48000008  b 0x8286ad74
	pc = 0x8286AD74; continue 'dispatch;
	// 8286AD70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8286AD74: 387C0370  addi r3, r28, 0x370
	ctx.r[3].s64 = ctx.r[28].s64 + 880;
	// 8286AD78: 4BFFD6D1  bl 0x82868448
	ctx.lr = 0x8286AD7C;
	sub_82868448(ctx, base);
	// 8286AD7C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8286AD80: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286AD84: 3BAB1EDC  addi r29, r11, 0x1edc
	ctx.r[29].s64 = ctx.r[11].s64 + 7900;
	// 8286AD88: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8286AD8C: 48588C7D  bl 0x82df3a08
	ctx.lr = 0x8286AD90;
	sub_82DF3A08(ctx, base);
	// 8286AD90: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8286AD94: 386100F4  addi r3, r1, 0xf4
	ctx.r[3].s64 = ctx.r[1].s64 + 244;
	// 8286AD98: 388B1360  addi r4, r11, 0x1360
	ctx.r[4].s64 = ctx.r[11].s64 + 4960;
	// 8286AD9C: 48588C6D  bl 0x82df3a08
	ctx.lr = 0x8286ADA0;
	sub_82DF3A08(ctx, base);
	// 8286ADA0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8286ADA4: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8286ADA8: D3E10100  stfs f31, 0x100(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 8286ADAC: 3D208207  lis r9, -0x7df9
	ctx.r[9].s64 = -2113470464;
	// 8286ADB0: D3E10108  stfs f31, 0x108(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 8286ADB4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 8286ADB8: D3E10110  stfs f31, 0x110(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 8286ADBC: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 8286ADC0: C1ABD934  lfs f13, -0x26cc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9932 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8286ADC4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8286ADC8: C18A135C  lfs f12, 0x135c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4956 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8286ADCC: 90E100F8  stw r7, 0xf8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[7].u32 ) };
	// 8286ADD0: C1696000  lfs f11, 0x6000(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24576 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8286ADD4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286ADD8: C00808A8  lfs f0, 0x8a8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8286ADDC: 3B4100F0  addi r26, r1, 0xf0
	ctx.r[26].s64 = ctx.r[1].s64 + 240;
	// 8286ADE0: D1A100FC  stfs f13, 0xfc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 8286ADE4: D1810104  stfs f12, 0x104(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 8286ADE8: D161010C  stfs f11, 0x10c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 8286ADEC: D0010114  stfs f0, 0x114(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 8286ADF0: D0010118  stfs f0, 0x118(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 8286ADF4: D001011C  stfs f0, 0x11c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 8286ADF8: 4BF817D1  bl 0x827ec5c8
	ctx.lr = 0x8286ADFC;
	sub_827EC5C8(ctx, base);
	// 8286ADFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8286AE00: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8286AE04: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 8286AE08: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8286AE0C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8286AE10: 4BF81A31  bl 0x827ec840
	ctx.lr = 0x8286AE14;
	sub_827EC840(ctx, base);
	// 8286AE14: 386100F4  addi r3, r1, 0xf4
	ctx.r[3].s64 = ctx.r[1].s64 + 244;
	// 8286AE18: 48588611  bl 0x82df3428
	ctx.lr = 0x8286AE1C;
	sub_82DF3428(ctx, base);
	// 8286AE1C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286AE20: 48588609  bl 0x82df3428
	ctx.lr = 0x8286AE24;
	sub_82DF3428(ctx, base);
	// 8286AE24: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8286AE28: 4BF81339  bl 0x827ec160
	ctx.lr = 0x8286AE2C;
	sub_827EC160(ctx, base);
	// 8286AE2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286AE30: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 8286AE34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8286AE38: 4E800421  bctrl
	ctx.lr = 0x8286AE3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286AE3C: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 8286AE40: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 8286AE44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8286AE48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286AE4C: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 8286AE50: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8286AE54: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 8286AE58: 4200FFF0  bdnz 0x8286ae48
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8286AE48; continue 'dispatch;
	}
	// 8286AE5C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8286AE60: 482E8571  bl 0x82b533d0
	ctx.lr = 0x8286AE64;
	sub_82B533D0(ctx, base);
	// 8286AE64: D3E100EC  stfs f31, 0xec(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 8286AE68: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286AE6C: 39600015  li r11, 0x15
	ctx.r[11].s64 = 21;
	// 8286AE70: C00100A0  lfs f0, 0xa0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8286AE74: 92C100E8  stw r22, 0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[22].u32 ) };
	// 8286AE78: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 8286AE7C: D00100E4  stfs f0, 0xe4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 8286AE80: 93E100C0  stw r31, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[31].u32 ) };
	// 8286AE84: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286AE88: 83DC0260  lwz r30, 0x260(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(608 as u32) ) } as u64;
	// 8286AE8C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286AE90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8286AE94: 4E800421  bctrl
	ctx.lr = 0x8286AE98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286AE98: 483498D1  bl 0x82bb4768
	ctx.lr = 0x8286AE9C;
	sub_82BB4768(ctx, base);
	// 8286AE9C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8286AEA0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286AEA4: 48588B65  bl 0x82df3a08
	ctx.lr = 0x8286AEA8;
	sub_82DF3A08(ctx, base);
	// 8286AEA8: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 8286AEAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8286AEB0: 38E100C0  addi r7, r1, 0xc0
	ctx.r[7].s64 = ctx.r[1].s64 + 192;
	// 8286AEB4: 7E86A378  mr r6, r20
	ctx.r[6].u64 = ctx.r[20].u64;
	// 8286AEB8: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 8286AEBC: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 8286AEC0: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8286AEC4: 480A8D85  bl 0x82913c48
	ctx.lr = 0x8286AEC8;
	sub_82913C48(ctx, base);
	// 8286AEC8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286AECC: 4858855D  bl 0x82df3428
	ctx.lr = 0x8286AED0;
	sub_82DF3428(ctx, base);
	// 8286AED0: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 8286AED4: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8286AED8: 936100A8  stw r27, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[27].u32 ) };
	// 8286AEDC: 396BF2A8  addi r11, r11, -0xd58
	ctx.r[11].s64 = ctx.r[11].s64 + -3416;
	// 8286AEE0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8286AEE4: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 8286AEE8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8286AEEC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8286AEF0: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 8286AEF4: 4BFFE605  bl 0x828694f8
	ctx.lr = 0x8286AEF8;
	sub_828694F8(ctx, base);
	// 8286AEF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8286AEFC: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 8286AF00: 480A7A19  bl 0x82912918
	ctx.lr = 0x8286AF04;
	sub_82912918(ctx, base);
	// 8286AF04: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8286AF08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8286AF0C: 388B5D14  addi r4, r11, 0x5d14
	ctx.r[4].s64 = ctx.r[11].s64 + 23828;
	// 8286AF10: 480A72A1  bl 0x829121b0
	ctx.lr = 0x8286AF14;
	sub_829121B0(ctx, base);
	// 8286AF14: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 8286AF18: CBE1FF70  lfd f31, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 8286AF1C: 4893D26C  b 0x831a8188
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286AF20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8286AF20 size=48
    let mut pc: u32 = 0x8286AF20;
    'dispatch: loop {
        match pc {
            0x8286AF20 => {
    //   block [0x8286AF20..0x8286AF50)
	// 8286AF20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286AF24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8286AF28: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286AF2C: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 8286AF30: 80640018  lwz r3, 0x18(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 8286AF34: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8286AF38: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8286AF3C: 4BC4A29D  bl 0x824b51d8
	ctx.lr = 0x8286AF40;
	sub_824B51D8(ctx, base);
	// 8286AF40: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8286AF44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286AF48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286AF4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286AF50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8286AF50 size=60
    let mut pc: u32 = 0x8286AF50;
    'dispatch: loop {
        match pc {
            0x8286AF50 => {
    //   block [0x8286AF50..0x8286AF8C)
	// 8286AF50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286AF54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8286AF58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8286AF5C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286AF60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286AF64: 480AA63D  bl 0x829155a0
	ctx.lr = 0x8286AF68;
	sub_829155A0(ctx, base);
	// 8286AF68: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8286AF6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286AF70: 396B1388  addi r11, r11, 0x1388
	ctx.r[11].s64 = ctx.r[11].s64 + 5000;
	// 8286AF74: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8286AF78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8286AF7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286AF80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286AF84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286AF88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286AF90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8286AF90 size=116
    let mut pc: u32 = 0x8286AF90;
    'dispatch: loop {
        match pc {
            0x8286AF90 => {
    //   block [0x8286AF90..0x8286B004)
	// 8286AF90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286AF94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8286AF98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8286AF9C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286AFA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286AFA4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8286AFA8: 419A0040  beq cr6, 0x8286afe8
	if ctx.cr[6].eq {
	pc = 0x8286AFE8; continue 'dispatch;
	}
	// 8286AFAC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 8286AFB0: 0CDF0000  twi 6, r31, 0
	// 8286AFB4: 7D6BFB96  divwu r11, r11, r31
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 8286AFB8: 2B0B0018  cmplwi cr6, r11, 0x18
	ctx.cr[6].compare_u32(ctx.r[11].u32, 24 as u32, &mut ctx.xer);
	// 8286AFBC: 4098002C  bge cr6, 0x8286afe8
	if !ctx.cr[6].lt {
	pc = 0x8286AFE8; continue 'dispatch;
	}
	// 8286AFC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8286AFC4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8286AFC8: 396B0828  addi r11, r11, 0x828
	ctx.r[11].s64 = ctx.r[11].s64 + 2088;
	// 8286AFCC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 8286AFD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286AFD4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8286AFD8: 4BA592D9  bl 0x822c42b0
	ctx.lr = 0x8286AFDC;
	sub_822C42B0(ctx, base);
	// 8286AFDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8286AFE0: 396B0818  addi r11, r11, 0x818
	ctx.r[11].s64 = ctx.r[11].s64 + 2072;
	// 8286AFE4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8286AFE8: 1C7F0018  mulli r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 * 24;
	// 8286AFEC: 4BA5594D  bl 0x822c0938
	ctx.lr = 0x8286AFF0;
	sub_822C0938(ctx, base);
	// 8286AFF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286AFF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286AFF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286AFFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286B000: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286B008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8286B008 size=88
    let mut pc: u32 = 0x8286B008;
    'dispatch: loop {
        match pc {
            0x8286B008 => {
    //   block [0x8286B008..0x8286B060)
	// 8286B008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286B00C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8286B010: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286B014: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8286B018: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286B01C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286B020: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8286B024: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8286B028: 396B1388  addi r11, r11, 0x1388
	ctx.r[11].s64 = ctx.r[11].s64 + 5000;
	// 8286B02C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8286B030: 480AA559  bl 0x82915588
	ctx.lr = 0x8286B034;
	sub_82915588(ctx, base);
	// 8286B034: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286B038: 4182000C  beq 0x8286b044
	if ctx.cr[0].eq {
	pc = 0x8286B044; continue 'dispatch;
	}
	// 8286B03C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286B040: 4BA55229  bl 0x822c0268
	ctx.lr = 0x8286B044;
	sub_822C0268(ctx, base);
	// 8286B044: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286B048: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286B04C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286B050: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286B054: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8286B058: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286B05C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286B060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8286B060 size=44
    let mut pc: u32 = 0x8286B060;
    'dispatch: loop {
        match pc {
            0x8286B060 => {
    //   block [0x8286B060..0x8286B08C)
	// 8286B060: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B064: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B068: 892B0015  lbz r9, 0x15(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 8286B06C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8286B070: 409A0030  bne cr6, 0x8286b0a0
	if !ctx.cr[6].eq {
		sub_8286B08C(ctx, base);
		return;
	}
	// 8286B074: 81250000  lwz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B078: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8286B07C: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8286B080: 4098000C  bge cr6, 0x8286b08c
	if !ctx.cr[6].lt {
		sub_8286B08C(ctx, base);
		return;
	}
	// 8286B084: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286B088: 4800000C  b 0x8286b094
	sub_8286B08C(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286B08C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8286B08C size=60
    let mut pc: u32 = 0x8286B08C;
    'dispatch: loop {
        match pc {
            0x8286B08C => {
    //   block [0x8286B08C..0x8286B0C8)
	// 8286B08C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8286B090: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B094: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 8286B098: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8286B09C: 419AFFDC  beq cr6, 0x8286b078
	if ctx.cr[6].eq {
		sub_8286B060(ctx, base);
		return;
	}
	// 8286B0A0: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B0A4: 9141FFF0  stw r10, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u32 ) };
	// 8286B0A8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8286B0AC: 419A001C  beq cr6, 0x8286b0c8
	if ctx.cr[6].eq {
		sub_8286B0C8(ctx, base);
		return;
	}
	// 8286B0B0: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 8286B0B4: 81250000  lwz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B0B8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8286B0BC: 4198000C  blt cr6, 0x8286b0c8
	if ctx.cr[6].lt {
		sub_8286B0C8(ctx, base);
		return;
	}
	// 8286B0C0: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 8286B0C4: 4800000C  b 0x8286b0d0
	sub_8286B0C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286B0C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8286B0C8 size=20
    let mut pc: u32 = 0x8286B0C8;
    'dispatch: loop {
        match pc {
            0x8286B0C8 => {
    //   block [0x8286B0C8..0x8286B0DC)
	// 8286B0C8: 9161FFF4  stw r11, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[11].u32 ) };
	// 8286B0CC: 3961FFF4  addi r11, r1, -0xc
	ctx.r[11].s64 = ctx.r[1].s64 + -12;
	// 8286B0D0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B0D4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8286B0D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286B0E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8286B0E0 size=64
    let mut pc: u32 = 0x8286B0E0;
    'dispatch: loop {
        match pc {
            0x8286B0E0 => {
    //   block [0x8286B0E0..0x8286B120)
	// 8286B0E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286B0E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8286B0E8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286B0EC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8286B0F0: 1D44000C  mulli r10, r4, 0xc
	ctx.r[10].s64 = ctx.r[4].s64 * 12;
	// 8286B0F4: 396BCAF0  addi r11, r11, -0x3510
	ctx.r[11].s64 = ctx.r[11].s64 + -13584;
	// 8286B0F8: 38830004  addi r4, r3, 4
	ctx.r[4].s64 = ctx.r[3].s64 + 4;
	// 8286B0FC: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8286B100: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286B104: 4BFFFF5D  bl 0x8286b060
	ctx.lr = 0x8286B108;
	sub_8286B060(ctx, base);
	// 8286B108: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8286B10C: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8286B110: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8286B114: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286B118: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286B11C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286B120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8286B120 size=236
    let mut pc: u32 = 0x8286B120;
    'dispatch: loop {
        match pc {
            0x8286B120 => {
    //   block [0x8286B120..0x8286B20C)
	// 8286B120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286B124: 4893D03D  bl 0x831a8160
	ctx.lr = 0x8286B128;
	sub_831A8130(ctx, base);
	// 8286B128: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286B12C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8286B130: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 8286B134: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286B138: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 8286B13C: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 8286B140: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B144: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B148: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 8286B14C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8286B150: 409A0038  bne cr6, 0x8286b188
	if !ctx.cr[6].eq {
	pc = 0x8286B188; continue 'dispatch;
	}
	// 8286B154: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B158: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8286B15C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 8286B160: 7D295010  subfc r9, r9, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[9].u32;
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 8286B164: 7D294910  subfe r9, r9, r9
	let x = (!ctx.r[9].u32);
	let y = ctx.r[9].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[9].u32 = res;
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 8286B168: 553D07FF  clrlwi. r29, r9, 0x1f
	ctx.r[29].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8286B16C: 4182000C  beq 0x8286b178
	if ctx.cr[0].eq {
	pc = 0x8286B178; continue 'dispatch;
	}
	// 8286B170: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B174: 48000008  b 0x8286b17c
	pc = 0x8286B17C; continue 'dispatch;
	// 8286B178: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8286B17C: 892B0015  lbz r9, 0x15(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 8286B180: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8286B184: 419AFFD4  beq cr6, 0x8286b158
	if ctx.cr[6].eq {
	pc = 0x8286B158; continue 'dispatch;
	}
	// 8286B188: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 8286B18C: 57AA063F  clrlwi. r10, r29, 0x18
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8286B190: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8286B194: 41820044  beq 0x8286b1d8
	if ctx.cr[0].eq {
	pc = 0x8286B1D8; continue 'dispatch;
	}
	// 8286B198: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B19C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286B1A0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B1A4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8286B1A8: 409A0028  bne cr6, 0x8286b1d0
	if !ctx.cr[6].eq {
	pc = 0x8286B1D0; continue 'dispatch;
	}
	// 8286B1AC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8286B1B0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8286B1B4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 8286B1B8: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 8286B1BC: 480B6EDD  bl 0x82922098
	ctx.lr = 0x8286B1C0;
	sub_82922098(ctx, base);
	// 8286B1C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8286B1C4: 9B5F0004  stb r26, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u8 ) };
	// 8286B1C8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B1CC: 48000030  b 0x8286b1fc
	pc = 0x8286B1FC; continue 'dispatch;
	// 8286B1D0: 4834BA69  bl 0x82bb6c38
	ctx.lr = 0x8286B1D4;
	sub_82BB6C38(ctx, base);
	// 8286B1D4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8286B1D8: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B1DC: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8286B1E0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8286B1E4: 40980010  bge cr6, 0x8286b1f4
	if !ctx.cr[6].lt {
	pc = 0x8286B1F4; continue 'dispatch;
	}
	// 8286B1E8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8286B1EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286B1F0: 4BFFFFC0  b 0x8286b1b0
	pc = 0x8286B1B0; continue 'dispatch;
	// 8286B1F4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8286B1F8: 995F0004  stb r10, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 8286B1FC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8286B200: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286B204: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8286B208: 4893CFA8  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286B210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8286B210 size=488
    let mut pc: u32 = 0x8286B210;
    'dispatch: loop {
        match pc {
            0x8286B210 => {
    //   block [0x8286B210..0x8286B3F8)
	// 8286B210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286B214: 4893CF3D  bl 0x831a8150
	ctx.lr = 0x8286B218;
	sub_831A8130(ctx, base);
	// 8286B218: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286B21C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 8286B220: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8286B224: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 8286B228: 4BFFB269  bl 0x82866490
	ctx.lr = 0x8286B22C;
	sub_82866490(ctx, base);
	// 8286B22C: 834D0000  lwz r26, 0(r13)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B230: 3B200014  li r25, 0x14
	ctx.r[25].s64 = 20;
	// 8286B234: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8286B238: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 8286B23C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8286B240: 7C79D02E  lwzx r3, r25, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 8286B244: 486354ED  bl 0x82ea0730
	ctx.lr = 0x8286B248;
	sub_82EA0730(ctx, base);
	// 8286B248: 3AC00020  li r22, 0x20
	ctx.r[22].s64 = 32;
	// 8286B24C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8286B250: B2C30004  sth r22, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[22].u16 ) };
	// 8286B254: C1BB0000  lfs f13, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8286B258: 3BEBCAF0  addi r31, r11, -0x3510
	ctx.r[31].s64 = ctx.r[11].s64 + -13584;
	// 8286B25C: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8286B260: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8286B264: 486AEF8D  bl 0x82f1a1f0
	ctx.lr = 0x8286B268;
	sub_82F1A1F0(ctx, base);
	// 8286B268: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8286B26C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8286B270: 4182000C  beq 0x8286b27c
	if ctx.cr[0].eq {
	pc = 0x8286B27C; continue 'dispatch;
	}
	// 8286B274: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286B278: 4BA7CFD1  bl 0x822e8248
	ctx.lr = 0x8286B27C;
	sub_822E8248(ctx, base);
	// 8286B27C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8286B280: 839E0000  lwz r28, 0(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B284: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 8286B288: 80970000  lwz r4, 0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B28C: 485A9DA5  bl 0x82e15030
	ctx.lr = 0x8286B290;
	sub_82E15030(ctx, base);
	// 8286B290: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8286B294: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8286B298: 815C00C8  lwz r10, 0xc8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(200 as u32) ) } as u64;
	// 8286B29C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8286B2A0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8286B2A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8286B2A8: 80CB6820  lwz r6, 0x6820(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26656 as u32) ) } as u64;
	// 8286B2AC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8286B2B0: 4E800421  bctrl
	ctx.lr = 0x8286B2B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286B2B4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8286B2B8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8286B2BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286B2C0: 419A000C  beq cr6, 0x8286b2cc
	if ctx.cr[6].eq {
	pc = 0x8286B2CC; continue 'dispatch;
	}
	// 8286B2C4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8286B2C8: 4BA7CFA1  bl 0x822e8268
	ctx.lr = 0x8286B2CC;
	sub_822E8268(ctx, base);
	// 8286B2CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B2D0: 3B180004  addi r24, r24, 4
	ctx.r[24].s64 = ctx.r[24].s64 + 4;
	// 8286B2D4: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 8286B2D8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8286B2DC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8286B2E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8286B2E4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8286B2E8: 4BFFFE39  bl 0x8286b120
	ctx.lr = 0x8286B2EC;
	sub_8286B120(ctx, base);
	// 8286B2EC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8286B2F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8286B2F4: 4809DBBD  bl 0x82908eb0
	ctx.lr = 0x8286B2F8;
	sub_82908EB0(ctx, base);
	// 8286B2F8: 38802012  li r4, 0x2012
	ctx.r[4].s64 = 8210;
	// 8286B2FC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8286B300: 4BC23EB1  bl 0x8248f1b0
	ctx.lr = 0x8286B304;
	sub_8248F1B0(ctx, base);
	// 8286B304: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8286B308: 419A000C  beq cr6, 0x8286b314
	if ctx.cr[6].eq {
	pc = 0x8286B314; continue 'dispatch;
	}
	// 8286B30C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8286B310: 4BA7CF59  bl 0x822e8268
	ctx.lr = 0x8286B314;
	sub_822E8268(ctx, base);
	// 8286B314: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8286B318: 7C79D02E  lwzx r3, r25, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 8286B31C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 8286B320: 48635411  bl 0x82ea0730
	ctx.lr = 0x8286B324;
	sub_82EA0730(ctx, base);
	// 8286B324: B2C30004  sth r22, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[22].u16 ) };
	// 8286B328: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8286B32C: C1BB0000  lfs f13, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8286B330: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8286B334: 486AEEBD  bl 0x82f1a1f0
	ctx.lr = 0x8286B338;
	sub_82F1A1F0(ctx, base);
	// 8286B338: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 8286B33C: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 8286B340: 4182000C  beq 0x8286b34c
	if ctx.cr[0].eq {
	pc = 0x8286B34C; continue 'dispatch;
	}
	// 8286B344: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8286B348: 4BA7CF01  bl 0x822e8248
	ctx.lr = 0x8286B34C;
	sub_822E8248(ctx, base);
	// 8286B34C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8286B350: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B354: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 8286B358: 80970000  lwz r4, 0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 8286B35C: 485A9CD5  bl 0x82e15030
	ctx.lr = 0x8286B360;
	sub_82E15030(ctx, base);
	// 8286B360: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8286B364: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8286B368: 815D00C8  lwz r10, 0xc8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(200 as u32) ) } as u64;
	// 8286B36C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 8286B370: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 8286B374: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8286B378: 80CB681C  lwz r6, 0x681c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26652 as u32) ) } as u64;
	// 8286B37C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8286B380: 4E800421  bctrl
	ctx.lr = 0x8286B384;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8286B384: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8286B388: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8286B38C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286B390: 419A000C  beq cr6, 0x8286b39c
	if ctx.cr[6].eq {
	pc = 0x8286B39C; continue 'dispatch;
	}
	// 8286B394: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8286B398: 4BA7CED1  bl 0x822e8268
	ctx.lr = 0x8286B39C;
	sub_822E8268(ctx, base);
	// 8286B39C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8286B3A0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8286B3A4: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 8286B3A8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 8286B3AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8286B3B0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8286B3B4: 4BFFFD6D  bl 0x8286b120
	ctx.lr = 0x8286B3B8;
	sub_8286B120(ctx, base);
	// 8286B3B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8286B3BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8286B3C0: 4809DAF1  bl 0x82908eb0
	ctx.lr = 0x8286B3C4;
	sub_82908EB0(ctx, base);
	// 8286B3C4: 38802012  li r4, 0x2012
	ctx.r[4].s64 = 8210;
	// 8286B3C8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8286B3CC: 4BC23DE5  bl 0x8248f1b0
	ctx.lr = 0x8286B3D0;
	sub_8248F1B0(ctx, base);
	// 8286B3D0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8286B3D4: 419A000C  beq cr6, 0x8286b3e0
	if ctx.cr[6].eq {
	pc = 0x8286B3E0; continue 'dispatch;
	}
	// 8286B3D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8286B3DC: 4BA7CE8D  bl 0x822e8268
	ctx.lr = 0x8286B3E0;
	sub_822E8268(ctx, base);
	// 8286B3E0: 80770004  lwz r3, 4(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 8286B3E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8286B3E8: 419A0008  beq cr6, 0x8286b3f0
	if ctx.cr[6].eq {
	pc = 0x8286B3F0; continue 'dispatch;
	}
	// 8286B3EC: 4BA554A5  bl 0x822c0890
	ctx.lr = 0x8286B3F0;
	sub_822C0890(ctx, base);
	// 8286B3F0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8286B3F4: 4893CDAC  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286B3F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8286B3F8 size=60
    let mut pc: u32 = 0x8286B3F8;
    'dispatch: loop {
        match pc {
            0x8286B3F8 => {
    //   block [0x8286B3F8..0x8286B434)
	// 8286B3F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286B3FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8286B400: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8286B404: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286B408: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286B40C: 480ABACD  bl 0x82916ed8
	ctx.lr = 0x8286B410;
	sub_82916ED8(ctx, base);
	// 8286B410: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8286B414: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286B418: 396B13E4  addi r11, r11, 0x13e4
	ctx.r[11].s64 = ctx.r[11].s64 + 5092;
	// 8286B41C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8286B420: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8286B424: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286B428: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286B42C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286B430: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286B438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8286B438 size=28
    let mut pc: u32 = 0x8286B438;
    'dispatch: loop {
        match pc {
            0x8286B438 => {
    //   block [0x8286B438..0x8286B454)
	// 8286B438: 81630070  lwz r11, 0x70(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 8286B43C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8286B440: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 8286B444: 409A0008  bne cr6, 0x8286b44c
	if !ctx.cr[6].eq {
	pc = 0x8286B44C; continue 'dispatch;
	}
	// 8286B448: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8286B44C: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 8286B450: 4809DA08  b 0x82908e58
	sub_82908E58(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286B458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8286B458 size=88
    let mut pc: u32 = 0x8286B458;
    'dispatch: loop {
        match pc {
            0x8286B458 => {
    //   block [0x8286B458..0x8286B4B0)
	// 8286B458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286B45C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8286B460: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8286B464: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8286B468: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286B46C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286B470: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8286B474: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8286B478: 396B13E4  addi r11, r11, 0x13e4
	ctx.r[11].s64 = ctx.r[11].s64 + 5092;
	// 8286B47C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8286B480: 480AB6E9  bl 0x82916b68
	ctx.lr = 0x8286B484;
	sub_82916B68(ctx, base);
	// 8286B484: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8286B488: 4182000C  beq 0x8286b494
	if ctx.cr[0].eq {
	pc = 0x8286B494; continue 'dispatch;
	}
	// 8286B48C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286B490: 4BA54DD9  bl 0x822c0268
	ctx.lr = 0x8286B494;
	sub_822C0268(ctx, base);
	// 8286B494: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8286B498: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8286B49C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8286B4A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8286B4A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8286B4A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8286B4AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286B4B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8286B4B0 size=152
    let mut pc: u32 = 0x8286B4B0;
    'dispatch: loop {
        match pc {
            0x8286B4B0 => {
    //   block [0x8286B4B0..0x8286B548)
	// 8286B4B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8286B4B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8286B4B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8286B4BC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8286B4C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8286B4C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8286B4C8: 480AB8D1  bl 0x82916d98
	ctx.lr = 0x8286B4CC;
	sub_82916D98(ctx, base);
	// 8286B4CC: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8286B4D0: 396000D0  li r11, 0xd0
	ctx.r[11].s64 = 208;
	// 8286B4D4: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8286B4D8: 13E958C7  vcmpequd (lvx128) v31, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8286B548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8286B548 size=16
    let mut pc: u32 = 0x8286B548;
    'dispatch: loop {
        match pc {
            0x8286B548 => {
    //   block [0x8286B548..0x8286B558)
	// 8286B548: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8286B54C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8286B550: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8286B554: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


