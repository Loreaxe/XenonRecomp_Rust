pub fn sub_82AC5F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC5F18 size=68
    let mut pc: u32 = 0x82AC5F18;
    'dispatch: loop {
        match pc {
            0x82AC5F18 => {
    //   block [0x82AC5F18..0x82AC5F5C)
	// 82AC5F18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC5F1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC5F20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC5F24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC5F28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC5F2C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC5F30: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82AC5F34: 396B97A0  addi r11, r11, -0x6860
	ctx.r[11].s64 = ctx.r[11].s64 + -26720;
	// 82AC5F38: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC5F3C: 41820008  beq 0x82ac5f44
	if ctx.cr[0].eq {
	pc = 0x82AC5F44; continue 'dispatch;
	}
	// 82AC5F40: 4B7FA329  bl 0x822c0268
	ctx.lr = 0x82AC5F44;
	sub_822C0268(ctx, base);
	// 82AC5F44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC5F48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AC5F4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC5F50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC5F54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC5F58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC5F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC5F60 size=56
    let mut pc: u32 = 0x82AC5F60;
    'dispatch: loop {
        match pc {
            0x82AC5F60 => {
    //   block [0x82AC5F60..0x82AC5F98)
	// 82AC5F60: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82AC5F64: 81240018  lwz r9, 0x18(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AC5F68: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82AC5F6C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC5F70: 394AE644  addi r10, r10, -0x19bc
	ctx.r[10].s64 = ctx.r[10].s64 + -6588;
	// 82AC5F74: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC5F78: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82AC5F7C: 419A001C  beq cr6, 0x82ac5f98
	if ctx.cr[6].eq {
		sub_82AC5F98(ctx, base);
		return;
	}
	// 82AC5F80: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82AC5F84: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 82AC5F88: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC5F8C: 4198FFE8  blt cr6, 0x82ac5f74
	if ctx.cr[6].lt {
	pc = 0x82AC5F74; continue 'dispatch;
	}
	// 82AC5F90: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC5F94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC5F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC5F98 size=24
    let mut pc: u32 = 0x82AC5F98;
    'dispatch: loop {
        match pc {
            0x82AC5F98 => {
    //   block [0x82AC5F98..0x82AC5FB0)
	// 82AC5F98: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82AC5F9C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AC5FA0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AC5FA4: 7D6B402E  lwzx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82AC5FA8: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC5FAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC5FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC5FB0 size=636
    let mut pc: u32 = 0x82AC5FB0;
    'dispatch: loop {
        match pc {
            0x82AC5FB0 => {
    //   block [0x82AC5FB0..0x82AC622C)
	// 82AC5FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC5FB4: 486E21A1  bl 0x831a8154
	ctx.lr = 0x82AC5FB8;
	sub_831A8130(ctx, base);
	// 82AC5FB8: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC5FBC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82AC5FC0: 807A0004  lwz r3, 4(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC5FC4: 4BF4D6D5  bl 0x82a13698
	ctx.lr = 0x82AC5FC8;
	sub_82A13698(ctx, base);
	// 82AC5FC8: 807A0004  lwz r3, 4(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC5FCC: 4BF4CEED  bl 0x82a12eb8
	ctx.lr = 0x82AC5FD0;
	sub_82A12EB8(ctx, base);
	// 82AC5FD0: 4BF52F39  bl 0x82a18f08
	ctx.lr = 0x82AC5FD4;
	sub_82A18F08(ctx, base);
	// 82AC5FD4: 83030004  lwz r24, 4(r3)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC5FD8: 83230000  lwz r25, 0(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC5FDC: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82AC5FE0: 419A0024  beq cr6, 0x82ac6004
	if ctx.cr[6].eq {
	pc = 0x82AC6004; continue 'dispatch;
	}
	// 82AC5FE4: 39780004  addi r11, r24, 4
	ctx.r[11].s64 = ctx.r[24].s64 + 4;
	// 82AC5FE8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC5FEC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC5FF0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC5FF4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC5FF8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC5FFC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC6000: 4082FFE8  bne 0x82ac5fe8
	if !ctx.cr[0].eq {
	pc = 0x82AC5FE8; continue 'dispatch;
	}
	// 82AC6004: 83AD0000  lwz r29, 0(r13)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC6008: 3B800014  li r28, 0x14
	ctx.r[28].s64 = 20;
	// 82AC600C: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82AC6010: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82AC6014: 7C7CE82E  lwzx r3, r28, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82AC6018: 483DA719  bl 0x82ea0730
	ctx.lr = 0x82AC601C;
	sub_82EA0730(ctx, base);
	// 82AC601C: 3B600020  li r27, 0x20
	ctx.r[27].s64 = 32;
	// 82AC6020: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AC6024: B3630004  sth r27, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[27].u16 ) };
	// 82AC6028: 3BCBE644  addi r30, r11, -0x19bc
	ctx.r[30].s64 = ctx.r[11].s64 + -6588;
	// 82AC602C: C03E0008  lfs f1, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC6030: 484541C1  bl 0x82f1a1f0
	ctx.lr = 0x82AC6034;
	sub_82F1A1F0(ctx, base);
	// 82AC6034: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC6038: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC603C: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC6040: 4832D9C9  bl 0x82df3a08
	ctx.lr = 0x82AC6044;
	sub_82DF3A08(ctx, base);
	// 82AC6044: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AC6048: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82AC604C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AC6050: 4834EFE1  bl 0x82e15030
	ctx.lr = 0x82AC6054;
	sub_82E15030(ctx, base);
	// 82AC6054: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC6058: 4832D3D1  bl 0x82df3428
	ctx.lr = 0x82AC605C;
	sub_82DF3428(ctx, base);
	// 82AC605C: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82AC6060: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC6064: 419A000C  beq cr6, 0x82ac6070
	if ctx.cr[6].eq {
	pc = 0x82AC6070; continue 'dispatch;
	}
	// 82AC6068: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC606C: 4B8221DD  bl 0x822e8248
	ctx.lr = 0x82AC6070;
	sub_822E8248(ctx, base);
	// 82AC6070: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 82AC6074: 3AE10068  addi r23, r1, 0x68
	ctx.r[23].s64 = ctx.r[1].s64 + 104;
	// 82AC6078: 4BFE8A21  bl 0x82aaea98
	ctx.lr = 0x82AC607C;
	sub_82AAEA98(ctx, base);
	// 82AC607C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AC6080: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC6084: 807A0004  lwz r3, 4(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC6088: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 82AC608C: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 82AC6090: 4BFE6921  bl 0x82aac9b0
	ctx.lr = 0x82AC6094;
	sub_82AAC9B0(ctx, base);
	// 82AC6094: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AC6098: 907A0008  stw r3, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82AC609C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC60A0: 419A000C  beq cr6, 0x82ac60ac
	if ctx.cr[6].eq {
	pc = 0x82AC60AC; continue 'dispatch;
	}
	// 82AC60A4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AC60A8: 4B8221C1  bl 0x822e8268
	ctx.lr = 0x82AC60AC;
	sub_822E8268(ctx, base);
	// 82AC60AC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AC60B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC60B4: 419A0008  beq cr6, 0x82ac60bc
	if ctx.cr[6].eq {
	pc = 0x82AC60BC; continue 'dispatch;
	}
	// 82AC60B8: 4B7FA7D9  bl 0x822c0890
	ctx.lr = 0x82AC60BC;
	sub_822C0890(ctx, base);
	// 82AC60BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC60C0: 419A000C  beq cr6, 0x82ac60cc
	if ctx.cr[6].eq {
	pc = 0x82AC60CC; continue 'dispatch;
	}
	// 82AC60C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC60C8: 4B8221A1  bl 0x822e8268
	ctx.lr = 0x82AC60CC;
	sub_822E8268(ctx, base);
	// 82AC60CC: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82AC60D0: 7C7CE82E  lwzx r3, r28, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82AC60D4: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82AC60D8: 483DA659  bl 0x82ea0730
	ctx.lr = 0x82AC60DC;
	sub_82EA0730(ctx, base);
	// 82AC60DC: B3630004  sth r27, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[27].u16 ) };
	// 82AC60E0: C03E000C  lfs f1, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC60E4: 4845410D  bl 0x82f1a1f0
	ctx.lr = 0x82AC60E8;
	sub_82F1A1F0(ctx, base);
	// 82AC60E8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AC60EC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AC60F0: 484068F9  bl 0x82ecc9e8
	ctx.lr = 0x82AC60F4;
	sub_82ECC9E8(ctx, base);
	// 82AC60F4: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 82AC60F8: 93610084  stw r27, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 82AC60FC: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 82AC6100: 99610130  stb r11, 0x130(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[11].u8 ) };
	// 82AC6104: 38800200  li r4, 0x200
	ctx.r[4].s64 = 512;
	// 82AC6108: 7C7CE82E  lwzx r3, r28, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82AC610C: 483DA625  bl 0x82ea0730
	ctx.lr = 0x82AC6110;
	sub_82EA0730(ctx, base);
	// 82AC6110: 39600200  li r11, 0x200
	ctx.r[11].s64 = 512;
	// 82AC6114: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82AC6118: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 82AC611C: 484057C5  bl 0x82ecb8e0
	ctx.lr = 0x82AC6120;
	sub_82ECB8E0(ctx, base);
	// 82AC6120: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82AC6124: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC6128: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC612C: 388B97A8  addi r4, r11, -0x6858
	ctx.r[4].s64 = ctx.r[11].s64 + -26712;
	// 82AC6130: 38A00078  li r5, 0x78
	ctx.r[5].s64 = 120;
	// 82AC6134: 38600110  li r3, 0x110
	ctx.r[3].s64 = 272;
	// 82AC6138: 4832C2B1  bl 0x82df23e8
	ctx.lr = 0x82AC613C;
	sub_82DF23E8(ctx, base);
	// 82AC613C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC6140: 41820028  beq 0x82ac6168
	if ctx.cr[0].eq {
	pc = 0x82AC6168; continue 'dispatch;
	}
	// 82AC6144: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC6148: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC614C: 388B0028  addi r4, r11, 0x28
	ctx.r[4].s64 = ctx.r[11].s64 + 40;
	// 82AC6150: 409A0008  bne cr6, 0x82ac6158
	if !ctx.cr[6].eq {
	pc = 0x82AC6158; continue 'dispatch;
	}
	// 82AC6154: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC6158: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82AC615C: 4B827D55  bl 0x822edeb0
	ctx.lr = 0x82AC6160;
	sub_822EDEB0(ctx, base);
	// 82AC6160: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC6164: 48000008  b 0x82ac616c
	pc = 0x82AC616C; continue 'dispatch;
	// 82AC6168: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC616C: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82AC6170: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC6174: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AC6178: 4B827A11  bl 0x822edb88
	ctx.lr = 0x82AC617C;
	sub_822EDB88(ctx, base);
	// 82AC617C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC6180: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC6184: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AC6188: 4B7F9E79  bl 0x822c0000
	ctx.lr = 0x82AC618C;
	sub_822C0000(ctx, base);
	// 82AC618C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC6190: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC6194: 4832D875  bl 0x82df3a08
	ctx.lr = 0x82AC6198;
	sub_82DF3A08(ctx, base);
	// 82AC6198: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AC619C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82AC61A0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AC61A4: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AC61A8: 4834EE89  bl 0x82e15030
	ctx.lr = 0x82AC61AC;
	sub_82E15030(ctx, base);
	// 82AC61AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC61B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC61B4: 4B827DAD  bl 0x822edf60
	ctx.lr = 0x82AC61B8;
	sub_822EDF60(ctx, base);
	// 82AC61B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC61BC: 4832D26D  bl 0x82df3428
	ctx.lr = 0x82AC61C0;
	sub_82DF3428(ctx, base);
	// 82AC61C0: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 82AC61C4: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AC61C8: 4BFE88D1  bl 0x82aaea98
	ctx.lr = 0x82AC61CC;
	sub_82AAEA98(ctx, base);
	// 82AC61CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC61D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC61D4: 4B9C91CD  bl 0x8248f3a0
	ctx.lr = 0x82AC61D8;
	sub_8248F3A0(ctx, base);
	// 82AC61D8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AC61DC: 807A0004  lwz r3, 4(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC61E0: 4BA4AB61  bl 0x82510d40
	ctx.lr = 0x82AC61E4;
	sub_82510D40(ctx, base);
	// 82AC61E4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AC61E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC61EC: 419A0008  beq cr6, 0x82ac61f4
	if ctx.cr[6].eq {
	pc = 0x82AC61F4; continue 'dispatch;
	}
	// 82AC61F0: 4B7FA6A1  bl 0x822c0890
	ctx.lr = 0x82AC61F4;
	sub_822C0890(ctx, base);
	// 82AC61F4: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AC61F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC61FC: 419A0008  beq cr6, 0x82ac6204
	if ctx.cr[6].eq {
	pc = 0x82AC6204; continue 'dispatch;
	}
	// 82AC6200: 4B822069  bl 0x822e8268
	ctx.lr = 0x82AC6204;
	sub_822E8268(ctx, base);
	// 82AC6204: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82AC6208: 419A000C  beq cr6, 0x82ac6214
	if ctx.cr[6].eq {
	pc = 0x82AC6214; continue 'dispatch;
	}
	// 82AC620C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AC6210: 4B822059  bl 0x822e8268
	ctx.lr = 0x82AC6214;
	sub_822E8268(ctx, base);
	// 82AC6214: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82AC6218: 419A000C  beq cr6, 0x82ac6224
	if ctx.cr[6].eq {
	pc = 0x82AC6224; continue 'dispatch;
	}
	// 82AC621C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82AC6220: 4B7FA671  bl 0x822c0890
	ctx.lr = 0x82AC6224;
	sub_822C0890(ctx, base);
	// 82AC6224: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 82AC6228: 486E1F7C  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC6230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC6230 size=120
    let mut pc: u32 = 0x82AC6230;
    'dispatch: loop {
        match pc {
            0x82AC6230 => {
    //   block [0x82AC6230..0x82AC62A8)
	// 82AC6230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC6234: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC6238: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC623C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC6240: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC6244: 897F000C  lbz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AC6248: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC624C: 40820048  bne 0x82ac6294
	if !ctx.cr[0].eq {
	pc = 0x82AC6294; continue 'dispatch;
	}
	// 82AC6250: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC6254: 4BF4CC65  bl 0x82a12eb8
	ctx.lr = 0x82AC6258;
	sub_82A12EB8(ctx, base);
	// 82AC6258: 4BD2E189  bl 0x827f43e0
	ctx.lr = 0x82AC625C;
	sub_827F43E0(ctx, base);
	// 82AC625C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC6260: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC6264: 419A0030  beq cr6, 0x82ac6294
	if ctx.cr[6].eq {
	pc = 0x82AC6294; continue 'dispatch;
	}
	// 82AC6268: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC626C: 4BF4CC4D  bl 0x82a12eb8
	ctx.lr = 0x82AC6270;
	sub_82A12EB8(ctx, base);
	// 82AC6270: 4BD2E171  bl 0x827f43e0
	ctx.lr = 0x82AC6274;
	sub_827F43E0(ctx, base);
	// 82AC6274: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC6278: 480EE5A1  bl 0x82bb4818
	ctx.lr = 0x82AC627C;
	sub_82BB4818(ctx, base);
	// 82AC627C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC6280: 41820014  beq 0x82ac6294
	if ctx.cr[0].eq {
	pc = 0x82AC6294; continue 'dispatch;
	}
	// 82AC6284: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC6288: 4BFFFD29  bl 0x82ac5fb0
	ctx.lr = 0x82AC628C;
	sub_82AC5FB0(ctx, base);
	// 82AC628C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AC6290: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82AC6294: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AC6298: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC629C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC62A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC62A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC62A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC62A8 size=88
    let mut pc: u32 = 0x82AC62A8;
    'dispatch: loop {
        match pc {
            0x82AC62A8 => {
    //   block [0x82AC62A8..0x82AC6300)
	// 82AC62A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC62AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC62B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC62B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC62B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC62BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC62C0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC62C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC62C8: 396B9800  addi r11, r11, -0x6800
	ctx.r[11].s64 = ctx.r[11].s64 + -26624;
	// 82AC62CC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC62D0: 48397579  bl 0x82e5d848
	ctx.lr = 0x82AC62D4;
	sub_82E5D848(ctx, base);
	// 82AC62D4: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC62D8: 4182000C  beq 0x82ac62e4
	if ctx.cr[0].eq {
	pc = 0x82AC62E4; continue 'dispatch;
	}
	// 82AC62DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC62E0: 4832C0F9  bl 0x82df23d8
	ctx.lr = 0x82AC62E4;
	sub_82DF23D8(ctx, base);
	// 82AC62E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC62E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC62EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC62F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC62F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC62F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC62FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC6300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC6300 size=196
    let mut pc: u32 = 0x82AC6300;
    'dispatch: loop {
        match pc {
            0x82AC6300 => {
    //   block [0x82AC6300..0x82AC63C4)
	// 82AC6300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC6304: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC6308: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC630C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC6310: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC6314: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC6318: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC631C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AC6320: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC6324: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC6328: 4B7FA611  bl 0x822c0938
	ctx.lr = 0x82AC632C;
	sub_822C0938(ctx, base);
	// 82AC632C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC6330: 41820028  beq 0x82ac6358
	if ctx.cr[0].eq {
	pc = 0x82AC6358; continue 'dispatch;
	}
	// 82AC6334: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC6338: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AC633C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AC6340: 392B9810  addi r9, r11, -0x67f0
	ctx.r[9].s64 = ctx.r[11].s64 + -26608;
	// 82AC6344: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AC6348: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC634C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC6350: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AC6354: 48000008  b 0x82ac635c
	pc = 0x82AC635C; continue 'dispatch;
	// 82AC6358: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC635C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC6360: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC6364: 409A0044  bne cr6, 0x82ac63a8
	if !ctx.cr[6].eq {
	pc = 0x82AC63A8; continue 'dispatch;
	}
	// 82AC6368: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC636C: 419A001C  beq cr6, 0x82ac6388
	if ctx.cr[6].eq {
	pc = 0x82AC6388; continue 'dispatch;
	}
	// 82AC6370: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC6374: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC6378: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC637C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC6380: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC6384: 4E800421  bctrl
	ctx.lr = 0x82AC6388;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC6388: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC638C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC6390: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC6394: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AC6398: 816BFE90  lwz r11, -0x170(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-368 as u32) ) } as u64;
	// 82AC639C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AC63A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC63A4: 4B7F9C5D  bl 0x822c0000
	ctx.lr = 0x82AC63A8;
	sub_822C0000(ctx, base);
	// 82AC63A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC63AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC63B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC63B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC63B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC63BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC63C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC63C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC63C8 size=196
    let mut pc: u32 = 0x82AC63C8;
    'dispatch: loop {
        match pc {
            0x82AC63C8 => {
    //   block [0x82AC63C8..0x82AC648C)
	// 82AC63C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC63CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC63D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC63D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC63D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC63DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC63E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC63E4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AC63E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC63EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC63F0: 4B7FA549  bl 0x822c0938
	ctx.lr = 0x82AC63F4;
	sub_822C0938(ctx, base);
	// 82AC63F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC63F8: 41820028  beq 0x82ac6420
	if ctx.cr[0].eq {
	pc = 0x82AC6420; continue 'dispatch;
	}
	// 82AC63FC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC6400: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AC6404: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AC6408: 392B9824  addi r9, r11, -0x67dc
	ctx.r[9].s64 = ctx.r[11].s64 + -26588;
	// 82AC640C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AC6410: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC6414: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC6418: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AC641C: 48000008  b 0x82ac6424
	pc = 0x82AC6424; continue 'dispatch;
	// 82AC6420: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC6424: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC6428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC642C: 409A0044  bne cr6, 0x82ac6470
	if !ctx.cr[6].eq {
	pc = 0x82AC6470; continue 'dispatch;
	}
	// 82AC6430: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC6434: 419A001C  beq cr6, 0x82ac6450
	if ctx.cr[6].eq {
	pc = 0x82AC6450; continue 'dispatch;
	}
	// 82AC6438: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC643C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC6440: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC6444: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC6448: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC644C: 4E800421  bctrl
	ctx.lr = 0x82AC6450;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC6450: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC6454: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC6458: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC645C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AC6460: 816BFE90  lwz r11, -0x170(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-368 as u32) ) } as u64;
	// 82AC6464: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AC6468: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC646C: 4B7F9B95  bl 0x822c0000
	ctx.lr = 0x82AC6470;
	sub_822C0000(ctx, base);
	// 82AC6470: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC6474: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC6478: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC647C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC6480: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC6484: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC6488: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC6490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC6490 size=196
    let mut pc: u32 = 0x82AC6490;
    'dispatch: loop {
        match pc {
            0x82AC6490 => {
    //   block [0x82AC6490..0x82AC6554)
	// 82AC6490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC6494: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC6498: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC649C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC64A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC64A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC64A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC64AC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AC64B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC64B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC64B8: 4B7FA481  bl 0x822c0938
	ctx.lr = 0x82AC64BC;
	sub_822C0938(ctx, base);
	// 82AC64BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC64C0: 41820028  beq 0x82ac64e8
	if ctx.cr[0].eq {
	pc = 0x82AC64E8; continue 'dispatch;
	}
	// 82AC64C4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC64C8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AC64CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AC64D0: 392B9838  addi r9, r11, -0x67c8
	ctx.r[9].s64 = ctx.r[11].s64 + -26568;
	// 82AC64D4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AC64D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC64DC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC64E0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AC64E4: 48000008  b 0x82ac64ec
	pc = 0x82AC64EC; continue 'dispatch;
	// 82AC64E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC64EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC64F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC64F4: 409A0044  bne cr6, 0x82ac6538
	if !ctx.cr[6].eq {
	pc = 0x82AC6538; continue 'dispatch;
	}
	// 82AC64F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC64FC: 419A001C  beq cr6, 0x82ac6518
	if ctx.cr[6].eq {
	pc = 0x82AC6518; continue 'dispatch;
	}
	// 82AC6500: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC6504: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC6508: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC650C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC6510: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC6514: 4E800421  bctrl
	ctx.lr = 0x82AC6518;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC6518: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC651C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC6520: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC6524: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AC6528: 816BFE90  lwz r11, -0x170(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-368 as u32) ) } as u64;
	// 82AC652C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AC6530: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC6534: 4B7F9ACD  bl 0x822c0000
	ctx.lr = 0x82AC6538;
	sub_822C0000(ctx, base);
	// 82AC6538: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC653C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC6540: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC6544: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC6548: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC654C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC6550: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC6558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC6558 size=196
    let mut pc: u32 = 0x82AC6558;
    'dispatch: loop {
        match pc {
            0x82AC6558 => {
    //   block [0x82AC6558..0x82AC661C)
	// 82AC6558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC655C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC6560: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC6564: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC6568: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC656C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC6570: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC6574: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AC6578: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC657C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC6580: 4B7FA3B9  bl 0x822c0938
	ctx.lr = 0x82AC6584;
	sub_822C0938(ctx, base);
	// 82AC6584: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC6588: 41820028  beq 0x82ac65b0
	if ctx.cr[0].eq {
	pc = 0x82AC65B0; continue 'dispatch;
	}
	// 82AC658C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC6590: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AC6594: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AC6598: 392B984C  addi r9, r11, -0x67b4
	ctx.r[9].s64 = ctx.r[11].s64 + -26548;
	// 82AC659C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AC65A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC65A4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC65A8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AC65AC: 48000008  b 0x82ac65b4
	pc = 0x82AC65B4; continue 'dispatch;
	// 82AC65B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC65B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC65B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC65BC: 409A0044  bne cr6, 0x82ac6600
	if !ctx.cr[6].eq {
	pc = 0x82AC6600; continue 'dispatch;
	}
	// 82AC65C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC65C4: 419A001C  beq cr6, 0x82ac65e0
	if ctx.cr[6].eq {
	pc = 0x82AC65E0; continue 'dispatch;
	}
	// 82AC65C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC65CC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC65D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC65D4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC65D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC65DC: 4E800421  bctrl
	ctx.lr = 0x82AC65E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC65E0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC65E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC65E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC65EC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AC65F0: 816BFE90  lwz r11, -0x170(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-368 as u32) ) } as u64;
	// 82AC65F4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AC65F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC65FC: 4B7F9A05  bl 0x822c0000
	ctx.lr = 0x82AC6600;
	sub_822C0000(ctx, base);
	// 82AC6600: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC6604: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC6608: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC660C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC6610: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC6614: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC6618: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC6620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC6620 size=196
    let mut pc: u32 = 0x82AC6620;
    'dispatch: loop {
        match pc {
            0x82AC6620 => {
    //   block [0x82AC6620..0x82AC66E4)
	// 82AC6620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC6624: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC6628: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC662C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC6630: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC6634: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC6638: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC663C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AC6640: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC6644: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC6648: 4B7FA2F1  bl 0x822c0938
	ctx.lr = 0x82AC664C;
	sub_822C0938(ctx, base);
	// 82AC664C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC6650: 41820028  beq 0x82ac6678
	if ctx.cr[0].eq {
	pc = 0x82AC6678; continue 'dispatch;
	}
	// 82AC6654: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC6658: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AC665C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AC6660: 392B9860  addi r9, r11, -0x67a0
	ctx.r[9].s64 = ctx.r[11].s64 + -26528;
	// 82AC6664: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AC6668: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC666C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC6670: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AC6674: 48000008  b 0x82ac667c
	pc = 0x82AC667C; continue 'dispatch;
	// 82AC6678: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC667C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC6680: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC6684: 409A0044  bne cr6, 0x82ac66c8
	if !ctx.cr[6].eq {
	pc = 0x82AC66C8; continue 'dispatch;
	}
	// 82AC6688: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC668C: 419A001C  beq cr6, 0x82ac66a8
	if ctx.cr[6].eq {
	pc = 0x82AC66A8; continue 'dispatch;
	}
	// 82AC6690: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC6694: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC6698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC669C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC66A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC66A4: 4E800421  bctrl
	ctx.lr = 0x82AC66A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC66A8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC66AC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC66B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC66B4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AC66B8: 816BFE90  lwz r11, -0x170(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-368 as u32) ) } as u64;
	// 82AC66BC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AC66C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC66C4: 4B7F993D  bl 0x822c0000
	ctx.lr = 0x82AC66C8;
	sub_822C0000(ctx, base);
	// 82AC66C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC66CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC66D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC66D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC66D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC66DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC66E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC66E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC66E8 size=196
    let mut pc: u32 = 0x82AC66E8;
    'dispatch: loop {
        match pc {
            0x82AC66E8 => {
    //   block [0x82AC66E8..0x82AC67AC)
	// 82AC66E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC66EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC66F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC66F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC66F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC66FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC6700: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC6704: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AC6708: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC670C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC6710: 4B7FA229  bl 0x822c0938
	ctx.lr = 0x82AC6714;
	sub_822C0938(ctx, base);
	// 82AC6714: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC6718: 41820028  beq 0x82ac6740
	if ctx.cr[0].eq {
	pc = 0x82AC6740; continue 'dispatch;
	}
	// 82AC671C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC6720: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AC6724: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AC6728: 392B9874  addi r9, r11, -0x678c
	ctx.r[9].s64 = ctx.r[11].s64 + -26508;
	// 82AC672C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AC6730: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC6734: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC6738: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AC673C: 48000008  b 0x82ac6744
	pc = 0x82AC6744; continue 'dispatch;
	// 82AC6740: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC6744: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC6748: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC674C: 409A0044  bne cr6, 0x82ac6790
	if !ctx.cr[6].eq {
	pc = 0x82AC6790; continue 'dispatch;
	}
	// 82AC6750: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC6754: 419A001C  beq cr6, 0x82ac6770
	if ctx.cr[6].eq {
	pc = 0x82AC6770; continue 'dispatch;
	}
	// 82AC6758: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC675C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC6760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC6764: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC6768: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC676C: 4E800421  bctrl
	ctx.lr = 0x82AC6770;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC6770: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC6774: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC6778: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC677C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AC6780: 816BFE90  lwz r11, -0x170(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-368 as u32) ) } as u64;
	// 82AC6784: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AC6788: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC678C: 4B7F9875  bl 0x822c0000
	ctx.lr = 0x82AC6790;
	sub_822C0000(ctx, base);
	// 82AC6790: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC6794: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC6798: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC679C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC67A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC67A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC67A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC67B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC67B0 size=112
    let mut pc: u32 = 0x82AC67B0;
    'dispatch: loop {
        match pc {
            0x82AC67B0 => {
    //   block [0x82AC67B0..0x82AC6820)
	// 82AC67B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC67B4: 486E19B9  bl 0x831a816c
	ctx.lr = 0x82AC67B8;
	sub_831A8130(ctx, base);
	// 82AC67B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC67BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC67C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC67C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC67C8: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82AC67CC: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82AC67D0: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 82AC67D4: 4832BC15  bl 0x82df23e8
	ctx.lr = 0x82AC67D8;
	sub_82DF23E8(ctx, base);
	// 82AC67D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC67DC: 41820010  beq 0x82ac67ec
	if ctx.cr[0].eq {
	pc = 0x82AC67EC; continue 'dispatch;
	}
	// 82AC67E0: 48001F51  bl 0x82ac8730
	ctx.lr = 0x82AC67E4;
	sub_82AC8730(ctx, base);
	// 82AC67E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC67E8: 48000008  b 0x82ac67f0
	pc = 0x82AC67F0; continue 'dispatch;
	// 82AC67EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC67F0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AC67F4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AC67F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC67FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC6800: 4BFFFB01  bl 0x82ac6300
	ctx.lr = 0x82AC6804;
	sub_82AC6300(ctx, base);
	// 82AC6804: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC6808: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC680C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC6810: 4B7F97F1  bl 0x822c0000
	ctx.lr = 0x82AC6814;
	sub_822C0000(ctx, base);
	// 82AC6814: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC6818: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC681C: 486E19A0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC6820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC6820 size=112
    let mut pc: u32 = 0x82AC6820;
    'dispatch: loop {
        match pc {
            0x82AC6820 => {
    //   block [0x82AC6820..0x82AC6890)
	// 82AC6820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC6824: 486E1949  bl 0x831a816c
	ctx.lr = 0x82AC6828;
	sub_831A8130(ctx, base);
	// 82AC6828: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC682C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC6830: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC6834: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC6838: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82AC683C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82AC6840: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82AC6844: 4832BBA5  bl 0x82df23e8
	ctx.lr = 0x82AC6848;
	sub_82DF23E8(ctx, base);
	// 82AC6848: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC684C: 41820010  beq 0x82ac685c
	if ctx.cr[0].eq {
	pc = 0x82AC685C; continue 'dispatch;
	}
	// 82AC6850: 48000589  bl 0x82ac6dd8
	ctx.lr = 0x82AC6854;
	sub_82AC6DD8(ctx, base);
	// 82AC6854: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC6858: 48000008  b 0x82ac6860
	pc = 0x82AC6860; continue 'dispatch;
	// 82AC685C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC6860: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AC6864: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AC6868: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC686C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC6870: 4BFFFB59  bl 0x82ac63c8
	ctx.lr = 0x82AC6874;
	sub_82AC63C8(ctx, base);
	// 82AC6874: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC6878: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC687C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC6880: 4B7F9781  bl 0x822c0000
	ctx.lr = 0x82AC6884;
	sub_822C0000(ctx, base);
	// 82AC6884: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC6888: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC688C: 486E1930  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC6890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC6890 size=112
    let mut pc: u32 = 0x82AC6890;
    'dispatch: loop {
        match pc {
            0x82AC6890 => {
    //   block [0x82AC6890..0x82AC6900)
	// 82AC6890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC6894: 486E18D9  bl 0x831a816c
	ctx.lr = 0x82AC6898;
	sub_831A8130(ctx, base);
	// 82AC6898: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC689C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC68A0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC68A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC68A8: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82AC68AC: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82AC68B0: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 82AC68B4: 4832BB35  bl 0x82df23e8
	ctx.lr = 0x82AC68B8;
	sub_82DF23E8(ctx, base);
	// 82AC68B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC68BC: 41820010  beq 0x82ac68cc
	if ctx.cr[0].eq {
	pc = 0x82AC68CC; continue 'dispatch;
	}
	// 82AC68C0: 48002541  bl 0x82ac8e00
	ctx.lr = 0x82AC68C4;
	sub_82AC8E00(ctx, base);
	// 82AC68C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC68C8: 48000008  b 0x82ac68d0
	pc = 0x82AC68D0; continue 'dispatch;
	// 82AC68CC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC68D0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AC68D4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AC68D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC68DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC68E0: 4BFFFBB1  bl 0x82ac6490
	ctx.lr = 0x82AC68E4;
	sub_82AC6490(ctx, base);
	// 82AC68E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC68E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC68EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC68F0: 4B7F9711  bl 0x822c0000
	ctx.lr = 0x82AC68F4;
	sub_822C0000(ctx, base);
	// 82AC68F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC68F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC68FC: 486E18C0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC6900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC6900 size=112
    let mut pc: u32 = 0x82AC6900;
    'dispatch: loop {
        match pc {
            0x82AC6900 => {
    //   block [0x82AC6900..0x82AC6970)
	// 82AC6900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC6904: 486E1869  bl 0x831a816c
	ctx.lr = 0x82AC6908;
	sub_831A8130(ctx, base);
	// 82AC6908: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC690C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC6910: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC6914: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC6918: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82AC691C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82AC6920: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 82AC6924: 4832BAC5  bl 0x82df23e8
	ctx.lr = 0x82AC6928;
	sub_82DF23E8(ctx, base);
	// 82AC6928: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC692C: 41820010  beq 0x82ac693c
	if ctx.cr[0].eq {
	pc = 0x82AC693C; continue 'dispatch;
	}
	// 82AC6930: 48001499  bl 0x82ac7dc8
	ctx.lr = 0x82AC6934;
	sub_82AC7DC8(ctx, base);
	// 82AC6934: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC6938: 48000008  b 0x82ac6940
	pc = 0x82AC6940; continue 'dispatch;
	// 82AC693C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC6940: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AC6944: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AC6948: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC694C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC6950: 4BFFFC09  bl 0x82ac6558
	ctx.lr = 0x82AC6954;
	sub_82AC6558(ctx, base);
	// 82AC6954: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC6958: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC695C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC6960: 4B7F96A1  bl 0x822c0000
	ctx.lr = 0x82AC6964;
	sub_822C0000(ctx, base);
	// 82AC6964: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC6968: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC696C: 486E1850  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC6970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC6970 size=112
    let mut pc: u32 = 0x82AC6970;
    'dispatch: loop {
        match pc {
            0x82AC6970 => {
    //   block [0x82AC6970..0x82AC69E0)
	// 82AC6970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC6974: 486E17F9  bl 0x831a816c
	ctx.lr = 0x82AC6978;
	sub_831A8130(ctx, base);
	// 82AC6978: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC697C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC6980: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC6984: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC6988: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82AC698C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82AC6990: 38600074  li r3, 0x74
	ctx.r[3].s64 = 116;
	// 82AC6994: 4832BA55  bl 0x82df23e8
	ctx.lr = 0x82AC6998;
	sub_82DF23E8(ctx, base);
	// 82AC6998: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC699C: 41820010  beq 0x82ac69ac
	if ctx.cr[0].eq {
	pc = 0x82AC69AC; continue 'dispatch;
	}
	// 82AC69A0: 48001DF1  bl 0x82ac8790
	ctx.lr = 0x82AC69A4;
	sub_82AC8790(ctx, base);
	// 82AC69A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC69A8: 48000008  b 0x82ac69b0
	pc = 0x82AC69B0; continue 'dispatch;
	// 82AC69AC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC69B0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AC69B4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AC69B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC69BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC69C0: 4BFFFC61  bl 0x82ac6620
	ctx.lr = 0x82AC69C4;
	sub_82AC6620(ctx, base);
	// 82AC69C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC69C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC69CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC69D0: 4B7F9631  bl 0x822c0000
	ctx.lr = 0x82AC69D4;
	sub_822C0000(ctx, base);
	// 82AC69D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC69D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC69DC: 486E17E0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC69E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC69E0 size=112
    let mut pc: u32 = 0x82AC69E0;
    'dispatch: loop {
        match pc {
            0x82AC69E0 => {
    //   block [0x82AC69E0..0x82AC6A50)
	// 82AC69E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC69E4: 486E1789  bl 0x831a816c
	ctx.lr = 0x82AC69E8;
	sub_831A8130(ctx, base);
	// 82AC69E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC69EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC69F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC69F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC69F8: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82AC69FC: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82AC6A00: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 82AC6A04: 4832B9E5  bl 0x82df23e8
	ctx.lr = 0x82AC6A08;
	sub_82DF23E8(ctx, base);
	// 82AC6A08: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC6A0C: 41820010  beq 0x82ac6a1c
	if ctx.cr[0].eq {
	pc = 0x82AC6A1C; continue 'dispatch;
	}
	// 82AC6A10: 48002101  bl 0x82ac8b10
	ctx.lr = 0x82AC6A14;
	sub_82AC8B10(ctx, base);
	// 82AC6A14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC6A18: 48000008  b 0x82ac6a20
	pc = 0x82AC6A20; continue 'dispatch;
	// 82AC6A1C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC6A20: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AC6A24: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AC6A28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC6A2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC6A30: 4BFFFCB9  bl 0x82ac66e8
	ctx.lr = 0x82AC6A34;
	sub_82AC66E8(ctx, base);
	// 82AC6A34: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC6A38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC6A3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC6A40: 4B7F95C1  bl 0x822c0000
	ctx.lr = 0x82AC6A44;
	sub_822C0000(ctx, base);
	// 82AC6A44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC6A48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC6A4C: 486E1770  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC6A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC6A50 size=92
    let mut pc: u32 = 0x82AC6A50;
    'dispatch: loop {
        match pc {
            0x82AC6A50 => {
    //   block [0x82AC6A50..0x82AC6AAC)
	// 82AC6A50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC6A54: 486E1719  bl 0x831a816c
	ctx.lr = 0x82AC6A58;
	sub_831A8130(ctx, base);
	// 82AC6A58: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC6A5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC6A60: 3D4082AC  lis r10, -0x7d54
	ctx.r[10].s64 = -2102657024;
	// 82AC6A64: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82AC6A68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC6A6C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC6A70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC6A74: 388A67B0  addi r4, r10, 0x67b0
	ctx.r[4].s64 = ctx.r[10].s64 + 26544;
	// 82AC6A78: 4B898FF9  bl 0x8235fa70
	ctx.lr = 0x82AC6A7C;
	sub_8235FA70(ctx, base);
	// 82AC6A7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC6A80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC6A84: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82AC6A88: 4832D179  bl 0x82df3c00
	ctx.lr = 0x82AC6A8C;
	sub_82DF3C00(ctx, base);
	// 82AC6A8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC6A90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC6A94: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AC6A98: 483956C1  bl 0x82e5c158
	ctx.lr = 0x82AC6A9C;
	sub_82E5C158(ctx, base);
	// 82AC6A9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC6AA0: 4832C989  bl 0x82df3428
	ctx.lr = 0x82AC6AA4;
	sub_82DF3428(ctx, base);
	// 82AC6AA4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AC6AA8: 486E1714  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC6AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC6AB0 size=92
    let mut pc: u32 = 0x82AC6AB0;
    'dispatch: loop {
        match pc {
            0x82AC6AB0 => {
    //   block [0x82AC6AB0..0x82AC6B0C)
	// 82AC6AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC6AB4: 486E16B9  bl 0x831a816c
	ctx.lr = 0x82AC6AB8;
	sub_831A8130(ctx, base);
	// 82AC6AB8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC6ABC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC6AC0: 3D4082AC  lis r10, -0x7d54
	ctx.r[10].s64 = -2102657024;
	// 82AC6AC4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82AC6AC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC6ACC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC6AD0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC6AD4: 388A6820  addi r4, r10, 0x6820
	ctx.r[4].s64 = ctx.r[10].s64 + 26656;
	// 82AC6AD8: 4B898F99  bl 0x8235fa70
	ctx.lr = 0x82AC6ADC;
	sub_8235FA70(ctx, base);
	// 82AC6ADC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC6AE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC6AE4: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82AC6AE8: 4832D119  bl 0x82df3c00
	ctx.lr = 0x82AC6AEC;
	sub_82DF3C00(ctx, base);
	// 82AC6AEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC6AF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC6AF4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AC6AF8: 48395661  bl 0x82e5c158
	ctx.lr = 0x82AC6AFC;
	sub_82E5C158(ctx, base);
	// 82AC6AFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC6B00: 4832C929  bl 0x82df3428
	ctx.lr = 0x82AC6B04;
	sub_82DF3428(ctx, base);
	// 82AC6B04: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AC6B08: 486E16B4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC6B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC6B10 size=92
    let mut pc: u32 = 0x82AC6B10;
    'dispatch: loop {
        match pc {
            0x82AC6B10 => {
    //   block [0x82AC6B10..0x82AC6B6C)
	// 82AC6B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC6B14: 486E1659  bl 0x831a816c
	ctx.lr = 0x82AC6B18;
	sub_831A8130(ctx, base);
	// 82AC6B18: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC6B1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC6B20: 3D4082AC  lis r10, -0x7d54
	ctx.r[10].s64 = -2102657024;
	// 82AC6B24: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82AC6B28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC6B2C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC6B30: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC6B34: 388A6890  addi r4, r10, 0x6890
	ctx.r[4].s64 = ctx.r[10].s64 + 26768;
	// 82AC6B38: 4B898F39  bl 0x8235fa70
	ctx.lr = 0x82AC6B3C;
	sub_8235FA70(ctx, base);
	// 82AC6B3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC6B40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC6B44: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82AC6B48: 4832D0B9  bl 0x82df3c00
	ctx.lr = 0x82AC6B4C;
	sub_82DF3C00(ctx, base);
	// 82AC6B4C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC6B50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC6B54: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AC6B58: 48395601  bl 0x82e5c158
	ctx.lr = 0x82AC6B5C;
	sub_82E5C158(ctx, base);
	// 82AC6B5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC6B60: 4832C8C9  bl 0x82df3428
	ctx.lr = 0x82AC6B64;
	sub_82DF3428(ctx, base);
	// 82AC6B64: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AC6B68: 486E1654  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC6B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC6B70 size=92
    let mut pc: u32 = 0x82AC6B70;
    'dispatch: loop {
        match pc {
            0x82AC6B70 => {
    //   block [0x82AC6B70..0x82AC6BCC)
	// 82AC6B70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC6B74: 486E15F9  bl 0x831a816c
	ctx.lr = 0x82AC6B78;
	sub_831A8130(ctx, base);
	// 82AC6B78: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC6B7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC6B80: 3D4082AC  lis r10, -0x7d54
	ctx.r[10].s64 = -2102657024;
	// 82AC6B84: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82AC6B88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC6B8C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC6B90: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC6B94: 388A6900  addi r4, r10, 0x6900
	ctx.r[4].s64 = ctx.r[10].s64 + 26880;
	// 82AC6B98: 4B898ED9  bl 0x8235fa70
	ctx.lr = 0x82AC6B9C;
	sub_8235FA70(ctx, base);
	// 82AC6B9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC6BA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC6BA4: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82AC6BA8: 4832D059  bl 0x82df3c00
	ctx.lr = 0x82AC6BAC;
	sub_82DF3C00(ctx, base);
	// 82AC6BAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC6BB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC6BB4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AC6BB8: 483955A1  bl 0x82e5c158
	ctx.lr = 0x82AC6BBC;
	sub_82E5C158(ctx, base);
	// 82AC6BBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC6BC0: 4832C869  bl 0x82df3428
	ctx.lr = 0x82AC6BC4;
	sub_82DF3428(ctx, base);
	// 82AC6BC4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AC6BC8: 486E15F4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC6BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC6BD0 size=92
    let mut pc: u32 = 0x82AC6BD0;
    'dispatch: loop {
        match pc {
            0x82AC6BD0 => {
    //   block [0x82AC6BD0..0x82AC6C2C)
	// 82AC6BD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC6BD4: 486E1599  bl 0x831a816c
	ctx.lr = 0x82AC6BD8;
	sub_831A8130(ctx, base);
	// 82AC6BD8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC6BDC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC6BE0: 3D4082AC  lis r10, -0x7d54
	ctx.r[10].s64 = -2102657024;
	// 82AC6BE4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82AC6BE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC6BEC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC6BF0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC6BF4: 388A6970  addi r4, r10, 0x6970
	ctx.r[4].s64 = ctx.r[10].s64 + 26992;
	// 82AC6BF8: 4B898E79  bl 0x8235fa70
	ctx.lr = 0x82AC6BFC;
	sub_8235FA70(ctx, base);
	// 82AC6BFC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC6C00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC6C04: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82AC6C08: 4832CFF9  bl 0x82df3c00
	ctx.lr = 0x82AC6C0C;
	sub_82DF3C00(ctx, base);
	// 82AC6C0C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC6C10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC6C14: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AC6C18: 48395541  bl 0x82e5c158
	ctx.lr = 0x82AC6C1C;
	sub_82E5C158(ctx, base);
	// 82AC6C1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC6C20: 4832C809  bl 0x82df3428
	ctx.lr = 0x82AC6C24;
	sub_82DF3428(ctx, base);
	// 82AC6C24: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AC6C28: 486E1594  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC6C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC6C30 size=92
    let mut pc: u32 = 0x82AC6C30;
    'dispatch: loop {
        match pc {
            0x82AC6C30 => {
    //   block [0x82AC6C30..0x82AC6C8C)
	// 82AC6C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC6C34: 486E1539  bl 0x831a816c
	ctx.lr = 0x82AC6C38;
	sub_831A8130(ctx, base);
	// 82AC6C38: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC6C3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC6C40: 3D4082AC  lis r10, -0x7d54
	ctx.r[10].s64 = -2102657024;
	// 82AC6C44: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82AC6C48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC6C4C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC6C50: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC6C54: 388A69E0  addi r4, r10, 0x69e0
	ctx.r[4].s64 = ctx.r[10].s64 + 27104;
	// 82AC6C58: 4B898E19  bl 0x8235fa70
	ctx.lr = 0x82AC6C5C;
	sub_8235FA70(ctx, base);
	// 82AC6C5C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC6C60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC6C64: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82AC6C68: 4832CF99  bl 0x82df3c00
	ctx.lr = 0x82AC6C6C;
	sub_82DF3C00(ctx, base);
	// 82AC6C6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC6C70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC6C74: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AC6C78: 483954E1  bl 0x82e5c158
	ctx.lr = 0x82AC6C7C;
	sub_82E5C158(ctx, base);
	// 82AC6C7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC6C80: 4832C7A9  bl 0x82df3428
	ctx.lr = 0x82AC6C84;
	sub_82DF3428(ctx, base);
	// 82AC6C84: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82AC6C88: 486E1534  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC6C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC6C90 size=324
    let mut pc: u32 = 0x82AC6C90;
    'dispatch: loop {
        match pc {
            0x82AC6C90 => {
    //   block [0x82AC6C90..0x82AC6DD4)
	// 82AC6C90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC6C94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC6C98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC6C9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC6CA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC6CA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC6CA8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC6CAC: 48396C25  bl 0x82e5d8d0
	ctx.lr = 0x82AC6CB0;
	sub_82E5D8D0(ctx, base);
	// 82AC6CB0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC6CB4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AC6CB8: 396B9800  addi r11, r11, -0x6800
	ctx.r[11].s64 = ctx.r[11].s64 + -26624;
	// 82AC6CBC: 995F0060  stb r10, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u8 ) };
	// 82AC6CC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC6CC4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC6CC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC6CCC: 4858C645  bl 0x83053310
	ctx.lr = 0x82AC6CD0;
	sub_83053310(ctx, base);
	// 82AC6CD0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82AC6CD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC6CD8: 388B893C  addi r4, r11, -0x76c4
	ctx.r[4].s64 = ctx.r[11].s64 + -30404;
	// 82AC6CDC: 4832CD2D  bl 0x82df3a08
	ctx.lr = 0x82AC6CE0;
	sub_82DF3A08(ctx, base);
	// 82AC6CE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC6CE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC6CE8: 4BFFFD69  bl 0x82ac6a50
	ctx.lr = 0x82AC6CEC;
	sub_82AC6A50(ctx, base);
	// 82AC6CEC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC6CF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC6CF4: 388B95B0  addi r4, r11, -0x6a50
	ctx.r[4].s64 = ctx.r[11].s64 + -27216;
	// 82AC6CF8: 4832CD11  bl 0x82df3a08
	ctx.lr = 0x82AC6CFC;
	sub_82DF3A08(ctx, base);
	// 82AC6CFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC6D00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC6D04: 4BFFFDAD  bl 0x82ac6ab0
	ctx.lr = 0x82AC6D08;
	sub_82AC6AB0(ctx, base);
	// 82AC6D08: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82AC6D0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC6D10: 3BCB6564  addi r30, r11, 0x6564
	ctx.r[30].s64 = ctx.r[11].s64 + 25956;
	// 82AC6D14: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC6D18: 4832CCF1  bl 0x82df3a08
	ctx.lr = 0x82AC6D1C;
	sub_82DF3A08(ctx, base);
	// 82AC6D1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC6D20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC6D24: 4BFFFDED  bl 0x82ac6b10
	ctx.lr = 0x82AC6D28;
	sub_82AC6B10(ctx, base);
	// 82AC6D28: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82AC6D2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC6D30: 388BCB24  addi r4, r11, -0x34dc
	ctx.r[4].s64 = ctx.r[11].s64 + -13532;
	// 82AC6D34: 4832CCD5  bl 0x82df3a08
	ctx.lr = 0x82AC6D38;
	sub_82DF3A08(ctx, base);
	// 82AC6D38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC6D3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC6D40: 4BFFFE31  bl 0x82ac6b70
	ctx.lr = 0x82AC6D44;
	sub_82AC6B70(ctx, base);
	// 82AC6D44: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC6D48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC6D4C: 388B0740  addi r4, r11, 0x740
	ctx.r[4].s64 = ctx.r[11].s64 + 1856;
	// 82AC6D50: 4832CCB9  bl 0x82df3a08
	ctx.lr = 0x82AC6D54;
	sub_82DF3A08(ctx, base);
	// 82AC6D54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC6D58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC6D5C: 4BFFFE75  bl 0x82ac6bd0
	ctx.lr = 0x82AC6D60;
	sub_82AC6BD0(ctx, base);
	// 82AC6D60: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82AC6D64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC6D68: 388B4418  addi r4, r11, 0x4418
	ctx.r[4].s64 = ctx.r[11].s64 + 17432;
	// 82AC6D6C: 4832CC9D  bl 0x82df3a08
	ctx.lr = 0x82AC6D70;
	sub_82DF3A08(ctx, base);
	// 82AC6D70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AC6D74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC6D78: 4BFFFEB9  bl 0x82ac6c30
	ctx.lr = 0x82AC6D7C;
	sub_82AC6C30(ctx, base);
	// 82AC6D7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC6D80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC6D84: 4832CC85  bl 0x82df3a08
	ctx.lr = 0x82AC6D88;
	sub_82DF3A08(ctx, base);
	// 82AC6D88: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC6D8C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AC6D90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC6D94: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC6D98: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC6D9C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82AC6DA0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC6DA4: 48397BBD  bl 0x82e5e960
	ctx.lr = 0x82AC6DA8;
	sub_82E5E960(ctx, base);
	// 82AC6DA8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AC6DAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC6DB0: 419A0008  beq cr6, 0x82ac6db8
	if ctx.cr[6].eq {
	pc = 0x82AC6DB8; continue 'dispatch;
	}
	// 82AC6DB4: 4B7F9ADD  bl 0x822c0890
	ctx.lr = 0x82AC6DB8;
	sub_822C0890(ctx, base);
	// 82AC6DB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC6DBC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC6DC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC6DC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC6DC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC6DCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC6DD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC6DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC6DD8 size=252
    let mut pc: u32 = 0x82AC6DD8;
    'dispatch: loop {
        match pc {
            0x82AC6DD8 => {
    //   block [0x82AC6DD8..0x82AC6ED4)
	// 82AC6DD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC6DDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC6DE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC6DE4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC6DE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC6DEC: 48001805  bl 0x82ac85f0
	ctx.lr = 0x82AC6DF0;
	sub_82AC85F0(ctx, base);
	// 82AC6DF0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AC6DF4: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AC6DF8: 392B6910  addi r9, r11, 0x6910
	ctx.r[9].s64 = ctx.r[11].s64 + 26896;
	// 82AC6DFC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82AC6E00: 39000070  li r8, 0x70
	ctx.r[8].s64 = 112;
	// 82AC6E04: 394A98D8  addi r10, r10, -0x6728
	ctx.r[10].s64 = ctx.r[10].s64 + -26408;
	// 82AC6E08: 38EBBA80  addi r7, r11, -0x4580
	ctx.r[7].s64 = ctx.r[11].s64 + -17792;
	// 82AC6E0C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AC6E10: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AC6E14: 39400090  li r10, 0x90
	ctx.r[10].s64 = 144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC6ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC6ED8 size=172
    let mut pc: u32 = 0x82AC6ED8;
    'dispatch: loop {
        match pc {
            0x82AC6ED8 => {
    //   block [0x82AC6ED8..0x82AC6F84)
	// 82AC6ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC6EDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC6EE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC6EE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC6EE8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC6EEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC6EF0: 4868D711  bl 0x83154600
	ctx.lr = 0x82AC6EF4;
	sub_83154600(ctx, base);
	// 82AC6EF4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AC6EF8: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82AC6EFC: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82AC6F00: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AC6F04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC6F08: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC6F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC6F88 size=572
    let mut pc: u32 = 0x82AC6F88;
    'dispatch: loop {
        match pc {
            0x82AC6F88 => {
    //   block [0x82AC6F88..0x82AC71C4)
	// 82AC6F88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC6F8C: 486E11CD  bl 0x831a8158
	ctx.lr = 0x82AC6F90;
	sub_831A8130(ctx, base);
	// 82AC6F90: DBC1FFA8  stfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 82AC6F94: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82AC6F98: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC6F9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC6FA0: 4BFFFF39  bl 0x82ac6ed8
	ctx.lr = 0x82AC6FA4;
	sub_82AC6ED8(ctx, base);
	// 82AC6FA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC6FA8: 4868D659  bl 0x83154600
	ctx.lr = 0x82AC6FAC;
	sub_83154600(ctx, base);
	// 82AC6FAC: 895F00B4  lbz r10, 0xb4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 82AC6FB0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC6FB4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82AC6FB8: 3BCB98A8  addi r30, r11, -0x6758
	ctx.r[30].s64 = ctx.r[11].s64 + -26456;
	// 82AC6FBC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC6FC0: 4082014C  bne 0x82ac710c
	if !ctx.cr[0].eq {
	pc = 0x82AC710C; continue 'dispatch;
	}
	// 82AC6FC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC6FC8: 483927B1  bl 0x82e59778
	ctx.lr = 0x82AC6FCC;
	sub_82E59778(ctx, base);
	// 82AC6FCC: C01EFFF0  lfs f0, -0x10(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC6FD0: FC400890  fmr f2, f1
	ctx.f[2].f64 = ctx.f[1].f64;
	// 82AC6FD4: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 82AC6FD8: 4BFE7429  bl 0x82aae400
	ctx.lr = 0x82AC6FDC;
	sub_82AAE400(ctx, base);
	// 82AC6FDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC6FE0: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82AC6FE4: 48392795  bl 0x82e59778
	ctx.lr = 0x82AC6FE8;
	sub_82E59778(ctx, base);
	// 82AC6FE8: C01EFFF4  lfs f0, -0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC6FEC: FC400890  fmr f2, f1
	ctx.f[2].f64 = ctx.f[1].f64;
	// 82AC6FF0: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 82AC6FF4: 4BFE740D  bl 0x82aae400
	ctx.lr = 0x82AC6FF8;
	sub_82AAE400(ctx, base);
	// 82AC6FF8: 3BBF00CC  addi r29, r31, 0xcc
	ctx.r[29].s64 = ctx.r[31].s64 + 204;
	// 82AC6FFC: FC600890  fmr f3, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[1].f64;
	// 82AC7000: C03F00B0  lfs f1, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC7004: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82AC7008: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC700C: 4BFE7665  bl 0x82aae670
	ctx.lr = 0x82AC7010;
	sub_82AAE670(ctx, base);
	// 82AC7010: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82AC7014: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC7018: 48392761  bl 0x82e59778
	ctx.lr = 0x82AC701C;
	sub_82E59778(ctx, base);
	// 82AC701C: C01EFFF8  lfs f0, -8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC7020: FC400890  fmr f2, f1
	ctx.f[2].f64 = ctx.f[1].f64;
	// 82AC7024: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 82AC7028: 4BFE73D9  bl 0x82aae400
	ctx.lr = 0x82AC702C;
	sub_82AAE400(ctx, base);
	// 82AC702C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC7030: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82AC7034: 48392745  bl 0x82e59778
	ctx.lr = 0x82AC7038;
	sub_82E59778(ctx, base);
	// 82AC7038: C01EFFFC  lfs f0, -4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC703C: FC400890  fmr f2, f1
	ctx.f[2].f64 = ctx.f[1].f64;
	// 82AC7040: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 82AC7044: 4BFE73BD  bl 0x82aae400
	ctx.lr = 0x82AC7048;
	sub_82AAE400(ctx, base);
	// 82AC7048: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82AC704C: 3B9F00D0  addi r28, r31, 0xd0
	ctx.r[28].s64 = ctx.r[31].s64 + 208;
	// 82AC7050: C03F0094  lfs f1, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC7054: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82AC7058: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AC705C: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82AC7060: 4BFE7611  bl 0x82aae670
	ctx.lr = 0x82AC7064;
	sub_82AAE670(ctx, base);
	// 82AC7064: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC7068: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82AC706C: 3B7F00D4  addi r27, r31, 0xd4
	ctx.r[27].s64 = ctx.r[31].s64 + 212;
	// 82AC7070: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82AC7074: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82AC7078: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AC707C: C02B83B8  lfs f1, -0x7c48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31816 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC7080: 4BFE75F1  bl 0x82aae670
	ctx.lr = 0x82AC7084;
	sub_82AAE670(ctx, base);
	// 82AC7084: 39600090  li r11, 0x90
	ctx.r[11].s64 = 144;
	// 82AC7088: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82AC708C: 5709063F  clrlwi. r9, r24, 0x18
	ctx.r[9].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AC7090: 13FF58C7  vcmpequd (lvx128) v31, v31, v11
	tmp.u32 = ctx.r[31].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC71C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC71C8 size=272
    let mut pc: u32 = 0x82AC71C8;
    'dispatch: loop {
        match pc {
            0x82AC71C8 => {
    //   block [0x82AC71C8..0x82AC72D8)
	// 82AC71C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC71CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC71D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC71D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC71D8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC71DC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AC71E0: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82AC71E4: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82AC71E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC71EC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC72D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC72D8 size=404
    let mut pc: u32 = 0x82AC72D8;
    'dispatch: loop {
        match pc {
            0x82AC72D8 => {
    //   block [0x82AC72D8..0x82AC746C)
	// 82AC72D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC72DC: 486E0E91  bl 0x831a816c
	ctx.lr = 0x82AC72E0;
	sub_831A8130(ctx, base);
	// 82AC72E0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC72E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC72E8: 897E00C8  lbz r11, 0xc8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(200 as u32) ) } as u64;
	// 82AC72EC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC72F0: 40820174  bne 0x82ac7464
	if !ctx.cr[0].eq {
	pc = 0x82AC7464; continue 'dispatch;
	}
	// 82AC72F4: 4868D30D  bl 0x83154600
	ctx.lr = 0x82AC72F8;
	sub_83154600(ctx, base);
	// 82AC72F8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AC72FC: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82AC7300: 3BAB6910  addi r29, r11, 0x6910
	ctx.r[29].s64 = ctx.r[11].s64 + 26896;
	// 82AC7304: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82AC7308: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC730C: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC7470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC7470 size=688
    let mut pc: u32 = 0x82AC7470;
    'dispatch: loop {
        match pc {
            0x82AC7470 => {
    //   block [0x82AC7470..0x82AC7720)
	// 82AC7470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC7474: 486E0CF5  bl 0x831a8168
	ctx.lr = 0x82AC7478;
	sub_831A8130(ctx, base);
	// 82AC7478: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82AC747C: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82AC7480: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC7484: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC7488: 4BFFFA51  bl 0x82ac6ed8
	ctx.lr = 0x82AC748C;
	sub_82AC6ED8(ctx, base);
	// 82AC748C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC7490: 4868D171  bl 0x83154600
	ctx.lr = 0x82AC7494;
	sub_83154600(ctx, base);
	// 82AC7494: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AC7498: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 82AC749C: 3BEB6910  addi r31, r11, 0x6910
	ctx.r[31].s64 = ctx.r[11].s64 + 26896;
	// 82AC74A0: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82AC74A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC74A8: 13E0F8C7  vcmpequd (lvx128) v31, v0, v31
	tmp.u32 = ctx.r[31].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC7720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC7720 size=924
    let mut pc: u32 = 0x82AC7720;
    'dispatch: loop {
        match pc {
            0x82AC7720 => {
    //   block [0x82AC7720..0x82AC7ABC)
	// 82AC7720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC7724: 486E0A45  bl 0x831a8168
	ctx.lr = 0x82AC7728;
	sub_831A8130(ctx, base);
	// 82AC7728: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82AC772C: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC7AC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC7AC0 size=772
    let mut pc: u32 = 0x82AC7AC0;
    'dispatch: loop {
        match pc {
            0x82AC7AC0 => {
    //   block [0x82AC7AC0..0x82AC7DC4)
	// 82AC7AC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC7AC4: 486E06A5  bl 0x831a8168
	ctx.lr = 0x82AC7AC8;
	sub_831A8130(ctx, base);
	// 82AC7AC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC7ACC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC7AD0: 4868CB31  bl 0x83154600
	ctx.lr = 0x82AC7AD4;
	sub_83154600(ctx, base);
	// 82AC7AD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC7AD8: 4BD24701  bl 0x827ec1d8
	ctx.lr = 0x82AC7ADC;
	sub_827EC1D8(ctx, base);
	// 82AC7ADC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AC7AE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC7AE4: 4BF4B3D5  bl 0x82a12eb8
	ctx.lr = 0x82AC7AE8;
	sub_82A12EB8(ctx, base);
	// 82AC7AE8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC7AEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC7AF0: 48000AF1  bl 0x82ac85e0
	ctx.lr = 0x82AC7AF4;
	sub_82AC85E0(ctx, base);
	// 82AC7AF4: 2B03000A  cmplwi cr6, r3, 0xa
	ctx.cr[6].compare_u32(ctx.r[3].u32, 10 as u32, &mut ctx.xer);
	// 82AC7AF8: 419902BC  bgt cr6, 0x82ac7db4
	if ctx.cr[6].gt {
	pc = 0x82AC7DB4; continue 'dispatch;
	}
	// 82AC7AFC: 3D80820C  lis r12, -0x7df4
	ctx.r[12].s64 = -2113142784;
	// 82AC7B00: 398C98C8  addi r12, r12, -0x6738
	ctx.r[12].s64 = ctx.r[12].s64 + -26424;
	// 82AC7B04: 7C0C18AE  lbzx r0, r12, r3
	ctx.r[0].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82AC7B08: 5400103A  slwi r0, r0, 2
	ctx.r[0].u32 = ctx.r[0].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82AC7B0C: 3D8082AC  lis r12, -0x7d54
	ctx.r[12].s64 = -2102657024;
	// 82AC7B10: 398C7B24  addi r12, r12, 0x7b24
	ctx.r[12].s64 = ctx.r[12].s64 + 31524;
	// 82AC7B14: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 82AC7B18: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 82AC7B1C: 60000000  nop
	// 82AC7B20: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
	// 82AC7B24: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AC7B28: 4BF9C1A9  bl 0x82a63cd0
	ctx.lr = 0x82AC7B2C;
	sub_82A63CD0(ctx, base);
	// 82AC7B2C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82AC7B30: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC7B34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC7B38: C02B6150  lfs f1, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC7B3C: 4BFFDA65  bl 0x82ac55a0
	ctx.lr = 0x82AC7B40;
	sub_82AC55A0(ctx, base);
	// 82AC7B40: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC7B44: 48000268  b 0x82ac7dac
	pc = 0x82AC7DAC; continue 'dispatch;
	// 82AC7B48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC7B4C: 4BFFC8BD  bl 0x82ac4408
	ctx.lr = 0x82AC7B50;
	sub_82AC4408(ctx, base);
	// 82AC7B50: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC7B54: 41820260  beq 0x82ac7db4
	if ctx.cr[0].eq {
	pc = 0x82AC7DB4; continue 'dispatch;
	}
	// 82AC7B58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC7B5C: 4BFFF915  bl 0x82ac7470
	ctx.lr = 0x82AC7B60;
	sub_82AC7470(ctx, base);
	// 82AC7B60: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC7B64: 41820250  beq 0x82ac7db4
	if ctx.cr[0].eq {
	pc = 0x82AC7DB4; continue 'dispatch;
	}
	// 82AC7B68: 38DF00B0  addi r6, r31, 0xb0
	ctx.r[6].s64 = ctx.r[31].s64 + 176;
	// 82AC7B6C: 38BF00A0  addi r5, r31, 0xa0
	ctx.r[5].s64 = ctx.r[31].s64 + 160;
	// 82AC7B70: 389F0090  addi r4, r31, 0x90
	ctx.r[4].s64 = ctx.r[31].s64 + 144;
	// 82AC7B74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC7B78: 4BFFC6C9  bl 0x82ac4240
	ctx.lr = 0x82AC7B7C;
	sub_82AC4240(ctx, base);
	// 82AC7B7C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC7B80: 41820234  beq 0x82ac7db4
	if ctx.cr[0].eq {
	pc = 0x82AC7DB4; continue 'dispatch;
	}
	// 82AC7B84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC7B88: 4BFFF641  bl 0x82ac71c8
	ctx.lr = 0x82AC7B8C;
	sub_82AC71C8(ctx, base);
	// 82AC7B8C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82AC7B90: 4800021C  b 0x82ac7dac
	pc = 0x82AC7DAC; continue 'dispatch;
	// 82AC7B94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC7B98: 4BFFF3F1  bl 0x82ac6f88
	ctx.lr = 0x82AC7B9C;
	sub_82AC6F88(ctx, base);
	// 82AC7B9C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC7BA0: 41820214  beq 0x82ac7db4
	if ctx.cr[0].eq {
	pc = 0x82AC7DB4; continue 'dispatch;
	}
	// 82AC7BA4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82AC7BA8: 48000204  b 0x82ac7dac
	pc = 0x82AC7DAC; continue 'dispatch;
	// 82AC7BAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC7BB0: 4BFFA3F1  bl 0x82ac1fa0
	ctx.lr = 0x82AC7BB4;
	sub_82AC1FA0(ctx, base);
	// 82AC7BB4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC7BB8: 418201FC  beq 0x82ac7db4
	if ctx.cr[0].eq {
	pc = 0x82AC7DB4; continue 'dispatch;
	}
	// 82AC7BBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC7BC0: 4BFFCC79  bl 0x82ac4838
	ctx.lr = 0x82AC7BC4;
	sub_82AC4838(ctx, base);
	// 82AC7BC4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC7BC8: 408201EC  bne 0x82ac7db4
	if !ctx.cr[0].eq {
	pc = 0x82AC7DB4; continue 'dispatch;
	}
	// 82AC7BCC: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82AC7BD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC7BD4: 4BFFCB95  bl 0x82ac4768
	ctx.lr = 0x82AC7BD8;
	sub_82AC4768(ctx, base);
	// 82AC7BD8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC7BDC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82AC7BE0: 396B98C4  addi r11, r11, -0x673c
	ctx.r[11].s64 = ctx.r[11].s64 + -26428;
	// 82AC7BE4: C00BFFF0  lfs f0, -0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC7BE8: D01F00BC  stfs f0, 0xbc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82AC7BEC: 480001C0  b 0x82ac7dac
	pc = 0x82AC7DAC; continue 'dispatch;
	// 82AC7BF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC7BF4: C1BF00BC  lfs f13, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC7BF8: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC7BFC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AC7C00: 4099001C  ble cr6, 0x82ac7c1c
	if !ctx.cr[6].gt {
	pc = 0x82AC7C1C; continue 'dispatch;
	}
	// 82AC7C04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC7C08: 48391B71  bl 0x82e59778
	ctx.lr = 0x82AC7C0C;
	sub_82E59778(ctx, base);
	// 82AC7C0C: C01F00BC  lfs f0, 0xbc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC7C10: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82AC7C14: D01F00BC  stfs f0, 0xbc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82AC7C18: 4800019C  b 0x82ac7db4
	pc = 0x82AC7DB4; continue 'dispatch;
	// 82AC7C1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC7C20: 4BFFCC19  bl 0x82ac4838
	ctx.lr = 0x82AC7C24;
	sub_82AC4838(ctx, base);
	// 82AC7C24: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC7C28: 4082018C  bne 0x82ac7db4
	if !ctx.cr[0].eq {
	pc = 0x82AC7DB4; continue 'dispatch;
	}
	// 82AC7C2C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC7C30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC7C34: 4BFFCB35  bl 0x82ac4768
	ctx.lr = 0x82AC7C38;
	sub_82AC4768(ctx, base);
	// 82AC7C38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC7C3C: 4BFFC705  bl 0x82ac4340
	ctx.lr = 0x82AC7C40;
	sub_82AC4340(ctx, base);
	// 82AC7C40: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82AC7C44: 48000168  b 0x82ac7dac
	pc = 0x82AC7DAC; continue 'dispatch;
	// 82AC7C48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC7C4C: 4BFFFAD5  bl 0x82ac7720
	ctx.lr = 0x82AC7C50;
	sub_82AC7720(ctx, base);
	// 82AC7C50: 48000164  b 0x82ac7db4
	pc = 0x82AC7DB4; continue 'dispatch;
	// 82AC7C54: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC7C58: 4BFFD659  bl 0x82ac52b0
	ctx.lr = 0x82AC7C5C;
	sub_82AC52B0(ctx, base);
	// 82AC7C5C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC7C60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC7C64: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC7C68: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC7C6C: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AC7C70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC7C74: 4E800421  bctrl
	ctx.lr = 0x82AC7C78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC7C78: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AC7C7C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC7C80: 409AFF84  bne cr6, 0x82ac7c04
	if !ctx.cr[6].eq {
	pc = 0x82AC7C04; continue 'dispatch;
	}
	// 82AC7C84: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82AC7C88: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 82AC7C8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC7C90: C02B6150  lfs f1, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC7C94: 4BFFD90D  bl 0x82ac55a0
	ctx.lr = 0x82AC7C98;
	sub_82AC55A0(ctx, base);
	// 82AC7C98: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 82AC7C9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC7CA0: 48000949  bl 0x82ac85e8
	ctx.lr = 0x82AC7CA4;
	sub_82AC85E8(ctx, base);
	// 82AC7CA4: 4BFFFF60  b 0x82ac7c04
	pc = 0x82AC7C04; continue 'dispatch;
	// 82AC7CA8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC7CAC: C1BF00BC  lfs f13, 0xbc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC7CB0: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC7CB4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AC7CB8: 4199FF4C  bgt cr6, 0x82ac7c04
	if ctx.cr[6].gt {
	pc = 0x82AC7C04; continue 'dispatch;
	}
	// 82AC7CBC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC7CC0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82AC7CC4: C00B98C4  lfs f0, -0x673c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-26428 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC7CC8: D01F00BC  stfs f0, 0xbc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82AC7CCC: 4BFFFFD0  b 0x82ac7c9c
	pc = 0x82AC7C9C; continue 'dispatch;
	// 82AC7CD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC7CD4: 4BFFFA4D  bl 0x82ac7720
	ctx.lr = 0x82AC7CD8;
	sub_82AC7720(ctx, base);
	// 82AC7CD8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC7CDC: C1BF00BC  lfs f13, 0xbc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC7CE0: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC7CE4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AC7CE8: 4199FF1C  bgt cr6, 0x82ac7c04
	if ctx.cr[6].gt {
	pc = 0x82AC7C04; continue 'dispatch;
	}
	// 82AC7CEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AC7CF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC7CF4: 4BFFB9B5  bl 0x82ac36a8
	ctx.lr = 0x82AC7CF8;
	sub_82AC36A8(ctx, base);
	// 82AC7CF8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AC7CFC: 809F00C4  lwz r4, 0xc4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82AC7D00: 48012DC1  bl 0x82adaac0
	ctx.lr = 0x82AC7D04;
	sub_82ADAAC0(ctx, base);
	// 82AC7D04: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82AC7D08: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 82AC7D0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC7D10: C02B6150  lfs f1, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC7D14: 4BFFD88D  bl 0x82ac55a0
	ctx.lr = 0x82AC7D18;
	sub_82AC55A0(ctx, base);
	// 82AC7D18: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 82AC7D1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC7D20: 480008C9  bl 0x82ac85e8
	ctx.lr = 0x82AC7D24;
	sub_82AC85E8(ctx, base);
	// 82AC7D24: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC7D28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC7D2C: 419AFED8  beq cr6, 0x82ac7c04
	if ctx.cr[6].eq {
	pc = 0x82AC7C04; continue 'dispatch;
	}
	// 82AC7D30: 4B7F8B61  bl 0x822c0890
	ctx.lr = 0x82AC7D34;
	sub_822C0890(ctx, base);
	// 82AC7D34: 4BFFFED0  b 0x82ac7c04
	pc = 0x82AC7C04; continue 'dispatch;
	// 82AC7D38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC7D3C: 4BFFF9E5  bl 0x82ac7720
	ctx.lr = 0x82AC7D40;
	sub_82AC7720(ctx, base);
	// 82AC7D40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC7D44: 4BFFD56D  bl 0x82ac52b0
	ctx.lr = 0x82AC7D48;
	sub_82AC52B0(ctx, base);
	// 82AC7D48: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC7D4C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC7D50: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC7D54: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC7D58: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AC7D5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC7D60: 4E800421  bctrl
	ctx.lr = 0x82AC7D64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC7D64: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AC7D68: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC7D6C: 409A0048  bne cr6, 0x82ac7db4
	if !ctx.cr[6].eq {
	pc = 0x82AC7DB4; continue 'dispatch;
	}
	// 82AC7D70: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82AC7D74: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC7D78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC7D7C: C02B6150  lfs f1, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC7D80: 4BFFD821  bl 0x82ac55a0
	ctx.lr = 0x82AC7D84;
	sub_82AC55A0(ctx, base);
	// 82AC7D84: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 82AC7D88: 48000024  b 0x82ac7dac
	pc = 0x82AC7DAC; continue 'dispatch;
	// 82AC7D8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC7D90: 4BFFF991  bl 0x82ac7720
	ctx.lr = 0x82AC7D94;
	sub_82AC7720(ctx, base);
	// 82AC7D94: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AC7D98: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC7D9C: 409A0018  bne cr6, 0x82ac7db4
	if !ctx.cr[6].eq {
	pc = 0x82AC7DB4; continue 'dispatch;
	}
	// 82AC7DA0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AC7DA4: 4BF9BF3D  bl 0x82a63ce0
	ctx.lr = 0x82AC7DA8;
	sub_82A63CE0(ctx, base);
	// 82AC7DA8: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 82AC7DAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC7DB0: 48000839  bl 0x82ac85e8
	ctx.lr = 0x82AC7DB4;
	sub_82AC85E8(ctx, base);
	// 82AC7DB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC7DB8: 4BFFF521  bl 0x82ac72d8
	ctx.lr = 0x82AC7DBC;
	sub_82AC72D8(ctx, base);
	// 82AC7DBC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC7DC0: 486E03F8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC7DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC7DC8 size=164
    let mut pc: u32 = 0x82AC7DC8;
    'dispatch: loop {
        match pc {
            0x82AC7DC8 => {
    //   block [0x82AC7DC8..0x82AC7E6C)
	// 82AC7DC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC7DCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC7DD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC7DD4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC7DD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC7DDC: 48000815  bl 0x82ac85f0
	ctx.lr = 0x82AC7DE0;
	sub_82AC85F0(ctx, base);
	// 82AC7DE0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC7DE4: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82AC7DE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC7DEC: 392999D0  addi r9, r9, -0x6630
	ctx.r[9].s64 = ctx.r[9].s64 + -26160;
	// 82AC7DF0: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82AC7DF4: 3D008202  lis r8, -0x7dfe
	ctx.r[8].s64 = -2113798144;
	// 82AC7DF8: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC7DFC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC7E00: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82AC7E04: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82AC7E08: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82AC7E0C: 997F0078  stb r11, 0x78(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u8 ) };
	// 82AC7E10: 997F0079  stb r11, 0x79(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(121 as u32), ctx.r[11].u8 ) };
	// 82AC7E14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC7E18: 997F007A  stb r11, 0x7a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(122 as u32), ctx.r[11].u8 ) };
	// 82AC7E1C: 3888CB24  addi r4, r8, -0x34dc
	ctx.r[4].s64 = ctx.r[8].s64 + -13532;
	// 82AC7E20: 997F007B  stb r11, 0x7b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(123 as u32), ctx.r[11].u8 ) };
	// 82AC7E24: 997F007C  stb r11, 0x7c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u8 ) };
	// 82AC7E28: 997F007D  stb r11, 0x7d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(125 as u32), ctx.r[11].u8 ) };
	// 82AC7E2C: 997F007E  stb r11, 0x7e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(126 as u32), ctx.r[11].u8 ) };
	// 82AC7E30: 4832BBD9  bl 0x82df3a08
	ctx.lr = 0x82AC7E34;
	sub_82DF3A08(ctx, base);
	// 82AC7E34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC7E38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AC7E3C: 483918AD  bl 0x82e596e8
	ctx.lr = 0x82AC7E40;
	sub_82E596E8(ctx, base);
	// 82AC7E40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC7E44: 4832B5E5  bl 0x82df3428
	ctx.lr = 0x82AC7E48;
	sub_82DF3428(ctx, base);
	// 82AC7E48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC7E4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC7E50: 48000799  bl 0x82ac85e8
	ctx.lr = 0x82AC7E54;
	sub_82AC85E8(ctx, base);
	// 82AC7E54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC7E58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC7E5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC7E60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC7E64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC7E68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC7E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC7E70 size=156
    let mut pc: u32 = 0x82AC7E70;
    'dispatch: loop {
        match pc {
            0x82AC7E70 => {
    //   block [0x82AC7E70..0x82AC7F0C)
	// 82AC7E70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC7E74: 486E02F9  bl 0x831a816c
	ctx.lr = 0x82AC7E78;
	sub_831A8130(ctx, base);
	// 82AC7E78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC7E7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC7E80: 897F007B  lbz r11, 0x7b(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(123 as u32) ) } as u64;
	// 82AC7E84: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC7E88: 409A0010  bne cr6, 0x82ac7e98
	if !ctx.cr[6].eq {
	pc = 0x82AC7E98; continue 'dispatch;
	}
	// 82AC7E8C: 897F007C  lbz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AC7E90: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC7E94: 419A0070  beq cr6, 0x82ac7f04
	if ctx.cr[6].eq {
	pc = 0x82AC7F04; continue 'dispatch;
	}
	// 82AC7E98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC7E9C: 4868C765  bl 0x83154600
	ctx.lr = 0x82AC7EA0;
	sub_83154600(ctx, base);
	// 82AC7EA0: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AC7EA4: C01F0070  lfs f0, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC7EA8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82AC7EAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC7EB0: C1AB0014  lfs f13, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC7EB4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AC7EB8: 4199001C  bgt cr6, 0x82ac7ed4
	if ctx.cr[6].gt {
	pc = 0x82AC7ED4; continue 'dispatch;
	}
	// 82AC7EBC: 897F007B  lbz r11, 0x7b(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(123 as u32) ) } as u64;
	// 82AC7EC0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC7EC4: 40820010  bne 0x82ac7ed4
	if !ctx.cr[0].eq {
	pc = 0x82AC7ED4; continue 'dispatch;
	}
	// 82AC7EC8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC7ECC: 4BFFA165  bl 0x82ac2030
	ctx.lr = 0x82AC7ED0;
	sub_82AC2030(ctx, base);
	// 82AC7ED0: 9BBF007B  stb r29, 0x7b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(123 as u32), ctx.r[29].u8 ) };
	// 82AC7ED4: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AC7ED8: C01F0070  lfs f0, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC7EDC: C1AB001C  lfs f13, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC7EE0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AC7EE4: 41990020  bgt cr6, 0x82ac7f04
	if ctx.cr[6].gt {
	pc = 0x82AC7F04; continue 'dispatch;
	}
	// 82AC7EE8: 897F007C  lbz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AC7EEC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC7EF0: 40820014  bne 0x82ac7f04
	if !ctx.cr[0].eq {
	pc = 0x82AC7F04; continue 'dispatch;
	}
	// 82AC7EF4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC7EF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC7EFC: 4BFFA135  bl 0x82ac2030
	ctx.lr = 0x82AC7F00;
	sub_82AC2030(ctx, base);
	// 82AC7F00: 9BBF007C  stb r29, 0x7c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[29].u8 ) };
	// 82AC7F04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC7F08: 486E02B4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC7F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC7F10 size=256
    let mut pc: u32 = 0x82AC7F10;
    'dispatch: loop {
        match pc {
            0x82AC7F10 => {
    //   block [0x82AC7F10..0x82AC8010)
	// 82AC7F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC7F14: 486E0259  bl 0x831a816c
	ctx.lr = 0x82AC7F18;
	sub_831A8130(ctx, base);
	// 82AC7F18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC7F1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC7F20: 897F007D  lbz r11, 0x7d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(125 as u32) ) } as u64;
	// 82AC7F24: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC7F28: 409A0010  bne cr6, 0x82ac7f38
	if !ctx.cr[6].eq {
	pc = 0x82AC7F38; continue 'dispatch;
	}
	// 82AC7F2C: 897F007E  lbz r11, 0x7e(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(126 as u32) ) } as u64;
	// 82AC7F30: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC7F34: 419A00D4  beq cr6, 0x82ac8008
	if ctx.cr[6].eq {
	pc = 0x82AC8008; continue 'dispatch;
	}
	// 82AC7F38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC7F3C: 4868C6C5  bl 0x83154600
	ctx.lr = 0x82AC7F40;
	sub_83154600(ctx, base);
	// 82AC7F40: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC7F44: 4BFFA055  bl 0x82ac1f98
	ctx.lr = 0x82AC7F48;
	sub_82AC1F98(ctx, base);
	// 82AC7F48: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82AC7F4C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82AC7F50: 419A0074  beq cr6, 0x82ac7fc4
	if ctx.cr[6].eq {
	pc = 0x82AC7FC4; continue 'dispatch;
	}
	// 82AC7F54: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 82AC7F58: 419A000C  beq cr6, 0x82ac7f64
	if ctx.cr[6].eq {
	pc = 0x82AC7F64; continue 'dispatch;
	}
	// 82AC7F5C: 9BBF007D  stb r29, 0x7d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(125 as u32), ctx.r[29].u8 ) };
	// 82AC7F60: 480000A4  b 0x82ac8004
	pc = 0x82AC8004; continue 'dispatch;
	// 82AC7F64: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AC7F68: C01F0070  lfs f0, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC7F6C: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC7F70: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AC7F74: 41990020  bgt cr6, 0x82ac7f94
	if ctx.cr[6].gt {
	pc = 0x82AC7F94; continue 'dispatch;
	}
	// 82AC7F78: 897F007D  lbz r11, 0x7d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(125 as u32) ) } as u64;
	// 82AC7F7C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC7F80: 40820014  bne 0x82ac7f94
	if !ctx.cr[0].eq {
	pc = 0x82AC7F94; continue 'dispatch;
	}
	// 82AC7F84: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82AC7F88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC7F8C: 4BFFB0ED  bl 0x82ac3078
	ctx.lr = 0x82AC7F90;
	sub_82AC3078(ctx, base);
	// 82AC7F90: 9BBF007D  stb r29, 0x7d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(125 as u32), ctx.r[29].u8 ) };
	// 82AC7F94: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AC7F98: C01F0070  lfs f0, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC7F9C: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC7FA0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AC7FA4: 41990064  bgt cr6, 0x82ac8008
	if ctx.cr[6].gt {
	pc = 0x82AC8008; continue 'dispatch;
	}
	// 82AC7FA8: 897F007E  lbz r11, 0x7e(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(126 as u32) ) } as u64;
	// 82AC7FAC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC7FB0: 40820058  bne 0x82ac8008
	if !ctx.cr[0].eq {
	pc = 0x82AC8008; continue 'dispatch;
	}
	// 82AC7FB4: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82AC7FB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC7FBC: 4BFFB0BD  bl 0x82ac3078
	ctx.lr = 0x82AC7FC0;
	sub_82AC3078(ctx, base);
	// 82AC7FC0: 48000034  b 0x82ac7ff4
	pc = 0x82AC7FF4; continue 'dispatch;
	// 82AC7FC4: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AC7FC8: C01F0070  lfs f0, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC7FCC: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC7FD0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AC7FD4: 41990030  bgt cr6, 0x82ac8004
	if ctx.cr[6].gt {
	pc = 0x82AC8004; continue 'dispatch;
	}
	// 82AC7FD8: 897F007D  lbz r11, 0x7d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(125 as u32) ) } as u64;
	// 82AC7FDC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC7FE0: 40820024  bne 0x82ac8004
	if !ctx.cr[0].eq {
	pc = 0x82AC8004; continue 'dispatch;
	}
	// 82AC7FE4: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82AC7FE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC7FEC: 4BFFB08D  bl 0x82ac3078
	ctx.lr = 0x82AC7FF0;
	sub_82AC3078(ctx, base);
	// 82AC7FF0: 9BBF007D  stb r29, 0x7d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(125 as u32), ctx.r[29].u8 ) };
	// 82AC7FF4: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82AC7FF8: 3880001E  li r4, 0x1e
	ctx.r[4].s64 = 30;
	// 82AC7FFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC8000: 4BFFA0B9  bl 0x82ac20b8
	ctx.lr = 0x82AC8004;
	sub_82AC20B8(ctx, base);
	// 82AC8004: 9BBF007E  stb r29, 0x7e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(126 as u32), ctx.r[29].u8 ) };
	// 82AC8008: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC800C: 486E01B0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC8010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC8010 size=76
    let mut pc: u32 = 0x82AC8010;
    'dispatch: loop {
        match pc {
            0x82AC8010 => {
    //   block [0x82AC8010..0x82AC805C)
	// 82AC8010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC8014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC8018: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC801C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC8020: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC8024: 4868C5DD  bl 0x83154600
	ctx.lr = 0x82AC8028;
	sub_83154600(ctx, base);
	// 82AC8028: 4BF4AE91  bl 0x82a12eb8
	ctx.lr = 0x82AC802C;
	sub_82A12EB8(ctx, base);
	// 82AC802C: 813F0074  lwz r9, 0x74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AC8030: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC8034: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82AC8038: 80890000  lwz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC803C: C04B8398  lfs f2, -0x7c68(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31848 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AC8040: C02A6150  lfs f1, 0x6150(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC8044: 4BFFD5F5  bl 0x82ac5638
	ctx.lr = 0x82AC8048;
	sub_82AC5638(ctx, base);
	// 82AC8048: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AC804C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC8050: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC8054: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC8058: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC8060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC8060 size=140
    let mut pc: u32 = 0x82AC8060;
    'dispatch: loop {
        match pc {
            0x82AC8060 => {
    //   block [0x82AC8060..0x82AC80EC)
	// 82AC8060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC8064: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC8068: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC806C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC8070: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC8074: 897F0078  lbz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82AC8078: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC807C: 419A005C  beq cr6, 0x82ac80d8
	if ctx.cr[6].eq {
	pc = 0x82AC80D8; continue 'dispatch;
	}
	// 82AC8080: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AC8084: C01F006C  lfs f0, 0x6c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC8088: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC808C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AC8090: 40990024  ble cr6, 0x82ac80b4
	if !ctx.cr[6].gt {
	pc = 0x82AC80B4; continue 'dispatch;
	}
	// 82AC8094: 483916E5  bl 0x82e59778
	ctx.lr = 0x82AC8098;
	sub_82E59778(ctx, base);
	// 82AC8098: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC809C: C1BF006C  lfs f13, 0x6c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC80A0: C00B8398  lfs f0, -0x7c68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31848 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC80A4: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AC80A8: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82AC80AC: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82AC80B0: 48000028  b 0x82ac80d8
	pc = 0x82AC80D8; continue 'dispatch;
	// 82AC80B4: 4868C54D  bl 0x83154600
	ctx.lr = 0x82AC80B8;
	sub_83154600(ctx, base);
	// 82AC80B8: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AC80BC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AC80C0: 808B0020  lwz r4, 0x20(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AC80C4: 4BFFC4F5  bl 0x82ac45b8
	ctx.lr = 0x82AC80C8;
	sub_82AC45B8(ctx, base);
	// 82AC80C8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC80CC: 4182000C  beq 0x82ac80d8
	if ctx.cr[0].eq {
	pc = 0x82AC80D8; continue 'dispatch;
	}
	// 82AC80D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AC80D4: 997F0078  stb r11, 0x78(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u8 ) };
	// 82AC80D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AC80DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC80E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC80E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC80E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC80F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC80F0 size=396
    let mut pc: u32 = 0x82AC80F0;
    'dispatch: loop {
        match pc {
            0x82AC80F0 => {
    //   block [0x82AC80F0..0x82AC827C)
	// 82AC80F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC80F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC80F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC80FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC8100: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC8104: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC8108: 4868C4F9  bl 0x83154600
	ctx.lr = 0x82AC810C;
	sub_83154600(ctx, base);
	// 82AC810C: 4BF4ADAD  bl 0x82a12eb8
	ctx.lr = 0x82AC8110;
	sub_82A12EB8(ctx, base);
	// 82AC8110: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AC8114: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC8118: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC811C: 41980104  blt cr6, 0x82ac8220
	if ctx.cr[6].lt {
	pc = 0x82AC8220; continue 'dispatch;
	}
	// 82AC8120: 419A00B8  beq cr6, 0x82ac81d8
	if ctx.cr[6].eq {
	pc = 0x82AC81D8; continue 'dispatch;
	}
	// 82AC8124: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82AC8128: 41980060  blt cr6, 0x82ac8188
	if ctx.cr[6].lt {
	pc = 0x82AC8188; continue 'dispatch;
	}
	// 82AC812C: 419A000C  beq cr6, 0x82ac8138
	if ctx.cr[6].eq {
	pc = 0x82AC8138; continue 'dispatch;
	}
	// 82AC8130: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AC8134: 48000130  b 0x82ac8264
	pc = 0x82AC8264; continue 'dispatch;
	// 82AC8138: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC813C: 4BFFD175  bl 0x82ac52b0
	ctx.lr = 0x82AC8140;
	sub_82AC52B0(ctx, base);
	// 82AC8140: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC8144: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC8148: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC814C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC8150: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AC8154: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC8158: 4E800421  bctrl
	ctx.lr = 0x82AC815C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC815C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC8160: 41820100  beq 0x82ac8260
	if ctx.cr[0].eq {
	pc = 0x82AC8260; continue 'dispatch;
	}
	// 82AC8164: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC8168: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82AC816C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC8170: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC8174: C04B8398  lfs f2, -0x7c68(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31848 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AC8178: C02A6150  lfs f1, 0x6150(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC817C: 4BFFD4BD  bl 0x82ac5638
	ctx.lr = 0x82AC8180;
	sub_82AC5638(ctx, base);
	// 82AC8180: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82AC8184: 480000D8  b 0x82ac825c
	pc = 0x82AC825C; continue 'dispatch;
	// 82AC8188: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC818C: 4BFFD125  bl 0x82ac52b0
	ctx.lr = 0x82AC8190;
	sub_82AC52B0(ctx, base);
	// 82AC8190: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC8194: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC8198: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC819C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC81A0: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AC81A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC81A8: 4E800421  bctrl
	ctx.lr = 0x82AC81AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC81AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC81B0: 418200B0  beq 0x82ac8260
	if ctx.cr[0].eq {
	pc = 0x82AC8260; continue 'dispatch;
	}
	// 82AC81B4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC81B8: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82AC81BC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82AC81C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC81C4: C04B8398  lfs f2, -0x7c68(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31848 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AC81C8: C02A6150  lfs f1, 0x6150(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC81CC: 4BFFD46D  bl 0x82ac5638
	ctx.lr = 0x82AC81D0;
	sub_82AC5638(ctx, base);
	// 82AC81D0: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82AC81D4: 48000088  b 0x82ac825c
	pc = 0x82AC825C; continue 'dispatch;
	// 82AC81D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC81DC: 4BFFD0D5  bl 0x82ac52b0
	ctx.lr = 0x82AC81E0;
	sub_82AC52B0(ctx, base);
	// 82AC81E0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC81E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC81E8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC81EC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC81F0: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AC81F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC81F8: 4E800421  bctrl
	ctx.lr = 0x82AC81FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC81FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC8200: 41820060  beq 0x82ac8260
	if ctx.cr[0].eq {
	pc = 0x82AC8260; continue 'dispatch;
	}
	// 82AC8204: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8208: 4BFFFE59  bl 0x82ac8060
	ctx.lr = 0x82AC820C;
	sub_82AC8060(ctx, base);
	// 82AC820C: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82AC8210: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC8214: 4BFFD67D  bl 0x82ac5890
	ctx.lr = 0x82AC8218;
	sub_82AC5890(ctx, base);
	// 82AC8218: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82AC821C: 48000040  b 0x82ac825c
	pc = 0x82AC825C; continue 'dispatch;
	// 82AC8220: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC8224: 4BFFD08D  bl 0x82ac52b0
	ctx.lr = 0x82AC8228;
	sub_82AC52B0(ctx, base);
	// 82AC8228: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC822C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC8230: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC8234: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC8238: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AC823C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC8240: 4E800421  bctrl
	ctx.lr = 0x82AC8244;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC8244: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC8248: 41820018  beq 0x82ac8260
	if ctx.cr[0].eq {
	pc = 0x82AC8260; continue 'dispatch;
	}
	// 82AC824C: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82AC8250: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC8254: 4BFFD63D  bl 0x82ac5890
	ctx.lr = 0x82AC8258;
	sub_82AC5890(ctx, base);
	// 82AC8258: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AC825C: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82AC8260: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC8264: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC8268: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC826C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC8270: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC8274: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC8278: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC8280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC8280 size=144
    let mut pc: u32 = 0x82AC8280;
    'dispatch: loop {
        match pc {
            0x82AC8280 => {
    //   block [0x82AC8280..0x82AC8310)
	// 82AC8280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC8284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC8288: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC828C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC8290: 4868C371  bl 0x83154600
	ctx.lr = 0x82AC8294;
	sub_83154600(ctx, base);
	// 82AC8294: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC8298: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC829C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC82A0: 4BFFB409  bl 0x82ac36a8
	ctx.lr = 0x82AC82A4;
	sub_82AC36A8(ctx, base);
	// 82AC82A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC82A8: 4BA227E1  bl 0x824eaa88
	ctx.lr = 0x82AC82AC;
	sub_824EAA88(ctx, base);
	// 82AC82AC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC82B0: 4BA215A1  bl 0x824e9850
	ctx.lr = 0x82AC82B4;
	sub_824E9850(ctx, base);
	// 82AC82B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC82B8: 483299D9  bl 0x82df1c90
	ctx.lr = 0x82AC82BC;
	sub_82DF1C90(ctx, base);
	// 82AC82BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC82C0: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AC82C4: 4BF4B3BD  bl 0x82a13680
	ctx.lr = 0x82AC82C8;
	sub_82A13680(ctx, base);
	// 82AC82C8: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82AC82CC: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82AC82D0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AC82D4: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 82AC82D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC82DC: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82AC82E0: C02B4430  lfs f1, 0x4430(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17456 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC82E4: C04A6218  lfs f2, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AC82E8: 48012909  bl 0x82adabf0
	ctx.lr = 0x82AC82EC;
	sub_82ADABF0(ctx, base);
	// 82AC82EC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC82F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC82F4: 419A0008  beq cr6, 0x82ac82fc
	if ctx.cr[6].eq {
	pc = 0x82AC82FC; continue 'dispatch;
	}
	// 82AC82F8: 4B7F8599  bl 0x822c0890
	ctx.lr = 0x82AC82FC;
	sub_822C0890(ctx, base);
	// 82AC82FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC8300: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC8304: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC8308: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC830C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC8310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC8310 size=284
    let mut pc: u32 = 0x82AC8310;
    'dispatch: loop {
        match pc {
            0x82AC8310 => {
    //   block [0x82AC8310..0x82AC842C)
	// 82AC8310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC8314: 486DFE59  bl 0x831a816c
	ctx.lr = 0x82AC8318;
	sub_831A8130(ctx, base);
	// 82AC8318: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC831C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC8320: 897F0079  lbz r11, 0x79(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(121 as u32) ) } as u64;
	// 82AC8324: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC8328: 409A0010  bne cr6, 0x82ac8338
	if !ctx.cr[6].eq {
	pc = 0x82AC8338; continue 'dispatch;
	}
	// 82AC832C: 897F007A  lbz r11, 0x7a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(122 as u32) ) } as u64;
	// 82AC8330: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC8334: 419A00F0  beq cr6, 0x82ac8424
	if ctx.cr[6].eq {
	pc = 0x82AC8424; continue 'dispatch;
	}
	// 82AC8338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC833C: 4868C2C5  bl 0x83154600
	ctx.lr = 0x82AC8340;
	sub_83154600(ctx, base);
	// 82AC8340: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC8344: 4BFF9C55  bl 0x82ac1f98
	ctx.lr = 0x82AC8348;
	sub_82AC1F98(ctx, base);
	// 82AC8348: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82AC834C: 419A0094  beq cr6, 0x82ac83e0
	if ctx.cr[6].eq {
	pc = 0x82AC83E0; continue 'dispatch;
	}
	// 82AC8350: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 82AC8354: 419A0018  beq cr6, 0x82ac836c
	if ctx.cr[6].eq {
	pc = 0x82AC836C; continue 'dispatch;
	}
	// 82AC8358: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 82AC835C: 419A0084  beq cr6, 0x82ac83e0
	if ctx.cr[6].eq {
	pc = 0x82AC83E0; continue 'dispatch;
	}
	// 82AC8360: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82AC8364: 9BDF0079  stb r30, 0x79(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(121 as u32), ctx.r[30].u8 ) };
	// 82AC8368: 480000B8  b 0x82ac8420
	pc = 0x82AC8420; continue 'dispatch;
	// 82AC836C: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AC8370: C01F0070  lfs f0, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC8374: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82AC8378: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC837C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AC8380: 41990028  bgt cr6, 0x82ac83a8
	if ctx.cr[6].gt {
	pc = 0x82AC83A8; continue 'dispatch;
	}
	// 82AC8384: 897F0079  lbz r11, 0x79(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(121 as u32) ) } as u64;
	// 82AC8388: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC838C: 4082001C  bne 0x82ac83a8
	if !ctx.cr[0].eq {
	pc = 0x82AC83A8; continue 'dispatch;
	}
	// 82AC8390: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC8394: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC8398: 4BFFACE1  bl 0x82ac3078
	ctx.lr = 0x82AC839C;
	sub_82AC3078(ctx, base);
	// 82AC839C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC83A0: 4BFFFEE1  bl 0x82ac8280
	ctx.lr = 0x82AC83A4;
	sub_82AC8280(ctx, base);
	// 82AC83A4: 9BDF0079  stb r30, 0x79(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(121 as u32), ctx.r[30].u8 ) };
	// 82AC83A8: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AC83AC: C01F0070  lfs f0, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC83B0: C1AB0018  lfs f13, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC83B4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AC83B8: 4199006C  bgt cr6, 0x82ac8424
	if ctx.cr[6].gt {
	pc = 0x82AC8424; continue 'dispatch;
	}
	// 82AC83BC: 897F007A  lbz r11, 0x7a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(122 as u32) ) } as u64;
	// 82AC83C0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC83C4: 40820060  bne 0x82ac8424
	if !ctx.cr[0].eq {
	pc = 0x82AC8424; continue 'dispatch;
	}
	// 82AC83C8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC83CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC83D0: 4BFFACA9  bl 0x82ac3078
	ctx.lr = 0x82AC83D4;
	sub_82AC3078(ctx, base);
	// 82AC83D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC83D8: 4BFFFEA9  bl 0x82ac8280
	ctx.lr = 0x82AC83DC;
	sub_82AC8280(ctx, base);
	// 82AC83DC: 48000044  b 0x82ac8420
	pc = 0x82AC8420; continue 'dispatch;
	// 82AC83E0: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AC83E4: C01F0070  lfs f0, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC83E8: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82AC83EC: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC83F0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AC83F4: 41990028  bgt cr6, 0x82ac841c
	if ctx.cr[6].gt {
	pc = 0x82AC841C; continue 'dispatch;
	}
	// 82AC83F8: 897F0079  lbz r11, 0x79(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(121 as u32) ) } as u64;
	// 82AC83FC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC8400: 4082001C  bne 0x82ac841c
	if !ctx.cr[0].eq {
	pc = 0x82AC841C; continue 'dispatch;
	}
	// 82AC8404: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC8408: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC840C: 4BFFAC6D  bl 0x82ac3078
	ctx.lr = 0x82AC8410;
	sub_82AC3078(ctx, base);
	// 82AC8410: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8414: 4BFFFE6D  bl 0x82ac8280
	ctx.lr = 0x82AC8418;
	sub_82AC8280(ctx, base);
	// 82AC8418: 9BDF0079  stb r30, 0x79(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(121 as u32), ctx.r[30].u8 ) };
	// 82AC841C: 9BDF007C  stb r30, 0x7c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[30].u8 ) };
	// 82AC8420: 9BDF007A  stb r30, 0x7a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(122 as u32), ctx.r[30].u8 ) };
	// 82AC8424: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC8428: 486DFD94  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC8430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC8430 size=112
    let mut pc: u32 = 0x82AC8430;
    'dispatch: loop {
        match pc {
            0x82AC8430 => {
    //   block [0x82AC8430..0x82AC84A0)
	// 82AC8430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC8434: 486DFD39  bl 0x831a816c
	ctx.lr = 0x82AC8438;
	sub_831A8130(ctx, base);
	// 82AC8438: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC843C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC8440: 4868C1C1  bl 0x83154600
	ctx.lr = 0x82AC8444;
	sub_83154600(ctx, base);
	// 82AC8444: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC8448: 4BF4AA71  bl 0x82a12eb8
	ctx.lr = 0x82AC844C;
	sub_82A12EB8(ctx, base);
	// 82AC844C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC8450: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8454: 4BFFFC0D  bl 0x82ac8060
	ctx.lr = 0x82AC8458;
	sub_82AC8060(ctx, base);
	// 82AC8458: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC845C: 4BFF9B3D  bl 0x82ac1f98
	ctx.lr = 0x82AC8460;
	sub_82AC1F98(ctx, base);
	// 82AC8460: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 82AC8464: 419A002C  beq cr6, 0x82ac8490
	if ctx.cr[6].eq {
	pc = 0x82AC8490; continue 'dispatch;
	}
	// 82AC8468: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC846C: 4BFFCE45  bl 0x82ac52b0
	ctx.lr = 0x82AC8470;
	sub_82AC52B0(ctx, base);
	// 82AC8470: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC8474: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC8478: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC847C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC8480: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AC8484: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC8488: 4E800421  bctrl
	ctx.lr = 0x82AC848C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC848C: 4800000C  b 0x82ac8498
	pc = 0x82AC8498; continue 'dispatch;
	// 82AC8490: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8494: 4BFFFC5D  bl 0x82ac80f0
	ctx.lr = 0x82AC8498;
	sub_82AC80F0(ctx, base);
	// 82AC8498: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC849C: 486DFD20  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC84A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC84A0 size=304
    let mut pc: u32 = 0x82AC84A0;
    'dispatch: loop {
        match pc {
            0x82AC84A0 => {
    //   block [0x82AC84A0..0x82AC85D0)
	// 82AC84A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC84A4: 486DFCC5  bl 0x831a8168
	ctx.lr = 0x82AC84A8;
	sub_831A8130(ctx, base);
	// 82AC84A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC84AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC84B0: 4868C151  bl 0x83154600
	ctx.lr = 0x82AC84B4;
	sub_83154600(ctx, base);
	// 82AC84B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC84B8: 4BD23D21  bl 0x827ec1d8
	ctx.lr = 0x82AC84BC;
	sub_827EC1D8(ctx, base);
	// 82AC84BC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC84C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC84C4: 4BF4A9F5  bl 0x82a12eb8
	ctx.lr = 0x82AC84C8;
	sub_82A12EB8(ctx, base);
	// 82AC84C8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AC84CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC84D0: 48000111  bl 0x82ac85e0
	ctx.lr = 0x82AC84D4;
	sub_82AC85E0(ctx, base);
	// 82AC84D4: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82AC84D8: 41980060  blt cr6, 0x82ac8538
	if ctx.cr[6].lt {
	pc = 0x82AC8538; continue 'dispatch;
	}
	// 82AC84DC: 419A001C  beq cr6, 0x82ac84f8
	if ctx.cr[6].eq {
	pc = 0x82AC84F8; continue 'dispatch;
	}
	// 82AC84E0: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 82AC84E4: 40980090  bge cr6, 0x82ac8574
	if !ctx.cr[6].lt {
	pc = 0x82AC8574; continue 'dispatch;
	}
	// 82AC84E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC84EC: 4BF9B7F5  bl 0x82a63ce0
	ctx.lr = 0x82AC84F0;
	sub_82A63CE0(ctx, base);
	// 82AC84F0: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82AC84F4: 48000078  b 0x82ac856c
	pc = 0x82AC856C; continue 'dispatch;
	// 82AC84F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC84FC: 4BFFFF35  bl 0x82ac8430
	ctx.lr = 0x82AC8500;
	sub_82AC8430(ctx, base);
	// 82AC8500: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AC8504: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC8508: 409A006C  bne cr6, 0x82ac8574
	if !ctx.cr[6].eq {
	pc = 0x82AC8574; continue 'dispatch;
	}
	// 82AC850C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC8510: 4BFF9A89  bl 0x82ac1f98
	ctx.lr = 0x82AC8514;
	sub_82AC1F98(ctx, base);
	// 82AC8514: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 82AC8518: 419A0018  beq cr6, 0x82ac8530
	if ctx.cr[6].eq {
	pc = 0x82AC8530; continue 'dispatch;
	}
	// 82AC851C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82AC8520: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC8524: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AC8528: C02B6150  lfs f1, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC852C: 4BFFD075  bl 0x82ac55a0
	ctx.lr = 0x82AC8530;
	sub_82AC55A0(ctx, base);
	// 82AC8530: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82AC8534: 48000038  b 0x82ac856c
	pc = 0x82AC856C; continue 'dispatch;
	// 82AC8538: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC853C: 4BFF9A5D  bl 0x82ac1f98
	ctx.lr = 0x82AC8540;
	sub_82AC1F98(ctx, base);
	// 82AC8540: 3963FFFE  addi r11, r3, -2
	ctx.r[11].s64 = ctx.r[3].s64 + -2;
	// 82AC8544: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82AC8548: 1D4B0024  mulli r10, r11, 0x24
	ctx.r[10].s64 = ctx.r[11].s64 * 36;
	// 82AC854C: 39699960  addi r11, r9, -0x66a0
	ctx.r[11].s64 = ctx.r[9].s64 + -26272;
	// 82AC8550: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC8554: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AC8558: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82AC855C: 4BF9B775  bl 0x82a63cd0
	ctx.lr = 0x82AC8560;
	sub_82A63CD0(ctx, base);
	// 82AC8560: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8564: 4BFFFAAD  bl 0x82ac8010
	ctx.lr = 0x82AC8568;
	sub_82AC8010(ctx, base);
	// 82AC8568: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC856C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8570: 48000079  bl 0x82ac85e8
	ctx.lr = 0x82AC8574;
	sub_82AC85E8(ctx, base);
	// 82AC8574: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8578: 4BF9B779  bl 0x82a63cf0
	ctx.lr = 0x82AC857C;
	sub_82A63CF0(ctx, base);
	// 82AC857C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC8580: 40820048  bne 0x82ac85c8
	if !ctx.cr[0].eq {
	pc = 0x82AC85C8; continue 'dispatch;
	}
	// 82AC8584: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8588: 4BFFFD89  bl 0x82ac8310
	ctx.lr = 0x82AC858C;
	sub_82AC8310(ctx, base);
	// 82AC858C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8590: 4BFFF8E1  bl 0x82ac7e70
	ctx.lr = 0x82AC8594;
	sub_82AC7E70(ctx, base);
	// 82AC8594: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8598: 4BFFF979  bl 0x82ac7f10
	ctx.lr = 0x82AC859C;
	sub_82AC7F10(ctx, base);
	// 82AC859C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC85A0: 483911D9  bl 0x82e59778
	ctx.lr = 0x82AC85A4;
	sub_82E59778(ctx, base);
	// 82AC85A4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC85A8: C1BF0070  lfs f13, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC85AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC85B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC85B4: C00B8398  lfs f0, -0x7c68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31848 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC85B8: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AC85BC: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82AC85C0: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82AC85C4: 480000CD  bl 0x82ac8690
	ctx.lr = 0x82AC85C8;
	sub_82AC8690(ctx, base);
	// 82AC85C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC85CC: 486DFBEC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC85D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC85D0 size=16
    let mut pc: u32 = 0x82AC85D0;
    'dispatch: loop {
        match pc {
            0x82AC85D0 => {
    //   block [0x82AC85D0..0x82AC85E0)
	// 82AC85D0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC85D4: 396B99F8  addi r11, r11, -0x6608
	ctx.r[11].s64 = ctx.r[11].s64 + -26120;
	// 82AC85D8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC85DC: 48393FAC  b 0x82e5c588
	sub_82E5C588(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC85E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC85E0 size=8
    let mut pc: u32 = 0x82AC85E0;
    'dispatch: loop {
        match pc {
            0x82AC85E0 => {
    //   block [0x82AC85E0..0x82AC85E8)
	// 82AC85E0: 80630064  lwz r3, 0x64(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AC85E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC85E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC85E8 size=8
    let mut pc: u32 = 0x82AC85E8;
    'dispatch: loop {
        match pc {
            0x82AC85E8 => {
    //   block [0x82AC85E8..0x82AC85F0)
	// 82AC85E8: 90830064  stw r4, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[4].u32 ) };
	// 82AC85EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC85F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC85F0 size=72
    let mut pc: u32 = 0x82AC85F0;
    'dispatch: loop {
        match pc {
            0x82AC85F0 => {
    //   block [0x82AC85F0..0x82AC8638)
	// 82AC85F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC85F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC85F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC85FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC8600: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC8604: 48394325  bl 0x82e5c928
	ctx.lr = 0x82AC8608;
	sub_82E5C928(ctx, base);
	// 82AC8608: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AC860C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC8610: 394A99F8  addi r10, r10, -0x6608
	ctx.r[10].s64 = ctx.r[10].s64 + -26120;
	// 82AC8614: 997F0060  stb r11, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 82AC8618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC861C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AC8620: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AC8624: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AC8628: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC862C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC8630: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC8634: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC8638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC8638 size=88
    let mut pc: u32 = 0x82AC8638;
    'dispatch: loop {
        match pc {
            0x82AC8638 => {
    //   block [0x82AC8638..0x82AC8690)
	// 82AC8638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC863C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC8640: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC8644: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC8648: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC864C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC8650: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC8654: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC8658: 396B99F8  addi r11, r11, -0x6608
	ctx.r[11].s64 = ctx.r[11].s64 + -26120;
	// 82AC865C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC8660: 48393F29  bl 0x82e5c588
	ctx.lr = 0x82AC8664;
	sub_82E5C588(ctx, base);
	// 82AC8664: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC8668: 4182000C  beq 0x82ac8674
	if ctx.cr[0].eq {
	pc = 0x82AC8674; continue 'dispatch;
	}
	// 82AC866C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8670: 48329D69  bl 0x82df23d8
	ctx.lr = 0x82AC8674;
	sub_82DF23D8(ctx, base);
	// 82AC8674: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8678: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC867C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC8680: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC8684: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC8688: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC868C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC8690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC8690 size=156
    let mut pc: u32 = 0x82AC8690;
    'dispatch: loop {
        match pc {
            0x82AC8690 => {
    //   block [0x82AC8690..0x82AC872C)
	// 82AC8690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC8694: 486DFACD  bl 0x831a8160
	ctx.lr = 0x82AC8698;
	sub_831A8130(ctx, base);
	// 82AC8698: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC869C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC86A0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82AC86A4: 4868BF5D  bl 0x83154600
	ctx.lr = 0x82AC86A8;
	sub_83154600(ctx, base);
	// 82AC86A8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82AC86AC: 4BFFBFE5  bl 0x82ac4690
	ctx.lr = 0x82AC86B0;
	sub_82AC4690(ctx, base);
	// 82AC86B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC86B4: 57DD063F  clrlwi. r29, r30, 0x18
	ctx.r[29].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AC86B8: 41820058  beq 0x82ac8710
	if ctx.cr[0].eq {
	pc = 0x82AC8710; continue 'dispatch;
	}
	// 82AC86BC: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC86C0: 41820050  beq 0x82ac8710
	if ctx.cr[0].eq {
	pc = 0x82AC8710; continue 'dispatch;
	}
	// 82AC86C4: 897F0060  lbz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AC86C8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC86CC: 40820044  bne 0x82ac8710
	if !ctx.cr[0].eq {
	pc = 0x82AC8710; continue 'dispatch;
	}
	// 82AC86D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC86D4: 4868BF2D  bl 0x83154600
	ctx.lr = 0x82AC86D8;
	sub_83154600(ctx, base);
	// 82AC86D8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AC86DC: 4BD23AFD  bl 0x827ec1d8
	ctx.lr = 0x82AC86E0;
	sub_827EC1D8(ctx, base);
	// 82AC86E0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82AC86E4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AC86E8: 4BF4A7D1  bl 0x82a12eb8
	ctx.lr = 0x82AC86EC;
	sub_82A12EB8(ctx, base);
	// 82AC86EC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC86F0: 4BFFD1A1  bl 0x82ac5890
	ctx.lr = 0x82AC86F4;
	sub_82AC5890(ctx, base);
	// 82AC86F4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AC86F8: 4BFFAEF9  bl 0x82ac35f0
	ctx.lr = 0x82AC86FC;
	sub_82AC35F0(ctx, base);
	// 82AC86FC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AC8700: 4BF9B5E1  bl 0x82a63ce0
	ctx.lr = 0x82AC8704;
	sub_82A63CE0(ctx, base);
	// 82AC8704: 3D600FFF  lis r11, 0xfff
	ctx.r[11].s64 = 268369920;
	// 82AC8708: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 82AC870C: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AC8710: 9BDF0060  stb r30, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[30].u8 ) };
	// 82AC8714: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82AC8718: 419A000C  beq cr6, 0x82ac8724
	if ctx.cr[6].eq {
	pc = 0x82AC8724; continue 'dispatch;
	}
	// 82AC871C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AC8720: 4BFFAED1  bl 0x82ac35f0
	ctx.lr = 0x82AC8724;
	sub_82AC35F0(ctx, base);
	// 82AC8724: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AC8728: 486DFA88  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC8730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC8730 size=96
    let mut pc: u32 = 0x82AC8730;
    'dispatch: loop {
        match pc {
            0x82AC8730 => {
    //   block [0x82AC8730..0x82AC8790)
	// 82AC8730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC8734: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC8738: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC873C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC8740: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC8744: 4BFFFEAD  bl 0x82ac85f0
	ctx.lr = 0x82AC8748;
	sub_82AC85F0(ctx, base);
	// 82AC8748: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC874C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82AC8750: 396B9A20  addi r11, r11, -0x65e0
	ctx.r[11].s64 = ctx.r[11].s64 + -26080;
	// 82AC8754: 388A893C  addi r4, r10, -0x76c4
	ctx.r[4].s64 = ctx.r[10].s64 + -30404;
	// 82AC8758: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC875C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC8760: 4832B2A9  bl 0x82df3a08
	ctx.lr = 0x82AC8764;
	sub_82DF3A08(ctx, base);
	// 82AC8764: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8768: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AC876C: 48390F7D  bl 0x82e596e8
	ctx.lr = 0x82AC8770;
	sub_82E596E8(ctx, base);
	// 82AC8770: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC8774: 4832ACB5  bl 0x82df3428
	ctx.lr = 0x82AC8778;
	sub_82DF3428(ctx, base);
	// 82AC8778: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC877C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC8780: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC8784: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC8788: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC878C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC8790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC8790 size=136
    let mut pc: u32 = 0x82AC8790;
    'dispatch: loop {
        match pc {
            0x82AC8790 => {
    //   block [0x82AC8790..0x82AC8818)
	// 82AC8790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC8794: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC8798: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC879C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC87A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC87A4: 4BFFFE4D  bl 0x82ac85f0
	ctx.lr = 0x82AC87A8;
	sub_82AC85F0(ctx, base);
	// 82AC87A8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC87AC: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82AC87B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC87B4: 39299A60  addi r9, r9, -0x65a0
	ctx.r[9].s64 = ctx.r[9].s64 + -26016;
	// 82AC87B8: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82AC87BC: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82AC87C0: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC87C4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC87C8: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82AC87CC: 997F0070  stb r11, 0x70(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u8 ) };
	// 82AC87D0: 997F0071  stb r11, 0x71(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(113 as u32), ctx.r[11].u8 ) };
	// 82AC87D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC87D8: 38880740  addi r4, r8, 0x740
	ctx.r[4].s64 = ctx.r[8].s64 + 1856;
	// 82AC87DC: 4832B22D  bl 0x82df3a08
	ctx.lr = 0x82AC87E0;
	sub_82DF3A08(ctx, base);
	// 82AC87E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC87E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AC87E8: 48390F01  bl 0x82e596e8
	ctx.lr = 0x82AC87EC;
	sub_82E596E8(ctx, base);
	// 82AC87EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC87F0: 4832AC39  bl 0x82df3428
	ctx.lr = 0x82AC87F4;
	sub_82DF3428(ctx, base);
	// 82AC87F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC87F8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC87FC: 4BFFFDED  bl 0x82ac85e8
	ctx.lr = 0x82AC8800;
	sub_82AC85E8(ctx, base);
	// 82AC8800: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8804: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC8808: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC880C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC8810: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC8814: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC8818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC8818 size=76
    let mut pc: u32 = 0x82AC8818;
    'dispatch: loop {
        match pc {
            0x82AC8818 => {
    //   block [0x82AC8818..0x82AC8864)
	// 82AC8818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC881C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC8820: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC8824: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC8828: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC882C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC8830: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC8834: 4BFFFD9D  bl 0x82ac85d0
	ctx.lr = 0x82AC8838;
	sub_82AC85D0(ctx, base);
	// 82AC8838: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC883C: 4182000C  beq 0x82ac8848
	if ctx.cr[0].eq {
	pc = 0x82AC8848; continue 'dispatch;
	}
	// 82AC8840: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8844: 48329B95  bl 0x82df23d8
	ctx.lr = 0x82AC8848;
	sub_82DF23D8(ctx, base);
	// 82AC8848: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC884C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC8850: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC8854: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC8858: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC885C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC8860: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC8868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC8868 size=108
    let mut pc: u32 = 0x82AC8868;
    'dispatch: loop {
        match pc {
            0x82AC8868 => {
    //   block [0x82AC8868..0x82AC88D4)
	// 82AC8868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC886C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC8870: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC8874: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC8878: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC887C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC8880: 4868BD81  bl 0x83154600
	ctx.lr = 0x82AC8884;
	sub_83154600(ctx, base);
	// 82AC8884: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC8888: 4BFF9711  bl 0x82ac1f98
	ctx.lr = 0x82AC888C;
	sub_82AC1F98(ctx, base);
	// 82AC888C: 2F030007  cmpwi cr6, r3, 7
	ctx.cr[6].compare_i32(ctx.r[3].s32, 7, &mut ctx.xer);
	// 82AC8890: 419A0024  beq cr6, 0x82ac88b4
	if ctx.cr[6].eq {
	pc = 0x82AC88B4; continue 'dispatch;
	}
	// 82AC8894: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82AC8898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC889C: 4BFFA7DD  bl 0x82ac3078
	ctx.lr = 0x82AC88A0;
	sub_82AC3078(ctx, base);
	// 82AC88A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC88A4: 4BFFC43D  bl 0x82ac4ce0
	ctx.lr = 0x82AC88A8;
	sub_82AC4CE0(ctx, base);
	// 82AC88A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC88AC: 4BFFC11D  bl 0x82ac49c8
	ctx.lr = 0x82AC88B0;
	sub_82AC49C8(ctx, base);
	// 82AC88B0: 987E0071  stb r3, 0x71(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(113 as u32), ctx.r[3].u8 ) };
	// 82AC88B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AC88B8: 997E0070  stb r11, 0x70(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(112 as u32), ctx.r[11].u8 ) };
	// 82AC88BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC88C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC88C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC88C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC88CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC88D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC88D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC88D8 size=80
    let mut pc: u32 = 0x82AC88D8;
    'dispatch: loop {
        match pc {
            0x82AC88D8 => {
    //   block [0x82AC88D8..0x82AC8928)
	// 82AC88D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC88DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC88E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC88E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC88E8: 89630070  lbz r11, 0x70(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AC88EC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC88F0: 41820024  beq 0x82ac8914
	if ctx.cr[0].eq {
	pc = 0x82AC8914; continue 'dispatch;
	}
	// 82AC88F4: 4868BD0D  bl 0x83154600
	ctx.lr = 0x82AC88F8;
	sub_83154600(ctx, base);
	// 82AC88F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC88FC: 4BFF969D  bl 0x82ac1f98
	ctx.lr = 0x82AC8900;
	sub_82AC1F98(ctx, base);
	// 82AC8900: 2F030007  cmpwi cr6, r3, 7
	ctx.cr[6].compare_i32(ctx.r[3].s32, 7, &mut ctx.xer);
	// 82AC8904: 419A0010  beq cr6, 0x82ac8914
	if ctx.cr[6].eq {
	pc = 0x82AC8914; continue 'dispatch;
	}
	// 82AC8908: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82AC890C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8910: 4BFF9721  bl 0x82ac2030
	ctx.lr = 0x82AC8914;
	sub_82AC2030(ctx, base);
	// 82AC8914: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AC8918: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC891C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC8920: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC8924: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC8928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC8928 size=76
    let mut pc: u32 = 0x82AC8928;
    'dispatch: loop {
        match pc {
            0x82AC8928 => {
    //   block [0x82AC8928..0x82AC8974)
	// 82AC8928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC892C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC8930: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC8934: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC8938: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC893C: 4868BCC5  bl 0x83154600
	ctx.lr = 0x82AC8940;
	sub_83154600(ctx, base);
	// 82AC8940: 4BF4A579  bl 0x82a12eb8
	ctx.lr = 0x82AC8944;
	sub_82A12EB8(ctx, base);
	// 82AC8944: 813F0068  lwz r9, 0x68(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AC8948: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC894C: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82AC8950: 80890000  lwz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC8954: C04B8398  lfs f2, -0x7c68(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31848 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AC8958: C02A6150  lfs f1, 0x6150(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC895C: 4BFFCCDD  bl 0x82ac5638
	ctx.lr = 0x82AC8960;
	sub_82AC5638(ctx, base);
	// 82AC8960: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AC8964: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC8968: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC896C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC8970: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC8978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC8978 size=68
    let mut pc: u32 = 0x82AC8978;
    'dispatch: loop {
        match pc {
            0x82AC8978 => {
    //   block [0x82AC8978..0x82AC89BC)
	// 82AC8978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC897C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC8980: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC8984: 4868BC7D  bl 0x83154600
	ctx.lr = 0x82AC8988;
	sub_83154600(ctx, base);
	// 82AC8988: 4BF4A531  bl 0x82a12eb8
	ctx.lr = 0x82AC898C;
	sub_82A12EB8(ctx, base);
	// 82AC898C: 4BFFC925  bl 0x82ac52b0
	ctx.lr = 0x82AC8990;
	sub_82AC52B0(ctx, base);
	// 82AC8990: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC8994: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC8998: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC899C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC89A0: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AC89A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC89A8: 4E800421  bctrl
	ctx.lr = 0x82AC89AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC89AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AC89B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC89B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC89B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC89C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC89C0 size=332
    let mut pc: u32 = 0x82AC89C0;
    'dispatch: loop {
        match pc {
            0x82AC89C0 => {
    //   block [0x82AC89C0..0x82AC8B0C)
	// 82AC89C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC89C4: 486DF7A5  bl 0x831a8168
	ctx.lr = 0x82AC89C8;
	sub_831A8130(ctx, base);
	// 82AC89C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC89CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC89D0: 4868BC31  bl 0x83154600
	ctx.lr = 0x82AC89D4;
	sub_83154600(ctx, base);
	// 82AC89D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC89D8: 4BD23801  bl 0x827ec1d8
	ctx.lr = 0x82AC89DC;
	sub_827EC1D8(ctx, base);
	// 82AC89DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC89E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC89E4: 4BF4A4D5  bl 0x82a12eb8
	ctx.lr = 0x82AC89E8;
	sub_82A12EB8(ctx, base);
	// 82AC89E8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AC89EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC89F0: 4BFFFBF1  bl 0x82ac85e0
	ctx.lr = 0x82AC89F4;
	sub_82AC85E0(ctx, base);
	// 82AC89F4: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82AC89F8: 41980070  blt cr6, 0x82ac8a68
	if ctx.cr[6].lt {
	pc = 0x82AC8A68; continue 'dispatch;
	}
	// 82AC89FC: 419A001C  beq cr6, 0x82ac8a18
	if ctx.cr[6].eq {
	pc = 0x82AC8A18; continue 'dispatch;
	}
	// 82AC8A00: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 82AC8A04: 409800A0  bge cr6, 0x82ac8aa4
	if !ctx.cr[6].lt {
	pc = 0x82AC8AA4; continue 'dispatch;
	}
	// 82AC8A08: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC8A0C: 4BF9B2D5  bl 0x82a63ce0
	ctx.lr = 0x82AC8A10;
	sub_82A63CE0(ctx, base);
	// 82AC8A10: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82AC8A14: 48000088  b 0x82ac8a9c
	pc = 0x82AC8A9C; continue 'dispatch;
	// 82AC8A18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8A1C: 4BFFFF5D  bl 0x82ac8978
	ctx.lr = 0x82AC8A20;
	sub_82AC8978(ctx, base);
	// 82AC8A20: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AC8A24: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC8A28: 409A007C  bne cr6, 0x82ac8aa4
	if !ctx.cr[6].eq {
	pc = 0x82AC8AA4; continue 'dispatch;
	}
	// 82AC8A2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8A30: 4BFFFEA9  bl 0x82ac88d8
	ctx.lr = 0x82AC8A34;
	sub_82AC88D8(ctx, base);
	// 82AC8A34: 897F0071  lbz r11, 0x71(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(113 as u32) ) } as u64;
	// 82AC8A38: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AC8A3C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC8A40: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82AC8A44: C02B6150  lfs f1, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC8A48: 40820014  bne 0x82ac8a5c
	if !ctx.cr[0].eq {
	pc = 0x82AC8A5C; continue 'dispatch;
	}
	// 82AC8A4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC8A50: 4BFFCB51  bl 0x82ac55a0
	ctx.lr = 0x82AC8A54;
	sub_82AC55A0(ctx, base);
	// 82AC8A54: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82AC8A58: 48000044  b 0x82ac8a9c
	pc = 0x82AC8A9C; continue 'dispatch;
	// 82AC8A5C: 3880000F  li r4, 0xf
	ctx.r[4].s64 = 15;
	// 82AC8A60: 4BFFCB41  bl 0x82ac55a0
	ctx.lr = 0x82AC8A64;
	sub_82AC55A0(ctx, base);
	// 82AC8A64: 4BFFFFAC  b 0x82ac8a10
	pc = 0x82AC8A10; continue 'dispatch;
	// 82AC8A68: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC8A6C: 4BF9B265  bl 0x82a63cd0
	ctx.lr = 0x82AC8A70;
	sub_82A63CD0(ctx, base);
	// 82AC8A70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC8A74: 4BFF9525  bl 0x82ac1f98
	ctx.lr = 0x82AC8A78;
	sub_82AC1F98(ctx, base);
	// 82AC8A78: 3963FFFB  addi r11, r3, -5
	ctx.r[11].s64 = ctx.r[3].s64 + -5;
	// 82AC8A7C: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82AC8A80: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AC8A84: 39699A44  addi r11, r9, -0x65bc
	ctx.r[11].s64 = ctx.r[9].s64 + -26044;
	// 82AC8A88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8A8C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82AC8A90: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82AC8A94: 4BFFFE95  bl 0x82ac8928
	ctx.lr = 0x82AC8A98;
	sub_82AC8928(ctx, base);
	// 82AC8A98: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC8A9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8AA0: 4BFFFB49  bl 0x82ac85e8
	ctx.lr = 0x82AC8AA4;
	sub_82AC85E8(ctx, base);
	// 82AC8AA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8AA8: 4BF9B249  bl 0x82a63cf0
	ctx.lr = 0x82AC8AAC;
	sub_82A63CF0(ctx, base);
	// 82AC8AAC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC8AB0: 40820054  bne 0x82ac8b04
	if !ctx.cr[0].eq {
	pc = 0x82AC8B04; continue 'dispatch;
	}
	// 82AC8AB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8AB8: 48390CC1  bl 0x82e59778
	ctx.lr = 0x82AC8ABC;
	sub_82E59778(ctx, base);
	// 82AC8ABC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC8AC0: C1BF006C  lfs f13, 0x6c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC8AC4: 895F0070  lbz r10, 0x70(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82AC8AC8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC8ACC: C00B8398  lfs f0, -0x7c68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31848 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC8AD0: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AC8AD4: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82AC8AD8: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82AC8ADC: 4082001C  bne 0x82ac8af8
	if !ctx.cr[0].eq {
	pc = 0x82AC8AF8; continue 'dispatch;
	}
	// 82AC8AE0: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82AC8AE4: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AC8AE8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82AC8AEC: 4198000C  blt cr6, 0x82ac8af8
	if ctx.cr[6].lt {
	pc = 0x82AC8AF8; continue 'dispatch;
	}
	// 82AC8AF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8AF4: 4BFFFD75  bl 0x82ac8868
	ctx.lr = 0x82AC8AF8;
	sub_82AC8868(ctx, base);
	// 82AC8AF8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC8AFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8B00: 4BFFFB91  bl 0x82ac8690
	ctx.lr = 0x82AC8B04;
	sub_82AC8690(ctx, base);
	// 82AC8B04: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC8B08: 486DF6B0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC8B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC8B10 size=128
    let mut pc: u32 = 0x82AC8B10;
    'dispatch: loop {
        match pc {
            0x82AC8B10 => {
    //   block [0x82AC8B10..0x82AC8B90)
	// 82AC8B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC8B14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC8B18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC8B1C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC8B20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC8B24: 4BFFFACD  bl 0x82ac85f0
	ctx.lr = 0x82AC8B28;
	sub_82AC85F0(ctx, base);
	// 82AC8B28: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC8B2C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AC8B30: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82AC8B34: 394A9A8C  addi r10, r10, -0x6574
	ctx.r[10].s64 = ctx.r[10].s64 + -25972;
	// 82AC8B38: 993F006C  stb r9, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[9].u8 ) };
	// 82AC8B3C: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 82AC8B40: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC8B44: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AC8B48: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82AC8B4C: 38894418  addi r4, r9, 0x4418
	ctx.r[4].s64 = ctx.r[9].s64 + 17432;
	// 82AC8B50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC8B54: 4832AEB5  bl 0x82df3a08
	ctx.lr = 0x82AC8B58;
	sub_82DF3A08(ctx, base);
	// 82AC8B58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8B5C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AC8B60: 48390B89  bl 0x82e596e8
	ctx.lr = 0x82AC8B64;
	sub_82E596E8(ctx, base);
	// 82AC8B64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC8B68: 4832A8C1  bl 0x82df3428
	ctx.lr = 0x82AC8B6C;
	sub_82DF3428(ctx, base);
	// 82AC8B6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8B70: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC8B74: 4BFFFA75  bl 0x82ac85e8
	ctx.lr = 0x82AC8B78;
	sub_82AC85E8(ctx, base);
	// 82AC8B78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8B7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC8B80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC8B84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC8B88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC8B8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC8B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC8B90 size=620
    let mut pc: u32 = 0x82AC8B90;
    'dispatch: loop {
        match pc {
            0x82AC8B90 => {
    //   block [0x82AC8B90..0x82AC8DFC)
	// 82AC8B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC8B94: 486DF5CD  bl 0x831a8160
	ctx.lr = 0x82AC8B98;
	sub_831A8130(ctx, base);
	// 82AC8B98: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC8B9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC8BA0: 4868BA61  bl 0x83154600
	ctx.lr = 0x82AC8BA4;
	sub_83154600(ctx, base);
	// 82AC8BA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC8BA8: 4BD23631  bl 0x827ec1d8
	ctx.lr = 0x82AC8BAC;
	sub_827EC1D8(ctx, base);
	// 82AC8BAC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AC8BB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC8BB4: 4BF4A305  bl 0x82a12eb8
	ctx.lr = 0x82AC8BB8;
	sub_82A12EB8(ctx, base);
	// 82AC8BB8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC8BBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8BC0: 4BFFFA21  bl 0x82ac85e0
	ctx.lr = 0x82AC8BC4;
	sub_82AC85E0(ctx, base);
	// 82AC8BC4: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82AC8BC8: 3F60820C  lis r27, -0x7df4
	ctx.r[27].s64 = -2113142784;
	// 82AC8BCC: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82AC8BD0: 41980110  blt cr6, 0x82ac8ce0
	if ctx.cr[6].lt {
	pc = 0x82AC8CE0; continue 'dispatch;
	}
	// 82AC8BD4: 419A00B0  beq cr6, 0x82ac8c84
	if ctx.cr[6].eq {
	pc = 0x82AC8C84; continue 'dispatch;
	}
	// 82AC8BD8: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 82AC8BDC: 41980064  blt cr6, 0x82ac8c40
	if ctx.cr[6].lt {
	pc = 0x82AC8C40; continue 'dispatch;
	}
	// 82AC8BE0: 409A01A0  bne cr6, 0x82ac8d80
	if !ctx.cr[6].eq {
	pc = 0x82AC8D80; continue 'dispatch;
	}
	// 82AC8BE4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC8BE8: 4BFFC6C9  bl 0x82ac52b0
	ctx.lr = 0x82AC8BEC;
	sub_82AC52B0(ctx, base);
	// 82AC8BEC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC8BF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC8BF4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC8BF8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC8BFC: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AC8C00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC8C04: 4E800421  bctrl
	ctx.lr = 0x82AC8C08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC8C08: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AC8C0C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC8C10: 409A0170  bne cr6, 0x82ac8d80
	if !ctx.cr[6].eq {
	pc = 0x82AC8D80; continue 'dispatch;
	}
	// 82AC8C14: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82AC8C18: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC8C1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC8C20: C02B6150  lfs f1, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC8C24: 4BFFC97D  bl 0x82ac55a0
	ctx.lr = 0x82AC8C28;
	sub_82AC55A0(ctx, base);
	// 82AC8C28: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82AC8C2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8C30: 4BFFF9B9  bl 0x82ac85e8
	ctx.lr = 0x82AC8C34;
	sub_82AC85E8(ctx, base);
	// 82AC8C34: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AC8C38: 4BF9B0A9  bl 0x82a63ce0
	ctx.lr = 0x82AC8C3C;
	sub_82A63CE0(ctx, base);
	// 82AC8C3C: 48000144  b 0x82ac8d80
	pc = 0x82AC8D80; continue 'dispatch;
	// 82AC8C40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC8C44: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82AC8C48: 4BFFB899  bl 0x82ac44e0
	ctx.lr = 0x82AC8C4C;
	sub_82AC44E0(ctx, base);
	// 82AC8C4C: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82AC8C50: 409A0008  bne cr6, 0x82ac8c58
	if !ctx.cr[6].eq {
	pc = 0x82AC8C58; continue 'dispatch;
	}
	// 82AC8C54: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 82AC8C58: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82AC8C5C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC8C60: 409A0120  bne cr6, 0x82ac8d80
	if !ctx.cr[6].eq {
	pc = 0x82AC8D80; continue 'dispatch;
	}
	// 82AC8C64: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82AC8C68: C05B8398  lfs f2, -0x7c68(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-31848 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AC8C6C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82AC8C70: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC8C74: C02B6150  lfs f1, 0x6150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC8C78: 4BFFC9C1  bl 0x82ac5638
	ctx.lr = 0x82AC8C7C;
	sub_82AC5638(ctx, base);
	// 82AC8C7C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82AC8C80: 480000F8  b 0x82ac8d78
	pc = 0x82AC8D78; continue 'dispatch;
	// 82AC8C84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC8C88: 4BFFC629  bl 0x82ac52b0
	ctx.lr = 0x82AC8C8C;
	sub_82AC52B0(ctx, base);
	// 82AC8C8C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC8C90: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AC8C94: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC8C98: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC8C9C: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AC8CA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC8CA4: 4E800421  bctrl
	ctx.lr = 0x82AC8CA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC8CA8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AC8CAC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AC8CB0: 409A00D0  bne cr6, 0x82ac8d80
	if !ctx.cr[6].eq {
	pc = 0x82AC8D80; continue 'dispatch;
	}
	// 82AC8CB4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82AC8CB8: C05B8398  lfs f2, -0x7c68(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-31848 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AC8CBC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC8CC0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC8CC4: C02B6150  lfs f1, 0x6150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC8CC8: 4BFFC971  bl 0x82ac5638
	ctx.lr = 0x82AC8CCC;
	sub_82AC5638(ctx, base);
	// 82AC8CCC: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82AC8CD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC8CD4: 4BFF935D  bl 0x82ac2030
	ctx.lr = 0x82AC8CD8;
	sub_82AC2030(ctx, base);
	// 82AC8CD8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82AC8CDC: 4800009C  b 0x82ac8d78
	pc = 0x82AC8D78; continue 'dispatch;
	// 82AC8CE0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AC8CE4: 4BF9AFED  bl 0x82a63cd0
	ctx.lr = 0x82AC8CE8;
	sub_82A63CD0(ctx, base);
	// 82AC8CE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC8CEC: 4BFF92AD  bl 0x82ac1f98
	ctx.lr = 0x82AC8CF0;
	sub_82AC1F98(ctx, base);
	// 82AC8CF0: 2F030009  cmpwi cr6, r3, 9
	ctx.cr[6].compare_i32(ctx.r[3].s32, 9, &mut ctx.xer);
	// 82AC8CF4: 409A0068  bne cr6, 0x82ac8d5c
	if !ctx.cr[6].eq {
	pc = 0x82AC8D5C; continue 'dispatch;
	}
	// 82AC8CF8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AC8CFC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC8D00: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82AC8D04: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82AC8D08: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 82AC8D0C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AC8D10: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AC8D14: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82AC8D18: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AC8D1C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AC8D20: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82AC8D24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC8E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC8E00 size=108
    let mut pc: u32 = 0x82AC8E00;
    'dispatch: loop {
        match pc {
            0x82AC8E00 => {
    //   block [0x82AC8E00..0x82AC8E6C)
	// 82AC8E00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC8E04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC8E08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC8E0C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC8E10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC8E14: 4BFFF7DD  bl 0x82ac85f0
	ctx.lr = 0x82AC8E18;
	sub_82AC85F0(ctx, base);
	// 82AC8E18: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC8E1C: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 82AC8E20: 396B9AB4  addi r11, r11, -0x654c
	ctx.r[11].s64 = ctx.r[11].s64 + -25932;
	// 82AC8E24: 388A6564  addi r4, r10, 0x6564
	ctx.r[4].s64 = ctx.r[10].s64 + 25956;
	// 82AC8E28: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC8E2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC8E30: 4832ABD9  bl 0x82df3a08
	ctx.lr = 0x82AC8E34;
	sub_82DF3A08(ctx, base);
	// 82AC8E34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8E38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AC8E3C: 483908AD  bl 0x82e596e8
	ctx.lr = 0x82AC8E40;
	sub_82E596E8(ctx, base);
	// 82AC8E40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC8E44: 4832A5E5  bl 0x82df3428
	ctx.lr = 0x82AC8E48;
	sub_82DF3428(ctx, base);
	// 82AC8E48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8E4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC8E50: 4BFFF799  bl 0x82ac85e8
	ctx.lr = 0x82AC8E54;
	sub_82AC85E8(ctx, base);
	// 82AC8E54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8E58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC8E5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC8E60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC8E64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC8E68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC8E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC8E70 size=128
    let mut pc: u32 = 0x82AC8E70;
    'dispatch: loop {
        match pc {
            0x82AC8E70 => {
    //   block [0x82AC8E70..0x82AC8EF0)
	// 82AC8E70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC8E74: 486DF2F9  bl 0x831a816c
	ctx.lr = 0x82AC8E78;
	sub_831A8130(ctx, base);
	// 82AC8E78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC8E7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC8E80: 4868B781  bl 0x83154600
	ctx.lr = 0x82AC8E84;
	sub_83154600(ctx, base);
	// 82AC8E84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC8E88: 4BF4A031  bl 0x82a12eb8
	ctx.lr = 0x82AC8E8C;
	sub_82A12EB8(ctx, base);
	// 82AC8E8C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC8E90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC8E94: 4BD23345  bl 0x827ec1d8
	ctx.lr = 0x82AC8E98;
	sub_827EC1D8(ctx, base);
	// 82AC8E98: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC8E9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8EA0: 4BFFF741  bl 0x82ac85e0
	ctx.lr = 0x82AC8EA4;
	sub_82AC85E0(ctx, base);
	// 82AC8EA4: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82AC8EA8: 41980018  blt cr6, 0x82ac8ec0
	if ctx.cr[6].lt {
	pc = 0x82AC8EC0; continue 'dispatch;
	}
	// 82AC8EAC: 409A003C  bne cr6, 0x82ac8ee8
	if !ctx.cr[6].eq {
	pc = 0x82AC8EE8; continue 'dispatch;
	}
	// 82AC8EB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC8EB4: 4BF9AE2D  bl 0x82a63ce0
	ctx.lr = 0x82AC8EB8;
	sub_82A63CE0(ctx, base);
	// 82AC8EB8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82AC8EBC: 48000024  b 0x82ac8ee0
	pc = 0x82AC8EE0; continue 'dispatch;
	// 82AC8EC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC8EC4: 4BF9AE0D  bl 0x82a63cd0
	ctx.lr = 0x82AC8EC8;
	sub_82A63CD0(ctx, base);
	// 82AC8EC8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82AC8ECC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC8ED0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC8ED4: C02B6150  lfs f1, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AC8ED8: 4BFFC6C9  bl 0x82ac55a0
	ctx.lr = 0x82AC8EDC;
	sub_82AC55A0(ctx, base);
	// 82AC8EDC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC8EE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC8EE4: 4BFFF705  bl 0x82ac85e8
	ctx.lr = 0x82AC8EE8;
	sub_82AC85E8(ctx, base);
	// 82AC8EE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC8EEC: 486DF2D0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC8EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC8EF0 size=12
    let mut pc: u32 = 0x82AC8EF0;
    'dispatch: loop {
        match pc {
            0x82AC8EF0 => {
    //   block [0x82AC8EF0..0x82AC8EFC)
	// 82AC8EF0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AC8EF4: 806BE65C  lwz r3, -0x19a4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6564 as u32) ) } as u64;
	// 82AC8EF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC8F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC8F00 size=136
    let mut pc: u32 = 0x82AC8F00;
    'dispatch: loop {
        match pc {
            0x82AC8F00 => {
    //   block [0x82AC8F00..0x82AC8F88)
	// 82AC8F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC8F04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC8F08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC8F0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC8F10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC8F14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC8F18: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82AC8F1C: 4BA48ABD  bl 0x825119d8
	ctx.lr = 0x82AC8F20;
	sub_825119D8(ctx, base);
	// 82AC8F20: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82AC8F24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC8F28: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82AC8F2C: 4832AADD  bl 0x82df3a08
	ctx.lr = 0x82AC8F30;
	sub_82DF3A08(ctx, base);
	// 82AC8F30: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC8F34: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AC8F38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC8F3C: 4BA3F845  bl 0x82508780
	ctx.lr = 0x82AC8F40;
	sub_82508780(ctx, base);
	// 82AC8F40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC8F44: 4832A4E5  bl 0x82df3428
	ctx.lr = 0x82AC8F48;
	sub_82DF3428(ctx, base);
	// 82AC8F48: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC8F4C: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82AC8F50: 409A0008  bne cr6, 0x82ac8f58
	if !ctx.cr[6].eq {
	pc = 0x82AC8F58; continue 'dispatch;
	}
	// 82AC8F54: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC8F58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC8F5C: 4BA3F845  bl 0x825087a0
	ctx.lr = 0x82AC8F60;
	sub_825087A0(ctx, base);
	// 82AC8F60: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82AC8F64: 48540055  bl 0x83008fb8
	ctx.lr = 0x82AC8F68;
	sub_83008FB8(ctx, base);
	// 82AC8F68: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AC8F6C: 906BE65C  stw r3, -0x19a4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-6564 as u32), ctx.r[3].u32 ) };
	// 82AC8F70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC8F74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC8F78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC8F7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC8F80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC8F84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC8F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC8F88 size=136
    let mut pc: u32 = 0x82AC8F88;
    'dispatch: loop {
        match pc {
            0x82AC8F88 => {
    //   block [0x82AC8F88..0x82AC9010)
	// 82AC8F88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC8F8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC8F90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC8F94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC8F98: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC8F9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC8FA0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC8FA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC8FA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC8FAC: 4BA4651D  bl 0x8250f4c8
	ctx.lr = 0x82AC8FB0;
	sub_8250F4C8(ctx, base);
	// 82AC8FB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC8FB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC8FB8: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82AC8FBC: 409A0008  bne cr6, 0x82ac8fc4
	if !ctx.cr[6].eq {
	pc = 0x82AC8FC4; continue 'dispatch;
	}
	// 82AC8FC0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC8FC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC8FC8: 4BA41989  bl 0x8250a950
	ctx.lr = 0x82AC8FCC;
	sub_8250A950(ctx, base);
	// 82AC8FCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC8FD0: 48328CC1  bl 0x82df1c90
	ctx.lr = 0x82AC8FD4;
	sub_82DF1C90(ctx, base);
	// 82AC8FD4: 57CB1838  slwi r11, r30, 3
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AC8FD8: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82AC8FDC: 806B0114  lwz r3, 0x114(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(276 as u32) ) } as u64;
	// 82AC8FE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC8FE4: 419A000C  beq cr6, 0x82ac8ff0
	if ctx.cr[6].eq {
	pc = 0x82AC8FF0; continue 'dispatch;
	}
	// 82AC8FE8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC8FEC: 483B8755  bl 0x82e81740
	ctx.lr = 0x82AC8FF0;
	sub_82E81740(ctx, base);
	// 82AC8FF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC8FF4: 48328C9D  bl 0x82df1c90
	ctx.lr = 0x82AC8FF8;
	sub_82DF1C90(ctx, base);
	// 82AC8FF8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC8FFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC9000: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC9004: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC9008: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC900C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC9010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC9010 size=196
    let mut pc: u32 = 0x82AC9010;
    'dispatch: loop {
        match pc {
            0x82AC9010 => {
    //   block [0x82AC9010..0x82AC90D4)
	// 82AC9010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC9014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC9018: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC901C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC9020: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC9024: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC9028: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC902C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AC9030: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC9034: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC9038: 4B7F7901  bl 0x822c0938
	ctx.lr = 0x82AC903C;
	sub_822C0938(ctx, base);
	// 82AC903C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC9040: 41820028  beq 0x82ac9068
	if ctx.cr[0].eq {
	pc = 0x82AC9068; continue 'dispatch;
	}
	// 82AC9044: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC9048: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AC904C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AC9050: 392B9B88  addi r9, r11, -0x6478
	ctx.r[9].s64 = ctx.r[11].s64 + -25720;
	// 82AC9054: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AC9058: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC905C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC9060: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AC9064: 48000008  b 0x82ac906c
	pc = 0x82AC906C; continue 'dispatch;
	// 82AC9068: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC906C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC9070: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC9074: 409A0044  bne cr6, 0x82ac90b8
	if !ctx.cr[6].eq {
	pc = 0x82AC90B8; continue 'dispatch;
	}
	// 82AC9078: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC907C: 419A001C  beq cr6, 0x82ac9098
	if ctx.cr[6].eq {
	pc = 0x82AC9098; continue 'dispatch;
	}
	// 82AC9080: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC9084: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC9088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC908C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC9090: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC9094: 4E800421  bctrl
	ctx.lr = 0x82AC9098;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC9098: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC909C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC90A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC90A4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AC90A8: 816B0390  lwz r11, 0x390(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(912 as u32) ) } as u64;
	// 82AC90AC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AC90B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC90B4: 4B7F6F4D  bl 0x822c0000
	ctx.lr = 0x82AC90B8;
	sub_822C0000(ctx, base);
	// 82AC90B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC90BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC90C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC90C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC90C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC90CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC90D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC90D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC90D8 size=196
    let mut pc: u32 = 0x82AC90D8;
    'dispatch: loop {
        match pc {
            0x82AC90D8 => {
    //   block [0x82AC90D8..0x82AC919C)
	// 82AC90D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC90DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC90E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC90E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC90E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC90EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC90F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC90F4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AC90F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC90FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC9100: 4B7F7839  bl 0x822c0938
	ctx.lr = 0x82AC9104;
	sub_822C0938(ctx, base);
	// 82AC9104: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC9108: 41820028  beq 0x82ac9130
	if ctx.cr[0].eq {
	pc = 0x82AC9130; continue 'dispatch;
	}
	// 82AC910C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC9110: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AC9114: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AC9118: 392B9B9C  addi r9, r11, -0x6464
	ctx.r[9].s64 = ctx.r[11].s64 + -25700;
	// 82AC911C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AC9120: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC9124: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC9128: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AC912C: 48000008  b 0x82ac9134
	pc = 0x82AC9134; continue 'dispatch;
	// 82AC9130: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC9134: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC9138: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC913C: 409A0044  bne cr6, 0x82ac9180
	if !ctx.cr[6].eq {
	pc = 0x82AC9180; continue 'dispatch;
	}
	// 82AC9140: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC9144: 419A001C  beq cr6, 0x82ac9160
	if ctx.cr[6].eq {
	pc = 0x82AC9160; continue 'dispatch;
	}
	// 82AC9148: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC914C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC9150: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC9154: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC9158: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC915C: 4E800421  bctrl
	ctx.lr = 0x82AC9160;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC9160: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC9164: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC9168: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC916C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AC9170: 816B0390  lwz r11, 0x390(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(912 as u32) ) } as u64;
	// 82AC9174: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AC9178: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC917C: 4B7F6E85  bl 0x822c0000
	ctx.lr = 0x82AC9180;
	sub_822C0000(ctx, base);
	// 82AC9180: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC9184: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC9188: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC918C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC9190: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC9194: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC9198: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC91A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC91A0 size=196
    let mut pc: u32 = 0x82AC91A0;
    'dispatch: loop {
        match pc {
            0x82AC91A0 => {
    //   block [0x82AC91A0..0x82AC9264)
	// 82AC91A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC91A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC91A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC91AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC91B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC91B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC91B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC91BC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AC91C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC91C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC91C8: 4B7F7771  bl 0x822c0938
	ctx.lr = 0x82AC91CC;
	sub_822C0938(ctx, base);
	// 82AC91CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC91D0: 41820028  beq 0x82ac91f8
	if ctx.cr[0].eq {
	pc = 0x82AC91F8; continue 'dispatch;
	}
	// 82AC91D4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC91D8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AC91DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AC91E0: 392B9BB0  addi r9, r11, -0x6450
	ctx.r[9].s64 = ctx.r[11].s64 + -25680;
	// 82AC91E4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AC91E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC91EC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC91F0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AC91F4: 48000008  b 0x82ac91fc
	pc = 0x82AC91FC; continue 'dispatch;
	// 82AC91F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC91FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC9200: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC9204: 409A0044  bne cr6, 0x82ac9248
	if !ctx.cr[6].eq {
	pc = 0x82AC9248; continue 'dispatch;
	}
	// 82AC9208: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC920C: 419A001C  beq cr6, 0x82ac9228
	if ctx.cr[6].eq {
	pc = 0x82AC9228; continue 'dispatch;
	}
	// 82AC9210: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC9214: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC9218: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC921C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC9220: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC9224: 4E800421  bctrl
	ctx.lr = 0x82AC9228;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC9228: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC922C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC9230: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC9234: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AC9238: 816B0390  lwz r11, 0x390(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(912 as u32) ) } as u64;
	// 82AC923C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AC9240: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC9244: 4B7F6DBD  bl 0x822c0000
	ctx.lr = 0x82AC9248;
	sub_822C0000(ctx, base);
	// 82AC9248: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC924C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC9250: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC9254: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC9258: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC925C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC9260: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC9268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC9268 size=196
    let mut pc: u32 = 0x82AC9268;
    'dispatch: loop {
        match pc {
            0x82AC9268 => {
    //   block [0x82AC9268..0x82AC932C)
	// 82AC9268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC926C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC9270: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC9274: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC9278: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC927C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC9280: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC9284: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AC9288: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC928C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC9290: 4B7F76A9  bl 0x822c0938
	ctx.lr = 0x82AC9294;
	sub_822C0938(ctx, base);
	// 82AC9294: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC9298: 41820028  beq 0x82ac92c0
	if ctx.cr[0].eq {
	pc = 0x82AC92C0; continue 'dispatch;
	}
	// 82AC929C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC92A0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AC92A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AC92A8: 392B9BC4  addi r9, r11, -0x643c
	ctx.r[9].s64 = ctx.r[11].s64 + -25660;
	// 82AC92AC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AC92B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC92B4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC92B8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AC92BC: 48000008  b 0x82ac92c4
	pc = 0x82AC92C4; continue 'dispatch;
	// 82AC92C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC92C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC92C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC92CC: 409A0044  bne cr6, 0x82ac9310
	if !ctx.cr[6].eq {
	pc = 0x82AC9310; continue 'dispatch;
	}
	// 82AC92D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC92D4: 419A001C  beq cr6, 0x82ac92f0
	if ctx.cr[6].eq {
	pc = 0x82AC92F0; continue 'dispatch;
	}
	// 82AC92D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC92DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC92E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC92E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC92E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC92EC: 4E800421  bctrl
	ctx.lr = 0x82AC92F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC92F0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC92F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC92F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC92FC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AC9300: 816B0390  lwz r11, 0x390(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(912 as u32) ) } as u64;
	// 82AC9304: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AC9308: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC930C: 4B7F6CF5  bl 0x822c0000
	ctx.lr = 0x82AC9310;
	sub_822C0000(ctx, base);
	// 82AC9310: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC9314: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC9318: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC931C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC9320: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC9324: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC9328: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC9330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC9330 size=196
    let mut pc: u32 = 0x82AC9330;
    'dispatch: loop {
        match pc {
            0x82AC9330 => {
    //   block [0x82AC9330..0x82AC93F4)
	// 82AC9330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC9334: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC9338: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC933C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC9340: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC9344: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC9348: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC934C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AC9350: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC9354: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC9358: 4B7F75E1  bl 0x822c0938
	ctx.lr = 0x82AC935C;
	sub_822C0938(ctx, base);
	// 82AC935C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC9360: 41820028  beq 0x82ac9388
	if ctx.cr[0].eq {
	pc = 0x82AC9388; continue 'dispatch;
	}
	// 82AC9364: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC9368: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AC936C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AC9370: 392B9BD8  addi r9, r11, -0x6428
	ctx.r[9].s64 = ctx.r[11].s64 + -25640;
	// 82AC9374: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AC9378: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC937C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC9380: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AC9384: 48000008  b 0x82ac938c
	pc = 0x82AC938C; continue 'dispatch;
	// 82AC9388: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC938C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC9390: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC9394: 409A0044  bne cr6, 0x82ac93d8
	if !ctx.cr[6].eq {
	pc = 0x82AC93D8; continue 'dispatch;
	}
	// 82AC9398: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC939C: 419A001C  beq cr6, 0x82ac93b8
	if ctx.cr[6].eq {
	pc = 0x82AC93B8; continue 'dispatch;
	}
	// 82AC93A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC93A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC93A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC93AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC93B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC93B4: 4E800421  bctrl
	ctx.lr = 0x82AC93B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC93B8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC93BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC93C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC93C4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AC93C8: 816B0390  lwz r11, 0x390(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(912 as u32) ) } as u64;
	// 82AC93CC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AC93D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC93D4: 4B7F6C2D  bl 0x822c0000
	ctx.lr = 0x82AC93D8;
	sub_822C0000(ctx, base);
	// 82AC93D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC93DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC93E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC93E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC93E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC93EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC93F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC93F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC93F8 size=196
    let mut pc: u32 = 0x82AC93F8;
    'dispatch: loop {
        match pc {
            0x82AC93F8 => {
    //   block [0x82AC93F8..0x82AC94BC)
	// 82AC93F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC93FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC9400: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC9404: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC9408: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC940C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC9410: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC9414: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AC9418: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC941C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC9420: 4B7F7519  bl 0x822c0938
	ctx.lr = 0x82AC9424;
	sub_822C0938(ctx, base);
	// 82AC9424: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC9428: 41820028  beq 0x82ac9450
	if ctx.cr[0].eq {
	pc = 0x82AC9450; continue 'dispatch;
	}
	// 82AC942C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC9430: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AC9434: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AC9438: 392B9BEC  addi r9, r11, -0x6414
	ctx.r[9].s64 = ctx.r[11].s64 + -25620;
	// 82AC943C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AC9440: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC9444: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC9448: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AC944C: 48000008  b 0x82ac9454
	pc = 0x82AC9454; continue 'dispatch;
	// 82AC9450: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC9454: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC9458: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC945C: 409A0044  bne cr6, 0x82ac94a0
	if !ctx.cr[6].eq {
	pc = 0x82AC94A0; continue 'dispatch;
	}
	// 82AC9460: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC9464: 419A001C  beq cr6, 0x82ac9480
	if ctx.cr[6].eq {
	pc = 0x82AC9480; continue 'dispatch;
	}
	// 82AC9468: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC946C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC9470: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC9474: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC9478: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC947C: 4E800421  bctrl
	ctx.lr = 0x82AC9480;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC9480: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC9484: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC9488: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC948C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AC9490: 816B0390  lwz r11, 0x390(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(912 as u32) ) } as u64;
	// 82AC9494: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AC9498: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC949C: 4B7F6B65  bl 0x822c0000
	ctx.lr = 0x82AC94A0;
	sub_822C0000(ctx, base);
	// 82AC94A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC94A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC94A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC94AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC94B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC94B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC94B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC94C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC94C0 size=196
    let mut pc: u32 = 0x82AC94C0;
    'dispatch: loop {
        match pc {
            0x82AC94C0 => {
    //   block [0x82AC94C0..0x82AC9584)
	// 82AC94C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC94C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC94C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC94CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC94D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC94D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC94D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC94DC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AC94E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC94E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC94E8: 4B7F7451  bl 0x822c0938
	ctx.lr = 0x82AC94EC;
	sub_822C0938(ctx, base);
	// 82AC94EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC94F0: 41820028  beq 0x82ac9518
	if ctx.cr[0].eq {
	pc = 0x82AC9518; continue 'dispatch;
	}
	// 82AC94F4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC94F8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AC94FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AC9500: 392B9C00  addi r9, r11, -0x6400
	ctx.r[9].s64 = ctx.r[11].s64 + -25600;
	// 82AC9504: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AC9508: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AC950C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AC9510: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AC9514: 48000008  b 0x82ac951c
	pc = 0x82AC951C; continue 'dispatch;
	// 82AC9518: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC951C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC9520: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC9524: 409A0044  bne cr6, 0x82ac9568
	if !ctx.cr[6].eq {
	pc = 0x82AC9568; continue 'dispatch;
	}
	// 82AC9528: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC952C: 419A001C  beq cr6, 0x82ac9548
	if ctx.cr[6].eq {
	pc = 0x82AC9548; continue 'dispatch;
	}
	// 82AC9530: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC9534: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AC9538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC953C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC9540: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AC9544: 4E800421  bctrl
	ctx.lr = 0x82AC9548;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AC9548: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC954C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC9550: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC9554: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AC9558: 816B0390  lwz r11, 0x390(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(912 as u32) ) } as u64;
	// 82AC955C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AC9560: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AC9564: 4B7F6A9D  bl 0x822c0000
	ctx.lr = 0x82AC9568;
	sub_822C0000(ctx, base);
	// 82AC9568: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC956C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC9570: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC9574: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC9578: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC957C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC9580: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC9588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC9588 size=124
    let mut pc: u32 = 0x82AC9588;
    'dispatch: loop {
        match pc {
            0x82AC9588 => {
    //   block [0x82AC9588..0x82AC9604)
	// 82AC9588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC958C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC9590: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC9594: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC9598: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC959C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC95A0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AC95A4: 3D208338  lis r9, -0x7cc8
	ctx.r[9].s64 = -2093481984;
	// 82AC95A8: 390B9C2C  addi r8, r11, -0x63d4
	ctx.r[8].s64 = ctx.r[11].s64 + -25556;
	// 82AC95AC: 394A9C14  addi r10, r10, -0x63ec
	ctx.r[10].s64 = ctx.r[10].s64 + -25580;
	// 82AC95B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC95B4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82AC95B8: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82AC95BC: 9169E65C  stw r11, -0x19a4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-6564 as u32), ctx.r[11].u32 ) };
	// 82AC95C0: 807F0138  lwz r3, 0x138(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82AC95C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC95C8: 419A0008  beq cr6, 0x82ac95d0
	if ctx.cr[6].eq {
	pc = 0x82AC95D0; continue 'dispatch;
	}
	// 82AC95CC: 4B7F72C5  bl 0x822c0890
	ctx.lr = 0x82AC95D0;
	sub_822C0890(ctx, base);
	// 82AC95D0: 387F0114  addi r3, r31, 0x114
	ctx.r[3].s64 = ctx.r[31].s64 + 276;
	// 82AC95D4: 480A9915  bl 0x82b72ee8
	ctx.lr = 0x82AC95D8;
	sub_82B72EE8(ctx, base);
	// 82AC95D8: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82AC95DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC95E0: 419A0008  beq cr6, 0x82ac95e8
	if ctx.cr[6].eq {
	pc = 0x82AC95E8; continue 'dispatch;
	}
	// 82AC95E4: 4B7F72AD  bl 0x822c0890
	ctx.lr = 0x82AC95E8;
	sub_822C0890(ctx, base);
	// 82AC95E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC95EC: 4B885D65  bl 0x8234f350
	ctx.lr = 0x82AC95F0;
	sub_8234F350(ctx, base);
	// 82AC95F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AC95F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC95F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC95FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC9600: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC9608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AC9608 size=8
    let mut pc: u32 = 0x82AC9608;
    'dispatch: loop {
        match pc {
            0x82AC9608 => {
    //   block [0x82AC9608..0x82AC9610)
	// 82AC9608: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82AC960C: 480002B4  b 0x82ac98c0
	sub_82AC98C0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC9610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC9610 size=240
    let mut pc: u32 = 0x82AC9610;
    'dispatch: loop {
        match pc {
            0x82AC9610 => {
    //   block [0x82AC9610..0x82AC9700)
	// 82AC9610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC9614: 486DEB59  bl 0x831a816c
	ctx.lr = 0x82AC9618;
	sub_831A8130(ctx, base);
	// 82AC9618: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC961C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC9620: 4BA49479  bl 0x82512a98
	ctx.lr = 0x82AC9624;
	sub_82512A98(ctx, base);
	// 82AC9624: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82AC9628: 812D0000  lwz r9, 0(r13)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC962C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AC9630: 396B4BC0  addi r11, r11, 0x4bc0
	ctx.r[11].s64 = ctx.r[11].s64 + 19392;
	// 82AC9634: 394A9C70  addi r10, r10, -0x6390
	ctx.r[10].s64 = ctx.r[10].s64 + -25488;
	// 82AC9638: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 82AC963C: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82AC9640: 38C00014  li r6, 0x14
	ctx.r[6].s64 = 20;
	// 82AC9644: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AC9648: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82AC964C: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AC9650: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC9700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC9700 size=168
    let mut pc: u32 = 0x82AC9700;
    'dispatch: loop {
        match pc {
            0x82AC9700 => {
    //   block [0x82AC9700..0x82AC97A8)
	// 82AC9700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC9704: 486DEA69  bl 0x831a816c
	ctx.lr = 0x82AC9708;
	sub_831A8130(ctx, base);
	// 82AC9708: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC970C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC9710: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC9714: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC9718: 4BA45DB1  bl 0x8250f4c8
	ctx.lr = 0x82AC971C;
	sub_8250F4C8(ctx, base);
	// 82AC971C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC9720: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82AC9724: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC9728: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82AC972C: 409A0008  bne cr6, 0x82ac9734
	if !ctx.cr[6].eq {
	pc = 0x82AC9734; continue 'dispatch;
	}
	// 82AC9730: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AC9734: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC9738: 4BA41219  bl 0x8250a950
	ctx.lr = 0x82AC973C;
	sub_8250A950(ctx, base);
	// 82AC973C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC9740: 48328551  bl 0x82df1c90
	ctx.lr = 0x82AC9744;
	sub_82DF1C90(ctx, base);
	// 82AC9744: 3BFF0114  addi r31, r31, 0x114
	ctx.r[31].s64 = ctx.r[31].s64 + 276;
	// 82AC9748: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	// 82AC974C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC9750: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC9754: 419A0038  beq cr6, 0x82ac978c
	if ctx.cr[6].eq {
	pc = 0x82AC978C; continue 'dispatch;
	}
	// 82AC9758: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AC975C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC9760: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82AC9764: 409A0008  bne cr6, 0x82ac976c
	if !ctx.cr[6].eq {
	pc = 0x82AC976C; continue 'dispatch;
	}
	// 82AC9768: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC976C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC9770: 4BD0A291  bl 0x827d3a00
	ctx.lr = 0x82AC9774;
	sub_827D3A00(ctx, base);
	// 82AC9774: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82AC9778: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AC977C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC9780: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82AC9784: 419A0008  beq cr6, 0x82ac978c
	if ctx.cr[6].eq {
	pc = 0x82AC978C; continue 'dispatch;
	}
	// 82AC9788: 4B7F7109  bl 0x822c0890
	ctx.lr = 0x82AC978C;
	sub_822C0890(ctx, base);
	// 82AC978C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AC9790: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82AC9794: 4082FFB8  bne 0x82ac974c
	if !ctx.cr[0].eq {
	pc = 0x82AC974C; continue 'dispatch;
	}
	// 82AC9798: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AC979C: 483284F5  bl 0x82df1c90
	ctx.lr = 0x82AC97A0;
	sub_82DF1C90(ctx, base);
	// 82AC97A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AC97A4: 486DEA18  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC97A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC97A8 size=280
    let mut pc: u32 = 0x82AC97A8;
    'dispatch: loop {
        match pc {
            0x82AC97A8 => {
    //   block [0x82AC97A8..0x82AC98C0)
	// 82AC97A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC97AC: 486DE9C1  bl 0x831a816c
	ctx.lr = 0x82AC97B0;
	sub_831A8130(ctx, base);
	// 82AC97B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC97B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC97B8: 4BA48B79  bl 0x82512330
	ctx.lr = 0x82AC97BC;
	sub_82512330(ctx, base);
	// 82AC97BC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC97C0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AC97C4: 3D208338  lis r9, -0x7cc8
	ctx.r[9].s64 = -2093481984;
	// 82AC97C8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AC97CC: 396B9C2C  addi r11, r11, -0x63d4
	ctx.r[11].s64 = ctx.r[11].s64 + -25556;
	// 82AC97D0: 394A9C14  addi r10, r10, -0x63ec
	ctx.r[10].s64 = ctx.r[10].s64 + -25580;
	// 82AC97D4: 93DF00E4  stw r30, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[30].u32 ) };
	// 82AC97D8: 39296910  addi r9, r9, 0x6910
	ctx.r[9].s64 = ctx.r[9].s64 + 26896;
	// 82AC97DC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC97E0: 39000100  li r8, 0x100
	ctx.r[8].s64 = 256;
	// 82AC97E4: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82AC97E8: 93DF00E8  stw r30, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[30].u32 ) };
	// 82AC97EC: 3BBF00EC  addi r29, r31, 0xec
	ctx.r[29].s64 = ctx.r[31].s64 + 236;
	// 82AC97F0: 93DF00EC  stw r30, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[30].u32 ) };
	// 82AC97F4: 397F0114  addi r11, r31, 0x114
	ctx.r[11].s64 = ctx.r[31].s64 + 276;
	// 82AC97F8: 93DF00F0  stw r30, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[30].u32 ) };
	// 82AC97FC: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 82AC9800: 93DF00F4  stw r30, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[30].u32 ) };
	// 82AC9804: 93DF00F8  stw r30, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[30].u32 ) };
	// 82AC9808: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC98C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC98C0 size=76
    let mut pc: u32 = 0x82AC98C0;
    'dispatch: loop {
        match pc {
            0x82AC98C0 => {
    //   block [0x82AC98C0..0x82AC990C)
	// 82AC98C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC98C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC98C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC98CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC98D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC98D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC98D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AC98DC: 4BFFFCAD  bl 0x82ac9588
	ctx.lr = 0x82AC98E0;
	sub_82AC9588(ctx, base);
	// 82AC98E0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC98E4: 4182000C  beq 0x82ac98f0
	if ctx.cr[0].eq {
	pc = 0x82AC98F0; continue 'dispatch;
	}
	// 82AC98E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC98EC: 48328AED  bl 0x82df23d8
	ctx.lr = 0x82AC98F0;
	sub_82DF23D8(ctx, base);
	// 82AC98F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC98F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC98F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC98FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC9900: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AC9904: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC9908: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC9910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC9910 size=64
    let mut pc: u32 = 0x82AC9910;
    'dispatch: loop {
        match pc {
            0x82AC9910 => {
    //   block [0x82AC9910..0x82AC9950)
	// 82AC9910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC9914: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC9918: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC991C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC9920: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC9924: 4BA48745  bl 0x82512068
	ctx.lr = 0x82AC9928;
	sub_82512068(ctx, base);
	// 82AC9928: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC992C: 4BFFFDD5  bl 0x82ac9700
	ctx.lr = 0x82AC9930;
	sub_82AC9700(ctx, base);
	// 82AC9930: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82AC9934: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AC9938: 916AE65C  stw r11, -0x19a4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-6564 as u32), ctx.r[11].u32 ) };
	// 82AC993C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AC9940: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AC9944: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AC9948: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AC994C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC9950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC9950 size=112
    let mut pc: u32 = 0x82AC9950;
    'dispatch: loop {
        match pc {
            0x82AC9950 => {
    //   block [0x82AC9950..0x82AC99C0)
	// 82AC9950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC9954: 486DE819  bl 0x831a816c
	ctx.lr = 0x82AC9958;
	sub_831A8130(ctx, base);
	// 82AC9958: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC995C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC9960: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC9964: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC9968: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82AC996C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82AC9970: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 82AC9974: 48328A75  bl 0x82df23e8
	ctx.lr = 0x82AC9978;
	sub_82DF23E8(ctx, base);
	// 82AC9978: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC997C: 41820010  beq 0x82ac998c
	if ctx.cr[0].eq {
	pc = 0x82AC998C; continue 'dispatch;
	}
	// 82AC9980: 4BFF2F69  bl 0x82abc8e8
	ctx.lr = 0x82AC9984;
	sub_82ABC8E8(ctx, base);
	// 82AC9984: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC9988: 48000008  b 0x82ac9990
	pc = 0x82AC9990; continue 'dispatch;
	// 82AC998C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC9990: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AC9994: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AC9998: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC999C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC99A0: 4BFFF739  bl 0x82ac90d8
	ctx.lr = 0x82AC99A4;
	sub_82AC90D8(ctx, base);
	// 82AC99A4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC99A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC99AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC99B0: 4B7F6651  bl 0x822c0000
	ctx.lr = 0x82AC99B4;
	sub_822C0000(ctx, base);
	// 82AC99B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC99B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC99BC: 486DE800  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC99C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC99C0 size=124
    let mut pc: u32 = 0x82AC99C0;
    'dispatch: loop {
        match pc {
            0x82AC99C0 => {
    //   block [0x82AC99C0..0x82AC9A3C)
	// 82AC99C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC99C4: 486DE7A9  bl 0x831a816c
	ctx.lr = 0x82AC99C8;
	sub_831A8130(ctx, base);
	// 82AC99C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC99CC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC99D0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC99D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC99D8: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82AC99DC: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82AC99E0: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82AC99E4: 48328A05  bl 0x82df23e8
	ctx.lr = 0x82AC99E8;
	sub_82DF23E8(ctx, base);
	// 82AC99E8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AC99EC: 4182001C  beq 0x82ac9a08
	if ctx.cr[0].eq {
	pc = 0x82AC9A08; continue 'dispatch;
	}
	// 82AC99F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC99F4: 4838FC8D  bl 0x82e59680
	ctx.lr = 0x82AC99F8;
	sub_82E59680(ctx, base);
	// 82AC99F8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC99FC: 396B9B68  addi r11, r11, -0x6498
	ctx.r[11].s64 = ctx.r[11].s64 + -25752;
	// 82AC9A00: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC9A04: 48000008  b 0x82ac9a0c
	pc = 0x82AC9A0C; continue 'dispatch;
	// 82AC9A08: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC9A0C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AC9A10: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AC9A14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC9A18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC9A1C: 4BFFF785  bl 0x82ac91a0
	ctx.lr = 0x82AC9A20;
	sub_82AC91A0(ctx, base);
	// 82AC9A20: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC9A24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC9A28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC9A2C: 4B7F65D5  bl 0x822c0000
	ctx.lr = 0x82AC9A30;
	sub_822C0000(ctx, base);
	// 82AC9A30: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC9A34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC9A38: 486DE784  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC9A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC9A40 size=124
    let mut pc: u32 = 0x82AC9A40;
    'dispatch: loop {
        match pc {
            0x82AC9A40 => {
    //   block [0x82AC9A40..0x82AC9ABC)
	// 82AC9A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC9A44: 486DE729  bl 0x831a816c
	ctx.lr = 0x82AC9A48;
	sub_831A8130(ctx, base);
	// 82AC9A48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC9A4C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC9A50: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC9A54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC9A58: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82AC9A5C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82AC9A60: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82AC9A64: 48328985  bl 0x82df23e8
	ctx.lr = 0x82AC9A68;
	sub_82DF23E8(ctx, base);
	// 82AC9A68: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AC9A6C: 4182001C  beq 0x82ac9a88
	if ctx.cr[0].eq {
	pc = 0x82AC9A88; continue 'dispatch;
	}
	// 82AC9A70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC9A74: 4838FC0D  bl 0x82e59680
	ctx.lr = 0x82AC9A78;
	sub_82E59680(ctx, base);
	// 82AC9A78: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC9A7C: 396B9B70  addi r11, r11, -0x6490
	ctx.r[11].s64 = ctx.r[11].s64 + -25744;
	// 82AC9A80: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC9A84: 48000008  b 0x82ac9a8c
	pc = 0x82AC9A8C; continue 'dispatch;
	// 82AC9A88: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC9A8C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AC9A90: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AC9A94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC9A98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC9A9C: 4BFFF7CD  bl 0x82ac9268
	ctx.lr = 0x82AC9AA0;
	sub_82AC9268(ctx, base);
	// 82AC9AA0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC9AA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC9AA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC9AAC: 4B7F6555  bl 0x822c0000
	ctx.lr = 0x82AC9AB0;
	sub_822C0000(ctx, base);
	// 82AC9AB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC9AB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC9AB8: 486DE704  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC9AC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC9AC0 size=124
    let mut pc: u32 = 0x82AC9AC0;
    'dispatch: loop {
        match pc {
            0x82AC9AC0 => {
    //   block [0x82AC9AC0..0x82AC9B3C)
	// 82AC9AC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC9AC4: 486DE6A9  bl 0x831a816c
	ctx.lr = 0x82AC9AC8;
	sub_831A8130(ctx, base);
	// 82AC9AC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC9ACC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC9AD0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC9AD4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC9AD8: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82AC9ADC: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82AC9AE0: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82AC9AE4: 48328905  bl 0x82df23e8
	ctx.lr = 0x82AC9AE8;
	sub_82DF23E8(ctx, base);
	// 82AC9AE8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AC9AEC: 4182001C  beq 0x82ac9b08
	if ctx.cr[0].eq {
	pc = 0x82AC9B08; continue 'dispatch;
	}
	// 82AC9AF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC9AF4: 4838FB8D  bl 0x82e59680
	ctx.lr = 0x82AC9AF8;
	sub_82E59680(ctx, base);
	// 82AC9AF8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC9AFC: 396B9B78  addi r11, r11, -0x6488
	ctx.r[11].s64 = ctx.r[11].s64 + -25736;
	// 82AC9B00: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC9B04: 48000008  b 0x82ac9b0c
	pc = 0x82AC9B0C; continue 'dispatch;
	// 82AC9B08: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC9B0C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AC9B10: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AC9B14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC9B18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC9B1C: 4BFFF815  bl 0x82ac9330
	ctx.lr = 0x82AC9B20;
	sub_82AC9330(ctx, base);
	// 82AC9B20: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC9B24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC9B28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC9B2C: 4B7F64D5  bl 0x822c0000
	ctx.lr = 0x82AC9B30;
	sub_822C0000(ctx, base);
	// 82AC9B30: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC9B34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC9B38: 486DE684  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC9B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC9B40 size=124
    let mut pc: u32 = 0x82AC9B40;
    'dispatch: loop {
        match pc {
            0x82AC9B40 => {
    //   block [0x82AC9B40..0x82AC9BBC)
	// 82AC9B40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC9B44: 486DE629  bl 0x831a816c
	ctx.lr = 0x82AC9B48;
	sub_831A8130(ctx, base);
	// 82AC9B48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC9B4C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC9B50: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC9B54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC9B58: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82AC9B5C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82AC9B60: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82AC9B64: 48328885  bl 0x82df23e8
	ctx.lr = 0x82AC9B68;
	sub_82DF23E8(ctx, base);
	// 82AC9B68: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AC9B6C: 4182001C  beq 0x82ac9b88
	if ctx.cr[0].eq {
	pc = 0x82AC9B88; continue 'dispatch;
	}
	// 82AC9B70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC9B74: 4838FB0D  bl 0x82e59680
	ctx.lr = 0x82AC9B78;
	sub_82E59680(ctx, base);
	// 82AC9B78: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC9B7C: 396B9B80  addi r11, r11, -0x6480
	ctx.r[11].s64 = ctx.r[11].s64 + -25728;
	// 82AC9B80: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AC9B84: 48000008  b 0x82ac9b8c
	pc = 0x82AC9B8C; continue 'dispatch;
	// 82AC9B88: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC9B8C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AC9B90: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AC9B94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC9B98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC9B9C: 4BFFF85D  bl 0x82ac93f8
	ctx.lr = 0x82AC9BA0;
	sub_82AC93F8(ctx, base);
	// 82AC9BA0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC9BA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC9BA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC9BAC: 4B7F6455  bl 0x822c0000
	ctx.lr = 0x82AC9BB0;
	sub_822C0000(ctx, base);
	// 82AC9BB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC9BB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC9BB8: 486DE604  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC9BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC9BC0 size=120
    let mut pc: u32 = 0x82AC9BC0;
    'dispatch: loop {
        match pc {
            0x82AC9BC0 => {
    //   block [0x82AC9BC0..0x82AC9C38)
	// 82AC9BC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC9BC4: 486DE5A9  bl 0x831a816c
	ctx.lr = 0x82AC9BC8;
	sub_831A8130(ctx, base);
	// 82AC9BC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC9BCC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AC9BD0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC9BD4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AC9BD8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC9BDC: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82AC9BE0: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82AC9BE4: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 82AC9BE8: 48328801  bl 0x82df23e8
	ctx.lr = 0x82AC9BEC;
	sub_82DF23E8(ctx, base);
	// 82AC9BEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC9BF0: 41820014  beq 0x82ac9c04
	if ctx.cr[0].eq {
	pc = 0x82AC9C04; continue 'dispatch;
	}
	// 82AC9BF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC9BF8: 48092171  bl 0x82b5bd68
	ctx.lr = 0x82AC9BFC;
	sub_82B5BD68(ctx, base);
	// 82AC9BFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC9C00: 48000008  b 0x82ac9c08
	pc = 0x82AC9C08; continue 'dispatch;
	// 82AC9C04: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC9C08: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AC9C0C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AC9C10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC9C14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC9C18: 4BFFF8A9  bl 0x82ac94c0
	ctx.lr = 0x82AC9C1C;
	sub_82AC94C0(ctx, base);
	// 82AC9C1C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC9C20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC9C24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC9C28: 4B7F63D9  bl 0x822c0000
	ctx.lr = 0x82AC9C2C;
	sub_822C0000(ctx, base);
	// 82AC9C2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC9C30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC9C34: 486DE588  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC9C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC9C38 size=112
    let mut pc: u32 = 0x82AC9C38;
    'dispatch: loop {
        match pc {
            0x82AC9C38 => {
    //   block [0x82AC9C38..0x82AC9CA8)
	// 82AC9C38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC9C3C: 486DE531  bl 0x831a816c
	ctx.lr = 0x82AC9C40;
	sub_831A8130(ctx, base);
	// 82AC9C40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC9C44: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC9C48: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC9C4C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AC9C50: 388B9C80  addi r4, r11, -0x6380
	ctx.r[4].s64 = ctx.r[11].s64 + -25472;
	// 82AC9C54: 38A0004E  li r5, 0x4e
	ctx.r[5].s64 = 78;
	// 82AC9C58: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 82AC9C5C: 4832878D  bl 0x82df23e8
	ctx.lr = 0x82AC9C60;
	sub_82DF23E8(ctx, base);
	// 82AC9C60: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC9C64: 41820010  beq 0x82ac9c74
	if ctx.cr[0].eq {
	pc = 0x82AC9C74; continue 'dispatch;
	}
	// 82AC9C68: 4BFFFB41  bl 0x82ac97a8
	ctx.lr = 0x82AC9C6C;
	sub_82AC97A8(ctx, base);
	// 82AC9C6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC9C70: 48000008  b 0x82ac9c78
	pc = 0x82AC9C78; continue 'dispatch;
	// 82AC9C74: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AC9C78: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AC9C7C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AC9C80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC9C84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC9C88: 4BFFF389  bl 0x82ac9010
	ctx.lr = 0x82AC9C8C;
	sub_82AC9010(ctx, base);
	// 82AC9C8C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AC9C90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC9C94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC9C98: 4B7F6369  bl 0x822c0000
	ctx.lr = 0x82AC9C9C;
	sub_822C0000(ctx, base);
	// 82AC9C9C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC9CA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AC9CA4: 486DE518  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC9CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AC9CA8 size=216
    let mut pc: u32 = 0x82AC9CA8;
    'dispatch: loop {
        match pc {
            0x82AC9CA8 => {
    //   block [0x82AC9CA8..0x82AC9D80)
	// 82AC9CA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC9CAC: 486DE4BD  bl 0x831a8168
	ctx.lr = 0x82AC9CB0;
	sub_831A8130(ctx, base);
	// 82AC9CB0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC9CB4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AC9CB8: 4BFE6D11  bl 0x82ab09c8
	ctx.lr = 0x82AC9CBC;
	sub_82AB09C8(ctx, base);
	// 82AC9CBC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AC9CC0: 4082000C  bne 0x82ac9ccc
	if !ctx.cr[0].eq {
	pc = 0x82AC9CCC; continue 'dispatch;
	}
	// 82AC9CC4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC9CC8: 480000B0  b 0x82ac9d78
	pc = 0x82AC9D78; continue 'dispatch;
	// 82AC9CCC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AC9CD0: 4BFB1DE9  bl 0x82a7bab8
	ctx.lr = 0x82AC9CD4;
	sub_82A7BAB8(ctx, base);
	// 82AC9CD4: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AC9CD8: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AC9CDC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC9CE0: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82AC9CE4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82AC9CE8: 419A0024  beq cr6, 0x82ac9d0c
	if ctx.cr[6].eq {
	pc = 0x82AC9D0C; continue 'dispatch;
	}
	// 82AC9CEC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82AC9CF0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AC9CF4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC9CF8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AC9CFC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AC9D00: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AC9D04: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AC9D08: 4082FFE8  bne 0x82ac9cf0
	if !ctx.cr[0].eq {
	pc = 0x82AC9CF0; continue 'dispatch;
	}
	// 82AC9D0C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC9D10: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82AC9D14: 388B9C80  addi r4, r11, -0x6380
	ctx.r[4].s64 = ctx.r[11].s64 + -25472;
	// 82AC9D18: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82AC9D1C: 38A00099  li r5, 0x99
	ctx.r[5].s64 = 153;
	// 82AC9D20: 387D0028  addi r3, r29, 0x28
	ctx.r[3].s64 = ctx.r[29].s64 + 40;
	// 82AC9D24: 4838D2C5  bl 0x82e56fe8
	ctx.lr = 0x82AC9D28;
	sub_82E56FE8(ctx, base);
	// 82AC9D28: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AC9D2C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AC9D30: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 82AC9D34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AC9D38: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82AC9D3C: 557EDFFE  rlwinm r30, r11, 0x1b, 0x1f, 0x1f
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82AC9D40: 419A0008  beq cr6, 0x82ac9d48
	if ctx.cr[6].eq {
	pc = 0x82AC9D48; continue 'dispatch;
	}
	// 82AC9D44: 4B7F6B4D  bl 0x822c0890
	ctx.lr = 0x82AC9D48;
	sub_822C0890(ctx, base);
	// 82AC9D48: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC9D4C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AC9D50: 41820014  beq 0x82ac9d64
	if ctx.cr[0].eq {
	pc = 0x82AC9D64; continue 'dispatch;
	}
	// 82AC9D54: 419AFF70  beq cr6, 0x82ac9cc4
	if ctx.cr[6].eq {
	pc = 0x82AC9CC4; continue 'dispatch;
	}
	// 82AC9D58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC9D5C: 4B7F6B35  bl 0x822c0890
	ctx.lr = 0x82AC9D60;
	sub_822C0890(ctx, base);
	// 82AC9D60: 4BFFFF64  b 0x82ac9cc4
	pc = 0x82AC9CC4; continue 'dispatch;
	// 82AC9D64: 8BDC0018  lbz r30, 0x18(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AC9D68: 419A000C  beq cr6, 0x82ac9d74
	if ctx.cr[6].eq {
	pc = 0x82AC9D74; continue 'dispatch;
	}
	// 82AC9D6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC9D70: 4B7F6B21  bl 0x822c0890
	ctx.lr = 0x82AC9D74;
	sub_822C0890(ctx, base);
	// 82AC9D74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AC9D78: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AC9D7C: 486DE43C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC9D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC9D80 size=424
    let mut pc: u32 = 0x82AC9D80;
    'dispatch: loop {
        match pc {
            0x82AC9D80 => {
    //   block [0x82AC9D80..0x82AC9F28)
	// 82AC9D80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC9D84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AC9D88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AC9D8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AC9D90: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC9D94: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AC9D98: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82AC9D9C: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82AC9DA0: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 82AC9DA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC9DA8: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 82AC9DAC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AC9DB0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AC9DB4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AC9F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AC9F28 size=532
    let mut pc: u32 = 0x82AC9F28;
    'dispatch: loop {
        match pc {
            0x82AC9F28 => {
    //   block [0x82AC9F28..0x82ACA13C)
	// 82AC9F28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AC9F2C: 486DE23D  bl 0x831a8168
	ctx.lr = 0x82AC9F30;
	sub_831A8130(ctx, base);
	// 82AC9F30: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82AC9F34: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AC9F38: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AC9F3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AC9F40: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82AC9F44: 816BE968  lwz r11, -0x1698(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5784 as u32) ) } as u64;
	// 82AC9F48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC9F4C: 419A01E4  beq cr6, 0x82aca130
	if ctx.cr[6].eq {
	pc = 0x82ACA130; continue 'dispatch;
	}
	// 82AC9F50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AC9F54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC9F58: 4BA45571  bl 0x8250f4c8
	ctx.lr = 0x82AC9F5C;
	sub_8250F4C8(ctx, base);
	// 82AC9F5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AC9F60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AC9F64: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82AC9F68: 409A0008  bne cr6, 0x82ac9f70
	if !ctx.cr[6].eq {
	pc = 0x82AC9F70; continue 'dispatch;
	}
	// 82AC9F6C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AC9F70: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AC9F74: 4BA3EAA5  bl 0x82508a18
	ctx.lr = 0x82AC9F78;
	sub_82508A18(ctx, base);
	// 82AC9F78: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AC9F7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AC9F80: 4853E1A9  bl 0x83008128
	ctx.lr = 0x82AC9F84;
	sub_83008128(ctx, base);
	// 82AC9F84: 7D63F050  subf r11, r3, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[3].s64;
	// 82AC9F88: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AC9F8C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82AC9F90: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82AC9F94: 697E0001  xori r30, r11, 1
	ctx.r[30].u64 = ctx.r[11].u64 ^ 1;
	// 82AC9F98: 48327CF9  bl 0x82df1c90
	ctx.lr = 0x82AC9F9C;
	sub_82DF1C90(ctx, base);
	// 82AC9F9C: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AC9FA0: 40820190  bne 0x82aca130
	if !ctx.cr[0].eq {
	pc = 0x82ACA130; continue 'dispatch;
	}
	// 82AC9FA4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AC9FA8: 815D0018  lwz r10, 0x18(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82AC9FAC: 816BE660  lwz r11, -0x19a0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6560 as u32) ) } as u64;
	// 82AC9FB0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82AC9FB4: 409A017C  bne cr6, 0x82aca130
	if !ctx.cr[6].eq {
	pc = 0x82ACA130; continue 'dispatch;
	}
	// 82AC9FB8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AC9FBC: 893F0110  lbz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82AC9FC0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AC9FC4: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AC9FC8: 3BCB9C80  addi r30, r11, -0x6380
	ctx.r[30].s64 = ctx.r[11].s64 + -25472;
	// 82AC9FCC: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AC9FD0: 408200CC  bne 0x82aca09c
	if !ctx.cr[0].eq {
	pc = 0x82ACA09C; continue 'dispatch;
	}
	// 82AC9FD4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AC9FD8: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82AC9FDC: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82AC9FE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AC9FE4: 3B810080  addi r28, r1, 0x80
	ctx.r[28].s64 = ctx.r[1].s64 + 128;
	// 82AC9FE8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACA140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACA140 size=276
    let mut pc: u32 = 0x82ACA140;
    'dispatch: loop {
        match pc {
            0x82ACA140 => {
    //   block [0x82ACA140..0x82ACA254)
	// 82ACA140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACA144: 486DE029  bl 0x831a816c
	ctx.lr = 0x82ACA148;
	sub_831A8130(ctx, base);
	// 82ACA148: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACA14C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ACA150: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82ACA154: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACA158: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ACA15C: 816BE660  lwz r11, -0x19a0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6560 as u32) ) } as u64;
	// 82ACA160: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ACA164: 409A00E8  bne cr6, 0x82aca24c
	if !ctx.cr[6].eq {
	pc = 0x82ACA24C; continue 'dispatch;
	}
	// 82ACA168: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ACA16C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACA170: 4BA45359  bl 0x8250f4c8
	ctx.lr = 0x82ACA174;
	sub_8250F4C8(ctx, base);
	// 82ACA174: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACA178: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACA17C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82ACA180: 409A0008  bne cr6, 0x82aca188
	if !ctx.cr[6].eq {
	pc = 0x82ACA188; continue 'dispatch;
	}
	// 82ACA184: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ACA188: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACA18C: 4BA3E88D  bl 0x82508a18
	ctx.lr = 0x82ACA190;
	sub_82508A18(ctx, base);
	// 82ACA190: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ACA194: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACA198: 4853DF91  bl 0x83008128
	ctx.lr = 0x82ACA19C;
	sub_83008128(ctx, base);
	// 82ACA19C: 7D63E850  subf r11, r3, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[3].s64;
	// 82ACA1A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACA1A4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82ACA1A8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82ACA1AC: 697D0001  xori r29, r11, 1
	ctx.r[29].u64 = ctx.r[11].u64 ^ 1;
	// 82ACA1B0: 48327AE1  bl 0x82df1c90
	ctx.lr = 0x82ACA1B4;
	sub_82DF1C90(ctx, base);
	// 82ACA1B4: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACA1B8: 40820094  bne 0x82aca24c
	if !ctx.cr[0].eq {
	pc = 0x82ACA24C; continue 'dispatch;
	}
	// 82ACA1BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACA1C0: 4BFFF981  bl 0x82ac9b40
	ctx.lr = 0x82ACA1C4;
	sub_82AC9B40(ctx, base);
	// 82ACA1C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACA1C8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82ACA1CC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ACA1D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACA1D4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ACA1D8: 419A0024  beq cr6, 0x82aca1fc
	if ctx.cr[6].eq {
	pc = 0x82ACA1FC; continue 'dispatch;
	}
	// 82ACA1DC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ACA1E0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ACA1E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACA1E8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ACA1EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ACA1F0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ACA1F4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACA1F8: 4082FFE8  bne 0x82aca1e0
	if !ctx.cr[0].eq {
	pc = 0x82ACA1E0; continue 'dispatch;
	}
	// 82ACA1FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACA200: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 82ACA204: 4853DF25  bl 0x83008128
	ctx.lr = 0x82ACA208;
	sub_83008128(ctx, base);
	// 82ACA208: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ACA20C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ACA210: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82ACA214: 388A9C80  addi r4, r10, -0x6380
	ctx.r[4].s64 = ctx.r[10].s64 + -25472;
	// 82ACA218: 38A0017C  li r5, 0x17c
	ctx.r[5].s64 = 380;
	// 82ACA21C: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82ACA220: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACA224: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82ACA228: 4838E819  bl 0x82e58a40
	ctx.lr = 0x82ACA22C;
	sub_82E58A40(ctx, base);
	// 82ACA22C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82ACA230: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACA234: 419A0008  beq cr6, 0x82aca23c
	if ctx.cr[6].eq {
	pc = 0x82ACA23C; continue 'dispatch;
	}
	// 82ACA238: 4B7F6659  bl 0x822c0890
	ctx.lr = 0x82ACA23C;
	sub_822C0890(ctx, base);
	// 82ACA23C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ACA240: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACA244: 419A0008  beq cr6, 0x82aca24c
	if ctx.cr[6].eq {
	pc = 0x82ACA24C; continue 'dispatch;
	}
	// 82ACA248: 4B7F6649  bl 0x822c0890
	ctx.lr = 0x82ACA24C;
	sub_822C0890(ctx, base);
	// 82ACA24C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82ACA250: 486DDF6C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACA258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACA258 size=516
    let mut pc: u32 = 0x82ACA258;
    'dispatch: loop {
        match pc {
            0x82ACA258 => {
    //   block [0x82ACA258..0x82ACA45C)
	// 82ACA258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACA25C: 486DDF11  bl 0x831a816c
	ctx.lr = 0x82ACA260;
	sub_831A8130(ctx, base);
	// 82ACA260: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACA264: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ACA268: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACA26C: 57CB1838  slwi r11, r30, 3
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ACA270: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82ACA274: 3BAB0114  addi r29, r11, 0x114
	ctx.r[29].s64 = ctx.r[11].s64 + 276;
	// 82ACA278: 806B0114  lwz r3, 0x114(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(276 as u32) ) } as u64;
	// 82ACA27C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACA280: 419A0018  beq cr6, 0x82aca298
	if ctx.cr[6].eq {
	pc = 0x82ACA298; continue 'dispatch;
	}
	// 82ACA284: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACA288: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ACA28C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ACA290: 4E800421  bctrl
	ctx.lr = 0x82ACA294;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ACA294: 480001C0  b 0x82aca454
	pc = 0x82ACA454; continue 'dispatch;
	// 82ACA298: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACA29C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACA2A0: 4BA45229  bl 0x8250f4c8
	ctx.lr = 0x82ACA2A4;
	sub_8250F4C8(ctx, base);
	// 82ACA2A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACA2A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACA2AC: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82ACA2B0: 409A0008  bne cr6, 0x82aca2b8
	if !ctx.cr[6].eq {
	pc = 0x82ACA2B8; continue 'dispatch;
	}
	// 82ACA2B4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACA2B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACA2BC: 4BA40695  bl 0x8250a950
	ctx.lr = 0x82ACA2C0;
	sub_8250A950(ctx, base);
	// 82ACA2C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACA2C4: 483279CD  bl 0x82df1c90
	ctx.lr = 0x82ACA2C8;
	sub_82DF1C90(ctx, base);
	// 82ACA2C8: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82ACA2CC: 419A0098  beq cr6, 0x82aca364
	if ctx.cr[6].eq {
	pc = 0x82ACA364; continue 'dispatch;
	}
	// 82ACA2D0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACA2D4: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ACA2D8: 396B9B54  addi r11, r11, -0x64ac
	ctx.r[11].s64 = ctx.r[11].s64 + -25772;
	// 82ACA2DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACA2E0: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ACA2E4: 48329725  bl 0x82df3a08
	ctx.lr = 0x82ACA2E8;
	sub_82DF3A08(ctx, base);
	// 82ACA2E8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ACA2EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACA2F0: 3BCBFF40  addi r30, r11, -0xc0
	ctx.r[30].s64 = ctx.r[11].s64 + -192;
	// 82ACA2F4: 409A0008  bne cr6, 0x82aca2fc
	if !ctx.cr[6].eq {
	pc = 0x82ACA2FC; continue 'dispatch;
	}
	// 82ACA2F8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ACA2FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACA300: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82ACA304: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 82ACA308: 4BA47E11  bl 0x82512118
	ctx.lr = 0x82ACA30C;
	sub_82512118(ctx, base);
	// 82ACA30C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82ACA310: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ACA314: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82ACA318: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82ACA31C: 38E0000B  li r7, 0xb
	ctx.r[7].s64 = 11;
	// 82ACA320: 4BD0A991  bl 0x827d4cb0
	ctx.lr = 0x82ACA324;
	sub_827D4CB0(ctx, base);
	// 82ACA324: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ACA328: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 82ACA32C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82ACA330: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACA334: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACA338: 4B7FA129  bl 0x822c4460
	ctx.lr = 0x82ACA33C;
	sub_822C4460(ctx, base);
	// 82ACA33C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ACA340: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACA344: 419A0008  beq cr6, 0x82aca34c
	if ctx.cr[6].eq {
	pc = 0x82ACA34C; continue 'dispatch;
	}
	// 82ACA348: 4B7F6549  bl 0x822c0890
	ctx.lr = 0x82ACA34C;
	sub_822C0890(ctx, base);
	// 82ACA34C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82ACA350: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACA354: 419A0008  beq cr6, 0x82aca35c
	if ctx.cr[6].eq {
	pc = 0x82ACA35C; continue 'dispatch;
	}
	// 82ACA358: 4B7F6539  bl 0x822c0890
	ctx.lr = 0x82ACA35C;
	sub_822C0890(ctx, base);
	// 82ACA35C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACA360: 480000E8  b 0x82aca448
	pc = 0x82ACA448; continue 'dispatch;
	// 82ACA364: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACA368: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ACA36C: 388B9C80  addi r4, r11, -0x6380
	ctx.r[4].s64 = ctx.r[11].s64 + -25472;
	// 82ACA370: 38A00193  li r5, 0x193
	ctx.r[5].s64 = 403;
	// 82ACA374: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82ACA378: 48328071  bl 0x82df23e8
	ctx.lr = 0x82ACA37C;
	sub_82DF23E8(ctx, base);
	// 82ACA37C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82ACA380: 41820028  beq 0x82aca3a8
	if ctx.cr[0].eq {
	pc = 0x82ACA3A8; continue 'dispatch;
	}
	// 82ACA384: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ACA388: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82ACA38C: 388B03A0  addi r4, r11, 0x3a0
	ctx.r[4].s64 = ctx.r[11].s64 + 928;
	// 82ACA390: 483B1C49  bl 0x82e7bfd8
	ctx.lr = 0x82ACA394;
	sub_82E7BFD8(ctx, base);
	// 82ACA394: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ACA398: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACA39C: 48348D55  bl 0x82e130f0
	ctx.lr = 0x82ACA3A0;
	sub_82E130F0(ctx, base);
	// 82ACA3A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ACA3A4: 48000008  b 0x82aca3ac
	pc = 0x82ACA3AC; continue 'dispatch;
	// 82ACA3A8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACA3AC: 3BDF0134  addi r30, r31, 0x134
	ctx.r[30].s64 = ctx.r[31].s64 + 308;
	// 82ACA3B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACA3B4: 4B81799D  bl 0x822e1d50
	ctx.lr = 0x82ACA3B8;
	sub_822E1D50(ctx, base);
	// 82ACA3B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACA3BC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82ACA3C0: 83FF0134  lwz r31, 0x134(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82ACA3C4: 4BA47D55  bl 0x82512118
	ctx.lr = 0x82ACA3C8;
	sub_82512118(ctx, base);
	// 82ACA3C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACA3CC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACA3D0: 48348A61  bl 0x82e12e30
	ctx.lr = 0x82ACA3D4;
	sub_82E12E30(ctx, base);
	// 82ACA3D4: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ACA3D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACA3DC: 419A0008  beq cr6, 0x82aca3e4
	if ctx.cr[6].eq {
	pc = 0x82ACA3E4; continue 'dispatch;
	}
	// 82ACA3E0: 4B7F64B1  bl 0x822c0890
	ctx.lr = 0x82ACA3E4;
	sub_822C0890(ctx, base);
	// 82ACA3E4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACA3E8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82ACA3EC: 808B9B54  lwz r4, -0x64ac(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25772 as u32) ) } as u64;
	// 82ACA3F0: 48329619  bl 0x82df3a08
	ctx.lr = 0x82ACA3F4;
	sub_82DF3A08(ctx, base);
	// 82ACA3F4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ACA3F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACA3FC: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 82ACA400: 409A0008  bne cr6, 0x82aca408
	if !ctx.cr[6].eq {
	pc = 0x82ACA408; continue 'dispatch;
	}
	// 82ACA404: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACA408: 38E0000B  li r7, 0xb
	ctx.r[7].s64 = 11;
	// 82ACA40C: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82ACA410: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ACA414: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82ACA418: 4BD0A899  bl 0x827d4cb0
	ctx.lr = 0x82ACA41C;
	sub_827D4CB0(ctx, base);
	// 82ACA41C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ACA420: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 82ACA424: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82ACA428: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACA42C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACA430: 4B7FA031  bl 0x822c4460
	ctx.lr = 0x82ACA434;
	sub_822C4460(ctx, base);
	// 82ACA434: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82ACA438: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACA43C: 419A0008  beq cr6, 0x82aca444
	if ctx.cr[6].eq {
	pc = 0x82ACA444; continue 'dispatch;
	}
	// 82ACA440: 4B7F6451  bl 0x822c0890
	ctx.lr = 0x82ACA444;
	sub_822C0890(ctx, base);
	// 82ACA444: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82ACA448: 48328FE1  bl 0x82df3428
	ctx.lr = 0x82ACA44C;
	sub_82DF3428(ctx, base);
	// 82ACA44C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACA450: 48327841  bl 0x82df1c90
	ctx.lr = 0x82ACA454;
	sub_82DF1C90(ctx, base);
	// 82ACA454: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82ACA458: 486DDD64  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACA460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACA460 size=220
    let mut pc: u32 = 0x82ACA460;
    'dispatch: loop {
        match pc {
            0x82ACA460 => {
    //   block [0x82ACA460..0x82ACA53C)
	// 82ACA460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACA464: 486DDD05  bl 0x831a8168
	ctx.lr = 0x82ACA468;
	sub_831A8130(ctx, base);
	// 82ACA468: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACA46C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82ACA470: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACA474: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ACA478: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82ACA47C: 41820038  beq 0x82aca4b4
	if ctx.cr[0].eq {
	pc = 0x82ACA4B4; continue 'dispatch;
	}
	// 82ACA480: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACA484: 486DF505  bl 0x831a9988
	ctx.lr = 0x82ACA488;
	sub_831A9988(ctx, base);
	// 82ACA488: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82ACA48C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ACA490: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 82ACA494: 486DDC65  bl 0x831a80f8
	ctx.lr = 0x82ACA498;
	sub_831A80F8(ctx, base);
	// 82ACA498: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACA49C: 41820018  beq 0x82aca4b4
	if ctx.cr[0].eq {
	pc = 0x82ACA4B4; continue 'dispatch;
	}
	// 82ACA4A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACA4A4: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82ACA4A8: 4BB97241  bl 0x826616e8
	ctx.lr = 0x82ACA4AC;
	sub_826616E8(ctx, base);
	// 82ACA4AC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ACA4B0: 48000084  b 0x82aca534
	pc = 0x82ACA534; continue 'dispatch;
	// 82ACA4B4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82ACA4B8: 419A006C  beq cr6, 0x82aca524
	if ctx.cr[6].eq {
	pc = 0x82ACA524; continue 'dispatch;
	}
	// 82ACA4BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACA4C0: 486DF4C9  bl 0x831a9988
	ctx.lr = 0x82ACA4C4;
	sub_831A9988(ctx, base);
	// 82ACA4C4: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82ACA4C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ACA4CC: 386B0B88  addi r3, r11, 0xb88
	ctx.r[3].s64 = ctx.r[11].s64 + 2952;
	// 82ACA4D0: 486DDC29  bl 0x831a80f8
	ctx.lr = 0x82ACA4D4;
	sub_831A80F8(ctx, base);
	// 82ACA4D4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACA4D8: 41820014  beq 0x82aca4ec
	if ctx.cr[0].eq {
	pc = 0x82ACA4EC; continue 'dispatch;
	}
	// 82ACA4DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACA4E0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82ACA4E4: 4BFFFC5D  bl 0x82aca140
	ctx.lr = 0x82ACA4E8;
	sub_82ACA140(ctx, base);
	// 82ACA4E8: 4BFFFFC4  b 0x82aca4ac
	pc = 0x82ACA4AC; continue 'dispatch;
	// 82ACA4EC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82ACA4F0: 419A0034  beq cr6, 0x82aca524
	if ctx.cr[6].eq {
	pc = 0x82ACA524; continue 'dispatch;
	}
	// 82ACA4F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACA4F8: 486DF491  bl 0x831a9988
	ctx.lr = 0x82ACA4FC;
	sub_831A9988(ctx, base);
	// 82ACA4FC: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ACA500: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ACA504: 386B8CB4  addi r3, r11, -0x734c
	ctx.r[3].s64 = ctx.r[11].s64 + -29516;
	// 82ACA508: 486DDBF1  bl 0x831a80f8
	ctx.lr = 0x82ACA50C;
	sub_831A80F8(ctx, base);
	// 82ACA50C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACA510: 41820014  beq 0x82aca524
	if ctx.cr[0].eq {
	pc = 0x82ACA524; continue 'dispatch;
	}
	// 82ACA514: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACA518: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82ACA51C: 4BFB0AE5  bl 0x82a7b000
	ctx.lr = 0x82ACA520;
	sub_82A7B000(ctx, base);
	// 82ACA520: 4BFFFF8C  b 0x82aca4ac
	pc = 0x82ACA4AC; continue 'dispatch;
	// 82ACA524: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82ACA528: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACA52C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACA530: 4BA480E9  bl 0x82512618
	ctx.lr = 0x82ACA534;
	sub_82512618(ctx, base);
	// 82ACA534: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ACA538: 486DDC80  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACA540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACA540 size=1196
    let mut pc: u32 = 0x82ACA540;
    'dispatch: loop {
        match pc {
            0x82ACA540 => {
    //   block [0x82ACA540..0x82ACA9EC)
	// 82ACA540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACA544: 486DDC11  bl 0x831a8154
	ctx.lr = 0x82ACA548;
	sub_831A8130(ctx, base);
	// 82ACA548: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82ACA54C: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACA550: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACA554: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 82ACA558: 4BA461B1  bl 0x82510708
	ctx.lr = 0x82ACA55C;
	sub_82510708(ctx, base);
	// 82ACA55C: 4BFE646D  bl 0x82ab09c8
	ctx.lr = 0x82ACA560;
	sub_82AB09C8(ctx, base);
	// 82ACA560: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82ACA564: 4182047C  beq 0x82aca9e0
	if ctx.cr[0].eq {
	pc = 0x82ACA9E0; continue 'dispatch;
	}
	// 82ACA568: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82ACA56C: 4BFFF3E5  bl 0x82ac9950
	ctx.lr = 0x82ACA570;
	sub_82AC9950(ctx, base);
	// 82ACA570: 8301007C  lwz r24, 0x7c(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ACA574: 83410078  lwz r26, 0x78(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82ACA578: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82ACA57C: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 82ACA580: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82ACA584: 419A0024  beq cr6, 0x82aca5a8
	if ctx.cr[6].eq {
	pc = 0x82ACA5A8; continue 'dispatch;
	}
	// 82ACA588: 39780004  addi r11, r24, 4
	ctx.r[11].s64 = ctx.r[24].s64 + 4;
	// 82ACA58C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ACA590: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACA594: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ACA598: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ACA59C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ACA5A0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACA5A4: 4082FFE8  bne 0x82aca58c
	if !ctx.cr[0].eq {
	pc = 0x82ACA58C; continue 'dispatch;
	}
	// 82ACA5A8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACA5AC: 3B9F0028  addi r28, r31, 0x28
	ctx.r[28].s64 = ctx.r[31].s64 + 40;
	// 82ACA5B0: 3B6B9C80  addi r27, r11, -0x6380
	ctx.r[27].s64 = ctx.r[11].s64 + -25472;
	// 82ACA5B4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82ACA5B8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82ACA5BC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82ACA5C0: 38A000C4  li r5, 0xc4
	ctx.r[5].s64 = 196;
	// 82ACA5C4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ACA5C8: 4838CA21  bl 0x82e56fe8
	ctx.lr = 0x82ACA5CC;
	sub_82E56FE8(ctx, base);
	// 82ACA5CC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82ACA5D0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82ACA5D4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82ACA5D8: 7D795850  subf r11, r25, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[25].s64;
	// 82ACA5DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACA5E0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82ACA5E4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82ACA5E8: 697E0001  xori r30, r11, 1
	ctx.r[30].u64 = ctx.r[11].u64 ^ 1;
	// 82ACA5EC: 419A0008  beq cr6, 0x82aca5f4
	if ctx.cr[6].eq {
	pc = 0x82ACA5F4; continue 'dispatch;
	}
	// 82ACA5F0: 4B7F62A1  bl 0x822c0890
	ctx.lr = 0x82ACA5F4;
	sub_822C0890(ctx, base);
	// 82ACA5F4: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACA5F8: 4182001C  beq 0x82aca614
	if ctx.cr[0].eq {
	pc = 0x82ACA614; continue 'dispatch;
	}
	// 82ACA5FC: 389A0020  addi r4, r26, 0x20
	ctx.r[4].s64 = ctx.r[26].s64 + 32;
	// 82ACA600: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACA604: 4BA4747D  bl 0x82511a80
	ctx.lr = 0x82ACA608;
	sub_82511A80(ctx, base);
	// 82ACA608: 389A0030  addi r4, r26, 0x30
	ctx.r[4].s64 = ctx.r[26].s64 + 48;
	// 82ACA60C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACA610: 4BA474E1  bl 0x82511af0
	ctx.lr = 0x82ACA614;
	sub_82511AF0(ctx, base);
	// 82ACA614: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACA618: 4BFFF691  bl 0x82ac9ca8
	ctx.lr = 0x82ACA61C;
	sub_82AC9CA8(ctx, base);
	// 82ACA61C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACA620: 3BC00007  li r30, 7
	ctx.r[30].s64 = 7;
	// 82ACA624: 41820010  beq 0x82aca634
	if ctx.cr[0].eq {
	pc = 0x82ACA634; continue 'dispatch;
	}
	// 82ACA628: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACA62C: 4BA45FA5  bl 0x825105d0
	ctx.lr = 0x82ACA630;
	sub_825105D0(ctx, base);
	// 82ACA630: 93DF00E4  stw r30, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[30].u32 ) };
	// 82ACA634: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82ACA638: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82ACA63C: 419A0310  beq cr6, 0x82aca94c
	if ctx.cr[6].eq {
	pc = 0x82ACA94C; continue 'dispatch;
	}
	// 82ACA640: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82ACA644: 419A0278  beq cr6, 0x82aca8bc
	if ctx.cr[6].eq {
	pc = 0x82ACA8BC; continue 'dispatch;
	}
	// 82ACA648: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82ACA64C: 419A019C  beq cr6, 0x82aca7e8
	if ctx.cr[6].eq {
	pc = 0x82ACA7E8; continue 'dispatch;
	}
	// 82ACA650: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82ACA654: 419A001C  beq cr6, 0x82aca670
	if ctx.cr[6].eq {
	pc = 0x82ACA670; continue 'dispatch;
	}
	// 82ACA658: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 82ACA65C: 409A0344  bne cr6, 0x82aca9a0
	if !ctx.cr[6].eq {
	pc = 0x82ACA9A0; continue 'dispatch;
	}
	// 82ACA660: 93DF00E4  stw r30, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[30].u32 ) };
	// 82ACA664: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACA668: 4BA45F69  bl 0x825105d0
	ctx.lr = 0x82ACA66C;
	sub_825105D0(ctx, base);
	// 82ACA66C: 48000334  b 0x82aca9a0
	pc = 0x82ACA9A0; continue 'dispatch;
	// 82ACA670: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACA674: 809F00E8  lwz r4, 0xe8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82ACA678: 4BA48491  bl 0x82512b08
	ctx.lr = 0x82ACA67C;
	sub_82512B08(ctx, base);
	// 82ACA67C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82ACA680: 4BFFF441  bl 0x82ac9ac0
	ctx.lr = 0x82ACA684;
	sub_82AC9AC0(ctx, base);
	// 82ACA684: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACA688: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82ACA68C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ACA690: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACA694: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82ACA698: 419A0024  beq cr6, 0x82aca6bc
	if ctx.cr[6].eq {
	pc = 0x82ACA6BC; continue 'dispatch;
	}
	// 82ACA69C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ACA6A0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ACA6A4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACA6A8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ACA6AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ACA6B0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ACA6B4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACA6B8: 4082FFE8  bne 0x82aca6a0
	if !ctx.cr[0].eq {
	pc = 0x82ACA6A0; continue 'dispatch;
	}
	// 82ACA6BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ACA6C0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82ACA6C4: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82ACA6C8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82ACA6CC: 38A000FD  li r5, 0xfd
	ctx.r[5].s64 = 253;
	// 82ACA6D0: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ACA6D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ACA6D8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82ACA6DC: 4838E365  bl 0x82e58a40
	ctx.lr = 0x82ACA6E0;
	sub_82E58A40(ctx, base);
	// 82ACA6E0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ACA6E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACA6E8: 419A0008  beq cr6, 0x82aca6f0
	if ctx.cr[6].eq {
	pc = 0x82ACA6F0; continue 'dispatch;
	}
	// 82ACA6EC: 4B7F61A5  bl 0x822c0890
	ctx.lr = 0x82ACA6F0;
	sub_822C0890(ctx, base);
	// 82ACA6F0: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82ACA6F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACA6F8: 419A0008  beq cr6, 0x82aca700
	if ctx.cr[6].eq {
	pc = 0x82ACA700; continue 'dispatch;
	}
	// 82ACA6FC: 4B7F6195  bl 0x822c0890
	ctx.lr = 0x82ACA700;
	sub_822C0890(ctx, base);
	// 82ACA700: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACA704: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACA708: 4BFFE881  bl 0x82ac8f88
	ctx.lr = 0x82ACA70C;
	sub_82AC8F88(ctx, base);
	// 82ACA70C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ACA710: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACA714: 4BFFE875  bl 0x82ac8f88
	ctx.lr = 0x82ACA718;
	sub_82AC8F88(ctx, base);
	// 82ACA718: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82ACA71C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACA720: 4BFFE869  bl 0x82ac8f88
	ctx.lr = 0x82ACA724;
	sub_82AC8F88(ctx, base);
	// 82ACA724: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82ACA728: 4BFFF419  bl 0x82ac9b40
	ctx.lr = 0x82ACA72C;
	sub_82AC9B40(ctx, base);
	// 82ACA72C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACA730: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82ACA734: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ACA738: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACA73C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82ACA740: 419A0024  beq cr6, 0x82aca764
	if ctx.cr[6].eq {
	pc = 0x82ACA764; continue 'dispatch;
	}
	// 82ACA744: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ACA748: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ACA74C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACA750: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ACA754: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ACA758: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ACA75C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACA760: 4082FFE8  bne 0x82aca748
	if !ctx.cr[0].eq {
	pc = 0x82ACA748; continue 'dispatch;
	}
	// 82ACA764: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACA768: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82ACA76C: 4BA44D5D  bl 0x8250f4c8
	ctx.lr = 0x82ACA770;
	sub_8250F4C8(ctx, base);
	// 82ACA770: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACA774: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACA778: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82ACA77C: 409A0008  bne cr6, 0x82aca784
	if !ctx.cr[6].eq {
	pc = 0x82ACA784; continue 'dispatch;
	}
	// 82ACA780: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82ACA784: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACA788: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 82ACA78C: 4BA3E28D  bl 0x82508a18
	ctx.lr = 0x82ACA790;
	sub_82508A18(ctx, base);
	// 82ACA790: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82ACA794: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82ACA798: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82ACA79C: 38A00104  li r5, 0x104
	ctx.r[5].s64 = 260;
	// 82ACA7A0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ACA7A4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82ACA7A8: 4838E299  bl 0x82e58a40
	ctx.lr = 0x82ACA7AC;
	sub_82E58A40(ctx, base);
	// 82ACA7AC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82ACA7B0: 483274E1  bl 0x82df1c90
	ctx.lr = 0x82ACA7B4;
	sub_82DF1C90(ctx, base);
	// 82ACA7B4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ACA7B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACA7BC: 419A0008  beq cr6, 0x82aca7c4
	if ctx.cr[6].eq {
	pc = 0x82ACA7C4; continue 'dispatch;
	}
	// 82ACA7C0: 4B7F60D1  bl 0x822c0890
	ctx.lr = 0x82ACA7C4;
	sub_822C0890(ctx, base);
	// 82ACA7C4: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82ACA7C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACA7CC: 419A0008  beq cr6, 0x82aca7d4
	if ctx.cr[6].eq {
	pc = 0x82ACA7D4; continue 'dispatch;
	}
	// 82ACA7D0: 4B7F60C1  bl 0x822c0890
	ctx.lr = 0x82ACA7D4;
	sub_822C0890(ctx, base);
	// 82ACA7D4: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82ACA7D8: 809F00F8  lwz r4, 0xf8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82ACA7DC: 480102E5  bl 0x82adaac0
	ctx.lr = 0x82ACA7E0;
	sub_82ADAAC0(ctx, base);
	// 82ACA7E0: 933F00F8  stw r25, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[25].u32 ) };
	// 82ACA7E4: 480001B4  b 0x82aca998
	pc = 0x82ACA998; continue 'dispatch;
	// 82ACA7E8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82ACA7EC: 4BFFF255  bl 0x82ac9a40
	ctx.lr = 0x82ACA7F0;
	sub_82AC9A40(ctx, base);
	// 82ACA7F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACA7F4: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82ACA7F8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ACA7FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACA800: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82ACA804: 419A0024  beq cr6, 0x82aca828
	if ctx.cr[6].eq {
	pc = 0x82ACA828; continue 'dispatch;
	}
	// 82ACA808: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ACA80C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ACA810: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACA814: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ACA818: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ACA81C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ACA820: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACA824: 4082FFE8  bne 0x82aca80c
	if !ctx.cr[0].eq {
	pc = 0x82ACA80C; continue 'dispatch;
	}
	// 82ACA828: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ACA82C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82ACA830: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 82ACA834: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82ACA838: 38A000EC  li r5, 0xec
	ctx.r[5].s64 = 236;
	// 82ACA83C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ACA840: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACA844: 4838E1FD  bl 0x82e58a40
	ctx.lr = 0x82ACA848;
	sub_82E58A40(ctx, base);
	// 82ACA848: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ACA84C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACA850: 419A0008  beq cr6, 0x82aca858
	if ctx.cr[6].eq {
	pc = 0x82ACA858; continue 'dispatch;
	}
	// 82ACA854: 4B7F603D  bl 0x822c0890
	ctx.lr = 0x82ACA858;
	sub_822C0890(ctx, base);
	// 82ACA858: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82ACA85C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACA860: 419A0008  beq cr6, 0x82aca868
	if ctx.cr[6].eq {
	pc = 0x82ACA868; continue 'dispatch;
	}
	// 82ACA864: 4B7F602D  bl 0x822c0890
	ctx.lr = 0x82ACA868;
	sub_822C0890(ctx, base);
	// 82ACA868: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82ACA86C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACA870: 4BFFF9E9  bl 0x82aca258
	ctx.lr = 0x82ACA874;
	sub_82ACA258(ctx, base);
	// 82ACA874: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACA878: 4BFFF509  bl 0x82ac9d80
	ctx.lr = 0x82ACA87C;
	sub_82AC9D80(ctx, base);
	// 82ACA87C: 809F00F4  lwz r4, 0xf4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82ACA880: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82ACA884: 4801023D  bl 0x82adaac0
	ctx.lr = 0x82ACA888;
	sub_82ADAAC0(ctx, base);
	// 82ACA888: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82ACA88C: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82ACA890: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 82ACA894: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82ACA898: 38BF0100  addi r5, r31, 0x100
	ctx.r[5].s64 = ctx.r[31].s64 + 256;
	// 82ACA89C: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82ACA8A0: C04B6218  lfs f2, 0x6218(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82ACA8A4: C02A4430  lfs f1, 0x4430(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(17456 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACA8A8: 48010349  bl 0x82adabf0
	ctx.lr = 0x82ACA8AC;
	sub_82ADABF0(ctx, base);
	// 82ACA8AC: 907F00F8  stw r3, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[3].u32 ) };
	// 82ACA8B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACA8B4: 4BFFED5D  bl 0x82ac9610
	ctx.lr = 0x82ACA8B8;
	sub_82AC9610(ctx, base);
	// 82ACA8B8: 480000E0  b 0x82aca998
	pc = 0x82ACA998; continue 'dispatch;
	// 82ACA8BC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82ACA8C0: 4BFFF101  bl 0x82ac99c0
	ctx.lr = 0x82ACA8C4;
	sub_82AC99C0(ctx, base);
	// 82ACA8C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACA8C8: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82ACA8CC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ACA8D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACA8D4: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82ACA8D8: 419A0024  beq cr6, 0x82aca8fc
	if ctx.cr[6].eq {
	pc = 0x82ACA8FC; continue 'dispatch;
	}
	// 82ACA8DC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ACA8E0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ACA8E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACA8E8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ACA8EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ACA8F0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ACA8F4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACA8F8: 4082FFE8  bne 0x82aca8e0
	if !ctx.cr[0].eq {
	pc = 0x82ACA8E0; continue 'dispatch;
	}
	// 82ACA8FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ACA900: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82ACA904: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 82ACA908: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82ACA90C: 38A000E4  li r5, 0xe4
	ctx.r[5].s64 = 228;
	// 82ACA910: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ACA914: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACA918: 4838E129  bl 0x82e58a40
	ctx.lr = 0x82ACA91C;
	sub_82E58A40(ctx, base);
	// 82ACA91C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82ACA920: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACA924: 419A0008  beq cr6, 0x82aca92c
	if ctx.cr[6].eq {
	pc = 0x82ACA92C; continue 'dispatch;
	}
	// 82ACA928: 4B7F5F69  bl 0x822c0890
	ctx.lr = 0x82ACA92C;
	sub_822C0890(ctx, base);
	// 82ACA92C: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82ACA930: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACA934: 419A0008  beq cr6, 0x82aca93c
	if ctx.cr[6].eq {
	pc = 0x82ACA93C; continue 'dispatch;
	}
	// 82ACA938: 4B7F5F59  bl 0x822c0890
	ctx.lr = 0x82ACA93C;
	sub_822C0890(ctx, base);
	// 82ACA93C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82ACA940: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACA944: 4BFFF915  bl 0x82aca258
	ctx.lr = 0x82ACA948;
	sub_82ACA258(ctx, base);
	// 82ACA948: 48000050  b 0x82aca998
	pc = 0x82ACA998; continue 'dispatch;
	// 82ACA94C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACA950: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACA954: 4BFFF905  bl 0x82aca258
	ctx.lr = 0x82ACA958;
	sub_82ACA258(ctx, base);
	// 82ACA958: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ACA95C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACA960: 4BFFF8F9  bl 0x82aca258
	ctx.lr = 0x82ACA964;
	sub_82ACA258(ctx, base);
	// 82ACA964: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACA968: 83DF00EC  lwz r30, 0xec(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82ACA96C: 4BA4717D  bl 0x82511ae8
	ctx.lr = 0x82ACA970;
	sub_82511AE8(ctx, base);
	// 82ACA970: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82ACA974: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82ACA978: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82ACA97C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82ACA980: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACA984: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82ACA988: C02B4430  lfs f1, 0x4430(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17456 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACA98C: C04A6218  lfs f2, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82ACA990: 48010261  bl 0x82adabf0
	ctx.lr = 0x82ACA994;
	sub_82ADABF0(ctx, base);
	// 82ACA994: 907F00F4  stw r3, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[3].u32 ) };
	// 82ACA998: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ACA99C: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82ACA9A0: 817F00F8  lwz r11, 0xf8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82ACA9A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACA9A8: 419A001C  beq cr6, 0x82aca9c4
	if ctx.cr[6].eq {
	pc = 0x82ACA9C4; continue 'dispatch;
	}
	// 82ACA9AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACA9B0: 4BFFF3D1  bl 0x82ac9d80
	ctx.lr = 0x82ACA9B4;
	sub_82AC9D80(ctx, base);
	// 82ACA9B4: 38BF0100  addi r5, r31, 0x100
	ctx.r[5].s64 = ctx.r[31].s64 + 256;
	// 82ACA9B8: 809F00F8  lwz r4, 0xf8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82ACA9BC: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82ACA9C0: 4800FFE9  bl 0x82ada9a8
	ctx.lr = 0x82ACA9C4;
	sub_82ADA9A8(ctx, base);
	// 82ACA9C4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82ACA9C8: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82ACA9CC: 48010435  bl 0x82adae00
	ctx.lr = 0x82ACA9D0;
	sub_82ADAE00(ctx, base);
	// 82ACA9D0: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82ACA9D4: 419A000C  beq cr6, 0x82aca9e0
	if ctx.cr[6].eq {
	pc = 0x82ACA9E0; continue 'dispatch;
	}
	// 82ACA9D8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82ACA9DC: 4B7F5EB5  bl 0x822c0890
	ctx.lr = 0x82ACA9E0;
	sub_822C0890(ctx, base);
	// 82ACA9E0: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82ACA9E4: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82ACA9E8: 486DD7BC  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACA9F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82ACA9F0 size=20
    let mut pc: u32 = 0x82ACA9F0;
    'dispatch: loop {
        match pc {
            0x82ACA9F0 => {
    //   block [0x82ACA9F0..0x82ACAA04)
	// 82ACA9F0: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82ACA9F4: C0040018  lfs f0, 0x18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACA9F8: D0030140  stfs f0, 0x140(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 82ACA9FC: 916300E4  stw r11, 0xe4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82ACAA00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACAA08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ACAA08 size=16
    let mut pc: u32 = 0x82ACAA08;
    'dispatch: loop {
        match pc {
            0x82ACAA08 => {
    //   block [0x82ACAA08..0x82ACAA18)
	// 82ACAA08: 8963013C  lbz r11, 0x13c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(316 as u32) ) } as u64;
	// 82ACAA0C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ACAA10: 99640018  stb r11, 0x18(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 82ACAA14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACAA18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACAA18 size=220
    let mut pc: u32 = 0x82ACAA18;
    'dispatch: loop {
        match pc {
            0x82ACAA18 => {
    //   block [0x82ACAA18..0x82ACAAF4)
	// 82ACAA18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACAA1C: 486DD74D  bl 0x831a8168
	ctx.lr = 0x82ACAA20;
	sub_831A8130(ctx, base);
	// 82ACAA20: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACAA24: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82ACAA28: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACAA2C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ACAA30: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82ACAA34: 41820038  beq 0x82acaa6c
	if ctx.cr[0].eq {
	pc = 0x82ACAA6C; continue 'dispatch;
	}
	// 82ACAA38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACAA3C: 486DEF4D  bl 0x831a9988
	ctx.lr = 0x82ACAA40;
	sub_831A9988(ctx, base);
	// 82ACAA40: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82ACAA44: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ACAA48: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 82ACAA4C: 486DD6AD  bl 0x831a80f8
	ctx.lr = 0x82ACAA50;
	sub_831A80F8(ctx, base);
	// 82ACAA50: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACAA54: 41820018  beq 0x82acaa6c
	if ctx.cr[0].eq {
	pc = 0x82ACAA6C; continue 'dispatch;
	}
	// 82ACAA58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACAA5C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82ACAA60: 4BB96C89  bl 0x826616e8
	ctx.lr = 0x82ACAA64;
	sub_826616E8(ctx, base);
	// 82ACAA64: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ACAA68: 48000084  b 0x82acaaec
	pc = 0x82ACAAEC; continue 'dispatch;
	// 82ACAA6C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82ACAA70: 419A006C  beq cr6, 0x82acaadc
	if ctx.cr[6].eq {
	pc = 0x82ACAADC; continue 'dispatch;
	}
	// 82ACAA74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACAA78: 486DEF11  bl 0x831a9988
	ctx.lr = 0x82ACAA7C;
	sub_831A9988(ctx, base);
	// 82ACAA7C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ACAA80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ACAA84: 386BEB94  addi r3, r11, -0x146c
	ctx.r[3].s64 = ctx.r[11].s64 + -5228;
	// 82ACAA88: 486DD671  bl 0x831a80f8
	ctx.lr = 0x82ACAA8C;
	sub_831A80F8(ctx, base);
	// 82ACAA8C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACAA90: 41820014  beq 0x82acaaa4
	if ctx.cr[0].eq {
	pc = 0x82ACAAA4; continue 'dispatch;
	}
	// 82ACAA94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACAA98: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82ACAA9C: 4BFFFF55  bl 0x82aca9f0
	ctx.lr = 0x82ACAAA0;
	sub_82ACA9F0(ctx, base);
	// 82ACAAA0: 4BFFFFC4  b 0x82acaa64
	pc = 0x82ACAA64; continue 'dispatch;
	// 82ACAAA4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82ACAAA8: 419A0034  beq cr6, 0x82acaadc
	if ctx.cr[6].eq {
	pc = 0x82ACAADC; continue 'dispatch;
	}
	// 82ACAAAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACAAB0: 486DEED9  bl 0x831a9988
	ctx.lr = 0x82ACAAB4;
	sub_831A9988(ctx, base);
	// 82ACAAB4: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ACAAB8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ACAABC: 386BEBEC  addi r3, r11, -0x1414
	ctx.r[3].s64 = ctx.r[11].s64 + -5140;
	// 82ACAAC0: 486DD639  bl 0x831a80f8
	ctx.lr = 0x82ACAAC4;
	sub_831A80F8(ctx, base);
	// 82ACAAC4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACAAC8: 41820014  beq 0x82acaadc
	if ctx.cr[0].eq {
	pc = 0x82ACAADC; continue 'dispatch;
	}
	// 82ACAACC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACAAD0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82ACAAD4: 4BFFFF35  bl 0x82acaa08
	ctx.lr = 0x82ACAAD8;
	sub_82ACAA08(ctx, base);
	// 82ACAAD8: 48000014  b 0x82acaaec
	pc = 0x82ACAAEC; continue 'dispatch;
	// 82ACAADC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82ACAAE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACAAE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACAAE8: 4BA47B31  bl 0x82512618
	ctx.lr = 0x82ACAAEC;
	sub_82512618(ctx, base);
	// 82ACAAEC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ACAAF0: 486DD6C8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACAAF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACAAF8 size=244
    let mut pc: u32 = 0x82ACAAF8;
    'dispatch: loop {
        match pc {
            0x82ACAAF8 => {
    //   block [0x82ACAAF8..0x82ACABEC)
	// 82ACAAF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACAAFC: 486DD671  bl 0x831a816c
	ctx.lr = 0x82ACAB00;
	sub_831A8130(ctx, base);
	// 82ACAB00: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACAB04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACAB08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACAB0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ACAB10: 4BA44A09  bl 0x8250f518
	ctx.lr = 0x82ACAB14;
	sub_8250F518(ctx, base);
	// 82ACAB14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACAB18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACAB1C: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 82ACAB20: 409A0008  bne cr6, 0x82acab28
	if !ctx.cr[6].eq {
	pc = 0x82ACAB28; continue 'dispatch;
	}
	// 82ACAB24: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ACAB28: 4BA5DA59  bl 0x82528580
	ctx.lr = 0x82ACAB2C;
	sub_82528580(ctx, base);
	// 82ACAB2C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ACAB30: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82ACAB34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACAB38: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACABF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ACABF0 size=152
    let mut pc: u32 = 0x82ACABF0;
    'dispatch: loop {
        match pc {
            0x82ACABF0 => {
    //   block [0x82ACABF0..0x82ACAC88)
	// 82ACABF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACABF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACABF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACABFC: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACAC88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACAC88 size=152
    let mut pc: u32 = 0x82ACAC88;
    'dispatch: loop {
        match pc {
            0x82ACAC88 => {
    //   block [0x82ACAC88..0x82ACAD20)
	// 82ACAC88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACAC8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACAC90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACAC94: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACAC98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACAC9C: 39400160  li r10, 0x160
	ctx.r[10].s64 = 352;
	// 82ACACA0: 397F0150  addi r11, r31, 0x150
	ctx.r[11].s64 = ctx.r[31].s64 + 336;
	// 82ACACA4: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82ACACA8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ACACAC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82ACACB0: 13DF50C7  vcmpequd (lvx128) v30, v31, v10
	tmp.u32 = ctx.r[31].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82ACACB4: 91010068  stw r8, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u32 ) };
	// 82ACACB8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82ACACBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACAD20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACAD20 size=308
    let mut pc: u32 = 0x82ACAD20;
    'dispatch: loop {
        match pc {
            0x82ACAD20 => {
    //   block [0x82ACAD20..0x82ACAE54)
	// 82ACAD20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACAD24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACAD28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACAD2C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACAD30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACAD34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACAD38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACAD3C: 4BA4478D  bl 0x8250f4c8
	ctx.lr = 0x82ACAD40;
	sub_8250F4C8(ctx, base);
	// 82ACAD40: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACAD44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACAD48: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82ACAD4C: 409A0008  bne cr6, 0x82acad54
	if !ctx.cr[6].eq {
	pc = 0x82ACAD54; continue 'dispatch;
	}
	// 82ACAD50: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACAD54: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACAD58: 4BA3FBF9  bl 0x8250a950
	ctx.lr = 0x82ACAD5C;
	sub_8250A950(ctx, base);
	// 82ACAD5C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACAD60: 48326F31  bl 0x82df1c90
	ctx.lr = 0x82ACAD64;
	sub_82DF1C90(ctx, base);
	// 82ACAD64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACAD68: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82ACAD6C: 4BA473AD  bl 0x82512118
	ctx.lr = 0x82ACAD70;
	sub_82512118(ctx, base);
	// 82ACAD70: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACAD74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACAD78: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ACAD7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ACAD80: 4E800421  bctrl
	ctx.lr = 0x82ACAD84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ACAD84: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ACAD88: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82ACAD8C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82ACAD90: C00B003C  lfs f0, 0x3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACAD94: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACAD98: C18B0034  lfs f12, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ACAD9C: C16B0030  lfs f11, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ACADA0: D1610070  stfs f11, 0x70(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82ACADA4: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82ACADA8: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82ACADAC: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82ACADB0: 483B1229  bl 0x82e7bfd8
	ctx.lr = 0x82ACADB4;
	sub_82E7BFD8(ctx, base);
	// 82ACADB4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ACADB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACADBC: 419A0008  beq cr6, 0x82acadc4
	if ctx.cr[6].eq {
	pc = 0x82ACADC4; continue 'dispatch;
	}
	// 82ACADC0: 4B7F5AD1  bl 0x822c0890
	ctx.lr = 0x82ACADC4;
	sub_822C0890(ctx, base);
	// 82ACADC4: 817F0134  lwz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82ACADC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACADCC: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ACADD0: 48328C39  bl 0x82df3a08
	ctx.lr = 0x82ACADD4;
	sub_82DF3A08(ctx, base);
	// 82ACADD4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ACADD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACADDC: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82ACADE0: 409A0008  bne cr6, 0x82acade8
	if !ctx.cr[6].eq {
	pc = 0x82ACADE8; continue 'dispatch;
	}
	// 82ACADE4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ACADE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ACADEC: 38C0000B  li r6, 0xb
	ctx.r[6].s64 = 11;
	// 82ACADF0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ACADF4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82ACADF8: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACADFC: 4BD09D55  bl 0x827d4b50
	ctx.lr = 0x82ACAE00;
	sub_827D4B50(ctx, base);
	// 82ACAE00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACAE04: 48328625  bl 0x82df3428
	ctx.lr = 0x82ACAE08;
	sub_82DF3428(ctx, base);
	// 82ACAE08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACAE0C: 83FF0178  lwz r31, 0x178(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) } as u64;
	// 82ACAE10: 4BA46CD9  bl 0x82511ae8
	ctx.lr = 0x82ACAE14;
	sub_82511AE8(ctx, base);
	// 82ACAE14: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82ACAE18: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ACAE1C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82ACAE20: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82ACAE24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACAE28: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82ACAE2C: C02B4430  lfs f1, 0x4430(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17456 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACAE30: C04A9D80  lfs f2, -0x6280(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25216 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82ACAE34: 4800FDBD  bl 0x82adabf0
	ctx.lr = 0x82ACAE38;
	sub_82ADABF0(ctx, base);
	// 82ACAE38: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACAE3C: 48326E55  bl 0x82df1c90
	ctx.lr = 0x82ACAE40;
	sub_82DF1C90(ctx, base);
	// 82ACAE40: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82ACAE44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACAE48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACAE4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACAE50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACAE58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ACAE58 size=284
    let mut pc: u32 = 0x82ACAE58;
    'dispatch: loop {
        match pc {
            0x82ACAE58 => {
    //   block [0x82ACAE58..0x82ACAF74)
	// 82ACAE58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACAE5C: 486DD305  bl 0x831a8160
	ctx.lr = 0x82ACAE60;
	sub_831A8130(ctx, base);
	// 82ACAE60: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82ACAE64: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACAF78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACAF78 size=196
    let mut pc: u32 = 0x82ACAF78;
    'dispatch: loop {
        match pc {
            0x82ACAF78 => {
    //   block [0x82ACAF78..0x82ACB03C)
	// 82ACAF78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACAF7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACAF80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACAF84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACAF88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACAF8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACAF90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACAF94: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82ACAF98: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ACAF9C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACAFA0: 4B7F5999  bl 0x822c0938
	ctx.lr = 0x82ACAFA4;
	sub_822C0938(ctx, base);
	// 82ACAFA4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACAFA8: 41820028  beq 0x82acafd0
	if ctx.cr[0].eq {
	pc = 0x82ACAFD0; continue 'dispatch;
	}
	// 82ACAFAC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACAFB0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82ACAFB4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ACAFB8: 392B9DB0  addi r9, r11, -0x6250
	ctx.r[9].s64 = ctx.r[11].s64 + -25168;
	// 82ACAFBC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ACAFC0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ACAFC4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ACAFC8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ACAFCC: 48000008  b 0x82acafd4
	pc = 0x82ACAFD4; continue 'dispatch;
	// 82ACAFD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACAFD4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACAFD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACAFDC: 409A0044  bne cr6, 0x82acb020
	if !ctx.cr[6].eq {
	pc = 0x82ACB020; continue 'dispatch;
	}
	// 82ACAFE0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ACAFE4: 419A001C  beq cr6, 0x82acb000
	if ctx.cr[6].eq {
	pc = 0x82ACB000; continue 'dispatch;
	}
	// 82ACAFE8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACAFEC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ACAFF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACAFF4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACAFF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ACAFFC: 4E800421  bctrl
	ctx.lr = 0x82ACB000;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ACB000: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ACB004: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ACB008: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACB00C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82ACB010: 816B0658  lwz r11, 0x658(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1624 as u32) ) } as u64;
	// 82ACB014: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ACB018: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ACB01C: 4B7F4FE5  bl 0x822c0000
	ctx.lr = 0x82ACB020;
	sub_822C0000(ctx, base);
	// 82ACB020: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACB024: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ACB028: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACB02C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACB030: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ACB034: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACB038: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACB040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACB040 size=196
    let mut pc: u32 = 0x82ACB040;
    'dispatch: loop {
        match pc {
            0x82ACB040 => {
    //   block [0x82ACB040..0x82ACB104)
	// 82ACB040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACB044: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACB048: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACB04C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACB050: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACB054: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACB058: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACB05C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82ACB060: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ACB064: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACB068: 4B7F58D1  bl 0x822c0938
	ctx.lr = 0x82ACB06C;
	sub_822C0938(ctx, base);
	// 82ACB06C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACB070: 41820028  beq 0x82acb098
	if ctx.cr[0].eq {
	pc = 0x82ACB098; continue 'dispatch;
	}
	// 82ACB074: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACB078: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82ACB07C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ACB080: 392B9DC4  addi r9, r11, -0x623c
	ctx.r[9].s64 = ctx.r[11].s64 + -25148;
	// 82ACB084: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ACB088: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ACB08C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ACB090: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ACB094: 48000008  b 0x82acb09c
	pc = 0x82ACB09C; continue 'dispatch;
	// 82ACB098: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACB09C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACB0A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACB0A4: 409A0044  bne cr6, 0x82acb0e8
	if !ctx.cr[6].eq {
	pc = 0x82ACB0E8; continue 'dispatch;
	}
	// 82ACB0A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ACB0AC: 419A001C  beq cr6, 0x82acb0c8
	if ctx.cr[6].eq {
	pc = 0x82ACB0C8; continue 'dispatch;
	}
	// 82ACB0B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACB0B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ACB0B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACB0BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACB0C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ACB0C4: 4E800421  bctrl
	ctx.lr = 0x82ACB0C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ACB0C8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ACB0CC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ACB0D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACB0D4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82ACB0D8: 816B0658  lwz r11, 0x658(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1624 as u32) ) } as u64;
	// 82ACB0DC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ACB0E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ACB0E4: 4B7F4F1D  bl 0x822c0000
	ctx.lr = 0x82ACB0E8;
	sub_822C0000(ctx, base);
	// 82ACB0E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACB0EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ACB0F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACB0F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACB0F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ACB0FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACB100: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACB108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACB108 size=196
    let mut pc: u32 = 0x82ACB108;
    'dispatch: loop {
        match pc {
            0x82ACB108 => {
    //   block [0x82ACB108..0x82ACB1CC)
	// 82ACB108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACB10C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACB110: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACB114: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACB118: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACB11C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACB120: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACB124: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82ACB128: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ACB12C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACB130: 4B7F5809  bl 0x822c0938
	ctx.lr = 0x82ACB134;
	sub_822C0938(ctx, base);
	// 82ACB134: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACB138: 41820028  beq 0x82acb160
	if ctx.cr[0].eq {
	pc = 0x82ACB160; continue 'dispatch;
	}
	// 82ACB13C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACB140: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82ACB144: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ACB148: 392B9DD8  addi r9, r11, -0x6228
	ctx.r[9].s64 = ctx.r[11].s64 + -25128;
	// 82ACB14C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ACB150: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ACB154: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ACB158: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ACB15C: 48000008  b 0x82acb164
	pc = 0x82ACB164; continue 'dispatch;
	// 82ACB160: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACB164: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACB168: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACB16C: 409A0044  bne cr6, 0x82acb1b0
	if !ctx.cr[6].eq {
	pc = 0x82ACB1B0; continue 'dispatch;
	}
	// 82ACB170: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ACB174: 419A001C  beq cr6, 0x82acb190
	if ctx.cr[6].eq {
	pc = 0x82ACB190; continue 'dispatch;
	}
	// 82ACB178: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACB17C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ACB180: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACB184: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACB188: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ACB18C: 4E800421  bctrl
	ctx.lr = 0x82ACB190;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ACB190: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ACB194: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ACB198: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACB19C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82ACB1A0: 816B0658  lwz r11, 0x658(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1624 as u32) ) } as u64;
	// 82ACB1A4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ACB1A8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ACB1AC: 4B7F4E55  bl 0x822c0000
	ctx.lr = 0x82ACB1B0;
	sub_822C0000(ctx, base);
	// 82ACB1B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACB1B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ACB1B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACB1BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACB1C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ACB1C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACB1C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACB1D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACB1D0 size=196
    let mut pc: u32 = 0x82ACB1D0;
    'dispatch: loop {
        match pc {
            0x82ACB1D0 => {
    //   block [0x82ACB1D0..0x82ACB294)
	// 82ACB1D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACB1D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACB1D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACB1DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACB1E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACB1E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACB1E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACB1EC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82ACB1F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ACB1F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACB1F8: 4B7F5741  bl 0x822c0938
	ctx.lr = 0x82ACB1FC;
	sub_822C0938(ctx, base);
	// 82ACB1FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACB200: 41820028  beq 0x82acb228
	if ctx.cr[0].eq {
	pc = 0x82ACB228; continue 'dispatch;
	}
	// 82ACB204: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACB208: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82ACB20C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ACB210: 392B9DEC  addi r9, r11, -0x6214
	ctx.r[9].s64 = ctx.r[11].s64 + -25108;
	// 82ACB214: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ACB218: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ACB21C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ACB220: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ACB224: 48000008  b 0x82acb22c
	pc = 0x82ACB22C; continue 'dispatch;
	// 82ACB228: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACB22C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACB230: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACB234: 409A0044  bne cr6, 0x82acb278
	if !ctx.cr[6].eq {
	pc = 0x82ACB278; continue 'dispatch;
	}
	// 82ACB238: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ACB23C: 419A001C  beq cr6, 0x82acb258
	if ctx.cr[6].eq {
	pc = 0x82ACB258; continue 'dispatch;
	}
	// 82ACB240: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACB244: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ACB248: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACB24C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACB250: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ACB254: 4E800421  bctrl
	ctx.lr = 0x82ACB258;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ACB258: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ACB25C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ACB260: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACB264: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82ACB268: 816B0658  lwz r11, 0x658(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1624 as u32) ) } as u64;
	// 82ACB26C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ACB270: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ACB274: 4B7F4D8D  bl 0x822c0000
	ctx.lr = 0x82ACB278;
	sub_822C0000(ctx, base);
	// 82ACB278: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACB27C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ACB280: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACB284: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACB288: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ACB28C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACB290: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACB298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACB298 size=196
    let mut pc: u32 = 0x82ACB298;
    'dispatch: loop {
        match pc {
            0x82ACB298 => {
    //   block [0x82ACB298..0x82ACB35C)
	// 82ACB298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACB29C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACB2A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACB2A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACB2A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACB2AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACB2B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACB2B4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82ACB2B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ACB2BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACB2C0: 4B7F5679  bl 0x822c0938
	ctx.lr = 0x82ACB2C4;
	sub_822C0938(ctx, base);
	// 82ACB2C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACB2C8: 41820028  beq 0x82acb2f0
	if ctx.cr[0].eq {
	pc = 0x82ACB2F0; continue 'dispatch;
	}
	// 82ACB2CC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACB2D0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82ACB2D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ACB2D8: 392B9E00  addi r9, r11, -0x6200
	ctx.r[9].s64 = ctx.r[11].s64 + -25088;
	// 82ACB2DC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ACB2E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ACB2E4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ACB2E8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ACB2EC: 48000008  b 0x82acb2f4
	pc = 0x82ACB2F4; continue 'dispatch;
	// 82ACB2F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACB2F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACB2F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACB2FC: 409A0044  bne cr6, 0x82acb340
	if !ctx.cr[6].eq {
	pc = 0x82ACB340; continue 'dispatch;
	}
	// 82ACB300: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ACB304: 419A001C  beq cr6, 0x82acb320
	if ctx.cr[6].eq {
	pc = 0x82ACB320; continue 'dispatch;
	}
	// 82ACB308: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACB30C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ACB310: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACB314: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACB318: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ACB31C: 4E800421  bctrl
	ctx.lr = 0x82ACB320;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ACB320: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ACB324: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ACB328: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACB32C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82ACB330: 816B0658  lwz r11, 0x658(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1624 as u32) ) } as u64;
	// 82ACB334: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ACB338: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ACB33C: 4B7F4CC5  bl 0x822c0000
	ctx.lr = 0x82ACB340;
	sub_822C0000(ctx, base);
	// 82ACB340: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACB344: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ACB348: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACB34C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACB350: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ACB354: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACB358: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACB360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACB360 size=120
    let mut pc: u32 = 0x82ACB360;
    'dispatch: loop {
        match pc {
            0x82ACB360 => {
    //   block [0x82ACB360..0x82ACB3D8)
	// 82ACB360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACB364: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACB368: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACB36C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACB370: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACB374: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACB378: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ACB37C: 396B9E2C  addi r11, r11, -0x61d4
	ctx.r[11].s64 = ctx.r[11].s64 + -25044;
	// 82ACB380: 394A9E14  addi r10, r10, -0x61ec
	ctx.r[10].s64 = ctx.r[10].s64 + -25068;
	// 82ACB384: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACB388: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82ACB38C: 807F0194  lwz r3, 0x194(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82ACB390: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACB394: 419A0008  beq cr6, 0x82acb39c
	if ctx.cr[6].eq {
	pc = 0x82ACB39C; continue 'dispatch;
	}
	// 82ACB398: 4B7F54F9  bl 0x822c0890
	ctx.lr = 0x82ACB39C;
	sub_822C0890(ctx, base);
	// 82ACB39C: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82ACB3A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACB3A4: 419A0008  beq cr6, 0x82acb3ac
	if ctx.cr[6].eq {
	pc = 0x82ACB3AC; continue 'dispatch;
	}
	// 82ACB3A8: 4B7F54E9  bl 0x822c0890
	ctx.lr = 0x82ACB3AC;
	sub_822C0890(ctx, base);
	// 82ACB3AC: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82ACB3B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACB3B4: 419A0008  beq cr6, 0x82acb3bc
	if ctx.cr[6].eq {
	pc = 0x82ACB3BC; continue 'dispatch;
	}
	// 82ACB3B8: 4B7F54D9  bl 0x822c0890
	ctx.lr = 0x82ACB3BC;
	sub_822C0890(ctx, base);
	// 82ACB3BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACB3C0: 4B883F91  bl 0x8234f350
	ctx.lr = 0x82ACB3C4;
	sub_8234F350(ctx, base);
	// 82ACB3C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ACB3C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACB3CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACB3D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACB3D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACB3D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ACB3D8 size=8
    let mut pc: u32 = 0x82ACB3D8;
    'dispatch: loop {
        match pc {
            0x82ACB3D8 => {
    //   block [0x82ACB3D8..0x82ACB3E0)
	// 82ACB3D8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82ACB3DC: 4800050C  b 0x82acb8e8
	sub_82ACB8E8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACB3E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACB3E0 size=180
    let mut pc: u32 = 0x82ACB3E0;
    'dispatch: loop {
        match pc {
            0x82ACB3E0 => {
    //   block [0x82ACB3E0..0x82ACB494)
	// 82ACB3E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACB3E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACB3E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACB3EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACB3F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACB3F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACB3F8: 4BA46C71  bl 0x82512068
	ctx.lr = 0x82ACB3FC;
	sub_82512068(ctx, base);
	// 82ACB3FC: 817F0190  lwz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82ACB400: 3BDF0190  addi r30, r31, 0x190
	ctx.r[30].s64 = ctx.r[31].s64 + 400;
	// 82ACB404: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACB408: 419A0074  beq cr6, 0x82acb47c
	if ctx.cr[6].eq {
	pc = 0x82ACB47C; continue 'dispatch;
	}
	// 82ACB40C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACB410: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACB414: 4BA440B5  bl 0x8250f4c8
	ctx.lr = 0x82ACB418;
	sub_8250F4C8(ctx, base);
	// 82ACB418: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACB41C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ACB420: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACB424: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82ACB428: 409A0008  bne cr6, 0x82acb430
	if !ctx.cr[6].eq {
	pc = 0x82ACB430; continue 'dispatch;
	}
	// 82ACB42C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACB430: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACB434: 4BA3F51D  bl 0x8250a950
	ctx.lr = 0x82ACB438;
	sub_8250A950(ctx, base);
	// 82ACB438: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACB43C: 48326855  bl 0x82df1c90
	ctx.lr = 0x82ACB440;
	sub_82DF1C90(ctx, base);
	// 82ACB440: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ACB444: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACB448: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82ACB44C: 409A0008  bne cr6, 0x82acb454
	if !ctx.cr[6].eq {
	pc = 0x82ACB454; continue 'dispatch;
	}
	// 82ACB450: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACB454: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ACB458: 4BD085A9  bl 0x827d3a00
	ctx.lr = 0x82ACB45C;
	sub_827D3A00(ctx, base);
	// 82ACB45C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ACB460: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ACB464: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACB468: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82ACB46C: 419A0008  beq cr6, 0x82acb474
	if ctx.cr[6].eq {
	pc = 0x82ACB474; continue 'dispatch;
	}
	// 82ACB470: 4B7F5421  bl 0x822c0890
	ctx.lr = 0x82ACB474;
	sub_822C0890(ctx, base);
	// 82ACB474: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACB478: 48326819  bl 0x82df1c90
	ctx.lr = 0x82ACB47C;
	sub_82DF1C90(ctx, base);
	// 82ACB47C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ACB480: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACB484: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACB488: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ACB48C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACB490: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACB498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACB498 size=276
    let mut pc: u32 = 0x82ACB498;
    'dispatch: loop {
        match pc {
            0x82ACB498 => {
    //   block [0x82ACB498..0x82ACB5AC)
	// 82ACB498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACB49C: 486DCCD1  bl 0x831a816c
	ctx.lr = 0x82ACB4A0;
	sub_831A8130(ctx, base);
	// 82ACB4A0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACB4A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACB4A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACB4AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACB4B0: 4BA44019  bl 0x8250f4c8
	ctx.lr = 0x82ACB4B4;
	sub_8250F4C8(ctx, base);
	// 82ACB4B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACB4B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACB4BC: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82ACB4C0: 409A0008  bne cr6, 0x82acb4c8
	if !ctx.cr[6].eq {
	pc = 0x82ACB4C8; continue 'dispatch;
	}
	// 82ACB4C4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACB4C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACB4CC: 4BA3F485  bl 0x8250a950
	ctx.lr = 0x82ACB4D0;
	sub_8250A950(ctx, base);
	// 82ACB4D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACB4D4: 483267BD  bl 0x82df1c90
	ctx.lr = 0x82ACB4D8;
	sub_82DF1C90(ctx, base);
	// 82ACB4D8: 817F0134  lwz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82ACB4DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACB4E0: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ACB4E4: 48328525  bl 0x82df3a08
	ctx.lr = 0x82ACB4E8;
	sub_82DF3A08(ctx, base);
	// 82ACB4E8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ACB4EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACB4F0: 3BCBFF40  addi r30, r11, -0xc0
	ctx.r[30].s64 = ctx.r[11].s64 + -192;
	// 82ACB4F4: 409A0008  bne cr6, 0x82acb4fc
	if !ctx.cr[6].eq {
	pc = 0x82ACB4FC; continue 'dispatch;
	}
	// 82ACB4F8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ACB4FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACB500: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82ACB504: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 82ACB508: 4BA46C11  bl 0x82512118
	ctx.lr = 0x82ACB50C;
	sub_82512118(ctx, base);
	// 82ACB50C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82ACB510: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ACB514: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82ACB518: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82ACB51C: 38E0000B  li r7, 0xb
	ctx.r[7].s64 = 11;
	// 82ACB520: 4BD09791  bl 0x827d4cb0
	ctx.lr = 0x82ACB524;
	sub_827D4CB0(ctx, base);
	// 82ACB524: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ACB528: 395F0190  addi r10, r31, 0x190
	ctx.r[10].s64 = ctx.r[31].s64 + 400;
	// 82ACB52C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82ACB530: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82ACB534: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACB538: 917F0190  stw r11, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[11].u32 ) };
	// 82ACB53C: 4B7F8F25  bl 0x822c4460
	ctx.lr = 0x82ACB540;
	sub_822C4460(ctx, base);
	// 82ACB540: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ACB544: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACB548: 419A0008  beq cr6, 0x82acb550
	if ctx.cr[6].eq {
	pc = 0x82ACB550; continue 'dispatch;
	}
	// 82ACB54C: 4B7F5345  bl 0x822c0890
	ctx.lr = 0x82ACB550;
	sub_822C0890(ctx, base);
	// 82ACB550: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82ACB554: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACB558: 419A0008  beq cr6, 0x82acb560
	if ctx.cr[6].eq {
	pc = 0x82ACB560; continue 'dispatch;
	}
	// 82ACB55C: 4B7F5335  bl 0x822c0890
	ctx.lr = 0x82ACB560;
	sub_822C0890(ctx, base);
	// 82ACB560: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACB564: 48327EC5  bl 0x82df3428
	ctx.lr = 0x82ACB568;
	sub_82DF3428(ctx, base);
	// 82ACB568: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACB56C: 83DF0178  lwz r30, 0x178(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) } as u64;
	// 82ACB570: 4BA46579  bl 0x82511ae8
	ctx.lr = 0x82ACB574;
	sub_82511AE8(ctx, base);
	// 82ACB574: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82ACB578: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ACB57C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82ACB580: 38800017  li r4, 0x17
	ctx.r[4].s64 = 23;
	// 82ACB584: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACB588: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82ACB58C: C02B4430  lfs f1, 0x4430(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17456 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACB590: C04A9D80  lfs f2, -0x6280(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25216 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82ACB594: 4800F65D  bl 0x82adabf0
	ctx.lr = 0x82ACB598;
	sub_82ADABF0(ctx, base);
	// 82ACB598: 907F0180  stw r3, 0x180(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[3].u32 ) };
	// 82ACB59C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACB5A0: 483266F1  bl 0x82df1c90
	ctx.lr = 0x82ACB5A4;
	sub_82DF1C90(ctx, base);
	// 82ACB5A4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82ACB5A8: 486DCC14  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACB5B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACB5B0 size=188
    let mut pc: u32 = 0x82ACB5B0;
    'dispatch: loop {
        match pc {
            0x82ACB5B0 => {
    //   block [0x82ACB5B0..0x82ACB66C)
	// 82ACB5B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACB5B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACB5B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACB5BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACB5C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACB5C4: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACB5C8: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82ACB5CC: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82ACB5D0: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82ACB5D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACB5D8: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ACB5DC: 483D5155  bl 0x82ea0730
	ctx.lr = 0x82ACB5E0;
	sub_82EA0730(ctx, base);
	// 82ACB5E0: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 82ACB5E4: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 82ACB5E8: 817F0134  lwz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82ACB5EC: C02B0010  lfs f1, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACB5F0: 4844EC01  bl 0x82f1a1f0
	ctx.lr = 0x82ACB5F4;
	sub_82F1A1F0(ctx, base);
	// 82ACB5F4: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82ACB5F8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82ACB5FC: 4182000C  beq 0x82acb608
	if ctx.cr[0].eq {
	pc = 0x82ACB608; continue 'dispatch;
	}
	// 82ACB600: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACB604: 4B81CC45  bl 0x822e8248
	ctx.lr = 0x82ACB608;
	sub_822E8248(ctx, base);
	// 82ACB608: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82ACB60C: 4BFE348D  bl 0x82aaea98
	ctx.lr = 0x82ACB610;
	sub_82AAEA98(ctx, base);
	// 82ACB610: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82ACB614: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82ACB618: 388BE664  addi r4, r11, -0x199c
	ctx.r[4].s64 = ctx.r[11].s64 + -6556;
	// 82ACB61C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ACB620: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACB624: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82ACB628: 4BA47AC1  bl 0x825130e8
	ctx.lr = 0x82ACB62C;
	sub_825130E8(ctx, base);
	// 82ACB62C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ACB630: 907F00EC  stw r3, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[3].u32 ) };
	// 82ACB634: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACB638: 419A000C  beq cr6, 0x82acb644
	if ctx.cr[6].eq {
	pc = 0x82ACB644; continue 'dispatch;
	}
	// 82ACB63C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82ACB640: 4B81CC29  bl 0x822e8268
	ctx.lr = 0x82ACB644;
	sub_822E8268(ctx, base);
	// 82ACB644: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82ACB648: 419A000C  beq cr6, 0x82acb654
	if ctx.cr[6].eq {
	pc = 0x82ACB654; continue 'dispatch;
	}
	// 82ACB64C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACB650: 4B81CC19  bl 0x822e8268
	ctx.lr = 0x82ACB654;
	sub_822E8268(ctx, base);
	// 82ACB654: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ACB658: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACB65C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACB660: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ACB664: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACB668: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACB670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACB670 size=632
    let mut pc: u32 = 0x82ACB670;
    'dispatch: loop {
        match pc {
            0x82ACB670 => {
    //   block [0x82ACB670..0x82ACB8E8)
	// 82ACB670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACB674: 486DCAE9  bl 0x831a815c
	ctx.lr = 0x82ACB678;
	sub_831A8130(ctx, base);
	// 82ACB678: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 82ACB67C: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82ACB680: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACB684: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACB688: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82ACB68C: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82ACB690: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82ACB694: 4BA46C9D  bl 0x82512330
	ctx.lr = 0x82ACB698;
	sub_82512330(ctx, base);
	// 82ACB698: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82ACB69C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ACB6A0: 93DF00E8  stw r30, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[30].u32 ) };
	// 82ACB6A4: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82ACB6A8: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82ACB6AC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ACB6B0: 394A9E2C  addi r10, r10, -0x61d4
	ctx.r[10].s64 = ctx.r[10].s64 + -25044;
	// 82ACB6B4: 39299E14  addi r9, r9, -0x61ec
	ctx.r[9].s64 = ctx.r[9].s64 + -25068;
	// 82ACB6B8: 93DF00E4  stw r30, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[30].u32 ) };
	// 82ACB6BC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ACB6C0: 394000F0  li r10, 0xf0
	ctx.r[10].s64 = 240;
	// 82ACB6C4: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82ACB6C8: 39200100  li r9, 0x100
	ctx.r[9].s64 = 256;
	// 82ACB6CC: 93DF00EC  stw r30, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[30].u32 ) };
	// 82ACB6D0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACB8E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACB8E8 size=76
    let mut pc: u32 = 0x82ACB8E8;
    'dispatch: loop {
        match pc {
            0x82ACB8E8 => {
    //   block [0x82ACB8E8..0x82ACB934)
	// 82ACB8E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACB8EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACB8F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACB8F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACB8F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACB8FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACB900: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ACB904: 4BFFFA5D  bl 0x82acb360
	ctx.lr = 0x82ACB908;
	sub_82ACB360(ctx, base);
	// 82ACB908: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACB90C: 4182000C  beq 0x82acb918
	if ctx.cr[0].eq {
	pc = 0x82ACB918; continue 'dispatch;
	}
	// 82ACB910: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACB914: 48326AC5  bl 0x82df23d8
	ctx.lr = 0x82ACB918;
	sub_82DF23D8(ctx, base);
	// 82ACB918: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACB91C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ACB920: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACB924: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACB928: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ACB92C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACB930: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACB938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACB938 size=112
    let mut pc: u32 = 0x82ACB938;
    'dispatch: loop {
        match pc {
            0x82ACB938 => {
    //   block [0x82ACB938..0x82ACB9A8)
	// 82ACB938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACB93C: 486DC831  bl 0x831a816c
	ctx.lr = 0x82ACB940;
	sub_831A8130(ctx, base);
	// 82ACB940: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACB944: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82ACB948: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ACB94C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ACB950: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82ACB954: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82ACB958: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 82ACB95C: 48326A8D  bl 0x82df23e8
	ctx.lr = 0x82ACB960;
	sub_82DF23E8(ctx, base);
	// 82ACB960: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACB964: 41820010  beq 0x82acb974
	if ctx.cr[0].eq {
	pc = 0x82ACB974; continue 'dispatch;
	}
	// 82ACB968: 4BFF0FF9  bl 0x82abc960
	ctx.lr = 0x82ACB96C;
	sub_82ABC960(ctx, base);
	// 82ACB96C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACB970: 48000008  b 0x82acb978
	pc = 0x82ACB978; continue 'dispatch;
	// 82ACB974: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ACB978: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ACB97C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82ACB980: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACB984: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACB988: 4BFFF6B9  bl 0x82acb040
	ctx.lr = 0x82ACB98C;
	sub_82ACB040(ctx, base);
	// 82ACB98C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ACB990: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACB994: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACB998: 4B7F4669  bl 0x822c0000
	ctx.lr = 0x82ACB99C;
	sub_822C0000(ctx, base);
	// 82ACB99C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ACB9A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ACB9A4: 486DC818  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACB9A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACB9A8 size=124
    let mut pc: u32 = 0x82ACB9A8;
    'dispatch: loop {
        match pc {
            0x82ACB9A8 => {
    //   block [0x82ACB9A8..0x82ACBA24)
	// 82ACB9A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACB9AC: 486DC7C1  bl 0x831a816c
	ctx.lr = 0x82ACB9B0;
	sub_831A8130(ctx, base);
	// 82ACB9B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACB9B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82ACB9B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ACB9BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ACB9C0: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82ACB9C4: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82ACB9C8: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82ACB9CC: 48326A1D  bl 0x82df23e8
	ctx.lr = 0x82ACB9D0;
	sub_82DF23E8(ctx, base);
	// 82ACB9D0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82ACB9D4: 4182001C  beq 0x82acb9f0
	if ctx.cr[0].eq {
	pc = 0x82ACB9F0; continue 'dispatch;
	}
	// 82ACB9D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACB9DC: 4838DCA5  bl 0x82e59680
	ctx.lr = 0x82ACB9E0;
	sub_82E59680(ctx, base);
	// 82ACB9E0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACB9E4: 396B9DA0  addi r11, r11, -0x6260
	ctx.r[11].s64 = ctx.r[11].s64 + -25184;
	// 82ACB9E8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACB9EC: 48000008  b 0x82acb9f4
	pc = 0x82ACB9F4; continue 'dispatch;
	// 82ACB9F0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ACB9F4: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ACB9F8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82ACB9FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACBA00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACBA04: 4BFFF705  bl 0x82acb108
	ctx.lr = 0x82ACBA08;
	sub_82ACB108(ctx, base);
	// 82ACBA08: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ACBA0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACBA10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACBA14: 4B7F45ED  bl 0x822c0000
	ctx.lr = 0x82ACBA18;
	sub_822C0000(ctx, base);
	// 82ACBA18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ACBA1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ACBA20: 486DC79C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACBA28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACBA28 size=124
    let mut pc: u32 = 0x82ACBA28;
    'dispatch: loop {
        match pc {
            0x82ACBA28 => {
    //   block [0x82ACBA28..0x82ACBAA4)
	// 82ACBA28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACBA2C: 486DC741  bl 0x831a816c
	ctx.lr = 0x82ACBA30;
	sub_831A8130(ctx, base);
	// 82ACBA30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACBA34: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82ACBA38: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ACBA3C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ACBA40: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82ACBA44: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82ACBA48: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82ACBA4C: 4832699D  bl 0x82df23e8
	ctx.lr = 0x82ACBA50;
	sub_82DF23E8(ctx, base);
	// 82ACBA50: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82ACBA54: 4182001C  beq 0x82acba70
	if ctx.cr[0].eq {
	pc = 0x82ACBA70; continue 'dispatch;
	}
	// 82ACBA58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACBA5C: 4838DC25  bl 0x82e59680
	ctx.lr = 0x82ACBA60;
	sub_82E59680(ctx, base);
	// 82ACBA60: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACBA64: 396B9DA8  addi r11, r11, -0x6258
	ctx.r[11].s64 = ctx.r[11].s64 + -25176;
	// 82ACBA68: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACBA6C: 48000008  b 0x82acba74
	pc = 0x82ACBA74; continue 'dispatch;
	// 82ACBA70: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ACBA74: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ACBA78: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82ACBA7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACBA80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACBA84: 4BFFF74D  bl 0x82acb1d0
	ctx.lr = 0x82ACBA88;
	sub_82ACB1D0(ctx, base);
	// 82ACBA88: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ACBA8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACBA90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACBA94: 4B7F456D  bl 0x822c0000
	ctx.lr = 0x82ACBA98;
	sub_822C0000(ctx, base);
	// 82ACBA98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ACBA9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ACBAA0: 486DC71C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACBAA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACBAA8 size=120
    let mut pc: u32 = 0x82ACBAA8;
    'dispatch: loop {
        match pc {
            0x82ACBAA8 => {
    //   block [0x82ACBAA8..0x82ACBB20)
	// 82ACBAA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACBAAC: 486DC6C1  bl 0x831a816c
	ctx.lr = 0x82ACBAB0;
	sub_831A8130(ctx, base);
	// 82ACBAB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACBAB4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82ACBAB8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ACBABC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ACBAC0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ACBAC4: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82ACBAC8: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82ACBACC: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 82ACBAD0: 48326919  bl 0x82df23e8
	ctx.lr = 0x82ACBAD4;
	sub_82DF23E8(ctx, base);
	// 82ACBAD4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACBAD8: 41820014  beq 0x82acbaec
	if ctx.cr[0].eq {
	pc = 0x82ACBAEC; continue 'dispatch;
	}
	// 82ACBADC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACBAE0: 4BFF0ED9  bl 0x82abc9b8
	ctx.lr = 0x82ACBAE4;
	sub_82ABC9B8(ctx, base);
	// 82ACBAE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACBAE8: 48000008  b 0x82acbaf0
	pc = 0x82ACBAF0; continue 'dispatch;
	// 82ACBAEC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ACBAF0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ACBAF4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82ACBAF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACBAFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACBB00: 4BFFF799  bl 0x82acb298
	ctx.lr = 0x82ACBB04;
	sub_82ACB298(ctx, base);
	// 82ACBB04: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ACBB08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACBB0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACBB10: 4B7F44F1  bl 0x822c0000
	ctx.lr = 0x82ACBB14;
	sub_822C0000(ctx, base);
	// 82ACBB14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ACBB18: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ACBB1C: 486DC6A0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACBB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACBB20 size=152
    let mut pc: u32 = 0x82ACBB20;
    'dispatch: loop {
        match pc {
            0x82ACBB20 => {
    //   block [0x82ACBB20..0x82ACBBB8)
	// 82ACBB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACBB24: 486DC649  bl 0x831a816c
	ctx.lr = 0x82ACBB28;
	sub_831A8130(ctx, base);
	// 82ACBB28: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82ACBB2C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82ACBB30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACBB34: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACBB38: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82ACBB3C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ACBB40: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82ACBB44: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82ACBB48: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ACBB4C: 388B9E70  addi r4, r11, -0x6190
	ctx.r[4].s64 = ctx.r[11].s64 + -24976;
	// 82ACBB50: 38A00065  li r5, 0x65
	ctx.r[5].s64 = 101;
	// 82ACBB54: 386001A0  li r3, 0x1a0
	ctx.r[3].s64 = 416;
	// 82ACBB58: 48326891  bl 0x82df23e8
	ctx.lr = 0x82ACBB5C;
	sub_82DF23E8(ctx, base);
	// 82ACBB5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACBB60: 4182001C  beq 0x82acbb7c
	if ctx.cr[0].eq {
	pc = 0x82ACBB7C; continue 'dispatch;
	}
	// 82ACBB64: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82ACBB68: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82ACBB6C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82ACBB70: 4BFFFB01  bl 0x82acb670
	ctx.lr = 0x82ACBB74;
	sub_82ACB670(ctx, base);
	// 82ACBB74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACBB78: 48000008  b 0x82acbb80
	pc = 0x82ACBB80; continue 'dispatch;
	// 82ACBB7C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ACBB80: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ACBB84: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82ACBB88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACBB8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACBB90: 4BFFF3E9  bl 0x82acaf78
	ctx.lr = 0x82ACBB94;
	sub_82ACAF78(ctx, base);
	// 82ACBB94: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ACBB98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACBB9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACBBA0: 4B7F4461  bl 0x822c0000
	ctx.lr = 0x82ACBBA4;
	sub_822C0000(ctx, base);
	// 82ACBBA4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ACBBA8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ACBBAC: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82ACBBB0: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82ACBBB4: 486DC608  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACBBB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACBBB8 size=296
    let mut pc: u32 = 0x82ACBBB8;
    'dispatch: loop {
        match pc {
            0x82ACBBB8 => {
    //   block [0x82ACBBB8..0x82ACBCE0)
	// 82ACBBB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACBBBC: 486DC5AD  bl 0x831a8168
	ctx.lr = 0x82ACBBC0;
	sub_831A8130(ctx, base);
	// 82ACBBC0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACBBC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACBBC8: 4BFE4E01  bl 0x82ab09c8
	ctx.lr = 0x82ACBBCC;
	sub_82AB09C8(ctx, base);
	// 82ACBBCC: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82ACBBD0: 41820108  beq 0x82acbcd8
	if ctx.cr[0].eq {
	pc = 0x82ACBCD8; continue 'dispatch;
	}
	// 82ACBBD4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACBBD8: 4BFFFD61  bl 0x82acb938
	ctx.lr = 0x82ACBBDC;
	sub_82ACB938(ctx, base);
	// 82ACBBDC: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ACBBE0: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ACBBE4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82ACBBE8: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82ACBBEC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82ACBBF0: 419A0024  beq cr6, 0x82acbc14
	if ctx.cr[6].eq {
	pc = 0x82ACBC14; continue 'dispatch;
	}
	// 82ACBBF4: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82ACBBF8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ACBBFC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACBC00: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ACBC04: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ACBC08: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ACBC0C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACBC10: 4082FFE8  bne 0x82acbbf8
	if !ctx.cr[0].eq {
	pc = 0x82ACBBF8; continue 'dispatch;
	}
	// 82ACBC14: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACBC18: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82ACBC1C: 388B9E70  addi r4, r11, -0x6190
	ctx.r[4].s64 = ctx.r[11].s64 + -24976;
	// 82ACBC20: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82ACBC24: 38A000AE  li r5, 0xae
	ctx.r[5].s64 = 174;
	// 82ACBC28: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82ACBC2C: 4838B3BD  bl 0x82e56fe8
	ctx.lr = 0x82ACBC30;
	sub_82E56FE8(ctx, base);
	// 82ACBC30: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82ACBC34: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82ACBC38: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 82ACBC3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACBC40: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82ACBC44: 557CDFFE  rlwinm r28, r11, 0x1b, 0x1f, 0x1f
	ctx.r[28].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82ACBC48: 419A0008  beq cr6, 0x82acbc50
	if ctx.cr[6].eq {
	pc = 0x82ACBC50; continue 'dispatch;
	}
	// 82ACBC4C: 4B7F4C45  bl 0x822c0890
	ctx.lr = 0x82ACBC50;
	sub_822C0890(ctx, base);
	// 82ACBC50: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACBC54: 40820074  bne 0x82acbcc8
	if !ctx.cr[0].eq {
	pc = 0x82ACBCC8; continue 'dispatch;
	}
	// 82ACBC58: 389D0020  addi r4, r29, 0x20
	ctx.r[4].s64 = ctx.r[29].s64 + 32;
	// 82ACBC5C: 39600100  li r11, 0x100
	ctx.r[11].s64 = 256;
	// 82ACBC60: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82ACBC64: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82ACBC68: 394A6910  addi r10, r10, 0x6910
	ctx.r[10].s64 = ctx.r[10].s64 + 26896;
	// 82ACBC6C: 13E020C7  vcmpequd (lvx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82ACBC70: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACBCE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACBCE0 size=220
    let mut pc: u32 = 0x82ACBCE0;
    'dispatch: loop {
        match pc {
            0x82ACBCE0 => {
    //   block [0x82ACBCE0..0x82ACBDBC)
	// 82ACBCE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACBCE4: 486DC489  bl 0x831a816c
	ctx.lr = 0x82ACBCE8;
	sub_831A8130(ctx, base);
	// 82ACBCE8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACBCEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACBCF0: 80840000  lwz r4, 0(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACBCF4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACBCF8: 4835EDF1  bl 0x82e2aae8
	ctx.lr = 0x82ACBCFC;
	sub_82E2AAE8(ctx, base);
	// 82ACBCFC: 817F0134  lwz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82ACBD00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACBD04: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACBD08: 48327D01  bl 0x82df3a08
	ctx.lr = 0x82ACBD0C;
	sub_82DF3A08(ctx, base);
	// 82ACBD0C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ACBD10: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ACBD14: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82ACBD18: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACBD1C: 48363155  bl 0x82e2ee70
	ctx.lr = 0x82ACBD20;
	sub_82E2EE70(ctx, base);
	// 82ACBD20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACBD24: 48327705  bl 0x82df3428
	ctx.lr = 0x82ACBD28;
	sub_82DF3428(ctx, base);
	// 82ACBD28: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACBD2C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ACBD30: 388B9E70  addi r4, r11, -0x6190
	ctx.r[4].s64 = ctx.r[11].s64 + -24976;
	// 82ACBD34: 38A000E5  li r5, 0xe5
	ctx.r[5].s64 = 229;
	// 82ACBD38: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82ACBD3C: 483266AD  bl 0x82df23e8
	ctx.lr = 0x82ACBD40;
	sub_82DF23E8(ctx, base);
	// 82ACBD40: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACBD44: 41820014  beq 0x82acbd58
	if ctx.cr[0].eq {
	pc = 0x82ACBD58; continue 'dispatch;
	}
	// 82ACBD48: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82ACBD4C: 4834AB45  bl 0x82e16890
	ctx.lr = 0x82ACBD50;
	sub_82E16890(ctx, base);
	// 82ACBD50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ACBD54: 48000008  b 0x82acbd5c
	pc = 0x82ACBD5C; continue 'dispatch;
	// 82ACBD58: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACBD5C: 3BDF0188  addi r30, r31, 0x188
	ctx.r[30].s64 = ctx.r[31].s64 + 392;
	// 82ACBD60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACBD64: 4B89160D  bl 0x8235d370
	ctx.lr = 0x82ACBD68;
	sub_8235D370(ctx, base);
	// 82ACBD68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACBD6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACBD70: 83BF0188  lwz r29, 0x188(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82ACBD74: 4BA463A5  bl 0x82512118
	ctx.lr = 0x82ACBD78;
	sub_82512118(ctx, base);
	// 82ACBD78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ACBD7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ACBD80: 48349331  bl 0x82e150b0
	ctx.lr = 0x82ACBD84;
	sub_82E150B0(ctx, base);
	// 82ACBD84: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ACBD88: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82ACBD8C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ACBD90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACBD94: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82ACBD98: 4BA44DC1  bl 0x82510b58
	ctx.lr = 0x82ACBD9C;
	sub_82510B58(ctx, base);
	// 82ACBD9C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ACBDA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACBDA4: 419A0008  beq cr6, 0x82acbdac
	if ctx.cr[6].eq {
	pc = 0x82ACBDAC; continue 'dispatch;
	}
	// 82ACBDA8: 4B7F4AE9  bl 0x822c0890
	ctx.lr = 0x82ACBDAC;
	sub_822C0890(ctx, base);
	// 82ACBDAC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACBDB0: 4835ED51  bl 0x82e2ab00
	ctx.lr = 0x82ACBDB4;
	sub_82E2AB00(ctx, base);
	// 82ACBDB4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82ACBDB8: 486DC404  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACBDC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACBDC0 size=216
    let mut pc: u32 = 0x82ACBDC0;
    'dispatch: loop {
        match pc {
            0x82ACBDC0 => {
    //   block [0x82ACBDC0..0x82ACBE98)
	// 82ACBDC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACBDC4: 486DC3A5  bl 0x831a8168
	ctx.lr = 0x82ACBDC8;
	sub_831A8130(ctx, base);
	// 82ACBDC8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACBDCC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ACBDD0: 4BFE4BF9  bl 0x82ab09c8
	ctx.lr = 0x82ACBDD4;
	sub_82AB09C8(ctx, base);
	// 82ACBDD4: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82ACBDD8: 4082000C  bne 0x82acbde4
	if !ctx.cr[0].eq {
	pc = 0x82ACBDE4; continue 'dispatch;
	}
	// 82ACBDDC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ACBDE0: 480000B0  b 0x82acbe90
	pc = 0x82ACBE90; continue 'dispatch;
	// 82ACBDE4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACBDE8: 4BFAFCD1  bl 0x82a7bab8
	ctx.lr = 0x82ACBDEC;
	sub_82A7BAB8(ctx, base);
	// 82ACBDEC: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ACBDF0: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ACBDF4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ACBDF8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82ACBDFC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82ACBE00: 419A0024  beq cr6, 0x82acbe24
	if ctx.cr[6].eq {
	pc = 0x82ACBE24; continue 'dispatch;
	}
	// 82ACBE04: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82ACBE08: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ACBE0C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACBE10: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ACBE14: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ACBE18: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ACBE1C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACBE20: 4082FFE8  bne 0x82acbe08
	if !ctx.cr[0].eq {
	pc = 0x82ACBE08; continue 'dispatch;
	}
	// 82ACBE24: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACBE28: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82ACBE2C: 388B9E70  addi r4, r11, -0x6190
	ctx.r[4].s64 = ctx.r[11].s64 + -24976;
	// 82ACBE30: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82ACBE34: 38A000FA  li r5, 0xfa
	ctx.r[5].s64 = 250;
	// 82ACBE38: 387D0028  addi r3, r29, 0x28
	ctx.r[3].s64 = ctx.r[29].s64 + 40;
	// 82ACBE3C: 4838B1AD  bl 0x82e56fe8
	ctx.lr = 0x82ACBE40;
	sub_82E56FE8(ctx, base);
	// 82ACBE40: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82ACBE44: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82ACBE48: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 82ACBE4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACBE50: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82ACBE54: 557EDFFE  rlwinm r30, r11, 0x1b, 0x1f, 0x1f
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82ACBE58: 419A0008  beq cr6, 0x82acbe60
	if ctx.cr[6].eq {
	pc = 0x82ACBE60; continue 'dispatch;
	}
	// 82ACBE5C: 4B7F4A35  bl 0x822c0890
	ctx.lr = 0x82ACBE60;
	sub_822C0890(ctx, base);
	// 82ACBE60: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACBE64: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ACBE68: 41820014  beq 0x82acbe7c
	if ctx.cr[0].eq {
	pc = 0x82ACBE7C; continue 'dispatch;
	}
	// 82ACBE6C: 419AFF70  beq cr6, 0x82acbddc
	if ctx.cr[6].eq {
	pc = 0x82ACBDDC; continue 'dispatch;
	}
	// 82ACBE70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACBE74: 4B7F4A1D  bl 0x822c0890
	ctx.lr = 0x82ACBE78;
	sub_822C0890(ctx, base);
	// 82ACBE78: 4BFFFF64  b 0x82acbddc
	pc = 0x82ACBDDC; continue 'dispatch;
	// 82ACBE7C: 8BDC0018  lbz r30, 0x18(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ACBE80: 419A000C  beq cr6, 0x82acbe8c
	if ctx.cr[6].eq {
	pc = 0x82ACBE8C; continue 'dispatch;
	}
	// 82ACBE84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACBE88: 4B7F4A09  bl 0x822c0890
	ctx.lr = 0x82ACBE8C;
	sub_822C0890(ctx, base);
	// 82ACBE8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACBE90: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82ACBE94: 486DC324  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACBE98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACBE98 size=188
    let mut pc: u32 = 0x82ACBE98;
    'dispatch: loop {
        match pc {
            0x82ACBE98 => {
    //   block [0x82ACBE98..0x82ACBF54)
	// 82ACBE98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACBE9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACBEA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACBEA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACBEA8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACBEAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACBEB0: 4BFE4B19  bl 0x82ab09c8
	ctx.lr = 0x82ACBEB4;
	sub_82AB09C8(ctx, base);
	// 82ACBEB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACBEB8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACBEBC: 4BFFFAED  bl 0x82acb9a8
	ctx.lr = 0x82ACBEC0;
	sub_82ACB9A8(ctx, base);
	// 82ACBEC0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACBEC4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82ACBEC8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ACBECC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACBED0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ACBED4: 419A0024  beq cr6, 0x82acbef8
	if ctx.cr[6].eq {
	pc = 0x82ACBEF8; continue 'dispatch;
	}
	// 82ACBED8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ACBEDC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ACBEE0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACBEE4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ACBEE8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ACBEEC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ACBEF0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACBEF4: 4082FFE8  bne 0x82acbedc
	if !ctx.cr[0].eq {
	pc = 0x82ACBEDC; continue 'dispatch;
	}
	// 82ACBEF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ACBEFC: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ACBF00: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82ACBF04: 388A9E70  addi r4, r10, -0x6190
	ctx.r[4].s64 = ctx.r[10].s64 + -24976;
	// 82ACBF08: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82ACBF0C: 38A0010A  li r5, 0x10a
	ctx.r[5].s64 = 266;
	// 82ACBF10: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACBF14: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82ACBF18: 4838CB29  bl 0x82e58a40
	ctx.lr = 0x82ACBF1C;
	sub_82E58A40(ctx, base);
	// 82ACBF1C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82ACBF20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACBF24: 419A0008  beq cr6, 0x82acbf2c
	if ctx.cr[6].eq {
	pc = 0x82ACBF2C; continue 'dispatch;
	}
	// 82ACBF28: 4B7F4969  bl 0x822c0890
	ctx.lr = 0x82ACBF2C;
	sub_822C0890(ctx, base);
	// 82ACBF2C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ACBF30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACBF34: 419A0008  beq cr6, 0x82acbf3c
	if ctx.cr[6].eq {
	pc = 0x82ACBF3C; continue 'dispatch;
	}
	// 82ACBF38: 4B7F4959  bl 0x822c0890
	ctx.lr = 0x82ACBF3C;
	sub_822C0890(ctx, base);
	// 82ACBF3C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ACBF40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACBF44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACBF48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ACBF4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACBF50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACBF58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACBF58 size=196
    let mut pc: u32 = 0x82ACBF58;
    'dispatch: loop {
        match pc {
            0x82ACBF58 => {
    //   block [0x82ACBF58..0x82ACC01C)
	// 82ACBF58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACBF5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACBF60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACBF64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACBF68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACBF6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACBF70: 4BFE4A59  bl 0x82ab09c8
	ctx.lr = 0x82ACBF74;
	sub_82AB09C8(ctx, base);
	// 82ACBF74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACBF78: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACBF7C: 4BFFFAAD  bl 0x82acba28
	ctx.lr = 0x82ACBF80;
	sub_82ACBA28(ctx, base);
	// 82ACBF80: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACBF84: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82ACBF88: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ACBF8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACBF90: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ACBF94: 419A0024  beq cr6, 0x82acbfb8
	if ctx.cr[6].eq {
	pc = 0x82ACBFB8; continue 'dispatch;
	}
	// 82ACBF98: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ACBF9C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ACBFA0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACBFA4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ACBFA8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ACBFAC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ACBFB0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACBFB4: 4082FFE8  bne 0x82acbf9c
	if !ctx.cr[0].eq {
	pc = 0x82ACBF9C; continue 'dispatch;
	}
	// 82ACBFB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ACBFBC: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ACBFC0: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82ACBFC4: 388A9E70  addi r4, r10, -0x6190
	ctx.r[4].s64 = ctx.r[10].s64 + -24976;
	// 82ACBFC8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82ACBFCC: 38A00115  li r5, 0x115
	ctx.r[5].s64 = 277;
	// 82ACBFD0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACBFD4: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82ACBFD8: 4838CA69  bl 0x82e58a40
	ctx.lr = 0x82ACBFDC;
	sub_82E58A40(ctx, base);
	// 82ACBFDC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82ACBFE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACBFE4: 419A0008  beq cr6, 0x82acbfec
	if ctx.cr[6].eq {
	pc = 0x82ACBFEC; continue 'dispatch;
	}
	// 82ACBFE8: 4B7F48A9  bl 0x822c0890
	ctx.lr = 0x82ACBFEC;
	sub_822C0890(ctx, base);
	// 82ACBFEC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ACBFF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACBFF4: 419A0008  beq cr6, 0x82acbffc
	if ctx.cr[6].eq {
	pc = 0x82ACBFFC; continue 'dispatch;
	}
	// 82ACBFF8: 4B7F4899  bl 0x822c0890
	ctx.lr = 0x82ACBFFC;
	sub_822C0890(ctx, base);
	// 82ACBFFC: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 82ACC000: 917E00E4  stw r11, 0xe4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82ACC004: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ACC008: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACC00C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACC010: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ACC014: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACC018: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACC020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACC020 size=276
    let mut pc: u32 = 0x82ACC020;
    'dispatch: loop {
        match pc {
            0x82ACC020 => {
    //   block [0x82ACC020..0x82ACC134)
	// 82ACC020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACC024: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACC028: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACC02C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACC030: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACC034: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 82ACC038: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACC03C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82ACC040: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ACC044: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82ACC048: 4B851189  bl 0x8231d1d0
	ctx.lr = 0x82ACC04C;
	sub_8231D1D0(ctx, base);
	// 82ACC04C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACC050: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82ACC054: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ACC058: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACC05C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82ACC060: 419A0024  beq cr6, 0x82acc084
	if ctx.cr[6].eq {
	pc = 0x82ACC084; continue 'dispatch;
	}
	// 82ACC064: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ACC068: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ACC06C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACC070: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ACC074: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ACC078: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ACC07C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACC080: 4082FFE8  bne 0x82acc068
	if !ctx.cr[0].eq {
	pc = 0x82ACC068; continue 'dispatch;
	}
	// 82ACC084: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACC088: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACC08C: 4BA4343D  bl 0x8250f4c8
	ctx.lr = 0x82ACC090;
	sub_8250F4C8(ctx, base);
	// 82ACC090: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACC094: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACC098: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82ACC09C: 409A0008  bne cr6, 0x82acc0a4
	if !ctx.cr[6].eq {
	pc = 0x82ACC0A4; continue 'dispatch;
	}
	// 82ACC0A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ACC0A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACC0A8: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82ACC0AC: 4BA3C96D  bl 0x82508a18
	ctx.lr = 0x82ACC0B0;
	sub_82508A18(ctx, base);
	// 82ACC0B0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACC0B4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82ACC0B8: 388B9E70  addi r4, r11, -0x6190
	ctx.r[4].s64 = ctx.r[11].s64 + -24976;
	// 82ACC0BC: 38A001D0  li r5, 0x1d0
	ctx.r[5].s64 = 464;
	// 82ACC0C0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82ACC0C4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82ACC0C8: 4838AF21  bl 0x82e56fe8
	ctx.lr = 0x82ACC0CC;
	sub_82E56FE8(ctx, base);
	// 82ACC0CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACC0D0: 48325BC1  bl 0x82df1c90
	ctx.lr = 0x82ACC0D4;
	sub_82DF1C90(ctx, base);
	// 82ACC0D4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ACC0D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACC0DC: 419A0008  beq cr6, 0x82acc0e4
	if ctx.cr[6].eq {
	pc = 0x82ACC0E4; continue 'dispatch;
	}
	// 82ACC0E0: 4B7F47B1  bl 0x822c0890
	ctx.lr = 0x82ACC0E4;
	sub_822C0890(ctx, base);
	// 82ACC0E4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ACC0E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACC0EC: 419A0008  beq cr6, 0x82acc0f4
	if ctx.cr[6].eq {
	pc = 0x82ACC0F4; continue 'dispatch;
	}
	// 82ACC0F0: 4B7F47A1  bl 0x822c0890
	ctx.lr = 0x82ACC0F4;
	sub_822C0890(ctx, base);
	// 82ACC0F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACC0F8: 4BA459F1  bl 0x82511ae8
	ctx.lr = 0x82ACC0FC;
	sub_82511AE8(ctx, base);
	// 82ACC0FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ACC100: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82ACC104: 483B1425  bl 0x82e7d528
	ctx.lr = 0x82ACC108;
	sub_82E7D528(ctx, base);
	// 82ACC108: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 82ACC10C: 387F0120  addi r3, r31, 0x120
	ctx.r[3].s64 = ctx.r[31].s64 + 288;
	// 82ACC110: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACC138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ACC138 size=560
    let mut pc: u32 = 0x82ACC138;
    'dispatch: loop {
        match pc {
            0x82ACC138 => {
    //   block [0x82ACC138..0x82ACC368)
	// 82ACC138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACC13C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACC140: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACC144: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACC148: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82ACC14C: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACC368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACC368 size=300
    let mut pc: u32 = 0x82ACC368;
    'dispatch: loop {
        match pc {
            0x82ACC368 => {
    //   block [0x82ACC368..0x82ACC494)
	// 82ACC368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACC36C: 486DBDFD  bl 0x831a8168
	ctx.lr = 0x82ACC370;
	sub_831A8130(ctx, base);
	// 82ACC370: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACC374: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACC378: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ACC37C: 4BA4590D  bl 0x82511c88
	ctx.lr = 0x82ACC380;
	sub_82511C88(ctx, base);
	// 82ACC380: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ACC384: 38BF0188  addi r5, r31, 0x188
	ctx.r[5].s64 = ctx.r[31].s64 + 392;
	// 82ACC388: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACC38C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82ACC390: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82ACC394: 4BA43E5D  bl 0x825101f0
	ctx.lr = 0x82ACC398;
	sub_825101F0(ctx, base);
	// 82ACC398: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACC39C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACC3A0: 4BA43129  bl 0x8250f4c8
	ctx.lr = 0x82ACC3A4;
	sub_8250F4C8(ctx, base);
	// 82ACC3A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACC3A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACC3AC: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82ACC3B0: 409A0008  bne cr6, 0x82acc3b8
	if !ctx.cr[6].eq {
	pc = 0x82ACC3B8; continue 'dispatch;
	}
	// 82ACC3B4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACC3B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACC3BC: 4BA3E595  bl 0x8250a950
	ctx.lr = 0x82ACC3C0;
	sub_8250A950(ctx, base);
	// 82ACC3C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACC3C4: 483258CD  bl 0x82df1c90
	ctx.lr = 0x82ACC3C8;
	sub_82DF1C90(ctx, base);
	// 82ACC3C8: 817F0134  lwz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82ACC3CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACC3D0: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ACC3D4: 48327635  bl 0x82df3a08
	ctx.lr = 0x82ACC3D8;
	sub_82DF3A08(ctx, base);
	// 82ACC3D8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ACC3DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACC3E0: 3BCBFF40  addi r30, r11, -0xc0
	ctx.r[30].s64 = ctx.r[11].s64 + -192;
	// 82ACC3E4: 409A0008  bne cr6, 0x82acc3ec
	if !ctx.cr[6].eq {
	pc = 0x82ACC3EC; continue 'dispatch;
	}
	// 82ACC3E8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ACC3EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACC3F0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82ACC3F4: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 82ACC3F8: 4BA45D21  bl 0x82512118
	ctx.lr = 0x82ACC3FC;
	sub_82512118(ctx, base);
	// 82ACC3FC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82ACC400: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ACC404: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82ACC408: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82ACC40C: 38E0000B  li r7, 0xb
	ctx.r[7].s64 = 11;
	// 82ACC410: 4BD088A1  bl 0x827d4cb0
	ctx.lr = 0x82ACC414;
	sub_827D4CB0(ctx, base);
	// 82ACC414: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ACC418: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACC41C: 419A0008  beq cr6, 0x82acc424
	if ctx.cr[6].eq {
	pc = 0x82ACC424; continue 'dispatch;
	}
	// 82ACC420: 4B7F4471  bl 0x822c0890
	ctx.lr = 0x82ACC424;
	sub_822C0890(ctx, base);
	// 82ACC424: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82ACC428: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACC42C: 419A0008  beq cr6, 0x82acc434
	if ctx.cr[6].eq {
	pc = 0x82ACC434; continue 'dispatch;
	}
	// 82ACC430: 4B7F4461  bl 0x822c0890
	ctx.lr = 0x82ACC434;
	sub_822C0890(ctx, base);
	// 82ACC434: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACC438: 48326FF1  bl 0x82df3428
	ctx.lr = 0x82ACC43C;
	sub_82DF3428(ctx, base);
	// 82ACC43C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACC440: 48325851  bl 0x82df1c90
	ctx.lr = 0x82ACC444;
	sub_82DF1C90(ctx, base);
	// 82ACC444: 809F0180  lwz r4, 0x180(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82ACC448: 807F0178  lwz r3, 0x178(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) } as u64;
	// 82ACC44C: 4800E675  bl 0x82adaac0
	ctx.lr = 0x82ACC450;
	sub_82ADAAC0(ctx, base);
	// 82ACC450: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACC454: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 82ACC458: 41820008  beq 0x82acc460
	if ctx.cr[0].eq {
	pc = 0x82ACC460; continue 'dispatch;
	}
	// 82ACC45C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ACC460: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACC464: 4BA45685  bl 0x82511ae8
	ctx.lr = 0x82ACC468;
	sub_82511AE8(ctx, base);
	// 82ACC468: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82ACC46C: 38800018  li r4, 0x18
	ctx.r[4].s64 = 24;
	// 82ACC470: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACC474: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82ACC478: 4BFFE9E1  bl 0x82acae58
	ctx.lr = 0x82ACC47C;
	sub_82ACAE58(ctx, base);
	// 82ACC47C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACC480: 4BFFFAD9  bl 0x82acbf58
	ctx.lr = 0x82ACC484;
	sub_82ACBF58(ctx, base);
	// 82ACC484: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ACC488: 997F0130  stb r11, 0x130(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u8 ) };
	// 82ACC48C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82ACC490: 486DBD28  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACC498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACC498 size=112
    let mut pc: u32 = 0x82ACC498;
    'dispatch: loop {
        match pc {
            0x82ACC498 => {
    //   block [0x82ACC498..0x82ACC508)
	// 82ACC498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACC49C: 486DBCD1  bl 0x831a816c
	ctx.lr = 0x82ACC4A0;
	sub_831A8130(ctx, base);
	// 82ACC4A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACC4A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACC4A8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82ACC4AC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82ACC4B0: 4BA45529  bl 0x825119d8
	ctx.lr = 0x82ACC4B4;
	sub_825119D8(ctx, base);
	// 82ACC4B4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82ACC4B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACC4BC: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82ACC4C0: 48327549  bl 0x82df3a08
	ctx.lr = 0x82ACC4C4;
	sub_82DF3A08(ctx, base);
	// 82ACC4C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ACC4C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ACC4CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACC4D0: 4BA3C2B1  bl 0x82508780
	ctx.lr = 0x82ACC4D4;
	sub_82508780(ctx, base);
	// 82ACC4D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACC4D8: 48326F51  bl 0x82df3428
	ctx.lr = 0x82ACC4DC;
	sub_82DF3428(ctx, base);
	// 82ACC4DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ACC4E0: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82ACC4E4: 409A0008  bne cr6, 0x82acc4ec
	if !ctx.cr[6].eq {
	pc = 0x82ACC4EC; continue 'dispatch;
	}
	// 82ACC4E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACC4EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACC4F0: 4BA3C2B1  bl 0x825087a0
	ctx.lr = 0x82ACC4F4;
	sub_825087A0(ctx, base);
	// 82ACC4F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ACC4F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACC4FC: 4BFFF7E5  bl 0x82acbce0
	ctx.lr = 0x82ACC500;
	sub_82ACBCE0(ctx, base);
	// 82ACC500: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ACC504: 486DBCB8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACC508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACC508 size=780
    let mut pc: u32 = 0x82ACC508;
    'dispatch: loop {
        match pc {
            0x82ACC508 => {
    //   block [0x82ACC508..0x82ACC814)
	// 82ACC508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACC50C: 486DBC59  bl 0x831a8164
	ctx.lr = 0x82ACC510;
	sub_831A8130(ctx, base);
	// 82ACC510: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82ACC514: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACC518: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACC51C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82ACC520: 4BA441E9  bl 0x82510708
	ctx.lr = 0x82ACC524;
	sub_82510708(ctx, base);
	// 82ACC524: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82ACC528: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 82ACC52C: 40980020  bge cr6, 0x82acc54c
	if !ctx.cr[6].lt {
	pc = 0x82ACC54C; continue 'dispatch;
	}
	// 82ACC530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACC534: 4BFFF88D  bl 0x82acbdc0
	ctx.lr = 0x82ACC538;
	sub_82ACBDC0(ctx, base);
	// 82ACC538: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACC53C: 41820010  beq 0x82acc54c
	if ctx.cr[0].eq {
	pc = 0x82ACC54C; continue 'dispatch;
	}
	// 82ACC540: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACC544: 4BFFFA15  bl 0x82acbf58
	ctx.lr = 0x82ACC548;
	sub_82ACBF58(ctx, base);
	// 82ACC548: 48000018  b 0x82acc560
	pc = 0x82ACC560; continue 'dispatch;
	// 82ACC54C: 897F0174  lbz r11, 0x174(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 82ACC550: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACC554: 4082000C  bne 0x82acc560
	if !ctx.cr[0].eq {
	pc = 0x82ACC560; continue 'dispatch;
	}
	// 82ACC558: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACC55C: 4BFFF65D  bl 0x82acbbb8
	ctx.lr = 0x82ACC560;
	sub_82ACBBB8(ctx, base);
	// 82ACC560: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ACC564: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82ACC568: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 82ACC56C: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ACC570: 41990230  bgt cr6, 0x82acc7a0
	if ctx.cr[6].gt {
	pc = 0x82ACC7A0; continue 'dispatch;
	}
	// 82ACC574: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ACC578: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82ACC57C: 3BCA9D80  addi r30, r10, -0x6280
	ctx.r[30].s64 = ctx.r[10].s64 + -25216;
	// 82ACC580: 3D80820C  lis r12, -0x7df4
	ctx.r[12].s64 = -2113142784;
	// 82ACC584: 398C9D90  addi r12, r12, -0x6270
	ctx.r[12].s64 = ctx.r[12].s64 + -25200;
	// 82ACC588: 7C0C58AE  lbzx r0, r12, r11
	ctx.r[0].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ACC58C: 5400103A  slwi r0, r0, 2
	ctx.r[0].u32 = ctx.r[0].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82ACC590: 3D8082AD  lis r12, -0x7d53
	ctx.r[12].s64 = -2102591488;
	// 82ACC594: 398CC5A8  addi r12, r12, -0x3a58
	ctx.r[12].s64 = ctx.r[12].s64 + -14936;
	// 82ACC598: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 82ACC59C: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 82ACC5A0: 60000000  nop
	// 82ACC5A4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
	// 82ACC5A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACC5AC: 4BFFF8ED  bl 0x82acbe98
	ctx.lr = 0x82ACC5B0;
	sub_82ACBE98(ctx, base);
	// 82ACC5B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACC5B4: 4BFFEFFD  bl 0x82acb5b0
	ctx.lr = 0x82ACC5B8;
	sub_82ACB5B0(ctx, base);
	// 82ACC5B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACC5BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACC5C0: 4BA43581  bl 0x8250fb40
	ctx.lr = 0x82ACC5C4;
	sub_8250FB40(ctx, base);
	// 82ACC5C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ACC5C8: 480001D4  b 0x82acc79c
	pc = 0x82ACC79C; continue 'dispatch;
	// 82ACC5CC: C01F0140  lfs f0, 0x140(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACC5D0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82ACC5D4: 40990014  ble cr6, 0x82acc5e8
	if !ctx.cr[6].gt {
	pc = 0x82ACC5E8; continue 'dispatch;
	}
	// 82ACC5D8: C1BC0000  lfs f13, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACC5DC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ACC5E0: D01F0140  stfs f0, 0x140(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 82ACC5E4: 480001BC  b 0x82acc7a0
	pc = 0x82ACC7A0; continue 'dispatch;
	// 82ACC5E8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACC5EC: 9BBF0175  stb r29, 0x175(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(373 as u32), ctx.r[29].u8 ) };
	// 82ACC5F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACC5F4: 3BCB9D80  addi r30, r11, -0x6280
	ctx.r[30].s64 = ctx.r[11].s64 + -25216;
	// 82ACC5F8: C01EFFF4  lfs f0, -0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACC5FC: D01F0140  stfs f0, 0x140(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 82ACC600: 4BFFE721  bl 0x82acad20
	ctx.lr = 0x82ACC604;
	sub_82ACAD20(ctx, base);
	// 82ACC604: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82ACC608: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82ACC60C: C01F0140  lfs f0, 0x140(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACC610: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82ACC614: 4199FFC4  bgt cr6, 0x82acc5d8
	if ctx.cr[6].gt {
	pc = 0x82ACC5D8; continue 'dispatch;
	}
	// 82ACC618: D3FF0140  stfs f31, 0x140(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 82ACC61C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ACC620: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACC624: 4BA4351D  bl 0x8250fb40
	ctx.lr = 0x82ACC628;
	sub_8250FB40(ctx, base);
	// 82ACC628: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACC62C: 4BFFEE6D  bl 0x82acb498
	ctx.lr = 0x82ACC630;
	sub_82ACB498(ctx, base);
	// 82ACC630: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82ACC634: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82ACC638: 3F608200  lis r27, -0x7e00
	ctx.r[27].s64 = -2113929216;
	// 82ACC63C: C07EFFD8  lfs f3, -0x28(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-40 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82ACC640: C05F00F4  lfs f2, 0xf4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82ACC644: C03F0138  lfs f1, 0x138(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACC648: C09B08A8  lfs f4, 0x8a8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(2216 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82ACC64C: 4BFE1FED  bl 0x82aae638
	ctx.lr = 0x82ACC650;
	sub_82AAE638(ctx, base);
	// 82ACC650: C1BF00F4  lfs f13, 0xf4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACC654: C01B08A8  lfs f0, 0x8a8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACC658: EDAD082A  fadds f13, f13, f1
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[1].f64) as f32) as f64;
	// 82ACC65C: D1BF00F4  stfs f13, 0xf4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82ACC660: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82ACC664: 4199013C  bgt cr6, 0x82acc7a0
	if ctx.cr[6].gt {
	pc = 0x82ACC7A0; continue 'dispatch;
	}
	// 82ACC668: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82ACC66C: 9BBF013C  stb r29, 0x13c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[29].u8 ) };
	// 82ACC670: 4800012C  b 0x82acc79c
	pc = 0x82ACC79C; continue 'dispatch;
	// 82ACC674: C01F0140  lfs f0, 0x140(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACC678: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82ACC67C: 4199FF5C  bgt cr6, 0x82acc5d8
	if ctx.cr[6].gt {
	pc = 0x82ACC5D8; continue 'dispatch;
	}
	// 82ACC680: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACC684: 83BF0178  lwz r29, 0x178(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) } as u64;
	// 82ACC688: 4BA45461  bl 0x82511ae8
	ctx.lr = 0x82ACC68C;
	sub_82511AE8(ctx, base);
	// 82ACC68C: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82ACC690: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82ACC694: C05E0000  lfs f2, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82ACC698: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82ACC69C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ACC6A0: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82ACC6A4: C02B4430  lfs f1, 0x4430(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17456 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACC6A8: 4800E549  bl 0x82adabf0
	ctx.lr = 0x82ACC6AC;
	sub_82ADABF0(ctx, base);
	// 82ACC6AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACC6B0: 4BFFF971  bl 0x82acc020
	ctx.lr = 0x82ACC6B4;
	sub_82ACC020(ctx, base);
	// 82ACC6B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ACC6B8: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 82ACC6BC: D3FF0140  stfs f31, 0x140(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 82ACC6C0: 997F0174  stb r11, 0x174(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[11].u8 ) };
	// 82ACC6C4: 915F00E4  stw r10, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[10].u32 ) };
	// 82ACC6C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACC6CC: C03C0000  lfs f1, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACC6D0: 4BFFE521  bl 0x82acabf0
	ctx.lr = 0x82ACC6D4;
	sub_82ACABF0(ctx, base);
	// 82ACC6D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACC6D8: 4BA45411  bl 0x82511ae8
	ctx.lr = 0x82ACC6DC;
	sub_82511AE8(ctx, base);
	// 82ACC6DC: 39600100  li r11, 0x100
	ctx.r[11].s64 = 256;
	// 82ACC6E0: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82ACC6E4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82ACC6E8: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACC818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACC818 size=728
    let mut pc: u32 = 0x82ACC818;
    'dispatch: loop {
        match pc {
            0x82ACC818 => {
    //   block [0x82ACC818..0x82ACCAF0)
	// 82ACC818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACC81C: 486DB949  bl 0x831a8164
	ctx.lr = 0x82ACC820;
	sub_831A8130(ctx, base);
	// 82ACC820: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACC824: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACC828: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ACC82C: 897E0130  lbz r11, 0x130(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(304 as u32) ) } as u64;
	// 82ACC830: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACC834: 408202B4  bne 0x82accae8
	if !ctx.cr[0].eq {
	pc = 0x82ACCAE8; continue 'dispatch;
	}
	// 82ACC838: 897E0175  lbz r11, 0x175(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(373 as u32) ) } as u64;
	// 82ACC83C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACC840: 418202A8  beq 0x82accae8
	if ctx.cr[0].eq {
	pc = 0x82ACCAE8; continue 'dispatch;
	}
	// 82ACC844: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82ACC848: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ACC84C: 816BE664  lwz r11, -0x199c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6556 as u32) ) } as u64;
	// 82ACC850: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ACC854: 409A0294  bne cr6, 0x82accae8
	if !ctx.cr[6].eq {
	pc = 0x82ACCAE8; continue 'dispatch;
	}
	// 82ACC858: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82ACC85C: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 82ACC860: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82ACC864: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ACC868: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82ACC86C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82ACC870: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACCAF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ACCAF0 size=12
    let mut pc: u32 = 0x82ACCAF0;
    'dispatch: loop {
        match pc {
            0x82ACCAF0 => {
    //   block [0x82ACCAF0..0x82ACCAFC)
	// 82ACCAF0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82ACCAF4: 806BE66C  lwz r3, -0x1994(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6548 as u32) ) } as u64;
	// 82ACCAF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACCB00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACCB00 size=60
    let mut pc: u32 = 0x82ACCB00;
    'dispatch: loop {
        match pc {
            0x82ACCB00 => {
    //   block [0x82ACCB00..0x82ACCB3C)
	// 82ACCB00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACCB04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACCB08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACCB0C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACCB10: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ACCB14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACCB18: 483898B1  bl 0x82e563c8
	ctx.lr = 0x82ACCB1C;
	sub_82E563C8(ctx, base);
	// 82ACCB1C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACCB20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACCB24: 4BA4301D  bl 0x8250fb40
	ctx.lr = 0x82ACCB28;
	sub_8250FB40(ctx, base);
	// 82ACCB28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ACCB2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACCB30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACCB34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACCB38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACCB40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACCB40 size=136
    let mut pc: u32 = 0x82ACCB40;
    'dispatch: loop {
        match pc {
            0x82ACCB40 => {
    //   block [0x82ACCB40..0x82ACCBC8)
	// 82ACCB40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACCB44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACCB48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACCB4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACCB50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACCB54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACCB58: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ACCB5C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82ACCB60: 409A0020  bne cr6, 0x82accb80
	if !ctx.cr[6].eq {
	pc = 0x82ACCB80; continue 'dispatch;
	}
	// 82ACCB64: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ACCB68: 419A0048  beq cr6, 0x82accbb0
	if ctx.cr[6].eq {
	pc = 0x82ACCBB0; continue 'dispatch;
	}
	// 82ACCB6C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82ACCB70: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82ACCB74: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 82ACCB78: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82ACCB7C: 48000034  b 0x82accbb0
	pc = 0x82ACCBB0; continue 'dispatch;
	// 82ACCB80: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82ACCB84: 419A002C  beq cr6, 0x82accbb0
	if ctx.cr[6].eq {
	pc = 0x82ACCBB0; continue 'dispatch;
	}
	// 82ACCB88: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ACCB8C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACCB90: 388B0868  addi r4, r11, 0x868
	ctx.r[4].s64 = ctx.r[11].s64 + 2152;
	// 82ACCB94: 486DB565  bl 0x831a80f8
	ctx.lr = 0x82ACCB98;
	sub_831A80F8(ctx, base);
	// 82ACCB98: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACCB9C: 4182000C  beq 0x82accba8
	if ctx.cr[0].eq {
	pc = 0x82ACCBA8; continue 'dispatch;
	}
	// 82ACCBA0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82ACCBA4: 4800000C  b 0x82accbb0
	pc = 0x82ACCBB0; continue 'dispatch;
	// 82ACCBA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACCBAC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACCBB0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ACCBB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACCBB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACCBBC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ACCBC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACCBC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACCBC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACCBC8 size=124
    let mut pc: u32 = 0x82ACCBC8;
    'dispatch: loop {
        match pc {
            0x82ACCBC8 => {
    //   block [0x82ACCBC8..0x82ACCC44)
	// 82ACCBC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACCBCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACCBD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACCBD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACCBD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACCBDC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ACCBE0: 809F0124  lwz r4, 0x124(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 82ACCBE4: 997F0100  stb r11, 0x100(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u8 ) };
	// 82ACCBE8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82ACCBEC: 419A0014  beq cr6, 0x82accc00
	if ctx.cr[6].eq {
	pc = 0x82ACCC00; continue 'dispatch;
	}
	// 82ACCBF0: 807F0138  lwz r3, 0x138(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82ACCBF4: 4800DECD  bl 0x82adaac0
	ctx.lr = 0x82ACCBF8;
	sub_82ADAAC0(ctx, base);
	// 82ACCBF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACCBFC: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 82ACCC00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACCC04: 83FF0138  lwz r31, 0x138(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82ACCC08: 4BA44EE1  bl 0x82511ae8
	ctx.lr = 0x82ACCC0C;
	sub_82511AE8(ctx, base);
	// 82ACCC0C: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82ACCC10: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82ACCC14: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82ACCC18: 38800019  li r4, 0x19
	ctx.r[4].s64 = 25;
	// 82ACCC1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACCC20: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82ACCC24: C02B4430  lfs f1, 0x4430(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17456 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACCC28: C04A6218  lfs f2, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82ACCC2C: 4800DFC5  bl 0x82adabf0
	ctx.lr = 0x82ACCC30;
	sub_82ADABF0(ctx, base);
	// 82ACCC30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ACCC34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACCC38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACCC3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACCC40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACCC48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACCC48 size=128
    let mut pc: u32 = 0x82ACCC48;
    'dispatch: loop {
        match pc {
            0x82ACCC48 => {
    //   block [0x82ACCC48..0x82ACCCC8)
	// 82ACCC48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACCC4C: 486DB51D  bl 0x831a8168
	ctx.lr = 0x82ACCC50;
	sub_831A8130(ctx, base);
	// 82ACCC50: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82ACCC54: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACCC58: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82ACCC5C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82ACCC60: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 82ACCC64: 3BDC0140  addi r30, r28, 0x140
	ctx.r[30].s64 = ctx.r[28].s64 + 320;
	// 82ACCC68: 3BFC0150  addi r31, r28, 0x150
	ctx.r[31].s64 = ctx.r[28].s64 + 336;
	// 82ACCC6C: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACCC70: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82ACCC74: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82ACCC78: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACCC7C: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82ACCC80: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACCC84: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ACCC88: 4198000C  blt cr6, 0x82accc94
	if ctx.cr[6].lt {
	pc = 0x82ACCC94; continue 'dispatch;
	}
	// 82ACCC8C: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ACCC90: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82ACCC94: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACCC98: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACCC9C: 807C0130  lwz r3, 0x130(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(304 as u32) ) } as u64;
	// 82ACCCA0: C1A4001C  lfs f13, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACCCA4: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ACCCA8: 48371B91  bl 0x82e3e838
	ctx.lr = 0x82ACCCAC;
	sub_82E3E838(ctx, base);
	// 82ACCCAC: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82ACCCB0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82ACCCB4: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82ACCCB8: 4082FFB4  bne 0x82accc6c
	if !ctx.cr[0].eq {
	pc = 0x82ACCC6C; continue 'dispatch;
	}
	// 82ACCCBC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ACCCC0: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82ACCCC4: 486DB4F4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACCCC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACCCC8 size=164
    let mut pc: u32 = 0x82ACCCC8;
    'dispatch: loop {
        match pc {
            0x82ACCCC8 => {
    //   block [0x82ACCCC8..0x82ACCD6C)
	// 82ACCCC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACCCCC: 486DB49D  bl 0x831a8168
	ctx.lr = 0x82ACCCD0;
	sub_831A8130(ctx, base);
	// 82ACCCD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACCCD4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82ACCCD8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACCCDC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ACCCE0: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82ACCCE4: 41820038  beq 0x82accd1c
	if ctx.cr[0].eq {
	pc = 0x82ACCD1C; continue 'dispatch;
	}
	// 82ACCCE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACCCEC: 486DCC9D  bl 0x831a9988
	ctx.lr = 0x82ACCCF0;
	sub_831A9988(ctx, base);
	// 82ACCCF0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ACCCF4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ACCCF8: 386BD7D8  addi r3, r11, -0x2828
	ctx.r[3].s64 = ctx.r[11].s64 + -10280;
	// 82ACCCFC: 486DB3FD  bl 0x831a80f8
	ctx.lr = 0x82ACCD00;
	sub_831A80F8(ctx, base);
	// 82ACCD00: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACCD04: 41820018  beq 0x82accd1c
	if ctx.cr[0].eq {
	pc = 0x82ACCD1C; continue 'dispatch;
	}
	// 82ACCD08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACCD0C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82ACCD10: 4BFFFEB9  bl 0x82accbc8
	ctx.lr = 0x82ACCD14;
	sub_82ACCBC8(ctx, base);
	// 82ACCD14: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ACCD18: 4800004C  b 0x82accd64
	pc = 0x82ACCD64; continue 'dispatch;
	// 82ACCD1C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82ACCD20: 419A0034  beq cr6, 0x82accd54
	if ctx.cr[6].eq {
	pc = 0x82ACCD54; continue 'dispatch;
	}
	// 82ACCD24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACCD28: 486DCC61  bl 0x831a9988
	ctx.lr = 0x82ACCD2C;
	sub_831A9988(ctx, base);
	// 82ACCD2C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82ACCD30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ACCD34: 386B59B0  addi r3, r11, 0x59b0
	ctx.r[3].s64 = ctx.r[11].s64 + 22960;
	// 82ACCD38: 486DB3C1  bl 0x831a80f8
	ctx.lr = 0x82ACCD3C;
	sub_831A80F8(ctx, base);
	// 82ACCD3C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACCD40: 41820014  beq 0x82accd54
	if ctx.cr[0].eq {
	pc = 0x82ACCD54; continue 'dispatch;
	}
	// 82ACCD44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACCD48: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82ACCD4C: 4BFFFDB5  bl 0x82accb00
	ctx.lr = 0x82ACCD50;
	sub_82ACCB00(ctx, base);
	// 82ACCD50: 4BFFFFC4  b 0x82accd14
	pc = 0x82ACCD14; continue 'dispatch;
	// 82ACCD54: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ACCD58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACCD5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACCD60: 4BA458B9  bl 0x82512618
	ctx.lr = 0x82ACCD64;
	sub_82512618(ctx, base);
	// 82ACCD64: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ACCD68: 486DB450  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACCD70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACCD70 size=476
    let mut pc: u32 = 0x82ACCD70;
    'dispatch: loop {
        match pc {
            0x82ACCD70 => {
    //   block [0x82ACCD70..0x82ACCF4C)
	// 82ACCD70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACCD74: 486DB3F9  bl 0x831a816c
	ctx.lr = 0x82ACCD78;
	sub_831A8130(ctx, base);
	// 82ACCD78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACCD7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACCD80: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ACCD84: 4BA43985  bl 0x82510708
	ctx.lr = 0x82ACCD88;
	sub_82510708(ctx, base);
	// 82ACCD88: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82ACCD8C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ACCD90: 41980184  blt cr6, 0x82accf14
	if ctx.cr[6].lt {
	pc = 0x82ACCF14; continue 'dispatch;
	}
	// 82ACCD94: 419A0154  beq cr6, 0x82accee8
	if ctx.cr[6].eq {
	pc = 0x82ACCEE8; continue 'dispatch;
	}
	// 82ACCD98: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82ACCD9C: 419800AC  blt cr6, 0x82acce48
	if ctx.cr[6].lt {
	pc = 0x82ACCE48; continue 'dispatch;
	}
	// 82ACCDA0: 419A0084  beq cr6, 0x82acce24
	if ctx.cr[6].eq {
	pc = 0x82ACCE24; continue 'dispatch;
	}
	// 82ACCDA4: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82ACCDA8: 41980014  blt cr6, 0x82accdbc
	if ctx.cr[6].lt {
	pc = 0x82ACCDBC; continue 'dispatch;
	}
	// 82ACCDAC: 409A0198  bne cr6, 0x82accf44
	if !ctx.cr[6].eq {
	pc = 0x82ACCF44; continue 'dispatch;
	}
	// 82ACCDB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACCDB4: 4BA4381D  bl 0x825105d0
	ctx.lr = 0x82ACCDB8;
	sub_825105D0(ctx, base);
	// 82ACCDB8: 4800018C  b 0x82accf44
	pc = 0x82ACCF44; continue 'dispatch;
	// 82ACCDBC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ACCDC0: C01F011C  lfs f0, 0x11c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACCDC4: C1AB08A4  lfs f13, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACCDC8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ACCDCC: 41990018  bgt cr6, 0x82accde4
	if ctx.cr[6].gt {
	pc = 0x82ACCDE4; continue 'dispatch;
	}
	// 82ACCDD0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACCDD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACCDD8: 4BA42D69  bl 0x8250fb40
	ctx.lr = 0x82ACCDDC;
	sub_8250FB40(ctx, base);
	// 82ACCDDC: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82ACCDE0: 48000054  b 0x82acce34
	pc = 0x82ACCE34; continue 'dispatch;
	// 82ACCDE4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACCDE8: C19E0000  lfs f12, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ACCDEC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82ACCDF0: 83BF0130  lwz r29, 0x130(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 82ACCDF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACCDF8: 388AAC50  addi r4, r10, -0x53b0
	ctx.r[4].s64 = ctx.r[10].s64 + -21424;
	// 82ACCDFC: C1AB9F18  lfs f13, -0x60e8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24808 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACCE00: EC0C037C  fnmsubs f0, f12, f13, f0
	ctx.f[0].f64 = -(((ctx.f[12].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ACCE04: D01F011C  stfs f0, 0x11c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 82ACCE08: 4832C729  bl 0x82df9530
	ctx.lr = 0x82ACCE0C;
	sub_82DF9530(ctx, base);
	// 82ACCE0C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ACCE10: 38BF0110  addi r5, r31, 0x110
	ctx.r[5].s64 = ctx.r[31].s64 + 272;
	// 82ACCE14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ACCE18: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACCE1C: 48349D1D  bl 0x82e16b38
	ctx.lr = 0x82ACCE20;
	sub_82E16B38(ctx, base);
	// 82ACCE20: 48000018  b 0x82acce38
	pc = 0x82ACCE38; continue 'dispatch;
	// 82ACCE24: 897F0100  lbz r11, 0x100(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 82ACCE28: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACCE2C: 4182000C  beq 0x82acce38
	if ctx.cr[0].eq {
	pc = 0x82ACCE38; continue 'dispatch;
	}
	// 82ACCE30: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82ACCE34: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82ACCE38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACCE3C: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACCE40: 4BFFFE09  bl 0x82accc48
	ctx.lr = 0x82ACCE44;
	sub_82ACCC48(ctx, base);
	// 82ACCE44: 48000100  b 0x82accf44
	pc = 0x82ACCF44; continue 'dispatch;
	// 82ACCE48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACCE4C: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACCE50: 4BFFFDF9  bl 0x82accc48
	ctx.lr = 0x82ACCE54;
	sub_82ACCC48(ctx, base);
	// 82ACCE54: C1BF011C  lfs f13, 0x11c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACCE58: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ACCE5C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACCE60: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82ACCE64: D1BF011C  stfs f13, 0x11c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 82ACCE68: 3BAB9F18  addi r29, r11, -0x60e8
	ctx.r[29].s64 = ctx.r[11].s64 + -24808;
	// 82ACCE6C: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACCE70: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ACCE74: 41980048  blt cr6, 0x82accebc
	if ctx.cr[6].lt {
	pc = 0x82ACCEBC; continue 'dispatch;
	}
	// 82ACCE78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACCE7C: 83DF0138  lwz r30, 0x138(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82ACCE80: 4BA44C69  bl 0x82511ae8
	ctx.lr = 0x82ACCE84;
	sub_82511AE8(ctx, base);
	// 82ACCE84: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82ACCE88: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82ACCE8C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82ACCE90: 3880001B  li r4, 0x1b
	ctx.r[4].s64 = 27;
	// 82ACCE94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACCE98: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82ACCE9C: C02B4430  lfs f1, 0x4430(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17456 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACCEA0: C04A6218  lfs f2, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82ACCEA4: 4800DD4D  bl 0x82adabf0
	ctx.lr = 0x82ACCEA8;
	sub_82ADABF0(ctx, base);
	// 82ACCEA8: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82ACCEAC: C01D0008  lfs f0, 8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACCEB0: 907F0124  stw r3, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[3].u32 ) };
	// 82ACCEB4: D01F011C  stfs f0, 0x11c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 82ACCEB8: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82ACCEBC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82ACCEC0: 83DF0130  lwz r30, 0x130(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 82ACCEC4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82ACCEC8: 388BAC50  addi r4, r11, -0x53b0
	ctx.r[4].s64 = ctx.r[11].s64 + -21424;
	// 82ACCECC: 4832C665  bl 0x82df9530
	ctx.lr = 0x82ACCED0;
	sub_82DF9530(ctx, base);
	// 82ACCED0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ACCED4: 38BF0110  addi r5, r31, 0x110
	ctx.r[5].s64 = ctx.r[31].s64 + 272;
	// 82ACCED8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACCEDC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACCEE0: 48349C59  bl 0x82e16b38
	ctx.lr = 0x82ACCEE4;
	sub_82E16B38(ctx, base);
	// 82ACCEE4: 48000060  b 0x82accf44
	pc = 0x82ACCF44; continue 'dispatch;
	// 82ACCEE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ACCEEC: C01F0120  lfs f0, 0x120(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACCEF0: C1AB08A4  lfs f13, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACCEF4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ACCEF8: 40990014  ble cr6, 0x82accf0c
	if !ctx.cr[6].gt {
	pc = 0x82ACCF0C; continue 'dispatch;
	}
	// 82ACCEFC: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACCF00: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ACCF04: D01F0120  stfs f0, 0x120(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82ACCF08: 4800003C  b 0x82accf44
	pc = 0x82ACCF44; continue 'dispatch;
	// 82ACCF0C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82ACCF10: 48000030  b 0x82accf40
	pc = 0x82ACCF40; continue 'dispatch;
	// 82ACCF14: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82ACCF18: 83DF0130  lwz r30, 0x130(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 82ACCF1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACCF20: 388BAC50  addi r4, r11, -0x53b0
	ctx.r[4].s64 = ctx.r[11].s64 + -21424;
	// 82ACCF24: 4832C60D  bl 0x82df9530
	ctx.lr = 0x82ACCF28;
	sub_82DF9530(ctx, base);
	// 82ACCF28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ACCF2C: 38BF0110  addi r5, r31, 0x110
	ctx.r[5].s64 = ctx.r[31].s64 + 272;
	// 82ACCF30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACCF34: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACCF38: 48349C01  bl 0x82e16b38
	ctx.lr = 0x82ACCF3C;
	sub_82E16B38(ctx, base);
	// 82ACCF3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ACCF40: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82ACCF44: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ACCF48: 486DB274  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACCF50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACCF50 size=196
    let mut pc: u32 = 0x82ACCF50;
    'dispatch: loop {
        match pc {
            0x82ACCF50 => {
    //   block [0x82ACCF50..0x82ACD014)
	// 82ACCF50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACCF54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACCF58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACCF5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACCF60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACCF64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACCF68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACCF6C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82ACCF70: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ACCF74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACCF78: 4B7F39C1  bl 0x822c0938
	ctx.lr = 0x82ACCF7C;
	sub_822C0938(ctx, base);
	// 82ACCF7C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACCF80: 41820028  beq 0x82accfa8
	if ctx.cr[0].eq {
	pc = 0x82ACCFA8; continue 'dispatch;
	}
	// 82ACCF84: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACCF88: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82ACCF8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ACCF90: 392B9F2C  addi r9, r11, -0x60d4
	ctx.r[9].s64 = ctx.r[11].s64 + -24788;
	// 82ACCF94: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ACCF98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ACCF9C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ACCFA0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ACCFA4: 48000008  b 0x82accfac
	pc = 0x82ACCFAC; continue 'dispatch;
	// 82ACCFA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACCFAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACCFB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACCFB4: 409A0044  bne cr6, 0x82accff8
	if !ctx.cr[6].eq {
	pc = 0x82ACCFF8; continue 'dispatch;
	}
	// 82ACCFB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ACCFBC: 419A001C  beq cr6, 0x82accfd8
	if ctx.cr[6].eq {
	pc = 0x82ACCFD8; continue 'dispatch;
	}
	// 82ACCFC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACCFC4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ACCFC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACCFCC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACCFD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ACCFD4: 4E800421  bctrl
	ctx.lr = 0x82ACCFD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ACCFD8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ACCFDC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ACCFE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACCFE4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82ACCFE8: 816B0860  lwz r11, 0x860(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2144 as u32) ) } as u64;
	// 82ACCFEC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ACCFF0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ACCFF4: 4B7F300D  bl 0x822c0000
	ctx.lr = 0x82ACCFF8;
	sub_822C0000(ctx, base);
	// 82ACCFF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACCFFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ACD000: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACD004: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACD008: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ACD00C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACD010: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACD018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACD018 size=72
    let mut pc: u32 = 0x82ACD018;
    'dispatch: loop {
        match pc {
            0x82ACD018 => {
    //   block [0x82ACD018..0x82ACD060)
	// 82ACD018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACD01C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACD020: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACD024: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82ACD028: 419A001C  beq cr6, 0x82acd044
	if ctx.cr[6].eq {
	pc = 0x82ACD044; continue 'dispatch;
	}
	// 82ACD02C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82ACD030: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ACD034: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82ACD038: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ACD03C: 4BFFFB05  bl 0x82accb40
	ctx.lr = 0x82ACD040;
	sub_82ACCB40(ctx, base);
	// 82ACD040: 48000010  b 0x82acd050
	pc = 0x82ACD050; continue 'dispatch;
	// 82ACD044: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ACD048: 396B0868  addi r11, r11, 0x868
	ctx.r[11].s64 = ctx.r[11].s64 + 2152;
	// 82ACD04C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACD050: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ACD054: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACD058: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACD05C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACD060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACD060 size=172
    let mut pc: u32 = 0x82ACD060;
    'dispatch: loop {
        match pc {
            0x82ACD060 => {
    //   block [0x82ACD060..0x82ACD10C)
	// 82ACD060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACD064: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACD068: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACD06C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACD070: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACD074: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACD078: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACD07C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ACD080: 396B9FA4  addi r11, r11, -0x605c
	ctx.r[11].s64 = ctx.r[11].s64 + -24668;
	// 82ACD084: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82ACD088: 3D008338  lis r8, -0x7cc8
	ctx.r[8].s64 = -2093481984;
	// 82ACD08C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACD090: 394A9F90  addi r10, r10, -0x6070
	ctx.r[10].s64 = ctx.r[10].s64 + -24688;
	// 82ACD094: 39299F44  addi r9, r9, -0x60bc
	ctx.r[9].s64 = ctx.r[9].s64 + -24764;
	// 82ACD098: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACD09C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82ACD0A0: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 82ACD0A4: 387F0140  addi r3, r31, 0x140
	ctx.r[3].s64 = ctx.r[31].s64 + 320;
	// 82ACD0A8: 9168E66C  stw r11, -0x1994(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(-6548 as u32), ctx.r[11].u32 ) };
	// 82ACD0AC: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 82ACD0B0: 4BF998B9  bl 0x82a66968
	ctx.lr = 0x82ACD0B4;
	sub_82A66968(ctx, base);
	// 82ACD0B4: 807F013C  lwz r3, 0x13c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82ACD0B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACD0BC: 419A0008  beq cr6, 0x82acd0c4
	if ctx.cr[6].eq {
	pc = 0x82ACD0C4; continue 'dispatch;
	}
	// 82ACD0C0: 4B7F37D1  bl 0x822c0890
	ctx.lr = 0x82ACD0C4;
	sub_822C0890(ctx, base);
	// 82ACD0C4: 807F0134  lwz r3, 0x134(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82ACD0C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACD0CC: 419A0008  beq cr6, 0x82acd0d4
	if ctx.cr[6].eq {
	pc = 0x82ACD0D4; continue 'dispatch;
	}
	// 82ACD0D0: 4B7F37C1  bl 0x822c0890
	ctx.lr = 0x82ACD0D4;
	sub_822C0890(ctx, base);
	// 82ACD0D4: 807F012C  lwz r3, 0x12c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 82ACD0D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACD0DC: 419A0008  beq cr6, 0x82acd0e4
	if ctx.cr[6].eq {
	pc = 0x82ACD0E4; continue 'dispatch;
	}
	// 82ACD0E0: 4B7F37B1  bl 0x822c0890
	ctx.lr = 0x82ACD0E4;
	sub_822C0890(ctx, base);
	// 82ACD0E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACD0E8: 4BCDA571  bl 0x827a7658
	ctx.lr = 0x82ACD0EC;
	sub_827A7658(ctx, base);
	// 82ACD0EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACD0F0: 4B882261  bl 0x8234f350
	ctx.lr = 0x82ACD0F4;
	sub_8234F350(ctx, base);
	// 82ACD0F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ACD0F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACD0FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACD100: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ACD104: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACD108: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACD110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ACD110 size=8
    let mut pc: u32 = 0x82ACD110;
    'dispatch: loop {
        match pc {
            0x82ACD110 => {
    //   block [0x82ACD110..0x82ACD118)
	// 82ACD110: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82ACD114: 480001EC  b 0x82acd300
	sub_82ACD300(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACD118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ACD118 size=8
    let mut pc: u32 = 0x82ACD118;
    'dispatch: loop {
        match pc {
            0x82ACD118 => {
    //   block [0x82ACD118..0x82ACD120)
	// 82ACD118: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 82ACD11C: 480001E4  b 0x82acd300
	sub_82ACD300(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACD120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACD120 size=140
    let mut pc: u32 = 0x82ACD120;
    'dispatch: loop {
        match pc {
            0x82ACD120 => {
    //   block [0x82ACD120..0x82ACD1AC)
	// 82ACD120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACD124: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACD128: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACD12C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACD130: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACD134: 4BA44F35  bl 0x82512068
	ctx.lr = 0x82ACD138;
	sub_82512068(ctx, base);
	// 82ACD138: 817F012C  lwz r11, 0x12c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 82ACD13C: 815F0128  lwz r10, 0x128(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 82ACD140: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACD144: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ACD148: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ACD14C: 419A0024  beq cr6, 0x82acd170
	if ctx.cr[6].eq {
	pc = 0x82ACD170; continue 'dispatch;
	}
	// 82ACD150: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ACD154: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ACD158: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACD15C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ACD160: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ACD164: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ACD168: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACD16C: 4082FFE8  bne 0x82acd154
	if !ctx.cr[0].eq {
	pc = 0x82ACD154; continue 'dispatch;
	}
	// 82ACD170: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ACD174: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82ACD178: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ACD17C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACD180: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82ACD184: 4BA42F3D  bl 0x825100c0
	ctx.lr = 0x82ACD188;
	sub_825100C0(ctx, base);
	// 82ACD188: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82ACD18C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACD190: 419A0008  beq cr6, 0x82acd198
	if ctx.cr[6].eq {
	pc = 0x82ACD198; continue 'dispatch;
	}
	// 82ACD194: 4B7F36FD  bl 0x822c0890
	ctx.lr = 0x82ACD198;
	sub_822C0890(ctx, base);
	// 82ACD198: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ACD19C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACD1A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACD1A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACD1A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACD1B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACD1B0 size=332
    let mut pc: u32 = 0x82ACD1B0;
    'dispatch: loop {
        match pc {
            0x82ACD1B0 => {
    //   block [0x82ACD1B0..0x82ACD2FC)
	// 82ACD1B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACD1B4: 486DAFB9  bl 0x831a816c
	ctx.lr = 0x82ACD1B8;
	sub_831A8130(ctx, base);
	// 82ACD1B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACD1BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACD1C0: 4BA45171  bl 0x82512330
	ctx.lr = 0x82ACD1C4;
	sub_82512330(ctx, base);
	// 82ACD1C4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACD1C8: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82ACD1CC: 390B9F20  addi r8, r11, -0x60e0
	ctx.r[8].s64 = ctx.r[11].s64 + -24800;
	// 82ACD1D0: 3969A214  addi r11, r9, -0x5dec
	ctx.r[11].s64 = ctx.r[9].s64 + -24044;
	// 82ACD1D4: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 82ACD1D8: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82ACD1DC: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82ACD1E0: 3CC0820C  lis r6, -0x7df4
	ctx.r[6].s64 = -2113142784;
	// 82ACD1E4: 3CA0820C  lis r5, -0x7df4
	ctx.r[5].s64 = -2113142784;
	// 82ACD1E8: C008FFFC  lfs f0, -4(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACD1EC: 39679FA4  addi r11, r7, -0x605c
	ctx.r[11].s64 = ctx.r[7].s64 + -24668;
	// 82ACD1F0: 394A6910  addi r10, r10, 0x6910
	ctx.r[10].s64 = ctx.r[10].s64 + 26896;
	// 82ACD1F4: 38E69F90  addi r7, r6, -0x6070
	ctx.r[7].s64 = ctx.r[6].s64 + -24688;
	// 82ACD1F8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACD1FC: 393F0110  addi r9, r31, 0x110
	ctx.r[9].s64 = ctx.r[31].s64 + 272;
	// 82ACD200: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ACD204: 90FF0028  stw r7, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[7].u32 ) };
	// 82ACD208: 38C59F44  addi r6, r5, -0x60bc
	ctx.r[6].s64 = ctx.r[5].s64 + -24764;
	// 82ACD20C: 93DF00E8  stw r30, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[30].u32 ) };
	// 82ACD210: 3BBF0138  addi r29, r31, 0x138
	ctx.r[29].s64 = ctx.r[31].s64 + 312;
	// 82ACD214: 90DF00E4  stw r6, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[6].u32 ) };
	// 82ACD218: 397F0140  addi r11, r31, 0x140
	ctx.r[11].s64 = ctx.r[31].s64 + 320;
	// 82ACD21C: 9BDF0100  stb r30, 0x100(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[30].u8 ) };
	// 82ACD220: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACD300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACD300 size=76
    let mut pc: u32 = 0x82ACD300;
    'dispatch: loop {
        match pc {
            0x82ACD300 => {
    //   block [0x82ACD300..0x82ACD34C)
	// 82ACD300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACD304: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACD308: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACD30C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACD310: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACD314: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACD318: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ACD31C: 4BFFFD45  bl 0x82acd060
	ctx.lr = 0x82ACD320;
	sub_82ACD060(ctx, base);
	// 82ACD320: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACD324: 4182000C  beq 0x82acd330
	if ctx.cr[0].eq {
	pc = 0x82ACD330; continue 'dispatch;
	}
	// 82ACD328: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACD32C: 483250AD  bl 0x82df23d8
	ctx.lr = 0x82ACD330;
	sub_82DF23D8(ctx, base);
	// 82ACD330: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACD334: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ACD338: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACD33C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACD340: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ACD344: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACD348: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACD350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACD350 size=424
    let mut pc: u32 = 0x82ACD350;
    'dispatch: loop {
        match pc {
            0x82ACD350 => {
    //   block [0x82ACD350..0x82ACD4F8)
	// 82ACD350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACD354: 486DAE15  bl 0x831a8168
	ctx.lr = 0x82ACD358;
	sub_831A8130(ctx, base);
	// 82ACD358: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACD35C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACD360: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82ACD364: 3BCB9FE0  addi r30, r11, -0x6020
	ctx.r[30].s64 = ctx.r[11].s64 + -24608;
	// 82ACD368: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ACD36C: 38A00046  li r5, 0x46
	ctx.r[5].s64 = 70;
	// 82ACD370: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ACD374: 38600160  li r3, 0x160
	ctx.r[3].s64 = 352;
	// 82ACD378: 48325071  bl 0x82df23e8
	ctx.lr = 0x82ACD37C;
	sub_82DF23E8(ctx, base);
	// 82ACD37C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACD380: 41820010  beq 0x82acd390
	if ctx.cr[0].eq {
	pc = 0x82ACD390; continue 'dispatch;
	}
	// 82ACD384: 4BFFFE2D  bl 0x82acd1b0
	ctx.lr = 0x82ACD388;
	sub_82ACD1B0(ctx, base);
	// 82ACD388: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACD38C: 48000008  b 0x82acd394
	pc = 0x82ACD394; continue 'dispatch;
	// 82ACD390: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ACD394: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82ACD398: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACD39C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82ACD3A0: 4BFFFBB1  bl 0x82accf50
	ctx.lr = 0x82ACD3A4;
	sub_82ACCF50(ctx, base);
	// 82ACD3A4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ACD3A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACD3AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82ACD3B0: 4B7F2C51  bl 0x822c0000
	ctx.lr = 0x82ACD3B4;
	sub_822C0000(ctx, base);
	// 82ACD3B4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ACD3B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82ACD3BC: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 82ACD3C0: 409A0008  bne cr6, 0x82acd3c8
	if !ctx.cr[6].eq {
	pc = 0x82ACD3C8; continue 'dispatch;
	}
	// 82ACD3C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACD3C8: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82ACD3CC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82ACD3D0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82ACD3D4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82ACD3D8: 419A0024  beq cr6, 0x82acd3fc
	if ctx.cr[6].eq {
	pc = 0x82ACD3FC; continue 'dispatch;
	}
	// 82ACD3DC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82ACD3E0: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82ACD3E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACD3E8: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82ACD3EC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ACD3F0: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ACD3F4: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACD3F8: 4082FFE8  bne 0x82acd3e0
	if !ctx.cr[0].eq {
	pc = 0x82ACD3E0; continue 'dispatch;
	}
	// 82ACD3FC: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82ACD400: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82ACD404: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82ACD408: 419A0024  beq cr6, 0x82acd42c
	if ctx.cr[6].eq {
	pc = 0x82ACD42C; continue 'dispatch;
	}
	// 82ACD40C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82ACD410: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ACD414: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACD418: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ACD41C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ACD420: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ACD424: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACD428: 4082FFE8  bne 0x82acd410
	if !ctx.cr[0].eq {
	pc = 0x82ACD410; continue 'dispatch;
	}
	// 82ACD42C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ACD430: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82ACD434: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ACD438: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 82ACD43C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ACD440: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82ACD444: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACD448: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACD44C: 4BCCBAE5  bl 0x82798f30
	ctx.lr = 0x82ACD450;
	sub_82798F30(ctx, base);
	// 82ACD450: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACD454: 3D40832F  lis r10, -0x7cd1
	ctx.r[10].s64 = -2094071808;
	// 82ACD458: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ACD45C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ACD460: 38A0004C  li r5, 0x4c
	ctx.r[5].s64 = 76;
	// 82ACD464: C00B9F24  lfs f0, -0x60dc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24796 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACD468: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82ACD46C: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82ACD470: C00A0864  lfs f0, 0x864(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACD474: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82ACD478: 4B7F2F61  bl 0x822c03d8
	ctx.lr = 0x82ACD47C;
	sub_822C03D8(ctx, base);
	// 82ACD47C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACD480: 41820014  beq 0x82acd494
	if ctx.cr[0].eq {
	pc = 0x82ACD494; continue 'dispatch;
	}
	// 82ACD484: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82ACD488: 4BCCE1E1  bl 0x8279b668
	ctx.lr = 0x82ACD48C;
	sub_8279B668(ctx, base);
	// 82ACD48C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACD490: 48000008  b 0x82acd498
	pc = 0x82ACD498; continue 'dispatch;
	// 82ACD494: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ACD498: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ACD49C: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82ACD4A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACD4A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACD4A8: 4BACA7A9  bl 0x82597c50
	ctx.lr = 0x82ACD4AC;
	sub_82597C50(ctx, base);
	// 82ACD4AC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ACD4B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACD4B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACD4B8: 4B7F2B49  bl 0x822c0000
	ctx.lr = 0x82ACD4BC;
	sub_822C0000(ctx, base);
	// 82ACD4BC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ACD4C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACD4C4: 419A0008  beq cr6, 0x82acd4cc
	if ctx.cr[6].eq {
	pc = 0x82ACD4CC; continue 'dispatch;
	}
	// 82ACD4C8: 4B7F33C9  bl 0x822c0890
	ctx.lr = 0x82ACD4CC;
	sub_822C0890(ctx, base);
	// 82ACD4CC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ACD4D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACD4D4: 419A0008  beq cr6, 0x82acd4dc
	if ctx.cr[6].eq {
	pc = 0x82ACD4DC; continue 'dispatch;
	}
	// 82ACD4D8: 4B7F33B9  bl 0x822c0890
	ctx.lr = 0x82ACD4DC;
	sub_822C0890(ctx, base);
	// 82ACD4DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82ACD4E0: 419A000C  beq cr6, 0x82acd4ec
	if ctx.cr[6].eq {
	pc = 0x82ACD4EC; continue 'dispatch;
	}
	// 82ACD4E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ACD4E8: 4B7F33A9  bl 0x822c0890
	ctx.lr = 0x82ACD4EC;
	sub_822C0890(ctx, base);
	// 82ACD4EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ACD4F0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82ACD4F4: 486DACC4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACD4F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACD4F8 size=128
    let mut pc: u32 = 0x82ACD4F8;
    'dispatch: loop {
        match pc {
            0x82ACD4F8 => {
    //   block [0x82ACD4F8..0x82ACD578)
	// 82ACD4F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACD4FC: 486DAC71  bl 0x831a816c
	ctx.lr = 0x82ACD500;
	sub_831A8130(ctx, base);
	// 82ACD500: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACD504: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82ACD508: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82ACD50C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACD510: 3BEBE670  addi r31, r11, -0x1990
	ctx.r[31].s64 = ctx.r[11].s64 + -6544;
	// 82ACD514: 816AE678  lwz r11, -0x1988(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6536 as u32) ) } as u64;
	// 82ACD518: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82ACD51C: 40820024  bne 0x82acd540
	if !ctx.cr[0].eq {
	pc = 0x82ACD540; continue 'dispatch;
	}
	// 82ACD520: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 82ACD524: 3D0082AD  lis r8, -0x7d53
	ctx.r[8].s64 = -2102591488;
	// 82ACD528: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82ACD52C: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 82ACD530: 3908D018  addi r8, r8, -0x2fe8
	ctx.r[8].s64 = ctx.r[8].s64 + -12264;
	// 82ACD534: 916AE678  stw r11, -0x1988(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-6536 as u32), ctx.r[11].u32 ) };
	// 82ACD538: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82ACD53C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82ACD540: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82ACD544: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82ACD548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACD54C: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82ACD550: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82ACD554: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ACD558: 4BB87069  bl 0x826545c0
	ctx.lr = 0x82ACD55C;
	sub_826545C0(ctx, base);
	// 82ACD55C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACD560: 4182000C  beq 0x82acd56c
	if ctx.cr[0].eq {
	pc = 0x82ACD56C; continue 'dispatch;
	}
	// 82ACD564: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ACD568: 48000008  b 0x82acd570
	pc = 0x82ACD570; continue 'dispatch;
	// 82ACD56C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82ACD570: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ACD574: 486DAC48  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACD578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACD578 size=208
    let mut pc: u32 = 0x82ACD578;
    'dispatch: loop {
        match pc {
            0x82ACD578 => {
    //   block [0x82ACD578..0x82ACD648)
	// 82ACD578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACD57C: 486DABF1  bl 0x831a816c
	ctx.lr = 0x82ACD580;
	sub_831A8130(ctx, base);
	// 82ACD580: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82ACD584: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACD588: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACD58C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACD590: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ACD594: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ACD598: 388B9FE0  addi r4, r11, -0x6020
	ctx.r[4].s64 = ctx.r[11].s64 + -24608;
	// 82ACD59C: 38A00105  li r5, 0x105
	ctx.r[5].s64 = 261;
	// 82ACD5A0: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 82ACD5A4: 48324E45  bl 0x82df23e8
	ctx.lr = 0x82ACD5A8;
	sub_82DF23E8(ctx, base);
	// 82ACD5A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACD5AC: 41820010  beq 0x82acd5bc
	if ctx.cr[0].eq {
	pc = 0x82ACD5BC; continue 'dispatch;
	}
	// 82ACD5B0: 4BB2F9C1  bl 0x825fcf70
	ctx.lr = 0x82ACD5B4;
	sub_825FCF70(ctx, base);
	// 82ACD5B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ACD5B8: 48000008  b 0x82acd5c0
	pc = 0x82ACD5C0; continue 'dispatch;
	// 82ACD5BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACD5C0: 3BFE0130  addi r31, r30, 0x130
	ctx.r[31].s64 = ctx.r[30].s64 + 304;
	// 82ACD5C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACD5C8: 4BB2E231  bl 0x825fb7f8
	ctx.lr = 0x82ACD5CC;
	sub_825FB7F8(ctx, base);
	// 82ACD5CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ACD5D0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ACD5D4: 807E0128  lwz r3, 0x128(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(296 as u32) ) } as u64;
	// 82ACD5D8: 48349269  bl 0x82e16840
	ctx.lr = 0x82ACD5DC;
	sub_82E16840(ctx, base);
	// 82ACD5DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ACD5E0: 807E0130  lwz r3, 0x130(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(304 as u32) ) } as u64;
	// 82ACD5E4: 48349D7D  bl 0x82e17360
	ctx.lr = 0x82ACD5E8;
	sub_82E17360(ctx, base);
	// 82ACD5E8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82ACD5EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACD5F0: 388B51D0  addi r4, r11, 0x51d0
	ctx.r[4].s64 = ctx.r[11].s64 + 20944;
	// 82ACD5F4: 83BE0130  lwz r29, 0x130(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(304 as u32) ) } as u64;
	// 82ACD5F8: 4832BF39  bl 0x82df9530
	ctx.lr = 0x82ACD5FC;
	sub_82DF9530(ctx, base);
	// 82ACD5FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ACD600: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82ACD604: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ACD608: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACD60C: 4834A13D  bl 0x82e17748
	ctx.lr = 0x82ACD610;
	sub_82E17748(ctx, base);
	// 82ACD610: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ACD614: 3BBE0140  addi r29, r30, 0x140
	ctx.r[29].s64 = ctx.r[30].s64 + 320;
	// 82ACD618: 3BC00002  li r30, 2
	ctx.r[30].s64 = 2;
	// 82ACD61C: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ACD620: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACD624: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82ACD628: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACD62C: 4837120D  bl 0x82e3e838
	ctx.lr = 0x82ACD630;
	sub_82E3E838(ctx, base);
	// 82ACD630: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82ACD634: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82ACD638: 4082FFE8  bne 0x82acd620
	if !ctx.cr[0].eq {
	pc = 0x82ACD620; continue 'dispatch;
	}
	// 82ACD63C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ACD640: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82ACD644: 486DAB78  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACD648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACD648 size=632
    let mut pc: u32 = 0x82ACD648;
    'dispatch: loop {
        match pc {
            0x82ACD648 => {
    //   block [0x82ACD648..0x82ACD8C0)
	// 82ACD648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACD64C: 486DAB15  bl 0x831a8160
	ctx.lr = 0x82ACD650;
	sub_831A8130(ctx, base);
	// 82ACD650: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82ACD654: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACD658: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ACD65C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACD660: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82ACD664: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACD668: 4835D481  bl 0x82e2aae8
	ctx.lr = 0x82ACD66C;
	sub_82E2AAE8(ctx, base);
	// 82ACD66C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ACD670: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACD674: 3BCB0850  addi r30, r11, 0x850
	ctx.r[30].s64 = ctx.r[11].s64 + 2128;
	// 82ACD678: 808B0850  lwz r4, 0x850(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2128 as u32) ) } as u64;
	// 82ACD67C: 4832638D  bl 0x82df3a08
	ctx.lr = 0x82ACD680;
	sub_82DF3A08(ctx, base);
	// 82ACD680: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ACD684: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ACD688: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82ACD68C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82ACD690: 483617E1  bl 0x82e2ee70
	ctx.lr = 0x82ACD694;
	sub_82E2EE70(ctx, base);
	// 82ACD694: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACD698: 48325D91  bl 0x82df3428
	ctx.lr = 0x82ACD69C;
	sub_82DF3428(ctx, base);
	// 82ACD69C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACD6A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ACD6A4: 388B9FE0  addi r4, r11, -0x6020
	ctx.r[4].s64 = ctx.r[11].s64 + -24608;
	// 82ACD6A8: 38A00095  li r5, 0x95
	ctx.r[5].s64 = 149;
	// 82ACD6AC: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82ACD6B0: 48324D39  bl 0x82df23e8
	ctx.lr = 0x82ACD6B4;
	sub_82DF23E8(ctx, base);
	// 82ACD6B4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82ACD6B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACD6BC: 41820014  beq 0x82acd6d0
	if ctx.cr[0].eq {
	pc = 0x82ACD6D0; continue 'dispatch;
	}
	// 82ACD6C0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82ACD6C4: 483491CD  bl 0x82e16890
	ctx.lr = 0x82ACD6C8;
	sub_82E16890(ctx, base);
	// 82ACD6C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ACD6CC: 48000008  b 0x82acd6d4
	pc = 0x82ACD6D4; continue 'dispatch;
	// 82ACD6D0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82ACD6D4: 387F0128  addi r3, r31, 0x128
	ctx.r[3].s64 = ctx.r[31].s64 + 296;
	// 82ACD6D8: 4B88FC99  bl 0x8235d370
	ctx.lr = 0x82ACD6DC;
	sub_8235D370(ctx, base);
	// 82ACD6DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACD6E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACD6E4: 839F0128  lwz r28, 0x128(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 82ACD6E8: 4BA44A31  bl 0x82512118
	ctx.lr = 0x82ACD6EC;
	sub_82512118(ctx, base);
	// 82ACD6EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ACD6F0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ACD6F4: 483479BD  bl 0x82e150b0
	ctx.lr = 0x82ACD6F8;
	sub_82E150B0(ctx, base);
	// 82ACD6F8: 817F012C  lwz r11, 0x12c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 82ACD6FC: 815F0128  lwz r10, 0x128(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 82ACD700: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACD704: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82ACD708: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82ACD70C: 419A0024  beq cr6, 0x82acd730
	if ctx.cr[6].eq {
	pc = 0x82ACD730; continue 'dispatch;
	}
	// 82ACD710: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ACD714: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ACD718: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACD71C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ACD720: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ACD724: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ACD728: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACD72C: 4082FFE8  bne 0x82acd714
	if !ctx.cr[0].eq {
	pc = 0x82ACD714; continue 'dispatch;
	}
	// 82ACD730: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ACD734: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82ACD738: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82ACD73C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACD740: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82ACD744: 4BA432B5  bl 0x825109f8
	ctx.lr = 0x82ACD748;
	sub_825109F8(ctx, base);
	// 82ACD748: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ACD74C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACD750: 419A0008  beq cr6, 0x82acd758
	if ctx.cr[6].eq {
	pc = 0x82ACD758; continue 'dispatch;
	}
	// 82ACD754: 4B7F313D  bl 0x822c0890
	ctx.lr = 0x82ACD758;
	sub_822C0890(ctx, base);
	// 82ACD758: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACD75C: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ACD760: 483262A9  bl 0x82df3a08
	ctx.lr = 0x82ACD764;
	sub_82DF3A08(ctx, base);
	// 82ACD764: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ACD768: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ACD76C: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82ACD770: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82ACD774: 4836102D  bl 0x82e2e7a0
	ctx.lr = 0x82ACD778;
	sub_82E2E7A0(ctx, base);
	// 82ACD778: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACD77C: 48325CAD  bl 0x82df3428
	ctx.lr = 0x82ACD780;
	sub_82DF3428(ctx, base);
	// 82ACD780: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACD784: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACD788: 48372781  bl 0x82e3ff08
	ctx.lr = 0x82ACD78C;
	sub_82E3FF08(ctx, base);
	// 82ACD78C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ACD790: 3BBE0008  addi r29, r30, 8
	ctx.r[29].s64 = ctx.r[30].s64 + 8;
	// 82ACD794: 3B7F0150  addi r27, r31, 0x150
	ctx.r[27].s64 = ctx.r[31].s64 + 336;
	// 82ACD798: 3BDF0140  addi r30, r31, 0x140
	ctx.r[30].s64 = ctx.r[31].s64 + 320;
	// 82ACD79C: 3B800002  li r28, 2
	ctx.r[28].s64 = 2;
	// 82ACD7A0: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ACD7A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACD7A8: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACD7AC: 4832625D  bl 0x82df3a08
	ctx.lr = 0x82ACD7B0;
	sub_82DF3A08(ctx, base);
	// 82ACD7B0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ACD7B4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ACD7B8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82ACD7BC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82ACD7C0: 483732A9  bl 0x82e40a68
	ctx.lr = 0x82ACD7C4;
	sub_82E40A68(ctx, base);
	// 82ACD7C4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ACD7C8: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82ACD7CC: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82ACD7D0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACD7D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACD7D8: 4B7F6C89  bl 0x822c4460
	ctx.lr = 0x82ACD7DC;
	sub_822C4460(ctx, base);
	// 82ACD7DC: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82ACD7E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACD7E4: 419A0008  beq cr6, 0x82acd7ec
	if ctx.cr[6].eq {
	pc = 0x82ACD7EC; continue 'dispatch;
	}
	// 82ACD7E8: 4B7F30A9  bl 0x822c0890
	ctx.lr = 0x82ACD7EC;
	sub_822C0890(ctx, base);
	// 82ACD7EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACD7F0: 48325C39  bl 0x82df3428
	ctx.lr = 0x82ACD7F4;
	sub_82DF3428(ctx, base);
	// 82ACD7F4: D3FB0000  stfs f31, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82ACD7F8: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82ACD7FC: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82ACD800: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82ACD804: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82ACD808: 4082FF9C  bne 0x82acd7a4
	if !ctx.cr[0].eq {
	pc = 0x82ACD7A4; continue 'dispatch;
	}
	// 82ACD80C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82ACD810: 3D4082AD  lis r10, -0x7d53
	ctx.r[10].s64 = -2102591488;
	// 82ACD814: 81210070  lwz r9, 0x70(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82ACD818: 394AD578  addi r10, r10, -0x2a88
	ctx.r[10].s64 = ctx.r[10].s64 + -10888;
	// 82ACD81C: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82ACD820: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACD824: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ACD828: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82ACD82C: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 82ACD830: 419A0024  beq cr6, 0x82acd854
	if ctx.cr[6].eq {
	pc = 0x82ACD854; continue 'dispatch;
	}
	// 82ACD834: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ACD838: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ACD83C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACD840: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ACD844: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ACD848: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ACD84C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACD850: 4082FFE8  bne 0x82acd838
	if !ctx.cr[0].eq {
	pc = 0x82ACD838; continue 'dispatch;
	}
	// 82ACD854: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82ACD858: 93E10098  stw r31, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[31].u32 ) };
	// 82ACD85C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82ACD860: E8A10098  ld r5, 0x98(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 82ACD864: 934100A0  stw r26, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[26].u32 ) };
	// 82ACD868: 4BFFFC91  bl 0x82acd4f8
	ctx.lr = 0x82ACD86C;
	sub_82ACD4F8(ctx, base);
	// 82ACD86C: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 82ACD870: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82ACD874: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACD878: 4BA435C9  bl 0x82510e40
	ctx.lr = 0x82ACD87C;
	sub_82510E40(ctx, base);
	// 82ACD87C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ACD880: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACD884: 419A0008  beq cr6, 0x82acd88c
	if ctx.cr[6].eq {
	pc = 0x82ACD88C; continue 'dispatch;
	}
	// 82ACD888: 4B7F3009  bl 0x822c0890
	ctx.lr = 0x82ACD88C;
	sub_822C0890(ctx, base);
	// 82ACD88C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82ACD890: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACD894: 419A0008  beq cr6, 0x82acd89c
	if ctx.cr[6].eq {
	pc = 0x82ACD89C; continue 'dispatch;
	}
	// 82ACD898: 4B7F2FF9  bl 0x822c0890
	ctx.lr = 0x82ACD89C;
	sub_822C0890(ctx, base);
	// 82ACD89C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82ACD8A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACD8A4: 419A0008  beq cr6, 0x82acd8ac
	if ctx.cr[6].eq {
	pc = 0x82ACD8AC; continue 'dispatch;
	}
	// 82ACD8A8: 4B7F2FE9  bl 0x822c0890
	ctx.lr = 0x82ACD8AC;
	sub_822C0890(ctx, base);
	// 82ACD8AC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82ACD8B0: 4835D251  bl 0x82e2ab00
	ctx.lr = 0x82ACD8B4;
	sub_82E2AB00(ctx, base);
	// 82ACD8B4: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82ACD8B8: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82ACD8BC: 486DA8F4  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACD8C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACD8C0 size=128
    let mut pc: u32 = 0x82ACD8C0;
    'dispatch: loop {
        match pc {
            0x82ACD8C0 => {
    //   block [0x82ACD8C0..0x82ACD940)
	// 82ACD8C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACD8C4: 486DA8A9  bl 0x831a816c
	ctx.lr = 0x82ACD8C8;
	sub_831A8130(ctx, base);
	// 82ACD8C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACD8CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACD8D0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82ACD8D4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82ACD8D8: 4BA44101  bl 0x825119d8
	ctx.lr = 0x82ACD8DC;
	sub_825119D8(ctx, base);
	// 82ACD8DC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82ACD8E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACD8E4: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82ACD8E8: 48326121  bl 0x82df3a08
	ctx.lr = 0x82ACD8EC;
	sub_82DF3A08(ctx, base);
	// 82ACD8EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ACD8F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ACD8F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACD8F8: 4BA3AE89  bl 0x82508780
	ctx.lr = 0x82ACD8FC;
	sub_82508780(ctx, base);
	// 82ACD8FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACD900: 48325B29  bl 0x82df3428
	ctx.lr = 0x82ACD904;
	sub_82DF3428(ctx, base);
	// 82ACD904: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ACD908: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82ACD90C: 409A0008  bne cr6, 0x82acd914
	if !ctx.cr[6].eq {
	pc = 0x82ACD914; continue 'dispatch;
	}
	// 82ACD910: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACD914: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACD918: 4BA3AE89  bl 0x825087a0
	ctx.lr = 0x82ACD91C;
	sub_825087A0(ctx, base);
	// 82ACD91C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ACD920: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACD924: 4BFFFD25  bl 0x82acd648
	ctx.lr = 0x82ACD928;
	sub_82ACD648(ctx, base);
	// 82ACD928: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82ACD92C: 4853B68D  bl 0x83008fb8
	ctx.lr = 0x82ACD930;
	sub_83008FB8(ctx, base);
	// 82ACD930: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82ACD934: 906BE66C  stw r3, -0x1994(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-6548 as u32), ctx.r[3].u32 ) };
	// 82ACD938: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ACD93C: 486DA880  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACD940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACD940 size=136
    let mut pc: u32 = 0x82ACD940;
    'dispatch: loop {
        match pc {
            0x82ACD940 => {
    //   block [0x82ACD940..0x82ACD9C8)
	// 82ACD940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACD944: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACD948: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACD94C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACD950: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACD954: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACD958: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ACD95C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACD960: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACD964: 4BA41B65  bl 0x8250f4c8
	ctx.lr = 0x82ACD968;
	sub_8250F4C8(ctx, base);
	// 82ACD968: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACD96C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACD970: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82ACD974: 409A0008  bne cr6, 0x82acd97c
	if !ctx.cr[6].eq {
	pc = 0x82ACD97C; continue 'dispatch;
	}
	// 82ACD978: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACD97C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACD980: 4BA3CFD1  bl 0x8250a950
	ctx.lr = 0x82ACD984;
	sub_8250A950(ctx, base);
	// 82ACD984: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACD988: 48324309  bl 0x82df1c90
	ctx.lr = 0x82ACD98C;
	sub_82DF1C90(ctx, base);
	// 82ACD98C: 397E0026  addi r11, r30, 0x26
	ctx.r[11].s64 = ctx.r[30].s64 + 38;
	// 82ACD990: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ACD994: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82ACD998: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACD99C: 419A000C  beq cr6, 0x82acd9a8
	if ctx.cr[6].eq {
	pc = 0x82ACD9A8; continue 'dispatch;
	}
	// 82ACD9A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACD9A4: 483B3D9D  bl 0x82e81740
	ctx.lr = 0x82ACD9A8;
	sub_82E81740(ctx, base);
	// 82ACD9A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACD9AC: 483242E5  bl 0x82df1c90
	ctx.lr = 0x82ACD9B0;
	sub_82DF1C90(ctx, base);
	// 82ACD9B0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ACD9B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACD9B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACD9BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ACD9C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACD9C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACD9C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACD9C8 size=196
    let mut pc: u32 = 0x82ACD9C8;
    'dispatch: loop {
        match pc {
            0x82ACD9C8 => {
    //   block [0x82ACD9C8..0x82ACDA8C)
	// 82ACD9C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACD9CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACD9D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACD9D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACD9D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACD9DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACD9E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACD9E4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82ACD9E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ACD9EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACD9F0: 4B7F2F49  bl 0x822c0938
	ctx.lr = 0x82ACD9F4;
	sub_822C0938(ctx, base);
	// 82ACD9F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACD9F8: 41820028  beq 0x82acda20
	if ctx.cr[0].eq {
	pc = 0x82ACDA20; continue 'dispatch;
	}
	// 82ACD9FC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACDA00: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82ACDA04: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ACDA08: 392BA064  addi r9, r11, -0x5f9c
	ctx.r[9].s64 = ctx.r[11].s64 + -24476;
	// 82ACDA0C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ACDA10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ACDA14: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ACDA18: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ACDA1C: 48000008  b 0x82acda24
	pc = 0x82ACDA24; continue 'dispatch;
	// 82ACDA20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACDA24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACDA28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACDA2C: 409A0044  bne cr6, 0x82acda70
	if !ctx.cr[6].eq {
	pc = 0x82ACDA70; continue 'dispatch;
	}
	// 82ACDA30: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ACDA34: 419A001C  beq cr6, 0x82acda50
	if ctx.cr[6].eq {
	pc = 0x82ACDA50; continue 'dispatch;
	}
	// 82ACDA38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACDA3C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ACDA40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACDA44: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACDA48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ACDA4C: 4E800421  bctrl
	ctx.lr = 0x82ACDA50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ACDA50: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ACDA54: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ACDA58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACDA5C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82ACDA60: 816B0A04  lwz r11, 0xa04(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2564 as u32) ) } as u64;
	// 82ACDA64: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ACDA68: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ACDA6C: 4B7F2595  bl 0x822c0000
	ctx.lr = 0x82ACDA70;
	sub_822C0000(ctx, base);
	// 82ACDA70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACDA74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ACDA78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACDA7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACDA80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ACDA84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACDA88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACDA90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACDA90 size=112
    let mut pc: u32 = 0x82ACDA90;
    'dispatch: loop {
        match pc {
            0x82ACDA90 => {
    //   block [0x82ACDA90..0x82ACDB00)
	// 82ACDA90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACDA94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACDA98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACDA9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACDAA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACDAA4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACDAA8: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ACDAAC: 396BA08C  addi r11, r11, -0x5f74
	ctx.r[11].s64 = ctx.r[11].s64 + -24436;
	// 82ACDAB0: 394AA078  addi r10, r10, -0x5f88
	ctx.r[10].s64 = ctx.r[10].s64 + -24456;
	// 82ACDAB4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACDAB8: 387F0130  addi r3, r31, 0x130
	ctx.r[3].s64 = ctx.r[31].s64 + 304;
	// 82ACDABC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82ACDAC0: 4BF5F429  bl 0x82a2cee8
	ctx.lr = 0x82ACDAC4;
	sub_82A2CEE8(ctx, base);
	// 82ACDAC4: 807F012C  lwz r3, 0x12c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 82ACDAC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACDACC: 419A0008  beq cr6, 0x82acdad4
	if ctx.cr[6].eq {
	pc = 0x82ACDAD4; continue 'dispatch;
	}
	// 82ACDAD0: 4B7F2DC1  bl 0x822c0890
	ctx.lr = 0x82ACDAD4;
	sub_822C0890(ctx, base);
	// 82ACDAD4: 807F0124  lwz r3, 0x124(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 82ACDAD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACDADC: 419A0008  beq cr6, 0x82acdae4
	if ctx.cr[6].eq {
	pc = 0x82ACDAE4; continue 'dispatch;
	}
	// 82ACDAE0: 4B7F2DB1  bl 0x822c0890
	ctx.lr = 0x82ACDAE4;
	sub_822C0890(ctx, base);
	// 82ACDAE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACDAE8: 4B881869  bl 0x8234f350
	ctx.lr = 0x82ACDAEC;
	sub_8234F350(ctx, base);
	// 82ACDAEC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ACDAF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACDAF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACDAF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACDAFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACDB00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ACDB00 size=8
    let mut pc: u32 = 0x82ACDB00;
    'dispatch: loop {
        match pc {
            0x82ACDB00 => {
    //   block [0x82ACDB00..0x82ACDB08)
	// 82ACDB00: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82ACDB04: 4800044C  b 0x82acdf50
	sub_82ACDF50(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACDB08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACDB08 size=428
    let mut pc: u32 = 0x82ACDB08;
    'dispatch: loop {
        match pc {
            0x82ACDB08 => {
    //   block [0x82ACDB08..0x82ACDCB4)
	// 82ACDB08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACDB0C: 486DA659  bl 0x831a8164
	ctx.lr = 0x82ACDB10;
	sub_831A8130(ctx, base);
	// 82ACDB10: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACDB14: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82ACDB18: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ACDB1C: 397C0026  addi r11, r28, 0x26
	ctx.r[11].s64 = ctx.r[28].s64 + 38;
	// 82ACDB20: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ACDB24: 7FCBEA14  add r30, r11, r29
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82ACDB28: 7C6BE82E  lwzx r3, r11, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82ACDB2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACDB30: 419A0018  beq cr6, 0x82acdb48
	if ctx.cr[6].eq {
	pc = 0x82ACDB48; continue 'dispatch;
	}
	// 82ACDB34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACDB38: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ACDB3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ACDB40: 4E800421  bctrl
	ctx.lr = 0x82ACDB44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ACDB44: 48000168  b 0x82acdcac
	pc = 0x82ACDCAC; continue 'dispatch;
	// 82ACDB48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ACDB4C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACDB50: 4BA41979  bl 0x8250f4c8
	ctx.lr = 0x82ACDB54;
	sub_8250F4C8(ctx, base);
	// 82ACDB54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACDB58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACDB5C: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82ACDB60: 409A0008  bne cr6, 0x82acdb68
	if !ctx.cr[6].eq {
	pc = 0x82ACDB68; continue 'dispatch;
	}
	// 82ACDB64: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACDB68: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACDB6C: 4BA3CDE5  bl 0x8250a950
	ctx.lr = 0x82ACDB70;
	sub_8250A950(ctx, base);
	// 82ACDB70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACDB74: 4832411D  bl 0x82df1c90
	ctx.lr = 0x82ACDB78;
	sub_82DF1C90(ctx, base);
	// 82ACDB78: 2F1C0002  cmpwi cr6, r28, 2
	ctx.cr[6].compare_i32(ctx.r[28].s32, 2, &mut ctx.xer);
	// 82ACDB7C: 419A0098  beq cr6, 0x82acdc14
	if ctx.cr[6].eq {
	pc = 0x82ACDC14; continue 'dispatch;
	}
	// 82ACDB80: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ACDB84: 578A103A  slwi r10, r28, 2
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ACDB88: 396B09F8  addi r11, r11, 0x9f8
	ctx.r[11].s64 = ctx.r[11].s64 + 2552;
	// 82ACDB8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACDB90: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ACDB94: 48325E75  bl 0x82df3a08
	ctx.lr = 0x82ACDB98;
	sub_82DF3A08(ctx, base);
	// 82ACDB98: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ACDB9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACDBA0: 3BEBFF40  addi r31, r11, -0xc0
	ctx.r[31].s64 = ctx.r[11].s64 + -192;
	// 82ACDBA4: 409A0008  bne cr6, 0x82acdbac
	if !ctx.cr[6].eq {
	pc = 0x82ACDBAC; continue 'dispatch;
	}
	// 82ACDBA8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ACDBAC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ACDBB0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82ACDBB4: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 82ACDBB8: 4BA44561  bl 0x82512118
	ctx.lr = 0x82ACDBBC;
	sub_82512118(ctx, base);
	// 82ACDBBC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82ACDBC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACDBC4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82ACDBC8: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82ACDBCC: 38E0000B  li r7, 0xb
	ctx.r[7].s64 = 11;
	// 82ACDBD0: 4BD070E1  bl 0x827d4cb0
	ctx.lr = 0x82ACDBD4;
	sub_827D4CB0(ctx, base);
	// 82ACDBD4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ACDBD8: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82ACDBDC: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82ACDBE0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACDBE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACDBE8: 4B7F6879  bl 0x822c4460
	ctx.lr = 0x82ACDBEC;
	sub_822C4460(ctx, base);
	// 82ACDBEC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ACDBF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACDBF4: 419A0008  beq cr6, 0x82acdbfc
	if ctx.cr[6].eq {
	pc = 0x82ACDBFC; continue 'dispatch;
	}
	// 82ACDBF8: 4B7F2C99  bl 0x822c0890
	ctx.lr = 0x82ACDBFC;
	sub_822C0890(ctx, base);
	// 82ACDBFC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82ACDC00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACDC04: 419A0008  beq cr6, 0x82acdc0c
	if ctx.cr[6].eq {
	pc = 0x82ACDC0C; continue 'dispatch;
	}
	// 82ACDC08: 4B7F2C89  bl 0x822c0890
	ctx.lr = 0x82ACDC0C;
	sub_822C0890(ctx, base);
	// 82ACDC0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACDC10: 48000078  b 0x82acdc88
	pc = 0x82ACDC88; continue 'dispatch;
	// 82ACDC14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ACDC18: 4BA43ED1  bl 0x82511ae8
	ctx.lr = 0x82ACDC1C;
	sub_82511AE8(ctx, base);
	// 82ACDC1C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ACDC20: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82ACDC24: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82ACDC28: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82ACDC2C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82ACDC30: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACDCB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACDCB8 size=168
    let mut pc: u32 = 0x82ACDCB8;
    'dispatch: loop {
        match pc {
            0x82ACDCB8 => {
    //   block [0x82ACDCB8..0x82ACDD60)
	// 82ACDCB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACDCBC: 486DA4B1  bl 0x831a816c
	ctx.lr = 0x82ACDCC0;
	sub_831A8130(ctx, base);
	// 82ACDCC0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACDCC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACDCC8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACDCCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACDCD0: 4BA417F9  bl 0x8250f4c8
	ctx.lr = 0x82ACDCD4;
	sub_8250F4C8(ctx, base);
	// 82ACDCD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACDCD8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82ACDCDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACDCE0: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82ACDCE4: 409A0008  bne cr6, 0x82acdcec
	if !ctx.cr[6].eq {
	pc = 0x82ACDCEC; continue 'dispatch;
	}
	// 82ACDCE8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ACDCEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACDCF0: 4BA3CC61  bl 0x8250a950
	ctx.lr = 0x82ACDCF4;
	sub_8250A950(ctx, base);
	// 82ACDCF4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACDCF8: 48323F99  bl 0x82df1c90
	ctx.lr = 0x82ACDCFC;
	sub_82DF1C90(ctx, base);
	// 82ACDCFC: 3BFF0130  addi r31, r31, 0x130
	ctx.r[31].s64 = ctx.r[31].s64 + 304;
	// 82ACDD00: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 82ACDD04: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACDD08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACDD0C: 419A0038  beq cr6, 0x82acdd44
	if ctx.cr[6].eq {
	pc = 0x82ACDD44; continue 'dispatch;
	}
	// 82ACDD10: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ACDD14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACDD18: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82ACDD1C: 409A0008  bne cr6, 0x82acdd24
	if !ctx.cr[6].eq {
	pc = 0x82ACDD24; continue 'dispatch;
	}
	// 82ACDD20: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ACDD24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACDD28: 4BD05CD9  bl 0x827d3a00
	ctx.lr = 0x82ACDD2C;
	sub_827D3A00(ctx, base);
	// 82ACDD2C: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82ACDD30: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ACDD34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACDD38: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82ACDD3C: 419A0008  beq cr6, 0x82acdd44
	if ctx.cr[6].eq {
	pc = 0x82ACDD44; continue 'dispatch;
	}
	// 82ACDD40: 4B7F2B51  bl 0x822c0890
	ctx.lr = 0x82ACDD44;
	sub_822C0890(ctx, base);
	// 82ACDD44: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82ACDD48: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82ACDD4C: 4082FFB8  bne 0x82acdd04
	if !ctx.cr[0].eq {
	pc = 0x82ACDD04; continue 'dispatch;
	}
	// 82ACDD50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACDD54: 48323F3D  bl 0x82df1c90
	ctx.lr = 0x82ACDD58;
	sub_82DF1C90(ctx, base);
	// 82ACDD58: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ACDD5C: 486DA460  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACDD60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACDD60 size=52
    let mut pc: u32 = 0x82ACDD60;
    'dispatch: loop {
        match pc {
            0x82ACDD60 => {
    //   block [0x82ACDD60..0x82ACDD94)
	// 82ACDD60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACDD64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACDD68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACDD6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACDD70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACDD74: 4BA442F5  bl 0x82512068
	ctx.lr = 0x82ACDD78;
	sub_82512068(ctx, base);
	// 82ACDD78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACDD7C: 4BFFFF3D  bl 0x82acdcb8
	ctx.lr = 0x82ACDD80;
	sub_82ACDCB8(ctx, base);
	// 82ACDD80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ACDD84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACDD88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACDD8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACDD90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACDD98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACDD98 size=440
    let mut pc: u32 = 0x82ACDD98;
    'dispatch: loop {
        match pc {
            0x82ACDD98 => {
    //   block [0x82ACDD98..0x82ACDF50)
	// 82ACDD98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACDD9C: 486DA3D1  bl 0x831a816c
	ctx.lr = 0x82ACDDA0;
	sub_831A8130(ctx, base);
	// 82ACDDA0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82ACDDA4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACDDA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACDDAC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82ACDDB0: 4BA44581  bl 0x82512330
	ctx.lr = 0x82ACDDB4;
	sub_82512330(ctx, base);
	// 82ACDDB4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACDDB8: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82ACDDBC: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82ACDDC0: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 82ACDDC4: 3BABA038  addi r29, r11, -0x5fc8
	ctx.r[29].s64 = ctx.r[11].s64 + -24520;
	// 82ACDDC8: 394A6910  addi r10, r10, 0x6910
	ctx.r[10].s64 = ctx.r[10].s64 + 26896;
	// 82ACDDCC: 396000F0  li r11, 0xf0
	ctx.r[11].s64 = 240;
	// 82ACDDD0: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82ACDDD4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ACDDD8: 3929A08C  addi r9, r9, -0x5f74
	ctx.r[9].s64 = ctx.r[9].s64 + -24436;
	// 82ACDDDC: C01D0004  lfs f0, 4(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACDDE0: 3908A078  addi r8, r8, -0x5f88
	ctx.r[8].s64 = ctx.r[8].s64 + -24456;
	// 82ACDDE4: 93DF00E4  stw r30, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[30].u32 ) };
	// 82ACDDE8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ACDDEC: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACDDF0: 911F0028  stw r8, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[8].u32 ) };
	// 82ACDDF4: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACDF50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACDF50 size=76
    let mut pc: u32 = 0x82ACDF50;
    'dispatch: loop {
        match pc {
            0x82ACDF50 => {
    //   block [0x82ACDF50..0x82ACDF9C)
	// 82ACDF50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACDF54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACDF58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACDF5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACDF60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACDF64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACDF68: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ACDF6C: 4BFFFB25  bl 0x82acda90
	ctx.lr = 0x82ACDF70;
	sub_82ACDA90(ctx, base);
	// 82ACDF70: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACDF74: 4182000C  beq 0x82acdf80
	if ctx.cr[0].eq {
	pc = 0x82ACDF80; continue 'dispatch;
	}
	// 82ACDF78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACDF7C: 4832445D  bl 0x82df23d8
	ctx.lr = 0x82ACDF80;
	sub_82DF23D8(ctx, base);
	// 82ACDF80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACDF84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ACDF88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACDF8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACDF90: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ACDF94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACDF98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACDFA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACDFA0 size=128
    let mut pc: u32 = 0x82ACDFA0;
    'dispatch: loop {
        match pc {
            0x82ACDFA0 => {
    //   block [0x82ACDFA0..0x82ACE020)
	// 82ACDFA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACDFA4: 486DA1C9  bl 0x831a816c
	ctx.lr = 0x82ACDFA8;
	sub_831A8130(ctx, base);
	// 82ACDFA8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82ACDFAC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACDFB0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACDFB4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82ACDFB8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ACDFBC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ACDFC0: 388BA0C8  addi r4, r11, -0x5f38
	ctx.r[4].s64 = ctx.r[11].s64 + -24376;
	// 82ACDFC4: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 82ACDFC8: 38600150  li r3, 0x150
	ctx.r[3].s64 = 336;
	// 82ACDFCC: 4832441D  bl 0x82df23e8
	ctx.lr = 0x82ACDFD0;
	sub_82DF23E8(ctx, base);
	// 82ACDFD0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACDFD4: 41820014  beq 0x82acdfe8
	if ctx.cr[0].eq {
	pc = 0x82ACDFE8; continue 'dispatch;
	}
	// 82ACDFD8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82ACDFDC: 4BFFFDBD  bl 0x82acdd98
	ctx.lr = 0x82ACDFE0;
	sub_82ACDD98(ctx, base);
	// 82ACDFE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACDFE4: 48000008  b 0x82acdfec
	pc = 0x82ACDFEC; continue 'dispatch;
	// 82ACDFE8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ACDFEC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ACDFF0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82ACDFF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACDFF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACDFFC: 4BFFF9CD  bl 0x82acd9c8
	ctx.lr = 0x82ACE000;
	sub_82ACD9C8(ctx, base);
	// 82ACE000: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ACE004: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACE008: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACE00C: 4B7F1FF5  bl 0x822c0000
	ctx.lr = 0x82ACE010;
	sub_822C0000(ctx, base);
	// 82ACE010: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ACE014: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ACE018: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82ACE01C: 486DA1A0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACE020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACE020 size=228
    let mut pc: u32 = 0x82ACE020;
    'dispatch: loop {
        match pc {
            0x82ACE020 => {
    //   block [0x82ACE020..0x82ACE104)
	// 82ACE020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACE024: 486DA149  bl 0x831a816c
	ctx.lr = 0x82ACE028;
	sub_831A8130(ctx, base);
	// 82ACE028: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACE02C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACE030: 809F0128  lwz r4, 0x128(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 82ACE034: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82ACE038: 419A00C4  beq cr6, 0x82ace0fc
	if ctx.cr[6].eq {
	pc = 0x82ACE0FC; continue 'dispatch;
	}
	// 82ACE03C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACE040: 4835CAA9  bl 0x82e2aae8
	ctx.lr = 0x82ACE044;
	sub_82E2AAE8(ctx, base);
	// 82ACE044: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ACE048: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACE04C: 808B09F4  lwz r4, 0x9f4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2548 as u32) ) } as u64;
	// 82ACE050: 483259B9  bl 0x82df3a08
	ctx.lr = 0x82ACE054;
	sub_82DF3A08(ctx, base);
	// 82ACE054: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ACE058: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ACE05C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82ACE060: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACE064: 48360E0D  bl 0x82e2ee70
	ctx.lr = 0x82ACE068;
	sub_82E2EE70(ctx, base);
	// 82ACE068: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACE06C: 483253BD  bl 0x82df3428
	ctx.lr = 0x82ACE070;
	sub_82DF3428(ctx, base);
	// 82ACE070: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACE074: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ACE078: 388BA0C8  addi r4, r11, -0x5f38
	ctx.r[4].s64 = ctx.r[11].s64 + -24376;
	// 82ACE07C: 38A00083  li r5, 0x83
	ctx.r[5].s64 = 131;
	// 82ACE080: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82ACE084: 48324365  bl 0x82df23e8
	ctx.lr = 0x82ACE088;
	sub_82DF23E8(ctx, base);
	// 82ACE088: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACE08C: 41820014  beq 0x82ace0a0
	if ctx.cr[0].eq {
	pc = 0x82ACE0A0; continue 'dispatch;
	}
	// 82ACE090: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82ACE094: 483487FD  bl 0x82e16890
	ctx.lr = 0x82ACE098;
	sub_82E16890(ctx, base);
	// 82ACE098: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ACE09C: 48000008  b 0x82ace0a4
	pc = 0x82ACE0A4; continue 'dispatch;
	// 82ACE0A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACE0A4: 3BDF0120  addi r30, r31, 0x120
	ctx.r[30].s64 = ctx.r[31].s64 + 288;
	// 82ACE0A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACE0AC: 4B88F2C5  bl 0x8235d370
	ctx.lr = 0x82ACE0B0;
	sub_8235D370(ctx, base);
	// 82ACE0B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACE0B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACE0B8: 83BF0120  lwz r29, 0x120(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 82ACE0BC: 4BA4405D  bl 0x82512118
	ctx.lr = 0x82ACE0C0;
	sub_82512118(ctx, base);
	// 82ACE0C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ACE0C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ACE0C8: 48346FE9  bl 0x82e150b0
	ctx.lr = 0x82ACE0CC;
	sub_82E150B0(ctx, base);
	// 82ACE0CC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ACE0D0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82ACE0D4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ACE0D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACE0DC: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82ACE0E0: 4BA42A79  bl 0x82510b58
	ctx.lr = 0x82ACE0E4;
	sub_82510B58(ctx, base);
	// 82ACE0E4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ACE0E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACE0EC: 419A0008  beq cr6, 0x82ace0f4
	if ctx.cr[6].eq {
	pc = 0x82ACE0F4; continue 'dispatch;
	}
	// 82ACE0F0: 4B7F27A1  bl 0x822c0890
	ctx.lr = 0x82ACE0F4;
	sub_822C0890(ctx, base);
	// 82ACE0F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACE0F8: 4835CA09  bl 0x82e2ab00
	ctx.lr = 0x82ACE0FC;
	sub_82E2AB00(ctx, base);
	// 82ACE0FC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82ACE100: 486DA0BC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACE108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACE108 size=612
    let mut pc: u32 = 0x82ACE108;
    'dispatch: loop {
        match pc {
            0x82ACE108 => {
    //   block [0x82ACE108..0x82ACE36C)
	// 82ACE108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACE10C: 486DA059  bl 0x831a8164
	ctx.lr = 0x82ACE110;
	sub_831A8130(ctx, base);
	// 82ACE110: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82ACE114: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACE118: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82ACE11C: 4BFE28AD  bl 0x82ab09c8
	ctx.lr = 0x82ACE120;
	sub_82AB09C8(ctx, base);
	// 82ACE120: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82ACE124: 4082000C  bne 0x82ace130
	if !ctx.cr[0].eq {
	pc = 0x82ACE130; continue 'dispatch;
	}
	// 82ACE128: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ACE12C: 48000234  b 0x82ace360
	pc = 0x82ACE360; continue 'dispatch;
	// 82ACE130: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82ACE134: 394100C0  addi r10, r1, 0xc0
	ctx.r[10].s64 = ctx.r[1].s64 + 192;
	// 82ACE138: 3B6B6910  addi r27, r11, 0x6910
	ctx.r[27].s64 = ctx.r[11].s64 + 26896;
	// 82ACE13C: 396100C0  addi r11, r1, 0xc0
	ctx.r[11].s64 = ctx.r[1].s64 + 192;
	// 82ACE140: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ACE144: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82ACE148: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82ACE14C: 13E0D8C7  vcmpequd (lvx128) v31, v0, v27
	tmp.u32 = ctx.r[27].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACE370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACE370 size=132
    let mut pc: u32 = 0x82ACE370;
    'dispatch: loop {
        match pc {
            0x82ACE370 => {
    //   block [0x82ACE370..0x82ACE3F4)
	// 82ACE370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACE374: 486D9DF9  bl 0x831a816c
	ctx.lr = 0x82ACE378;
	sub_831A8130(ctx, base);
	// 82ACE378: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACE37C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACE380: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82ACE384: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82ACE388: 4BA43651  bl 0x825119d8
	ctx.lr = 0x82ACE38C;
	sub_825119D8(ctx, base);
	// 82ACE38C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82ACE390: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACE394: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82ACE398: 48325671  bl 0x82df3a08
	ctx.lr = 0x82ACE39C;
	sub_82DF3A08(ctx, base);
	// 82ACE39C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ACE3A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ACE3A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ACE3A8: 4BA3A3D9  bl 0x82508780
	ctx.lr = 0x82ACE3AC;
	sub_82508780(ctx, base);
	// 82ACE3AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACE3B0: 48325079  bl 0x82df3428
	ctx.lr = 0x82ACE3B4;
	sub_82DF3428(ctx, base);
	// 82ACE3B4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ACE3B8: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82ACE3BC: 409A0008  bne cr6, 0x82ace3c4
	if !ctx.cr[6].eq {
	pc = 0x82ACE3C4; continue 'dispatch;
	}
	// 82ACE3C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACE3C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ACE3C8: 4BA3A3D9  bl 0x825087a0
	ctx.lr = 0x82ACE3CC;
	sub_825087A0(ctx, base);
	// 82ACE3CC: 397F0128  addi r11, r31, 0x128
	ctx.r[11].s64 = ctx.r[31].s64 + 296;
	// 82ACE3D0: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 82ACE3D4: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82ACE3D8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACE3DC: 917F0128  stw r11, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 82ACE3E0: 4B7F6081  bl 0x822c4460
	ctx.lr = 0x82ACE3E4;
	sub_822C4460(ctx, base);
	// 82ACE3E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACE3E8: 4BFFFC39  bl 0x82ace020
	ctx.lr = 0x82ACE3EC;
	sub_82ACE020(ctx, base);
	// 82ACE3EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ACE3F0: 486D9DCC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACE3F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACE3F8 size=508
    let mut pc: u32 = 0x82ACE3F8;
    'dispatch: loop {
        match pc {
            0x82ACE3F8 => {
    //   block [0x82ACE3F8..0x82ACE5F4)
	// 82ACE3F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACE3FC: 486D9D71  bl 0x831a816c
	ctx.lr = 0x82ACE400;
	sub_831A8130(ctx, base);
	// 82ACE400: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACE404: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACE408: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ACE40C: 4BA422FD  bl 0x82510708
	ctx.lr = 0x82ACE410;
	sub_82510708(ctx, base);
	// 82ACE410: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACE414: 3BABA044  addi r29, r11, -0x5fbc
	ctx.r[29].s64 = ctx.r[11].s64 + -24508;
	// 82ACE418: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82ACE41C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ACE420: 41980110  blt cr6, 0x82ace530
	if ctx.cr[6].lt {
	pc = 0x82ACE530; continue 'dispatch;
	}
	// 82ACE424: 419A00D0  beq cr6, 0x82ace4f4
	if ctx.cr[6].eq {
	pc = 0x82ACE4F4; continue 'dispatch;
	}
	// 82ACE428: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82ACE42C: 41980058  blt cr6, 0x82ace484
	if ctx.cr[6].lt {
	pc = 0x82ACE484; continue 'dispatch;
	}
	// 82ACE430: 409A0138  bne cr6, 0x82ace568
	if !ctx.cr[6].eq {
	pc = 0x82ACE568; continue 'dispatch;
	}
	// 82ACE434: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACE438: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ACE43C: C19F0104  lfs f12, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ACE440: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACE444: C17F00F4  lfs f11, 0xf4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ACE448: EC0D603A  fmadds f0, f13, f0, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82ACE44C: EDAC5B7A  fmadds f13, f12, f13, f11
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 82ACE450: C19F0108  lfs f12, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ACE454: D1BF00F4  stfs f13, 0xf4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82ACE458: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82ACE45C: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACE460: EDAC0028  fsubs f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ACE464: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACE468: D1BF0108  stfs f13, 0x108(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82ACE46C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ACE470: 419900F8  bgt cr6, 0x82ace568
	if ctx.cr[6].gt {
	pc = 0x82ACE568; continue 'dispatch;
	}
	// 82ACE474: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACE478: 4BFFF841  bl 0x82acdcb8
	ctx.lr = 0x82ACE47C;
	sub_82ACDCB8(ctx, base);
	// 82ACE47C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACE480: 480000E4  b 0x82ace564
	pc = 0x82ACE564; continue 'dispatch;
	// 82ACE484: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACE488: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82ACE48C: C19F0104  lfs f12, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ACE490: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACE494: C17F00F4  lfs f11, 0xf4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ACE498: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACE49C: ED6C5B7A  fmadds f11, f12, f13, f11
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 82ACE4A0: EC0D603A  fmadds f0, f13, f0, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82ACE4A4: D17F00F4  stfs f11, 0xf4(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82ACE4A8: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82ACE4AC: 4BFFF65D  bl 0x82acdb08
	ctx.lr = 0x82ACE4B0;
	sub_82ACDB08(ctx, base);
	// 82ACE4B0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ACE4B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACE4B8: 4BFFF489  bl 0x82acd940
	ctx.lr = 0x82ACE4BC;
	sub_82ACD940(ctx, base);
	// 82ACE4BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ACE4C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACE4C4: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACE4C8: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82ACE4CC: 4BA1C5BD  bl 0x824eaa88
	ctx.lr = 0x82ACE4D0;
	sub_824EAA88(ctx, base);
	// 82ACE4D0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACE4D4: 4BA1B37D  bl 0x824e9850
	ctx.lr = 0x82ACE4D8;
	sub_824E9850(ctx, base);
	// 82ACE4D8: C01F0108  lfs f0, 0x108(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACE4DC: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82ACE4E0: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82ACE4E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACE4E8: 483237A9  bl 0x82df1c90
	ctx.lr = 0x82ACE4EC;
	sub_82DF1C90(ctx, base);
	// 82ACE4EC: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82ACE4F0: 48000074  b 0x82ace564
	pc = 0x82ACE564; continue 'dispatch;
	// 82ACE4F4: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACE4F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ACE4FC: C19F0104  lfs f12, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ACE500: C17F00F4  lfs f11, 0xf4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ACE504: ED6C5B7A  fmadds f11, f12, f13, f11
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 82ACE508: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACE50C: EC0D603A  fmadds f0, f13, f0, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82ACE510: D17F00F4  stfs f11, 0xf4(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82ACE514: C1AB08A4  lfs f13, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACE518: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82ACE51C: FD805890  fmr f12, f11
	ctx.f[12].f64 = ctx.f[11].f64;
	// 82ACE520: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82ACE524: 41990044  bgt cr6, 0x82ace568
	if ctx.cr[6].gt {
	pc = 0x82ACE568; continue 'dispatch;
	}
	// 82ACE528: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82ACE52C: 48000038  b 0x82ace564
	pc = 0x82ACE564; continue 'dispatch;
	// 82ACE530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACE534: 4BFFFBD5  bl 0x82ace108
	ctx.lr = 0x82ACE538;
	sub_82ACE108(ctx, base);
	// 82ACE538: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACE53C: 4182002C  beq 0x82ace568
	if ctx.cr[0].eq {
	pc = 0x82ACE568; continue 'dispatch;
	}
	// 82ACE540: C01DFFFC  lfs f0, -4(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACE544: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACE548: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82ACE54C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACE550: 4BFFF5B9  bl 0x82acdb08
	ctx.lr = 0x82ACE554;
	sub_82ACDB08(ctx, base);
	// 82ACE554: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ACE558: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACE55C: 4BFFF5AD  bl 0x82acdb08
	ctx.lr = 0x82ACE560;
	sub_82ACDB08(ctx, base);
	// 82ACE560: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ACE564: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82ACE568: 817F010C  lwz r11, 0x10c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 82ACE56C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82ACE570: C1BD0014  lfs f13, 0x14(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACE574: 389F010C  addi r4, r31, 0x10c
	ctx.r[4].s64 = ctx.r[31].s64 + 268;
	// 82ACE578: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82ACE57C: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 82ACE580: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82ACE584: FD80069C  fcfid f12, f0
	ctx.f[12].f64 = (ctx.f[0].s64 as f64);
	// 82ACE588: C00AF770  lfs f0, -0x890(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-2192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACE58C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82ACE590: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ACE594: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82ACE598: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ACE59C: 40980030  bge cr6, 0x82ace5cc
	if !ctx.cr[6].lt {
	pc = 0x82ACE5CC; continue 'dispatch;
	}
	// 82ACE5A0: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACE5A4: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82ACE5A8: C1BF0118  lfs f13, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACE5AC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ACE5B0: C00AF778  lfs f0, -0x888(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-2184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACE5B4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ACE5B8: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82ACE5BC: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 82ACE5C0: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ACE5C4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82ACE5C8: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACE5CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACE5D0: 4BFDFD71  bl 0x82aae340
	ctx.lr = 0x82ACE5D4;
	sub_82AAE340(ctx, base);
	// 82ACE5D4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82ACE5D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACE5DC: 4BA43515  bl 0x82511af0
	ctx.lr = 0x82ACE5E0;
	sub_82511AF0(ctx, base);
	// 82ACE5E0: 389F00F0  addi r4, r31, 0xf0
	ctx.r[4].s64 = ctx.r[31].s64 + 240;
	// 82ACE5E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACE5E8: 4BA43499  bl 0x82511a80
	ctx.lr = 0x82ACE5EC;
	sub_82511A80(ctx, base);
	// 82ACE5EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82ACE5F0: 486D9BCC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACE5F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ACE5F8 size=8
    let mut pc: u32 = 0x82ACE5F8;
    'dispatch: loop {
        match pc {
            0x82ACE5F8 => {
    //   block [0x82ACE5F8..0x82ACE600)
	// 82ACE5F8: 98830138  stb r4, 0x138(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(312 as u32), ctx.r[4].u8 ) };
	// 82ACE5FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACE600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ACE600 size=12
    let mut pc: u32 = 0x82ACE600;
    'dispatch: loop {
        match pc {
            0x82ACE600 => {
    //   block [0x82ACE600..0x82ACE60C)
	// 82ACE600: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ACE604: 99630034  stb r11, 0x34(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u8 ) };
	// 82ACE608: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACE610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ACE610 size=12
    let mut pc: u32 = 0x82ACE610;
    'dispatch: loop {
        match pc {
            0x82ACE610 => {
    //   block [0x82ACE610..0x82ACE61C)
	// 82ACE610: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACE614: 99630034  stb r11, 0x34(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u8 ) };
	// 82ACE618: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACE620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACE620 size=136
    let mut pc: u32 = 0x82ACE620;
    'dispatch: loop {
        match pc {
            0x82ACE620 => {
    //   block [0x82ACE620..0x82ACE6A8)
	// 82ACE620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACE624: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACE628: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACE62C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACE630: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACE634: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACE638: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ACE63C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82ACE640: 409A0020  bne cr6, 0x82ace660
	if !ctx.cr[6].eq {
	pc = 0x82ACE660; continue 'dispatch;
	}
	// 82ACE644: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ACE648: 419A0048  beq cr6, 0x82ace690
	if ctx.cr[6].eq {
	pc = 0x82ACE690; continue 'dispatch;
	}
	// 82ACE64C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82ACE650: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82ACE654: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 82ACE658: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82ACE65C: 48000034  b 0x82ace690
	pc = 0x82ACE690; continue 'dispatch;
	// 82ACE660: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82ACE664: 419A002C  beq cr6, 0x82ace690
	if ctx.cr[6].eq {
	pc = 0x82ACE690; continue 'dispatch;
	}
	// 82ACE668: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ACE66C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACE670: 388B0B78  addi r4, r11, 0xb78
	ctx.r[4].s64 = ctx.r[11].s64 + 2936;
	// 82ACE674: 486D9A85  bl 0x831a80f8
	ctx.lr = 0x82ACE678;
	sub_831A80F8(ctx, base);
	// 82ACE678: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACE67C: 4182000C  beq 0x82ace688
	if ctx.cr[0].eq {
	pc = 0x82ACE688; continue 'dispatch;
	}
	// 82ACE680: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82ACE684: 4800000C  b 0x82ace690
	pc = 0x82ACE690; continue 'dispatch;
	// 82ACE688: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACE68C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACE690: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ACE694: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACE698: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACE69C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ACE6A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACE6A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACE6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACE6A8 size=164
    let mut pc: u32 = 0x82ACE6A8;
    'dispatch: loop {
        match pc {
            0x82ACE6A8 => {
    //   block [0x82ACE6A8..0x82ACE74C)
	// 82ACE6A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACE6AC: 486D9ABD  bl 0x831a8168
	ctx.lr = 0x82ACE6B0;
	sub_831A8130(ctx, base);
	// 82ACE6B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACE6B4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82ACE6B8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACE6BC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ACE6C0: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82ACE6C4: 41820038  beq 0x82ace6fc
	if ctx.cr[0].eq {
	pc = 0x82ACE6FC; continue 'dispatch;
	}
	// 82ACE6C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACE6CC: 486DB2BD  bl 0x831a9988
	ctx.lr = 0x82ACE6D0;
	sub_831A9988(ctx, base);
	// 82ACE6D0: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82ACE6D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ACE6D8: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 82ACE6DC: 486D9A1D  bl 0x831a80f8
	ctx.lr = 0x82ACE6E0;
	sub_831A80F8(ctx, base);
	// 82ACE6E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACE6E4: 41820018  beq 0x82ace6fc
	if ctx.cr[0].eq {
	pc = 0x82ACE6FC; continue 'dispatch;
	}
	// 82ACE6E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACE6EC: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82ACE6F0: 4BB92FF9  bl 0x826616e8
	ctx.lr = 0x82ACE6F4;
	sub_826616E8(ctx, base);
	// 82ACE6F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ACE6F8: 4800004C  b 0x82ace744
	pc = 0x82ACE744; continue 'dispatch;
	// 82ACE6FC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82ACE700: 419A0034  beq cr6, 0x82ace734
	if ctx.cr[6].eq {
	pc = 0x82ACE734; continue 'dispatch;
	}
	// 82ACE704: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACE708: 486DB281  bl 0x831a9988
	ctx.lr = 0x82ACE70C;
	sub_831A9988(ctx, base);
	// 82ACE70C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82ACE710: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ACE714: 386B59B0  addi r3, r11, 0x59b0
	ctx.r[3].s64 = ctx.r[11].s64 + 22960;
	// 82ACE718: 486D99E1  bl 0x831a80f8
	ctx.lr = 0x82ACE71C;
	sub_831A80F8(ctx, base);
	// 82ACE71C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACE720: 41820014  beq 0x82ace734
	if ctx.cr[0].eq {
	pc = 0x82ACE734; continue 'dispatch;
	}
	// 82ACE724: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACE728: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82ACE72C: 4BBD2C2D  bl 0x826a1358
	ctx.lr = 0x82ACE730;
	sub_826A1358(ctx, base);
	// 82ACE730: 4BFFFFC4  b 0x82ace6f4
	pc = 0x82ACE6F4; continue 'dispatch;
	// 82ACE734: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ACE738: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACE73C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACE740: 4BA43ED9  bl 0x82512618
	ctx.lr = 0x82ACE744;
	sub_82512618(ctx, base);
	// 82ACE744: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ACE748: 486D9A70  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACE750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACE750 size=136
    let mut pc: u32 = 0x82ACE750;
    'dispatch: loop {
        match pc {
            0x82ACE750 => {
    //   block [0x82ACE750..0x82ACE7D8)
	// 82ACE750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACE754: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACE758: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACE75C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACE760: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACE764: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82ACE768: 389F0100  addi r4, r31, 0x100
	ctx.r[4].s64 = ctx.r[31].s64 + 256;
	// 82ACE76C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACE770: C1BF010C  lfs f13, 0x10c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACE774: 815F0100  lwz r10, 0x100(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 82ACE778: C00BF778  lfs f0, -0x888(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACE77C: 813F0104  lwz r9, 0x104(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 82ACE780: C19F0110  lfs f12, 0x110(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ACE784: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ACE788: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ACE78C: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 82ACE790: D9A10050  stfd f13, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[13].u64 ) };
	// 82ACE794: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82ACE798: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82ACE79C: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82ACE7A0: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82ACE7A4: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82ACE7A8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82ACE7AC: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 82ACE7B0: 915F0100  stw r10, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[10].u32 ) };
	// 82ACE7B4: 4BFDFB8D  bl 0x82aae340
	ctx.lr = 0x82ACE7B8;
	sub_82AAE340(ctx, base);
	// 82ACE7B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ACE7BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACE7C0: 4BA43331  bl 0x82511af0
	ctx.lr = 0x82ACE7C4;
	sub_82511AF0(ctx, base);
	// 82ACE7C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ACE7C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACE7CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACE7D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACE7D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACE7D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACE7D8 size=232
    let mut pc: u32 = 0x82ACE7D8;
    'dispatch: loop {
        match pc {
            0x82ACE7D8 => {
    //   block [0x82ACE7D8..0x82ACE8C0)
	// 82ACE7D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACE7DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACE7E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACE7E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACE7E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACE7EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACE7F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACE7F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ACE7F8: 4BA40B39  bl 0x8250f330
	ctx.lr = 0x82ACE7FC;
	sub_8250F330(ctx, base);
	// 82ACE7FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ACE800: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACE804: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACE808: 4BA1C951  bl 0x824eb158
	ctx.lr = 0x82ACE80C;
	sub_824EB158(ctx, base);
	// 82ACE80C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACE810: 48323481  bl 0x82df1c90
	ctx.lr = 0x82ACE814;
	sub_82DF1C90(ctx, base);
	// 82ACE814: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82ACE818: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACE81C: 388B57F4  addi r4, r11, 0x57f4
	ctx.r[4].s64 = ctx.r[11].s64 + 22516;
	// 82ACE820: 483251E9  bl 0x82df3a08
	ctx.lr = 0x82ACE824;
	sub_82DF3A08(ctx, base);
	// 82ACE824: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ACE828: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACE82C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82ACE830: 409A000C  bne cr6, 0x82ace83c
	if !ctx.cr[6].eq {
	pc = 0x82ACE83C; continue 'dispatch;
	}
	// 82ACE834: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ACE838: 419A000C  beq cr6, 0x82ace844
	if ctx.cr[6].eq {
	pc = 0x82ACE844; continue 'dispatch;
	}
	// 82ACE83C: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82ACE840: 48000008  b 0x82ace848
	pc = 0x82ACE848; continue 'dispatch;
	// 82ACE844: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ACE848: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82ACE84C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ACE850: 4BA32C29  bl 0x82501478
	ctx.lr = 0x82ACE854;
	sub_82501478(ctx, base);
	// 82ACE854: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ACE858: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACE85C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82ACE860: 4BA31689  bl 0x824ffee8
	ctx.lr = 0x82ACE864;
	sub_824FFEE8(ctx, base);
	// 82ACE864: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82ACE868: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACE86C: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 82ACE870: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82ACE874: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82ACE878: 697F0001  xori r31, r11, 1
	ctx.r[31].u64 = ctx.r[11].u64 ^ 1;
	// 82ACE87C: 48324BAD  bl 0x82df3428
	ctx.lr = 0x82ACE880;
	sub_82DF3428(ctx, base);
	// 82ACE880: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACE884: 41820034  beq 0x82ace8b8
	if ctx.cr[0].eq {
	pc = 0x82ACE8B8; continue 'dispatch;
	}
	// 82ACE888: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACE88C: 4BA41D45  bl 0x825105d0
	ctx.lr = 0x82ACE890;
	sub_825105D0(ctx, base);
	// 82ACE890: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82ACE894: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACE898: 483233F9  bl 0x82df1c90
	ctx.lr = 0x82ACE89C;
	sub_82DF1C90(ctx, base);
	// 82ACE89C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACE8A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ACE8A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACE8A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACE8AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ACE8B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACE8B4: 4E800020  blr
	return;
	// 82ACE8B8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ACE8BC: 4BFFFFD8  b 0x82ace894
	pc = 0x82ACE894; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACE8C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACE8C0 size=196
    let mut pc: u32 = 0x82ACE8C0;
    'dispatch: loop {
        match pc {
            0x82ACE8C0 => {
    //   block [0x82ACE8C0..0x82ACE984)
	// 82ACE8C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACE8C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACE8C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACE8CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACE8D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACE8D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACE8D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACE8DC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82ACE8E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ACE8E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACE8E8: 4B7F2051  bl 0x822c0938
	ctx.lr = 0x82ACE8EC;
	sub_822C0938(ctx, base);
	// 82ACE8EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACE8F0: 41820028  beq 0x82ace918
	if ctx.cr[0].eq {
	pc = 0x82ACE918; continue 'dispatch;
	}
	// 82ACE8F4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACE8F8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82ACE8FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ACE900: 392BA21C  addi r9, r11, -0x5de4
	ctx.r[9].s64 = ctx.r[11].s64 + -24036;
	// 82ACE904: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ACE908: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ACE90C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ACE910: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ACE914: 48000008  b 0x82ace91c
	pc = 0x82ACE91C; continue 'dispatch;
	// 82ACE918: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACE91C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACE920: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACE924: 409A0044  bne cr6, 0x82ace968
	if !ctx.cr[6].eq {
	pc = 0x82ACE968; continue 'dispatch;
	}
	// 82ACE928: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ACE92C: 419A001C  beq cr6, 0x82ace948
	if ctx.cr[6].eq {
	pc = 0x82ACE948; continue 'dispatch;
	}
	// 82ACE930: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACE934: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ACE938: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACE93C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACE940: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ACE944: 4E800421  bctrl
	ctx.lr = 0x82ACE948;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ACE948: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ACE94C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ACE950: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACE954: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82ACE958: 816B0AB0  lwz r11, 0xab0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2736 as u32) ) } as u64;
	// 82ACE95C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ACE960: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ACE964: 4B7F169D  bl 0x822c0000
	ctx.lr = 0x82ACE968;
	sub_822C0000(ctx, base);
	// 82ACE968: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACE96C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ACE970: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACE974: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACE978: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ACE97C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACE980: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACE988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACE988 size=196
    let mut pc: u32 = 0x82ACE988;
    'dispatch: loop {
        match pc {
            0x82ACE988 => {
    //   block [0x82ACE988..0x82ACEA4C)
	// 82ACE988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACE98C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACE990: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACE994: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACE998: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACE99C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACE9A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACE9A4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82ACE9A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82ACE9AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACE9B0: 4B7F1F89  bl 0x822c0938
	ctx.lr = 0x82ACE9B4;
	sub_822C0938(ctx, base);
	// 82ACE9B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACE9B8: 41820028  beq 0x82ace9e0
	if ctx.cr[0].eq {
	pc = 0x82ACE9E0; continue 'dispatch;
	}
	// 82ACE9BC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACE9C0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82ACE9C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ACE9C8: 392BA230  addi r9, r11, -0x5dd0
	ctx.r[9].s64 = ctx.r[11].s64 + -24016;
	// 82ACE9CC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ACE9D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ACE9D4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ACE9D8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ACE9DC: 48000008  b 0x82ace9e4
	pc = 0x82ACE9E4; continue 'dispatch;
	// 82ACE9E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACE9E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACE9E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACE9EC: 409A0044  bne cr6, 0x82acea30
	if !ctx.cr[6].eq {
	pc = 0x82ACEA30; continue 'dispatch;
	}
	// 82ACE9F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ACE9F4: 419A001C  beq cr6, 0x82acea10
	if ctx.cr[6].eq {
	pc = 0x82ACEA10; continue 'dispatch;
	}
	// 82ACE9F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACE9FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ACEA00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACEA04: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACEA08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ACEA0C: 4E800421  bctrl
	ctx.lr = 0x82ACEA10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ACEA10: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ACEA14: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ACEA18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACEA1C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82ACEA20: 816B0AB0  lwz r11, 0xab0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2736 as u32) ) } as u64;
	// 82ACEA24: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ACEA28: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ACEA2C: 4B7F15D5  bl 0x822c0000
	ctx.lr = 0x82ACEA30;
	sub_822C0000(ctx, base);
	// 82ACEA30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACEA34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ACEA38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACEA3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACEA40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ACEA44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACEA48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACEA50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACEA50 size=72
    let mut pc: u32 = 0x82ACEA50;
    'dispatch: loop {
        match pc {
            0x82ACEA50 => {
    //   block [0x82ACEA50..0x82ACEA98)
	// 82ACEA50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACEA54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACEA58: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACEA5C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 82ACEA60: 419A001C  beq cr6, 0x82acea7c
	if ctx.cr[6].eq {
	pc = 0x82ACEA7C; continue 'dispatch;
	}
	// 82ACEA64: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82ACEA68: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ACEA6C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82ACEA70: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ACEA74: 4BFFFBAD  bl 0x82ace620
	ctx.lr = 0x82ACEA78;
	sub_82ACE620(ctx, base);
	// 82ACEA78: 48000010  b 0x82acea88
	pc = 0x82ACEA88; continue 'dispatch;
	// 82ACEA7C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ACEA80: 396B0B78  addi r11, r11, 0xb78
	ctx.r[11].s64 = ctx.r[11].s64 + 2936;
	// 82ACEA84: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACEA88: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ACEA8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACEA90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACEA94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACEA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACEA98 size=460
    let mut pc: u32 = 0x82ACEA98;
    'dispatch: loop {
        match pc {
            0x82ACEA98 => {
    //   block [0x82ACEA98..0x82ACEC64)
	// 82ACEA98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACEA9C: 486D96CD  bl 0x831a8168
	ctx.lr = 0x82ACEAA0;
	sub_831A8130(ctx, base);
	// 82ACEAA0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACEAA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACEAA8: 4BA43889  bl 0x82512330
	ctx.lr = 0x82ACEAAC;
	sub_82512330(ctx, base);
	// 82ACEAAC: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ACEAB0: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82ACEAB4: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 82ACEAB8: 3929A214  addi r9, r9, -0x5dec
	ctx.r[9].s64 = ctx.r[9].s64 + -24044;
	// 82ACEABC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82ACEAC0: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 82ACEAC4: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 82ACEAC8: 3908A2FC  addi r8, r8, -0x5d04
	ctx.r[8].s64 = ctx.r[8].s64 + -23812;
	// 82ACEACC: C02AA1D4  lfs f1, -0x5e2c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24108 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACEAD0: 3CC0820C  lis r6, -0x7df4
	ctx.r[6].s64 = -2113142784;
	// 82ACEAD4: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82ACEAD8: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82ACEADC: 3B8AA1D4  addi r28, r10, -0x5e2c
	ctx.r[28].s64 = ctx.r[10].s64 + -24108;
	// 82ACEAE0: 38E7A2E8  addi r7, r7, -0x5d18
	ctx.r[7].s64 = ctx.r[7].s64 + -23832;
	// 82ACEAE4: 394000F0  li r10, 0xf0
	ctx.r[10].s64 = 240;
	// 82ACEAE8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82ACEAEC: 90FF0028  stw r7, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[7].u32 ) };
	// 82ACEAF0: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82ACEAF4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ACEAF8: C1BC0004  lfs f13, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACEAFC: 38C6A29C  addi r6, r6, -0x5d64
	ctx.r[6].s64 = ctx.r[6].s64 + -23908;
	// 82ACEB00: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 82ACEB04: 93DF00E8  stw r30, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[30].u32 ) };
	// 82ACEB08: 90DF00E4  stw r6, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[6].u32 ) };
	// 82ACEB0C: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 82ACEB10: 93DF00EC  stw r30, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[30].u32 ) };
	// 82ACEB14: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACEC68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ACEC68 size=8
    let mut pc: u32 = 0x82ACEC68;
    'dispatch: loop {
        match pc {
            0x82ACEC68 => {
    //   block [0x82ACEC68..0x82ACEC70)
	// 82ACEC68: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82ACEC6C: 48000214  b 0x82acee80
	sub_82ACEE80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACEC70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ACEC70 size=8
    let mut pc: u32 = 0x82ACEC70;
    'dispatch: loop {
        match pc {
            0x82ACEC70 => {
    //   block [0x82ACEC70..0x82ACEC78)
	// 82ACEC70: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 82ACEC74: 4800020C  b 0x82acee80
	sub_82ACEE80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACEC78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACEC78 size=168
    let mut pc: u32 = 0x82ACEC78;
    'dispatch: loop {
        match pc {
            0x82ACEC78 => {
    //   block [0x82ACEC78..0x82ACED20)
	// 82ACEC78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACEC7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACEC80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACEC84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACEC88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACEC8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACEC90: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACEC94: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82ACEC98: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82ACEC9C: 396BA2FC  addi r11, r11, -0x5d04
	ctx.r[11].s64 = ctx.r[11].s64 + -23812;
	// 82ACECA0: 394AA2E8  addi r10, r10, -0x5d18
	ctx.r[10].s64 = ctx.r[10].s64 + -23832;
	// 82ACECA4: 3929A29C  addi r9, r9, -0x5d64
	ctx.r[9].s64 = ctx.r[9].s64 + -23908;
	// 82ACECA8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ACECAC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82ACECB0: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 82ACECB4: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 82ACECB8: 807F0158  lwz r3, 0x158(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 82ACECBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACECC0: 419A0008  beq cr6, 0x82acecc8
	if ctx.cr[6].eq {
	pc = 0x82ACECC8; continue 'dispatch;
	}
	// 82ACECC4: 4B7F1BCD  bl 0x822c0890
	ctx.lr = 0x82ACECC8;
	sub_822C0890(ctx, base);
	// 82ACECC8: 807F0150  lwz r3, 0x150(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82ACECCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACECD0: 419A0008  beq cr6, 0x82acecd8
	if ctx.cr[6].eq {
	pc = 0x82ACECD8; continue 'dispatch;
	}
	// 82ACECD4: 4B7F1BBD  bl 0x822c0890
	ctx.lr = 0x82ACECD8;
	sub_822C0890(ctx, base);
	// 82ACECD8: 807F0148  lwz r3, 0x148(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 82ACECDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACECE0: 419A0008  beq cr6, 0x82acece8
	if ctx.cr[6].eq {
	pc = 0x82ACECE8; continue 'dispatch;
	}
	// 82ACECE4: 4B7F1BAD  bl 0x822c0890
	ctx.lr = 0x82ACECE8;
	sub_822C0890(ctx, base);
	// 82ACECE8: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 82ACECEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACECF0: 419A0008  beq cr6, 0x82acecf8
	if ctx.cr[6].eq {
	pc = 0x82ACECF8; continue 'dispatch;
	}
	// 82ACECF4: 4B7F1B9D  bl 0x822c0890
	ctx.lr = 0x82ACECF8;
	sub_822C0890(ctx, base);
	// 82ACECF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACECFC: 4BCD895D  bl 0x827a7658
	ctx.lr = 0x82ACED00;
	sub_827A7658(ctx, base);
	// 82ACED00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACED04: 4B88064D  bl 0x8234f350
	ctx.lr = 0x82ACED08;
	sub_8234F350(ctx, base);
	// 82ACED08: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ACED0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACED10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACED14: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ACED18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACED1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACED20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACED20 size=240
    let mut pc: u32 = 0x82ACED20;
    'dispatch: loop {
        match pc {
            0x82ACED20 => {
    //   block [0x82ACED20..0x82ACEE10)
	// 82ACED20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACED24: 486D9449  bl 0x831a816c
	ctx.lr = 0x82ACED28;
	sub_831A8130(ctx, base);
	// 82ACED28: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82ACED2C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACED30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACED34: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACED38: 396BA1F0  addi r11, r11, -0x5e10
	ctx.r[11].s64 = ctx.r[11].s64 + -24080;
	// 82ACED3C: 815F00EC  lwz r10, 0xec(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82ACED40: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82ACED44: C01F0114  lfs f0, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACED48: 1D2A0014  mulli r9, r10, 0x14
	ctx.r[9].s64 = ctx.r[10].s64 * 20;
	// 82ACED4C: 7DA95C2E  lfsx f13, r9, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACED50: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ACED54: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 82ACED58: 419A0010  beq cr6, 0x82aced68
	if ctx.cr[6].eq {
	pc = 0x82ACED68; continue 'dispatch;
	}
	// 82ACED5C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ACED60: C1ABE99C  lfs f13, -0x1664(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5732 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACED64: 4800000C  b 0x82aced70
	pc = 0x82ACED70; continue 'dispatch;
	// 82ACED68: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ACED6C: C1ABE998  lfs f13, -0x1668(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5736 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACED70: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACED74: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82ACED78: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82ACED7C: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ACED80: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82ACED84: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ACED88: 483D19A9  bl 0x82ea0730
	ctx.lr = 0x82ACED8C;
	sub_82EA0730(ctx, base);
	// 82ACED8C: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 82ACED90: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82ACED94: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 82ACED98: 4844B459  bl 0x82f1a1f0
	ctx.lr = 0x82ACED9C;
	sub_82F1A1F0(ctx, base);
	// 82ACED9C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82ACEDA0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82ACEDA4: 4182000C  beq 0x82acedb0
	if ctx.cr[0].eq {
	pc = 0x82ACEDB0; continue 'dispatch;
	}
	// 82ACEDA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACEDAC: 4B81949D  bl 0x822e8248
	ctx.lr = 0x82ACEDB0;
	sub_822E8248(ctx, base);
	// 82ACEDB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACEDB4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACEDB8: 4BA43361  bl 0x82512118
	ctx.lr = 0x82ACEDBC;
	sub_82512118(ctx, base);
	// 82ACEDBC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ACEDC0: 38600006  li r3, 6
	ctx.r[3].s64 = 6;
	// 82ACEDC4: 4BFDFCD5  bl 0x82aaea98
	ctx.lr = 0x82ACEDC8;
	sub_82AAEA98(ctx, base);
	// 82ACEDC8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82ACEDCC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82ACEDD0: 388BE688  addi r4, r11, -0x1978
	ctx.r[4].s64 = ctx.r[11].s64 + -6520;
	// 82ACEDD4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ACEDD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACEDDC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82ACEDE0: 4BA44319  bl 0x825130f8
	ctx.lr = 0x82ACEDE4;
	sub_825130F8(ctx, base);
	// 82ACEDE4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ACEDE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACEDEC: 419A0008  beq cr6, 0x82acedf4
	if ctx.cr[6].eq {
	pc = 0x82ACEDF4; continue 'dispatch;
	}
	// 82ACEDF0: 4B819479  bl 0x822e8268
	ctx.lr = 0x82ACEDF4;
	sub_822E8268(ctx, base);
	// 82ACEDF4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82ACEDF8: 419A000C  beq cr6, 0x82acee04
	if ctx.cr[6].eq {
	pc = 0x82ACEE04; continue 'dispatch;
	}
	// 82ACEDFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACEE00: 4B819469  bl 0x822e8268
	ctx.lr = 0x82ACEE04;
	sub_822E8268(ctx, base);
	// 82ACEE04: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82ACEE08: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82ACEE0C: 486D93B0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACEE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACEE10 size=112
    let mut pc: u32 = 0x82ACEE10;
    'dispatch: loop {
        match pc {
            0x82ACEE10 => {
    //   block [0x82ACEE10..0x82ACEE80)
	// 82ACEE10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACEE14: 486D9359  bl 0x831a816c
	ctx.lr = 0x82ACEE18;
	sub_831A8130(ctx, base);
	// 82ACEE18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACEE1C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82ACEE20: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ACEE24: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ACEE28: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82ACEE2C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82ACEE30: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82ACEE34: 483235B5  bl 0x82df23e8
	ctx.lr = 0x82ACEE38;
	sub_82DF23E8(ctx, base);
	// 82ACEE38: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACEE3C: 41820010  beq 0x82acee4c
	if ctx.cr[0].eq {
	pc = 0x82ACEE4C; continue 'dispatch;
	}
	// 82ACEE40: 4BFED771  bl 0x82abc5b0
	ctx.lr = 0x82ACEE44;
	sub_82ABC5B0(ctx, base);
	// 82ACEE44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACEE48: 48000008  b 0x82acee50
	pc = 0x82ACEE50; continue 'dispatch;
	// 82ACEE4C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ACEE50: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ACEE54: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82ACEE58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACEE5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACEE60: 4BFFFB29  bl 0x82ace988
	ctx.lr = 0x82ACEE64;
	sub_82ACE988(ctx, base);
	// 82ACEE64: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ACEE68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACEE6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACEE70: 4B7F1191  bl 0x822c0000
	ctx.lr = 0x82ACEE74;
	sub_822C0000(ctx, base);
	// 82ACEE74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ACEE78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ACEE7C: 486D9340  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACEE80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACEE80 size=76
    let mut pc: u32 = 0x82ACEE80;
    'dispatch: loop {
        match pc {
            0x82ACEE80 => {
    //   block [0x82ACEE80..0x82ACEECC)
	// 82ACEE80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACEE84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACEE88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACEE8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACEE90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACEE94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACEE98: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ACEE9C: 4BFFFDDD  bl 0x82acec78
	ctx.lr = 0x82ACEEA0;
	sub_82ACEC78(ctx, base);
	// 82ACEEA0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACEEA4: 4182000C  beq 0x82aceeb0
	if ctx.cr[0].eq {
	pc = 0x82ACEEB0; continue 'dispatch;
	}
	// 82ACEEA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACEEAC: 4832352D  bl 0x82df23d8
	ctx.lr = 0x82ACEEB0;
	sub_82DF23D8(ctx, base);
	// 82ACEEB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACEEB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ACEEB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACEEBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACEEC0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ACEEC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACEEC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACEED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACEED0 size=240
    let mut pc: u32 = 0x82ACEED0;
    'dispatch: loop {
        match pc {
            0x82ACEED0 => {
    //   block [0x82ACEED0..0x82ACEFC0)
	// 82ACEED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACEED4: 486D9299  bl 0x831a816c
	ctx.lr = 0x82ACEED8;
	sub_831A8130(ctx, base);
	// 82ACEED8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACEEDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACEEE0: 809F0144  lwz r4, 0x144(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 82ACEEE4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82ACEEE8: 419A00D0  beq cr6, 0x82acefb8
	if ctx.cr[6].eq {
	pc = 0x82ACEFB8; continue 'dispatch;
	}
	// 82ACEEEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACEEF0: 4835BBF9  bl 0x82e2aae8
	ctx.lr = 0x82ACEEF4;
	sub_82E2AAE8(ctx, base);
	// 82ACEEF4: 815F00EC  lwz r10, 0xec(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82ACEEF8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACEEFC: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 * 20;
	// 82ACEF00: 396BA1F0  addi r11, r11, -0x5e10
	ctx.r[11].s64 = ctx.r[11].s64 + -24080;
	// 82ACEF04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACEF08: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ACEF0C: 48324AFD  bl 0x82df3a08
	ctx.lr = 0x82ACEF10;
	sub_82DF3A08(ctx, base);
	// 82ACEF10: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ACEF14: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ACEF18: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82ACEF1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACEF20: 4835FF51  bl 0x82e2ee70
	ctx.lr = 0x82ACEF24;
	sub_82E2EE70(ctx, base);
	// 82ACEF24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACEF28: 48324501  bl 0x82df3428
	ctx.lr = 0x82ACEF2C;
	sub_82DF3428(ctx, base);
	// 82ACEF2C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACEF30: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ACEF34: 388BA240  addi r4, r11, -0x5dc0
	ctx.r[4].s64 = ctx.r[11].s64 + -24000;
	// 82ACEF38: 38A000E2  li r5, 0xe2
	ctx.r[5].s64 = 226;
	// 82ACEF3C: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82ACEF40: 483234A9  bl 0x82df23e8
	ctx.lr = 0x82ACEF44;
	sub_82DF23E8(ctx, base);
	// 82ACEF44: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACEF48: 41820014  beq 0x82acef5c
	if ctx.cr[0].eq {
	pc = 0x82ACEF5C; continue 'dispatch;
	}
	// 82ACEF4C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82ACEF50: 48347941  bl 0x82e16890
	ctx.lr = 0x82ACEF54;
	sub_82E16890(ctx, base);
	// 82ACEF54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ACEF58: 48000008  b 0x82acef60
	pc = 0x82ACEF60; continue 'dispatch;
	// 82ACEF5C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACEF60: 3BDF013C  addi r30, r31, 0x13c
	ctx.r[30].s64 = ctx.r[31].s64 + 316;
	// 82ACEF64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACEF68: 4B88E409  bl 0x8235d370
	ctx.lr = 0x82ACEF6C;
	sub_8235D370(ctx, base);
	// 82ACEF6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACEF70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACEF74: 83BF013C  lwz r29, 0x13c(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82ACEF78: 4BA431A1  bl 0x82512118
	ctx.lr = 0x82ACEF7C;
	sub_82512118(ctx, base);
	// 82ACEF7C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ACEF80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ACEF84: 4834612D  bl 0x82e150b0
	ctx.lr = 0x82ACEF88;
	sub_82E150B0(ctx, base);
	// 82ACEF88: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ACEF8C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82ACEF90: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ACEF94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACEF98: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82ACEF9C: 4BA41BBD  bl 0x82510b58
	ctx.lr = 0x82ACEFA0;
	sub_82510B58(ctx, base);
	// 82ACEFA0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ACEFA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACEFA8: 419A0008  beq cr6, 0x82acefb0
	if ctx.cr[6].eq {
	pc = 0x82ACEFB0; continue 'dispatch;
	}
	// 82ACEFAC: 4B7F18E5  bl 0x822c0890
	ctx.lr = 0x82ACEFB0;
	sub_822C0890(ctx, base);
	// 82ACEFB0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACEFB4: 4835BB4D  bl 0x82e2ab00
	ctx.lr = 0x82ACEFB8;
	sub_82E2AB00(ctx, base);
	// 82ACEFB8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82ACEFBC: 486D9200  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACEFC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACEFC0 size=292
    let mut pc: u32 = 0x82ACEFC0;
    'dispatch: loop {
        match pc {
            0x82ACEFC0 => {
    //   block [0x82ACEFC0..0x82ACF0E4)
	// 82ACEFC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACEFC4: 486D91A5  bl 0x831a8168
	ctx.lr = 0x82ACEFC8;
	sub_831A8130(ctx, base);
	// 82ACEFC8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82ACEFCC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACEFD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACEFD4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82ACEFD8: 817F011C  lwz r11, 0x11c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 82ACEFDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACEFE0: 409A000C  bne cr6, 0x82acefec
	if !ctx.cr[6].eq {
	pc = 0x82ACEFEC; continue 'dispatch;
	}
	// 82ACEFE4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ACEFE8: 480000C4  b 0x82acf0ac
	pc = 0x82ACF0AC; continue 'dispatch;
	// 82ACEFEC: 4BFE19DD  bl 0x82ab09c8
	ctx.lr = 0x82ACEFF0;
	sub_82AB09C8(ctx, base);
	// 82ACEFF0: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82ACEFF4: 418200B4  beq 0x82acf0a8
	if ctx.cr[0].eq {
	pc = 0x82ACF0A8; continue 'dispatch;
	}
	// 82ACEFF8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACEFFC: 4BFFFE15  bl 0x82acee10
	ctx.lr = 0x82ACF000;
	sub_82ACEE10(ctx, base);
	// 82ACF000: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ACF004: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ACF008: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82ACF00C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82ACF010: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82ACF014: 419A0024  beq cr6, 0x82acf038
	if ctx.cr[6].eq {
	pc = 0x82ACF038; continue 'dispatch;
	}
	// 82ACF018: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82ACF01C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ACF020: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACF024: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ACF028: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ACF02C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ACF030: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACF034: 4082FFE8  bne 0x82acf01c
	if !ctx.cr[0].eq {
	pc = 0x82ACF01C; continue 'dispatch;
	}
	// 82ACF038: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACF03C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82ACF040: 388BA240  addi r4, r11, -0x5dc0
	ctx.r[4].s64 = ctx.r[11].s64 + -24000;
	// 82ACF044: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82ACF048: 38A001DC  li r5, 0x1dc
	ctx.r[5].s64 = 476;
	// 82ACF04C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82ACF050: 48387F99  bl 0x82e56fe8
	ctx.lr = 0x82ACF054;
	sub_82E56FE8(ctx, base);
	// 82ACF054: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82ACF058: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82ACF05C: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 82ACF060: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACF064: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82ACF068: 557DDFFE  rlwinm r29, r11, 0x1b, 0x1f, 0x1f
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82ACF06C: 419A0008  beq cr6, 0x82acf074
	if ctx.cr[6].eq {
	pc = 0x82ACF074; continue 'dispatch;
	}
	// 82ACF070: 4B7F1821  bl 0x822c0890
	ctx.lr = 0x82ACF074;
	sub_822C0890(ctx, base);
	// 82ACF074: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACF078: 40820020  bne 0x82acf098
	if !ctx.cr[0].eq {
	pc = 0x82ACF098; continue 'dispatch;
	}
	// 82ACF07C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ACF080: C01F0130  lfs f0, 0x130(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACF084: C1AB08A4  lfs f13, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACF088: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ACF08C: 4099002C  ble cr6, 0x82acf0b8
	if !ctx.cr[6].gt {
	pc = 0x82ACF0B8; continue 'dispatch;
	}
	// 82ACF090: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82ACF094: D01F0130  stfs f0, 0x130(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 82ACF098: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82ACF09C: 419A000C  beq cr6, 0x82acf0a8
	if ctx.cr[6].eq {
	pc = 0x82ACF0A8; continue 'dispatch;
	}
	// 82ACF0A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACF0A4: 4B7F17ED  bl 0x822c0890
	ctx.lr = 0x82ACF0A8;
	sub_822C0890(ctx, base);
	// 82ACF0A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ACF0AC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82ACF0B0: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82ACF0B4: 486D9104  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
	// 82ACF0B8: 817C001C  lwz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ACF0BC: 815F0120  lwz r10, 0x120(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 82ACF0C0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ACF0C4: 4199FFD4  bgt cr6, 0x82acf098
	if ctx.cr[6].gt {
	pc = 0x82ACF098; continue 'dispatch;
	}
	// 82ACF0C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACF0CC: 4BA42BDD  bl 0x82511ca8
	ctx.lr = 0x82ACF0D0;
	sub_82511CA8(ctx, base);
	// 82ACF0D0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82ACF0D4: 419AFF10  beq cr6, 0x82acefe4
	if ctx.cr[6].eq {
	pc = 0x82ACEFE4; continue 'dispatch;
	}
	// 82ACF0D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACF0DC: 4B7F17B5  bl 0x822c0890
	ctx.lr = 0x82ACF0E0;
	sub_822C0890(ctx, base);
	// 82ACF0E0: 4BFFFF04  b 0x82acefe4
	pc = 0x82ACEFE4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACF0E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACF0E8 size=340
    let mut pc: u32 = 0x82ACF0E8;
    'dispatch: loop {
        match pc {
            0x82ACF0E8 => {
    //   block [0x82ACF0E8..0x82ACF23C)
	// 82ACF0E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACF0EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACF0F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACF0F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACF0F8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82ACF0FC: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACF100: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACF104: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82ACF108: 4BFE18C1  bl 0x82ab09c8
	ctx.lr = 0x82ACF10C;
	sub_82AB09C8(ctx, base);
	// 82ACF10C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82ACF110: 41820110  beq 0x82acf220
	if ctx.cr[0].eq {
	pc = 0x82ACF220; continue 'dispatch;
	}
	// 82ACF114: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82ACF118: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82ACF11C: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82ACF120: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82ACF124: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ACF128: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82ACF12C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACF130: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACF240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACF240 size=132
    let mut pc: u32 = 0x82ACF240;
    'dispatch: loop {
        match pc {
            0x82ACF240 => {
    //   block [0x82ACF240..0x82ACF2C4)
	// 82ACF240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACF244: 486D8F29  bl 0x831a816c
	ctx.lr = 0x82ACF248;
	sub_831A8130(ctx, base);
	// 82ACF248: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82ACF24C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACF250: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ACF254: 3FA0820C  lis r29, -0x7df4
	ctx.r[29].s64 = -2113142784;
	// 82ACF258: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACF25C: C05E0000  lfs f2, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82ACF260: C03DA1DC  lfs f1, -0x5e24(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24100 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACF264: 4BFDF19D  bl 0x82aae400
	ctx.lr = 0x82ACF268;
	sub_82AAE400(ctx, base);
	// 82ACF268: C01DA1DC  lfs f0, -0x5e24(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-24100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACF26C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82ACF270: C05E0000  lfs f2, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82ACF274: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 82ACF278: 4BFDF189  bl 0x82aae400
	ctx.lr = 0x82ACF27C;
	sub_82AAE400(ctx, base);
	// 82ACF27C: 3BDF012C  addi r30, r31, 0x12c
	ctx.r[30].s64 = ctx.r[31].s64 + 300;
	// 82ACF280: FC600890  fmr f3, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[1].f64;
	// 82ACF284: C03F00F4  lfs f1, 0xf4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACF288: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACF28C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82ACF290: 4BFDF3E1  bl 0x82aae670
	ctx.lr = 0x82ACF294;
	sub_82AAE670(ctx, base);
	// 82ACF294: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACF298: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACF29C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACF2A0: 4082000C  bne 0x82acf2ac
	if !ctx.cr[0].eq {
	pc = 0x82ACF2AC; continue 'dispatch;
	}
	// 82ACF2A4: 4BFFFE45  bl 0x82acf0e8
	ctx.lr = 0x82ACF2A8;
	sub_82ACF0E8(ctx, base);
	// 82ACF2A8: 48000010  b 0x82acf2b8
	pc = 0x82ACF2B8; continue 'dispatch;
	// 82ACF2AC: 4BFFFE3D  bl 0x82acf0e8
	ctx.lr = 0x82ACF2B0;
	sub_82ACF0E8(ctx, base);
	// 82ACF2B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ACF2B4: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82ACF2B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ACF2BC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82ACF2C0: 486D8EFC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACF2C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACF2C8 size=236
    let mut pc: u32 = 0x82ACF2C8;
    'dispatch: loop {
        match pc {
            0x82ACF2C8 => {
    //   block [0x82ACF2C8..0x82ACF3B4)
	// 82ACF2C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACF2CC: 486D8E9D  bl 0x831a8168
	ctx.lr = 0x82ACF2D0;
	sub_831A8130(ctx, base);
	// 82ACF2D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACF2D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACF2D8: 4BFE16F1  bl 0x82ab09c8
	ctx.lr = 0x82ACF2DC;
	sub_82AB09C8(ctx, base);
	// 82ACF2DC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82ACF2E0: 418200CC  beq 0x82acf3ac
	if ctx.cr[0].eq {
	pc = 0x82ACF3AC; continue 'dispatch;
	}
	// 82ACF2E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACF2E8: 4BFE0E39  bl 0x82ab0120
	ctx.lr = 0x82ACF2EC;
	sub_82AB0120(ctx, base);
	// 82ACF2EC: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ACF2F0: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ACF2F4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82ACF2F8: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82ACF2FC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82ACF300: 419A0024  beq cr6, 0x82acf324
	if ctx.cr[6].eq {
	pc = 0x82ACF324; continue 'dispatch;
	}
	// 82ACF304: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82ACF308: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ACF30C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACF310: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ACF314: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ACF318: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ACF31C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACF320: 4082FFE8  bne 0x82acf308
	if !ctx.cr[0].eq {
	pc = 0x82ACF308; continue 'dispatch;
	}
	// 82ACF324: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACF328: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82ACF32C: 388BA240  addi r4, r11, -0x5dc0
	ctx.r[4].s64 = ctx.r[11].s64 + -24000;
	// 82ACF330: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82ACF334: 38A00234  li r5, 0x234
	ctx.r[5].s64 = 564;
	// 82ACF338: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82ACF33C: 48387CAD  bl 0x82e56fe8
	ctx.lr = 0x82ACF340;
	sub_82E56FE8(ctx, base);
	// 82ACF340: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82ACF344: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82ACF348: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 82ACF34C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACF350: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82ACF354: 557FDFFE  rlwinm r31, r11, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82ACF358: 419A0008  beq cr6, 0x82acf360
	if ctx.cr[6].eq {
	pc = 0x82ACF360; continue 'dispatch;
	}
	// 82ACF35C: 4B7F1535  bl 0x822c0890
	ctx.lr = 0x82ACF360;
	sub_822C0890(ctx, base);
	// 82ACF360: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACF364: 40820038  bne 0x82acf39c
	if !ctx.cr[0].eq {
	pc = 0x82ACF39C; continue 'dispatch;
	}
	// 82ACF368: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ACF36C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82ACF370: 409A000C  bne cr6, 0x82acf37c
	if !ctx.cr[6].eq {
	pc = 0x82ACF37C; continue 'dispatch;
	}
	// 82ACF374: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACF378: 4BA41259  bl 0x825105d0
	ctx.lr = 0x82ACF37C;
	sub_825105D0(ctx, base);
	// 82ACF37C: 817E011C  lwz r11, 0x11c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(284 as u32) ) } as u64;
	// 82ACF380: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACF384: 409A0018  bne cr6, 0x82acf39c
	if !ctx.cr[6].eq {
	pc = 0x82ACF39C; continue 'dispatch;
	}
	// 82ACF388: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ACF38C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82ACF390: 409A000C  bne cr6, 0x82acf39c
	if !ctx.cr[6].eq {
	pc = 0x82ACF39C; continue 'dispatch;
	}
	// 82ACF394: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACF398: 4BA41239  bl 0x825105d0
	ctx.lr = 0x82ACF39C;
	sub_825105D0(ctx, base);
	// 82ACF39C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82ACF3A0: 419A000C  beq cr6, 0x82acf3ac
	if ctx.cr[6].eq {
	pc = 0x82ACF3AC; continue 'dispatch;
	}
	// 82ACF3A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ACF3A8: 4B7F14E9  bl 0x822c0890
	ctx.lr = 0x82ACF3AC;
	sub_822C0890(ctx, base);
	// 82ACF3AC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82ACF3B0: 486D8E08  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACF3B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACF3B8 size=208
    let mut pc: u32 = 0x82ACF3B8;
    'dispatch: loop {
        match pc {
            0x82ACF3B8 => {
    //   block [0x82ACF3B8..0x82ACF488)
	// 82ACF3B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACF3BC: 486D8DAD  bl 0x831a8168
	ctx.lr = 0x82ACF3C0;
	sub_831A8130(ctx, base);
	// 82ACF3C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACF3C4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82ACF3C8: 4BFE1601  bl 0x82ab09c8
	ctx.lr = 0x82ACF3CC;
	sub_82AB09C8(ctx, base);
	// 82ACF3CC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82ACF3D0: 418200B0  beq 0x82acf480
	if ctx.cr[0].eq {
	pc = 0x82ACF480; continue 'dispatch;
	}
	// 82ACF3D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACF3D8: 4BFE0D49  bl 0x82ab0120
	ctx.lr = 0x82ACF3DC;
	sub_82AB0120(ctx, base);
	// 82ACF3DC: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ACF3E0: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ACF3E4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82ACF3E8: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82ACF3EC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82ACF3F0: 419A0024  beq cr6, 0x82acf414
	if ctx.cr[6].eq {
	pc = 0x82ACF414; continue 'dispatch;
	}
	// 82ACF3F4: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82ACF3F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ACF3FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACF400: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ACF404: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ACF408: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ACF40C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACF410: 4082FFE8  bne 0x82acf3f8
	if !ctx.cr[0].eq {
	pc = 0x82ACF3F8; continue 'dispatch;
	}
	// 82ACF414: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACF418: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82ACF41C: 388BA240  addi r4, r11, -0x5dc0
	ctx.r[4].s64 = ctx.r[11].s64 + -24000;
	// 82ACF420: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82ACF424: 38A0024F  li r5, 0x24f
	ctx.r[5].s64 = 591;
	// 82ACF428: 387D0028  addi r3, r29, 0x28
	ctx.r[3].s64 = ctx.r[29].s64 + 40;
	// 82ACF42C: 48387BBD  bl 0x82e56fe8
	ctx.lr = 0x82ACF430;
	sub_82E56FE8(ctx, base);
	// 82ACF430: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82ACF434: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82ACF438: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 82ACF43C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACF440: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82ACF444: 557FDFFE  rlwinm r31, r11, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82ACF448: 419A0008  beq cr6, 0x82acf450
	if ctx.cr[6].eq {
	pc = 0x82ACF450; continue 'dispatch;
	}
	// 82ACF44C: 4B7F1445  bl 0x822c0890
	ctx.lr = 0x82ACF450;
	sub_822C0890(ctx, base);
	// 82ACF450: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACF454: 4082001C  bne 0x82acf470
	if !ctx.cr[0].eq {
	pc = 0x82ACF470; continue 'dispatch;
	}
	// 82ACF458: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ACF45C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACF460: 409A0010  bne cr6, 0x82acf470
	if !ctx.cr[6].eq {
	pc = 0x82ACF470; continue 'dispatch;
	}
	// 82ACF464: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACF468: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ACF46C: 4BA406D5  bl 0x8250fb40
	ctx.lr = 0x82ACF470;
	sub_8250FB40(ctx, base);
	// 82ACF470: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82ACF474: 419A000C  beq cr6, 0x82acf480
	if ctx.cr[6].eq {
	pc = 0x82ACF480; continue 'dispatch;
	}
	// 82ACF478: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACF47C: 4B7F1415  bl 0x822c0890
	ctx.lr = 0x82ACF480;
	sub_822C0890(ctx, base);
	// 82ACF480: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82ACF484: 486D8D34  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACF488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACF488 size=596
    let mut pc: u32 = 0x82ACF488;
    'dispatch: loop {
        match pc {
            0x82ACF488 => {
    //   block [0x82ACF488..0x82ACF6DC)
	// 82ACF488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACF48C: 486D8CE1  bl 0x831a816c
	ctx.lr = 0x82ACF490;
	sub_831A8130(ctx, base);
	// 82ACF490: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82ACF494: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACF498: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACF49C: 817E011C  lwz r11, 0x11c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(284 as u32) ) } as u64;
	// 82ACF4A0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ACF4A4: 409A022C  bne cr6, 0x82acf6d0
	if !ctx.cr[6].eq {
	pc = 0x82ACF6D0; continue 'dispatch;
	}
	// 82ACF4A8: 4BFE1521  bl 0x82ab09c8
	ctx.lr = 0x82ACF4AC;
	sub_82AB09C8(ctx, base);
	// 82ACF4AC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82ACF4B0: 41820220  beq 0x82acf6d0
	if ctx.cr[0].eq {
	pc = 0x82ACF6D0; continue 'dispatch;
	}
	// 82ACF4B4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82ACF4B8: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82ACF4BC: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82ACF4C0: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 82ACF4C4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82ACF4C8: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82ACF4CC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82ACF4D0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACF6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACF6E0 size=504
    let mut pc: u32 = 0x82ACF6E0;
    'dispatch: loop {
        match pc {
            0x82ACF6E0 => {
    //   block [0x82ACF6E0..0x82ACF8D8)
	// 82ACF6E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACF6E4: 486D8A89  bl 0x831a816c
	ctx.lr = 0x82ACF6E8;
	sub_831A8130(ctx, base);
	// 82ACF6E8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACF6EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACF6F0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82ACF6F4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82ACF6F8: 4BA422E1  bl 0x825119d8
	ctx.lr = 0x82ACF6FC;
	sub_825119D8(ctx, base);
	// 82ACF6FC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82ACF700: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACF704: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82ACF708: 48324301  bl 0x82df3a08
	ctx.lr = 0x82ACF70C;
	sub_82DF3A08(ctx, base);
	// 82ACF70C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACF710: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ACF714: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ACF718: 4BA39069  bl 0x82508780
	ctx.lr = 0x82ACF71C;
	sub_82508780(ctx, base);
	// 82ACF71C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACF720: 48323D09  bl 0x82df3428
	ctx.lr = 0x82ACF724;
	sub_82DF3428(ctx, base);
	// 82ACF724: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82ACF728: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACF72C: 808BE268  lwz r4, -0x1d98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7576 as u32) ) } as u64;
	// 82ACF730: 483242D9  bl 0x82df3a08
	ctx.lr = 0x82ACF734;
	sub_82DF3A08(ctx, base);
	// 82ACF734: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ACF738: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ACF73C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACF740: 4BA39041  bl 0x82508780
	ctx.lr = 0x82ACF744;
	sub_82508780(ctx, base);
	// 82ACF744: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACF748: 48323CE1  bl 0x82df3428
	ctx.lr = 0x82ACF74C;
	sub_82DF3428(ctx, base);
	// 82ACF74C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ACF750: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82ACF754: 409A0008  bne cr6, 0x82acf75c
	if !ctx.cr[6].eq {
	pc = 0x82ACF75C; continue 'dispatch;
	}
	// 82ACF758: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACF75C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACF760: 4BA39041  bl 0x825087a0
	ctx.lr = 0x82ACF764;
	sub_825087A0(ctx, base);
	// 82ACF764: 397F0144  addi r11, r31, 0x144
	ctx.r[11].s64 = ctx.r[31].s64 + 324;
	// 82ACF768: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 82ACF76C: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82ACF770: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACF774: 917F0144  stw r11, 0x144(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), ctx.r[11].u32 ) };
	// 82ACF778: 4B7F4CE9  bl 0x822c4460
	ctx.lr = 0x82ACF77C;
	sub_822C4460(ctx, base);
	// 82ACF77C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACF780: 4BFFF751  bl 0x82aceed0
	ctx.lr = 0x82ACF784;
	sub_82ACEED0(ctx, base);
	// 82ACF784: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82ACF788: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACF78C: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 82ACF790: 483AC849  bl 0x82e7bfd8
	ctx.lr = 0x82ACF794;
	sub_82E7BFD8(ctx, base);
	// 82ACF794: C03F0114  lfs f1, 0x114(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACF798: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACF79C: FC600890  fmr f3, f1
	ctx.f[3].f64 = ctx.f[1].f64;
	// 82ACF7A0: FC400890  fmr f2, f1
	ctx.f[2].f64 = ctx.f[1].f64;
	// 82ACF7A4: 483AC3E5  bl 0x82e7bb88
	ctx.lr = 0x82ACF7A8;
	sub_82E7BB88(ctx, base);
	// 82ACF7A8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACF7AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ACF7B0: 388BA240  addi r4, r11, -0x5dc0
	ctx.r[4].s64 = ctx.r[11].s64 + -24000;
	// 82ACF7B4: 38A000A5  li r5, 0xa5
	ctx.r[5].s64 = 165;
	// 82ACF7B8: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82ACF7BC: 48322C2D  bl 0x82df23e8
	ctx.lr = 0x82ACF7C0;
	sub_82DF23E8(ctx, base);
	// 82ACF7C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACF7C4: 41820014  beq 0x82acf7d8
	if ctx.cr[0].eq {
	pc = 0x82ACF7D8; continue 'dispatch;
	}
	// 82ACF7C8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82ACF7CC: 48343925  bl 0x82e130f0
	ctx.lr = 0x82ACF7D0;
	sub_82E130F0(ctx, base);
	// 82ACF7D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACF7D4: 48000008  b 0x82acf7dc
	pc = 0x82ACF7DC; continue 'dispatch;
	// 82ACF7D8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ACF7DC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82ACF7E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ACF7E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82ACF7E8: 4B811831  bl 0x822e1018
	ctx.lr = 0x82ACF7EC;
	sub_822E1018(ctx, base);
	// 82ACF7EC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ACF7F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ACF7F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82ACF7F8: 4B7F0809  bl 0x822c0000
	ctx.lr = 0x82ACF7FC;
	sub_822C0000(ctx, base);
	// 82ACF7FC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ACF800: 3BDF014C  addi r30, r31, 0x14c
	ctx.r[30].s64 = ctx.r[31].s64 + 332;
	// 82ACF804: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82ACF808: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82ACF80C: 917F014C  stw r11, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[11].u32 ) };
	// 82ACF810: 4B7F4C51  bl 0x822c4460
	ctx.lr = 0x82ACF814;
	sub_822C4460(ctx, base);
	// 82ACF814: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82ACF818: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACF81C: 419A0008  beq cr6, 0x82acf824
	if ctx.cr[6].eq {
	pc = 0x82ACF824; continue 'dispatch;
	}
	// 82ACF820: 4B7F1071  bl 0x822c0890
	ctx.lr = 0x82ACF824;
	sub_822C0890(ctx, base);
	// 82ACF824: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACF828: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACF82C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACF830: 4BA428E9  bl 0x82512118
	ctx.lr = 0x82ACF834;
	sub_82512118(ctx, base);
	// 82ACF834: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ACF838: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACF83C: 483435F5  bl 0x82e12e30
	ctx.lr = 0x82ACF840;
	sub_82E12E30(ctx, base);
	// 82ACF840: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ACF844: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACF848: 419A0008  beq cr6, 0x82acf850
	if ctx.cr[6].eq {
	pc = 0x82ACF850; continue 'dispatch;
	}
	// 82ACF84C: 4B7F1045  bl 0x822c0890
	ctx.lr = 0x82ACF850;
	sub_822C0890(ctx, base);
	// 82ACF850: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ACF854: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACF858: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACF85C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ACF860: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82ACF864: 419A0024  beq cr6, 0x82acf888
	if ctx.cr[6].eq {
	pc = 0x82ACF888; continue 'dispatch;
	}
	// 82ACF868: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ACF86C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ACF870: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACF874: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ACF878: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ACF87C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ACF880: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACF884: 4082FFE8  bne 0x82acf86c
	if !ctx.cr[0].eq {
	pc = 0x82ACF86C; continue 'dispatch;
	}
	// 82ACF888: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ACF88C: 807F013C  lwz r3, 0x13c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 82ACF890: 48345821  bl 0x82e150b0
	ctx.lr = 0x82ACF894;
	sub_82E150B0(ctx, base);
	// 82ACF894: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACF898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACF89C: 4BA402A5  bl 0x8250fb40
	ctx.lr = 0x82ACF8A0;
	sub_8250FB40(ctx, base);
	// 82ACF8A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACF8A4: 4BFFF47D  bl 0x82aced20
	ctx.lr = 0x82ACF8A8;
	sub_82ACED20(ctx, base);
	// 82ACF8A8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACF8AC: 815F00EC  lwz r10, 0xec(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82ACF8B0: C01F0114  lfs f0, 0x114(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACF8B4: 396BA1F0  addi r11, r11, -0x5e10
	ctx.r[11].s64 = ctx.r[11].s64 + -24080;
	// 82ACF8B8: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 * 20;
	// 82ACF8BC: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82ACF8C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACF8C4: 7DAA5C2E  lfsx f13, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACF8C8: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ACF8CC: 4BA430CD  bl 0x82512998
	ctx.lr = 0x82ACF8D0;
	sub_82512998(ctx, base);
	// 82ACF8D0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82ACF8D4: 486D88E8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACF8D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACF8D8 size=68
    let mut pc: u32 = 0x82ACF8D8;
    'dispatch: loop {
        match pc {
            0x82ACF8D8 => {
    //   block [0x82ACF8D8..0x82ACF91C)
	// 82ACF8D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACF8DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACF8E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACF8E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACF8E8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ACF8EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACF8F0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82ACF8F4: 38BF013C  addi r5, r31, 0x13c
	ctx.r[5].s64 = ctx.r[31].s64 + 316;
	// 82ACF8F8: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82ACF8FC: 4BA408F5  bl 0x825101f0
	ctx.lr = 0x82ACF900;
	sub_825101F0(ctx, base);
	// 82ACF900: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACF904: 4BFFF5CD  bl 0x82aceed0
	ctx.lr = 0x82ACF908;
	sub_82ACEED0(ctx, base);
	// 82ACF908: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ACF90C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACF910: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACF914: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACF918: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACF920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACF920 size=84
    let mut pc: u32 = 0x82ACF920;
    'dispatch: loop {
        match pc {
            0x82ACF920 => {
    //   block [0x82ACF920..0x82ACF974)
	// 82ACF920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACF924: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACF928: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACF92C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACF930: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACF934: 4BA42355  bl 0x82511c88
	ctx.lr = 0x82ACF938;
	sub_82511C88(ctx, base);
	// 82ACF938: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACF93C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACF940: 4BA40201  bl 0x8250fb40
	ctx.lr = 0x82ACF944;
	sub_8250FB40(ctx, base);
	// 82ACF944: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ACF948: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82ACF94C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACF950: 915F00E8  stw r10, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[10].u32 ) };
	// 82ACF954: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACF958: D03F012C  stfs f1, 0x12c(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82ACF95C: 4BFFF78D  bl 0x82acf0e8
	ctx.lr = 0x82ACF960;
	sub_82ACF0E8(ctx, base);
	// 82ACF960: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ACF964: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACF968: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACF96C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACF970: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACF978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACF978 size=476
    let mut pc: u32 = 0x82ACF978;
    'dispatch: loop {
        match pc {
            0x82ACF978 => {
    //   block [0x82ACF978..0x82ACFB54)
	// 82ACF978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACF97C: 486D87F1  bl 0x831a816c
	ctx.lr = 0x82ACF980;
	sub_831A8130(ctx, base);
	// 82ACF980: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACF984: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACF988: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ACF98C: 4BA40D7D  bl 0x82510708
	ctx.lr = 0x82ACF990;
	sub_82510708(ctx, base);
	// 82ACF990: 897F0118  lbz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82ACF994: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACF998: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACF99C: 41820010  beq 0x82acf9ac
	if ctx.cr[0].eq {
	pc = 0x82ACF9AC; continue 'dispatch;
	}
	// 82ACF9A0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ACF9A4: 4BFFFAE5  bl 0x82acf488
	ctx.lr = 0x82ACF9A8;
	sub_82ACF488(ctx, base);
	// 82ACF9A8: 480001A4  b 0x82acfb4c
	pc = 0x82ACFB4C; continue 'dispatch;
	// 82ACF9AC: 4BFFEE2D  bl 0x82ace7d8
	ctx.lr = 0x82ACF9B0;
	sub_82ACE7D8(ctx, base);
	// 82ACF9B0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACF9B4: 40820198  bne 0x82acfb4c
	if !ctx.cr[0].eq {
	pc = 0x82ACFB4C; continue 'dispatch;
	}
	// 82ACF9B8: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82ACF9BC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ACF9C0: 419800B4  blt cr6, 0x82acfa74
	if ctx.cr[6].lt {
	pc = 0x82ACFA74; continue 'dispatch;
	}
	// 82ACF9C4: 419A0098  beq cr6, 0x82acfa5c
	if ctx.cr[6].eq {
	pc = 0x82ACFA5C; continue 'dispatch;
	}
	// 82ACF9C8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82ACF9CC: 41980058  blt cr6, 0x82acfa24
	if ctx.cr[6].lt {
	pc = 0x82ACFA24; continue 'dispatch;
	}
	// 82ACF9D0: 419A003C  beq cr6, 0x82acfa0c
	if ctx.cr[6].eq {
	pc = 0x82ACFA0C; continue 'dispatch;
	}
	// 82ACF9D4: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82ACF9D8: 40980158  bge cr6, 0x82acfb30
	if !ctx.cr[6].lt {
	pc = 0x82ACFB30; continue 'dispatch;
	}
	// 82ACF9DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ACF9E0: C01F0130  lfs f0, 0x130(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACF9E4: C1AB08A4  lfs f13, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACF9E8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ACF9EC: 41990010  bgt cr6, 0x82acf9fc
	if ctx.cr[6].gt {
	pc = 0x82ACF9FC; continue 'dispatch;
	}
	// 82ACF9F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACF9F4: 4BA40BDD  bl 0x825105d0
	ctx.lr = 0x82ACF9F8;
	sub_825105D0(ctx, base);
	// 82ACF9F8: 48000138  b 0x82acfb30
	pc = 0x82ACFB30; continue 'dispatch;
	// 82ACF9FC: C1BD0000  lfs f13, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACFA00: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ACFA04: D01F0130  stfs f0, 0x130(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 82ACFA08: 48000128  b 0x82acfb30
	pc = 0x82ACFB30; continue 'dispatch;
	// 82ACFA0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACFA10: 4BFFED41  bl 0x82ace750
	ctx.lr = 0x82ACFA14;
	sub_82ACE750(ctx, base);
	// 82ACFA14: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ACFA18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACFA1C: 4BFFF825  bl 0x82acf240
	ctx.lr = 0x82ACFA20;
	sub_82ACF240(ctx, base);
	// 82ACFA20: 48000110  b 0x82acfb30
	pc = 0x82ACFB30; continue 'dispatch;
	// 82ACFA24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACFA28: C03D0000  lfs f1, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACFA2C: 4BFFF595  bl 0x82acefc0
	ctx.lr = 0x82ACFA30;
	sub_82ACEFC0(ctx, base);
	// 82ACFA30: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ACFA34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACFA38: 41820018  beq 0x82acfa50
	if ctx.cr[0].eq {
	pc = 0x82ACFA50; continue 'dispatch;
	}
	// 82ACFA3C: 889F0138  lbz r4, 0x138(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82ACFA40: 4BA40101  bl 0x8250fb40
	ctx.lr = 0x82ACFA44;
	sub_8250FB40(ctx, base);
	// 82ACFA44: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82ACFA48: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82ACFA4C: 480000E4  b 0x82acfb30
	pc = 0x82ACFB30; continue 'dispatch;
	// 82ACFA50: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACFA54: 4BA400ED  bl 0x8250fb40
	ctx.lr = 0x82ACFA58;
	sub_8250FB40(ctx, base);
	// 82ACFA58: 480000D8  b 0x82acfb30
	pc = 0x82ACFB30; continue 'dispatch;
	// 82ACFA5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACFA60: 889F0138  lbz r4, 0x138(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 82ACFA64: 4BA400DD  bl 0x8250fb40
	ctx.lr = 0x82ACFA68;
	sub_8250FB40(ctx, base);
	// 82ACFA68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACFA6C: 4BFFECE5  bl 0x82ace750
	ctx.lr = 0x82ACFA70;
	sub_82ACE750(ctx, base);
	// 82ACFA70: 480000C0  b 0x82acfb30
	pc = 0x82ACFB30; continue 'dispatch;
	// 82ACFA74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACFA78: 4BA42071  bl 0x82511ae8
	ctx.lr = 0x82ACFA7C;
	sub_82511AE8(ctx, base);
	// 82ACFA7C: 3BDF00F0  addi r30, r31, 0xf0
	ctx.r[30].s64 = ctx.r[31].s64 + 240;
	// 82ACFA80: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACFB58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACFB58 size=332
    let mut pc: u32 = 0x82ACFB58;
    'dispatch: loop {
        match pc {
            0x82ACFB58 => {
    //   block [0x82ACFB58..0x82ACFCA4)
	// 82ACFB58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACFB5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ACFB60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ACFB64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ACFB68: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACFB6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACFB70: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82ACFB74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACFB78: 4BA3F951  bl 0x8250f4c8
	ctx.lr = 0x82ACFB7C;
	sub_8250F4C8(ctx, base);
	// 82ACFB7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ACFB80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACFB84: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82ACFB88: 409A0008  bne cr6, 0x82acfb90
	if !ctx.cr[6].eq {
	pc = 0x82ACFB90; continue 'dispatch;
	}
	// 82ACFB8C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACFB90: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACFB94: 4BA3ADBD  bl 0x8250a950
	ctx.lr = 0x82ACFB98;
	sub_8250A950(ctx, base);
	// 82ACFB98: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82ACFB9C: 483220F5  bl 0x82df1c90
	ctx.lr = 0x82ACFBA0;
	sub_82DF1C90(ctx, base);
	// 82ACFBA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACFBA4: 4BA41F45  bl 0x82511ae8
	ctx.lr = 0x82ACFBA8;
	sub_82511AE8(ctx, base);
	// 82ACFBA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82ACFBAC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82ACFBB0: 483AC429  bl 0x82e7bfd8
	ctx.lr = 0x82ACFBB4;
	sub_82E7BFD8(ctx, base);
	// 82ACFBB4: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82ACFBB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACFBBC: 808B0AAC  lwz r4, 0xaac(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2732 as u32) ) } as u64;
	// 82ACFBC0: 48323E49  bl 0x82df3a08
	ctx.lr = 0x82ACFBC4;
	sub_82DF3A08(ctx, base);
	// 82ACFBC4: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82ACFBC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACFBCC: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 82ACFBD0: 409A0008  bne cr6, 0x82acfbd8
	if !ctx.cr[6].eq {
	pc = 0x82ACFBD8; continue 'dispatch;
	}
	// 82ACFBD4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ACFBD8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82ACFBDC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82ACFBE0: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82ACFBE4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ACFBE8: 4BD05231  bl 0x827d4e18
	ctx.lr = 0x82ACFBEC;
	sub_827D4E18(ctx, base);
	// 82ACFBEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ACFBF0: 48323839  bl 0x82df3428
	ctx.lr = 0x82ACFBF4;
	sub_82DF3428(ctx, base);
	// 82ACFBF4: 3D40832F  lis r10, -0x7cd1
	ctx.r[10].s64 = -2094071808;
	// 82ACFBF8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACFBFC: C1BF0114  lfs f13, 0x114(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ACFC00: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ACFC04: 3BCBA1E4  addi r30, r11, -0x5e1c
	ctx.r[30].s64 = ctx.r[11].s64 + -24092;
	// 82ACFC08: C00AE9A0  lfs f0, -0x1660(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-5728 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACFC0C: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 82ACFC10: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82ACFC14: 815F00EC  lwz r10, 0xec(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82ACFC18: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 * 20;
	// 82ACFC1C: 7D8A5C2E  lfsx f12, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ACFC20: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ACFC24: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ACFC28: 483B18C9  bl 0x82e814f0
	ctx.lr = 0x82ACFC2C;
	sub_82E814F0(ctx, base);
	// 82ACFC2C: 817F011C  lwz r11, 0x11c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 82ACFC30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACFC34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ACFC38: 409A0030  bne cr6, 0x82acfc68
	if !ctx.cr[6].eq {
	pc = 0x82ACFC68; continue 'dispatch;
	}
	// 82ACFC3C: 4BA42F3D  bl 0x82512b78
	ctx.lr = 0x82ACFC40;
	sub_82512B78(ctx, base);
	// 82ACFC40: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ACFC44: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82ACFC48: 38BF013C  addi r5, r31, 0x13c
	ctx.r[5].s64 = ctx.r[31].s64 + 316;
	// 82ACFC4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ACFC50: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82ACFC54: 4BA4059D  bl 0x825101f0
	ctx.lr = 0x82ACFC58;
	sub_825101F0(ctx, base);
	// 82ACFC58: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82ACFC5C: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACFC60: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82ACFC64: 4800000C  b 0x82acfc70
	pc = 0x82ACFC70; continue 'dispatch;
	// 82ACFC68: 4BFFFCB9  bl 0x82acf920
	ctx.lr = 0x82ACFC6C;
	sub_82ACF920(ctx, base);
	// 82ACFC6C: C01F0128  lfs f0, 0x128(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACFC70: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ACFC74: D01F0130  stfs f0, 0x130(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 82ACFC78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACFC7C: 419A0008  beq cr6, 0x82acfc84
	if ctx.cr[6].eq {
	pc = 0x82ACFC84; continue 'dispatch;
	}
	// 82ACFC80: 4B7F0C11  bl 0x822c0890
	ctx.lr = 0x82ACFC84;
	sub_822C0890(ctx, base);
	// 82ACFC84: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACFC88: 48322009  bl 0x82df1c90
	ctx.lr = 0x82ACFC8C;
	sub_82DF1C90(ctx, base);
	// 82ACFC8C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82ACFC90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ACFC94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ACFC98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ACFC9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ACFCA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACFCA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACFCA8 size=424
    let mut pc: u32 = 0x82ACFCA8;
    'dispatch: loop {
        match pc {
            0x82ACFCA8 => {
    //   block [0x82ACFCA8..0x82ACFE50)
	// 82ACFCA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACFCAC: 486D84BD  bl 0x831a8168
	ctx.lr = 0x82ACFCB0;
	sub_831A8130(ctx, base);
	// 82ACFCB0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACFCB4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACFCB8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82ACFCBC: 3BCBA240  addi r30, r11, -0x5dc0
	ctx.r[30].s64 = ctx.r[11].s64 + -24000;
	// 82ACFCC0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ACFCC4: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 82ACFCC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ACFCCC: 38600160  li r3, 0x160
	ctx.r[3].s64 = 352;
	// 82ACFCD0: 48322719  bl 0x82df23e8
	ctx.lr = 0x82ACFCD4;
	sub_82DF23E8(ctx, base);
	// 82ACFCD4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACFCD8: 41820010  beq 0x82acfce8
	if ctx.cr[0].eq {
	pc = 0x82ACFCE8; continue 'dispatch;
	}
	// 82ACFCDC: 4BFFEDBD  bl 0x82acea98
	ctx.lr = 0x82ACFCE0;
	sub_82ACEA98(ctx, base);
	// 82ACFCE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACFCE4: 48000008  b 0x82acfcec
	pc = 0x82ACFCEC; continue 'dispatch;
	// 82ACFCE8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ACFCEC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82ACFCF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACFCF4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82ACFCF8: 4BFFEBC9  bl 0x82ace8c0
	ctx.lr = 0x82ACFCFC;
	sub_82ACE8C0(ctx, base);
	// 82ACFCFC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ACFD00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACFD04: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82ACFD08: 4B7F02F9  bl 0x822c0000
	ctx.lr = 0x82ACFD0C;
	sub_822C0000(ctx, base);
	// 82ACFD0C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ACFD10: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82ACFD14: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 82ACFD18: 409A0008  bne cr6, 0x82acfd20
	if !ctx.cr[6].eq {
	pc = 0x82ACFD20; continue 'dispatch;
	}
	// 82ACFD1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ACFD20: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82ACFD24: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82ACFD28: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82ACFD2C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82ACFD30: 419A0024  beq cr6, 0x82acfd54
	if ctx.cr[6].eq {
	pc = 0x82ACFD54; continue 'dispatch;
	}
	// 82ACFD34: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82ACFD38: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82ACFD3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACFD40: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82ACFD44: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ACFD48: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ACFD4C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACFD50: 4082FFE8  bne 0x82acfd38
	if !ctx.cr[0].eq {
	pc = 0x82ACFD38; continue 'dispatch;
	}
	// 82ACFD54: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82ACFD58: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82ACFD5C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82ACFD60: 419A0024  beq cr6, 0x82acfd84
	if ctx.cr[6].eq {
	pc = 0x82ACFD84; continue 'dispatch;
	}
	// 82ACFD64: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82ACFD68: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82ACFD6C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACFD70: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82ACFD74: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ACFD78: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82ACFD7C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82ACFD80: 4082FFE8  bne 0x82acfd68
	if !ctx.cr[0].eq {
	pc = 0x82ACFD68; continue 'dispatch;
	}
	// 82ACFD84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ACFD88: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82ACFD8C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ACFD90: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 82ACFD94: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82ACFD98: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82ACFD9C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ACFDA0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82ACFDA4: 4BCC918D  bl 0x82798f30
	ctx.lr = 0x82ACFDA8;
	sub_82798F30(ctx, base);
	// 82ACFDA8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82ACFDAC: 3D40832F  lis r10, -0x7cd1
	ctx.r[10].s64 = -2094071808;
	// 82ACFDB0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ACFDB4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ACFDB8: 38A0006A  li r5, 0x6a
	ctx.r[5].s64 = 106;
	// 82ACFDBC: C00BA1D4  lfs f0, -0x5e2c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACFDC0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82ACFDC4: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82ACFDC8: C00A0AB4  lfs f0, 0xab4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2740 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ACFDCC: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82ACFDD0: 4B7F0609  bl 0x822c03d8
	ctx.lr = 0x82ACFDD4;
	sub_822C03D8(ctx, base);
	// 82ACFDD4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ACFDD8: 41820014  beq 0x82acfdec
	if ctx.cr[0].eq {
	pc = 0x82ACFDEC; continue 'dispatch;
	}
	// 82ACFDDC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82ACFDE0: 4BCCB889  bl 0x8279b668
	ctx.lr = 0x82ACFDE4;
	sub_8279B668(ctx, base);
	// 82ACFDE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACFDE8: 48000008  b 0x82acfdf0
	pc = 0x82ACFDF0; continue 'dispatch;
	// 82ACFDEC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ACFDF0: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ACFDF4: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82ACFDF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACFDFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACFE00: 4BAC7E51  bl 0x82597c50
	ctx.lr = 0x82ACFE04;
	sub_82597C50(ctx, base);
	// 82ACFE04: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ACFE08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ACFE0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ACFE10: 4B7F01F1  bl 0x822c0000
	ctx.lr = 0x82ACFE14;
	sub_822C0000(ctx, base);
	// 82ACFE14: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ACFE18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACFE1C: 419A0008  beq cr6, 0x82acfe24
	if ctx.cr[6].eq {
	pc = 0x82ACFE24; continue 'dispatch;
	}
	// 82ACFE20: 4B7F0A71  bl 0x822c0890
	ctx.lr = 0x82ACFE24;
	sub_822C0890(ctx, base);
	// 82ACFE24: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82ACFE28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ACFE2C: 419A0008  beq cr6, 0x82acfe34
	if ctx.cr[6].eq {
	pc = 0x82ACFE34; continue 'dispatch;
	}
	// 82ACFE30: 4B7F0A61  bl 0x822c0890
	ctx.lr = 0x82ACFE34;
	sub_822C0890(ctx, base);
	// 82ACFE34: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82ACFE38: 419A000C  beq cr6, 0x82acfe44
	if ctx.cr[6].eq {
	pc = 0x82ACFE44; continue 'dispatch;
	}
	// 82ACFE3C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ACFE40: 4B7F0A51  bl 0x822c0890
	ctx.lr = 0x82ACFE44;
	sub_822C0890(ctx, base);
	// 82ACFE44: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ACFE48: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82ACFE4C: 486D836C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACFE50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ACFE50 size=392
    let mut pc: u32 = 0x82ACFE50;
    'dispatch: loop {
        match pc {
            0x82ACFE50 => {
    //   block [0x82ACFE50..0x82ACFFD8)
	// 82ACFE50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACFE54: 486D8315  bl 0x831a8168
	ctx.lr = 0x82ACFE58;
	sub_831A8130(ctx, base);
	// 82ACFE58: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACFE5C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ACFE60: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82ACFE64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ACFE68: 815D0018  lwz r10, 0x18(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ACFE6C: 816BE688  lwz r11, -0x1978(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6520 as u32) ) } as u64;
	// 82ACFE70: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ACFE74: 409A015C  bne cr6, 0x82acffd0
	if !ctx.cr[6].eq {
	pc = 0x82ACFFD0; continue 'dispatch;
	}
	// 82ACFE78: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82ACFE7C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82ACFE80: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82ACFE84: 3BC10070  addi r30, r1, 0x70
	ctx.r[30].s64 = ctx.r[1].s64 + 112;
	// 82ACFE88: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ACFFD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ACFFD8 size=128
    let mut pc: u32 = 0x82ACFFD8;
    'dispatch: loop {
        match pc {
            0x82ACFFD8 => {
    //   block [0x82ACFFD8..0x82AD0058)
	// 82ACFFD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ACFFDC: 486D8191  bl 0x831a816c
	ctx.lr = 0x82ACFFE0;
	sub_831A8130(ctx, base);
	// 82ACFFE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ACFFE4: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82ACFFE8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82ACFFEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ACFFF0: 3BEBE67C  addi r31, r11, -0x1984
	ctx.r[31].s64 = ctx.r[11].s64 + -6532;
	// 82ACFFF4: 816AE684  lwz r11, -0x197c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6524 as u32) ) } as u64;
	// 82ACFFF8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82ACFFFC: 40820024  bne 0x82ad0020
	if !ctx.cr[0].eq {
	pc = 0x82AD0020; continue 'dispatch;
	}
	// 82AD0000: 3D208289  lis r9, -0x7d77
	ctx.r[9].s64 = -2104950784;
	// 82AD0004: 3D0082AD  lis r8, -0x7d53
	ctx.r[8].s64 = -2102591488;
	// 82AD0008: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82AD000C: 392990C8  addi r9, r9, -0x6f38
	ctx.r[9].s64 = ctx.r[9].s64 + -28472;
	// 82AD0010: 3908EA50  addi r8, r8, -0x15b0
	ctx.r[8].s64 = ctx.r[8].s64 + -5552;
	// 82AD0014: 916AE684  stw r11, -0x197c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-6524 as u32), ctx.r[11].u32 ) };
	// 82AD0018: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82AD001C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82AD0020: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82AD0024: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82AD0028: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD002C: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82AD0030: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82AD0034: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AD0038: 4BB84589  bl 0x826545c0
	ctx.lr = 0x82AD003C;
	sub_826545C0(ctx, base);
	// 82AD003C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AD0040: 4182000C  beq 0x82ad004c
	if ctx.cr[0].eq {
	pc = 0x82AD004C; continue 'dispatch;
	}
	// 82AD0044: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AD0048: 48000008  b 0x82ad0050
	pc = 0x82AD0050; continue 'dispatch;
	// 82AD004C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82AD0050: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AD0054: 486D8168  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD0058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AD0058 size=1128
    let mut pc: u32 = 0x82AD0058;
    'dispatch: loop {
        match pc {
            0x82AD0058 => {
    //   block [0x82AD0058..0x82AD04C0)
	// 82AD0058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD005C: 486D8101  bl 0x831a815c
	ctx.lr = 0x82AD0060;
	sub_831A8130(ctx, base);
	// 82AD0060: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 82AD0064: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82AD0068: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD006C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AD0070: 3D6082AD  lis r11, -0x7d53
	ctx.r[11].s64 = -2102591488;
	// 82AD0074: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82AD0078: 396BF8D8  addi r11, r11, -0x728
	ctx.r[11].s64 = ctx.r[11].s64 + -1832;
	// 82AD007C: 395EFF1C  addi r10, r30, -0xe4
	ctx.r[10].s64 = ctx.r[30].s64 + -228;
	// 82AD0080: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 82AD0084: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 82AD0088: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AD008C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82AD0090: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82AD0094: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 82AD0098: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AD009C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AD00A0: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AD00A4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82AD00A8: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 82AD00AC: 4BFFFF2D  bl 0x82acffd8
	ctx.lr = 0x82AD00B0;
	sub_82ACFFD8(ctx, base);
	// 82AD00B0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD00B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AD00B8: 3B8BA240  addi r28, r11, -0x5dc0
	ctx.r[28].s64 = ctx.r[11].s64 + -24000;
	// 82AD00BC: 38A000B8  li r5, 0xb8
	ctx.r[5].s64 = 184;
	// 82AD00C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AD00C4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82AD00C8: 4B7F0311  bl 0x822c03d8
	ctx.lr = 0x82AD00CC;
	sub_822C03D8(ctx, base);
	// 82AD00CC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AD00D0: 41820044  beq 0x82ad0114
	if ctx.cr[0].eq {
	pc = 0x82AD0114; continue 'dispatch;
	}
	// 82AD00D4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82AD00D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD00DC: 388BCAD4  addi r4, r11, -0x352c
	ctx.r[4].s64 = ctx.r[11].s64 + -13612;
	// 82AD00E0: 48323929  bl 0x82df3a08
	ctx.lr = 0x82AD00E4;
	sub_82DF3A08(ctx, base);
	// 82AD00E4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AD00E8: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 82AD00EC: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82AD00F0: 4BABBE21  bl 0x8258bf10
	ctx.lr = 0x82AD00F4;
	sub_8258BF10(ctx, base);
	// 82AD00F4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82AD00F8: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 82AD00FC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AD0100: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD0104: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82AD0108: 4BADC089  bl 0x825ac190
	ctx.lr = 0x82AD010C;
	sub_825AC190(ctx, base);
	// 82AD010C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD0110: 48000008  b 0x82ad0118
	pc = 0x82AD0118; continue 'dispatch;
	// 82AD0114: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82AD0118: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82AD011C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD0120: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AD0124: 4BA23295  bl 0x824f33b8
	ctx.lr = 0x82AD0128;
	sub_824F33B8(ctx, base);
	// 82AD0128: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AD012C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD0130: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AD0134: 4B7EFECD  bl 0x822c0000
	ctx.lr = 0x82AD0138;
	sub_822C0000(ctx, base);
	// 82AD0138: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AD013C: 41820010  beq 0x82ad014c
	if ctx.cr[0].eq {
	pc = 0x82AD014C; continue 'dispatch;
	}
	// 82AD0140: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD0144: 57BD003C  rlwinm r29, r29, 0, 0, 0x1e
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 82AD0148: 483232E1  bl 0x82df3428
	ctx.lr = 0x82AD014C;
	sub_82DF3428(ctx, base);
	// 82AD014C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD0150: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD0154: 388BA370  addi r4, r11, -0x5c90
	ctx.r[4].s64 = ctx.r[11].s64 + -23696;
	// 82AD0158: 483238B1  bl 0x82df3a08
	ctx.lr = 0x82AD015C;
	sub_82DF3A08(ctx, base);
	// 82AD015C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AD0160: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82AD0164: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD0168: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD016C: 4BADBC55  bl 0x825abdc0
	ctx.lr = 0x82AD0170;
	sub_825ABDC0(ctx, base);
	// 82AD0170: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD0174: 483232B5  bl 0x82df3428
	ctx.lr = 0x82AD0178;
	sub_82DF3428(ctx, base);
	// 82AD0178: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AD017C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD0180: 388B1928  addi r4, r11, 0x1928
	ctx.r[4].s64 = ctx.r[11].s64 + 6440;
	// 82AD0184: 48323885  bl 0x82df3a08
	ctx.lr = 0x82AD0188;
	sub_82DF3A08(ctx, base);
	// 82AD0188: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82AD018C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AD0190: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD0194: 4BADBC2D  bl 0x825abdc0
	ctx.lr = 0x82AD0198;
	sub_825ABDC0(ctx, base);
	// 82AD0198: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD019C: 4832328D  bl 0x82df3428
	ctx.lr = 0x82AD01A0;
	sub_82DF3428(ctx, base);
	// 82AD01A0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD01A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD01A8: 388BA364  addi r4, r11, -0x5c9c
	ctx.r[4].s64 = ctx.r[11].s64 + -23708;
	// 82AD01AC: 4832385D  bl 0x82df3a08
	ctx.lr = 0x82AD01B0;
	sub_82DF3A08(ctx, base);
	// 82AD01B0: 83210054  lwz r25, 0x54(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AD01B4: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82AD01B8: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82AD01BC: 93210064  stw r25, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 82AD01C0: 419A0024  beq cr6, 0x82ad01e4
	if ctx.cr[6].eq {
	pc = 0x82AD01E4; continue 'dispatch;
	}
	// 82AD01C4: 39790004  addi r11, r25, 4
	ctx.r[11].s64 = ctx.r[25].s64 + 4;
	// 82AD01C8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AD01CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AD01D0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AD01D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AD01D8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AD01DC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AD01E0: 4082FFE8  bne 0x82ad01c8
	if !ctx.cr[0].eq {
	pc = 0x82AD01C8; continue 'dispatch;
	}
	// 82AD01E4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82AD01E8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AD01EC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AD01F0: 4BAD1F21  bl 0x825a2110
	ctx.lr = 0x82AD01F4;
	sub_825A2110(ctx, base);
	// 82AD01F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD01F8: 48323231  bl 0x82df3428
	ctx.lr = 0x82AD01FC;
	sub_82DF3428(ctx, base);
	// 82AD01FC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82AD0200: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD0204: 3BEB7C44  addi r31, r11, 0x7c44
	ctx.r[31].s64 = ctx.r[11].s64 + 31812;
	// 82AD0208: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD020C: 483237FD  bl 0x82df3a08
	ctx.lr = 0x82AD0210;
	sub_82DF3A08(ctx, base);
	// 82AD0210: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD0214: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD0218: 483237F1  bl 0x82df3a08
	ctx.lr = 0x82AD021C;
	sub_82DF3A08(ctx, base);
	// 82AD021C: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82AD0220: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82AD0224: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD0228: 38BE0030  addi r5, r30, 0x30
	ctx.r[5].s64 = ctx.r[30].s64 + 48;
	// 82AD022C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AD0230: C3EA6218  lfs f31, 0x6218(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AD0234: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82AD0238: C3C908A4  lfs f30, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82AD023C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82AD0240: C06BA1DC  lfs f3, -0x5e24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24100 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82AD0244: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82AD0248: 4BAD3061  bl 0x825a32a8
	ctx.lr = 0x82AD024C;
	sub_825A32A8(ctx, base);
	// 82AD024C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AD0250: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AD0254: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AD0258: 4BAD1519  bl 0x825a1770
	ctx.lr = 0x82AD025C;
	sub_825A1770(ctx, base);
	// 82AD025C: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82AD0260: 483231C9  bl 0x82df3428
	ctx.lr = 0x82AD0264;
	sub_82DF3428(ctx, base);
	// 82AD0264: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82AD0268: 4B7F8A51  bl 0x822c8cb8
	ctx.lr = 0x82AD026C;
	sub_822C8CB8(ctx, base);
	// 82AD026C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD0270: 483231B9  bl 0x82df3428
	ctx.lr = 0x82AD0274;
	sub_82DF3428(ctx, base);
	// 82AD0274: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD0278: 483231B1  bl 0x82df3428
	ctx.lr = 0x82AD027C;
	sub_82DF3428(ctx, base);
	// 82AD027C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AD0280: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AD0284: 38A000C2  li r5, 0xc2
	ctx.r[5].s64 = 194;
	// 82AD0288: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82AD028C: 4B7F014D  bl 0x822c03d8
	ctx.lr = 0x82AD0290;
	sub_822C03D8(ctx, base);
	// 82AD0290: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82AD0294: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AD0298: 3B8B44A0  addi r28, r11, 0x44a0
	ctx.r[28].s64 = ctx.r[11].s64 + 17568;
	// 82AD029C: 41820030  beq 0x82ad02cc
	if ctx.cr[0].eq {
	pc = 0x82AD02CC; continue 'dispatch;
	}
	// 82AD02A0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AD02A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD02A8: 48323761  bl 0x82df3a08
	ctx.lr = 0x82AD02AC;
	sub_82DF3A08(ctx, base);
	// 82AD02AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AD02B0: 38BE0038  addi r5, r30, 0x38
	ctx.r[5].s64 = ctx.r[30].s64 + 56;
	// 82AD02B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AD02B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD02BC: 63BD0002  ori r29, r29, 2
	ctx.r[29].u64 = ctx.r[29].u64 | 2;
	// 82AD02C0: 4BADC151  bl 0x825ac410
	ctx.lr = 0x82AD02C4;
	sub_825AC410(ctx, base);
	// 82AD02C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD02C8: 48000008  b 0x82ad02d0
	pc = 0x82AD02D0; continue 'dispatch;
	// 82AD02CC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82AD02D0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82AD02D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD02D8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AD02DC: 4BA230DD  bl 0x824f33b8
	ctx.lr = 0x82AD02E0;
	sub_824F33B8(ctx, base);
	// 82AD02E0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AD02E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD02E8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AD02EC: 4B7EFD15  bl 0x822c0000
	ctx.lr = 0x82AD02F0;
	sub_822C0000(ctx, base);
	// 82AD02F0: 57AB07BD  rlwinm. r11, r29, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AD02F4: 4182000C  beq 0x82ad0300
	if ctx.cr[0].eq {
	pc = 0x82AD0300; continue 'dispatch;
	}
	// 82AD02F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD02FC: 4832312D  bl 0x82df3428
	ctx.lr = 0x82AD0300;
	sub_82DF3428(ctx, base);
	// 82AD0300: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AD0304: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD0308: 388B5D2C  addi r4, r11, 0x5d2c
	ctx.r[4].s64 = ctx.r[11].s64 + 23852;
	// 82AD030C: 483236FD  bl 0x82df3a08
	ctx.lr = 0x82AD0310;
	sub_82DF3A08(ctx, base);
	// 82AD0310: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AD0314: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AD0318: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD031C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AD0320: 4BADBAA1  bl 0x825abdc0
	ctx.lr = 0x82AD0324;
	sub_825ABDC0(ctx, base);
	// 82AD0324: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD0328: 48323101  bl 0x82df3428
	ctx.lr = 0x82AD032C;
	sub_82DF3428(ctx, base);
	// 82AD032C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD0330: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD0334: 388BA358  addi r4, r11, -0x5ca8
	ctx.r[4].s64 = ctx.r[11].s64 + -23720;
	// 82AD0338: 483236D1  bl 0x82df3a08
	ctx.lr = 0x82AD033C;
	sub_82DF3A08(ctx, base);
	// 82AD033C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AD0340: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AD0344: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AD0348: 4BADBA79  bl 0x825abdc0
	ctx.lr = 0x82AD034C;
	sub_825ABDC0(ctx, base);
	// 82AD034C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD0350: 483230D9  bl 0x82df3428
	ctx.lr = 0x82AD0354;
	sub_82DF3428(ctx, base);
	// 82AD0354: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AD0358: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD035C: 483236AD  bl 0x82df3a08
	ctx.lr = 0x82AD0360;
	sub_82DF3A08(ctx, base);
	// 82AD0360: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AD0364: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82AD0368: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AD036C: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82AD0370: 419A0024  beq cr6, 0x82ad0394
	if ctx.cr[6].eq {
	pc = 0x82AD0394; continue 'dispatch;
	}
	// 82AD0374: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82AD0378: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AD037C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AD0380: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AD0384: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AD0388: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AD038C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AD0390: 4082FFE8  bne 0x82ad0378
	if !ctx.cr[0].eq {
	pc = 0x82AD0378; continue 'dispatch;
	}
	// 82AD0394: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82AD0398: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AD039C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AD03A0: 4BAD1D71  bl 0x825a2110
	ctx.lr = 0x82AD03A4;
	sub_825A2110(ctx, base);
	// 82AD03A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD03A8: 48323081  bl 0x82df3428
	ctx.lr = 0x82AD03AC;
	sub_82DF3428(ctx, base);
	// 82AD03AC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AD03B0: 419A000C  beq cr6, 0x82ad03bc
	if ctx.cr[6].eq {
	pc = 0x82AD03BC; continue 'dispatch;
	}
	// 82AD03B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD03B8: 4B7F04D9  bl 0x822c0890
	ctx.lr = 0x82AD03BC;
	sub_822C0890(ctx, base);
	// 82AD03BC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD03C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD03C4: 3BEBA34C  addi r31, r11, -0x5cb4
	ctx.r[31].s64 = ctx.r[11].s64 + -23732;
	// 82AD03C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD03CC: 4832363D  bl 0x82df3a08
	ctx.lr = 0x82AD03D0;
	sub_82DF3A08(ctx, base);
	// 82AD03D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD03D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD03D8: 48323631  bl 0x82df3a08
	ctx.lr = 0x82AD03DC;
	sub_82DF3A08(ctx, base);
	// 82AD03DC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82AD03E0: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 82AD03E4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82AD03E8: 38BE003C  addi r5, r30, 0x3c
	ctx.r[5].s64 = ctx.r[30].s64 + 60;
	// 82AD03EC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AD03F0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82AD03F4: 4BAD3025  bl 0x825a3418
	ctx.lr = 0x82AD03F8;
	sub_825A3418(ctx, base);
	// 82AD03F8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AD03FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AD0400: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AD0404: 4BAD1AD5  bl 0x825a1ed8
	ctx.lr = 0x82AD0408;
	sub_825A1ED8(ctx, base);
	// 82AD0408: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 82AD040C: 4832301D  bl 0x82df3428
	ctx.lr = 0x82AD0410;
	sub_82DF3428(ctx, base);
	// 82AD0410: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 82AD0414: 4B7F88A5  bl 0x822c8cb8
	ctx.lr = 0x82AD0418;
	sub_822C8CB8(ctx, base);
	// 82AD0418: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD041C: 4832300D  bl 0x82df3428
	ctx.lr = 0x82AD0420;
	sub_82DF3428(ctx, base);
	// 82AD0420: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD0424: 48323005  bl 0x82df3428
	ctx.lr = 0x82AD0428;
	sub_82DF3428(ctx, base);
	// 82AD0428: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD042C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD0430: 3BEBA340  addi r31, r11, -0x5cc0
	ctx.r[31].s64 = ctx.r[11].s64 + -23744;
	// 82AD0434: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD0438: 483235D1  bl 0x82df3a08
	ctx.lr = 0x82AD043C;
	sub_82DF3A08(ctx, base);
	// 82AD043C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD0440: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD0444: 483235C5  bl 0x82df3a08
	ctx.lr = 0x82AD0448;
	sub_82DF3A08(ctx, base);
	// 82AD0448: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AD044C: 38BE0044  addi r5, r30, 0x44
	ctx.r[5].s64 = ctx.r[30].s64 + 68;
	// 82AD0450: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82AD0454: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AD0458: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82AD045C: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82AD0460: C06B08A8  lfs f3, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82AD0464: 4BAD2E45  bl 0x825a32a8
	ctx.lr = 0x82AD0468;
	sub_825A32A8(ctx, base);
	// 82AD0468: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82AD046C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AD0470: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AD0474: 4BAD12FD  bl 0x825a1770
	ctx.lr = 0x82AD0478;
	sub_825A1770(ctx, base);
	// 82AD0478: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 82AD047C: 48322FAD  bl 0x82df3428
	ctx.lr = 0x82AD0480;
	sub_82DF3428(ctx, base);
	// 82AD0480: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 82AD0484: 4B7F8835  bl 0x822c8cb8
	ctx.lr = 0x82AD0488;
	sub_822C8CB8(ctx, base);
	// 82AD0488: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD048C: 48322F9D  bl 0x82df3428
	ctx.lr = 0x82AD0490;
	sub_82DF3428(ctx, base);
	// 82AD0490: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD0494: 48322F95  bl 0x82df3428
	ctx.lr = 0x82AD0498;
	sub_82DF3428(ctx, base);
	// 82AD0498: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82AD049C: 419A000C  beq cr6, 0x82ad04a8
	if ctx.cr[6].eq {
	pc = 0x82AD04A8; continue 'dispatch;
	}
	// 82AD04A0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82AD04A4: 4B7F03ED  bl 0x822c0890
	ctx.lr = 0x82AD04A8;
	sub_822C0890(ctx, base);
	// 82AD04A8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AD04AC: 4B7F880D  bl 0x822c8cb8
	ctx.lr = 0x82AD04B0;
	sub_822C8CB8(ctx, base);
	// 82AD04B0: 382101C0  addi r1, r1, 0x1c0
	ctx.r[1].s64 = ctx.r[1].s64 + 448;
	// 82AD04B4: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82AD04B8: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82AD04BC: 486D7CF0  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD04C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD04C0 size=68
    let mut pc: u32 = 0x82AD04C0;
    'dispatch: loop {
        match pc {
            0x82AD04C0 => {
    //   block [0x82AD04C0..0x82AD0504)
	// 82AD04C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD04C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AD04C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AD04CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD04D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD04D4: 4BA41B95  bl 0x82512068
	ctx.lr = 0x82AD04D8;
	sub_82512068(ctx, base);
	// 82AD04D8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82AD04DC: 38BF0118  addi r5, r31, 0x118
	ctx.r[5].s64 = ctx.r[31].s64 + 280;
	// 82AD04E0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82AD04E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD04E8: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82AD04EC: 4BA3FD05  bl 0x825101f0
	ctx.lr = 0x82AD04F0;
	sub_825101F0(ctx, base);
	// 82AD04F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AD04F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AD04F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AD04FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AD0500: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD0508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD0508 size=108
    let mut pc: u32 = 0x82AD0508;
    'dispatch: loop {
        match pc {
            0x82AD0508 => {
    //   block [0x82AD0508..0x82AD0574)
	// 82AD0508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD050C: 486D7C61  bl 0x831a816c
	ctx.lr = 0x82AD0510;
	sub_831A8130(ctx, base);
	// 82AD0510: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD0514: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82AD0518: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AD051C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AD0520: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AD0524: 41820038  beq 0x82ad055c
	if ctx.cr[0].eq {
	pc = 0x82AD055C; continue 'dispatch;
	}
	// 82AD0528: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD052C: 486D945D  bl 0x831a9988
	ctx.lr = 0x82AD0530;
	sub_831A9988(ctx, base);
	// 82AD0530: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82AD0534: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AD0538: 386B59B0  addi r3, r11, 0x59b0
	ctx.r[3].s64 = ctx.r[11].s64 + 22960;
	// 82AD053C: 486D7BBD  bl 0x831a80f8
	ctx.lr = 0x82AD0540;
	sub_831A80F8(ctx, base);
	// 82AD0540: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AD0544: 41820018  beq 0x82ad055c
	if ctx.cr[0].eq {
	pc = 0x82AD055C; continue 'dispatch;
	}
	// 82AD0548: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD054C: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 82AD0550: 4BFFC5B1  bl 0x82accb00
	ctx.lr = 0x82AD0554;
	sub_82ACCB00(ctx, base);
	// 82AD0554: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AD0558: 48000014  b 0x82ad056c
	pc = 0x82AD056C; continue 'dispatch;
	// 82AD055C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AD0560: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD0564: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AD0568: 4BA420B1  bl 0x82512618
	ctx.lr = 0x82AD056C;
	sub_82512618(ctx, base);
	// 82AD056C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AD0570: 486D7C4C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD0578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD0578 size=196
    let mut pc: u32 = 0x82AD0578;
    'dispatch: loop {
        match pc {
            0x82AD0578 => {
    //   block [0x82AD0578..0x82AD063C)
	// 82AD0578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD057C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AD0580: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AD0584: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AD0588: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD058C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AD0590: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AD0594: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AD0598: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AD059C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AD05A0: 4B7F0399  bl 0x822c0938
	ctx.lr = 0x82AD05A4;
	sub_822C0938(ctx, base);
	// 82AD05A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AD05A8: 41820028  beq 0x82ad05d0
	if ctx.cr[0].eq {
	pc = 0x82AD05D0; continue 'dispatch;
	}
	// 82AD05AC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD05B0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AD05B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AD05B8: 392BA3A4  addi r9, r11, -0x5c5c
	ctx.r[9].s64 = ctx.r[11].s64 + -23644;
	// 82AD05BC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AD05C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AD05C4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AD05C8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AD05CC: 48000008  b 0x82ad05d4
	pc = 0x82AD05D4; continue 'dispatch;
	// 82AD05D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AD05D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AD05D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD05DC: 409A0044  bne cr6, 0x82ad0620
	if !ctx.cr[6].eq {
	pc = 0x82AD0620; continue 'dispatch;
	}
	// 82AD05E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AD05E4: 419A001C  beq cr6, 0x82ad0600
	if ctx.cr[6].eq {
	pc = 0x82AD0600; continue 'dispatch;
	}
	// 82AD05E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD05EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AD05F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD05F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD05F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AD05FC: 4E800421  bctrl
	ctx.lr = 0x82AD0600;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AD0600: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AD0604: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AD0608: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD060C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AD0610: 816B0C8C  lwz r11, 0xc8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3212 as u32) ) } as u64;
	// 82AD0614: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AD0618: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AD061C: 4B7EF9E5  bl 0x822c0000
	ctx.lr = 0x82AD0620;
	sub_822C0000(ctx, base);
	// 82AD0620: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD0624: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AD0628: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AD062C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AD0630: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AD0634: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AD0638: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD0640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AD0640 size=232
    let mut pc: u32 = 0x82AD0640;
    'dispatch: loop {
        match pc {
            0x82AD0640 => {
    //   block [0x82AD0640..0x82AD0728)
	// 82AD0640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD0644: 486D7B21  bl 0x831a8164
	ctx.lr = 0x82AD0648;
	sub_831A8130(ctx, base);
	// 82AD0648: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD064C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD0650: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AD0654: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82AD0658: 4BA41CD9  bl 0x82512330
	ctx.lr = 0x82AD065C;
	sub_82512330(ctx, base);
	// 82AD065C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AD0660: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82AD0664: 394AA3CC  addi r10, r10, -0x5c34
	ctx.r[10].s64 = ctx.r[10].s64 + -23604;
	// 82AD0668: 390000F0  li r8, 0xf0
	ctx.r[8].s64 = 240;
	// 82AD066C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AD0670: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AD0674: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AD0678: 3929A3B8  addi r9, r9, -0x5c48
	ctx.r[9].s64 = ctx.r[9].s64 + -23624;
	// 82AD067C: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82AD0680: 3F80820C  lis r28, -0x7df4
	ctx.r[28].s64 = -2113142784;
	// 82AD0684: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82AD0688: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AD068C: 3F608338  lis r27, -0x7cc8
	ctx.r[27].s64 = -2093481984;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD0728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AD0728 size=8
    let mut pc: u32 = 0x82AD0728;
    'dispatch: loop {
        match pc {
            0x82AD0728 => {
    //   block [0x82AD0728..0x82AD0730)
	// 82AD0728: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82AD072C: 480000DC  b 0x82ad0808
	sub_82AD0808(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD0730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD0730 size=88
    let mut pc: u32 = 0x82AD0730;
    'dispatch: loop {
        match pc {
            0x82AD0730 => {
    //   block [0x82AD0730..0x82AD0788)
	// 82AD0730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD0734: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AD0738: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AD073C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD0740: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD0744: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD0748: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AD074C: 396BA3CC  addi r11, r11, -0x5c34
	ctx.r[11].s64 = ctx.r[11].s64 + -23604;
	// 82AD0750: 394AA3B8  addi r10, r10, -0x5c48
	ctx.r[10].s64 = ctx.r[10].s64 + -23624;
	// 82AD0754: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AD0758: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82AD075C: 807F011C  lwz r3, 0x11c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 82AD0760: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD0764: 419A0008  beq cr6, 0x82ad076c
	if ctx.cr[6].eq {
	pc = 0x82AD076C; continue 'dispatch;
	}
	// 82AD0768: 4B7F0129  bl 0x822c0890
	ctx.lr = 0x82AD076C;
	sub_822C0890(ctx, base);
	// 82AD076C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD0770: 4B87EBE1  bl 0x8234f350
	ctx.lr = 0x82AD0774;
	sub_8234F350(ctx, base);
	// 82AD0774: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AD0778: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AD077C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AD0780: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AD0784: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD0788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD0788 size=128
    let mut pc: u32 = 0x82AD0788;
    'dispatch: loop {
        match pc {
            0x82AD0788 => {
    //   block [0x82AD0788..0x82AD0808)
	// 82AD0788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD078C: 486D79E1  bl 0x831a816c
	ctx.lr = 0x82AD0790;
	sub_831A8130(ctx, base);
	// 82AD0790: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD0794: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD0798: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AD079C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AD07A0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82AD07A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AD07A8: 388BA408  addi r4, r11, -0x5bf8
	ctx.r[4].s64 = ctx.r[11].s64 + -23544;
	// 82AD07AC: 38A00036  li r5, 0x36
	ctx.r[5].s64 = 54;
	// 82AD07B0: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 82AD07B4: 48321C35  bl 0x82df23e8
	ctx.lr = 0x82AD07B8;
	sub_82DF23E8(ctx, base);
	// 82AD07B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AD07BC: 41820018  beq 0x82ad07d4
	if ctx.cr[0].eq {
	pc = 0x82AD07D4; continue 'dispatch;
	}
	// 82AD07C0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AD07C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD07C8: 4BFFFE79  bl 0x82ad0640
	ctx.lr = 0x82AD07CC;
	sub_82AD0640(ctx, base);
	// 82AD07CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD07D0: 48000008  b 0x82ad07d8
	pc = 0x82AD07D8; continue 'dispatch;
	// 82AD07D4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AD07D8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82AD07DC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82AD07E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD07E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD07E8: 4BFFFD91  bl 0x82ad0578
	ctx.lr = 0x82AD07EC;
	sub_82AD0578(ctx, base);
	// 82AD07EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AD07F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD07F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD07F8: 4B7EF809  bl 0x822c0000
	ctx.lr = 0x82AD07FC;
	sub_822C0000(ctx, base);
	// 82AD07FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AD0800: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AD0804: 486D79B8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD0808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD0808 size=76
    let mut pc: u32 = 0x82AD0808;
    'dispatch: loop {
        match pc {
            0x82AD0808 => {
    //   block [0x82AD0808..0x82AD0854)
	// 82AD0808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD080C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AD0810: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AD0814: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AD0818: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD081C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD0820: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AD0824: 4BFFFF0D  bl 0x82ad0730
	ctx.lr = 0x82AD0828;
	sub_82AD0730(ctx, base);
	// 82AD0828: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AD082C: 4182000C  beq 0x82ad0838
	if ctx.cr[0].eq {
	pc = 0x82AD0838; continue 'dispatch;
	}
	// 82AD0830: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD0834: 48321BA5  bl 0x82df23d8
	ctx.lr = 0x82AD0838;
	sub_82DF23D8(ctx, base);
	// 82AD0838: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD083C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AD0840: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AD0844: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AD0848: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AD084C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AD0850: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD0858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD0858 size=220
    let mut pc: u32 = 0x82AD0858;
    'dispatch: loop {
        match pc {
            0x82AD0858 => {
    //   block [0x82AD0858..0x82AD0934)
	// 82AD0858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD085C: 486D7911  bl 0x831a816c
	ctx.lr = 0x82AD0860;
	sub_831A8130(ctx, base);
	// 82AD0860: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD0864: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD0868: 80840000  lwz r4, 0(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD086C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AD0870: 4835A279  bl 0x82e2aae8
	ctx.lr = 0x82AD0874;
	sub_82E2AAE8(ctx, base);
	// 82AD0874: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AD0878: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD087C: 808B0C88  lwz r4, 0xc88(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3208 as u32) ) } as u64;
	// 82AD0880: 48323189  bl 0x82df3a08
	ctx.lr = 0x82AD0884;
	sub_82DF3A08(ctx, base);
	// 82AD0884: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AD0888: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AD088C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AD0890: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD0894: 4835E5DD  bl 0x82e2ee70
	ctx.lr = 0x82AD0898;
	sub_82E2EE70(ctx, base);
	// 82AD0898: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD089C: 48322B8D  bl 0x82df3428
	ctx.lr = 0x82AD08A0;
	sub_82DF3428(ctx, base);
	// 82AD08A0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD08A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AD08A8: 388BA408  addi r4, r11, -0x5bf8
	ctx.r[4].s64 = ctx.r[11].s64 + -23544;
	// 82AD08AC: 38A00071  li r5, 0x71
	ctx.r[5].s64 = 113;
	// 82AD08B0: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82AD08B4: 48321B35  bl 0x82df23e8
	ctx.lr = 0x82AD08B8;
	sub_82DF23E8(ctx, base);
	// 82AD08B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AD08BC: 41820014  beq 0x82ad08d0
	if ctx.cr[0].eq {
	pc = 0x82AD08D0; continue 'dispatch;
	}
	// 82AD08C0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AD08C4: 48345FCD  bl 0x82e16890
	ctx.lr = 0x82AD08C8;
	sub_82E16890(ctx, base);
	// 82AD08C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AD08CC: 48000008  b 0x82ad08d4
	pc = 0x82AD08D4; continue 'dispatch;
	// 82AD08D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD08D4: 3BDF0118  addi r30, r31, 0x118
	ctx.r[30].s64 = ctx.r[31].s64 + 280;
	// 82AD08D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD08DC: 4B88CA95  bl 0x8235d370
	ctx.lr = 0x82AD08E0;
	sub_8235D370(ctx, base);
	// 82AD08E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD08E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD08E8: 83BF0118  lwz r29, 0x118(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82AD08EC: 4BA4182D  bl 0x82512118
	ctx.lr = 0x82AD08F0;
	sub_82512118(ctx, base);
	// 82AD08F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AD08F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AD08F8: 483447B9  bl 0x82e150b0
	ctx.lr = 0x82AD08FC;
	sub_82E150B0(ctx, base);
	// 82AD08FC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82AD0900: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82AD0904: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AD0908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD090C: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82AD0910: 4BA40249  bl 0x82510b58
	ctx.lr = 0x82AD0914;
	sub_82510B58(ctx, base);
	// 82AD0914: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AD0918: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD091C: 419A0008  beq cr6, 0x82ad0924
	if ctx.cr[6].eq {
	pc = 0x82AD0924; continue 'dispatch;
	}
	// 82AD0920: 4B7EFF71  bl 0x822c0890
	ctx.lr = 0x82AD0924;
	sub_822C0890(ctx, base);
	// 82AD0924: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AD0928: 4835A1D9  bl 0x82e2ab00
	ctx.lr = 0x82AD092C;
	sub_82E2AB00(ctx, base);
	// 82AD092C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AD0930: 486D788C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD0938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AD0938 size=452
    let mut pc: u32 = 0x82AD0938;
    'dispatch: loop {
        match pc {
            0x82AD0938 => {
    //   block [0x82AD0938..0x82AD0AFC)
	// 82AD0938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD093C: 486D782D  bl 0x831a8168
	ctx.lr = 0x82AD0940;
	sub_831A8130(ctx, base);
	// 82AD0940: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82AD0944: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD0948: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD094C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AD0950: 4BA3FDB9  bl 0x82510708
	ctx.lr = 0x82AD0954;
	sub_82510708(ctx, base);
	// 82AD0954: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82AD0958: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AD095C: 41980168  blt cr6, 0x82ad0ac4
	if ctx.cr[6].lt {
	pc = 0x82AD0AC4; continue 'dispatch;
	}
	// 82AD0960: 409A0190  bne cr6, 0x82ad0af0
	if !ctx.cr[6].eq {
	pc = 0x82AD0AF0; continue 'dispatch;
	}
	// 82AD0964: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82AD0968: C1BF010C  lfs f13, 0x10c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AD096C: 815F0108  lwz r10, 0x108(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 82AD0970: 389F0100  addi r4, r31, 0x100
	ctx.r[4].s64 = ctx.r[31].s64 + 256;
	// 82AD0974: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AD0978: C00BF778  lfs f0, -0x888(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AD097C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AD0980: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82AD0984: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 82AD0988: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AD098C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82AD0990: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 82AD0994: 4BFDD9AD  bl 0x82aae340
	ctx.lr = 0x82AD0998;
	sub_82AAE340(ctx, base);
	// 82AD0998: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82AD099C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD09A0: 4BA41151  bl 0x82511af0
	ctx.lr = 0x82AD09A4;
	sub_82511AF0(ctx, base);
	// 82AD09A4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AD09A8: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AD09AC: C19F0110  lfs f12, 0x110(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82AD09B0: C00BE68C  lfs f0, -0x1974(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AD09B4: EC2D603A  fmadds f1, f13, f0, f12
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82AD09B8: D03F0110  stfs f1, 0x110(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82AD09BC: 486D840D  bl 0x831a8dc8
	ctx.lr = 0x82AD09C0;
	sub_831A8DC8(ctx, base);
	// 82AD09C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD09C4: FFE00818  frsp f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82AD09C8: 4BA41121  bl 0x82511ae8
	ctx.lr = 0x82AD09CC;
	sub_82511AE8(ctx, base);
	// 82AD09CC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD09D0: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82AD09D4: C1BF00F4  lfs f13, 0xf4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AD09D8: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82AD09DC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AD09E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD09E4: C00BA39C  lfs f0, -0x5c64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23652 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AD09E8: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AD09EC: EC1F683A  fmadds f0, f31, f0, f13
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD0B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD0B00 size=112
    let mut pc: u32 = 0x82AD0B00;
    'dispatch: loop {
        match pc {
            0x82AD0B00 => {
    //   block [0x82AD0B00..0x82AD0B70)
	// 82AD0B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD0B04: 486D7669  bl 0x831a816c
	ctx.lr = 0x82AD0B08;
	sub_831A8130(ctx, base);
	// 82AD0B08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD0B0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD0B10: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82AD0B14: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82AD0B18: 4BA40EC1  bl 0x825119d8
	ctx.lr = 0x82AD0B1C;
	sub_825119D8(ctx, base);
	// 82AD0B1C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82AD0B20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD0B24: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82AD0B28: 48322EE1  bl 0x82df3a08
	ctx.lr = 0x82AD0B2C;
	sub_82DF3A08(ctx, base);
	// 82AD0B2C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AD0B30: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AD0B34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD0B38: 4BA37C49  bl 0x82508780
	ctx.lr = 0x82AD0B3C;
	sub_82508780(ctx, base);
	// 82AD0B3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD0B40: 483228E9  bl 0x82df3428
	ctx.lr = 0x82AD0B44;
	sub_82DF3428(ctx, base);
	// 82AD0B44: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AD0B48: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82AD0B4C: 409A0008  bne cr6, 0x82ad0b54
	if !ctx.cr[6].eq {
	pc = 0x82AD0B54; continue 'dispatch;
	}
	// 82AD0B50: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD0B54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD0B58: 4BA37C49  bl 0x825087a0
	ctx.lr = 0x82AD0B5C;
	sub_825087A0(ctx, base);
	// 82AD0B5C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AD0B60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD0B64: 4BFFFCF5  bl 0x82ad0858
	ctx.lr = 0x82AD0B68;
	sub_82AD0858(ctx, base);
	// 82AD0B68: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AD0B6C: 486D7650  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD0B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD0B70 size=196
    let mut pc: u32 = 0x82AD0B70;
    'dispatch: loop {
        match pc {
            0x82AD0B70 => {
    //   block [0x82AD0B70..0x82AD0C34)
	// 82AD0B70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD0B74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AD0B78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AD0B7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AD0B80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD0B84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AD0B88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AD0B8C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AD0B90: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AD0B94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AD0B98: 4B7EFDA1  bl 0x822c0938
	ctx.lr = 0x82AD0B9C;
	sub_822C0938(ctx, base);
	// 82AD0B9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AD0BA0: 41820028  beq 0x82ad0bc8
	if ctx.cr[0].eq {
	pc = 0x82AD0BC8; continue 'dispatch;
	}
	// 82AD0BA4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD0BA8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AD0BAC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AD0BB0: 392BA474  addi r9, r11, -0x5b8c
	ctx.r[9].s64 = ctx.r[11].s64 + -23436;
	// 82AD0BB4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AD0BB8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AD0BBC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AD0BC0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AD0BC4: 48000008  b 0x82ad0bcc
	pc = 0x82AD0BCC; continue 'dispatch;
	// 82AD0BC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AD0BCC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AD0BD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD0BD4: 409A0044  bne cr6, 0x82ad0c18
	if !ctx.cr[6].eq {
	pc = 0x82AD0C18; continue 'dispatch;
	}
	// 82AD0BD8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AD0BDC: 419A001C  beq cr6, 0x82ad0bf8
	if ctx.cr[6].eq {
	pc = 0x82AD0BF8; continue 'dispatch;
	}
	// 82AD0BE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD0BE4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AD0BE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD0BEC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD0BF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AD0BF4: 4E800421  bctrl
	ctx.lr = 0x82AD0BF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AD0BF8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AD0BFC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AD0C00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD0C04: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AD0C08: 816B0D3C  lwz r11, 0xd3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3388 as u32) ) } as u64;
	// 82AD0C0C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AD0C10: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AD0C14: 4B7EF3ED  bl 0x822c0000
	ctx.lr = 0x82AD0C18;
	sub_822C0000(ctx, base);
	// 82AD0C18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD0C1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AD0C20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AD0C24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AD0C28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AD0C2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AD0C30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD0C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AD0C38 size=460
    let mut pc: u32 = 0x82AD0C38;
    'dispatch: loop {
        match pc {
            0x82AD0C38 => {
    //   block [0x82AD0C38..0x82AD0E04)
	// 82AD0C38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD0C3C: 486D7529  bl 0x831a8164
	ctx.lr = 0x82AD0C40;
	sub_831A8130(ctx, base);
	// 82AD0C40: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD0C44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AD0C48: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD0C4C: 809E011C  lwz r4, 0x11c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(284 as u32) ) } as u64;
	// 82AD0C50: 4BB0DE21  bl 0x825dea70
	ctx.lr = 0x82AD0C54;
	sub_825DEA70(ctx, base);
	// 82AD0C54: 3BBE00EC  addi r29, r30, 0xec
	ctx.r[29].s64 = ctx.r[30].s64 + 236;
	// 82AD0C58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AD0C5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AD0C60: 485E13C9  bl 0x830b2028
	ctx.lr = 0x82AD0C64;
	sub_830B2028(ctx, base);
	// 82AD0C64: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD0C68: 485E1271  bl 0x830b1ed8
	ctx.lr = 0x82AD0C6C;
	sub_830B1ED8(ctx, base);
	// 82AD0C6C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD0C70: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AD0C74: 388BA490  addi r4, r11, -0x5b70
	ctx.r[4].s64 = ctx.r[11].s64 + -23408;
	// 82AD0C78: 38A00065  li r5, 0x65
	ctx.r[5].s64 = 101;
	// 82AD0C7C: 386000D8  li r3, 0xd8
	ctx.r[3].s64 = 216;
	// 82AD0C80: 48321769  bl 0x82df23e8
	ctx.lr = 0x82AD0C84;
	sub_82DF23E8(ctx, base);
	// 82AD0C84: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AD0C88: 4182002C  beq 0x82ad0cb4
	if ctx.cr[0].eq {
	pc = 0x82AD0CB4; continue 'dispatch;
	}
	// 82AD0C8C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AD0C90: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AD0C94: 4B9C911D  bl 0x82499db0
	ctx.lr = 0x82AD0C98;
	sub_82499DB0(ctx, base);
	// 82AD0C98: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AD0C9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AD0CA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD0CA4: C02B9450  lfs f1, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AD0CA8: 4BB0F429  bl 0x825e00d0
	ctx.lr = 0x82AD0CAC;
	sub_825E00D0(ctx, base);
	// 82AD0CAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD0CB0: 48000008  b 0x82ad0cb8
	pc = 0x82AD0CB8; continue 'dispatch;
	// 82AD0CB4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AD0CB8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82AD0CBC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD0CC0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AD0CC4: 4B83C85D  bl 0x8230d520
	ctx.lr = 0x82AD0CC8;
	sub_8230D520(ctx, base);
	// 82AD0CC8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AD0CCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD0CD0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AD0CD4: 4B7EF32D  bl 0x822c0000
	ctx.lr = 0x82AD0CD8;
	sub_822C0000(ctx, base);
	// 82AD0CD8: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AD0CDC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AD0CE0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82AD0CE4: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82AD0CE8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AD0CEC: 419A0024  beq cr6, 0x82ad0d10
	if ctx.cr[6].eq {
	pc = 0x82AD0D10; continue 'dispatch;
	}
	// 82AD0CF0: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 82AD0CF4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AD0CF8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AD0CFC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AD0D00: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AD0D04: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AD0D08: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AD0D0C: 4082FFE8  bne 0x82ad0cf4
	if !ctx.cr[0].eq {
	pc = 0x82AD0CF4; continue 'dispatch;
	}
	// 82AD0D10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AD0D14: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AD0D18: 4BA3E7B1  bl 0x8250f4c8
	ctx.lr = 0x82AD0D1C;
	sub_8250F4C8(ctx, base);
	// 82AD0D1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD0D20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD0D24: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 82AD0D28: 409A0008  bne cr6, 0x82ad0d30
	if !ctx.cr[6].eq {
	pc = 0x82AD0D30; continue 'dispatch;
	}
	// 82AD0D2C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AD0D30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AD0D34: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AD0D38: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 82AD0D3C: 4BA3E7DD  bl 0x8250f518
	ctx.lr = 0x82AD0D40;
	sub_8250F518(ctx, base);
	// 82AD0D40: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AD0D44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD0D48: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82AD0D4C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82AD0D50: 4BA3C7B9  bl 0x8250d508
	ctx.lr = 0x82AD0D54;
	sub_8250D508(ctx, base);
	// 82AD0D54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AD0D58: 48320F39  bl 0x82df1c90
	ctx.lr = 0x82AD0D5C;
	sub_82DF1C90(ctx, base);
	// 82AD0D5C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AD0D60: 48320F31  bl 0x82df1c90
	ctx.lr = 0x82AD0D64;
	sub_82DF1C90(ctx, base);
	// 82AD0D64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AD0D68: 485E11C1  bl 0x830b1f28
	ctx.lr = 0x82AD0D6C;
	sub_830B1F28(ctx, base);
	// 82AD0D6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AD0D70: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AD0D74: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82AD0D78: 485E5F21  bl 0x830b6c98
	ctx.lr = 0x82AD0D7C;
	sub_830B6C98(ctx, base);
	// 82AD0D7C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AD0D80: 485E1159  bl 0x830b1ed8
	ctx.lr = 0x82AD0D84;
	sub_830B1ED8(ctx, base);
	// 82AD0D84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AD0D88: 485E11A1  bl 0x830b1f28
	ctx.lr = 0x82AD0D8C;
	sub_830B1F28(ctx, base);
	// 82AD0D8C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82AD0D90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AD0D94: 38AB685C  addi r5, r11, 0x685c
	ctx.r[5].s64 = ctx.r[11].s64 + 26716;
	// 82AD0D98: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AD0D9C: 485E45CD  bl 0x830b5368
	ctx.lr = 0x82AD0DA0;
	sub_830B5368(ctx, base);
	// 82AD0DA0: 3BFE00F4  addi r31, r30, 0xf4
	ctx.r[31].s64 = ctx.r[30].s64 + 244;
	// 82AD0DA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AD0DA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD0DAC: 485E127D  bl 0x830b2028
	ctx.lr = 0x82AD0DB0;
	sub_830B2028(ctx, base);
	// 82AD0DB0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AD0DB4: 485E1125  bl 0x830b1ed8
	ctx.lr = 0x82AD0DB8;
	sub_830B1ED8(ctx, base);
	// 82AD0DB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD0DBC: 485E116D  bl 0x830b1f28
	ctx.lr = 0x82AD0DC0;
	sub_830B1F28(ctx, base);
	// 82AD0DC0: 485E13A9  bl 0x830b2168
	ctx.lr = 0x82AD0DC4;
	sub_830B2168(ctx, base);
	// 82AD0DC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD0DC8: 485E1161  bl 0x830b1f28
	ctx.lr = 0x82AD0DCC;
	sub_830B1F28(ctx, base);
	// 82AD0DCC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD0DD0: 48012571  bl 0x82ae3340
	ctx.lr = 0x82AD0DD4;
	sub_82AE3340(ctx, base);
	// 82AD0DD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD0DD8: 485E1151  bl 0x830b1f28
	ctx.lr = 0x82AD0DDC;
	sub_830B1F28(ctx, base);
	// 82AD0DDC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AD0DE0: 485E21C9  bl 0x830b2fa8
	ctx.lr = 0x82AD0DE4;
	sub_830B2FA8(ctx, base);
	// 82AD0DE4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AD0DE8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82AD0DEC: 917E00DC  stw r11, 0xdc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(220 as u32), ctx.r[11].u32 ) };
	// 82AD0DF0: 419A000C  beq cr6, 0x82ad0dfc
	if ctx.cr[6].eq {
	pc = 0x82AD0DFC; continue 'dispatch;
	}
	// 82AD0DF4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AD0DF8: 4B7EFA99  bl 0x822c0890
	ctx.lr = 0x82AD0DFC;
	sub_822C0890(ctx, base);
	// 82AD0DFC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82AD0E00: 486D73B4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD0E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AD0E08 size=700
    let mut pc: u32 = 0x82AD0E08;
    'dispatch: loop {
        match pc {
            0x82AD0E08 => {
    //   block [0x82AD0E08..0x82AD10C4)
	// 82AD0E08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD0E0C: 486D7351  bl 0x831a815c
	ctx.lr = 0x82AD0E10;
	sub_831A8130(ctx, base);
	// 82AD0E10: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 82AD0E14: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82AD0E18: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD0E1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD0E20: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD0E24: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82AD0E28: 387F00C4  addi r3, r31, 0xc4
	ctx.r[3].s64 = ctx.r[31].s64 + 196;
	// 82AD0E2C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82AD0E30: C1BF00CC  lfs f13, 0xcc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AD0E34: C00BA46C  lfs f0, -0x5b94(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23444 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AD0E38: EC4D002A  fadds f2, f13, f0
	ctx.f[2].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82AD0E3C: D05F00CC  stfs f2, 0xcc(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82AD0E40: C03F00C8  lfs f1, 0xc8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AD0E44: C0790000  lfs f3, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82AD0E48: 4B9C6F41  bl 0x82497d88
	ctx.lr = 0x82AD0E4C;
	sub_82497D88(ctx, base);
	// 82AD0E4C: 3B7F00F4  addi r27, r31, 0xf4
	ctx.r[27].s64 = ctx.r[31].s64 + 244;
	// 82AD0E50: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82AD0E54: 485E10D5  bl 0x830b1f28
	ctx.lr = 0x82AD0E58;
	sub_830B1F28(ctx, base);
	// 82AD0E58: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82AD0E5C: C1BF00C4  lfs f13, 0xc4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AD0E60: C00B6218  lfs f0, 0x6218(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AD0E64: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AD0E68: 485E12C9  bl 0x830b2130
	ctx.lr = 0x82AD0E6C;
	sub_830B2130(ctx, base);
	// 82AD0E6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD0E70: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AD0E74: 4BA3E6A5  bl 0x8250f518
	ctx.lr = 0x82AD0E78;
	sub_8250F518(ctx, base);
	// 82AD0E78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD0E7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD0E80: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 82AD0E84: 409A0008  bne cr6, 0x82ad0e8c
	if !ctx.cr[6].eq {
	pc = 0x82AD0E8C; continue 'dispatch;
	}
	// 82AD0E88: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82AD0E8C: 4BA57835  bl 0x825286c0
	ctx.lr = 0x82AD0E90;
	sub_825286C0(ctx, base);
	// 82AD0E90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AD0E94: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 82AD0E98: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 82AD0E9C: 3BC00030  li r30, 0x30
	ctx.r[30].s64 = 48;
	// 82AD0EA0: 394100D0  addi r10, r1, 0xd0
	ctx.r[10].s64 = ctx.r[1].s64 + 208;
	// 82AD0EA4: 392100E0  addi r9, r1, 0xe0
	ctx.r[9].s64 = ctx.r[1].s64 + 224;
	// 82AD0EA8: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AD0EAC: 390100F0  addi r8, r1, 0xf0
	ctx.r[8].s64 = ctx.r[1].s64 + 240;
	// 82AD0EB0: 13DC5C07  vcmpneb. (lvlx128) v30, v28, v11
	tmp.u32 = ctx.r[28].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AD0EB4: 38E10100  addi r7, r1, 0x100
	ctx.r[7].s64 = ctx.r[1].s64 + 256;
	// 82AD0EB8: 13BD5C07  vcmpneb. (lvlx128) v29, v29, v11
	tmp.u32 = ctx.r[29].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82AD0EBC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AD0EC0: 139E5C07  vcmpneb. (lvlx128) v28, v30, v11
	tmp.u32 = ctx.r[30].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD10C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AD10C8 size=904
    let mut pc: u32 = 0x82AD10C8;
    'dispatch: loop {
        match pc {
            0x82AD10C8 => {
    //   block [0x82AD10C8..0x82AD1450)
	// 82AD10C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD10CC: 486D7081  bl 0x831a814c
	ctx.lr = 0x82AD10D0;
	sub_831A8130(ctx, base);
	// 82AD10D0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD10D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD10D8: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 82AD10DC: 4BA3F62D  bl 0x82510708
	ctx.lr = 0x82AD10E0;
	sub_82510708(ctx, base);
	// 82AD10E0: 807F011C  lwz r3, 0x11c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 82AD10E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD10E8: 419A0018  beq cr6, 0x82ad1100
	if ctx.cr[6].eq {
	pc = 0x82AD1100; continue 'dispatch;
	}
	// 82AD10EC: 4832D6F5  bl 0x82dfe7e0
	ctx.lr = 0x82AD10F0;
	sub_82DFE7E0(ctx, base);
	// 82AD10F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AD10F4: 4182000C  beq 0x82ad1100
	if ctx.cr[0].eq {
	pc = 0x82AD1100; continue 'dispatch;
	}
	// 82AD10F8: 387F00FC  addi r3, r31, 0xfc
	ctx.r[3].s64 = ctx.r[31].s64 + 252;
	// 82AD10FC: 48335425  bl 0x82e06520
	ctx.lr = 0x82AD1100;
	sub_82E06520(ctx, base);
	// 82AD1100: 387F00EC  addi r3, r31, 0xec
	ctx.r[3].s64 = ctx.r[31].s64 + 236;
	// 82AD1104: 485E0E7D  bl 0x830b1f80
	ctx.lr = 0x82AD1108;
	sub_830B1F80(ctx, base);
	// 82AD1108: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AD110C: 4182033C  beq 0x82ad1448
	if ctx.cr[0].eq {
	pc = 0x82AD1448; continue 'dispatch;
	}
	// 82AD1110: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD1114: 4BE4BC8D  bl 0x8291cda0
	ctx.lr = 0x82AD1118;
	sub_8291CDA0(ctx, base);
	// 82AD1118: 82E10054  lwz r23, 0x54(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AD111C: 83410050  lwz r26, 0x50(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AD1120: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 82AD1124: 92E10064  stw r23, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[23].u32 ) };
	// 82AD1128: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 82AD112C: 419A0024  beq cr6, 0x82ad1150
	if ctx.cr[6].eq {
	pc = 0x82AD1150; continue 'dispatch;
	}
	// 82AD1130: 39770004  addi r11, r23, 4
	ctx.r[11].s64 = ctx.r[23].s64 + 4;
	// 82AD1134: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AD1138: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AD113C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AD1140: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AD1144: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AD1148: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AD114C: 4082FFE8  bne 0x82ad1134
	if !ctx.cr[0].eq {
	pc = 0x82AD1134; continue 'dispatch;
	}
	// 82AD1150: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD1154: 80DF00C0  lwz r6, 0xc0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82AD1158: 3B9F0028  addi r28, r31, 0x28
	ctx.r[28].s64 = ctx.r[31].s64 + 40;
	// 82AD115C: 3B6BA490  addi r27, r11, -0x5b70
	ctx.r[27].s64 = ctx.r[11].s64 + -23408;
	// 82AD1160: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82AD1164: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AD1168: 38A00086  li r5, 0x86
	ctx.r[5].s64 = 134;
	// 82AD116C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82AD1170: 48385E79  bl 0x82e56fe8
	ctx.lr = 0x82AD1174;
	sub_82E56FE8(ctx, base);
	// 82AD1174: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82AD1178: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82AD117C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AD1180: 7D785850  subf r11, r24, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[24].s64;
	// 82AD1184: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD1188: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82AD118C: 557EDFFE  rlwinm r30, r11, 0x1b, 0x1f, 0x1f
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82AD1190: 419A0008  beq cr6, 0x82ad1198
	if ctx.cr[6].eq {
	pc = 0x82AD1198; continue 'dispatch;
	}
	// 82AD1194: 4B7EF6FD  bl 0x822c0890
	ctx.lr = 0x82AD1198;
	sub_822C0890(ctx, base);
	// 82AD1198: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AD119C: 4082029C  bne 0x82ad1438
	if !ctx.cr[0].eq {
	pc = 0x82AD1438; continue 'dispatch;
	}
	// 82AD11A0: 817F00DC  lwz r11, 0xdc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 82AD11A4: 3BBF00DC  addi r29, r31, 0xdc
	ctx.r[29].s64 = ctx.r[31].s64 + 220;
	// 82AD11A8: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AD11AC: 40820018  bne 0x82ad11c4
	if !ctx.cr[0].eq {
	pc = 0x82AD11C4; continue 'dispatch;
	}
	// 82AD11B0: C01A0018  lfs f0, 0x18(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AD11B4: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82AD11B8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD11BC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82AD11C0: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AD11C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AD11C8: C1BA001C  lfs f13, 0x1c(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AD11CC: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 82AD11D0: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AD11D4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AD11D8: 41990024  bgt cr6, 0x82ad11fc
	if ctx.cr[6].gt {
	pc = 0x82AD11FC; continue 'dispatch;
	}
	// 82AD11DC: C1BA0018  lfs f13, 0x18(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AD11E0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AD11E4: 41990010  bgt cr6, 0x82ad11f4
	if ctx.cr[6].gt {
	pc = 0x82AD11F4; continue 'dispatch;
	}
	// 82AD11E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD11EC: 4BA3F3E5  bl 0x825105d0
	ctx.lr = 0x82AD11F0;
	sub_825105D0(ctx, base);
	// 82AD11F0: 48000010  b 0x82ad1200
	pc = 0x82AD1200; continue 'dispatch;
	// 82AD11F4: 9B3F00D8  stb r25, 0xd8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[25].u8 ) };
	// 82AD11F8: 48000008  b 0x82ad1200
	pc = 0x82AD1200; continue 'dispatch;
	// 82AD11FC: 9B1F00D8  stb r24, 0xd8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[24].u8 ) };
	// 82AD1200: C1BF00D4  lfs f13, 0xd4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AD1204: C01A0018  lfs f0, 0x18(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AD1208: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AD120C: 4199000C  bgt cr6, 0x82ad1218
	if ctx.cr[6].gt {
	pc = 0x82AD1218; continue 'dispatch;
	}
	// 82AD1210: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82AD1214: 4098006C  bge cr6, 0x82ad1280
	if !ctx.cr[6].lt {
	pc = 0x82AD1280; continue 'dispatch;
	}
	// 82AD1218: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD121C: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82AD1220: 3BDF00F4  addi r30, r31, 0xf4
	ctx.r[30].s64 = ctx.r[31].s64 + 244;
	// 82AD1224: 3AABA464  addi r21, r11, -0x5b9c
	ctx.r[21].s64 = ctx.r[11].s64 + -23452;
	// 82AD1228: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD122C: C00BA464  lfs f0, -0x5b9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23452 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AD1230: D01F00D0  stfs f0, 0xd0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82AD1234: 485E0CF5  bl 0x830b1f28
	ctx.lr = 0x82AD1238;
	sub_830B1F28(ctx, base);
	// 82AD1238: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD123C: 485E1D6D  bl 0x830b2fa8
	ctx.lr = 0x82AD1240;
	sub_830B2FA8(ctx, base);
	// 82AD1240: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD1244: C0150004  lfs f0, 4(r21)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AD1248: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD124C: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 82AD1250: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AD1254: D01F00CC  stfs f0, 0xcc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82AD1258: C1BA001C  lfs f13, 0x1c(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AD125C: C01A0018  lfs f0, 0x18(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AD1260: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82AD1264: D01F00C8  stfs f0, 0xc8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82AD1268: 485E0CC1  bl 0x830b1f28
	ctx.lr = 0x82AD126C;
	sub_830B1F28(ctx, base);
	// 82AD126C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82AD1270: C1BF00C4  lfs f13, 0xc4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AD1274: C00B6218  lfs f0, 0x6218(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AD1278: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82AD127C: 485E0EB5  bl 0x830b2130
	ctx.lr = 0x82AD1280;
	sub_830B2130(ctx, base);
	// 82AD1280: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 82AD1284: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82AD1288: 409A0138  bne cr6, 0x82ad13c0
	if !ctx.cr[6].eq {
	pc = 0x82AD13C0; continue 'dispatch;
	}
	// 82AD128C: 3BDA0020  addi r30, r26, 0x20
	ctx.r[30].s64 = ctx.r[26].s64 + 32;
	// 82AD1290: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 82AD1294: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82AD1298: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AD129C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AD12A0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AD12A4: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD1450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD1450 size=132
    let mut pc: u32 = 0x82AD1450;
    'dispatch: loop {
        match pc {
            0x82AD1450 => {
    //   block [0x82AD1450..0x82AD14D4)
	// 82AD1450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD1454: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AD1458: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AD145C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AD1460: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD1464: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD1468: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD146C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AD1470: 396BA4FC  addi r11, r11, -0x5b04
	ctx.r[11].s64 = ctx.r[11].s64 + -23300;
	// 82AD1474: 394AA4E8  addi r10, r10, -0x5b18
	ctx.r[10].s64 = ctx.r[10].s64 + -23320;
	// 82AD1478: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AD147C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82AD1480: 807F0120  lwz r3, 0x120(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 82AD1484: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD1488: 419A0008  beq cr6, 0x82ad1490
	if ctx.cr[6].eq {
	pc = 0x82AD1490; continue 'dispatch;
	}
	// 82AD148C: 4B7EF405  bl 0x822c0890
	ctx.lr = 0x82AD1490;
	sub_822C0890(ctx, base);
	// 82AD1490: 3BDF00FC  addi r30, r31, 0xfc
	ctx.r[30].s64 = ctx.r[31].s64 + 252;
	// 82AD1494: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 82AD1498: 4B9DFE09  bl 0x824b12a0
	ctx.lr = 0x82AD149C;
	sub_824B12A0(ctx, base);
	// 82AD149C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD14A0: 4B9DFE01  bl 0x824b12a0
	ctx.lr = 0x82AD14A4;
	sub_824B12A0(ctx, base);
	// 82AD14A4: 387F00F4  addi r3, r31, 0xf4
	ctx.r[3].s64 = ctx.r[31].s64 + 244;
	// 82AD14A8: 485E0A31  bl 0x830b1ed8
	ctx.lr = 0x82AD14AC;
	sub_830B1ED8(ctx, base);
	// 82AD14AC: 387F00EC  addi r3, r31, 0xec
	ctx.r[3].s64 = ctx.r[31].s64 + 236;
	// 82AD14B0: 485E0A29  bl 0x830b1ed8
	ctx.lr = 0x82AD14B4;
	sub_830B1ED8(ctx, base);
	// 82AD14B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD14B8: 4BA3FCE1  bl 0x82511198
	ctx.lr = 0x82AD14BC;
	sub_82511198(ctx, base);
	// 82AD14BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AD14C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AD14C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AD14C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AD14CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AD14D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD14D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AD14D8 size=8
    let mut pc: u32 = 0x82AD14D8;
    'dispatch: loop {
        match pc {
            0x82AD14D8 => {
    //   block [0x82AD14D8..0x82AD14E0)
	// 82AD14D8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82AD14DC: 48000104  b 0x82ad15e0
	sub_82AD15E0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD14E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AD14E0 size=252
    let mut pc: u32 = 0x82AD14E0;
    'dispatch: loop {
        match pc {
            0x82AD14E0 => {
    //   block [0x82AD14E0..0x82AD15DC)
	// 82AD14E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD14E4: 486D6C89  bl 0x831a816c
	ctx.lr = 0x82AD14E8;
	sub_831A8130(ctx, base);
	// 82AD14E8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82AD14EC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD14F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD14F4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82AD14F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AD14FC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82AD1500: 4BA3FBF1  bl 0x825110f0
	ctx.lr = 0x82AD1504;
	sub_825110F0(ctx, base);
	// 82AD1504: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AD1508: 93DF00C0  stw r30, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 82AD150C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AD1510: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 82AD1514: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82AD1518: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AD151C: C1AB08A8  lfs f13, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AD1520: 3929A4FC  addi r9, r9, -0x5b04
	ctx.r[9].s64 = ctx.r[9].s64 + -23300;
	// 82AD1524: 3968A4E8  addi r11, r8, -0x5b18
	ctx.r[11].s64 = ctx.r[8].s64 + -23320;
	// 82AD1528: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AD152C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AD1530: D1BF00C4  stfs f13, 0xc4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82AD1534: D1BF00C8  stfs f13, 0xc8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82AD1538: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AD153C: D01F00CC  stfs f0, 0xcc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82AD1540: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82AD1544: D01F00D0  stfs f0, 0xd0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82AD1548: 9BDF00D8  stb r30, 0xd8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[30].u8 ) };
	// 82AD154C: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82AD1550: 93DF00DC  stw r30, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[30].u32 ) };
	// 82AD1554: 93BF00E0  stw r29, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[29].u32 ) };
	// 82AD1558: D3FF00E4  stfs f31, 0xe4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82AD155C: 995F00E8  stb r10, 0xe8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[10].u8 ) };
	// 82AD1560: 3BBF00EC  addi r29, r31, 0xec
	ctx.r[29].s64 = ctx.r[31].s64 + 236;
	// 82AD1564: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AD1568: 485E0959  bl 0x830b1ec0
	ctx.lr = 0x82AD156C;
	sub_830B1EC0(ctx, base);
	// 82AD156C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AD1570: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD1574: 396BD3F0  addi r11, r11, -0x2c10
	ctx.r[11].s64 = ctx.r[11].s64 + -11280;
	// 82AD1578: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AD157C: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 82AD1580: 485E0A19  bl 0x830b1f98
	ctx.lr = 0x82AD1584;
	sub_830B1F98(ctx, base);
	// 82AD1584: 3BBF00F4  addi r29, r31, 0xf4
	ctx.r[29].s64 = ctx.r[31].s64 + 244;
	// 82AD1588: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AD158C: 485E0935  bl 0x830b1ec0
	ctx.lr = 0x82AD1590;
	sub_830B1EC0(ctx, base);
	// 82AD1590: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AD1594: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD1598: 396BD3E4  addi r11, r11, -0x2c1c
	ctx.r[11].s64 = ctx.r[11].s64 + -11292;
	// 82AD159C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82AD15A0: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 82AD15A4: 485E09F5  bl 0x830b1f98
	ctx.lr = 0x82AD15A8;
	sub_830B1F98(ctx, base);
	// 82AD15A8: 93DF0100  stw r30, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[30].u32 ) };
	// 82AD15AC: 93DF0104  stw r30, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[30].u32 ) };
	// 82AD15B0: 397F00FC  addi r11, r31, 0xfc
	ctx.r[11].s64 = ctx.r[31].s64 + 252;
	// 82AD15B4: 93DF0108  stw r30, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[30].u32 ) };
	// 82AD15B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD15BC: 93DF0110  stw r30, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[30].u32 ) };
	// 82AD15C0: 93DF0114  stw r30, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[30].u32 ) };
	// 82AD15C4: 93DF0118  stw r30, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[30].u32 ) };
	// 82AD15C8: 93DF011C  stw r30, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[30].u32 ) };
	// 82AD15CC: 93DF0120  stw r30, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[30].u32 ) };
	// 82AD15D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AD15D4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82AD15D8: 486D6BE4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD15E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD15E0 size=76
    let mut pc: u32 = 0x82AD15E0;
    'dispatch: loop {
        match pc {
            0x82AD15E0 => {
    //   block [0x82AD15E0..0x82AD162C)
	// 82AD15E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD15E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AD15E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AD15EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AD15F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD15F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD15F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AD15FC: 4BFFFE55  bl 0x82ad1450
	ctx.lr = 0x82AD1600;
	sub_82AD1450(ctx, base);
	// 82AD1600: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AD1604: 4182000C  beq 0x82ad1610
	if ctx.cr[0].eq {
	pc = 0x82AD1610; continue 'dispatch;
	}
	// 82AD1608: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD160C: 48320DCD  bl 0x82df23d8
	ctx.lr = 0x82AD1610;
	sub_82DF23D8(ctx, base);
	// 82AD1610: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD1614: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AD1618: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AD161C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AD1620: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AD1624: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AD1628: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD1630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD1630 size=212
    let mut pc: u32 = 0x82AD1630;
    'dispatch: loop {
        match pc {
            0x82AD1630 => {
    //   block [0x82AD1630..0x82AD1704)
	// 82AD1630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD1634: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AD1638: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AD163C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AD1640: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD1644: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AD1648: F8810090  std r4, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[4].u64 ) };
	// 82AD164C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AD1650: F8A10098  std r5, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[5].u64 ) };
	// 82AD1654: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AD1658: 388B5D9C  addi r4, r11, 0x5d9c
	ctx.r[4].s64 = ctx.r[11].s64 + 23964;
	// 82AD165C: 38A0002B  li r5, 0x2b
	ctx.r[5].s64 = 43;
	// 82AD1660: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82AD1664: 4B7EED75  bl 0x822c03d8
	ctx.lr = 0x82AD1668;
	sub_822C03D8(ctx, base);
	// 82AD1668: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AD166C: 41820040  beq 0x82ad16ac
	if ctx.cr[0].eq {
	pc = 0x82AD16AC; continue 'dispatch;
	}
	// 82AD1670: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 82AD1674: 39230008  addi r9, r3, 8
	ctx.r[9].s64 = ctx.r[3].s64 + 8;
	// 82AD1678: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AD167C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD1680: 394AA488  addi r10, r10, -0x5b78
	ctx.r[10].s64 = ctx.r[10].s64 + -23416;
	// 82AD1684: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD1688: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AD168C: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AD1690: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82AD1694: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82AD1698: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82AD169C: 9103000C  stw r8, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82AD16A0: 90E30010  stw r7, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 82AD16A4: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82AD16A8: 48000008  b 0x82ad16b0
	pc = 0x82AD16B0; continue 'dispatch;
	// 82AD16AC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82AD16B0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82AD16B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD16B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AD16BC: 4BFFF4B5  bl 0x82ad0b70
	ctx.lr = 0x82AD16C0;
	sub_82AD0B70(ctx, base);
	// 82AD16C0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AD16C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD16C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82AD16CC: 4B7EE935  bl 0x822c0000
	ctx.lr = 0x82AD16D0;
	sub_822C0000(ctx, base);
	// 82AD16D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AD16D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD16D8: 480E1A31  bl 0x82bb3108
	ctx.lr = 0x82AD16DC;
	sub_82BB3108(ctx, base);
	// 82AD16DC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82AD16E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD16E4: 419A0008  beq cr6, 0x82ad16ec
	if ctx.cr[6].eq {
	pc = 0x82AD16EC; continue 'dispatch;
	}
	// 82AD16E8: 4B7EF1A9  bl 0x822c0890
	ctx.lr = 0x82AD16EC;
	sub_822C0890(ctx, base);
	// 82AD16EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AD16F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AD16F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AD16F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AD16FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AD1700: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD1708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD1708 size=256
    let mut pc: u32 = 0x82AD1708;
    'dispatch: loop {
        match pc {
            0x82AD1708 => {
    //   block [0x82AD1708..0x82AD1808)
	// 82AD1708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD170C: 486D6A61  bl 0x831a816c
	ctx.lr = 0x82AD1710;
	sub_831A8130(ctx, base);
	// 82AD1710: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD1714: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82AD1718: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD171C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82AD1720: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82AD1724: 4BA3DC4D  bl 0x8250f370
	ctx.lr = 0x82AD1728;
	sub_8250F370(ctx, base);
	// 82AD1728: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AD172C: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82AD1730: 409A0008  bne cr6, 0x82ad1738
	if !ctx.cr[6].eq {
	pc = 0x82AD1738; continue 'dispatch;
	}
	// 82AD1734: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD1738: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD173C: 4BA37065  bl 0x825087a0
	ctx.lr = 0x82AD1740;
	sub_825087A0(ctx, base);
	// 82AD1740: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82AD1744: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD1748: 808BE258  lwz r4, -0x1da8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7592 as u32) ) } as u64;
	// 82AD174C: 483222BD  bl 0x82df3a08
	ctx.lr = 0x82AD1750;
	sub_82DF3A08(ctx, base);
	// 82AD1750: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AD1754: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AD1758: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD175C: 4BA37025  bl 0x82508780
	ctx.lr = 0x82AD1760;
	sub_82508780(ctx, base);
	// 82AD1760: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD1764: 48321CC5  bl 0x82df3428
	ctx.lr = 0x82AD1768;
	sub_82DF3428(ctx, base);
	// 82AD1768: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AD176C: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD1770: 4BE43701  bl 0x82914e70
	ctx.lr = 0x82AD1774;
	sub_82914E70(ctx, base);
	// 82AD1774: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82AD1778: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD177C: 388B6900  addi r4, r11, 0x6900
	ctx.r[4].s64 = ctx.r[11].s64 + 26880;
	// 82AD1780: 48322289  bl 0x82df3a08
	ctx.lr = 0x82AD1784;
	sub_82DF3A08(ctx, base);
	// 82AD1784: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AD1788: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AD178C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AD1790: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AD1794: 4BB0BCE5  bl 0x825dd478
	ctx.lr = 0x82AD1798;
	sub_825DD478(ctx, base);
	// 82AD1798: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AD179C: 3BDF011C  addi r30, r31, 0x11c
	ctx.r[30].s64 = ctx.r[31].s64 + 284;
	// 82AD17A0: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82AD17A4: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82AD17A8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD17AC: 917F011C  stw r11, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[11].u32 ) };
	// 82AD17B0: 4B7F2CB1  bl 0x822c4460
	ctx.lr = 0x82AD17B4;
	sub_822C4460(ctx, base);
	// 82AD17B4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AD17B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD17BC: 419A0008  beq cr6, 0x82ad17c4
	if ctx.cr[6].eq {
	pc = 0x82AD17C4; continue 'dispatch;
	}
	// 82AD17C0: 4B7EF0D1  bl 0x822c0890
	ctx.lr = 0x82AD17C4;
	sub_822C0890(ctx, base);
	// 82AD17C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD17C8: 48321C61  bl 0x82df3428
	ctx.lr = 0x82AD17CC;
	sub_82DF3428(ctx, base);
	// 82AD17CC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD17D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD17D4: 419A002C  beq cr6, 0x82ad1800
	if ctx.cr[6].eq {
	pc = 0x82AD1800; continue 'dispatch;
	}
	// 82AD17D8: 3D6082AD  lis r11, -0x7d53
	ctx.r[11].s64 = -2102591488;
	// 82AD17DC: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82AD17E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82AD17E4: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82AD17E8: 396B0C38  addi r11, r11, 0xc38
	ctx.r[11].s64 = ctx.r[11].s64 + 3128;
	// 82AD17EC: 387F00FC  addi r3, r31, 0xfc
	ctx.r[3].s64 = ctx.r[31].s64 + 252;
	// 82AD17F0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82AD17F4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82AD17F8: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82AD17FC: 4BFFFE35  bl 0x82ad1630
	ctx.lr = 0x82AD1800;
	sub_82AD1630(ctx, base);
	// 82AD1800: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AD1804: 486D69B8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD1808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD1808 size=204
    let mut pc: u32 = 0x82AD1808;
    'dispatch: loop {
        match pc {
            0x82AD1808 => {
    //   block [0x82AD1808..0x82AD18D4)
	// 82AD1808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD180C: 486D6961  bl 0x831a816c
	ctx.lr = 0x82AD1810;
	sub_831A8130(ctx, base);
	// 82AD1810: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD1814: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD1818: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD181C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AD1820: 392BA544  addi r9, r11, -0x5abc
	ctx.r[9].s64 = ctx.r[11].s64 + -23228;
	// 82AD1824: 394AA52C  addi r10, r10, -0x5ad4
	ctx.r[10].s64 = ctx.r[10].s64 + -23252;
	// 82AD1828: 397F0168  addi r11, r31, 0x168
	ctx.r[11].s64 = ctx.r[31].s64 + 360;
	// 82AD182C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AD1830: 3BA00005  li r29, 5
	ctx.r[29].s64 = 5;
	// 82AD1834: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82AD1838: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 82AD183C: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 82AD1840: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD1844: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD1848: 419A0008  beq cr6, 0x82ad1850
	if ctx.cr[6].eq {
	pc = 0x82AD1850; continue 'dispatch;
	}
	// 82AD184C: 4B7EF045  bl 0x822c0890
	ctx.lr = 0x82AD1850;
	sub_822C0890(ctx, base);
	// 82AD1850: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AD1854: 4080FFE8  bge 0x82ad183c
	if !ctx.cr[0].lt {
	pc = 0x82AD183C; continue 'dispatch;
	}
	// 82AD1858: 397F0138  addi r11, r31, 0x138
	ctx.r[11].s64 = ctx.r[31].s64 + 312;
	// 82AD185C: 3BA00005  li r29, 5
	ctx.r[29].s64 = 5;
	// 82AD1860: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 82AD1864: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 82AD1868: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD186C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD1870: 419A0008  beq cr6, 0x82ad1878
	if ctx.cr[6].eq {
	pc = 0x82AD1878; continue 'dispatch;
	}
	// 82AD1874: 4B7EF01D  bl 0x822c0890
	ctx.lr = 0x82AD1878;
	sub_822C0890(ctx, base);
	// 82AD1878: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AD187C: 4080FFE8  bge 0x82ad1864
	if !ctx.cr[0].lt {
	pc = 0x82AD1864; continue 'dispatch;
	}
	// 82AD1880: 807F0104  lwz r3, 0x104(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 82AD1884: 397F0108  addi r11, r31, 0x108
	ctx.r[11].s64 = ctx.r[31].s64 + 264;
	// 82AD1888: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD188C: 419A0008  beq cr6, 0x82ad1894
	if ctx.cr[6].eq {
	pc = 0x82AD1894; continue 'dispatch;
	}
	// 82AD1890: 4B7EF001  bl 0x822c0890
	ctx.lr = 0x82AD1894;
	sub_822C0890(ctx, base);
	// 82AD1894: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82AD1898: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD189C: 419A0008  beq cr6, 0x82ad18a4
	if ctx.cr[6].eq {
	pc = 0x82AD18A4; continue 'dispatch;
	}
	// 82AD18A0: 4B7EEFF1  bl 0x822c0890
	ctx.lr = 0x82AD18A4;
	sub_822C0890(ctx, base);
	// 82AD18A4: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82AD18A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD18AC: 419A0008  beq cr6, 0x82ad18b4
	if ctx.cr[6].eq {
	pc = 0x82AD18B4; continue 'dispatch;
	}
	// 82AD18B0: 4B7EEFE1  bl 0x822c0890
	ctx.lr = 0x82AD18B4;
	sub_822C0890(ctx, base);
	// 82AD18B4: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82AD18B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD18BC: 419A0008  beq cr6, 0x82ad18c4
	if ctx.cr[6].eq {
	pc = 0x82AD18C4; continue 'dispatch;
	}
	// 82AD18C0: 4B7EEFD1  bl 0x822c0890
	ctx.lr = 0x82AD18C4;
	sub_822C0890(ctx, base);
	// 82AD18C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD18C8: 4B87DA89  bl 0x8234f350
	ctx.lr = 0x82AD18CC;
	sub_8234F350(ctx, base);
	// 82AD18CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AD18D0: 486D68EC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD18D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AD18D8 size=8
    let mut pc: u32 = 0x82AD18D8;
    'dispatch: loop {
        match pc {
            0x82AD18D8 => {
    //   block [0x82AD18D8..0x82AD18E0)
	// 82AD18D8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82AD18DC: 480003A4  b 0x82ad1c80
	sub_82AD1C80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD18E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD18E0 size=412
    let mut pc: u32 = 0x82AD18E0;
    'dispatch: loop {
        match pc {
            0x82AD18E0 => {
    //   block [0x82AD18E0..0x82AD1A7C)
	// 82AD18E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD18E4: 486D6885  bl 0x831a8168
	ctx.lr = 0x82AD18E8;
	sub_831A8130(ctx, base);
	// 82AD18E8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD18EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AD18F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD18F4: 397E0020  addi r11, r30, 0x20
	ctx.r[11].s64 = ctx.r[30].s64 + 32;
	// 82AD18F8: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AD18FC: 7FABFA14  add r29, r11, r31
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82AD1900: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82AD1904: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD1908: 419A0018  beq cr6, 0x82ad1920
	if ctx.cr[6].eq {
	pc = 0x82AD1920; continue 'dispatch;
	}
	// 82AD190C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD1910: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82AD1914: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AD1918: 4E800421  bctrl
	ctx.lr = 0x82AD191C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AD191C: 48000158  b 0x82ad1a74
	pc = 0x82AD1A74; continue 'dispatch;
	// 82AD1920: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD1924: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AD1928: 4BA3DBA1  bl 0x8250f4c8
	ctx.lr = 0x82AD192C;
	sub_8250F4C8(ctx, base);
	// 82AD192C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD1930: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82AD1934: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD1938: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82AD193C: 409A0008  bne cr6, 0x82ad1944
	if !ctx.cr[6].eq {
	pc = 0x82AD1944; continue 'dispatch;
	}
	// 82AD1940: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AD1944: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AD1948: 4BA39009  bl 0x8250a950
	ctx.lr = 0x82AD194C;
	sub_8250A950(ctx, base);
	// 82AD194C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AD1950: 48320341  bl 0x82df1c90
	ctx.lr = 0x82AD1954;
	sub_82DF1C90(ctx, base);
	// 82AD1954: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82AD1958: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AD195C: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82AD1960: 419A003C  beq cr6, 0x82ad199c
	if ctx.cr[6].eq {
	pc = 0x82AD199C; continue 'dispatch;
	}
	// 82AD1964: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD1968: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AD196C: 4BA407AD  bl 0x82512118
	ctx.lr = 0x82AD1970;
	sub_82512118(ctx, base);
	// 82AD1970: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AD1974: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AD1978: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82AD197C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD1980: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AD1984: 4B7F2ADD  bl 0x822c4460
	ctx.lr = 0x82AD1988;
	sub_822C4460(ctx, base);
	// 82AD1988: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AD198C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD1990: 419A005C  beq cr6, 0x82ad19ec
	if ctx.cr[6].eq {
	pc = 0x82AD19EC; continue 'dispatch;
	}
	// 82AD1994: 4B7EEEFD  bl 0x822c0890
	ctx.lr = 0x82AD1998;
	sub_822C0890(ctx, base);
	// 82AD1998: 48000054  b 0x82ad19ec
	pc = 0x82AD19EC; continue 'dispatch;
	// 82AD199C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AD19A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD19A4: 388B1EDC  addi r4, r11, 0x1edc
	ctx.r[4].s64 = ctx.r[11].s64 + 7900;
	// 82AD19A8: 48322061  bl 0x82df3a08
	ctx.lr = 0x82AD19AC;
	sub_82DF3A08(ctx, base);
	// 82AD19AC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AD19B0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AD19B4: 809F00E4  lwz r4, 0xe4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82AD19B8: 48343679  bl 0x82e15030
	ctx.lr = 0x82AD19BC;
	sub_82E15030(ctx, base);
	// 82AD19BC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AD19C0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82AD19C4: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82AD19C8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD19CC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82AD19D0: 4B7F2A91  bl 0x822c4460
	ctx.lr = 0x82AD19D4;
	sub_822C4460(ctx, base);
	// 82AD19D4: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AD19D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD19DC: 419A0008  beq cr6, 0x82ad19e4
	if ctx.cr[6].eq {
	pc = 0x82AD19E4; continue 'dispatch;
	}
	// 82AD19E0: 4B7EEEB1  bl 0x822c0890
	ctx.lr = 0x82AD19E4;
	sub_822C0890(ctx, base);
	// 82AD19E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD19E8: 48321A41  bl 0x82df3428
	ctx.lr = 0x82AD19EC;
	sub_82DF3428(ctx, base);
	// 82AD19EC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD19F0: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82AD19F4: 396BA524  addi r11, r11, -0x5adc
	ctx.r[11].s64 = ctx.r[11].s64 + -23260;
	// 82AD19F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD19FC: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82AD1A00: 48322009  bl 0x82df3a08
	ctx.lr = 0x82AD1A04;
	sub_82DF3A08(ctx, base);
	// 82AD1A04: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AD1A08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD1A0C: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 82AD1A10: 409A0008  bne cr6, 0x82ad1a18
	if !ctx.cr[6].eq {
	pc = 0x82AD1A18; continue 'dispatch;
	}
	// 82AD1A14: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AD1A18: 38E0000B  li r7, 0xb
	ctx.r[7].s64 = 11;
	// 82AD1A1C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AD1A20: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82AD1A24: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82AD1A28: 4BD03289  bl 0x827d4cb0
	ctx.lr = 0x82AD1A2C;
	sub_827D4CB0(ctx, base);
	// 82AD1A2C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AD1A30: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 82AD1A34: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82AD1A38: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD1A3C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AD1A40: 4B7F2A21  bl 0x822c4460
	ctx.lr = 0x82AD1A44;
	sub_822C4460(ctx, base);
	// 82AD1A44: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AD1A48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD1A4C: 419A0008  beq cr6, 0x82ad1a54
	if ctx.cr[6].eq {
	pc = 0x82AD1A54; continue 'dispatch;
	}
	// 82AD1A50: 4B7EEE41  bl 0x822c0890
	ctx.lr = 0x82AD1A54;
	sub_822C0890(ctx, base);
	// 82AD1A54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD1A58: 483219D1  bl 0x82df3428
	ctx.lr = 0x82AD1A5C;
	sub_82DF3428(ctx, base);
	// 82AD1A5C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AD1A60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD1A64: 419A0008  beq cr6, 0x82ad1a6c
	if ctx.cr[6].eq {
	pc = 0x82AD1A6C; continue 'dispatch;
	}
	// 82AD1A68: 4B7EEE29  bl 0x822c0890
	ctx.lr = 0x82AD1A6C;
	sub_822C0890(ctx, base);
	// 82AD1A6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AD1A70: 48320221  bl 0x82df1c90
	ctx.lr = 0x82AD1A74;
	sub_82DF1C90(ctx, base);
	// 82AD1A74: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82AD1A78: 486D6740  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD1A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD1A80 size=176
    let mut pc: u32 = 0x82AD1A80;
    'dispatch: loop {
        match pc {
            0x82AD1A80 => {
    //   block [0x82AD1A80..0x82AD1B30)
	// 82AD1A80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD1A84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AD1A88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AD1A8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AD1A90: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD1A94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD1A98: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD1A9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD1AA0: 4BA3DA29  bl 0x8250f4c8
	ctx.lr = 0x82AD1AA4;
	sub_8250F4C8(ctx, base);
	// 82AD1AA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD1AA8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AD1AAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD1AB0: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82AD1AB4: 409A0008  bne cr6, 0x82ad1abc
	if !ctx.cr[6].eq {
	pc = 0x82AD1ABC; continue 'dispatch;
	}
	// 82AD1AB8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AD1ABC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD1AC0: 4BA38E91  bl 0x8250a950
	ctx.lr = 0x82AD1AC4;
	sub_8250A950(ctx, base);
	// 82AD1AC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD1AC8: 483201C9  bl 0x82df1c90
	ctx.lr = 0x82AD1ACC;
	sub_82DF1C90(ctx, base);
	// 82AD1ACC: 3BFF0100  addi r31, r31, 0x100
	ctx.r[31].s64 = ctx.r[31].s64 + 256;
	// 82AD1AD0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD1AD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD1AD8: 419A0038  beq cr6, 0x82ad1b10
	if ctx.cr[6].eq {
	pc = 0x82AD1B10; continue 'dispatch;
	}
	// 82AD1ADC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AD1AE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD1AE4: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82AD1AE8: 409A0008  bne cr6, 0x82ad1af0
	if !ctx.cr[6].eq {
	pc = 0x82AD1AF0; continue 'dispatch;
	}
	// 82AD1AEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD1AF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD1AF4: 4BD01F0D  bl 0x827d3a00
	ctx.lr = 0x82AD1AF8;
	sub_827D3A00(ctx, base);
	// 82AD1AF8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82AD1AFC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AD1B00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD1B04: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82AD1B08: 419A0008  beq cr6, 0x82ad1b10
	if ctx.cr[6].eq {
	pc = 0x82AD1B10; continue 'dispatch;
	}
	// 82AD1B0C: 4B7EED85  bl 0x822c0890
	ctx.lr = 0x82AD1B10;
	sub_822C0890(ctx, base);
	// 82AD1B10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD1B14: 4832017D  bl 0x82df1c90
	ctx.lr = 0x82AD1B18;
	sub_82DF1C90(ctx, base);
	// 82AD1B18: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AD1B1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AD1B20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AD1B24: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AD1B28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AD1B2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD1B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD1B30 size=168
    let mut pc: u32 = 0x82AD1B30;
    'dispatch: loop {
        match pc {
            0x82AD1B30 => {
    //   block [0x82AD1B30..0x82AD1BD8)
	// 82AD1B30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD1B34: 486D6635  bl 0x831a8168
	ctx.lr = 0x82AD1B38;
	sub_831A8130(ctx, base);
	// 82AD1B38: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD1B3C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82AD1B40: 3BA00006  li r29, 6
	ctx.r[29].s64 = 6;
	// 82AD1B44: 3BFC0108  addi r31, r28, 0x108
	ctx.r[31].s64 = ctx.r[28].s64 + 264;
	// 82AD1B48: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82AD1B4C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD1B50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD1B54: 419A0070  beq cr6, 0x82ad1bc4
	if ctx.cr[6].eq {
	pc = 0x82AD1BC4; continue 'dispatch;
	}
	// 82AD1B58: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AD1B5C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD1B60: 4BA3D969  bl 0x8250f4c8
	ctx.lr = 0x82AD1B64;
	sub_8250F4C8(ctx, base);
	// 82AD1B64: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD1B68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD1B6C: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82AD1B70: 409A0008  bne cr6, 0x82ad1b78
	if !ctx.cr[6].eq {
	pc = 0x82AD1B78; continue 'dispatch;
	}
	// 82AD1B74: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AD1B78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD1B7C: 4BA38DD5  bl 0x8250a950
	ctx.lr = 0x82AD1B80;
	sub_8250A950(ctx, base);
	// 82AD1B80: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD1B84: 4832010D  bl 0x82df1c90
	ctx.lr = 0x82AD1B88;
	sub_82DF1C90(ctx, base);
	// 82AD1B88: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82AD1B8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD1B90: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 82AD1B94: 409A0008  bne cr6, 0x82ad1b9c
	if !ctx.cr[6].eq {
	pc = 0x82AD1B9C; continue 'dispatch;
	}
	// 82AD1B98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD1B9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD1BA0: 4BD01E61  bl 0x827d3a00
	ctx.lr = 0x82AD1BA4;
	sub_827D3A00(ctx, base);
	// 82AD1BA4: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82AD1BA8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AD1BAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD1BB0: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82AD1BB4: 419A0008  beq cr6, 0x82ad1bbc
	if ctx.cr[6].eq {
	pc = 0x82AD1BBC; continue 'dispatch;
	}
	// 82AD1BB8: 4B7EECD9  bl 0x822c0890
	ctx.lr = 0x82AD1BBC;
	sub_822C0890(ctx, base);
	// 82AD1BBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD1BC0: 483200D1  bl 0x82df1c90
	ctx.lr = 0x82AD1BC4;
	sub_82DF1C90(ctx, base);
	// 82AD1BC4: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82AD1BC8: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82AD1BCC: 4082FF80  bne 0x82ad1b4c
	if !ctx.cr[0].eq {
	pc = 0x82AD1B4C; continue 'dispatch;
	}
	// 82AD1BD0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82AD1BD4: 486D65E4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD1BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD1BD8 size=168
    let mut pc: u32 = 0x82AD1BD8;
    'dispatch: loop {
        match pc {
            0x82AD1BD8 => {
    //   block [0x82AD1BD8..0x82AD1C80)
	// 82AD1BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD1BDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AD1BE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AD1BE4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD1BE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD1BEC: 4BA40745  bl 0x82512330
	ctx.lr = 0x82AD1BF0;
	sub_82512330(ctx, base);
	// 82AD1BF0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD1BF4: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AD1BF8: 392BA544  addi r9, r11, -0x5abc
	ctx.r[9].s64 = ctx.r[11].s64 + -23228;
	// 82AD1BFC: 394AA52C  addi r10, r10, -0x5ad4
	ctx.r[10].s64 = ctx.r[10].s64 + -23252;
	// 82AD1C00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AD1C04: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AD1C08: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82AD1C0C: 395F0108  addi r10, r31, 0x108
	ctx.r[10].s64 = ctx.r[31].s64 + 264;
	// 82AD1C10: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82AD1C14: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 82AD1C18: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82AD1C1C: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 82AD1C20: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 82AD1C24: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 82AD1C28: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 82AD1C2C: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 82AD1C30: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 82AD1C34: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 82AD1C38: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AD1C3C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AD1C40: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AD1C44: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82AD1C48: 4080FFF0  bge 0x82ad1c38
	if !ctx.cr[0].lt {
	pc = 0x82AD1C38; continue 'dispatch;
	}
	// 82AD1C4C: 395F0138  addi r10, r31, 0x138
	ctx.r[10].s64 = ctx.r[31].s64 + 312;
	// 82AD1C50: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 82AD1C54: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AD1C58: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82AD1C5C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82AD1C60: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82AD1C64: 4080FFF0  bge 0x82ad1c54
	if !ctx.cr[0].lt {
	pc = 0x82AD1C54; continue 'dispatch;
	}
	// 82AD1C68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD1C6C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AD1C70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AD1C74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AD1C78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AD1C7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD1C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD1C80 size=76
    let mut pc: u32 = 0x82AD1C80;
    'dispatch: loop {
        match pc {
            0x82AD1C80 => {
    //   block [0x82AD1C80..0x82AD1CCC)
	// 82AD1C80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD1C84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AD1C88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AD1C8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AD1C90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD1C94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD1C98: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AD1C9C: 4BFFFB6D  bl 0x82ad1808
	ctx.lr = 0x82AD1CA0;
	sub_82AD1808(ctx, base);
	// 82AD1CA0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AD1CA4: 4182000C  beq 0x82ad1cb0
	if ctx.cr[0].eq {
	pc = 0x82AD1CB0; continue 'dispatch;
	}
	// 82AD1CA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD1CAC: 4832072D  bl 0x82df23d8
	ctx.lr = 0x82AD1CB0;
	sub_82DF23D8(ctx, base);
	// 82AD1CB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD1CB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AD1CB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AD1CBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AD1CC0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AD1CC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AD1CC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD1CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD1CD0 size=60
    let mut pc: u32 = 0x82AD1CD0;
    'dispatch: loop {
        match pc {
            0x82AD1CD0 => {
    //   block [0x82AD1CD0..0x82AD1D0C)
	// 82AD1CD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD1CD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AD1CD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AD1CDC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD1CE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD1CE4: 4BA40385  bl 0x82512068
	ctx.lr = 0x82AD1CE8;
	sub_82512068(ctx, base);
	// 82AD1CE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD1CEC: 4BFFFD95  bl 0x82ad1a80
	ctx.lr = 0x82AD1CF0;
	sub_82AD1A80(ctx, base);
	// 82AD1CF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD1CF4: 4BFFFE3D  bl 0x82ad1b30
	ctx.lr = 0x82AD1CF8;
	sub_82AD1B30(ctx, base);
	// 82AD1CF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AD1CFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AD1D00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AD1D04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AD1D08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD1D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD1D10 size=688
    let mut pc: u32 = 0x82AD1D10;
    'dispatch: loop {
        match pc {
            0x82AD1D10 => {
    //   block [0x82AD1D10..0x82AD1FC0)
	// 82AD1D10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD1D14: 486D644D  bl 0x831a8160
	ctx.lr = 0x82AD1D18;
	sub_831A8130(ctx, base);
	// 82AD1D18: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD1D1C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82AD1D20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD1D24: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82AD1D28: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82AD1D2C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82AD1D30: 4BA3FCA9  bl 0x825119d8
	ctx.lr = 0x82AD1D34;
	sub_825119D8(ctx, base);
	// 82AD1D34: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AD1D38: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82AD1D3C: 409A0008  bne cr6, 0x82ad1d44
	if !ctx.cr[6].eq {
	pc = 0x82AD1D44; continue 'dispatch;
	}
	// 82AD1D40: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD1D44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD1D48: 4BA36A59  bl 0x825087a0
	ctx.lr = 0x82AD1D4C;
	sub_825087A0(ctx, base);
	// 82AD1D4C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82AD1D50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD1D54: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82AD1D58: 48321CB1  bl 0x82df3a08
	ctx.lr = 0x82AD1D5C;
	sub_82DF3A08(ctx, base);
	// 82AD1D5C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82AD1D60: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AD1D64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD1D68: 4BA36A19  bl 0x82508780
	ctx.lr = 0x82AD1D6C;
	sub_82508780(ctx, base);
	// 82AD1D6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD1D70: 483216B9  bl 0x82df3428
	ctx.lr = 0x82AD1D74;
	sub_82DF3428(ctx, base);
	// 82AD1D74: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AD1D78: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD1D7C: 48358D6D  bl 0x82e2aae8
	ctx.lr = 0x82AD1D80;
	sub_82E2AAE8(ctx, base);
	// 82AD1D80: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AD1D84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD1D88: 3BAB0F70  addi r29, r11, 0xf70
	ctx.r[29].s64 = ctx.r[11].s64 + 3952;
	// 82AD1D8C: 808B0F70  lwz r4, 0xf70(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3952 as u32) ) } as u64;
	// 82AD1D90: 48321C79  bl 0x82df3a08
	ctx.lr = 0x82AD1D94;
	sub_82DF3A08(ctx, base);
	// 82AD1D94: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AD1D98: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AD1D9C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82AD1DA0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82AD1DA4: 4835D0CD  bl 0x82e2ee70
	ctx.lr = 0x82AD1DA8;
	sub_82E2EE70(ctx, base);
	// 82AD1DA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD1DAC: 4832167D  bl 0x82df3428
	ctx.lr = 0x82AD1DB0;
	sub_82DF3428(ctx, base);
	// 82AD1DB0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD1DB4: 3B6BA580  addi r27, r11, -0x5a80
	ctx.r[27].s64 = ctx.r[11].s64 + -23168;
	// 82AD1DB8: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82AD1DBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD1DC0: 419A0074  beq cr6, 0x82ad1e34
	if ctx.cr[6].eq {
	pc = 0x82AD1E34; continue 'dispatch;
	}
	// 82AD1DC4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AD1DC8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AD1DCC: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 82AD1DD0: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82AD1DD4: 48320615  bl 0x82df23e8
	ctx.lr = 0x82AD1DD8;
	sub_82DF23E8(ctx, base);
	// 82AD1DD8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AD1DDC: 41820014  beq 0x82ad1df0
	if ctx.cr[0].eq {
	pc = 0x82AD1DF0; continue 'dispatch;
	}
	// 82AD1DE0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82AD1DE4: 48344AAD  bl 0x82e16890
	ctx.lr = 0x82AD1DE8;
	sub_82E16890(ctx, base);
	// 82AD1DE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AD1DEC: 48000008  b 0x82ad1df4
	pc = 0x82AD1DF4; continue 'dispatch;
	// 82AD1DF0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD1DF4: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 82AD1DF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD1DFC: 4B88B575  bl 0x8235d370
	ctx.lr = 0x82AD1E00;
	sub_8235D370(ctx, base);
	// 82AD1E00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD1E04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD1E08: 835F00E4  lwz r26, 0xe4(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82AD1E0C: 4BA4030D  bl 0x82512118
	ctx.lr = 0x82AD1E10;
	sub_82512118(ctx, base);
	// 82AD1E10: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AD1E14: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82AD1E18: 48343299  bl 0x82e150b0
	ctx.lr = 0x82AD1E1C;
	sub_82E150B0(ctx, base);
	// 82AD1E1C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82AD1E20: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82AD1E24: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82AD1E28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD1E2C: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82AD1E30: 4BA3ED29  bl 0x82510b58
	ctx.lr = 0x82AD1E34;
	sub_82510B58(ctx, base);
	// 82AD1E34: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AD1E38: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AD1E3C: 38A0006B  li r5, 0x6b
	ctx.r[5].s64 = 107;
	// 82AD1E40: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 82AD1E44: 483205A5  bl 0x82df23e8
	ctx.lr = 0x82AD1E48;
	sub_82DF23E8(ctx, base);
	// 82AD1E48: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AD1E4C: 4182003C  beq 0x82ad1e88
	if ctx.cr[0].eq {
	pc = 0x82AD1E88; continue 'dispatch;
	}
	// 82AD1E50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD1E54: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AD1E58: 48321BB1  bl 0x82df3a08
	ctx.lr = 0x82AD1E5C;
	sub_82DF3A08(ctx, base);
	// 82AD1E5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD1E60: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AD1E64: 3B800003  li r28, 3
	ctx.r[28].s64 = 3;
	// 82AD1E68: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 82AD1E6C: 4BA3D65D  bl 0x8250f4c8
	ctx.lr = 0x82AD1E70;
	sub_8250F4C8(ctx, base);
	// 82AD1E70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AD1E74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD1E78: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AD1E7C: 480E1D85  bl 0x82bb3c00
	ctx.lr = 0x82AD1E80;
	sub_82BB3C00(ctx, base);
	// 82AD1E80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AD1E84: 48000008  b 0x82ad1e8c
	pc = 0x82AD1E8C; continue 'dispatch;
	// 82AD1E88: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD1E8C: 3BDF00EC  addi r30, r31, 0xec
	ctx.r[30].s64 = ctx.r[31].s64 + 236;
	// 82AD1E90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD1E94: 4B88B54D  bl 0x8235d3e0
	ctx.lr = 0x82AD1E98;
	sub_8235D3E0(ctx, base);
	// 82AD1E98: 578B07BD  rlwinm. r11, r28, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AD1E9C: 41820010  beq 0x82ad1eac
	if ctx.cr[0].eq {
	pc = 0x82AD1EAC; continue 'dispatch;
	}
	// 82AD1EA0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82AD1EA4: 579C07FA  rlwinm r28, r28, 0, 0x1f, 0x1d
	ctx.r[28].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 82AD1EA8: 4831FDE9  bl 0x82df1c90
	ctx.lr = 0x82AD1EAC;
	sub_82DF1C90(ctx, base);
	// 82AD1EAC: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AD1EB0: 4182000C  beq 0x82ad1ebc
	if ctx.cr[0].eq {
	pc = 0x82AD1EBC; continue 'dispatch;
	}
	// 82AD1EB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD1EB8: 48321571  bl 0x82df3428
	ctx.lr = 0x82AD1EBC;
	sub_82DF3428(ctx, base);
	// 82AD1EBC: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AD1EC0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD1EC4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82AD1EC8: 388B0F7C  addi r4, r11, 0xf7c
	ctx.r[4].s64 = ctx.r[11].s64 + 3964;
	// 82AD1ECC: 480E3095  bl 0x82bb4f60
	ctx.lr = 0x82AD1ED0;
	sub_82BB4F60(ctx, base);
	// 82AD1ED0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AD1ED4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD1ED8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD1EDC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82AD1EE0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82AD1EE4: 419A0024  beq cr6, 0x82ad1f08
	if ctx.cr[6].eq {
	pc = 0x82AD1F08; continue 'dispatch;
	}
	// 82AD1EE8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AD1EEC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AD1EF0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AD1EF4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AD1EF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AD1EFC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AD1F00: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AD1F04: 4082FFE8  bne 0x82ad1eec
	if !ctx.cr[0].eq {
	pc = 0x82AD1EEC; continue 'dispatch;
	}
	// 82AD1F08: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82AD1F0C: 807F00E4  lwz r3, 0xe4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82AD1F10: 48343061  bl 0x82e14f70
	ctx.lr = 0x82AD1F14;
	sub_82E14F70(ctx, base);
	// 82AD1F14: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AD1F18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD1F1C: 419A0008  beq cr6, 0x82ad1f24
	if ctx.cr[6].eq {
	pc = 0x82AD1F24; continue 'dispatch;
	}
	// 82AD1F20: 4B7EE971  bl 0x822c0890
	ctx.lr = 0x82AD1F24;
	sub_822C0890(ctx, base);
	// 82AD1F24: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD1F28: 480E2841  bl 0x82bb4768
	ctx.lr = 0x82AD1F2C;
	sub_82BB4768(ctx, base);
	// 82AD1F2C: 807F00E4  lwz r3, 0xe4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82AD1F30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD1F34: 419A006C  beq cr6, 0x82ad1fa0
	if ctx.cr[6].eq {
	pc = 0x82AD1FA0; continue 'dispatch;
	}
	// 82AD1F38: 48357469  bl 0x82e293a0
	ctx.lr = 0x82AD1F3C;
	sub_82E293A0(ctx, base);
	// 82AD1F3C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AD1F40: 40820060  bne 0x82ad1fa0
	if !ctx.cr[0].eq {
	pc = 0x82AD1FA0; continue 'dispatch;
	}
	// 82AD1F44: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82AD1F48: 815F00E4  lwz r10, 0xe4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82AD1F4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD1F50: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AD1F54: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AD1F58: 419A0024  beq cr6, 0x82ad1f7c
	if ctx.cr[6].eq {
	pc = 0x82AD1F7C; continue 'dispatch;
	}
	// 82AD1F5C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AD1F60: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AD1F64: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AD1F68: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AD1F6C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AD1F70: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AD1F74: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AD1F78: 4082FFE8  bne 0x82ad1f60
	if !ctx.cr[0].eq {
	pc = 0x82AD1F60; continue 'dispatch;
	}
	// 82AD1F7C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AD1F80: 4BA18B09  bl 0x824eaa88
	ctx.lr = 0x82AD1F84;
	sub_824EAA88(ctx, base);
	// 82AD1F84: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82AD1F88: 38C00072  li r6, 0x72
	ctx.r[6].s64 = 114;
	// 82AD1F8C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD1F90: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82AD1F94: 4BC001FD  bl 0x826d2190
	ctx.lr = 0x82AD1F98;
	sub_826D2190(ctx, base);
	// 82AD1F98: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82AD1F9C: 4831FCF5  bl 0x82df1c90
	ctx.lr = 0x82AD1FA0;
	sub_82DF1C90(ctx, base);
	// 82AD1FA0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AD1FA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD1FA8: 419A0008  beq cr6, 0x82ad1fb0
	if ctx.cr[6].eq {
	pc = 0x82AD1FB0; continue 'dispatch;
	}
	// 82AD1FAC: 4B7EE8E5  bl 0x822c0890
	ctx.lr = 0x82AD1FB0;
	sub_822C0890(ctx, base);
	// 82AD1FB0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82AD1FB4: 48358B4D  bl 0x82e2ab00
	ctx.lr = 0x82AD1FB8;
	sub_82E2AB00(ctx, base);
	// 82AD1FB8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82AD1FBC: 486D61F4  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD1FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AD1FC0 size=2084
    let mut pc: u32 = 0x82AD1FC0;
    'dispatch: loop {
        match pc {
            0x82AD1FC0 => {
    //   block [0x82AD1FC0..0x82AD27E4)
	// 82AD1FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD1FC4: 486D619D  bl 0x831a8160
	ctx.lr = 0x82AD1FC8;
	sub_831A8130(ctx, base);
	// 82AD1FC8: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82AD1FCC: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD1FD0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AD1FD4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82AD1FD8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82AD1FDC: 4BA3D4ED  bl 0x8250f4c8
	ctx.lr = 0x82AD1FE0;
	sub_8250F4C8(ctx, base);
	// 82AD1FE0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD1FE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD1FE8: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82AD1FEC: 409A0008  bne cr6, 0x82ad1ff4
	if !ctx.cr[6].eq {
	pc = 0x82AD1FF4; continue 'dispatch;
	}
	// 82AD1FF0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD1FF4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD1FF8: 4BA38959  bl 0x8250a950
	ctx.lr = 0x82AD1FFC;
	sub_8250A950(ctx, base);
	// 82AD1FFC: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82AD2000: 4831FC91  bl 0x82df1c90
	ctx.lr = 0x82AD2004;
	sub_82DF1C90(ctx, base);
	// 82AD2004: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD2008: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AD200C: 3B6BA580  addi r27, r11, -0x5a80
	ctx.r[27].s64 = ctx.r[11].s64 + -23168;
	// 82AD2010: 38A000DD  li r5, 0xdd
	ctx.r[5].s64 = 221;
	// 82AD2014: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AD2018: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82AD201C: 483203CD  bl 0x82df23e8
	ctx.lr = 0x82AD2020;
	sub_82DF23E8(ctx, base);
	// 82AD2020: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AD2024: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AD2028: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82AD202C: 41820064  beq 0x82ad2090
	if ctx.cr[0].eq {
	pc = 0x82AD2090; continue 'dispatch;
	}
	// 82AD2030: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 82AD2034: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82AD2038: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 82AD203C: C00BDFAC  lfs f0, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AD2040: C1AA9530  lfs f13, -0x6ad0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27344 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82AD2044: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82AD2048: 483AAA01  bl 0x82e7ca48
	ctx.lr = 0x82AD204C;
	sub_82E7CA48(ctx, base);
	// 82AD204C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AD2050: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82AD2054: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82AD2058: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82AD205C: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 82AD2060: C06B9F78  lfs f3, -0x6088(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24712 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82AD2064: C02A04B0  lfs f1, 0x4b0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1200 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AD2068: 483A9FB1  bl 0x82e7c018
	ctx.lr = 0x82AD206C;
	sub_82E7C018(ctx, base);
	// 82AD206C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AD2070: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82AD2074: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82AD2078: 4B7F2889  bl 0x822c4900
	ctx.lr = 0x82AD207C;
	sub_822C4900(ctx, base);
	// 82AD207C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AD2080: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD2084: 4834106D  bl 0x82e130f0
	ctx.lr = 0x82AD2088;
	sub_82E130F0(ctx, base);
	// 82AD2088: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AD208C: 48000008  b 0x82ad2094
	pc = 0x82AD2094; continue 'dispatch;
	// 82AD2090: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD2094: 3BFE0138  addi r31, r30, 0x138
	ctx.r[31].s64 = ctx.r[30].s64 + 312;
	// 82AD2098: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD209C: 4B80FCB5  bl 0x822e1d50
	ctx.lr = 0x82AD20A0;
	sub_822E1D50(ctx, base);
	// 82AD20A0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AD20A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD20A8: 388B1EDC  addi r4, r11, 0x1edc
	ctx.r[4].s64 = ctx.r[11].s64 + 7900;
	// 82AD20AC: 4832195D  bl 0x82df3a08
	ctx.lr = 0x82AD20B0;
	sub_82DF3A08(ctx, base);
	// 82AD20B0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AD20B4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82AD20B8: 809E00E4  lwz r4, 0xe4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(228 as u32) ) } as u64;
	// 82AD20BC: 83BE0138  lwz r29, 0x138(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(312 as u32) ) } as u64;
	// 82AD20C0: 48342F71  bl 0x82e15030
	ctx.lr = 0x82AD20C4;
	sub_82E15030(ctx, base);
	// 82AD20C4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AD20C8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD20CC: 48340D65  bl 0x82e12e30
	ctx.lr = 0x82AD20D0;
	sub_82E12E30(ctx, base);
	// 82AD20D0: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82AD20D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD20D8: 419A0008  beq cr6, 0x82ad20e0
	if ctx.cr[6].eq {
	pc = 0x82AD20E0; continue 'dispatch;
	}
	// 82AD20DC: 4B7EE7B5  bl 0x822c0890
	ctx.lr = 0x82AD20E0;
	sub_822C0890(ctx, base);
	// 82AD20E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD20E4: 48321345  bl 0x82df3428
	ctx.lr = 0x82AD20E8;
	sub_82DF3428(ctx, base);
	// 82AD20E8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82AD20EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD20F0: 388B63D8  addi r4, r11, 0x63d8
	ctx.r[4].s64 = ctx.r[11].s64 + 25560;
	// 82AD20F4: 48321915  bl 0x82df3a08
	ctx.lr = 0x82AD20F8;
	sub_82DF3A08(ctx, base);
	// 82AD20F8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AD20FC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD2100: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD2104: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82AD2108: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82AD210C: 419A0024  beq cr6, 0x82ad2130
	if ctx.cr[6].eq {
	pc = 0x82AD2130; continue 'dispatch;
	}
	// 82AD2110: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AD2114: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AD2118: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AD211C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AD2120: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AD2124: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AD2128: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AD212C: 4082FFE8  bne 0x82ad2114
	if !ctx.cr[0].eq {
	pc = 0x82AD2114; continue 'dispatch;
	}
	// 82AD2130: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AD2134: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD2138: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 82AD213C: 409A0008  bne cr6, 0x82ad2144
	if !ctx.cr[6].eq {
	pc = 0x82AD2144; continue 'dispatch;
	}
	// 82AD2140: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD2144: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 82AD2148: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AD214C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82AD2150: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82AD2154: 4BD02B5D  bl 0x827d4cb0
	ctx.lr = 0x82AD2158;
	sub_827D4CB0(ctx, base);
	// 82AD2158: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AD215C: 395E0108  addi r10, r30, 0x108
	ctx.r[10].s64 = ctx.r[30].s64 + 264;
	// 82AD2160: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82AD2164: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82AD2168: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD216C: 917E0108  stw r11, 0x108(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 82AD2170: 4B7F22F1  bl 0x822c4460
	ctx.lr = 0x82AD2174;
	sub_822C4460(ctx, base);
	// 82AD2174: 806100F4  lwz r3, 0xf4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82AD2178: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD217C: 419A0008  beq cr6, 0x82ad2184
	if ctx.cr[6].eq {
	pc = 0x82AD2184; continue 'dispatch;
	}
	// 82AD2180: 4B7EE711  bl 0x822c0890
	ctx.lr = 0x82AD2184;
	sub_822C0890(ctx, base);
	// 82AD2184: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82AD2188: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD218C: 419A0008  beq cr6, 0x82ad2194
	if ctx.cr[6].eq {
	pc = 0x82AD2194; continue 'dispatch;
	}
	// 82AD2190: 4B7EE701  bl 0x822c0890
	ctx.lr = 0x82AD2194;
	sub_822C0890(ctx, base);
	// 82AD2194: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD2198: 48321291  bl 0x82df3428
	ctx.lr = 0x82AD219C;
	sub_82DF3428(ctx, base);
	// 82AD219C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AD21A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AD21A4: 38A000E1  li r5, 0xe1
	ctx.r[5].s64 = 225;
	// 82AD21A8: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82AD21AC: 4832023D  bl 0x82df23e8
	ctx.lr = 0x82AD21B0;
	sub_82DF23E8(ctx, base);
	// 82AD21B0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82AD21B4: 41820034  beq 0x82ad21e8
	if ctx.cr[0].eq {
	pc = 0x82AD21E8; continue 'dispatch;
	}
	// 82AD21B8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AD21BC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82AD21C0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82AD21C4: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82AD21C8: C06B0B54  lfs f3, 0xb54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2900 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82AD21CC: C04A964C  lfs f2, -0x69b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AD21D0: 483A9E49  bl 0x82e7c018
	ctx.lr = 0x82AD21D4;
	sub_82E7C018(ctx, base);
	// 82AD21D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AD21D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD21DC: 48340F15  bl 0x82e130f0
	ctx.lr = 0x82AD21E0;
	sub_82E130F0(ctx, base);
	// 82AD21E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AD21E4: 48000008  b 0x82ad21ec
	pc = 0x82AD21EC; continue 'dispatch;
	// 82AD21E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD21EC: 3BFE0140  addi r31, r30, 0x140
	ctx.r[31].s64 = ctx.r[30].s64 + 320;
	// 82AD21F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD21F4: 4B80FB5D  bl 0x822e1d50
	ctx.lr = 0x82AD21F8;
	sub_822E1D50(ctx, base);
	// 82AD21F8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82AD21FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD2200: 388B4DD4  addi r4, r11, 0x4dd4
	ctx.r[4].s64 = ctx.r[11].s64 + 19924;
	// 82AD2204: 48321805  bl 0x82df3a08
	ctx.lr = 0x82AD2208;
	sub_82DF3A08(ctx, base);
	// 82AD2208: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AD220C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82AD2210: 809E00E4  lwz r4, 0xe4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(228 as u32) ) } as u64;
	// 82AD2214: 83BE0140  lwz r29, 0x140(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(320 as u32) ) } as u64;
	// 82AD2218: 48342E19  bl 0x82e15030
	ctx.lr = 0x82AD221C;
	sub_82E15030(ctx, base);
	// 82AD221C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AD2220: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD2224: 48340C0D  bl 0x82e12e30
	ctx.lr = 0x82AD2228;
	sub_82E12E30(ctx, base);
	// 82AD2228: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82AD222C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD2230: 419A0008  beq cr6, 0x82ad2238
	if ctx.cr[6].eq {
	pc = 0x82AD2238; continue 'dispatch;
	}
	// 82AD2234: 4B7EE65D  bl 0x822c0890
	ctx.lr = 0x82AD2238;
	sub_822C0890(ctx, base);
	// 82AD2238: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD223C: 483211ED  bl 0x82df3428
	ctx.lr = 0x82AD2240;
	sub_82DF3428(ctx, base);
	// 82AD2240: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82AD2244: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD2248: 3B8B63C0  addi r28, r11, 0x63c0
	ctx.r[28].s64 = ctx.r[11].s64 + 25536;
	// 82AD224C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AD2250: 483217B9  bl 0x82df3a08
	ctx.lr = 0x82AD2254;
	sub_82DF3A08(ctx, base);
	// 82AD2254: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AD2258: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD225C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD2260: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82AD2264: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82AD2268: 419A0024  beq cr6, 0x82ad228c
	if ctx.cr[6].eq {
	pc = 0x82AD228C; continue 'dispatch;
	}
	// 82AD226C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AD2270: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AD2274: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AD2278: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AD227C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AD2280: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AD2284: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AD2288: 4082FFE8  bne 0x82ad2270
	if !ctx.cr[0].eq {
	pc = 0x82AD2270; continue 'dispatch;
	}
	// 82AD228C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AD2290: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD2294: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 82AD2298: 409A0008  bne cr6, 0x82ad22a0
	if !ctx.cr[6].eq {
	pc = 0x82AD22A0; continue 'dispatch;
	}
	// 82AD229C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD22A0: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 82AD22A4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AD22A8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82AD22AC: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82AD22B0: 4BD02A01  bl 0x827d4cb0
	ctx.lr = 0x82AD22B4;
	sub_827D4CB0(ctx, base);
	// 82AD22B4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AD22B8: 395E0110  addi r10, r30, 0x110
	ctx.r[10].s64 = ctx.r[30].s64 + 272;
	// 82AD22BC: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82AD22C0: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82AD22C4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD22C8: 917E0110  stw r11, 0x110(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82AD22CC: 4B7F2195  bl 0x822c4460
	ctx.lr = 0x82AD22D0;
	sub_822C4460(ctx, base);
	// 82AD22D0: 806100E4  lwz r3, 0xe4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 82AD22D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD22D8: 419A0008  beq cr6, 0x82ad22e0
	if ctx.cr[6].eq {
	pc = 0x82AD22E0; continue 'dispatch;
	}
	// 82AD22DC: 4B7EE5B5  bl 0x822c0890
	ctx.lr = 0x82AD22E0;
	sub_822C0890(ctx, base);
	// 82AD22E0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82AD22E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD22E8: 419A0008  beq cr6, 0x82ad22f0
	if ctx.cr[6].eq {
	pc = 0x82AD22F0; continue 'dispatch;
	}
	// 82AD22EC: 4B7EE5A5  bl 0x822c0890
	ctx.lr = 0x82AD22F0;
	sub_822C0890(ctx, base);
	// 82AD22F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD22F4: 48321135  bl 0x82df3428
	ctx.lr = 0x82AD22F8;
	sub_82DF3428(ctx, base);
	// 82AD22F8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AD22FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AD2300: 38A000E5  li r5, 0xe5
	ctx.r[5].s64 = 229;
	// 82AD2304: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82AD2308: 483200E1  bl 0x82df23e8
	ctx.lr = 0x82AD230C;
	sub_82DF23E8(ctx, base);
	// 82AD230C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82AD2310: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AD2314: 3BAB6880  addi r29, r11, 0x6880
	ctx.r[29].s64 = ctx.r[11].s64 + 26752;
	// 82AD2318: 41820014  beq 0x82ad232c
	if ctx.cr[0].eq {
	pc = 0x82AD232C; continue 'dispatch;
	}
	// 82AD231C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AD2320: 48340DD1  bl 0x82e130f0
	ctx.lr = 0x82AD2324;
	sub_82E130F0(ctx, base);
	// 82AD2324: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AD2328: 48000008  b 0x82ad2330
	pc = 0x82AD2330; continue 'dispatch;
	// 82AD232C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD2330: 3BFE0148  addi r31, r30, 0x148
	ctx.r[31].s64 = ctx.r[30].s64 + 328;
	// 82AD2334: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD2338: 4B80FA19  bl 0x822e1d50
	ctx.lr = 0x82AD233C;
	sub_822E1D50(ctx, base);
	// 82AD233C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82AD2340: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD2344: 388BF820  addi r4, r11, -0x7e0
	ctx.r[4].s64 = ctx.r[11].s64 + -2016;
	// 82AD2348: 483216C1  bl 0x82df3a08
	ctx.lr = 0x82AD234C;
	sub_82DF3A08(ctx, base);
	// 82AD234C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AD2350: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82AD2354: 809E00E4  lwz r4, 0xe4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(228 as u32) ) } as u64;
	// 82AD2358: 835E0148  lwz r26, 0x148(r30)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(328 as u32) ) } as u64;
	// 82AD235C: 48342CD5  bl 0x82e15030
	ctx.lr = 0x82AD2360;
	sub_82E15030(ctx, base);
	// 82AD2360: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82AD2364: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD2368: 48340AC9  bl 0x82e12e30
	ctx.lr = 0x82AD236C;
	sub_82E12E30(ctx, base);
	// 82AD236C: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82AD2370: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD2374: 419A0008  beq cr6, 0x82ad237c
	if ctx.cr[6].eq {
	pc = 0x82AD237C; continue 'dispatch;
	}
	// 82AD2378: 4B7EE519  bl 0x822c0890
	ctx.lr = 0x82AD237C;
	sub_822C0890(ctx, base);
	// 82AD237C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD2380: 483210A9  bl 0x82df3428
	ctx.lr = 0x82AD2384;
	sub_82DF3428(ctx, base);
	// 82AD2384: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AD2388: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD238C: 4832167D  bl 0x82df3a08
	ctx.lr = 0x82AD2390;
	sub_82DF3A08(ctx, base);
	// 82AD2390: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AD2394: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD2398: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD239C: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82AD23A0: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 82AD23A4: 419A0024  beq cr6, 0x82ad23c8
	if ctx.cr[6].eq {
	pc = 0x82AD23C8; continue 'dispatch;
	}
	// 82AD23A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AD23AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AD23B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AD23B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AD23B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AD23BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AD23C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AD23C4: 4082FFE8  bne 0x82ad23ac
	if !ctx.cr[0].eq {
	pc = 0x82AD23AC; continue 'dispatch;
	}
	// 82AD23C8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AD23CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD23D0: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 82AD23D4: 409A0008  bne cr6, 0x82ad23dc
	if !ctx.cr[6].eq {
	pc = 0x82AD23DC; continue 'dispatch;
	}
	// 82AD23D8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD23DC: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 82AD23E0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AD23E4: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82AD23E8: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 82AD23EC: 4BD028C5  bl 0x827d4cb0
	ctx.lr = 0x82AD23F0;
	sub_827D4CB0(ctx, base);
	// 82AD23F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AD23F4: 395E0118  addi r10, r30, 0x118
	ctx.r[10].s64 = ctx.r[30].s64 + 280;
	// 82AD23F8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82AD23FC: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82AD2400: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD2404: 917E0118  stw r11, 0x118(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 82AD2408: 4B7F2059  bl 0x822c4460
	ctx.lr = 0x82AD240C;
	sub_822C4460(ctx, base);
	// 82AD240C: 806100EC  lwz r3, 0xec(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AD2410: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD2414: 419A0008  beq cr6, 0x82ad241c
	if ctx.cr[6].eq {
	pc = 0x82AD241C; continue 'dispatch;
	}
	// 82AD2418: 4B7EE479  bl 0x822c0890
	ctx.lr = 0x82AD241C;
	sub_822C0890(ctx, base);
	// 82AD241C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82AD2420: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD2424: 419A0008  beq cr6, 0x82ad242c
	if ctx.cr[6].eq {
	pc = 0x82AD242C; continue 'dispatch;
	}
	// 82AD2428: 4B7EE469  bl 0x822c0890
	ctx.lr = 0x82AD242C;
	sub_822C0890(ctx, base);
	// 82AD242C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD2430: 48320FF9  bl 0x82df3428
	ctx.lr = 0x82AD2434;
	sub_82DF3428(ctx, base);
	// 82AD2434: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AD2438: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AD243C: 38A000E9  li r5, 0xe9
	ctx.r[5].s64 = 233;
	// 82AD2440: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82AD2444: 4831FFA5  bl 0x82df23e8
	ctx.lr = 0x82AD2448;
	sub_82DF23E8(ctx, base);
	// 82AD2448: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AD244C: 41820014  beq 0x82ad2460
	if ctx.cr[0].eq {
	pc = 0x82AD2460; continue 'dispatch;
	}
	// 82AD2450: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AD2454: 48340C9D  bl 0x82e130f0
	ctx.lr = 0x82AD2458;
	sub_82E130F0(ctx, base);
	// 82AD2458: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AD245C: 48000008  b 0x82ad2464
	pc = 0x82AD2464; continue 'dispatch;
	// 82AD2460: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD2464: 3BFE0150  addi r31, r30, 0x150
	ctx.r[31].s64 = ctx.r[30].s64 + 336;
	// 82AD2468: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD246C: 4B80F8E5  bl 0x822e1d50
	ctx.lr = 0x82AD2470;
	sub_822E1D50(ctx, base);
	// 82AD2470: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82AD2474: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD2478: 388BF818  addi r4, r11, -0x7e8
	ctx.r[4].s64 = ctx.r[11].s64 + -2024;
	// 82AD247C: 4832158D  bl 0x82df3a08
	ctx.lr = 0x82AD2480;
	sub_82DF3A08(ctx, base);
	// 82AD2480: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AD2484: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82AD2488: 809E00E4  lwz r4, 0xe4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(228 as u32) ) } as u64;
	// 82AD248C: 835E0150  lwz r26, 0x150(r30)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(336 as u32) ) } as u64;
	// 82AD2490: 48342BA1  bl 0x82e15030
	ctx.lr = 0x82AD2494;
	sub_82E15030(ctx, base);
	// 82AD2494: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82AD2498: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD249C: 48340995  bl 0x82e12e30
	ctx.lr = 0x82AD24A0;
	sub_82E12E30(ctx, base);
	// 82AD24A0: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82AD24A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD24A8: 419A0008  beq cr6, 0x82ad24b0
	if ctx.cr[6].eq {
	pc = 0x82AD24B0; continue 'dispatch;
	}
	// 82AD24AC: 4B7EE3E5  bl 0x822c0890
	ctx.lr = 0x82AD24B0;
	sub_822C0890(ctx, base);
	// 82AD24B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD24B4: 48320F75  bl 0x82df3428
	ctx.lr = 0x82AD24B8;
	sub_82DF3428(ctx, base);
	// 82AD24B8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AD24BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD24C0: 48321549  bl 0x82df3a08
	ctx.lr = 0x82AD24C4;
	sub_82DF3A08(ctx, base);
	// 82AD24C4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AD24C8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD24CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD24D0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82AD24D4: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82AD24D8: 419A0024  beq cr6, 0x82ad24fc
	if ctx.cr[6].eq {
	pc = 0x82AD24FC; continue 'dispatch;
	}
	// 82AD24DC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AD24E0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AD24E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AD24E8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AD24EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AD24F0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AD24F4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AD24F8: 4082FFE8  bne 0x82ad24e0
	if !ctx.cr[0].eq {
	pc = 0x82AD24E0; continue 'dispatch;
	}
	// 82AD24FC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AD2500: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD2504: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 82AD2508: 409A0008  bne cr6, 0x82ad2510
	if !ctx.cr[6].eq {
	pc = 0x82AD2510; continue 'dispatch;
	}
	// 82AD250C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD2510: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 82AD2514: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AD2518: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82AD251C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82AD2520: 4BD02791  bl 0x827d4cb0
	ctx.lr = 0x82AD2524;
	sub_827D4CB0(ctx, base);
	// 82AD2524: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AD2528: 395E0120  addi r10, r30, 0x120
	ctx.r[10].s64 = ctx.r[30].s64 + 288;
	// 82AD252C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82AD2530: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82AD2534: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD2538: 917E0120  stw r11, 0x120(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 82AD253C: 4B7F1F25  bl 0x822c4460
	ctx.lr = 0x82AD2540;
	sub_822C4460(ctx, base);
	// 82AD2540: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82AD2544: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD2548: 419A0008  beq cr6, 0x82ad2550
	if ctx.cr[6].eq {
	pc = 0x82AD2550; continue 'dispatch;
	}
	// 82AD254C: 4B7EE345  bl 0x822c0890
	ctx.lr = 0x82AD2550;
	sub_822C0890(ctx, base);
	// 82AD2550: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82AD2554: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD2558: 419A0008  beq cr6, 0x82ad2560
	if ctx.cr[6].eq {
	pc = 0x82AD2560; continue 'dispatch;
	}
	// 82AD255C: 4B7EE335  bl 0x822c0890
	ctx.lr = 0x82AD2560;
	sub_822C0890(ctx, base);
	// 82AD2560: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD2564: 48320EC5  bl 0x82df3428
	ctx.lr = 0x82AD2568;
	sub_82DF3428(ctx, base);
	// 82AD2568: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AD256C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AD2570: 38A000ED  li r5, 0xed
	ctx.r[5].s64 = 237;
	// 82AD2574: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82AD2578: 4831FE71  bl 0x82df23e8
	ctx.lr = 0x82AD257C;
	sub_82DF23E8(ctx, base);
	// 82AD257C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AD2580: 41820014  beq 0x82ad2594
	if ctx.cr[0].eq {
	pc = 0x82AD2594; continue 'dispatch;
	}
	// 82AD2584: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AD2588: 48340B69  bl 0x82e130f0
	ctx.lr = 0x82AD258C;
	sub_82E130F0(ctx, base);
	// 82AD258C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AD2590: 48000008  b 0x82ad2598
	pc = 0x82AD2598; continue 'dispatch;
	// 82AD2594: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD2598: 3BFE0158  addi r31, r30, 0x158
	ctx.r[31].s64 = ctx.r[30].s64 + 344;
	// 82AD259C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD25A0: 4B80F7B1  bl 0x822e1d50
	ctx.lr = 0x82AD25A4;
	sub_822E1D50(ctx, base);
	// 82AD25A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AD25A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD25AC: 388B50DC  addi r4, r11, 0x50dc
	ctx.r[4].s64 = ctx.r[11].s64 + 20700;
	// 82AD25B0: 48321459  bl 0x82df3a08
	ctx.lr = 0x82AD25B4;
	sub_82DF3A08(ctx, base);
	// 82AD25B4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AD25B8: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82AD25BC: 809E00E4  lwz r4, 0xe4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(228 as u32) ) } as u64;
	// 82AD25C0: 835E0158  lwz r26, 0x158(r30)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(344 as u32) ) } as u64;
	// 82AD25C4: 48342A6D  bl 0x82e15030
	ctx.lr = 0x82AD25C8;
	sub_82E15030(ctx, base);
	// 82AD25C8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82AD25CC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD25D0: 48340861  bl 0x82e12e30
	ctx.lr = 0x82AD25D4;
	sub_82E12E30(ctx, base);
	// 82AD25D4: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82AD25D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD25DC: 419A0008  beq cr6, 0x82ad25e4
	if ctx.cr[6].eq {
	pc = 0x82AD25E4; continue 'dispatch;
	}
	// 82AD25E0: 4B7EE2B1  bl 0x822c0890
	ctx.lr = 0x82AD25E4;
	sub_822C0890(ctx, base);
	// 82AD25E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD25E8: 48320E41  bl 0x82df3428
	ctx.lr = 0x82AD25EC;
	sub_82DF3428(ctx, base);
	// 82AD25EC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AD25F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD25F4: 48321415  bl 0x82df3a08
	ctx.lr = 0x82AD25F8;
	sub_82DF3A08(ctx, base);
	// 82AD25F8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AD25FC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD2600: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD2604: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82AD2608: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 82AD260C: 419A0024  beq cr6, 0x82ad2630
	if ctx.cr[6].eq {
	pc = 0x82AD2630; continue 'dispatch;
	}
	// 82AD2610: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AD2614: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AD2618: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AD261C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AD2620: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AD2624: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AD2628: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AD262C: 4082FFE8  bne 0x82ad2614
	if !ctx.cr[0].eq {
	pc = 0x82AD2614; continue 'dispatch;
	}
	// 82AD2630: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AD2634: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD2638: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 82AD263C: 409A0008  bne cr6, 0x82ad2644
	if !ctx.cr[6].eq {
	pc = 0x82AD2644; continue 'dispatch;
	}
	// 82AD2640: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD2644: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 82AD2648: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AD264C: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 82AD2650: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82AD2654: 4BD0265D  bl 0x827d4cb0
	ctx.lr = 0x82AD2658;
	sub_827D4CB0(ctx, base);
	// 82AD2658: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AD265C: 395E0128  addi r10, r30, 0x128
	ctx.r[10].s64 = ctx.r[30].s64 + 296;
	// 82AD2660: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82AD2664: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82AD2668: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD266C: 917E0128  stw r11, 0x128(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 82AD2670: 4B7F1DF1  bl 0x822c4460
	ctx.lr = 0x82AD2674;
	sub_822C4460(ctx, base);
	// 82AD2674: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82AD2678: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD267C: 419A0008  beq cr6, 0x82ad2684
	if ctx.cr[6].eq {
	pc = 0x82AD2684; continue 'dispatch;
	}
	// 82AD2680: 4B7EE211  bl 0x822c0890
	ctx.lr = 0x82AD2684;
	sub_822C0890(ctx, base);
	// 82AD2684: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82AD2688: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD268C: 419A0008  beq cr6, 0x82ad2694
	if ctx.cr[6].eq {
	pc = 0x82AD2694; continue 'dispatch;
	}
	// 82AD2690: 4B7EE201  bl 0x822c0890
	ctx.lr = 0x82AD2694;
	sub_822C0890(ctx, base);
	// 82AD2694: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD2698: 48320D91  bl 0x82df3428
	ctx.lr = 0x82AD269C;
	sub_82DF3428(ctx, base);
	// 82AD269C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82AD26A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82AD26A4: 38A000F1  li r5, 0xf1
	ctx.r[5].s64 = 241;
	// 82AD26A8: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82AD26AC: 4831FD3D  bl 0x82df23e8
	ctx.lr = 0x82AD26B0;
	sub_82DF23E8(ctx, base);
	// 82AD26B0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AD26B4: 41820014  beq 0x82ad26c8
	if ctx.cr[0].eq {
	pc = 0x82AD26C8; continue 'dispatch;
	}
	// 82AD26B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AD26BC: 48340A35  bl 0x82e130f0
	ctx.lr = 0x82AD26C0;
	sub_82E130F0(ctx, base);
	// 82AD26C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AD26C4: 48000008  b 0x82ad26cc
	pc = 0x82AD26CC; continue 'dispatch;
	// 82AD26C8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD26CC: 3BFE0160  addi r31, r30, 0x160
	ctx.r[31].s64 = ctx.r[30].s64 + 352;
	// 82AD26D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD26D4: 4B80F67D  bl 0x822e1d50
	ctx.lr = 0x82AD26D8;
	sub_822E1D50(ctx, base);
	// 82AD26D8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AD26DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD26E0: 388B50C4  addi r4, r11, 0x50c4
	ctx.r[4].s64 = ctx.r[11].s64 + 20676;
	// 82AD26E4: 48321325  bl 0x82df3a08
	ctx.lr = 0x82AD26E8;
	sub_82DF3A08(ctx, base);
	// 82AD26E8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AD26EC: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82AD26F0: 809E00E4  lwz r4, 0xe4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(228 as u32) ) } as u64;
	// 82AD26F4: 83BE0160  lwz r29, 0x160(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 82AD26F8: 48342939  bl 0x82e15030
	ctx.lr = 0x82AD26FC;
	sub_82E15030(ctx, base);
	// 82AD26FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AD2700: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD2704: 4834072D  bl 0x82e12e30
	ctx.lr = 0x82AD2708;
	sub_82E12E30(ctx, base);
	// 82AD2708: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82AD270C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD2710: 419A0008  beq cr6, 0x82ad2718
	if ctx.cr[6].eq {
	pc = 0x82AD2718; continue 'dispatch;
	}
	// 82AD2714: 4B7EE17D  bl 0x822c0890
	ctx.lr = 0x82AD2718;
	sub_822C0890(ctx, base);
	// 82AD2718: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD271C: 48320D0D  bl 0x82df3428
	ctx.lr = 0x82AD2720;
	sub_82DF3428(ctx, base);
	// 82AD2720: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82AD2724: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD2728: 483212E1  bl 0x82df3a08
	ctx.lr = 0x82AD272C;
	sub_82DF3A08(ctx, base);
	// 82AD272C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AD2730: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD2734: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD2738: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82AD273C: 91410088  stw r10, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 82AD2740: 419A0024  beq cr6, 0x82ad2764
	if ctx.cr[6].eq {
	pc = 0x82AD2764; continue 'dispatch;
	}
	// 82AD2744: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82AD2748: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82AD274C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AD2750: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82AD2754: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82AD2758: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82AD275C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82AD2760: 4082FFE8  bne 0x82ad2748
	if !ctx.cr[0].eq {
	pc = 0x82AD2748; continue 'dispatch;
	}
	// 82AD2764: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82AD2768: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD276C: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 82AD2770: 409A0008  bne cr6, 0x82ad2778
	if !ctx.cr[6].eq {
	pc = 0x82AD2778; continue 'dispatch;
	}
	// 82AD2774: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD2778: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 82AD277C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82AD2780: 38A10088  addi r5, r1, 0x88
	ctx.r[5].s64 = ctx.r[1].s64 + 136;
	// 82AD2784: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82AD2788: 4BD02529  bl 0x827d4cb0
	ctx.lr = 0x82AD278C;
	sub_827D4CB0(ctx, base);
	// 82AD278C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AD2790: 395E0130  addi r10, r30, 0x130
	ctx.r[10].s64 = ctx.r[30].s64 + 304;
	// 82AD2794: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82AD2798: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82AD279C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD27A0: 917E0130  stw r11, 0x130(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 82AD27A4: 4B7F1CBD  bl 0x822c4460
	ctx.lr = 0x82AD27A8;
	sub_822C4460(ctx, base);
	// 82AD27A8: 806100DC  lwz r3, 0xdc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82AD27AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD27B0: 419A0008  beq cr6, 0x82ad27b8
	if ctx.cr[6].eq {
	pc = 0x82AD27B8; continue 'dispatch;
	}
	// 82AD27B4: 4B7EE0DD  bl 0x822c0890
	ctx.lr = 0x82AD27B8;
	sub_822C0890(ctx, base);
	// 82AD27B8: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82AD27BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD27C0: 419A0008  beq cr6, 0x82ad27c8
	if ctx.cr[6].eq {
	pc = 0x82AD27C8; continue 'dispatch;
	}
	// 82AD27C4: 4B7EE0CD  bl 0x822c0890
	ctx.lr = 0x82AD27C8;
	sub_822C0890(ctx, base);
	// 82AD27C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD27CC: 48320C5D  bl 0x82df3428
	ctx.lr = 0x82AD27D0;
	sub_82DF3428(ctx, base);
	// 82AD27D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD27D4: 4831F4BD  bl 0x82df1c90
	ctx.lr = 0x82AD27D8;
	sub_82DF1C90(ctx, base);
	// 82AD27D8: 38210200  addi r1, r1, 0x200
	ctx.r[1].s64 = ctx.r[1].s64 + 512;
	// 82AD27DC: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82AD27E0: 486D59D0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD27E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AD27E8 size=320
    let mut pc: u32 = 0x82AD27E8;
    'dispatch: loop {
        match pc {
            0x82AD27E8 => {
    //   block [0x82AD27E8..0x82AD2928)
	// 82AD27E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD27EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AD27F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AD27F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AD27F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD27FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD2800: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AD2804: 4BA3DF05  bl 0x82510708
	ctx.lr = 0x82AD2808;
	sub_82510708(ctx, base);
	// 82AD2808: 817F00FC  lwz r11, 0xfc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82AD280C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82AD2810: 41980054  blt cr6, 0x82ad2864
	if ctx.cr[6].lt {
	pc = 0x82AD2864; continue 'dispatch;
	}
	// 82AD2814: 419A0018  beq cr6, 0x82ad282c
	if ctx.cr[6].eq {
	pc = 0x82AD282C; continue 'dispatch;
	}
	// 82AD2818: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82AD281C: 409800F4  bge cr6, 0x82ad2910
	if !ctx.cr[6].lt {
	pc = 0x82AD2910; continue 'dispatch;
	}
	// 82AD2820: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD2824: 4BA3DDAD  bl 0x825105d0
	ctx.lr = 0x82AD2828;
	sub_825105D0(ctx, base);
	// 82AD2828: 480000E8  b 0x82ad2910
	pc = 0x82AD2910; continue 'dispatch;
	// 82AD282C: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AD2830: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AD2834: 480E2CBD  bl 0x82bb54f0
	ctx.lr = 0x82AD2838;
	sub_82BB54F0(ctx, base);
	// 82AD2838: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AD283C: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82AD2840: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AD2844: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD2848: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82AD284C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AD2850: 4E800421  bctrl
	ctx.lr = 0x82AD2854;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AD2854: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AD2858: 418200B8  beq 0x82ad2910
	if ctx.cr[0].eq {
	pc = 0x82AD2910; continue 'dispatch;
	}
	// 82AD285C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82AD2860: 480000AC  b 0x82ad290c
	pc = 0x82AD290C; continue 'dispatch;
	// 82AD2864: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82AD2868: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82AD286C: 4832BF75  bl 0x82dfe7e0
	ctx.lr = 0x82AD2870;
	sub_82DFE7E0(ctx, base);
	// 82AD2870: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AD2874: 4182009C  beq 0x82ad2910
	if ctx.cr[0].eq {
	pc = 0x82AD2910; continue 'dispatch;
	}
	// 82AD2878: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AD287C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD2880: 419A0090  beq cr6, 0x82ad2910
	if ctx.cr[6].eq {
	pc = 0x82AD2910; continue 'dispatch;
	}
	// 82AD2884: 480E1F95  bl 0x82bb4818
	ctx.lr = 0x82AD2888;
	sub_82BB4818(ctx, base);
	// 82AD2888: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AD288C: 41820084  beq 0x82ad2910
	if ctx.cr[0].eq {
	pc = 0x82AD2910; continue 'dispatch;
	}
	// 82AD2890: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AD2894: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD2898: 388B0FB0  addi r4, r11, 0xfb0
	ctx.r[4].s64 = ctx.r[11].s64 + 4016;
	// 82AD289C: 4BA3F1E5  bl 0x82511a80
	ctx.lr = 0x82AD28A0;
	sub_82511A80(ctx, base);
	// 82AD28A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD28A4: 4BFFF71D  bl 0x82ad1fc0
	ctx.lr = 0x82AD28A8;
	sub_82AD1FC0(ctx, base);
	// 82AD28A8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD28AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD28B0: 4BFFF031  bl 0x82ad18e0
	ctx.lr = 0x82AD28B4;
	sub_82AD18E0(ctx, base);
	// 82AD28B4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82AD28B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD28BC: 388BCB24  addi r4, r11, -0x34dc
	ctx.r[4].s64 = ctx.r[11].s64 + -13532;
	// 82AD28C0: 48321149  bl 0x82df3a08
	ctx.lr = 0x82AD28C4;
	sub_82DF3A08(ctx, base);
	// 82AD28C4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82AD28C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD28CC: 809F00EC  lwz r4, 0xec(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AD28D0: 480E0A41  bl 0x82bb3310
	ctx.lr = 0x82AD28D4;
	sub_82BB3310(ctx, base);
	// 82AD28D4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AD28D8: 395F00F4  addi r10, r31, 0xf4
	ctx.r[10].s64 = ctx.r[31].s64 + 244;
	// 82AD28DC: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82AD28E0: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82AD28E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD28E8: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 82AD28EC: 4B7F1B75  bl 0x822c4460
	ctx.lr = 0x82AD28F0;
	sub_822C4460(ctx, base);
	// 82AD28F0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82AD28F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD28F8: 419A0008  beq cr6, 0x82ad2900
	if ctx.cr[6].eq {
	pc = 0x82AD2900; continue 'dispatch;
	}
	// 82AD28FC: 4B7EDF95  bl 0x822c0890
	ctx.lr = 0x82AD2900;
	sub_822C0890(ctx, base);
	// 82AD2900: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD2904: 48320B25  bl 0x82df3428
	ctx.lr = 0x82AD2908;
	sub_82DF3428(ctx, base);
	// 82AD2908: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AD290C: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 82AD2910: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AD2914: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AD2918: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AD291C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AD2920: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AD2924: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD2928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AD2928 size=12
    let mut pc: u32 = 0x82AD2928;
    'dispatch: loop {
        match pc {
            0x82AD2928 => {
    //   block [0x82AD2928..0x82AD2934)
	// 82AD2928: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AD292C: 996300FD  stb r11, 0xfd(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(253 as u32), ctx.r[11].u8 ) };
	// 82AD2930: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD2938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AD2938 size=8
    let mut pc: u32 = 0x82AD2938;
    'dispatch: loop {
        match pc {
            0x82AD2938 => {
    //   block [0x82AD2938..0x82AD2940)
	// 82AD2938: C0230134  lfs f1, 0x134(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(308 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AD293C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD2940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AD2940 size=12
    let mut pc: u32 = 0x82AD2940;
    'dispatch: loop {
        match pc {
            0x82AD2940 => {
    //   block [0x82AD2940..0x82AD294C)
	// 82AD2940: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AD2944: 9963013B  stb r11, 0x13b(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(315 as u32), ctx.r[11].u8 ) };
	// 82AD2948: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD2950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AD2950 size=12
    let mut pc: u32 = 0x82AD2950;
    'dispatch: loop {
        match pc {
            0x82AD2950 => {
    //   block [0x82AD2950..0x82AD295C)
	// 82AD2950: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AD2954: 9963013B  stb r11, 0x13b(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(315 as u32), ctx.r[11].u8 ) };
	// 82AD2958: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD2960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AD2960 size=16
    let mut pc: u32 = 0x82AD2960;
    'dispatch: loop {
        match pc {
            0x82AD2960 => {
    //   block [0x82AD2960..0x82AD2970)
	// 82AD2960: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AD2964: 9883014C  stb r4, 0x14c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(332 as u32), ctx.r[4].u8 ) };
	// 82AD2968: 9963014D  stb r11, 0x14d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(333 as u32), ctx.r[11].u8 ) };
	// 82AD296C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD2970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD2970 size=68
    let mut pc: u32 = 0x82AD2970;
    'dispatch: loop {
        match pc {
            0x82AD2970 => {
    //   block [0x82AD2970..0x82AD29B4)
	// 82AD2970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD2974: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AD2978: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AD297C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD2980: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD2984: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82AD2988: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD298C: 419A0014  beq cr6, 0x82ad29a0
	if ctx.cr[6].eq {
	pc = 0x82AD29A0; continue 'dispatch;
	}
	// 82AD2990: 4BD2D461  bl 0x827ffdf0
	ctx.lr = 0x82AD2994;
	sub_827FFDF0(ctx, base);
	// 82AD2994: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AD2998: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD299C: 4BA3F305  bl 0x82511ca0
	ctx.lr = 0x82AD29A0;
	sub_82511CA0(ctx, base);
	// 82AD29A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AD29A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AD29A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AD29AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AD29B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD29B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD29B8 size=68
    let mut pc: u32 = 0x82AD29B8;
    'dispatch: loop {
        match pc {
            0x82AD29B8 => {
    //   block [0x82AD29B8..0x82AD29FC)
	// 82AD29B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD29BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AD29C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AD29C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD29C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD29CC: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82AD29D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD29D4: 419A0014  beq cr6, 0x82ad29e8
	if ctx.cr[6].eq {
	pc = 0x82AD29E8; continue 'dispatch;
	}
	// 82AD29D8: 4BD2D419  bl 0x827ffdf0
	ctx.lr = 0x82AD29DC;
	sub_827FFDF0(ctx, base);
	// 82AD29DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AD29E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD29E4: 4BA3F2DD  bl 0x82511cc0
	ctx.lr = 0x82AD29E8;
	sub_82511CC0(ctx, base);
	// 82AD29E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AD29EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AD29F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AD29F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AD29F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD2A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AD2A00 size=12
    let mut pc: u32 = 0x82AD2A00;
    'dispatch: loop {
        match pc {
            0x82AD2A00 => {
    //   block [0x82AD2A00..0x82AD2A0C)
	// 82AD2A00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AD2A04: 99630054  stb r11, 0x54(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[11].u8 ) };
	// 82AD2A08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD2A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AD2A10 size=12
    let mut pc: u32 = 0x82AD2A10;
    'dispatch: loop {
        match pc {
            0x82AD2A10 => {
    //   block [0x82AD2A10..0x82AD2A1C)
	// 82AD2A10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AD2A14: 99630054  stb r11, 0x54(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[11].u8 ) };
	// 82AD2A18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD2A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD2A20 size=124
    let mut pc: u32 = 0x82AD2A20;
    'dispatch: loop {
        match pc {
            0x82AD2A20 => {
    //   block [0x82AD2A20..0x82AD2A9C)
	// 82AD2A20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD2A24: 486D5749  bl 0x831a816c
	ctx.lr = 0x82AD2A28;
	sub_831A8130(ctx, base);
	// 82AD2A28: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD2A2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD2A30: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82AD2A34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD2A38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD2A3C: 4BA3CA8D  bl 0x8250f4c8
	ctx.lr = 0x82AD2A40;
	sub_8250F4C8(ctx, base);
	// 82AD2A40: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD2A44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD2A48: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82AD2A4C: 409A0008  bne cr6, 0x82ad2a54
	if !ctx.cr[6].eq {
	pc = 0x82AD2A54; continue 'dispatch;
	}
	// 82AD2A50: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD2A54: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD2A58: 4BA37EF9  bl 0x8250a950
	ctx.lr = 0x82AD2A5C;
	sub_8250A950(ctx, base);
	// 82AD2A5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD2A60: 4831F231  bl 0x82df1c90
	ctx.lr = 0x82AD2A64;
	sub_82DF1C90(ctx, base);
	// 82AD2A64: 3BFF0158  addi r31, r31, 0x158
	ctx.r[31].s64 = ctx.r[31].s64 + 344;
	// 82AD2A68: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 82AD2A6C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD2A70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD2A74: 419A000C  beq cr6, 0x82ad2a80
	if ctx.cr[6].eq {
	pc = 0x82AD2A80; continue 'dispatch;
	}
	// 82AD2A78: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82AD2A7C: 483AE9DD  bl 0x82e81458
	ctx.lr = 0x82AD2A80;
	sub_82E81458(ctx, base);
	// 82AD2A80: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82AD2A84: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82AD2A88: 4082FFE4  bne 0x82ad2a6c
	if !ctx.cr[0].eq {
	pc = 0x82AD2A6C; continue 'dispatch;
	}
	// 82AD2A8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD2A90: 4831F201  bl 0x82df1c90
	ctx.lr = 0x82AD2A94;
	sub_82DF1C90(ctx, base);
	// 82AD2A94: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AD2A98: 486D5724  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD2AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AD2AA0 size=28
    let mut pc: u32 = 0x82AD2AA0;
    'dispatch: loop {
        match pc {
            0x82AD2AA0 => {
    //   block [0x82AD2AA0..0x82AD2ABC)
	// 82AD2AA0: 896300FD  lbz r11, 0xfd(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(253 as u32) ) } as u64;
	// 82AD2AA4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AD2AA8: 41820014  beq 0x82ad2abc
	if ctx.cr[0].eq {
		sub_82AD2ABC(ctx, base);
		return;
	}
	// 82AD2AAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82AD2AB0: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AD2AB4: D0040018  stfs f0, 0x18(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82AD2AB8: 48000014  b 0x82ad2acc
	sub_82AD2ABC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD2ABC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82AD2ABC size=40
    let mut pc: u32 = 0x82AD2ABC;
    'dispatch: loop {
        match pc {
            0x82AD2ABC => {
    //   block [0x82AD2ABC..0x82AD2AE4)
	// 82AD2ABC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD2AC0: C00300F8  lfs f0, 0xf8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AD2AC4: D0040018  stfs f0, 0x18(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82AD2AC8: C00BA638  lfs f0, -0x59c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82AD2ACC: 39600120  li r11, 0x120
	ctx.r[11].s64 = 288;
	// 82AD2AD0: D004001C  stfs f0, 0x1c(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82AD2AD4: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 82AD2AD8: 13E358C7  vcmpequd (lvx128) v31, v3, v11
	tmp.u32 = ctx.r[3].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD2AE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AD2AE8 size=136
    let mut pc: u32 = 0x82AD2AE8;
    'dispatch: loop {
        match pc {
            0x82AD2AE8 => {
    //   block [0x82AD2AE8..0x82AD2B70)
	// 82AD2AE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD2AEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AD2AF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AD2AF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AD2AF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD2AFC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AD2B00: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AD2B04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AD2B08: 997F0018  stb r11, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 82AD2B0C: 895E013B  lbz r10, 0x13b(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(315 as u32) ) } as u64;
	// 82AD2B10: 995F0018  stb r10, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	// 82AD2B14: 997F0030  stb r11, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u8 ) };
	// 82AD2B18: 807E00E8  lwz r3, 0xe8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(232 as u32) ) } as u64;
	// 82AD2B1C: 48387BB5  bl 0x82e5a6d0
	ctx.lr = 0x82AD2B20;
	sub_82E5A6D0(ctx, base);
	// 82AD2B20: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD2B24: 396BA6D8  addi r11, r11, -0x5928
	ctx.r[11].s64 = ctx.r[11].s64 + -22824;
	// 82AD2B28: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82AD2B2C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82AD2B30: 48320C99  bl 0x82df37c8
	ctx.lr = 0x82AD2B34;
	sub_82DF37C8(ctx, base);
	// 82AD2B34: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82AD2B38: 4182000C  beq 0x82ad2b44
	if ctx.cr[0].eq {
	pc = 0x82AD2B44; continue 'dispatch;
	}
	// 82AD2B3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82AD2B40: 997F0030  stb r11, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u8 ) };
	// 82AD2B44: 39600120  li r11, 0x120
	ctx.r[11].s64 = 288;
	// 82AD2B48: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 82AD2B4C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82AD2B50: 13FE58C7  vcmpequd (lvx128) v31, v30, v11
	tmp.u32 = ctx.r[30].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD2B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD2B70 size=136
    let mut pc: u32 = 0x82AD2B70;
    'dispatch: loop {
        match pc {
            0x82AD2B70 => {
    //   block [0x82AD2B70..0x82AD2BF8)
	// 82AD2B70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD2B74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AD2B78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AD2B7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AD2B80: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD2B84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD2B88: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82AD2B8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD2B90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD2B94: 4BA3C935  bl 0x8250f4c8
	ctx.lr = 0x82AD2B98;
	sub_8250F4C8(ctx, base);
	// 82AD2B98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD2B9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD2BA0: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82AD2BA4: 409A0008  bne cr6, 0x82ad2bac
	if !ctx.cr[6].eq {
	pc = 0x82AD2BAC; continue 'dispatch;
	}
	// 82AD2BA8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD2BAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD2BB0: 4BA37DA1  bl 0x8250a950
	ctx.lr = 0x82AD2BB4;
	sub_8250A950(ctx, base);
	// 82AD2BB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD2BB8: 4831F0D9  bl 0x82df1c90
	ctx.lr = 0x82AD2BBC;
	sub_82DF1C90(ctx, base);
	// 82AD2BBC: 397E002B  addi r11, r30, 0x2b
	ctx.r[11].s64 = ctx.r[30].s64 + 43;
	// 82AD2BC0: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82AD2BC4: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82AD2BC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD2BCC: 419A000C  beq cr6, 0x82ad2bd8
	if ctx.cr[6].eq {
	pc = 0x82AD2BD8; continue 'dispatch;
	}
	// 82AD2BD0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82AD2BD4: 483AEB6D  bl 0x82e81740
	ctx.lr = 0x82AD2BD8;
	sub_82E81740(ctx, base);
	// 82AD2BD8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82AD2BDC: 4831F0B5  bl 0x82df1c90
	ctx.lr = 0x82AD2BE0;
	sub_82DF1C90(ctx, base);
	// 82AD2BE0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82AD2BE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AD2BE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AD2BEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AD2BF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AD2BF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD2BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82AD2BF8 size=136
    let mut pc: u32 = 0x82AD2BF8;
    'dispatch: loop {
        match pc {
            0x82AD2BF8 => {
    //   block [0x82AD2BF8..0x82AD2C80)
	// 82AD2BF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD2BFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AD2C00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AD2C04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD2C08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD2C0C: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 82AD2C10: 41980028  blt cr6, 0x82ad2c38
	if ctx.cr[6].lt {
	pc = 0x82AD2C38; continue 'dispatch;
	}
	// 82AD2C14: 409A0058  bne cr6, 0x82ad2c6c
	if !ctx.cr[6].eq {
	pc = 0x82AD2C6C; continue 'dispatch;
	}
	// 82AD2C18: 809F0130  lwz r4, 0x130(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 82AD2C1C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82AD2C20: 419A004C  beq cr6, 0x82ad2c6c
	if ctx.cr[6].eq {
	pc = 0x82AD2C6C; continue 'dispatch;
	}
	// 82AD2C24: 807F0150  lwz r3, 0x150(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82AD2C28: 48007E99  bl 0x82adaac0
	ctx.lr = 0x82AD2C2C;
	sub_82ADAAC0(ctx, base);
	// 82AD2C2C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AD2C30: 917F0130  stw r11, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 82AD2C34: 48000038  b 0x82ad2c6c
	pc = 0x82AD2C6C; continue 'dispatch;
	// 82AD2C38: 817F0130  lwz r11, 0x130(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 82AD2C3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD2C40: 409A002C  bne cr6, 0x82ad2c6c
	if !ctx.cr[6].eq {
	pc = 0x82AD2C6C; continue 'dispatch;
	}
	// 82AD2C44: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82AD2C48: 807F0150  lwz r3, 0x150(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82AD2C4C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82AD2C50: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82AD2C54: 38BF0120  addi r5, r31, 0x120
	ctx.r[5].s64 = ctx.r[31].s64 + 288;
	// 82AD2C58: 38800013  li r4, 0x13
	ctx.r[4].s64 = 19;
	// 82AD2C5C: C04B95F4  lfs f2, -0x6a0c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27148 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82AD2C60: C02A9664  lfs f1, -0x699c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27036 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82AD2C64: 48007F8D  bl 0x82adabf0
	ctx.lr = 0x82AD2C68;
	sub_82ADABF0(ctx, base);
	// 82AD2C68: 907F0130  stw r3, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[3].u32 ) };
	// 82AD2C6C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AD2C70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AD2C74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AD2C78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AD2C7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD2C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD2C80 size=196
    let mut pc: u32 = 0x82AD2C80;
    'dispatch: loop {
        match pc {
            0x82AD2C80 => {
    //   block [0x82AD2C80..0x82AD2D44)
	// 82AD2C80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD2C84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AD2C88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AD2C8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AD2C90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD2C94: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AD2C98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AD2C9C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AD2CA0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AD2CA4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AD2CA8: 4B7EDC91  bl 0x822c0938
	ctx.lr = 0x82AD2CAC;
	sub_822C0938(ctx, base);
	// 82AD2CAC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AD2CB0: 41820028  beq 0x82ad2cd8
	if ctx.cr[0].eq {
	pc = 0x82AD2CD8; continue 'dispatch;
	}
	// 82AD2CB4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD2CB8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AD2CBC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AD2CC0: 392BA678  addi r9, r11, -0x5988
	ctx.r[9].s64 = ctx.r[11].s64 + -22920;
	// 82AD2CC4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AD2CC8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AD2CCC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AD2CD0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AD2CD4: 48000008  b 0x82ad2cdc
	pc = 0x82AD2CDC; continue 'dispatch;
	// 82AD2CD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AD2CDC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AD2CE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD2CE4: 409A0044  bne cr6, 0x82ad2d28
	if !ctx.cr[6].eq {
	pc = 0x82AD2D28; continue 'dispatch;
	}
	// 82AD2CE8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AD2CEC: 419A001C  beq cr6, 0x82ad2d08
	if ctx.cr[6].eq {
	pc = 0x82AD2D08; continue 'dispatch;
	}
	// 82AD2CF0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD2CF4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AD2CF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD2CFC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD2D00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AD2D04: 4E800421  bctrl
	ctx.lr = 0x82AD2D08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AD2D08: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AD2D0C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AD2D10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD2D14: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AD2D18: 816B1000  lwz r11, 0x1000(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4096 as u32) ) } as u64;
	// 82AD2D1C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AD2D20: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AD2D24: 4B7ED2DD  bl 0x822c0000
	ctx.lr = 0x82AD2D28;
	sub_822C0000(ctx, base);
	// 82AD2D28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD2D2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AD2D30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AD2D34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AD2D38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AD2D3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AD2D40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD2D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD2D48 size=196
    let mut pc: u32 = 0x82AD2D48;
    'dispatch: loop {
        match pc {
            0x82AD2D48 => {
    //   block [0x82AD2D48..0x82AD2E0C)
	// 82AD2D48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD2D4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AD2D50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AD2D54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AD2D58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD2D5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AD2D60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AD2D64: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AD2D68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AD2D6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AD2D70: 4B7EDBC9  bl 0x822c0938
	ctx.lr = 0x82AD2D74;
	sub_822C0938(ctx, base);
	// 82AD2D74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AD2D78: 41820028  beq 0x82ad2da0
	if ctx.cr[0].eq {
	pc = 0x82AD2DA0; continue 'dispatch;
	}
	// 82AD2D7C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD2D80: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AD2D84: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AD2D88: 392BA68C  addi r9, r11, -0x5974
	ctx.r[9].s64 = ctx.r[11].s64 + -22900;
	// 82AD2D8C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AD2D90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AD2D94: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AD2D98: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AD2D9C: 48000008  b 0x82ad2da4
	pc = 0x82AD2DA4; continue 'dispatch;
	// 82AD2DA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AD2DA4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AD2DA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD2DAC: 409A0044  bne cr6, 0x82ad2df0
	if !ctx.cr[6].eq {
	pc = 0x82AD2DF0; continue 'dispatch;
	}
	// 82AD2DB0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AD2DB4: 419A001C  beq cr6, 0x82ad2dd0
	if ctx.cr[6].eq {
	pc = 0x82AD2DD0; continue 'dispatch;
	}
	// 82AD2DB8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD2DBC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AD2DC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD2DC4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD2DC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AD2DCC: 4E800421  bctrl
	ctx.lr = 0x82AD2DD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AD2DD0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AD2DD4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AD2DD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD2DDC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AD2DE0: 816B1000  lwz r11, 0x1000(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4096 as u32) ) } as u64;
	// 82AD2DE4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AD2DE8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AD2DEC: 4B7ED215  bl 0x822c0000
	ctx.lr = 0x82AD2DF0;
	sub_822C0000(ctx, base);
	// 82AD2DF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD2DF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AD2DF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AD2DFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AD2E00: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AD2E04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AD2E08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD2E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD2E10 size=196
    let mut pc: u32 = 0x82AD2E10;
    'dispatch: loop {
        match pc {
            0x82AD2E10 => {
    //   block [0x82AD2E10..0x82AD2ED4)
	// 82AD2E10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD2E14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AD2E18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AD2E1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AD2E20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD2E24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AD2E28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AD2E2C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AD2E30: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AD2E34: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AD2E38: 4B7EDB01  bl 0x822c0938
	ctx.lr = 0x82AD2E3C;
	sub_822C0938(ctx, base);
	// 82AD2E3C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AD2E40: 41820028  beq 0x82ad2e68
	if ctx.cr[0].eq {
	pc = 0x82AD2E68; continue 'dispatch;
	}
	// 82AD2E44: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD2E48: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AD2E4C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AD2E50: 392BA6A0  addi r9, r11, -0x5960
	ctx.r[9].s64 = ctx.r[11].s64 + -22880;
	// 82AD2E54: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AD2E58: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AD2E5C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AD2E60: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AD2E64: 48000008  b 0x82ad2e6c
	pc = 0x82AD2E6C; continue 'dispatch;
	// 82AD2E68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AD2E6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AD2E70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD2E74: 409A0044  bne cr6, 0x82ad2eb8
	if !ctx.cr[6].eq {
	pc = 0x82AD2EB8; continue 'dispatch;
	}
	// 82AD2E78: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AD2E7C: 419A001C  beq cr6, 0x82ad2e98
	if ctx.cr[6].eq {
	pc = 0x82AD2E98; continue 'dispatch;
	}
	// 82AD2E80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD2E84: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AD2E88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD2E8C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD2E90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AD2E94: 4E800421  bctrl
	ctx.lr = 0x82AD2E98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AD2E98: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AD2E9C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AD2EA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD2EA4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AD2EA8: 816B1000  lwz r11, 0x1000(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4096 as u32) ) } as u64;
	// 82AD2EAC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AD2EB0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AD2EB4: 4B7ED14D  bl 0x822c0000
	ctx.lr = 0x82AD2EB8;
	sub_822C0000(ctx, base);
	// 82AD2EB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD2EBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AD2EC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AD2EC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AD2EC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AD2ECC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AD2ED0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD2ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD2ED8 size=196
    let mut pc: u32 = 0x82AD2ED8;
    'dispatch: loop {
        match pc {
            0x82AD2ED8 => {
    //   block [0x82AD2ED8..0x82AD2F9C)
	// 82AD2ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD2EDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AD2EE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AD2EE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AD2EE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD2EEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AD2EF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AD2EF4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AD2EF8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AD2EFC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AD2F00: 4B7EDA39  bl 0x822c0938
	ctx.lr = 0x82AD2F04;
	sub_822C0938(ctx, base);
	// 82AD2F04: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AD2F08: 41820028  beq 0x82ad2f30
	if ctx.cr[0].eq {
	pc = 0x82AD2F30; continue 'dispatch;
	}
	// 82AD2F0C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD2F10: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AD2F14: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AD2F18: 392BA6B4  addi r9, r11, -0x594c
	ctx.r[9].s64 = ctx.r[11].s64 + -22860;
	// 82AD2F1C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AD2F20: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AD2F24: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AD2F28: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AD2F2C: 48000008  b 0x82ad2f34
	pc = 0x82AD2F34; continue 'dispatch;
	// 82AD2F30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AD2F34: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AD2F38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD2F3C: 409A0044  bne cr6, 0x82ad2f80
	if !ctx.cr[6].eq {
	pc = 0x82AD2F80; continue 'dispatch;
	}
	// 82AD2F40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AD2F44: 419A001C  beq cr6, 0x82ad2f60
	if ctx.cr[6].eq {
	pc = 0x82AD2F60; continue 'dispatch;
	}
	// 82AD2F48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD2F4C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AD2F50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD2F54: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD2F58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AD2F5C: 4E800421  bctrl
	ctx.lr = 0x82AD2F60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AD2F60: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AD2F64: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AD2F68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD2F6C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AD2F70: 816B1000  lwz r11, 0x1000(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4096 as u32) ) } as u64;
	// 82AD2F74: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AD2F78: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AD2F7C: 4B7ED085  bl 0x822c0000
	ctx.lr = 0x82AD2F80;
	sub_822C0000(ctx, base);
	// 82AD2F80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD2F84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AD2F88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AD2F8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AD2F90: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AD2F94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AD2F98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD2FA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD2FA0 size=196
    let mut pc: u32 = 0x82AD2FA0;
    'dispatch: loop {
        match pc {
            0x82AD2FA0 => {
    //   block [0x82AD2FA0..0x82AD3064)
	// 82AD2FA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD2FA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AD2FA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AD2FAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AD2FB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD2FB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82AD2FB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AD2FBC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82AD2FC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82AD2FC4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AD2FC8: 4B7ED971  bl 0x822c0938
	ctx.lr = 0x82AD2FCC;
	sub_822C0938(ctx, base);
	// 82AD2FCC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82AD2FD0: 41820028  beq 0x82ad2ff8
	if ctx.cr[0].eq {
	pc = 0x82AD2FF8; continue 'dispatch;
	}
	// 82AD2FD4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD2FD8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82AD2FDC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82AD2FE0: 392BA6C8  addi r9, r11, -0x5938
	ctx.r[9].s64 = ctx.r[11].s64 + -22840;
	// 82AD2FE4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82AD2FE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82AD2FEC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82AD2FF0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82AD2FF4: 48000008  b 0x82ad2ffc
	pc = 0x82AD2FFC; continue 'dispatch;
	// 82AD2FF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82AD2FFC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AD3000: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82AD3004: 409A0044  bne cr6, 0x82ad3048
	if !ctx.cr[6].eq {
	pc = 0x82AD3048; continue 'dispatch;
	}
	// 82AD3008: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82AD300C: 419A001C  beq cr6, 0x82ad3028
	if ctx.cr[6].eq {
	pc = 0x82AD3028; continue 'dispatch;
	}
	// 82AD3010: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD3014: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AD3018: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD301C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD3020: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AD3024: 4E800421  bctrl
	ctx.lr = 0x82AD3028;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AD3028: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82AD302C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82AD3030: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82AD3034: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82AD3038: 816B1000  lwz r11, 0x1000(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4096 as u32) ) } as u64;
	// 82AD303C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82AD3040: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82AD3044: 4B7ECFBD  bl 0x822c0000
	ctx.lr = 0x82AD3048;
	sub_822C0000(ctx, base);
	// 82AD3048: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD304C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AD3050: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AD3054: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AD3058: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AD305C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AD3060: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD3068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD3068 size=56
    let mut pc: u32 = 0x82AD3068;
    'dispatch: loop {
        match pc {
            0x82AD3068 => {
    //   block [0x82AD3068..0x82AD30A0)
	// 82AD3068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD306C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AD3070: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AD3074: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD3078: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD307C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82AD3080: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82AD3084: 4BA3ED15  bl 0x82511d98
	ctx.lr = 0x82AD3088;
	sub_82511D98(ctx, base);
	// 82AD3088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD308C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82AD3090: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AD3094: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AD3098: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AD309C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD30A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82AD30A0 size=256
    let mut pc: u32 = 0x82AD30A0;
    'dispatch: loop {
        match pc {
            0x82AD30A0 => {
    //   block [0x82AD30A0..0x82AD31A0)
	// 82AD30A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82AD30A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82AD30A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82AD30AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82AD30B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82AD30B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82AD30B8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82AD30BC: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82AD30C0: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82AD30C4: 396BA744  addi r11, r11, -0x58bc
	ctx.r[11].s64 = ctx.r[11].s64 + -22716;
	// 82AD30C8: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82AD30CC: 394AA730  addi r10, r10, -0x58d0
	ctx.r[10].s64 = ctx.r[10].s64 + -22736;
	// 82AD30D0: 3929A6E4  addi r9, r9, -0x591c
	ctx.r[9].s64 = ctx.r[9].s64 + -22812;
	// 82AD30D4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82AD30D8: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 82AD30DC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82AD30E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD30E4: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 82AD30E8: 419A0018  beq cr6, 0x82ad3100
	if ctx.cr[6].eq {
	pc = 0x82AD3100; continue 'dispatch;
	}
	// 82AD30EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD30F0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AD30F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82AD30F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AD30FC: 4E800421  bctrl
	ctx.lr = 0x82AD3100;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AD3100: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82AD3104: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD3108: 419A0018  beq cr6, 0x82ad3120
	if ctx.cr[6].eq {
	pc = 0x82AD3120; continue 'dispatch;
	}
	// 82AD310C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD3110: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AD3114: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD3118: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AD311C: 4E800421  bctrl
	ctx.lr = 0x82AD3120;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AD3120: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82AD3124: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD3128: 419A0018  beq cr6, 0x82ad3140
	if ctx.cr[6].eq {
	pc = 0x82AD3140; continue 'dispatch;
	}
	// 82AD312C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD3130: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82AD3134: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82AD3138: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82AD313C: 4E800421  bctrl
	ctx.lr = 0x82AD3140;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82AD3140: 387F0158  addi r3, r31, 0x158
	ctx.r[3].s64 = ctx.r[31].s64 + 344;
	// 82AD3144: 4BF59DA5  bl 0x82a2cee8
	ctx.lr = 0x82AD3148;
	sub_82A2CEE8(ctx, base);
	// 82AD3148: 807F0154  lwz r3, 0x154(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 82AD314C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD3150: 419A0008  beq cr6, 0x82ad3158
	if ctx.cr[6].eq {
	pc = 0x82AD3158; continue 'dispatch;
	}
	// 82AD3154: 4B7ED73D  bl 0x822c0890
	ctx.lr = 0x82AD3158;
	sub_822C0890(ctx, base);
	// 82AD3158: 807F0148  lwz r3, 0x148(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 82AD315C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD3160: 419A0008  beq cr6, 0x82ad3168
	if ctx.cr[6].eq {
	pc = 0x82AD3168; continue 'dispatch;
	}
	// 82AD3164: 4B7ED72D  bl 0x822c0890
	ctx.lr = 0x82AD3168;
	sub_822C0890(ctx, base);
	// 82AD3168: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 82AD316C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82AD3170: 419A0008  beq cr6, 0x82ad3178
	if ctx.cr[6].eq {
	pc = 0x82AD3178; continue 'dispatch;
	}
	// 82AD3174: 4B7ED71D  bl 0x822c0890
	ctx.lr = 0x82AD3178;
	sub_822C0890(ctx, base);
	// 82AD3178: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82AD317C: 4BCD44DD  bl 0x827a7658
	ctx.lr = 0x82AD3180;
	sub_827A7658(ctx, base);
	// 82AD3180: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82AD3184: 4B87C1CD  bl 0x8234f350
	ctx.lr = 0x82AD3188;
	sub_8234F350(ctx, base);
	// 82AD3188: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82AD318C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82AD3190: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82AD3194: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82AD3198: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82AD319C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82AD31A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82AD31A0 size=8
    let mut pc: u32 = 0x82AD31A0;
    'dispatch: loop {
        match pc {
            0x82AD31A0 => {
    //   block [0x82AD31A0..0x82AD31A8)
	// 82AD31A0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82AD31A4: 48000A94  b 0x82ad3c38
	sub_82AD3C38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


