pub fn sub_828E9978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E9978 size=8
    let mut pc: u32 = 0x828E9978;
    'dispatch: loop {
        match pc {
            0x828E9978 => {
    //   block [0x828E9978..0x828E9980)
	// 828E9978: 3863FCA0  addi r3, r3, -0x360
	ctx.r[3].s64 = ctx.r[3].s64 + -864;
	// 828E997C: 48000104  b 0x828e9a80
	sub_828E9A80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E9980 size=8
    let mut pc: u32 = 0x828E9980;
    'dispatch: loop {
        match pc {
            0x828E9980 => {
    //   block [0x828E9980..0x828E9988)
	// 828E9980: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 828E9984: 480000FC  b 0x828e9a80
	sub_828E9A80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E9988 size=8
    let mut pc: u32 = 0x828E9988;
    'dispatch: loop {
        match pc {
            0x828E9988 => {
    //   block [0x828E9988..0x828E9990)
	// 828E9988: 3863FCA0  addi r3, r3, -0x360
	ctx.r[3].s64 = ctx.r[3].s64 + -864;
	// 828E998C: 48000144  b 0x828e9ad0
	sub_828E9AD0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E9990 size=8
    let mut pc: u32 = 0x828E9990;
    'dispatch: loop {
        match pc {
            0x828E9990 => {
    //   block [0x828E9990..0x828E9998)
	// 828E9990: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 828E9994: 4800013C  b 0x828e9ad0
	sub_828E9AD0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E9998 size=8
    let mut pc: u32 = 0x828E9998;
    'dispatch: loop {
        match pc {
            0x828E9998 => {
    //   block [0x828E9998..0x828E99A0)
	// 828E9998: 3863FDF8  addi r3, r3, -0x208
	ctx.r[3].s64 = ctx.r[3].s64 + -520;
	// 828E999C: 48000134  b 0x828e9ad0
	sub_828E9AD0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E99A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E99A0 size=8
    let mut pc: u32 = 0x828E99A0;
    'dispatch: loop {
        match pc {
            0x828E99A0 => {
    //   block [0x828E99A0..0x828E99A8)
	// 828E99A0: 3863FDF8  addi r3, r3, -0x208
	ctx.r[3].s64 = ctx.r[3].s64 + -520;
	// 828E99A4: 480001AC  b 0x828e9b50
	sub_828E9B50(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E99A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E99A8 size=8
    let mut pc: u32 = 0x828E99A8;
    'dispatch: loop {
        match pc {
            0x828E99A8 => {
    //   block [0x828E99A8..0x828E99B0)
	// 828E99A8: 3863FCA0  addi r3, r3, -0x360
	ctx.r[3].s64 = ctx.r[3].s64 + -864;
	// 828E99AC: 480001A4  b 0x828e9b50
	sub_828E9B50(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E99B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E99B0 size=8
    let mut pc: u32 = 0x828E99B0;
    'dispatch: loop {
        match pc {
            0x828E99B0 => {
    //   block [0x828E99B0..0x828E99B8)
	// 828E99B0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 828E99B4: 4800019C  b 0x828e9b50
	sub_828E9B50(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E99B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E99B8 size=8
    let mut pc: u32 = 0x828E99B8;
    'dispatch: loop {
        match pc {
            0x828E99B8 => {
    //   block [0x828E99B8..0x828E99C0)
	// 828E99B8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 828E99BC: 48000214  b 0x828e9bd0
	sub_828E9BD0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E99C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E99C0 size=8
    let mut pc: u32 = 0x828E99C0;
    'dispatch: loop {
        match pc {
            0x828E99C0 => {
    //   block [0x828E99C0..0x828E99C8)
	// 828E99C0: 3863FDF8  addi r3, r3, -0x208
	ctx.r[3].s64 = ctx.r[3].s64 + -520;
	// 828E99C4: 4800020C  b 0x828e9bd0
	sub_828E9BD0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E99C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E99C8 size=8
    let mut pc: u32 = 0x828E99C8;
    'dispatch: loop {
        match pc {
            0x828E99C8 => {
    //   block [0x828E99C8..0x828E99D0)
	// 828E99C8: 3863FCA0  addi r3, r3, -0x360
	ctx.r[3].s64 = ctx.r[3].s64 + -864;
	// 828E99CC: 48000204  b 0x828e9bd0
	sub_828E9BD0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E99D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E99D0 size=8
    let mut pc: u32 = 0x828E99D0;
    'dispatch: loop {
        match pc {
            0x828E99D0 => {
    //   block [0x828E99D0..0x828E99D8)
	// 828E99D0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 828E99D4: 4800027C  b 0x828e9c50
	sub_828E9C50(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E99D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E99D8 size=8
    let mut pc: u32 = 0x828E99D8;
    'dispatch: loop {
        match pc {
            0x828E99D8 => {
    //   block [0x828E99D8..0x828E99E0)
	// 828E99D8: 3863FDF8  addi r3, r3, -0x208
	ctx.r[3].s64 = ctx.r[3].s64 + -520;
	// 828E99DC: 48000274  b 0x828e9c50
	sub_828E9C50(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E99E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E99E0 size=8
    let mut pc: u32 = 0x828E99E0;
    'dispatch: loop {
        match pc {
            0x828E99E0 => {
    //   block [0x828E99E0..0x828E99E8)
	// 828E99E0: 3863FCA0  addi r3, r3, -0x360
	ctx.r[3].s64 = ctx.r[3].s64 + -864;
	// 828E99E4: 4800026C  b 0x828e9c50
	sub_828E9C50(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E99E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E99E8 size=8
    let mut pc: u32 = 0x828E99E8;
    'dispatch: loop {
        match pc {
            0x828E99E8 => {
    //   block [0x828E99E8..0x828E99F0)
	// 828E99E8: 3863FDF8  addi r3, r3, -0x208
	ctx.r[3].s64 = ctx.r[3].s64 + -520;
	// 828E99EC: 480002E4  b 0x828e9cd0
	sub_828E9CD0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E99F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E99F0 size=8
    let mut pc: u32 = 0x828E99F0;
    'dispatch: loop {
        match pc {
            0x828E99F0 => {
    //   block [0x828E99F0..0x828E99F8)
	// 828E99F0: 3863FCA0  addi r3, r3, -0x360
	ctx.r[3].s64 = ctx.r[3].s64 + -864;
	// 828E99F4: 480002DC  b 0x828e9cd0
	sub_828E9CD0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E99F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828E99F8 size=8
    let mut pc: u32 = 0x828E99F8;
    'dispatch: loop {
        match pc {
            0x828E99F8 => {
    //   block [0x828E99F8..0x828E9A00)
	// 828E99F8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 828E99FC: 480002D4  b 0x828e9cd0
	sub_828E9CD0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E9A00 size=128
    let mut pc: u32 = 0x828E9A00;
    'dispatch: loop {
        match pc {
            0x828E9A00 => {
    //   block [0x828E9A00..0x828E9A80)
	// 828E9A00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E9A04: 488BE769  bl 0x831a816c
	ctx.lr = 0x828E9A08;
	sub_831A8130(ctx, base);
	// 828E9A08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E9A0C: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828E9A10: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828E9A14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E9A18: 3BEB3C6C  addi r31, r11, 0x3c6c
	ctx.r[31].s64 = ctx.r[11].s64 + 15468;
	// 828E9A1C: 816A3C74  lwz r11, 0x3c74(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15476 as u32) ) } as u64;
	// 828E9A20: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828E9A24: 40820024  bne 0x828e9a48
	if !ctx.cr[0].eq {
	pc = 0x828E9A48; continue 'dispatch;
	}
	// 828E9A28: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 828E9A2C: 3D00828E  lis r8, -0x7d72
	ctx.r[8].s64 = -2104623104;
	// 828E9A30: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828E9A34: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 828E9A38: 39084C68  addi r8, r8, 0x4c68
	ctx.r[8].s64 = ctx.r[8].s64 + 19560;
	// 828E9A3C: 916A3C74  stw r11, 0x3c74(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15476 as u32), ctx.r[11].u32 ) };
	// 828E9A40: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828E9A44: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828E9A48: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828E9A4C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828E9A50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9A54: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828E9A58: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828E9A5C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E9A60: 4BD6AB61  bl 0x826545c0
	ctx.lr = 0x828E9A64;
	sub_826545C0(ctx, base);
	// 828E9A64: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E9A68: 4182000C  beq 0x828e9a74
	if ctx.cr[0].eq {
	pc = 0x828E9A74; continue 'dispatch;
	}
	// 828E9A6C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828E9A70: 48000008  b 0x828e9a78
	pc = 0x828E9A78; continue 'dispatch;
	// 828E9A74: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828E9A78: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E9A7C: 488BE740  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E9A80 size=76
    let mut pc: u32 = 0x828E9A80;
    'dispatch: loop {
        match pc {
            0x828E9A80 => {
    //   block [0x828E9A80..0x828E9ACC)
	// 828E9A80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E9A84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E9A88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E9A8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E9A90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E9A94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E9A98: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E9A9C: 4BFFFD7D  bl 0x828e9818
	ctx.lr = 0x828E9AA0;
	sub_828E9818(ctx, base);
	// 828E9AA0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E9AA4: 4182000C  beq 0x828e9ab0
	if ctx.cr[0].eq {
	pc = 0x828E9AB0; continue 'dispatch;
	}
	// 828E9AA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9AAC: 4850892D  bl 0x82df23d8
	ctx.lr = 0x828E9AB0;
	sub_82DF23D8(ctx, base);
	// 828E9AB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9AB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E9AB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E9ABC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E9AC0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E9AC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E9AC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E9AD0 size=124
    let mut pc: u32 = 0x828E9AD0;
    'dispatch: loop {
        match pc {
            0x828E9AD0 => {
    //   block [0x828E9AD0..0x828E9B4C)
	// 828E9AD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E9AD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E9AD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E9ADC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E9AE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E9AE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E9AE8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E9AEC: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828E9AF0: 396B1424  addi r11, r11, 0x1424
	ctx.r[11].s64 = ctx.r[11].s64 + 5156;
	// 828E9AF4: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828E9AF8: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828E9AFC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E9B00: 394A140C  addi r10, r10, 0x140c
	ctx.r[10].s64 = ctx.r[10].s64 + 5132;
	// 828E9B04: 392913F0  addi r9, r9, 0x13f0
	ctx.r[9].s64 = ctx.r[9].s64 + 5104;
	// 828E9B08: 396813A4  addi r11, r8, 0x13a4
	ctx.r[11].s64 = ctx.r[8].s64 + 5028;
	// 828E9B0C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 828E9B10: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 828E9B14: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E9B18: 917F0360  stw r11, 0x360(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(864 as u32), ctx.r[11].u32 ) };
	// 828E9B1C: 4BFFFCFD  bl 0x828e9818
	ctx.lr = 0x828E9B20;
	sub_828E9818(ctx, base);
	// 828E9B20: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E9B24: 4182000C  beq 0x828e9b30
	if ctx.cr[0].eq {
	pc = 0x828E9B30; continue 'dispatch;
	}
	// 828E9B28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9B2C: 485088AD  bl 0x82df23d8
	ctx.lr = 0x828E9B30;
	sub_82DF23D8(ctx, base);
	// 828E9B30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9B34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E9B38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E9B3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E9B40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E9B44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E9B48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E9B50 size=124
    let mut pc: u32 = 0x828E9B50;
    'dispatch: loop {
        match pc {
            0x828E9B50 => {
    //   block [0x828E9B50..0x828E9BCC)
	// 828E9B50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E9B54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E9B58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E9B5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E9B60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E9B64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E9B68: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E9B6C: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828E9B70: 396B1674  addi r11, r11, 0x1674
	ctx.r[11].s64 = ctx.r[11].s64 + 5748;
	// 828E9B74: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828E9B78: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828E9B7C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E9B80: 394A165C  addi r10, r10, 0x165c
	ctx.r[10].s64 = ctx.r[10].s64 + 5724;
	// 828E9B84: 39291640  addi r9, r9, 0x1640
	ctx.r[9].s64 = ctx.r[9].s64 + 5696;
	// 828E9B88: 396815F4  addi r11, r8, 0x15f4
	ctx.r[11].s64 = ctx.r[8].s64 + 5620;
	// 828E9B8C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 828E9B90: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 828E9B94: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E9B98: 917F0360  stw r11, 0x360(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(864 as u32), ctx.r[11].u32 ) };
	// 828E9B9C: 4BFFFC7D  bl 0x828e9818
	ctx.lr = 0x828E9BA0;
	sub_828E9818(ctx, base);
	// 828E9BA0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E9BA4: 4182000C  beq 0x828e9bb0
	if ctx.cr[0].eq {
	pc = 0x828E9BB0; continue 'dispatch;
	}
	// 828E9BA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9BAC: 4850882D  bl 0x82df23d8
	ctx.lr = 0x828E9BB0;
	sub_82DF23D8(ctx, base);
	// 828E9BB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9BB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E9BB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E9BBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E9BC0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E9BC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E9BC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E9BD0 size=124
    let mut pc: u32 = 0x828E9BD0;
    'dispatch: loop {
        match pc {
            0x828E9BD0 => {
    //   block [0x828E9BD0..0x828E9C4C)
	// 828E9BD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E9BD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E9BD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E9BDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E9BE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E9BE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E9BE8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E9BEC: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828E9BF0: 396B18C4  addi r11, r11, 0x18c4
	ctx.r[11].s64 = ctx.r[11].s64 + 6340;
	// 828E9BF4: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828E9BF8: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828E9BFC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E9C00: 394A18AC  addi r10, r10, 0x18ac
	ctx.r[10].s64 = ctx.r[10].s64 + 6316;
	// 828E9C04: 39291890  addi r9, r9, 0x1890
	ctx.r[9].s64 = ctx.r[9].s64 + 6288;
	// 828E9C08: 39681844  addi r11, r8, 0x1844
	ctx.r[11].s64 = ctx.r[8].s64 + 6212;
	// 828E9C0C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 828E9C10: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 828E9C14: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E9C18: 917F0360  stw r11, 0x360(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(864 as u32), ctx.r[11].u32 ) };
	// 828E9C1C: 4BFFFBFD  bl 0x828e9818
	ctx.lr = 0x828E9C20;
	sub_828E9818(ctx, base);
	// 828E9C20: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E9C24: 4182000C  beq 0x828e9c30
	if ctx.cr[0].eq {
	pc = 0x828E9C30; continue 'dispatch;
	}
	// 828E9C28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9C2C: 485087AD  bl 0x82df23d8
	ctx.lr = 0x828E9C30;
	sub_82DF23D8(ctx, base);
	// 828E9C30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9C34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E9C38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E9C3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E9C40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E9C44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E9C48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E9C50 size=124
    let mut pc: u32 = 0x828E9C50;
    'dispatch: loop {
        match pc {
            0x828E9C50 => {
    //   block [0x828E9C50..0x828E9CCC)
	// 828E9C50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E9C54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E9C58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E9C5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E9C60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E9C64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E9C68: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E9C6C: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828E9C70: 396B1B14  addi r11, r11, 0x1b14
	ctx.r[11].s64 = ctx.r[11].s64 + 6932;
	// 828E9C74: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828E9C78: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828E9C7C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E9C80: 394A1AFC  addi r10, r10, 0x1afc
	ctx.r[10].s64 = ctx.r[10].s64 + 6908;
	// 828E9C84: 39291AE0  addi r9, r9, 0x1ae0
	ctx.r[9].s64 = ctx.r[9].s64 + 6880;
	// 828E9C88: 39681A94  addi r11, r8, 0x1a94
	ctx.r[11].s64 = ctx.r[8].s64 + 6804;
	// 828E9C8C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 828E9C90: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 828E9C94: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E9C98: 917F0360  stw r11, 0x360(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(864 as u32), ctx.r[11].u32 ) };
	// 828E9C9C: 4BFFFB7D  bl 0x828e9818
	ctx.lr = 0x828E9CA0;
	sub_828E9818(ctx, base);
	// 828E9CA0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E9CA4: 4182000C  beq 0x828e9cb0
	if ctx.cr[0].eq {
	pc = 0x828E9CB0; continue 'dispatch;
	}
	// 828E9CA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9CAC: 4850872D  bl 0x82df23d8
	ctx.lr = 0x828E9CB0;
	sub_82DF23D8(ctx, base);
	// 828E9CB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9CB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E9CB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E9CBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E9CC0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E9CC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E9CC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E9CD0 size=124
    let mut pc: u32 = 0x828E9CD0;
    'dispatch: loop {
        match pc {
            0x828E9CD0 => {
    //   block [0x828E9CD0..0x828E9D4C)
	// 828E9CD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E9CD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828E9CD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828E9CDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828E9CE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E9CE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E9CE8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828E9CEC: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828E9CF0: 396B1D64  addi r11, r11, 0x1d64
	ctx.r[11].s64 = ctx.r[11].s64 + 7524;
	// 828E9CF4: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828E9CF8: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828E9CFC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828E9D00: 394A1D4C  addi r10, r10, 0x1d4c
	ctx.r[10].s64 = ctx.r[10].s64 + 7500;
	// 828E9D04: 39291D30  addi r9, r9, 0x1d30
	ctx.r[9].s64 = ctx.r[9].s64 + 7472;
	// 828E9D08: 39681CE4  addi r11, r8, 0x1ce4
	ctx.r[11].s64 = ctx.r[8].s64 + 7396;
	// 828E9D0C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 828E9D10: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 828E9D14: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E9D18: 917F0360  stw r11, 0x360(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(864 as u32), ctx.r[11].u32 ) };
	// 828E9D1C: 4BFFFAFD  bl 0x828e9818
	ctx.lr = 0x828E9D20;
	sub_828E9818(ctx, base);
	// 828E9D20: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E9D24: 4182000C  beq 0x828e9d30
	if ctx.cr[0].eq {
	pc = 0x828E9D30; continue 'dispatch;
	}
	// 828E9D28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9D2C: 485086AD  bl 0x82df23d8
	ctx.lr = 0x828E9D30;
	sub_82DF23D8(ctx, base);
	// 828E9D30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9D34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828E9D38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828E9D3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828E9D40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828E9D44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828E9D48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9D50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E9D50 size=128
    let mut pc: u32 = 0x828E9D50;
    'dispatch: loop {
        match pc {
            0x828E9D50 => {
    //   block [0x828E9D50..0x828E9DD0)
	// 828E9D50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E9D54: 488BE419  bl 0x831a816c
	ctx.lr = 0x828E9D58;
	sub_831A8130(ctx, base);
	// 828E9D58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E9D5C: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828E9D60: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828E9D64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E9D68: 3BEB3C78  addi r31, r11, 0x3c78
	ctx.r[31].s64 = ctx.r[11].s64 + 15480;
	// 828E9D6C: 816A3C80  lwz r11, 0x3c80(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15488 as u32) ) } as u64;
	// 828E9D70: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828E9D74: 40820024  bne 0x828e9d98
	if !ctx.cr[0].eq {
	pc = 0x828E9D98; continue 'dispatch;
	}
	// 828E9D78: 3D208271  lis r9, -0x7d8f
	ctx.r[9].s64 = -2106523648;
	// 828E9D7C: 3D00828E  lis r8, -0x7d72
	ctx.r[8].s64 = -2104623104;
	// 828E9D80: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828E9D84: 39298E48  addi r9, r9, -0x71b8
	ctx.r[9].s64 = ctx.r[9].s64 + -29112;
	// 828E9D88: 39084B00  addi r8, r8, 0x4b00
	ctx.r[8].s64 = ctx.r[8].s64 + 19200;
	// 828E9D8C: 916A3C80  stw r11, 0x3c80(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15488 as u32), ctx.r[11].u32 ) };
	// 828E9D90: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828E9D94: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828E9D98: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828E9D9C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828E9DA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9DA4: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828E9DA8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828E9DAC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E9DB0: 4BD6A811  bl 0x826545c0
	ctx.lr = 0x828E9DB4;
	sub_826545C0(ctx, base);
	// 828E9DB4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E9DB8: 4182000C  beq 0x828e9dc4
	if ctx.cr[0].eq {
	pc = 0x828E9DC4; continue 'dispatch;
	}
	// 828E9DBC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828E9DC0: 48000008  b 0x828e9dc8
	pc = 0x828E9DC8; continue 'dispatch;
	// 828E9DC4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828E9DC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E9DCC: 488BE3F0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9DD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E9DD0 size=128
    let mut pc: u32 = 0x828E9DD0;
    'dispatch: loop {
        match pc {
            0x828E9DD0 => {
    //   block [0x828E9DD0..0x828E9E50)
	// 828E9DD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E9DD4: 488BE399  bl 0x831a816c
	ctx.lr = 0x828E9DD8;
	sub_831A8130(ctx, base);
	// 828E9DD8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E9DDC: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828E9DE0: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828E9DE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E9DE8: 3BEB3C84  addi r31, r11, 0x3c84
	ctx.r[31].s64 = ctx.r[11].s64 + 15492;
	// 828E9DEC: 816A3C8C  lwz r11, 0x3c8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15500 as u32) ) } as u64;
	// 828E9DF0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828E9DF4: 40820024  bne 0x828e9e18
	if !ctx.cr[0].eq {
	pc = 0x828E9E18; continue 'dispatch;
	}
	// 828E9DF8: 3D208289  lis r9, -0x7d77
	ctx.r[9].s64 = -2104950784;
	// 828E9DFC: 3D00828E  lis r8, -0x7d72
	ctx.r[8].s64 = -2104623104;
	// 828E9E00: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828E9E04: 392990C8  addi r9, r9, -0x6f38
	ctx.r[9].s64 = ctx.r[9].s64 + -28472;
	// 828E9E08: 39084B48  addi r8, r8, 0x4b48
	ctx.r[8].s64 = ctx.r[8].s64 + 19272;
	// 828E9E0C: 916A3C8C  stw r11, 0x3c8c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15500 as u32), ctx.r[11].u32 ) };
	// 828E9E10: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828E9E14: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828E9E18: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828E9E1C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828E9E20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9E24: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828E9E28: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828E9E2C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E9E30: 4BD6A791  bl 0x826545c0
	ctx.lr = 0x828E9E34;
	sub_826545C0(ctx, base);
	// 828E9E34: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E9E38: 4182000C  beq 0x828e9e44
	if ctx.cr[0].eq {
	pc = 0x828E9E44; continue 'dispatch;
	}
	// 828E9E3C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828E9E40: 48000008  b 0x828e9e48
	pc = 0x828E9E48; continue 'dispatch;
	// 828E9E44: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828E9E48: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E9E4C: 488BE370  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E9E50 size=128
    let mut pc: u32 = 0x828E9E50;
    'dispatch: loop {
        match pc {
            0x828E9E50 => {
    //   block [0x828E9E50..0x828E9ED0)
	// 828E9E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E9E54: 488BE319  bl 0x831a816c
	ctx.lr = 0x828E9E58;
	sub_831A8130(ctx, base);
	// 828E9E58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E9E5C: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828E9E60: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828E9E64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E9E68: 3BEB3C90  addi r31, r11, 0x3c90
	ctx.r[31].s64 = ctx.r[11].s64 + 15504;
	// 828E9E6C: 816A3C98  lwz r11, 0x3c98(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15512 as u32) ) } as u64;
	// 828E9E70: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828E9E74: 40820024  bne 0x828e9e98
	if !ctx.cr[0].eq {
	pc = 0x828E9E98; continue 'dispatch;
	}
	// 828E9E78: 3D208289  lis r9, -0x7d77
	ctx.r[9].s64 = -2104950784;
	// 828E9E7C: 3D00828E  lis r8, -0x7d72
	ctx.r[8].s64 = -2104623104;
	// 828E9E80: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828E9E84: 39299108  addi r9, r9, -0x6ef8
	ctx.r[9].s64 = ctx.r[9].s64 + -28408;
	// 828E9E88: 39084B90  addi r8, r8, 0x4b90
	ctx.r[8].s64 = ctx.r[8].s64 + 19344;
	// 828E9E8C: 916A3C98  stw r11, 0x3c98(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15512 as u32), ctx.r[11].u32 ) };
	// 828E9E90: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828E9E94: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828E9E98: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828E9E9C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828E9EA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9EA4: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828E9EA8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828E9EAC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E9EB0: 4BD6A711  bl 0x826545c0
	ctx.lr = 0x828E9EB4;
	sub_826545C0(ctx, base);
	// 828E9EB4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E9EB8: 4182000C  beq 0x828e9ec4
	if ctx.cr[0].eq {
	pc = 0x828E9EC4; continue 'dispatch;
	}
	// 828E9EBC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828E9EC0: 48000008  b 0x828e9ec8
	pc = 0x828E9EC8; continue 'dispatch;
	// 828E9EC4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828E9EC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E9ECC: 488BE2F0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E9ED0 size=128
    let mut pc: u32 = 0x828E9ED0;
    'dispatch: loop {
        match pc {
            0x828E9ED0 => {
    //   block [0x828E9ED0..0x828E9F50)
	// 828E9ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E9ED4: 488BE299  bl 0x831a816c
	ctx.lr = 0x828E9ED8;
	sub_831A8130(ctx, base);
	// 828E9ED8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E9EDC: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828E9EE0: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828E9EE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E9EE8: 3BEB3C9C  addi r31, r11, 0x3c9c
	ctx.r[31].s64 = ctx.r[11].s64 + 15516;
	// 828E9EEC: 816A3CA4  lwz r11, 0x3ca4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15524 as u32) ) } as u64;
	// 828E9EF0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828E9EF4: 40820024  bne 0x828e9f18
	if !ctx.cr[0].eq {
	pc = 0x828E9F18; continue 'dispatch;
	}
	// 828E9EF8: 3D208289  lis r9, -0x7d77
	ctx.r[9].s64 = -2104950784;
	// 828E9EFC: 3D00828E  lis r8, -0x7d72
	ctx.r[8].s64 = -2104623104;
	// 828E9F00: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828E9F04: 392990C8  addi r9, r9, -0x6f38
	ctx.r[9].s64 = ctx.r[9].s64 + -28472;
	// 828E9F08: 39084BD8  addi r8, r8, 0x4bd8
	ctx.r[8].s64 = ctx.r[8].s64 + 19416;
	// 828E9F0C: 916A3CA4  stw r11, 0x3ca4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15524 as u32), ctx.r[11].u32 ) };
	// 828E9F10: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828E9F14: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828E9F18: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828E9F1C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828E9F20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9F24: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828E9F28: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828E9F2C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E9F30: 4BD6A691  bl 0x826545c0
	ctx.lr = 0x828E9F34;
	sub_826545C0(ctx, base);
	// 828E9F34: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E9F38: 4182000C  beq 0x828e9f44
	if ctx.cr[0].eq {
	pc = 0x828E9F44; continue 'dispatch;
	}
	// 828E9F3C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828E9F40: 48000008  b 0x828e9f48
	pc = 0x828E9F48; continue 'dispatch;
	// 828E9F44: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828E9F48: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E9F4C: 488BE270  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828E9F50 size=128
    let mut pc: u32 = 0x828E9F50;
    'dispatch: loop {
        match pc {
            0x828E9F50 => {
    //   block [0x828E9F50..0x828E9FD0)
	// 828E9F50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E9F54: 488BE219  bl 0x831a816c
	ctx.lr = 0x828E9F58;
	sub_831A8130(ctx, base);
	// 828E9F58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E9F5C: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828E9F60: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828E9F64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828E9F68: 3BEB3CA8  addi r31, r11, 0x3ca8
	ctx.r[31].s64 = ctx.r[11].s64 + 15528;
	// 828E9F6C: 816A3CB0  lwz r11, 0x3cb0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15536 as u32) ) } as u64;
	// 828E9F70: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828E9F74: 40820024  bne 0x828e9f98
	if !ctx.cr[0].eq {
	pc = 0x828E9F98; continue 'dispatch;
	}
	// 828E9F78: 3D20828F  lis r9, -0x7d71
	ctx.r[9].s64 = -2104557568;
	// 828E9F7C: 3D00828E  lis r8, -0x7d72
	ctx.r[8].s64 = -2104623104;
	// 828E9F80: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828E9F84: 39298DF8  addi r9, r9, -0x7208
	ctx.r[9].s64 = ctx.r[9].s64 + -29192;
	// 828E9F88: 39084C20  addi r8, r8, 0x4c20
	ctx.r[8].s64 = ctx.r[8].s64 + 19488;
	// 828E9F8C: 916A3CB0  stw r11, 0x3cb0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15536 as u32), ctx.r[11].u32 ) };
	// 828E9F90: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828E9F94: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828E9F98: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828E9F9C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828E9FA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828E9FA4: 38FE0008  addi r7, r30, 8
	ctx.r[7].s64 = ctx.r[30].s64 + 8;
	// 828E9FA8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828E9FAC: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828E9FB0: 4BFF9A21  bl 0x828e39d0
	ctx.lr = 0x828E9FB4;
	sub_828E39D0(ctx, base);
	// 828E9FB4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828E9FB8: 4182000C  beq 0x828e9fc4
	if ctx.cr[0].eq {
	pc = 0x828E9FC4; continue 'dispatch;
	}
	// 828E9FBC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828E9FC0: 48000008  b 0x828e9fc8
	pc = 0x828E9FC8; continue 'dispatch;
	// 828E9FC4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828E9FC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828E9FCC: 488BE1F0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828E9FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828E9FD0 size=560
    let mut pc: u32 = 0x828E9FD0;
    'dispatch: loop {
        match pc {
            0x828E9FD0 => {
    //   block [0x828E9FD0..0x828EA200)
	// 828E9FD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828E9FD4: 488BE199  bl 0x831a816c
	ctx.lr = 0x828E9FD8;
	sub_831A8130(ctx, base);
	// 828E9FD8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828E9FDC: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828E9FE0: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828E9FE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828E9FE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828E9FEC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828E9FF0: 808BE264  lwz r4, -0x1d9c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7580 as u32) ) } as u64;
	// 828E9FF4: 48509A15  bl 0x82df3a08
	ctx.lr = 0x828E9FF8;
	sub_82DF3A08(ctx, base);
	// 828E9FF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828E9FFC: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 828EA000: 48509309  bl 0x82df3308
	ctx.lr = 0x828EA004;
	sub_82DF3308(ctx, base);
	// 828EA004: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828EA008: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA00C: 4850941D  bl 0x82df3428
	ctx.lr = 0x828EA010;
	sub_82DF3428(ctx, base);
	// 828EA010: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EA014: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EA018: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA01C: 4182000C  beq 0x828ea028
	if ctx.cr[0].eq {
	pc = 0x828EA028; continue 'dispatch;
	}
	// 828EA020: 480268F9  bl 0x82910918
	ctx.lr = 0x828EA024;
	sub_82910918(ctx, base);
	// 828EA024: 480001D0  b 0x828ea1f4
	pc = 0x828EA1F4; continue 'dispatch;
	// 828EA028: 480271F9  bl 0x82911220
	ctx.lr = 0x828EA02C;
	sub_82911220(ctx, base);
	// 828EA02C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA030: 4BF02131  bl 0x827ec160
	ctx.lr = 0x828EA034;
	sub_827EC160(ctx, base);
	// 828EA034: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA038: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EA03C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EA040: 4E800421  bctrl
	ctx.lr = 0x828EA044;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EA044: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EA048: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA04C: 481D7F45  bl 0x82ac1f90
	ctx.lr = 0x828EA050;
	sub_82AC1F90(ctx, base);
	// 828EA050: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA054: 4BF0210D  bl 0x827ec160
	ctx.lr = 0x828EA058;
	sub_827EC160(ctx, base);
	// 828EA058: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA05C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828EA060: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EA064: 4E800421  bctrl
	ctx.lr = 0x828EA068;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EA068: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EA06C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA070: 481C1469  bl 0x82aab4d8
	ctx.lr = 0x828EA074;
	sub_82AAB4D8(ctx, base);
	// 828EA074: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EA078: 807F01CC  lwz r3, 0x1cc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 828EA07C: 4BF001D5  bl 0x827ea250
	ctx.lr = 0x828EA080;
	sub_827EA250(ctx, base);
	// 828EA080: 807F01CC  lwz r3, 0x1cc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 828EA084: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA088: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA08C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EA090: 4E800421  bctrl
	ctx.lr = 0x828EA094;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EA094: 482CA785  bl 0x82bb4818
	ctx.lr = 0x828EA098;
	sub_82BB4818(ctx, base);
	// 828EA098: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EA09C: 41820010  beq 0x828ea0ac
	if ctx.cr[0].eq {
	pc = 0x828EA0AC; continue 'dispatch;
	}
	// 828EA0A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EA0A4: 807F0260  lwz r3, 0x260(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 828EA0A8: 480285B1  bl 0x82912658
	ctx.lr = 0x828EA0AC;
	sub_82912658(ctx, base);
	// 828EA0AC: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 828EA0B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EA0B4: 419A0018  beq cr6, 0x828ea0cc
	if ctx.cr[6].eq {
	pc = 0x828EA0CC; continue 'dispatch;
	}
	// 828EA0B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA0BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EA0C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EA0C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EA0C8: 4E800421  bctrl
	ctx.lr = 0x828EA0CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EA0CC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828EA0D0: 817F03EC  lwz r11, 0x3ec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1004 as u32) ) } as u64;
	// 828EA0D4: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EA0D8: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828EA0DC: 418200B4  beq 0x828ea190
	if ctx.cr[0].eq {
	pc = 0x828EA190; continue 'dispatch;
	}
	// 828EA0E0: 817F03EC  lwz r11, 0x3ec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1004 as u32) ) } as u64;
	// 828EA0E4: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828EA0E8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828EA0EC: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828EA0F0: 917F03EC  stw r11, 0x3ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1004 as u32), ctx.r[11].u32 ) };
	// 828EA0F4: 808A9224  lwz r4, -0x6ddc(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28124 as u32) ) } as u64;
	// 828EA0F8: 48509911  bl 0x82df3a08
	ctx.lr = 0x828EA0FC;
	sub_82DF3A08(ctx, base);
	// 828EA0FC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828EA100: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828EA104: 388B2DE0  addi r4, r11, 0x2de0
	ctx.r[4].s64 = ctx.r[11].s64 + 11744;
	// 828EA108: 48509901  bl 0x82df3a08
	ctx.lr = 0x828EA10C;
	sub_82DF3A08(ctx, base);
	// 828EA10C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828EA110: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 828EA114: D3E1007C  stfs f31, 0x7c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 828EA118: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 828EA11C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828EA120: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828EA124: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 828EA128: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828EA12C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828EA130: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828EA134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA138: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 828EA13C: D3E10090  stfs f31, 0x90(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828EA140: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828EA144: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 828EA148: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 828EA14C: 4BF0254D  bl 0x827ec698
	ctx.lr = 0x828EA150;
	sub_827EC698(ctx, base);
	// 828EA150: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828EA154: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EA158: 38AB9704  addi r5, r11, -0x68fc
	ctx.r[5].s64 = ctx.r[11].s64 + -26876;
	// 828EA15C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EA160: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA164: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828EA168: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EA16C: 4E800421  bctrl
	ctx.lr = 0x828EA170;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EA170: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828EA174: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EA178: 419A0008  beq cr6, 0x828ea180
	if ctx.cr[6].eq {
	pc = 0x828EA180; continue 'dispatch;
	}
	// 828EA17C: 4B9D6715  bl 0x822c0890
	ctx.lr = 0x828EA180;
	sub_822C0890(ctx, base);
	// 828EA180: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 828EA184: 485092A5  bl 0x82df3428
	ctx.lr = 0x828EA188;
	sub_82DF3428(ctx, base);
	// 828EA188: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828EA18C: 4850929D  bl 0x82df3428
	ctx.lr = 0x828EA190;
	sub_82DF3428(ctx, base);
	// 828EA190: 817F03EC  lwz r11, 0x3ec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1004 as u32) ) } as u64;
	// 828EA194: 556BFFFF  rlwinm. r11, r11, 0x1f, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EA198: 40820050  bne 0x828ea1e8
	if !ctx.cr[0].eq {
	pc = 0x828EA1E8; continue 'dispatch;
	}
	// 828EA19C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA1A0: 4801ECB9  bl 0x82908e58
	ctx.lr = 0x828EA1A4;
	sub_82908E58(ctx, base);
	// 828EA1A4: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 828EA1A8: 41990040  bgt cr6, 0x828ea1e8
	if ctx.cr[6].gt {
	pc = 0x828EA1E8; continue 'dispatch;
	}
	// 828EA1AC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA1B0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828EA1B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EA1B8: 38AA1F2C  addi r5, r10, 0x1f2c
	ctx.r[5].s64 = ctx.r[10].s64 + 7980;
	// 828EA1BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EA1C0: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828EA1C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EA1C8: 4E800421  bctrl
	ctx.lr = 0x828EA1CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EA1CC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828EA1D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EA1D4: 419A0008  beq cr6, 0x828ea1dc
	if ctx.cr[6].eq {
	pc = 0x828EA1DC; continue 'dispatch;
	}
	// 828EA1D8: 4B9D66B9  bl 0x822c0890
	ctx.lr = 0x828EA1DC;
	sub_822C0890(ctx, base);
	// 828EA1DC: 817F03EC  lwz r11, 0x3ec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1004 as u32) ) } as u64;
	// 828EA1E0: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 828EA1E4: 917F03EC  stw r11, 0x3ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1004 as u32), ctx.r[11].u32 ) };
	// 828EA1E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EA1EC: 807F036C  lwz r3, 0x36c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(876 as u32) ) } as u64;
	// 828EA1F0: 48038789  bl 0x82922978
	ctx.lr = 0x828EA1F4;
	sub_82922978(ctx, base);
	// 828EA1F4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828EA1F8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828EA1FC: 488BDFC0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EA200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EA200 size=88
    let mut pc: u32 = 0x828EA200;
    'dispatch: loop {
        match pc {
            0x828EA200 => {
    //   block [0x828EA200..0x828EA258)
	// 828EA200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EA204: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EA208: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EA20C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EA210: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EA214: 4801EB15  bl 0x82908d28
	ctx.lr = 0x828EA218;
	sub_82908D28(ctx, base);
	// 828EA218: 817F03EC  lwz r11, 0x3ec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1004 as u32) ) } as u64;
	// 828EA21C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA220: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828EA224: 917F03EC  stw r11, 0x3ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1004 as u32), ctx.r[11].u32 ) };
	// 828EA228: 48026121  bl 0x82910348
	ctx.lr = 0x828EA22C;
	sub_82910348(ctx, base);
	// 828EA22C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA230: 48026161  bl 0x82910390
	ctx.lr = 0x828EA234;
	sub_82910390(ctx, base);
	// 828EA234: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA238: 4BFFD221  bl 0x828e7458
	ctx.lr = 0x828EA23C;
	sub_828E7458(ctx, base);
	// 828EA23C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EA240: 4BC26391  bl 0x825105d0
	ctx.lr = 0x828EA244;
	sub_825105D0(ctx, base);
	// 828EA244: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828EA248: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EA24C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EA250: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EA254: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EA258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828EA258 size=11712
    let mut pc: u32 = 0x828EA258;
    'dispatch: loop {
        match pc {
            0x828EA258 => {
    //   block [0x828EA258..0x828ED018)
	// 828EA258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EA25C: 488BDED5  bl 0x831a8130
	ctx.lr = 0x828EA260;
	sub_831A8130(ctx, base);
	// 828EA260: DBC1FF58  stfd f30, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 828EA264: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 828EA268: 9421FC60  stwu r1, -0x3a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-928 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EA26C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828EA270: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 828EA274: 7CB22B78  mr r18, r5
	ctx.r[18].u64 = ctx.r[5].u64;
	// 828EA278: 7CD43378  mr r20, r6
	ctx.r[20].u64 = ctx.r[6].u64;
	// 828EA27C: 48026B15  bl 0x82910d90
	ctx.lr = 0x828EA280;
	sub_82910D90(ctx, base);
	// 828EA280: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828EA284: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EA288: 4BC250E9  bl 0x8250f370
	ctx.lr = 0x828EA28C;
	sub_8250F370(ctx, base);
	// 828EA28C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828EA290: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 828EA294: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 828EA298: 48509771  bl 0x82df3a08
	ctx.lr = 0x828EA29C;
	sub_82DF3A08(ctx, base);
	// 828EA29C: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 828EA2A0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828EA2A4: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 828EA2A8: 4BC1E4D9  bl 0x82508780
	ctx.lr = 0x828EA2AC;
	sub_82508780(ctx, base);
	// 828EA2AC: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 828EA2B0: 48509179  bl 0x82df3428
	ctx.lr = 0x828EA2B4;
	sub_82DF3428(ctx, base);
	// 828EA2B4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828EA2B8: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 828EA2BC: 808BE264  lwz r4, -0x1d9c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7580 as u32) ) } as u64;
	// 828EA2C0: 48509749  bl 0x82df3a08
	ctx.lr = 0x828EA2C4;
	sub_82DF3A08(ctx, base);
	// 828EA2C4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828EA2C8: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 828EA2CC: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 828EA2D0: 4BC1E4B1  bl 0x82508780
	ctx.lr = 0x828EA2D4;
	sub_82508780(ctx, base);
	// 828EA2D4: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 828EA2D8: 48509151  bl 0x82df3428
	ctx.lr = 0x828EA2DC;
	sub_82DF3428(ctx, base);
	// 828EA2DC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828EA2E0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828EA2E4: 389D0028  addi r4, r29, 0x28
	ctx.r[4].s64 = ctx.r[29].s64 + 40;
	// 828EA2E8: 409A0008  bne cr6, 0x828ea2f0
	if !ctx.cr[6].eq {
	pc = 0x828EA2F0; continue 'dispatch;
	}
	// 828EA2EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EA2F0: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 828EA2F4: 4BC1E4AD  bl 0x825087a0
	ctx.lr = 0x828EA2F8;
	sub_825087A0(ctx, base);
	// 828EA2F8: 817D02E0  lwz r11, 0x2e0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(736 as u32) ) } as u64;
	// 828EA2FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EA300: 409A0018  bne cr6, 0x828ea318
	if !ctx.cr[6].eq {
	pc = 0x828EA318; continue 'dispatch;
	}
	// 828EA304: 817D03E0  lwz r11, 0x3e0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(992 as u32) ) } as u64;
	// 828EA308: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EA30C: 915D03E4  stw r10, 0x3e4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(996 as u32), ctx.r[10].u32 ) };
	// 828EA310: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA314: 917D03E8  stw r11, 0x3e8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(1000 as u32), ctx.r[11].u32 ) };
	// 828EA318: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EA31C: 4801EACD  bl 0x82908de8
	ctx.lr = 0x828EA320;
	sub_82908DE8(ctx, base);
	// 828EA320: 2F030010  cmpwi cr6, r3, 0x10
	ctx.cr[6].compare_i32(ctx.r[3].s32, 16, &mut ctx.xer);
	// 828EA324: 419A00D4  beq cr6, 0x828ea3f8
	if ctx.cr[6].eq {
	pc = 0x828EA3F8; continue 'dispatch;
	}
	// 828EA328: 2F030011  cmpwi cr6, r3, 0x11
	ctx.cr[6].compare_i32(ctx.r[3].s32, 17, &mut ctx.xer);
	// 828EA32C: 419A00A0  beq cr6, 0x828ea3cc
	if ctx.cr[6].eq {
	pc = 0x828EA3CC; continue 'dispatch;
	}
	// 828EA330: 2F030012  cmpwi cr6, r3, 0x12
	ctx.cr[6].compare_i32(ctx.r[3].s32, 18, &mut ctx.xer);
	// 828EA334: 419A006C  beq cr6, 0x828ea3a0
	if ctx.cr[6].eq {
	pc = 0x828EA3A0; continue 'dispatch;
	}
	// 828EA338: 2F030013  cmpwi cr6, r3, 0x13
	ctx.cr[6].compare_i32(ctx.r[3].s32, 19, &mut ctx.xer);
	// 828EA33C: 419A0038  beq cr6, 0x828ea374
	if ctx.cr[6].eq {
	pc = 0x828EA374; continue 'dispatch;
	}
	// 828EA340: 2F030014  cmpwi cr6, r3, 0x14
	ctx.cr[6].compare_i32(ctx.r[3].s32, 20, &mut ctx.xer);
	// 828EA344: 409A00DC  bne cr6, 0x828ea420
	if !ctx.cr[6].eq {
	pc = 0x828EA420; continue 'dispatch;
	}
	// 828EA348: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EA34C: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 828EA350: 396B9208  addi r11, r11, -0x6df8
	ctx.r[11].s64 = ctx.r[11].s64 + -28152;
	// 828EA354: 808B0010  lwz r4, 0x10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828EA358: 485096B1  bl 0x82df3a08
	ctx.lr = 0x828EA35C;
	sub_82DF3A08(ctx, base);
	// 828EA35C: 38A10100  addi r5, r1, 0x100
	ctx.r[5].s64 = ctx.r[1].s64 + 256;
	// 828EA360: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828EA364: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EA368: 48026299  bl 0x82910600
	ctx.lr = 0x828EA36C;
	sub_82910600(ctx, base);
	// 828EA36C: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 828EA370: 480000AC  b 0x828ea41c
	pc = 0x828EA41C; continue 'dispatch;
	// 828EA374: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EA378: 38610104  addi r3, r1, 0x104
	ctx.r[3].s64 = ctx.r[1].s64 + 260;
	// 828EA37C: 396B9208  addi r11, r11, -0x6df8
	ctx.r[11].s64 = ctx.r[11].s64 + -28152;
	// 828EA380: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828EA384: 48509685  bl 0x82df3a08
	ctx.lr = 0x828EA388;
	sub_82DF3A08(ctx, base);
	// 828EA388: 38A10104  addi r5, r1, 0x104
	ctx.r[5].s64 = ctx.r[1].s64 + 260;
	// 828EA38C: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828EA390: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EA394: 4802626D  bl 0x82910600
	ctx.lr = 0x828EA398;
	sub_82910600(ctx, base);
	// 828EA398: 38610104  addi r3, r1, 0x104
	ctx.r[3].s64 = ctx.r[1].s64 + 260;
	// 828EA39C: 48000080  b 0x828ea41c
	pc = 0x828EA41C; continue 'dispatch;
	// 828EA3A0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EA3A4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828EA3A8: 396B9208  addi r11, r11, -0x6df8
	ctx.r[11].s64 = ctx.r[11].s64 + -28152;
	// 828EA3AC: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828EA3B0: 48509659  bl 0x82df3a08
	ctx.lr = 0x828EA3B4;
	sub_82DF3A08(ctx, base);
	// 828EA3B4: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 828EA3B8: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828EA3BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EA3C0: 48026241  bl 0x82910600
	ctx.lr = 0x828EA3C4;
	sub_82910600(ctx, base);
	// 828EA3C4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828EA3C8: 48000054  b 0x828ea41c
	pc = 0x828EA41C; continue 'dispatch;
	// 828EA3CC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EA3D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EA3D4: 396B9208  addi r11, r11, -0x6df8
	ctx.r[11].s64 = ctx.r[11].s64 + -28152;
	// 828EA3D8: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EA3DC: 4850962D  bl 0x82df3a08
	ctx.lr = 0x828EA3E0;
	sub_82DF3A08(ctx, base);
	// 828EA3E0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828EA3E4: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828EA3E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EA3EC: 48026215  bl 0x82910600
	ctx.lr = 0x828EA3F0;
	sub_82910600(ctx, base);
	// 828EA3F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EA3F4: 48000028  b 0x828ea41c
	pc = 0x828EA41C; continue 'dispatch;
	// 828EA3F8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EA3FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA400: 808B9208  lwz r4, -0x6df8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28152 as u32) ) } as u64;
	// 828EA404: 48509605  bl 0x82df3a08
	ctx.lr = 0x828EA408;
	sub_82DF3A08(ctx, base);
	// 828EA408: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828EA40C: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828EA410: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EA414: 480261ED  bl 0x82910600
	ctx.lr = 0x828EA418;
	sub_82910600(ctx, base);
	// 828EA418: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA41C: 4850900D  bl 0x82df3428
	ctx.lr = 0x828EA420;
	sub_82DF3428(ctx, base);
	// 828EA420: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EA424: 4802649D  bl 0x829108c0
	ctx.lr = 0x828EA428;
	sub_829108C0(ctx, base);
	// 828EA428: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EA42C: 41820010  beq 0x828ea43c
	if ctx.cr[0].eq {
	pc = 0x828EA43C; continue 'dispatch;
	}
	// 828EA430: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EA434: 4BC2619D  bl 0x825105d0
	ctx.lr = 0x828EA438;
	sub_825105D0(ctx, base);
	// 828EA438: 48002BD0  b 0x828ed008
	pc = 0x828ED008; continue 'dispatch;
	// 828EA43C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EA440: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828EA444: 3AAB0FF0  addi r21, r11, 0xff0
	ctx.r[21].s64 = ctx.r[11].s64 + 4080;
	// 828EA448: 38A00112  li r5, 0x112
	ctx.r[5].s64 = 274;
	// 828EA44C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828EA450: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828EA454: 4B9D5F85  bl 0x822c03d8
	ctx.lr = 0x828EA458;
	sub_822C03D8(ctx, base);
	// 828EA458: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828EA45C: 41820020  beq 0x828ea47c
	if ctx.cr[0].eq {
	pc = 0x828EA47C; continue 'dispatch;
	}
	// 828EA460: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EA464: 4BF0084D  bl 0x827eacb0
	ctx.lr = 0x828EA468;
	sub_827EACB0(ctx, base);
	// 828EA468: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828EA46C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EA470: 396B09D8  addi r11, r11, 0x9d8
	ctx.r[11].s64 = ctx.r[11].s64 + 2520;
	// 828EA474: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828EA478: 48000008  b 0x828ea480
	pc = 0x828EA480; continue 'dispatch;
	// 828EA47C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EA480: 3BDD01CC  addi r30, r29, 0x1cc
	ctx.r[30].s64 = ctx.r[29].s64 + 460;
	// 828EA484: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EA488: 4BF7DDF9  bl 0x82868280
	ctx.lr = 0x828EA48C;
	sub_82868280(ctx, base);
	// 828EA48C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EA490: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA494: 808B921C  lwz r4, -0x6de4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28132 as u32) ) } as u64;
	// 828EA498: 48509571  bl 0x82df3a08
	ctx.lr = 0x828EA49C;
	sub_82DF3A08(ctx, base);
	// 828EA49C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828EA4A0: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 828EA4A4: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 828EA4A8: 837D01CC  lwz r27, 0x1cc(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(460 as u32) ) } as u64;
	// 828EA4AC: 4BC2501D  bl 0x8250f4c8
	ctx.lr = 0x828EA4B0;
	sub_8250F4C8(ctx, base);
	// 828EA4B0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EA4B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EA4B8: 3A6B0C0C  addi r19, r11, 0xc0c
	ctx.r[19].s64 = ctx.r[11].s64 + 3084;
	// 828EA4BC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828EA4C0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828EA4C4: C0330008  lfs f1, 8(r19)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EA4C8: 4BF004A1  bl 0x827ea968
	ctx.lr = 0x828EA4CC;
	sub_827EA968(ctx, base);
	// 828EA4CC: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 828EA4D0: 485077C1  bl 0x82df1c90
	ctx.lr = 0x828EA4D4;
	sub_82DF1C90(ctx, base);
	// 828EA4D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA4D8: 48508F51  bl 0x82df3428
	ctx.lr = 0x828EA4DC;
	sub_82DF3428(ctx, base);
	// 828EA4DC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EA4E0: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828EA4E4: 807D01CC  lwz r3, 0x1cc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(460 as u32) ) } as u64;
	// 828EA4E8: 388A9240  addi r4, r10, -0x6dc0
	ctx.r[4].s64 = ctx.r[10].s64 + -28096;
	// 828EA4EC: 80AB2084  lwz r5, 0x2084(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8324 as u32) ) } as u64;
	// 828EA4F0: 4BF001D1  bl 0x827ea6c0
	ctx.lr = 0x828EA4F4;
	sub_827EA6C0(ctx, base);
	// 828EA4F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828EA4F8: 386101C8  addi r3, r1, 0x1c8
	ctx.r[3].s64 = ctx.r[1].s64 + 456;
	// 828EA4FC: 4BF020CD  bl 0x827ec5c8
	ctx.lr = 0x828EA500;
	sub_827EC5C8(ctx, base);
	// 828EA500: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828EA504: 807D01CC  lwz r3, 0x1cc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(460 as u32) ) } as u64;
	// 828EA508: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA50C: 4BF001BD  bl 0x827ea6c8
	ctx.lr = 0x828EA510;
	sub_827EA6C8(ctx, base);
	// 828EA510: 806101CC  lwz r3, 0x1cc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(460 as u32) ) } as u64;
	// 828EA514: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EA518: 419A0008  beq cr6, 0x828ea520
	if ctx.cr[6].eq {
	pc = 0x828EA520; continue 'dispatch;
	}
	// 828EA51C: 4B9D6375  bl 0x822c0890
	ctx.lr = 0x828EA520;
	sub_822C0890(ctx, base);
	// 828EA520: 3F40832D  lis r26, -0x7cd3
	ctx.r[26].s64 = -2094202880;
	// 828EA524: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EA528: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EA52C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA530: 396B75F0  addi r11, r11, 0x75f0
	ctx.r[11].s64 = ctx.r[11].s64 + 30192;
	// 828EA534: 809AA028  lwz r4, -0x5fd8(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-24536 as u32) ) } as u64;
	// 828EA538: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EA53C: 485094CD  bl 0x82df3a08
	ctx.lr = 0x828EA540;
	sub_82DF3A08(ctx, base);
	// 828EA540: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828EA544: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 828EA548: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EA54C: E8A10078  ld r5, 0x78(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 828EA550: 93E100D0  stw r31, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 828EA554: 4BFFF7FD  bl 0x828e9d50
	ctx.lr = 0x828EA558;
	sub_828E9D50(ctx, base);
	// 828EA558: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828EA55C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA560: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 828EA564: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EA568: C02BF904  lfs f1, -0x6fc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1788 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EA56C: 4BF00245  bl 0x827ea7b0
	ctx.lr = 0x828EA570;
	sub_827EA7B0(ctx, base);
	// 828EA570: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA574: 48508EB5  bl 0x82df3428
	ctx.lr = 0x828EA578;
	sub_82DF3428(ctx, base);
	// 828EA578: 3F20832D  lis r25, -0x7cd3
	ctx.r[25].s64 = -2094202880;
	// 828EA57C: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EA580: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EA584: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA588: 396B76E0  addi r11, r11, 0x76e0
	ctx.r[11].s64 = ctx.r[11].s64 + 30432;
	// 828EA58C: 8099A02C  lwz r4, -0x5fd4(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-24532 as u32) ) } as u64;
	// 828EA590: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EA594: 48509475  bl 0x82df3a08
	ctx.lr = 0x828EA598;
	sub_82DF3A08(ctx, base);
	// 828EA598: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828EA59C: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 828EA5A0: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EA5A4: E8A10078  ld r5, 0x78(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 828EA5A8: 93E100D0  stw r31, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 828EA5AC: 4BFFF7A5  bl 0x828e9d50
	ctx.lr = 0x828EA5B0;
	sub_828E9D50(ctx, base);
	// 828EA5B0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828EA5B4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA5B8: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 828EA5BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EA5C0: C3CB966C  lfs f30, -0x6994(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27028 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828EA5C4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828EA5C8: 4BF001E9  bl 0x827ea7b0
	ctx.lr = 0x828EA5CC;
	sub_827EA7B0(ctx, base);
	// 828EA5CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA5D0: 48508E59  bl 0x82df3428
	ctx.lr = 0x828EA5D4;
	sub_82DF3428(ctx, base);
	// 828EA5D4: 3F00832D  lis r24, -0x7cd3
	ctx.r[24].s64 = -2094202880;
	// 828EA5D8: 3D60828F  lis r11, -0x7d71
	ctx.r[11].s64 = -2104557568;
	// 828EA5DC: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EA5E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA5E4: 396B8E80  addi r11, r11, -0x7180
	ctx.r[11].s64 = ctx.r[11].s64 + -29056;
	// 828EA5E8: 8098A038  lwz r4, -0x5fc8(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-24520 as u32) ) } as u64;
	// 828EA5EC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EA5F0: 48509419  bl 0x82df3a08
	ctx.lr = 0x828EA5F4;
	sub_82DF3A08(ctx, base);
	// 828EA5F4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828EA5F8: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 828EA5FC: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EA600: E8A10078  ld r5, 0x78(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 828EA604: 93E100D0  stw r31, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 828EA608: 4BFFF749  bl 0x828e9d50
	ctx.lr = 0x828EA60C;
	sub_828E9D50(ctx, base);
	// 828EA60C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828EA610: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA614: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 828EA618: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EA61C: C3EB95A0  lfs f31, -0x6a60(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27232 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828EA620: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828EA624: 4BF0018D  bl 0x827ea7b0
	ctx.lr = 0x828EA628;
	sub_827EA7B0(ctx, base);
	// 828EA628: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA62C: 48508DFD  bl 0x82df3428
	ctx.lr = 0x828EA630;
	sub_82DF3428(ctx, base);
	// 828EA630: 3EE0832D  lis r23, -0x7cd3
	ctx.r[23].s64 = -2094202880;
	// 828EA634: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EA638: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EA63C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA640: 396B58D8  addi r11, r11, 0x58d8
	ctx.r[11].s64 = ctx.r[11].s64 + 22744;
	// 828EA644: 8097A030  lwz r4, -0x5fd0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-24528 as u32) ) } as u64;
	// 828EA648: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EA64C: 485093BD  bl 0x82df3a08
	ctx.lr = 0x828EA650;
	sub_82DF3A08(ctx, base);
	// 828EA650: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 828EA654: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828EA658: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EA65C: E8A10078  ld r5, 0x78(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 828EA660: 93E100D0  stw r31, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 828EA664: 4BFFF6ED  bl 0x828e9d50
	ctx.lr = 0x828EA668;
	sub_828E9D50(ctx, base);
	// 828EA668: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828EA66C: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 828EA670: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA674: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EA678: C02B9584  lfs f1, -0x6a7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27260 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EA67C: 4BF00135  bl 0x827ea7b0
	ctx.lr = 0x828EA680;
	sub_827EA7B0(ctx, base);
	// 828EA680: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA684: 48508DA5  bl 0x82df3428
	ctx.lr = 0x828EA688;
	sub_82DF3428(ctx, base);
	// 828EA688: 3E20832D  lis r17, -0x7cd3
	ctx.r[17].s64 = -2094202880;
	// 828EA68C: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EA690: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EA694: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA698: 396B5B50  addi r11, r11, 0x5b50
	ctx.r[11].s64 = ctx.r[11].s64 + 23376;
	// 828EA69C: 8091A034  lwz r4, -0x5fcc(r17)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(-24524 as u32) ) } as u64;
	// 828EA6A0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EA6A4: 48509365  bl 0x82df3a08
	ctx.lr = 0x828EA6A8;
	sub_82DF3A08(ctx, base);
	// 828EA6A8: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828EA6AC: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 828EA6B0: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EA6B4: E8A10078  ld r5, 0x78(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 828EA6B8: 93E100D0  stw r31, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 828EA6BC: 4BFFF695  bl 0x828e9d50
	ctx.lr = 0x828EA6C0;
	sub_828E9D50(ctx, base);
	// 828EA6C0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828EA6C4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA6C8: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 828EA6CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EA6D0: C02BD86C  lfs f1, -0x2794(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10132 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EA6D4: 4BF000DD  bl 0x827ea7b0
	ctx.lr = 0x828EA6D8;
	sub_827EA7B0(ctx, base);
	// 828EA6D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA6DC: 48508D4D  bl 0x82df3428
	ctx.lr = 0x828EA6E0;
	sub_82DF3428(ctx, base);
	// 828EA6E0: 3E00832D  lis r16, -0x7cd3
	ctx.r[16].s64 = -2094202880;
	// 828EA6E4: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EA6E8: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EA6EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA6F0: 396B2628  addi r11, r11, 0x2628
	ctx.r[11].s64 = ctx.r[11].s64 + 9768;
	// 828EA6F4: 8090A020  lwz r4, -0x5fe0(r16)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(-24544 as u32) ) } as u64;
	// 828EA6F8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EA6FC: 4850930D  bl 0x82df3a08
	ctx.lr = 0x828EA700;
	sub_82DF3A08(ctx, base);
	// 828EA700: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828EA704: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828EA708: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 828EA70C: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EA710: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828EA714: 93E100D0  stw r31, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 828EA718: 4BFFF6B9  bl 0x828e9dd0
	ctx.lr = 0x828EA71C;
	sub_828E9DD0(ctx, base);
	// 828EA71C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828EA720: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA724: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 828EA728: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EA72C: C02B28C8  lfs f1, 0x28c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10440 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EA730: 4BF00081  bl 0x827ea7b0
	ctx.lr = 0x828EA734;
	sub_827EA7B0(ctx, base);
	// 828EA734: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA738: 48508CF1  bl 0x82df3428
	ctx.lr = 0x828EA73C;
	sub_82DF3428(ctx, base);
	// 828EA73C: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EA740: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA744: 8090A020  lwz r4, -0x5fe0(r16)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(-24544 as u32) ) } as u64;
	// 828EA748: 396B2628  addi r11, r11, 0x2628
	ctx.r[11].s64 = ctx.r[11].s64 + 9768;
	// 828EA74C: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EA750: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EA754: 485092B5  bl 0x82df3a08
	ctx.lr = 0x828EA758;
	sub_82DF3A08(ctx, base);
	// 828EA758: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 828EA75C: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828EA760: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828EA764: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EA768: 93610074  stw r27, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 828EA76C: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828EA770: 93E100D0  stw r31, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 828EA774: 4BFFF65D  bl 0x828e9dd0
	ctx.lr = 0x828EA778;
	sub_828E9DD0(ctx, base);
	// 828EA778: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828EA77C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA780: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 828EA784: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EA788: C02B093C  lfs f1, 0x93c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2364 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EA78C: 4BF00025  bl 0x827ea7b0
	ctx.lr = 0x828EA790;
	sub_827EA7B0(ctx, base);
	// 828EA790: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA794: 48508C95  bl 0x82df3428
	ctx.lr = 0x828EA798;
	sub_82DF3428(ctx, base);
	// 828EA798: 3F80832D  lis r28, -0x7cd3
	ctx.r[28].s64 = -2094202880;
	// 828EA79C: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EA7A0: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EA7A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA7A8: 396B2628  addi r11, r11, 0x2628
	ctx.r[11].s64 = ctx.r[11].s64 + 9768;
	// 828EA7AC: 809CA024  lwz r4, -0x5fdc(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-24540 as u32) ) } as u64;
	// 828EA7B0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EA7B4: 48509255  bl 0x82df3a08
	ctx.lr = 0x828EA7B8;
	sub_82DF3A08(ctx, base);
	// 828EA7B8: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828EA7BC: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828EA7C0: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 828EA7C4: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EA7C8: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828EA7CC: 93E100D0  stw r31, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 828EA7D0: 4BFFF601  bl 0x828e9dd0
	ctx.lr = 0x828EA7D4;
	sub_828E9DD0(ctx, base);
	// 828EA7D4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EA7D8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA7DC: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 828EA7E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EA7E4: C02B1F48  lfs f1, 0x1f48(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8008 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EA7E8: 4BEFFFC9  bl 0x827ea7b0
	ctx.lr = 0x828EA7EC;
	sub_827EA7B0(ctx, base);
	// 828EA7EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA7F0: 48508C39  bl 0x82df3428
	ctx.lr = 0x828EA7F4;
	sub_82DF3428(ctx, base);
	// 828EA7F4: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EA7F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA7FC: 809CA024  lwz r4, -0x5fdc(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-24540 as u32) ) } as u64;
	// 828EA800: 396B2628  addi r11, r11, 0x2628
	ctx.r[11].s64 = ctx.r[11].s64 + 9768;
	// 828EA804: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EA808: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EA80C: 485091FD  bl 0x82df3a08
	ctx.lr = 0x828EA810;
	sub_82DF3A08(ctx, base);
	// 828EA810: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828EA814: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828EA818: 93610074  stw r27, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 828EA81C: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EA820: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828EA824: 93E100D0  stw r31, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 828EA828: 4BFFF5A9  bl 0x828e9dd0
	ctx.lr = 0x828EA82C;
	sub_828E9DD0(ctx, base);
	// 828EA82C: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 828EA830: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA834: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EA838: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828EA83C: 4BEFFF75  bl 0x827ea7b0
	ctx.lr = 0x828EA840;
	sub_827EA7B0(ctx, base);
	// 828EA840: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA844: 48508BE5  bl 0x82df3428
	ctx.lr = 0x828EA848;
	sub_82DF3428(ctx, base);
	// 828EA848: 3F80832D  lis r28, -0x7cd3
	ctx.r[28].s64 = -2094202880;
	// 828EA84C: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 828EA850: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EA854: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA858: 396B3A90  addi r11, r11, 0x3a90
	ctx.r[11].s64 = ctx.r[11].s64 + 14992;
	// 828EA85C: 809CF434  lwz r4, -0xbcc(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-3020 as u32) ) } as u64;
	// 828EA860: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EA864: 485091A5  bl 0x82df3a08
	ctx.lr = 0x828EA868;
	sub_82DF3A08(ctx, base);
	// 828EA868: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828EA86C: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 828EA870: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EA874: E8A10078  ld r5, 0x78(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 828EA878: 93E100D0  stw r31, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 828EA87C: 4BFFF4D5  bl 0x828e9d50
	ctx.lr = 0x828EA880;
	sub_828E9D50(ctx, base);
	// 828EA880: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828EA884: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA888: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 828EA88C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EA890: C02BE830  lfs f1, -0x17d0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EA894: 4BEFFF1D  bl 0x827ea7b0
	ctx.lr = 0x828EA898;
	sub_827EA7B0(ctx, base);
	// 828EA898: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA89C: 48508B8D  bl 0x82df3428
	ctx.lr = 0x828EA8A0;
	sub_82DF3428(ctx, base);
	// 828EA8A0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 828EA8A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA8A8: 809CF434  lwz r4, -0xbcc(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-3020 as u32) ) } as u64;
	// 828EA8AC: 396B3A90  addi r11, r11, 0x3a90
	ctx.r[11].s64 = ctx.r[11].s64 + 14992;
	// 828EA8B0: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EA8B4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EA8B8: 48509151  bl 0x82df3a08
	ctx.lr = 0x828EA8BC;
	sub_82DF3A08(ctx, base);
	// 828EA8BC: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828EA8C0: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 828EA8C4: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EA8C8: E8A10078  ld r5, 0x78(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 828EA8CC: 93E100D0  stw r31, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 828EA8D0: 4BFFF481  bl 0x828e9d50
	ctx.lr = 0x828EA8D4;
	sub_828E9D50(ctx, base);
	// 828EA8D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828EA8D8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA8DC: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 828EA8E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EA8E4: C02B9594  lfs f1, -0x6a6c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27244 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EA8E8: 4BEFFEC9  bl 0x827ea7b0
	ctx.lr = 0x828EA8EC;
	sub_827EA7B0(ctx, base);
	// 828EA8EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA8F0: 48508B39  bl 0x82df3428
	ctx.lr = 0x828EA8F4;
	sub_82DF3428(ctx, base);
	// 828EA8F4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA8F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EA8FC: 816B01AC  lwz r11, 0x1ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(428 as u32) ) } as u64;
	// 828EA900: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EA904: 4E800421  bctrl
	ctx.lr = 0x828EA908;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EA908: 3F80832D  lis r28, -0x7cd3
	ctx.r[28].s64 = -2094202880;
	// 828EA90C: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EA910: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EA914: 7C6F1B78  mr r15, r3
	ctx.r[15].u64 = ctx.r[3].u64;
	// 828EA918: 396B7528  addi r11, r11, 0x7528
	ctx.r[11].s64 = ctx.r[11].s64 + 29992;
	// 828EA91C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA920: 809CF488  lwz r4, -0xb78(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-2936 as u32) ) } as u64;
	// 828EA924: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EA928: 485090E1  bl 0x82df3a08
	ctx.lr = 0x828EA92C;
	sub_82DF3A08(ctx, base);
	// 828EA92C: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EA930: C00F0004  lfs f0, 4(r15)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828EA934: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828EA938: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828EA93C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 828EA940: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828EA944: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828EA948: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828EA94C: 93E100D0  stw r31, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 828EA950: 4BFFF501  bl 0x828e9e50
	ctx.lr = 0x828EA954;
	sub_828E9E50(ctx, base);
	// 828EA954: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 828EA958: C02F000C  lfs f1, 0xc(r15)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EA95C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EA960: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA964: 4BEFFE4D  bl 0x827ea7b0
	ctx.lr = 0x828EA968;
	sub_827EA7B0(ctx, base);
	// 828EA968: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA96C: 48508ABD  bl 0x82df3428
	ctx.lr = 0x828EA970;
	sub_82DF3428(ctx, base);
	// 828EA970: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EA974: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA978: 809CF488  lwz r4, -0xb78(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-2936 as u32) ) } as u64;
	// 828EA97C: 396B7528  addi r11, r11, 0x7528
	ctx.r[11].s64 = ctx.r[11].s64 + 29992;
	// 828EA980: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EA984: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EA988: 48509081  bl 0x82df3a08
	ctx.lr = 0x828EA98C;
	sub_82DF3A08(ctx, base);
	// 828EA98C: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EA990: C00F0008  lfs f0, 8(r15)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828EA994: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828EA998: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828EA99C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 828EA9A0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828EA9A4: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828EA9A8: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828EA9AC: 93E100D0  stw r31, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 828EA9B0: 4BFFF4A1  bl 0x828e9e50
	ctx.lr = 0x828EA9B4;
	sub_828E9E50(ctx, base);
	// 828EA9B4: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 828EA9B8: C02F0010  lfs f1, 0x10(r15)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EA9BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EA9C0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EA9C4: 4BEFFDED  bl 0x827ea7b0
	ctx.lr = 0x828EA9C8;
	sub_827EA7B0(ctx, base);
	// 828EA9C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA9CC: 48508A5D  bl 0x82df3428
	ctx.lr = 0x828EA9D0;
	sub_82DF3428(ctx, base);
	// 828EA9D0: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EA9D4: 3F80832D  lis r28, -0x7cd3
	ctx.r[28].s64 = -2094202880;
	// 828EA9D8: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EA9DC: 396B7528  addi r11, r11, 0x7528
	ctx.r[11].s64 = ctx.r[11].s64 + 29992;
	// 828EA9E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EA9E4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EA9E8: 809CF49C  lwz r4, -0xb64(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-2916 as u32) ) } as u64;
	// 828EA9EC: 4850901D  bl 0x82df3a08
	ctx.lr = 0x828EA9F0;
	sub_82DF3A08(ctx, base);
	// 828EA9F0: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EA9F4: C00F00AC  lfs f0, 0xac(r15)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(172 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828EA9F8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828EA9FC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828EAA00: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 828EAA04: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828EAA08: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828EAA0C: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828EAA10: 93E100D0  stw r31, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 828EAA14: 4BFFF43D  bl 0x828e9e50
	ctx.lr = 0x828EAA18;
	sub_828E9E50(ctx, base);
	// 828EAA18: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 828EAA1C: C02F00B4  lfs f1, 0xb4(r15)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(180 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EAA20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EAA24: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EAA28: 4BEFFD89  bl 0x827ea7b0
	ctx.lr = 0x828EAA2C;
	sub_827EA7B0(ctx, base);
	// 828EAA2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EAA30: 485089F9  bl 0x82df3428
	ctx.lr = 0x828EAA34;
	sub_82DF3428(ctx, base);
	// 828EAA34: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EAA38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EAA3C: 809CF49C  lwz r4, -0xb64(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-2916 as u32) ) } as u64;
	// 828EAA40: 396B7528  addi r11, r11, 0x7528
	ctx.r[11].s64 = ctx.r[11].s64 + 29992;
	// 828EAA44: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EAA48: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EAA4C: 48508FBD  bl 0x82df3a08
	ctx.lr = 0x828EAA50;
	sub_82DF3A08(ctx, base);
	// 828EAA50: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EAA54: C00F00B0  lfs f0, 0xb0(r15)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828EAA58: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828EAA5C: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828EAA60: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 828EAA64: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828EAA68: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828EAA6C: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828EAA70: 93E100D0  stw r31, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 828EAA74: 4BFFF3DD  bl 0x828e9e50
	ctx.lr = 0x828EAA78;
	sub_828E9E50(ctx, base);
	// 828EAA78: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 828EAA7C: C02F00B8  lfs f1, 0xb8(r15)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EAA80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EAA84: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EAA88: 4BEFFD29  bl 0x827ea7b0
	ctx.lr = 0x828EAA8C;
	sub_827EA7B0(ctx, base);
	// 828EAA8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EAA90: 48508999  bl 0x82df3428
	ctx.lr = 0x828EAA94;
	sub_82DF3428(ctx, base);
	// 828EAA94: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EAA98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EAA9C: 816B01B0  lwz r11, 0x1b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(432 as u32) ) } as u64;
	// 828EAAA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EAAA4: 4E800421  bctrl
	ctx.lr = 0x828EAAA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EAAA8: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EAAAC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828EAAB0: 8090A020  lwz r4, -0x5fe0(r16)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(-24544 as u32) ) } as u64;
	// 828EAAB4: 396B7528  addi r11, r11, 0x7528
	ctx.r[11].s64 = ctx.r[11].s64 + 29992;
	// 828EAAB8: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EAABC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EAAC0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EAAC4: 48508F45  bl 0x82df3a08
	ctx.lr = 0x828EAAC8;
	sub_82DF3A08(ctx, base);
	// 828EAAC8: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EAACC: C01C0204  lfs f0, 0x204(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828EAAD0: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828EAAD4: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828EAAD8: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828EAADC: 93E100D0  stw r31, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 828EAAE0: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828EAAE4: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 828EAAE8: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828EAAEC: 4BFFF365  bl 0x828e9e50
	ctx.lr = 0x828EAAF0;
	sub_828E9E50(ctx, base);
	// 828EAAF0: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 828EAAF4: C03C020C  lfs f1, 0x20c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(524 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EAAF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EAAFC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EAB00: 4BEFFCB1  bl 0x827ea7b0
	ctx.lr = 0x828EAB04;
	sub_827EA7B0(ctx, base);
	// 828EAB04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EAB08: 48508921  bl 0x82df3428
	ctx.lr = 0x828EAB0C;
	sub_82DF3428(ctx, base);
	// 828EAB0C: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EAB10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EAB14: 8090A020  lwz r4, -0x5fe0(r16)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(-24544 as u32) ) } as u64;
	// 828EAB18: 396B7528  addi r11, r11, 0x7528
	ctx.r[11].s64 = ctx.r[11].s64 + 29992;
	// 828EAB1C: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EAB20: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EAB24: 48508EE5  bl 0x82df3a08
	ctx.lr = 0x828EAB28;
	sub_82DF3A08(ctx, base);
	// 828EAB28: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EAB2C: C01C0208  lfs f0, 0x208(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828EAB30: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828EAB34: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828EAB38: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 828EAB3C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828EAB40: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828EAB44: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828EAB48: 93E100D0  stw r31, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 828EAB4C: 4BFFF305  bl 0x828e9e50
	ctx.lr = 0x828EAB50;
	sub_828E9E50(ctx, base);
	// 828EAB50: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 828EAB54: C03C0210  lfs f1, 0x210(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(528 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EAB58: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EAB5C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EAB60: 4BEFFC51  bl 0x827ea7b0
	ctx.lr = 0x828EAB64;
	sub_827EA7B0(ctx, base);
	// 828EAB64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EAB68: 485088C1  bl 0x82df3428
	ctx.lr = 0x828EAB6C;
	sub_82DF3428(ctx, base);
	// 828EAB6C: 8090A020  lwz r4, -0x5fe0(r16)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(-24544 as u32) ) } as u64;
	// 828EAB70: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EAB74: 396B4080  addi r11, r11, 0x4080
	ctx.r[11].s64 = ctx.r[11].s64 + 16512;
	// 828EAB78: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EAB7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EAB80: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EAB84: 48508E85  bl 0x82df3a08
	ctx.lr = 0x828EAB88;
	sub_82DF3A08(ctx, base);
	// 828EAB88: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828EAB8C: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828EAB90: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 828EAB94: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EAB98: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828EAB9C: 93E100D0  stw r31, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 828EABA0: 4BFFF331  bl 0x828e9ed0
	ctx.lr = 0x828EABA4;
	sub_828E9ED0(ctx, base);
	// 828EABA4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828EABA8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EABAC: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 828EABB0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EABB4: C02B9D1C  lfs f1, -0x62e4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25316 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EABB8: 4BEFFBF9  bl 0x827ea7b0
	ctx.lr = 0x828EABBC;
	sub_827EA7B0(ctx, base);
	// 828EABBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EABC0: 48508869  bl 0x82df3428
	ctx.lr = 0x828EABC4;
	sub_82DF3428(ctx, base);
	// 828EABC4: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EABC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EABCC: 809AA028  lwz r4, -0x5fd8(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-24536 as u32) ) } as u64;
	// 828EABD0: 396B5808  addi r11, r11, 0x5808
	ctx.r[11].s64 = ctx.r[11].s64 + 22536;
	// 828EABD4: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EABD8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EABDC: 48508E2D  bl 0x82df3a08
	ctx.lr = 0x828EABE0;
	sub_82DF3A08(ctx, base);
	// 828EABE0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828EABE4: 93A100D8  stw r29, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[29].u32 ) };
	// 828EABE8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828EABEC: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EABF0: 99610078  stb r11, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u8 ) };
	// 828EABF4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828EABF8: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828EABFC: 914100DC  stw r10, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[10].u32 ) };
	// 828EAC00: 916100E0  stw r11, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 828EAC04: E8C100E0  ld r6, 0xe0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	// 828EAC08: E8A100D8  ld r5, 0xd8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 828EAC0C: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 828EAC10: 4BFFF341  bl 0x828e9f50
	ctx.lr = 0x828EAC14;
	sub_828E9F50(ctx, base);
	// 828EAC14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828EAC18: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EAC1C: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 828EAC20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EAC24: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828EAC28: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828EAC2C: 4BEFFB85  bl 0x827ea7b0
	ctx.lr = 0x828EAC30;
	sub_827EA7B0(ctx, base);
	// 828EAC30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EAC34: 485087F5  bl 0x82df3428
	ctx.lr = 0x828EAC38;
	sub_82DF3428(ctx, base);
	// 828EAC38: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EAC3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EAC40: 809AA028  lwz r4, -0x5fd8(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-24536 as u32) ) } as u64;
	// 828EAC44: 396B5808  addi r11, r11, 0x5808
	ctx.r[11].s64 = ctx.r[11].s64 + 22536;
	// 828EAC48: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EAC4C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EAC50: 48508DB9  bl 0x82df3a08
	ctx.lr = 0x828EAC54;
	sub_82DF3A08(ctx, base);
	// 828EAC54: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828EAC58: 93A100D8  stw r29, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[29].u32 ) };
	// 828EAC5C: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828EAC60: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EAC64: 99610078  stb r11, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u8 ) };
	// 828EAC68: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828EAC6C: 914100DC  stw r10, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[10].u32 ) };
	// 828EAC70: E8A100D8  ld r5, 0xd8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 828EAC74: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 828EAC78: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828EAC7C: 916100E0  stw r11, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 828EAC80: E8C100E0  ld r6, 0xe0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	// 828EAC84: 4BFFF2CD  bl 0x828e9f50
	ctx.lr = 0x828EAC88;
	sub_828E9F50(ctx, base);
	// 828EAC88: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828EAC8C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EAC90: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 828EAC94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EAC98: C02B8354  lfs f1, -0x7cac(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31916 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EAC9C: 4BEFFB15  bl 0x827ea7b0
	ctx.lr = 0x828EACA0;
	sub_827EA7B0(ctx, base);
	// 828EACA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EACA4: 48508785  bl 0x82df3428
	ctx.lr = 0x828EACA8;
	sub_82DF3428(ctx, base);
	// 828EACA8: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EACAC: 809AA028  lwz r4, -0x5fd8(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-24536 as u32) ) } as u64;
	// 828EACB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EACB4: 396B4080  addi r11, r11, 0x4080
	ctx.r[11].s64 = ctx.r[11].s64 + 16512;
	// 828EACB8: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EACBC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EACC0: 48508D49  bl 0x82df3a08
	ctx.lr = 0x828EACC4;
	sub_82DF3A08(ctx, base);
	// 828EACC4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828EACC8: 93610074  stw r27, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 828EACCC: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828EACD0: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EACD4: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828EACD8: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 828EACDC: 4BFFF1F5  bl 0x828e9ed0
	ctx.lr = 0x828EACE0;
	sub_828E9ED0(ctx, base);
	// 828EACE0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828EACE4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EACE8: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 828EACEC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EACF0: C02BE25C  lfs f1, -0x1da4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7588 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EACF4: 4BEFFABD  bl 0x827ea7b0
	ctx.lr = 0x828EACF8;
	sub_827EA7B0(ctx, base);
	// 828EACF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EACFC: 4850872D  bl 0x82df3428
	ctx.lr = 0x828EAD00;
	sub_82DF3428(ctx, base);
	// 828EAD00: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EAD04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EAD08: 8099A02C  lwz r4, -0x5fd4(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-24532 as u32) ) } as u64;
	// 828EAD0C: 396B5808  addi r11, r11, 0x5808
	ctx.r[11].s64 = ctx.r[11].s64 + 22536;
	// 828EAD10: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EAD14: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EAD18: 48508CF1  bl 0x82df3a08
	ctx.lr = 0x828EAD1C;
	sub_82DF3A08(ctx, base);
	// 828EAD1C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828EAD20: 93A100D8  stw r29, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[29].u32 ) };
	// 828EAD24: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828EAD28: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EAD2C: 99610078  stb r11, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u8 ) };
	// 828EAD30: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828EAD34: 914100DC  stw r10, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[10].u32 ) };
	// 828EAD38: E8A100D8  ld r5, 0xd8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 828EAD3C: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 828EAD40: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828EAD44: 916100E0  stw r11, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 828EAD48: E8C100E0  ld r6, 0xe0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	// 828EAD4C: 4BFFF205  bl 0x828e9f50
	ctx.lr = 0x828EAD50;
	sub_828E9F50(ctx, base);
	// 828EAD50: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 828EAD54: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EAD58: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EAD5C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828EAD60: 4BEFFA51  bl 0x827ea7b0
	ctx.lr = 0x828EAD64;
	sub_827EA7B0(ctx, base);
	// 828EAD64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EAD68: 485086C1  bl 0x82df3428
	ctx.lr = 0x828EAD6C;
	sub_82DF3428(ctx, base);
	// 828EAD6C: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EAD70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EAD74: 8099A02C  lwz r4, -0x5fd4(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-24532 as u32) ) } as u64;
	// 828EAD78: 396B5808  addi r11, r11, 0x5808
	ctx.r[11].s64 = ctx.r[11].s64 + 22536;
	// 828EAD7C: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EAD80: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EAD84: 48508C85  bl 0x82df3a08
	ctx.lr = 0x828EAD88;
	sub_82DF3A08(ctx, base);
	// 828EAD88: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828EAD8C: 93A100D8  stw r29, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[29].u32 ) };
	// 828EAD90: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828EAD94: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EAD98: 99610078  stb r11, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u8 ) };
	// 828EAD9C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828EADA0: 914100DC  stw r10, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[10].u32 ) };
	// 828EADA4: E8A100D8  ld r5, 0xd8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 828EADA8: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 828EADAC: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828EADB0: 916100E0  stw r11, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 828EADB4: E8C100E0  ld r6, 0xe0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	// 828EADB8: 4BFFF199  bl 0x828e9f50
	ctx.lr = 0x828EADBC;
	sub_828E9F50(ctx, base);
	// 828EADBC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828EADC0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EADC4: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 828EADC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EADCC: C02B0A9C  lfs f1, 0xa9c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2716 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EADD0: 4BEFF9E1  bl 0x827ea7b0
	ctx.lr = 0x828EADD4;
	sub_827EA7B0(ctx, base);
	// 828EADD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EADD8: 48508651  bl 0x82df3428
	ctx.lr = 0x828EADDC;
	sub_82DF3428(ctx, base);
	// 828EADDC: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EADE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EADE4: 8099A02C  lwz r4, -0x5fd4(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-24532 as u32) ) } as u64;
	// 828EADE8: 396B4080  addi r11, r11, 0x4080
	ctx.r[11].s64 = ctx.r[11].s64 + 16512;
	// 828EADEC: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EADF0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EADF4: 48508C15  bl 0x82df3a08
	ctx.lr = 0x828EADF8;
	sub_82DF3A08(ctx, base);
	// 828EADF8: 93610074  stw r27, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 828EADFC: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828EAE00: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828EAE04: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EAE08: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 828EAE0C: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828EAE10: 4BFFF0C1  bl 0x828e9ed0
	ctx.lr = 0x828EAE14;
	sub_828E9ED0(ctx, base);
	// 828EAE14: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EAE18: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EAE1C: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 828EAE20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EAE24: C02B1F44  lfs f1, 0x1f44(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8004 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EAE28: 4BEFF989  bl 0x827ea7b0
	ctx.lr = 0x828EAE2C;
	sub_827EA7B0(ctx, base);
	// 828EAE2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EAE30: 485085F9  bl 0x82df3428
	ctx.lr = 0x828EAE34;
	sub_82DF3428(ctx, base);
	// 828EAE34: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EAE38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EAE3C: 8097A030  lwz r4, -0x5fd0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-24528 as u32) ) } as u64;
	// 828EAE40: 396B5808  addi r11, r11, 0x5808
	ctx.r[11].s64 = ctx.r[11].s64 + 22536;
	// 828EAE44: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EAE48: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EAE4C: 48508BBD  bl 0x82df3a08
	ctx.lr = 0x828EAE50;
	sub_82DF3A08(ctx, base);
	// 828EAE50: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828EAE54: 93A100D8  stw r29, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[29].u32 ) };
	// 828EAE58: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828EAE5C: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EAE60: 99610078  stb r11, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u8 ) };
	// 828EAE64: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828EAE68: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828EAE6C: 914100DC  stw r10, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[10].u32 ) };
	// 828EAE70: 916100E0  stw r11, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 828EAE74: E8A100D8  ld r5, 0xd8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 828EAE78: E8C100E0  ld r6, 0xe0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	// 828EAE7C: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 828EAE80: 4BFFF0D1  bl 0x828e9f50
	ctx.lr = 0x828EAE84;
	sub_828E9F50(ctx, base);
	// 828EAE84: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 828EAE88: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EAE8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EAE90: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828EAE94: 4BEFF91D  bl 0x827ea7b0
	ctx.lr = 0x828EAE98;
	sub_827EA7B0(ctx, base);
	// 828EAE98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EAE9C: 4850858D  bl 0x82df3428
	ctx.lr = 0x828EAEA0;
	sub_82DF3428(ctx, base);
	// 828EAEA0: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EAEA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EAEA8: 8097A030  lwz r4, -0x5fd0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-24528 as u32) ) } as u64;
	// 828EAEAC: 396B5808  addi r11, r11, 0x5808
	ctx.r[11].s64 = ctx.r[11].s64 + 22536;
	// 828EAEB0: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EAEB4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EAEB8: 48508B51  bl 0x82df3a08
	ctx.lr = 0x828EAEBC;
	sub_82DF3A08(ctx, base);
	// 828EAEBC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828EAEC0: 93A100D8  stw r29, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[29].u32 ) };
	// 828EAEC4: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828EAEC8: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EAECC: 99610078  stb r11, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u8 ) };
	// 828EAED0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828EAED4: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828EAED8: 916100E0  stw r11, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 828EAEDC: 914100DC  stw r10, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[10].u32 ) };
	// 828EAEE0: E8A100D8  ld r5, 0xd8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 828EAEE4: E8C100E0  ld r6, 0xe0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	// 828EAEE8: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 828EAEEC: 4BFFF065  bl 0x828e9f50
	ctx.lr = 0x828EAEF0;
	sub_828E9F50(ctx, base);
	// 828EAEF0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828EAEF4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EAEF8: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 828EAEFC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EAF00: C02BB6D8  lfs f1, -0x4928(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18728 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EAF04: 4BEFF8AD  bl 0x827ea7b0
	ctx.lr = 0x828EAF08;
	sub_827EA7B0(ctx, base);
	// 828EAF08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EAF0C: 4850851D  bl 0x82df3428
	ctx.lr = 0x828EAF10;
	sub_82DF3428(ctx, base);
	// 828EAF10: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EAF14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EAF18: 8097A030  lwz r4, -0x5fd0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-24528 as u32) ) } as u64;
	// 828EAF1C: 396B4080  addi r11, r11, 0x4080
	ctx.r[11].s64 = ctx.r[11].s64 + 16512;
	// 828EAF20: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EAF24: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EAF28: 48508AE1  bl 0x82df3a08
	ctx.lr = 0x828EAF2C;
	sub_82DF3A08(ctx, base);
	// 828EAF2C: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EAF30: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828EAF34: 93610074  stw r27, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 828EAF38: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828EAF3C: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 828EAF40: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828EAF44: 4BFFEF8D  bl 0x828e9ed0
	ctx.lr = 0x828EAF48;
	sub_828E9ED0(ctx, base);
	// 828EAF48: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828EAF4C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EAF50: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 828EAF54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EAF58: C02B336C  lfs f1, 0x336c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13164 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EAF5C: 4BEFF855  bl 0x827ea7b0
	ctx.lr = 0x828EAF60;
	sub_827EA7B0(ctx, base);
	// 828EAF60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EAF64: 485084C5  bl 0x82df3428
	ctx.lr = 0x828EAF68;
	sub_82DF3428(ctx, base);
	// 828EAF68: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EAF6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EAF70: 8091A034  lwz r4, -0x5fcc(r17)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(-24524 as u32) ) } as u64;
	// 828EAF74: 396B5808  addi r11, r11, 0x5808
	ctx.r[11].s64 = ctx.r[11].s64 + 22536;
	// 828EAF78: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EAF7C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EAF80: 48508A89  bl 0x82df3a08
	ctx.lr = 0x828EAF84;
	sub_82DF3A08(ctx, base);
	// 828EAF84: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828EAF88: 93A100D8  stw r29, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[29].u32 ) };
	// 828EAF8C: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828EAF90: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EAF94: 99610078  stb r11, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u8 ) };
	// 828EAF98: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828EAF9C: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828EAFA0: 914100DC  stw r10, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[10].u32 ) };
	// 828EAFA4: 916100E0  stw r11, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 828EAFA8: E8A100D8  ld r5, 0xd8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 828EAFAC: E8C100E0  ld r6, 0xe0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	// 828EAFB0: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 828EAFB4: 4BFFEF9D  bl 0x828e9f50
	ctx.lr = 0x828EAFB8;
	sub_828E9F50(ctx, base);
	// 828EAFB8: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 828EAFBC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EAFC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EAFC4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828EAFC8: 4BEFF7E9  bl 0x827ea7b0
	ctx.lr = 0x828EAFCC;
	sub_827EA7B0(ctx, base);
	// 828EAFCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EAFD0: 48508459  bl 0x82df3428
	ctx.lr = 0x828EAFD4;
	sub_82DF3428(ctx, base);
	// 828EAFD4: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EAFD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EAFDC: 8091A034  lwz r4, -0x5fcc(r17)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(-24524 as u32) ) } as u64;
	// 828EAFE0: 396B5808  addi r11, r11, 0x5808
	ctx.r[11].s64 = ctx.r[11].s64 + 22536;
	// 828EAFE4: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EAFE8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EAFEC: 48508A1D  bl 0x82df3a08
	ctx.lr = 0x828EAFF0;
	sub_82DF3A08(ctx, base);
	// 828EAFF0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828EAFF4: 93A100D8  stw r29, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[29].u32 ) };
	// 828EAFF8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828EAFFC: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EB000: 99610078  stb r11, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u8 ) };
	// 828EB004: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828EB008: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828EB00C: 914100DC  stw r10, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[10].u32 ) };
	// 828EB010: 916100E0  stw r11, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 828EB014: E8A100D8  ld r5, 0xd8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 828EB018: E8C100E0  ld r6, 0xe0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	// 828EB01C: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 828EB020: 4BFFEF31  bl 0x828e9f50
	ctx.lr = 0x828EB024;
	sub_828E9F50(ctx, base);
	// 828EB024: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EB028: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB02C: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 828EB030: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB034: C02B1F40  lfs f1, 0x1f40(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8000 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EB038: 4BEFF779  bl 0x827ea7b0
	ctx.lr = 0x828EB03C;
	sub_827EA7B0(ctx, base);
	// 828EB03C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB040: 485083E9  bl 0x82df3428
	ctx.lr = 0x828EB044;
	sub_82DF3428(ctx, base);
	// 828EB044: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EB048: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB04C: 8091A034  lwz r4, -0x5fcc(r17)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(-24524 as u32) ) } as u64;
	// 828EB050: 396B4080  addi r11, r11, 0x4080
	ctx.r[11].s64 = ctx.r[11].s64 + 16512;
	// 828EB054: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EB058: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EB05C: 485089AD  bl 0x82df3a08
	ctx.lr = 0x828EB060;
	sub_82DF3A08(ctx, base);
	// 828EB060: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828EB064: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828EB068: 93610074  stw r27, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 828EB06C: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EB070: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 828EB074: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828EB078: 4BFFEE59  bl 0x828e9ed0
	ctx.lr = 0x828EB07C;
	sub_828E9ED0(ctx, base);
	// 828EB07C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB080: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828EB084: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 828EB088: C02B08AC  lfs f1, 0x8ac(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2220 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EB08C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB090: 4BEFF721  bl 0x827ea7b0
	ctx.lr = 0x828EB094;
	sub_827EA7B0(ctx, base);
	// 828EB094: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB098: 48508391  bl 0x82df3428
	ctx.lr = 0x828EB09C;
	sub_82DF3428(ctx, base);
	// 828EB09C: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EB0A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB0A4: 8098A038  lwz r4, -0x5fc8(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-24520 as u32) ) } as u64;
	// 828EB0A8: 396B5808  addi r11, r11, 0x5808
	ctx.r[11].s64 = ctx.r[11].s64 + 22536;
	// 828EB0AC: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EB0B0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EB0B4: 48508955  bl 0x82df3a08
	ctx.lr = 0x828EB0B8;
	sub_82DF3A08(ctx, base);
	// 828EB0B8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828EB0BC: 93A100D8  stw r29, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[29].u32 ) };
	// 828EB0C0: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828EB0C4: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EB0C8: 99610078  stb r11, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u8 ) };
	// 828EB0CC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828EB0D0: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828EB0D4: 914100DC  stw r10, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[10].u32 ) };
	// 828EB0D8: 916100E0  stw r11, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 828EB0DC: E8A100D8  ld r5, 0xd8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 828EB0E0: E8C100E0  ld r6, 0xe0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	// 828EB0E4: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 828EB0E8: 4BFFEE69  bl 0x828e9f50
	ctx.lr = 0x828EB0EC;
	sub_828E9F50(ctx, base);
	// 828EB0EC: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 828EB0F0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB0F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB0F8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828EB0FC: 4BEFF6B5  bl 0x827ea7b0
	ctx.lr = 0x828EB100;
	sub_827EA7B0(ctx, base);
	// 828EB100: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB104: 48508325  bl 0x82df3428
	ctx.lr = 0x828EB108;
	sub_82DF3428(ctx, base);
	// 828EB108: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EB10C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB110: 8098A038  lwz r4, -0x5fc8(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-24520 as u32) ) } as u64;
	// 828EB114: 396B5808  addi r11, r11, 0x5808
	ctx.r[11].s64 = ctx.r[11].s64 + 22536;
	// 828EB118: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EB11C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EB120: 485088E9  bl 0x82df3a08
	ctx.lr = 0x828EB124;
	sub_82DF3A08(ctx, base);
	// 828EB124: 93A100D8  stw r29, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[29].u32 ) };
	// 828EB128: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828EB12C: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828EB130: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EB134: 99610078  stb r11, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u8 ) };
	// 828EB138: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828EB13C: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 828EB140: 914100DC  stw r10, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[10].u32 ) };
	// 828EB144: 916100E0  stw r11, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 828EB148: E8C100E0  ld r6, 0xe0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	// 828EB14C: E8A100D8  ld r5, 0xd8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 828EB150: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 828EB154: 4BFFEDFD  bl 0x828e9f50
	ctx.lr = 0x828EB158;
	sub_828E9F50(ctx, base);
	// 828EB158: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EB15C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB160: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 828EB164: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB168: C02B9FF4  lfs f1, -0x600c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24588 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EB16C: 4BEFF645  bl 0x827ea7b0
	ctx.lr = 0x828EB170;
	sub_827EA7B0(ctx, base);
	// 828EB170: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB174: 485082B5  bl 0x82df3428
	ctx.lr = 0x828EB178;
	sub_82DF3428(ctx, base);
	// 828EB178: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EB17C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB180: 8098A038  lwz r4, -0x5fc8(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-24520 as u32) ) } as u64;
	// 828EB184: 396B4080  addi r11, r11, 0x4080
	ctx.r[11].s64 = ctx.r[11].s64 + 16512;
	// 828EB188: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EB18C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EB190: 48508879  bl 0x82df3a08
	ctx.lr = 0x828EB194;
	sub_82DF3A08(ctx, base);
	// 828EB194: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828EB198: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828EB19C: 93610074  stw r27, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 828EB1A0: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EB1A4: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 828EB1A8: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828EB1AC: 4BFFED25  bl 0x828e9ed0
	ctx.lr = 0x828EB1B0;
	sub_828E9ED0(ctx, base);
	// 828EB1B0: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 828EB1B4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB1B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB1BC: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828EB1C0: 4BEFF5F1  bl 0x827ea7b0
	ctx.lr = 0x828EB1C4;
	sub_827EA7B0(ctx, base);
	// 828EB1C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB1C8: 48508261  bl 0x82df3428
	ctx.lr = 0x828EB1CC;
	sub_82DF3428(ctx, base);
	// 828EB1CC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EB1D0: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828EB1D4: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EB1D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB1DC: 394A4080  addi r10, r10, 0x4080
	ctx.r[10].s64 = ctx.r[10].s64 + 16512;
	// 828EB1E0: 808BA05C  lwz r4, -0x5fa4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24484 as u32) ) } as u64;
	// 828EB1E4: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828EB1E8: 48508821  bl 0x82df3a08
	ctx.lr = 0x828EB1EC;
	sub_82DF3A08(ctx, base);
	// 828EB1EC: 3B800002  li r28, 2
	ctx.r[28].s64 = 2;
	// 828EB1F0: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828EB1F4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828EB1F8: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EB1FC: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 828EB200: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828EB204: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 828EB208: 4BFFECC9  bl 0x828e9ed0
	ctx.lr = 0x828EB20C;
	sub_828E9ED0(ctx, base);
	// 828EB20C: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 828EB210: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB214: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB218: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828EB21C: 4BEFF595  bl 0x827ea7b0
	ctx.lr = 0x828EB220;
	sub_827EA7B0(ctx, base);
	// 828EB220: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB224: 48508205  bl 0x82df3428
	ctx.lr = 0x828EB228;
	sub_82DF3428(ctx, base);
	// 828EB228: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828EB22C: 3D60828E  lis r11, -0x7d72
	ctx.r[11].s64 = -2104623104;
	// 828EB230: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EB234: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB238: 396B4080  addi r11, r11, 0x4080
	ctx.r[11].s64 = ctx.r[11].s64 + 16512;
	// 828EB23C: 808AA060  lwz r4, -0x5fa0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24480 as u32) ) } as u64;
	// 828EB240: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828EB244: 485087C5  bl 0x82df3a08
	ctx.lr = 0x828EB248;
	sub_82DF3A08(ctx, base);
	// 828EB248: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828EB24C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828EB250: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 828EB254: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EB258: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 828EB25C: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828EB260: 4BFFEC71  bl 0x828e9ed0
	ctx.lr = 0x828EB264;
	sub_828E9ED0(ctx, base);
	// 828EB264: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 828EB268: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB26C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB270: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828EB274: 4BEFF53D  bl 0x827ea7b0
	ctx.lr = 0x828EB278;
	sub_827EA7B0(ctx, base);
	// 828EB278: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB27C: 485081AD  bl 0x82df3428
	ctx.lr = 0x828EB280;
	sub_82DF3428(ctx, base);
	// 828EB280: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EB284: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828EB288: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EB28C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB290: 394A4080  addi r10, r10, 0x4080
	ctx.r[10].s64 = ctx.r[10].s64 + 16512;
	// 828EB294: 808BA064  lwz r4, -0x5f9c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24476 as u32) ) } as u64;
	// 828EB298: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828EB29C: 4850876D  bl 0x82df3a08
	ctx.lr = 0x828EB2A0;
	sub_82DF3A08(ctx, base);
	// 828EB2A0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828EB2A4: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828EB2A8: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 828EB2AC: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EB2B0: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828EB2B4: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 828EB2B8: 4BFFEC19  bl 0x828e9ed0
	ctx.lr = 0x828EB2BC;
	sub_828E9ED0(ctx, base);
	// 828EB2BC: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 828EB2C0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB2C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB2C8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828EB2CC: 4BEFF4E5  bl 0x827ea7b0
	ctx.lr = 0x828EB2D0;
	sub_827EA7B0(ctx, base);
	// 828EB2D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB2D4: 48508155  bl 0x82df3428
	ctx.lr = 0x828EB2D8;
	sub_82DF3428(ctx, base);
	// 828EB2D8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EB2DC: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828EB2E0: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EB2E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB2E8: 394A4080  addi r10, r10, 0x4080
	ctx.r[10].s64 = ctx.r[10].s64 + 16512;
	// 828EB2EC: 808BA068  lwz r4, -0x5f98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24472 as u32) ) } as u64;
	// 828EB2F0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828EB2F4: 48508715  bl 0x82df3a08
	ctx.lr = 0x828EB2F8;
	sub_82DF3A08(ctx, base);
	// 828EB2F8: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 828EB2FC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828EB300: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828EB304: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EB308: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828EB30C: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 828EB310: 4BFFEBC1  bl 0x828e9ed0
	ctx.lr = 0x828EB314;
	sub_828E9ED0(ctx, base);
	// 828EB314: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 828EB318: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB31C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB320: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828EB324: 4BEFF48D  bl 0x827ea7b0
	ctx.lr = 0x828EB328;
	sub_827EA7B0(ctx, base);
	// 828EB328: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB32C: 485080FD  bl 0x82df3428
	ctx.lr = 0x828EB330;
	sub_82DF3428(ctx, base);
	// 828EB330: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EB334: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828EB338: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EB33C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB340: 394A4080  addi r10, r10, 0x4080
	ctx.r[10].s64 = ctx.r[10].s64 + 16512;
	// 828EB344: 808BA06C  lwz r4, -0x5f94(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24468 as u32) ) } as u64;
	// 828EB348: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828EB34C: 485086BD  bl 0x82df3a08
	ctx.lr = 0x828EB350;
	sub_82DF3A08(ctx, base);
	// 828EB350: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828EB354: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828EB358: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 828EB35C: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EB360: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828EB364: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 828EB368: 4BFFEB69  bl 0x828e9ed0
	ctx.lr = 0x828EB36C;
	sub_828E9ED0(ctx, base);
	// 828EB36C: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 828EB370: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB374: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB378: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828EB37C: 4BEFF435  bl 0x827ea7b0
	ctx.lr = 0x828EB380;
	sub_827EA7B0(ctx, base);
	// 828EB380: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB384: 485080A5  bl 0x82df3428
	ctx.lr = 0x828EB388;
	sub_82DF3428(ctx, base);
	// 828EB388: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EB38C: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828EB390: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EB394: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB398: 394A4080  addi r10, r10, 0x4080
	ctx.r[10].s64 = ctx.r[10].s64 + 16512;
	// 828EB39C: 808BA070  lwz r4, -0x5f90(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24464 as u32) ) } as u64;
	// 828EB3A0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828EB3A4: 48508665  bl 0x82df3a08
	ctx.lr = 0x828EB3A8;
	sub_82DF3A08(ctx, base);
	// 828EB3A8: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828EB3AC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828EB3B0: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 828EB3B4: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EB3B8: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 828EB3BC: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828EB3C0: 4BFFEB11  bl 0x828e9ed0
	ctx.lr = 0x828EB3C4;
	sub_828E9ED0(ctx, base);
	// 828EB3C4: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 828EB3C8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB3CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB3D0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828EB3D4: 4BEFF3DD  bl 0x827ea7b0
	ctx.lr = 0x828EB3D8;
	sub_827EA7B0(ctx, base);
	// 828EB3D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB3DC: 4850804D  bl 0x82df3428
	ctx.lr = 0x828EB3E0;
	sub_82DF3428(ctx, base);
	// 828EB3E0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EB3E4: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828EB3E8: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EB3EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB3F0: 394A4080  addi r10, r10, 0x4080
	ctx.r[10].s64 = ctx.r[10].s64 + 16512;
	// 828EB3F4: 808BA074  lwz r4, -0x5f8c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24460 as u32) ) } as u64;
	// 828EB3F8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828EB3FC: 4850860D  bl 0x82df3a08
	ctx.lr = 0x828EB400;
	sub_82DF3A08(ctx, base);
	// 828EB400: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828EB404: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 828EB408: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828EB40C: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EB410: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828EB414: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 828EB418: 4BFFEAB9  bl 0x828e9ed0
	ctx.lr = 0x828EB41C;
	sub_828E9ED0(ctx, base);
	// 828EB41C: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 828EB420: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB424: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB428: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828EB42C: 4BEFF385  bl 0x827ea7b0
	ctx.lr = 0x828EB430;
	sub_827EA7B0(ctx, base);
	// 828EB430: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB434: 48507FF5  bl 0x82df3428
	ctx.lr = 0x828EB438;
	sub_82DF3428(ctx, base);
	// 828EB438: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EB43C: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 828EB440: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EB444: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB448: 394A4080  addi r10, r10, 0x4080
	ctx.r[10].s64 = ctx.r[10].s64 + 16512;
	// 828EB44C: 808BA078  lwz r4, -0x5f88(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24456 as u32) ) } as u64;
	// 828EB450: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828EB454: 485085B5  bl 0x82df3a08
	ctx.lr = 0x828EB458;
	sub_82DF3A08(ctx, base);
	// 828EB458: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 828EB45C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828EB460: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 828EB464: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828EB468: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 828EB46C: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828EB470: 4BFFEA61  bl 0x828e9ed0
	ctx.lr = 0x828EB474;
	sub_828E9ED0(ctx, base);
	// 828EB474: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 828EB478: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB47C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB480: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828EB484: 4BEFF32D  bl 0x827ea7b0
	ctx.lr = 0x828EB488;
	sub_827EA7B0(ctx, base);
	// 828EB488: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB48C: 48507F9D  bl 0x82df3428
	ctx.lr = 0x828EB490;
	sub_82DF3428(ctx, base);
	// 828EB490: 3F80832D  lis r28, -0x7cd3
	ctx.r[28].s64 = -2094202880;
	// 828EB494: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EB498: 809CF3F8  lwz r4, -0xc08(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-3080 as u32) ) } as u64;
	// 828EB49C: 4850856D  bl 0x82df3a08
	ctx.lr = 0x828EB4A0;
	sub_82DF3A08(ctx, base);
	// 828EB4A0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EB4A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB4A8: 808BF420  lwz r4, -0xbe0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3040 as u32) ) } as u64;
	// 828EB4AC: 4850855D  bl 0x82df3a08
	ctx.lr = 0x828EB4B0;
	sub_82DF3A08(ctx, base);
	// 828EB4B0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828EB4B4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB4B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB4BC: 4BEFEE65  bl 0x827ea320
	ctx.lr = 0x828EB4C0;
	sub_827EA320(ctx, base);
	// 828EB4C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB4C4: 48507F65  bl 0x82df3428
	ctx.lr = 0x828EB4C8;
	sub_82DF3428(ctx, base);
	// 828EB4C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EB4CC: 48507F5D  bl 0x82df3428
	ctx.lr = 0x828EB4D0;
	sub_82DF3428(ctx, base);
	// 828EB4D0: 3DE0832D  lis r15, -0x7cd3
	ctx.r[15].s64 = -2094202880;
	// 828EB4D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EB4D8: 808FF4B4  lwz r4, -0xb4c(r15)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-2892 as u32) ) } as u64;
	// 828EB4DC: 4850852D  bl 0x82df3a08
	ctx.lr = 0x828EB4E0;
	sub_82DF3A08(ctx, base);
	// 828EB4E0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EB4E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB4E8: 808BF4B0  lwz r4, -0xb50(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2896 as u32) ) } as u64;
	// 828EB4EC: 4850851D  bl 0x82df3a08
	ctx.lr = 0x828EB4F0;
	sub_82DF3A08(ctx, base);
	// 828EB4F0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828EB4F4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB4F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB4FC: 4BEFEE25  bl 0x827ea320
	ctx.lr = 0x828EB500;
	sub_827EA320(ctx, base);
	// 828EB500: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB504: 48507F25  bl 0x82df3428
	ctx.lr = 0x828EB508;
	sub_82DF3428(ctx, base);
	// 828EB508: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EB50C: 48507F1D  bl 0x82df3428
	ctx.lr = 0x828EB510;
	sub_82DF3428(ctx, base);
	// 828EB510: 3DC0832D  lis r14, -0x7cd3
	ctx.r[14].s64 = -2094202880;
	// 828EB514: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EB518: 808EF4BC  lwz r4, -0xb44(r14)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(-2884 as u32) ) } as u64;
	// 828EB51C: 485084ED  bl 0x82df3a08
	ctx.lr = 0x828EB520;
	sub_82DF3A08(ctx, base);
	// 828EB520: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EB524: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB528: 808BF4B8  lwz r4, -0xb48(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2888 as u32) ) } as u64;
	// 828EB52C: 485084DD  bl 0x82df3a08
	ctx.lr = 0x828EB530;
	sub_82DF3A08(ctx, base);
	// 828EB530: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828EB534: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB538: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB53C: 4BEFEDE5  bl 0x827ea320
	ctx.lr = 0x828EB540;
	sub_827EA320(ctx, base);
	// 828EB540: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB544: 48507EE5  bl 0x82df3428
	ctx.lr = 0x828EB548;
	sub_82DF3428(ctx, base);
	// 828EB548: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EB54C: 48507EDD  bl 0x82df3428
	ctx.lr = 0x828EB550;
	sub_82DF3428(ctx, base);
	// 828EB550: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EB554: 808FF4B4  lwz r4, -0xb4c(r15)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-2892 as u32) ) } as u64;
	// 828EB558: 485084B1  bl 0x82df3a08
	ctx.lr = 0x828EB55C;
	sub_82DF3A08(ctx, base);
	// 828EB55C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EB560: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB564: 808BF4C0  lwz r4, -0xb40(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2880 as u32) ) } as u64;
	// 828EB568: 485084A1  bl 0x82df3a08
	ctx.lr = 0x828EB56C;
	sub_82DF3A08(ctx, base);
	// 828EB56C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828EB570: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB574: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB578: 4BEFEDA9  bl 0x827ea320
	ctx.lr = 0x828EB57C;
	sub_827EA320(ctx, base);
	// 828EB57C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB580: 48507EA9  bl 0x82df3428
	ctx.lr = 0x828EB584;
	sub_82DF3428(ctx, base);
	// 828EB584: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EB588: 48507EA1  bl 0x82df3428
	ctx.lr = 0x828EB58C;
	sub_82DF3428(ctx, base);
	// 828EB58C: 808EF4BC  lwz r4, -0xb44(r14)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(-2884 as u32) ) } as u64;
	// 828EB590: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EB594: 48508475  bl 0x82df3a08
	ctx.lr = 0x828EB598;
	sub_82DF3A08(ctx, base);
	// 828EB598: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EB59C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB5A0: 808BF4C4  lwz r4, -0xb3c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2876 as u32) ) } as u64;
	// 828EB5A4: 48508465  bl 0x82df3a08
	ctx.lr = 0x828EB5A8;
	sub_82DF3A08(ctx, base);
	// 828EB5A8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828EB5AC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB5B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB5B4: 4BEFED6D  bl 0x827ea320
	ctx.lr = 0x828EB5B8;
	sub_827EA320(ctx, base);
	// 828EB5B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB5BC: 48507E6D  bl 0x82df3428
	ctx.lr = 0x828EB5C0;
	sub_82DF3428(ctx, base);
	// 828EB5C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EB5C4: 48507E65  bl 0x82df3428
	ctx.lr = 0x828EB5C8;
	sub_82DF3428(ctx, base);
	// 828EB5C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB5CC: 809CF3F8  lwz r4, -0xc08(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-3080 as u32) ) } as u64;
	// 828EB5D0: 48508439  bl 0x82df3a08
	ctx.lr = 0x828EB5D4;
	sub_82DF3A08(ctx, base);
	// 828EB5D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828EB5D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB5DC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB5E0: C3CBD5B8  lfs f30, -0x2a48(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828EB5E4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828EB5E8: 4BEFED51  bl 0x827ea338
	ctx.lr = 0x828EB5EC;
	sub_827EA338(ctx, base);
	// 828EB5EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB5F0: 48507E39  bl 0x82df3428
	ctx.lr = 0x828EB5F4;
	sub_82DF3428(ctx, base);
	// 828EB5F4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EB5F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB5FC: 808BF3FC  lwz r4, -0xc04(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3076 as u32) ) } as u64;
	// 828EB600: 48508409  bl 0x82df3a08
	ctx.lr = 0x828EB604;
	sub_82DF3A08(ctx, base);
	// 828EB604: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB608: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB60C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828EB610: 4BEFED29  bl 0x827ea338
	ctx.lr = 0x828EB614;
	sub_827EA338(ctx, base);
	// 828EB614: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB618: 48507E11  bl 0x82df3428
	ctx.lr = 0x828EB61C;
	sub_82DF3428(ctx, base);
	// 828EB61C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EB620: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB624: 808BF400  lwz r4, -0xc00(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3072 as u32) ) } as u64;
	// 828EB628: 485083E1  bl 0x82df3a08
	ctx.lr = 0x828EB62C;
	sub_82DF3A08(ctx, base);
	// 828EB62C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB630: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB634: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828EB638: 4BEFED01  bl 0x827ea338
	ctx.lr = 0x828EB63C;
	sub_827EA338(ctx, base);
	// 828EB63C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB640: 48507DE9  bl 0x82df3428
	ctx.lr = 0x828EB644;
	sub_82DF3428(ctx, base);
	// 828EB644: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EB648: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB64C: 808BF404  lwz r4, -0xbfc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3068 as u32) ) } as u64;
	// 828EB650: 485083B9  bl 0x82df3a08
	ctx.lr = 0x828EB654;
	sub_82DF3A08(ctx, base);
	// 828EB654: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB658: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB65C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828EB660: 4BEFECD9  bl 0x827ea338
	ctx.lr = 0x828EB664;
	sub_827EA338(ctx, base);
	// 828EB664: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB668: 48507DC1  bl 0x82df3428
	ctx.lr = 0x828EB66C;
	sub_82DF3428(ctx, base);
	// 828EB66C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EB670: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB674: 808BF44C  lwz r4, -0xbb4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2996 as u32) ) } as u64;
	// 828EB678: 48508391  bl 0x82df3a08
	ctx.lr = 0x828EB67C;
	sub_82DF3A08(ctx, base);
	// 828EB67C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB680: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB684: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828EB688: 4BEFECB1  bl 0x827ea338
	ctx.lr = 0x828EB68C;
	sub_827EA338(ctx, base);
	// 828EB68C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB690: 48507D99  bl 0x82df3428
	ctx.lr = 0x828EB694;
	sub_82DF3428(ctx, base);
	// 828EB694: 3F80832D  lis r28, -0x7cd3
	ctx.r[28].s64 = -2094202880;
	// 828EB698: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB69C: 809CA054  lwz r4, -0x5fac(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-24492 as u32) ) } as u64;
	// 828EB6A0: 48508369  bl 0x82df3a08
	ctx.lr = 0x828EB6A4;
	sub_82DF3A08(ctx, base);
	// 828EB6A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB6A8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB6AC: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828EB6B0: 4BEFEC89  bl 0x827ea338
	ctx.lr = 0x828EB6B4;
	sub_827EA338(ctx, base);
	// 828EB6B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB6B8: 48507D71  bl 0x82df3428
	ctx.lr = 0x828EB6BC;
	sub_82DF3428(ctx, base);
	// 828EB6BC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EB6C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB6C4: 808BA07C  lwz r4, -0x5f84(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24452 as u32) ) } as u64;
	// 828EB6C8: 48508341  bl 0x82df3a08
	ctx.lr = 0x828EB6CC;
	sub_82DF3A08(ctx, base);
	// 828EB6CC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB6D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB6D4: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828EB6D8: 4BEFEC61  bl 0x827ea338
	ctx.lr = 0x828EB6DC;
	sub_827EA338(ctx, base);
	// 828EB6DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB6E0: 48507D49  bl 0x82df3428
	ctx.lr = 0x828EB6E4;
	sub_82DF3428(ctx, base);
	// 828EB6E4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EB6E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB6EC: 808BA04C  lwz r4, -0x5fb4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24500 as u32) ) } as u64;
	// 828EB6F0: 48508319  bl 0x82df3a08
	ctx.lr = 0x828EB6F4;
	sub_82DF3A08(ctx, base);
	// 828EB6F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB6F8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB6FC: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828EB700: 4BEFEC39  bl 0x827ea338
	ctx.lr = 0x828EB704;
	sub_827EA338(ctx, base);
	// 828EB704: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB708: 48507D21  bl 0x82df3428
	ctx.lr = 0x828EB70C;
	sub_82DF3428(ctx, base);
	// 828EB70C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB710: 8090A020  lwz r4, -0x5fe0(r16)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(-24544 as u32) ) } as u64;
	// 828EB714: 485082F5  bl 0x82df3a08
	ctx.lr = 0x828EB718;
	sub_82DF3A08(ctx, base);
	// 828EB718: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB71C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB720: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828EB724: 4BEFEC15  bl 0x827ea338
	ctx.lr = 0x828EB728;
	sub_827EA338(ctx, base);
	// 828EB728: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB72C: 48507CFD  bl 0x82df3428
	ctx.lr = 0x828EB730;
	sub_82DF3428(ctx, base);
	// 828EB730: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB734: 809AA028  lwz r4, -0x5fd8(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-24536 as u32) ) } as u64;
	// 828EB738: 485082D1  bl 0x82df3a08
	ctx.lr = 0x828EB73C;
	sub_82DF3A08(ctx, base);
	// 828EB73C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB740: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB744: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828EB748: 4BEFEBF1  bl 0x827ea338
	ctx.lr = 0x828EB74C;
	sub_827EA338(ctx, base);
	// 828EB74C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB750: 48507CD9  bl 0x82df3428
	ctx.lr = 0x828EB754;
	sub_82DF3428(ctx, base);
	// 828EB754: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB758: 8099A02C  lwz r4, -0x5fd4(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-24532 as u32) ) } as u64;
	// 828EB75C: 485082AD  bl 0x82df3a08
	ctx.lr = 0x828EB760;
	sub_82DF3A08(ctx, base);
	// 828EB760: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB764: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB768: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828EB76C: 4BEFEBCD  bl 0x827ea338
	ctx.lr = 0x828EB770;
	sub_827EA338(ctx, base);
	// 828EB770: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB774: 48507CB5  bl 0x82df3428
	ctx.lr = 0x828EB778;
	sub_82DF3428(ctx, base);
	// 828EB778: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB77C: 8097A030  lwz r4, -0x5fd0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-24528 as u32) ) } as u64;
	// 828EB780: 48508289  bl 0x82df3a08
	ctx.lr = 0x828EB784;
	sub_82DF3A08(ctx, base);
	// 828EB784: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB788: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB78C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828EB790: 4BEFEBA9  bl 0x827ea338
	ctx.lr = 0x828EB794;
	sub_827EA338(ctx, base);
	// 828EB794: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB798: 48507C91  bl 0x82df3428
	ctx.lr = 0x828EB79C;
	sub_82DF3428(ctx, base);
	// 828EB79C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB7A0: 8091A034  lwz r4, -0x5fcc(r17)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(-24524 as u32) ) } as u64;
	// 828EB7A4: 48508265  bl 0x82df3a08
	ctx.lr = 0x828EB7A8;
	sub_82DF3A08(ctx, base);
	// 828EB7A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB7AC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB7B0: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828EB7B4: 4BEFEB85  bl 0x827ea338
	ctx.lr = 0x828EB7B8;
	sub_827EA338(ctx, base);
	// 828EB7B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB7BC: 48507C6D  bl 0x82df3428
	ctx.lr = 0x828EB7C0;
	sub_82DF3428(ctx, base);
	// 828EB7C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB7C4: 8098A038  lwz r4, -0x5fc8(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-24520 as u32) ) } as u64;
	// 828EB7C8: 48508241  bl 0x82df3a08
	ctx.lr = 0x828EB7CC;
	sub_82DF3A08(ctx, base);
	// 828EB7CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB7D0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB7D4: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828EB7D8: 4BEFEB61  bl 0x827ea338
	ctx.lr = 0x828EB7DC;
	sub_827EA338(ctx, base);
	// 828EB7DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB7E0: 48507C49  bl 0x82df3428
	ctx.lr = 0x828EB7E4;
	sub_82DF3428(ctx, base);
	// 828EB7E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EB7E8: 809CA054  lwz r4, -0x5fac(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-24492 as u32) ) } as u64;
	// 828EB7EC: 4850821D  bl 0x82df3a08
	ctx.lr = 0x828EB7F0;
	sub_82DF3A08(ctx, base);
	// 828EB7F0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828EB7F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB7F8: 388B89B0  addi r4, r11, -0x7650
	ctx.r[4].s64 = ctx.r[11].s64 + -30288;
	// 828EB7FC: 4850820D  bl 0x82df3a08
	ctx.lr = 0x828EB800;
	sub_82DF3A08(ctx, base);
	// 828EB800: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828EB804: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828EB808: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB80C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EB810: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828EB814: 4BEFEB45  bl 0x827ea358
	ctx.lr = 0x828EB818;
	sub_827EA358(ctx, base);
	// 828EB818: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB81C: 48507C0D  bl 0x82df3428
	ctx.lr = 0x828EB820;
	sub_82DF3428(ctx, base);
	// 828EB820: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EB824: 48507C05  bl 0x82df3428
	ctx.lr = 0x828EB828;
	sub_82DF3428(ctx, base);
	// 828EB828: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EB82C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB830: 388B8A1C  addi r4, r11, -0x75e4
	ctx.r[4].s64 = ctx.r[11].s64 + -30180;
	// 828EB834: 485081D5  bl 0x82df3a08
	ctx.lr = 0x828EB838;
	sub_82DF3A08(ctx, base);
	// 828EB838: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828EB83C: 38610198  addi r3, r1, 0x198
	ctx.r[3].s64 = ctx.r[1].s64 + 408;
	// 828EB840: 4BF00D89  bl 0x827ec5c8
	ctx.lr = 0x828EB844;
	sub_827EC5C8(ctx, base);
	// 828EB844: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828EB848: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828EB84C: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 828EB850: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EB854: 485297DD  bl 0x82e15030
	ctx.lr = 0x828EB858;
	sub_82E15030(ctx, base);
	// 828EB858: 8061019C  lwz r3, 0x19c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(412 as u32) ) } as u64;
	// 828EB85C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EB860: 419A0008  beq cr6, 0x828eb868
	if ctx.cr[6].eq {
	pc = 0x828EB868; continue 'dispatch;
	}
	// 828EB864: 4B9D502D  bl 0x822c0890
	ctx.lr = 0x828EB868;
	sub_822C0890(ctx, base);
	// 828EB868: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EB86C: 48507BBD  bl 0x82df3428
	ctx.lr = 0x828EB870;
	sub_82DF3428(ctx, base);
	// 828EB870: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828EB874: 3AE00010  li r23, 0x10
	ctx.r[23].s64 = 16;
	// 828EB878: 3BCB6880  addi r30, r11, 0x6880
	ctx.r[30].s64 = ctx.r[11].s64 + 26752;
	// 828EB87C: 3B000020  li r24, 0x20
	ctx.r[24].s64 = 32;
	// 828EB880: 3B200030  li r25, 0x30
	ctx.r[25].s64 = 48;
	// 828EB884: 81610110  lwz r11, 0x110(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(272 as u32) ) } as u64;
	// 828EB888: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EB88C: 419A015C  beq cr6, 0x828eb9e8
	if ctx.cr[6].eq {
	pc = 0x828EB9E8; continue 'dispatch;
	}
	// 828EB890: 39610270  addi r11, r1, 0x270
	ctx.r[11].s64 = ctx.r[1].s64 + 624;
	// 828EB894: 13E0F407  vcmpneb. (lvlx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828EB898: 39410280  addi r10, r1, 0x280
	ctx.r[10].s64 = ctx.r[1].s64 + 640;
	// 828EB89C: 13D7F407  vcmpneb. (lvlx128) v30, v23, v30
	tmp.u32 = ctx.r[23].u32 + ctx.r[30].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828EB8A0: 39210290  addi r9, r1, 0x290
	ctx.r[9].s64 = ctx.r[1].s64 + 656;
	// 828EB8A4: 13B8F407  vcmpneb. (lvlx128) v29, v24, v30
	tmp.u32 = ctx.r[24].u32 + ctx.r[30].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828EB8A8: 390102A0  addi r8, r1, 0x2a0
	ctx.r[8].s64 = ctx.r[1].s64 + 672;
	// 828EB8AC: 1399F407  vcmpneb. (lvlx128) v28, v25, v30
	tmp.u32 = ctx.r[25].u32 + ctx.r[30].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828EB8B0: 38810270  addi r4, r1, 0x270
	ctx.r[4].s64 = ctx.r[1].s64 + 624;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ED018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ED018 size=84
    let mut pc: u32 = 0x828ED018;
    'dispatch: loop {
        match pc {
            0x828ED018 => {
    //   block [0x828ED018..0x828ED06C)
	// 828ED018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ED01C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ED020: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828ED024: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ED028: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ED02C: 4BFFD22D  bl 0x828ea258
	ctx.lr = 0x828ED030;
	sub_828EA258(ctx, base);
	// 828ED030: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ED034: 4802388D  bl 0x829108c0
	ctx.lr = 0x828ED038;
	sub_829108C0(ctx, base);
	// 828ED038: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828ED03C: 4082001C  bne 0x828ed058
	if !ctx.cr[0].eq {
	pc = 0x828ED058; continue 'dispatch;
	}
	// 828ED040: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828ED044: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ED048: 4BFFA029  bl 0x828e7070
	ctx.lr = 0x828ED04C;
	sub_828E7070(ctx, base);
	// 828ED04C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828ED050: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ED054: 4BFF5D5D  bl 0x828e2db0
	ctx.lr = 0x828ED058;
	sub_828E2DB0(ctx, base);
	// 828ED058: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828ED05C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ED060: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ED064: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828ED068: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ED070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ED070 size=296
    let mut pc: u32 = 0x828ED070;
    'dispatch: loop {
        match pc {
            0x828ED070 => {
    //   block [0x828ED070..0x828ED198)
	// 828ED070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ED074: 488BB0F5  bl 0x831a8168
	ctx.lr = 0x828ED078;
	sub_831A8130(ctx, base);
	// 828ED078: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ED07C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ED080: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 828ED084: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 828ED088: 48023A91  bl 0x82910b18
	ctx.lr = 0x828ED08C;
	sub_82910B18(ctx, base);
	// 828ED08C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828ED090: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828ED094: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 828ED098: 394A11D4  addi r10, r10, 0x11d4
	ctx.r[10].s64 = ctx.r[10].s64 + 4564;
	// 828ED09C: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828ED0A0: 917F0360  stw r11, 0x360(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(864 as u32), ctx.r[11].u32 ) };
	// 828ED0A4: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828ED0A8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828ED0AC: 3CE08209  lis r7, -0x7df7
	ctx.r[7].s64 = -2113339392;
	// 828ED0B0: 396911BC  addi r11, r9, 0x11bc
	ctx.r[11].s64 = ctx.r[9].s64 + 4540;
	// 828ED0B4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828ED0B8: 392811A0  addi r9, r8, 0x11a0
	ctx.r[9].s64 = ctx.r[8].s64 + 4512;
	// 828ED0BC: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 828ED0C0: 39471154  addi r10, r7, 0x1154
	ctx.r[10].s64 = ctx.r[7].s64 + 4436;
	// 828ED0C4: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 828ED0C8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ED0CC: 915F0360  stw r10, 0x360(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(864 as u32), ctx.r[10].u32 ) };
	// 828ED0D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828ED0D4: 93DF0364  stw r30, 0x364(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(868 as u32), ctx.r[30].u32 ) };
	// 828ED0D8: 388B0FF0  addi r4, r11, 0xff0
	ctx.r[4].s64 = ctx.r[11].s64 + 4080;
	// 828ED0DC: 93DF0368  stw r30, 0x368(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(872 as u32), ctx.r[30].u32 ) };
	// 828ED0E0: 38A000D3  li r5, 0xd3
	ctx.r[5].s64 = 211;
	// 828ED0E4: 93DF036C  stw r30, 0x36c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(876 as u32), ctx.r[30].u32 ) };
	// 828ED0E8: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828ED0EC: 93DF0370  stw r30, 0x370(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(880 as u32), ctx.r[30].u32 ) };
	// 828ED0F0: 93DF0374  stw r30, 0x374(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(884 as u32), ctx.r[30].u32 ) };
	// 828ED0F4: 93DF0378  stw r30, 0x378(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(888 as u32), ctx.r[30].u32 ) };
	// 828ED0F8: 93DF037C  stw r30, 0x37c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), ctx.r[30].u32 ) };
	// 828ED0FC: 93DF0380  stw r30, 0x380(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(896 as u32), ctx.r[30].u32 ) };
	// 828ED100: 93DF0384  stw r30, 0x384(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(900 as u32), ctx.r[30].u32 ) };
	// 828ED104: 93DF0388  stw r30, 0x388(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(904 as u32), ctx.r[30].u32 ) };
	// 828ED108: 93DF0390  stw r30, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[30].u32 ) };
	// 828ED10C: 93DF0394  stw r30, 0x394(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), ctx.r[30].u32 ) };
	// 828ED110: 93DF0398  stw r30, 0x398(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), ctx.r[30].u32 ) };
	// 828ED114: 93DF03A0  stw r30, 0x3a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(928 as u32), ctx.r[30].u32 ) };
	// 828ED118: 93DF03A4  stw r30, 0x3a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(932 as u32), ctx.r[30].u32 ) };
	// 828ED11C: 93DF03A8  stw r30, 0x3a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(936 as u32), ctx.r[30].u32 ) };
	// 828ED120: 93DF03AC  stw r30, 0x3ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(940 as u32), ctx.r[30].u32 ) };
	// 828ED124: 93DF03B0  stw r30, 0x3b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(944 as u32), ctx.r[30].u32 ) };
	// 828ED128: 93DF03B4  stw r30, 0x3b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(948 as u32), ctx.r[30].u32 ) };
	// 828ED12C: 93DF03B8  stw r30, 0x3b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(952 as u32), ctx.r[30].u32 ) };
	// 828ED130: 93DF03BC  stw r30, 0x3bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(956 as u32), ctx.r[30].u32 ) };
	// 828ED134: 93DF03C0  stw r30, 0x3c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(960 as u32), ctx.r[30].u32 ) };
	// 828ED138: 93DF03C4  stw r30, 0x3c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(964 as u32), ctx.r[30].u32 ) };
	// 828ED13C: 93DF03C8  stw r30, 0x3c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(968 as u32), ctx.r[30].u32 ) };
	// 828ED140: 93DF03CC  stw r30, 0x3cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(972 as u32), ctx.r[30].u32 ) };
	// 828ED144: 93DF03D0  stw r30, 0x3d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(976 as u32), ctx.r[30].u32 ) };
	// 828ED148: 93DF03D4  stw r30, 0x3d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(980 as u32), ctx.r[30].u32 ) };
	// 828ED14C: 93DF03D8  stw r30, 0x3d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(984 as u32), ctx.r[30].u32 ) };
	// 828ED150: 93DF03E0  stw r30, 0x3e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(992 as u32), ctx.r[30].u32 ) };
	// 828ED154: 93BF03E4  stw r29, 0x3e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(996 as u32), ctx.r[29].u32 ) };
	// 828ED158: 939F03E8  stw r28, 0x3e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1000 as u32), ctx.r[28].u32 ) };
	// 828ED15C: 93DF03EC  stw r30, 0x3ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1004 as u32), ctx.r[30].u32 ) };
	// 828ED160: 93DF03F0  stw r30, 0x3f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1008 as u32), ctx.r[30].u32 ) };
	// 828ED164: 93DF03FC  stw r30, 0x3fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1020 as u32), ctx.r[30].u32 ) };
	// 828ED168: 93DF0400  stw r30, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[30].u32 ) };
	// 828ED16C: 93DF0404  stw r30, 0x404(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1028 as u32), ctx.r[30].u32 ) };
	// 828ED170: 4B9D3269  bl 0x822c03d8
	ctx.lr = 0x828ED174;
	sub_822C03D8(ctx, base);
	// 828ED174: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828ED178: 4182000C  beq 0x828ed184
	if ctx.cr[0].eq {
	pc = 0x828ED184; continue 'dispatch;
	}
	// 828ED17C: 48819B35  bl 0x83106cb0
	ctx.lr = 0x828ED180;
	sub_83106CB0(ctx, base);
	// 828ED180: 48000008  b 0x828ed188
	pc = 0x828ED188; continue 'dispatch;
	// 828ED184: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828ED188: 907F03E0  stw r3, 0x3e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(992 as u32), ctx.r[3].u32 ) };
	// 828ED18C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ED190: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828ED194: 488BB024  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ED198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ED198 size=240
    let mut pc: u32 = 0x828ED198;
    'dispatch: loop {
        match pc {
            0x828ED198 => {
    //   block [0x828ED198..0x828ED288)
	// 828ED198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ED19C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ED1A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828ED1A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828ED1A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ED1AC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828ED1B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ED1B4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828ED1B8: 808B6750  lwz r4, 0x6750(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26448 as u32) ) } as u64;
	// 828ED1BC: 4B9F7D75  bl 0x822e4f30
	ctx.lr = 0x828ED1C0;
	sub_822E4F30(ctx, base);
	// 828ED1C0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828ED1C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828ED1C8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828ED1CC: 808B6874  lwz r4, 0x6874(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26740 as u32) ) } as u64;
	// 828ED1D0: 4B9F7D61  bl 0x822e4f30
	ctx.lr = 0x828ED1D4;
	sub_822E4F30(ctx, base);
	// 828ED1D4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828ED1D8: E89E0000  ld r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828ED1DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828ED1E0: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 828ED1E4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828ED1E8: 4BB9F0A1  bl 0x8248c288
	ctx.lr = 0x828ED1EC;
	sub_8248C288(ctx, base);
	// 828ED1EC: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828ED1F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828ED1F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ED1F8: 4BF37599  bl 0x82824790
	ctx.lr = 0x828ED1FC;
	sub_82824790(ctx, base);
	// 828ED1FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ED200: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828ED204: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ED208: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ED20C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828ED210: 419A0024  beq cr6, 0x828ed234
	if ctx.cr[6].eq {
	pc = 0x828ED234; continue 'dispatch;
	}
	// 828ED214: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828ED218: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828ED21C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ED220: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828ED224: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828ED228: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828ED22C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ED230: 4082FFE8  bne 0x828ed218
	if !ctx.cr[0].eq {
	pc = 0x828ED218; continue 'dispatch;
	}
	// 828ED234: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828ED238: 807F037C  lwz r3, 0x37c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(892 as u32) ) } as u64;
	// 828ED23C: 4BF0AE3D  bl 0x827f8078
	ctx.lr = 0x828ED240;
	sub_827F8078(ctx, base);
	// 828ED240: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828ED244: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828ED248: 419A0008  beq cr6, 0x828ed250
	if ctx.cr[6].eq {
	pc = 0x828ED250; continue 'dispatch;
	}
	// 828ED24C: 4B9D3645  bl 0x822c0890
	ctx.lr = 0x828ED250;
	sub_822C0890(ctx, base);
	// 828ED250: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828ED254: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828ED258: 419A0008  beq cr6, 0x828ed260
	if ctx.cr[6].eq {
	pc = 0x828ED260; continue 'dispatch;
	}
	// 828ED25C: 4B9D3635  bl 0x822c0890
	ctx.lr = 0x828ED260;
	sub_822C0890(ctx, base);
	// 828ED260: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ED264: 807F037C  lwz r3, 0x37c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(892 as u32) ) } as u64;
	// 828ED268: 388B1148  addi r4, r11, 0x1148
	ctx.r[4].s64 = ctx.r[11].s64 + 4424;
	// 828ED26C: 4BF0B0A5  bl 0x827f8310
	ctx.lr = 0x828ED270;
	sub_827F8310(ctx, base);
	// 828ED270: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828ED274: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ED278: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ED27C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828ED280: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828ED284: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ED288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ED288 size=260
    let mut pc: u32 = 0x828ED288;
    'dispatch: loop {
        match pc {
            0x828ED288 => {
    //   block [0x828ED288..0x828ED38C)
	// 828ED288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ED28C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ED290: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828ED294: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828ED298: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ED29C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828ED2A0: 817E037C  lwz r11, 0x37c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(892 as u32) ) } as u64;
	// 828ED2A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ED2A8: 419A00CC  beq cr6, 0x828ed374
	if ctx.cr[6].eq {
	pc = 0x828ED374; continue 'dispatch;
	}
	// 828ED2AC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828ED2B0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828ED2B4: 808B6750  lwz r4, 0x6750(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26448 as u32) ) } as u64;
	// 828ED2B8: 4B9F7C79  bl 0x822e4f30
	ctx.lr = 0x828ED2BC;
	sub_822E4F30(ctx, base);
	// 828ED2BC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828ED2C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ED2C4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828ED2C8: 808B6874  lwz r4, 0x6874(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26740 as u32) ) } as u64;
	// 828ED2CC: 4B9F7C65  bl 0x822e4f30
	ctx.lr = 0x828ED2D0;
	sub_822E4F30(ctx, base);
	// 828ED2D0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828ED2D4: E89F0000  ld r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 828ED2D8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828ED2DC: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 828ED2E0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828ED2E4: 4BB9EFA5  bl 0x8248c288
	ctx.lr = 0x828ED2E8;
	sub_8248C288(ctx, base);
	// 828ED2E8: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828ED2EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828ED2F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ED2F4: 4BF3749D  bl 0x82824790
	ctx.lr = 0x828ED2F8;
	sub_82824790(ctx, base);
	// 828ED2F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ED2FC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828ED300: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ED304: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ED308: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828ED30C: 419A0024  beq cr6, 0x828ed330
	if ctx.cr[6].eq {
	pc = 0x828ED330; continue 'dispatch;
	}
	// 828ED310: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828ED314: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828ED318: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ED31C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828ED320: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828ED324: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828ED328: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ED32C: 4082FFE8  bne 0x828ed314
	if !ctx.cr[0].eq {
	pc = 0x828ED314; continue 'dispatch;
	}
	// 828ED330: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ED334: 807E037C  lwz r3, 0x37c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(892 as u32) ) } as u64;
	// 828ED338: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828ED33C: 3BEB1148  addi r31, r11, 0x1148
	ctx.r[31].s64 = ctx.r[11].s64 + 4424;
	// 828ED340: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828ED344: 4BF0AC35  bl 0x827f7f78
	ctx.lr = 0x828ED348;
	sub_827F7F78(ctx, base);
	// 828ED348: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828ED34C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828ED350: 419A0008  beq cr6, 0x828ed358
	if ctx.cr[6].eq {
	pc = 0x828ED358; continue 'dispatch;
	}
	// 828ED354: 4B9D353D  bl 0x822c0890
	ctx.lr = 0x828ED358;
	sub_822C0890(ctx, base);
	// 828ED358: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828ED35C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828ED360: 419A0008  beq cr6, 0x828ed368
	if ctx.cr[6].eq {
	pc = 0x828ED368; continue 'dispatch;
	}
	// 828ED364: 4B9D352D  bl 0x822c0890
	ctx.lr = 0x828ED368;
	sub_822C0890(ctx, base);
	// 828ED368: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828ED36C: 807E037C  lwz r3, 0x37c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(892 as u32) ) } as u64;
	// 828ED370: 4BF0AFA1  bl 0x827f8310
	ctx.lr = 0x828ED374;
	sub_827F8310(ctx, base);
	// 828ED374: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828ED378: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ED37C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ED380: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828ED384: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828ED388: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ED390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828ED390 size=52
    let mut pc: u32 = 0x828ED390;
    'dispatch: loop {
        match pc {
            0x828ED390 => {
    //   block [0x828ED390..0x828ED3C4)
	// 828ED390: 816303A0  lwz r11, 0x3a0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(928 as u32) ) } as u64;
	// 828ED394: 814303A4  lwz r10, 0x3a4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(932 as u32) ) } as u64;
	// 828ED398: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828ED39C: 419A0028  beq cr6, 0x828ed3c4
	if ctx.cr[6].eq {
		sub_828ED3C4(ctx, base);
		return;
	}
	// 828ED3A0: 81240018  lwz r9, 0x18(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 828ED3A4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ED3A8: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828ED3AC: 419A0010  beq cr6, 0x828ed3bc
	if ctx.cr[6].eq {
	pc = 0x828ED3BC; continue 'dispatch;
	}
	// 828ED3B0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828ED3B4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828ED3B8: 409AFFEC  bne cr6, 0x828ed3a4
	if !ctx.cr[6].eq {
	pc = 0x828ED3A4; continue 'dispatch;
	}
	// 828ED3BC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828ED3C0: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ED3C4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828ED3C4 size=12
    let mut pc: u32 = 0x828ED3C4;
    'dispatch: loop {
        match pc {
            0x828ED3C4 => {
    //   block [0x828ED3C4..0x828ED3D0)
	// 828ED3C4: 38840018  addi r4, r4, 0x18
	ctx.r[4].s64 = ctx.r[4].s64 + 24;
	// 828ED3C8: 3863039C  addi r3, r3, 0x39c
	ctx.r[3].s64 = ctx.r[3].s64 + 924;
	// 828ED3CC: 4BBCBD44  b 0x824b9110
	sub_824B9110(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ED3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828ED3D0 size=4
    let mut pc: u32 = 0x828ED3D0;
    'dispatch: loop {
        match pc {
            0x828ED3D0 => {
    //   block [0x828ED3D0..0x828ED3D4)
	// 828ED3D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ED3D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ED3D8 size=108
    let mut pc: u32 = 0x828ED3D8;
    'dispatch: loop {
        match pc {
            0x828ED3D8 => {
    //   block [0x828ED3D8..0x828ED444)
	// 828ED3D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ED3DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ED3E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828ED3E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ED3E8: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 828ED3EC: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 828ED3F0: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 828ED3F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ED3F8: 4BFFFC79  bl 0x828ed070
	ctx.lr = 0x828ED3FC;
	sub_828ED070(ctx, base);
	// 828ED3FC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ED400: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828ED404: 396B1424  addi r11, r11, 0x1424
	ctx.r[11].s64 = ctx.r[11].s64 + 5156;
	// 828ED408: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828ED40C: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828ED410: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828ED414: 394A140C  addi r10, r10, 0x140c
	ctx.r[10].s64 = ctx.r[10].s64 + 5132;
	// 828ED418: 392913F0  addi r9, r9, 0x13f0
	ctx.r[9].s64 = ctx.r[9].s64 + 5104;
	// 828ED41C: 396813A4  addi r11, r8, 0x13a4
	ctx.r[11].s64 = ctx.r[8].s64 + 5028;
	// 828ED420: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 828ED424: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 828ED428: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ED42C: 917F0360  stw r11, 0x360(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(864 as u32), ctx.r[11].u32 ) };
	// 828ED430: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828ED434: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ED438: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ED43C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828ED440: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ED448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ED448 size=108
    let mut pc: u32 = 0x828ED448;
    'dispatch: loop {
        match pc {
            0x828ED448 => {
    //   block [0x828ED448..0x828ED4B4)
	// 828ED448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ED44C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ED450: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828ED454: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ED458: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 828ED45C: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 828ED460: 38C00011  li r6, 0x11
	ctx.r[6].s64 = 17;
	// 828ED464: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ED468: 4BFFFC09  bl 0x828ed070
	ctx.lr = 0x828ED46C;
	sub_828ED070(ctx, base);
	// 828ED46C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ED470: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828ED474: 396B1674  addi r11, r11, 0x1674
	ctx.r[11].s64 = ctx.r[11].s64 + 5748;
	// 828ED478: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828ED47C: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828ED480: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828ED484: 394A165C  addi r10, r10, 0x165c
	ctx.r[10].s64 = ctx.r[10].s64 + 5724;
	// 828ED488: 39291640  addi r9, r9, 0x1640
	ctx.r[9].s64 = ctx.r[9].s64 + 5696;
	// 828ED48C: 396815F4  addi r11, r8, 0x15f4
	ctx.r[11].s64 = ctx.r[8].s64 + 5620;
	// 828ED490: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 828ED494: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 828ED498: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ED49C: 917F0360  stw r11, 0x360(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(864 as u32), ctx.r[11].u32 ) };
	// 828ED4A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828ED4A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ED4A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ED4AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828ED4B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ED4B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ED4B8 size=108
    let mut pc: u32 = 0x828ED4B8;
    'dispatch: loop {
        match pc {
            0x828ED4B8 => {
    //   block [0x828ED4B8..0x828ED524)
	// 828ED4B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ED4BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ED4C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828ED4C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ED4C8: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 828ED4CC: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 828ED4D0: 38C00012  li r6, 0x12
	ctx.r[6].s64 = 18;
	// 828ED4D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ED4D8: 4BFFFB99  bl 0x828ed070
	ctx.lr = 0x828ED4DC;
	sub_828ED070(ctx, base);
	// 828ED4DC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ED4E0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828ED4E4: 396B18C4  addi r11, r11, 0x18c4
	ctx.r[11].s64 = ctx.r[11].s64 + 6340;
	// 828ED4E8: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828ED4EC: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828ED4F0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828ED4F4: 394A18AC  addi r10, r10, 0x18ac
	ctx.r[10].s64 = ctx.r[10].s64 + 6316;
	// 828ED4F8: 39291890  addi r9, r9, 0x1890
	ctx.r[9].s64 = ctx.r[9].s64 + 6288;
	// 828ED4FC: 39681844  addi r11, r8, 0x1844
	ctx.r[11].s64 = ctx.r[8].s64 + 6212;
	// 828ED500: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 828ED504: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 828ED508: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ED50C: 917F0360  stw r11, 0x360(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(864 as u32), ctx.r[11].u32 ) };
	// 828ED510: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828ED514: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ED518: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ED51C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828ED520: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ED528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ED528 size=108
    let mut pc: u32 = 0x828ED528;
    'dispatch: loop {
        match pc {
            0x828ED528 => {
    //   block [0x828ED528..0x828ED594)
	// 828ED528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ED52C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ED530: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828ED534: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ED538: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 828ED53C: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 828ED540: 38C00013  li r6, 0x13
	ctx.r[6].s64 = 19;
	// 828ED544: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ED548: 4BFFFB29  bl 0x828ed070
	ctx.lr = 0x828ED54C;
	sub_828ED070(ctx, base);
	// 828ED54C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ED550: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828ED554: 396B1B14  addi r11, r11, 0x1b14
	ctx.r[11].s64 = ctx.r[11].s64 + 6932;
	// 828ED558: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828ED55C: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828ED560: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828ED564: 394A1AFC  addi r10, r10, 0x1afc
	ctx.r[10].s64 = ctx.r[10].s64 + 6908;
	// 828ED568: 39291AE0  addi r9, r9, 0x1ae0
	ctx.r[9].s64 = ctx.r[9].s64 + 6880;
	// 828ED56C: 39681A94  addi r11, r8, 0x1a94
	ctx.r[11].s64 = ctx.r[8].s64 + 6804;
	// 828ED570: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 828ED574: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 828ED578: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ED57C: 917F0360  stw r11, 0x360(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(864 as u32), ctx.r[11].u32 ) };
	// 828ED580: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828ED584: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ED588: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ED58C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828ED590: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ED598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ED598 size=108
    let mut pc: u32 = 0x828ED598;
    'dispatch: loop {
        match pc {
            0x828ED598 => {
    //   block [0x828ED598..0x828ED604)
	// 828ED598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ED59C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ED5A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828ED5A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ED5A8: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 828ED5AC: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 828ED5B0: 38C00014  li r6, 0x14
	ctx.r[6].s64 = 20;
	// 828ED5B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ED5B8: 4BFFFAB9  bl 0x828ed070
	ctx.lr = 0x828ED5BC;
	sub_828ED070(ctx, base);
	// 828ED5BC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ED5C0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828ED5C4: 396B1D64  addi r11, r11, 0x1d64
	ctx.r[11].s64 = ctx.r[11].s64 + 7524;
	// 828ED5C8: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828ED5CC: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828ED5D0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828ED5D4: 394A1D4C  addi r10, r10, 0x1d4c
	ctx.r[10].s64 = ctx.r[10].s64 + 7500;
	// 828ED5D8: 39291D30  addi r9, r9, 0x1d30
	ctx.r[9].s64 = ctx.r[9].s64 + 7472;
	// 828ED5DC: 39681CE4  addi r11, r8, 0x1ce4
	ctx.r[11].s64 = ctx.r[8].s64 + 7396;
	// 828ED5E0: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 828ED5E4: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 828ED5E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ED5EC: 917F0360  stw r11, 0x360(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(864 as u32), ctx.r[11].u32 ) };
	// 828ED5F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828ED5F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ED5F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ED5FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828ED600: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ED608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828ED608 size=480
    let mut pc: u32 = 0x828ED608;
    'dispatch: loop {
        match pc {
            0x828ED608 => {
    //   block [0x828ED608..0x828ED7E8)
	// 828ED608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ED60C: 488BAB59  bl 0x831a8164
	ctx.lr = 0x828ED610;
	sub_831A8130(ctx, base);
	// 828ED610: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ED614: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ED618: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828ED61C: 3BCB0FF0  addi r30, r11, 0xff0
	ctx.r[30].s64 = ctx.r[11].s64 + 4080;
	// 828ED620: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828ED624: 38A00662  li r5, 0x662
	ctx.r[5].s64 = 1634;
	// 828ED628: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828ED62C: 38600410  li r3, 0x410
	ctx.r[3].s64 = 1040;
	// 828ED630: 48504DB9  bl 0x82df23e8
	ctx.lr = 0x828ED634;
	sub_82DF23E8(ctx, base);
	// 828ED634: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828ED638: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828ED63C: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 828ED640: 41820024  beq 0x828ed664
	if ctx.cr[0].eq {
	pc = 0x828ED664; continue 'dispatch;
	}
	// 828ED644: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828ED648: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828ED64C: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 828ED650: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828ED654: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828ED658: 4BFFFD81  bl 0x828ed3d8
	ctx.lr = 0x828ED65C;
	sub_828ED3D8(ctx, base);
	// 828ED65C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ED660: 48000008  b 0x828ed668
	pc = 0x828ED668; continue 'dispatch;
	// 828ED664: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828ED668: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828ED66C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828ED670: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828ED674: 4BFF586D  bl 0x828e2ee0
	ctx.lr = 0x828ED678;
	sub_828E2EE0(ctx, base);
	// 828ED678: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828ED67C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828ED680: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828ED684: 4B9D297D  bl 0x822c0000
	ctx.lr = 0x828ED688;
	sub_822C0000(ctx, base);
	// 828ED688: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828ED68C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828ED690: 397F0360  addi r11, r31, 0x360
	ctx.r[11].s64 = ctx.r[31].s64 + 864;
	// 828ED694: 409A0008  bne cr6, 0x828ed69c
	if !ctx.cr[6].eq {
	pc = 0x828ED69C; continue 'dispatch;
	}
	// 828ED698: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828ED69C: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828ED6A0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828ED6A4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828ED6A8: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828ED6AC: 419A0024  beq cr6, 0x828ed6d0
	if ctx.cr[6].eq {
	pc = 0x828ED6D0; continue 'dispatch;
	}
	// 828ED6B0: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828ED6B4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828ED6B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ED6BC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828ED6C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828ED6C4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828ED6C8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ED6CC: 4082FFE8  bne 0x828ed6b4
	if !ctx.cr[0].eq {
	pc = 0x828ED6B4; continue 'dispatch;
	}
	// 828ED6D0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828ED6D4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828ED6D8: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828ED6DC: 419A0024  beq cr6, 0x828ed700
	if ctx.cr[6].eq {
	pc = 0x828ED700; continue 'dispatch;
	}
	// 828ED6E0: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828ED6E4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828ED6E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ED6EC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828ED6F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828ED6F4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828ED6F8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ED6FC: 4082FFE8  bne 0x828ed6e4
	if !ctx.cr[0].eq {
	pc = 0x828ED6E4; continue 'dispatch;
	}
	// 828ED700: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828ED704: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828ED708: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828ED70C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828ED710: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828ED714: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ED718: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828ED71C: 4BEAB815  bl 0x82798f30
	ctx.lr = 0x828ED720;
	sub_82798F30(ctx, base);
	// 828ED720: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ED724: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ED728: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828ED72C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828ED730: 4E800421  bctrl
	ctx.lr = 0x828ED734;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828ED734: C0030010  lfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828ED738: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828ED73C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ED740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ED744: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828ED748: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828ED74C: 4E800421  bctrl
	ctx.lr = 0x828ED750;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828ED750: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828ED754: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828ED758: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828ED75C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828ED760: 38A00667  li r5, 0x667
	ctx.r[5].s64 = 1639;
	// 828ED764: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828ED768: 4B9D2C71  bl 0x822c03d8
	ctx.lr = 0x828ED76C;
	sub_822C03D8(ctx, base);
	// 828ED76C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828ED770: 41820014  beq 0x828ed784
	if ctx.cr[0].eq {
	pc = 0x828ED784; continue 'dispatch;
	}
	// 828ED774: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828ED778: 4BEADEF1  bl 0x8279b668
	ctx.lr = 0x828ED77C;
	sub_8279B668(ctx, base);
	// 828ED77C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ED780: 48000008  b 0x828ed788
	pc = 0x828ED788; continue 'dispatch;
	// 828ED784: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828ED788: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828ED78C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828ED790: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828ED794: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828ED798: 4BCAA4B9  bl 0x82597c50
	ctx.lr = 0x828ED79C;
	sub_82597C50(ctx, base);
	// 828ED79C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828ED7A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828ED7A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828ED7A8: 4B9D2859  bl 0x822c0000
	ctx.lr = 0x828ED7AC;
	sub_822C0000(ctx, base);
	// 828ED7AC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828ED7B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828ED7B4: 419A0008  beq cr6, 0x828ed7bc
	if ctx.cr[6].eq {
	pc = 0x828ED7BC; continue 'dispatch;
	}
	// 828ED7B8: 4B9D30D9  bl 0x822c0890
	ctx.lr = 0x828ED7BC;
	sub_822C0890(ctx, base);
	// 828ED7BC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828ED7C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828ED7C4: 419A0008  beq cr6, 0x828ed7cc
	if ctx.cr[6].eq {
	pc = 0x828ED7CC; continue 'dispatch;
	}
	// 828ED7C8: 4B9D30C9  bl 0x822c0890
	ctx.lr = 0x828ED7CC;
	sub_822C0890(ctx, base);
	// 828ED7CC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828ED7D0: 419A000C  beq cr6, 0x828ed7dc
	if ctx.cr[6].eq {
	pc = 0x828ED7DC; continue 'dispatch;
	}
	// 828ED7D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828ED7D8: 4B9D30B9  bl 0x822c0890
	ctx.lr = 0x828ED7DC;
	sub_822C0890(ctx, base);
	// 828ED7DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ED7E0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828ED7E4: 488BA9D0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ED7E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ED7E8 size=144
    let mut pc: u32 = 0x828ED7E8;
    'dispatch: loop {
        match pc {
            0x828ED7E8 => {
    //   block [0x828ED7E8..0x828ED878)
	// 828ED7E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ED7EC: 488BA979  bl 0x831a8164
	ctx.lr = 0x828ED7F0;
	sub_831A8130(ctx, base);
	// 828ED7F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ED7F4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ED7F8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828ED7FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828ED800: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828ED804: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828ED808: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828ED80C: 388B0FF0  addi r4, r11, 0xff0
	ctx.r[4].s64 = ctx.r[11].s64 + 4080;
	// 828ED810: 38A0066D  li r5, 0x66d
	ctx.r[5].s64 = 1645;
	// 828ED814: 38600410  li r3, 0x410
	ctx.r[3].s64 = 1040;
	// 828ED818: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 828ED81C: 48504BCD  bl 0x82df23e8
	ctx.lr = 0x828ED820;
	sub_82DF23E8(ctx, base);
	// 828ED820: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828ED824: 41820020  beq 0x828ed844
	if ctx.cr[0].eq {
	pc = 0x828ED844; continue 'dispatch;
	}
	// 828ED828: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828ED82C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828ED830: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828ED834: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828ED838: 4BFFFBA1  bl 0x828ed3d8
	ctx.lr = 0x828ED83C;
	sub_828ED3D8(ctx, base);
	// 828ED83C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ED840: 48000008  b 0x828ed848
	pc = 0x828ED848; continue 'dispatch;
	// 828ED844: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828ED848: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828ED84C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828ED850: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828ED854: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828ED858: 4BFF5689  bl 0x828e2ee0
	ctx.lr = 0x828ED85C;
	sub_828E2EE0(ctx, base);
	// 828ED85C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828ED860: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828ED864: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828ED868: 4B9D2799  bl 0x822c0000
	ctx.lr = 0x828ED86C;
	sub_822C0000(ctx, base);
	// 828ED86C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828ED870: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828ED874: 488BA940  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ED878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828ED878 size=480
    let mut pc: u32 = 0x828ED878;
    'dispatch: loop {
        match pc {
            0x828ED878 => {
    //   block [0x828ED878..0x828EDA58)
	// 828ED878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ED87C: 488BA8E9  bl 0x831a8164
	ctx.lr = 0x828ED880;
	sub_831A8130(ctx, base);
	// 828ED880: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ED884: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ED888: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828ED88C: 3BCB0FF0  addi r30, r11, 0xff0
	ctx.r[30].s64 = ctx.r[11].s64 + 4080;
	// 828ED890: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828ED894: 38A006F0  li r5, 0x6f0
	ctx.r[5].s64 = 1776;
	// 828ED898: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828ED89C: 38600410  li r3, 0x410
	ctx.r[3].s64 = 1040;
	// 828ED8A0: 48504B49  bl 0x82df23e8
	ctx.lr = 0x828ED8A4;
	sub_82DF23E8(ctx, base);
	// 828ED8A4: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828ED8A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828ED8AC: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 828ED8B0: 41820024  beq 0x828ed8d4
	if ctx.cr[0].eq {
	pc = 0x828ED8D4; continue 'dispatch;
	}
	// 828ED8B4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828ED8B8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828ED8BC: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 828ED8C0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828ED8C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828ED8C8: 4BFFFB81  bl 0x828ed448
	ctx.lr = 0x828ED8CC;
	sub_828ED448(ctx, base);
	// 828ED8CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ED8D0: 48000008  b 0x828ed8d8
	pc = 0x828ED8D8; continue 'dispatch;
	// 828ED8D4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828ED8D8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828ED8DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828ED8E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828ED8E4: 4BFF56C5  bl 0x828e2fa8
	ctx.lr = 0x828ED8E8;
	sub_828E2FA8(ctx, base);
	// 828ED8E8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828ED8EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828ED8F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828ED8F4: 4B9D270D  bl 0x822c0000
	ctx.lr = 0x828ED8F8;
	sub_822C0000(ctx, base);
	// 828ED8F8: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828ED8FC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828ED900: 397F0360  addi r11, r31, 0x360
	ctx.r[11].s64 = ctx.r[31].s64 + 864;
	// 828ED904: 409A0008  bne cr6, 0x828ed90c
	if !ctx.cr[6].eq {
	pc = 0x828ED90C; continue 'dispatch;
	}
	// 828ED908: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828ED90C: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828ED910: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828ED914: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828ED918: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828ED91C: 419A0024  beq cr6, 0x828ed940
	if ctx.cr[6].eq {
	pc = 0x828ED940; continue 'dispatch;
	}
	// 828ED920: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828ED924: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828ED928: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ED92C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828ED930: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828ED934: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828ED938: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ED93C: 4082FFE8  bne 0x828ed924
	if !ctx.cr[0].eq {
	pc = 0x828ED924; continue 'dispatch;
	}
	// 828ED940: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828ED944: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828ED948: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828ED94C: 419A0024  beq cr6, 0x828ed970
	if ctx.cr[6].eq {
	pc = 0x828ED970; continue 'dispatch;
	}
	// 828ED950: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828ED954: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828ED958: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ED95C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828ED960: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828ED964: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828ED968: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ED96C: 4082FFE8  bne 0x828ed954
	if !ctx.cr[0].eq {
	pc = 0x828ED954; continue 'dispatch;
	}
	// 828ED970: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828ED974: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828ED978: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828ED97C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828ED980: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828ED984: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ED988: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828ED98C: 4BEAB5A5  bl 0x82798f30
	ctx.lr = 0x828ED990;
	sub_82798F30(ctx, base);
	// 828ED990: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ED994: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ED998: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828ED99C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828ED9A0: 4E800421  bctrl
	ctx.lr = 0x828ED9A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828ED9A4: C0030010  lfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828ED9A8: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828ED9AC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ED9B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ED9B4: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828ED9B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828ED9BC: 4E800421  bctrl
	ctx.lr = 0x828ED9C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828ED9C0: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828ED9C4: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828ED9C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828ED9CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828ED9D0: 38A006F5  li r5, 0x6f5
	ctx.r[5].s64 = 1781;
	// 828ED9D4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828ED9D8: 4B9D2A01  bl 0x822c03d8
	ctx.lr = 0x828ED9DC;
	sub_822C03D8(ctx, base);
	// 828ED9DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828ED9E0: 41820014  beq 0x828ed9f4
	if ctx.cr[0].eq {
	pc = 0x828ED9F4; continue 'dispatch;
	}
	// 828ED9E4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828ED9E8: 4BEADC81  bl 0x8279b668
	ctx.lr = 0x828ED9EC;
	sub_8279B668(ctx, base);
	// 828ED9EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ED9F0: 48000008  b 0x828ed9f8
	pc = 0x828ED9F8; continue 'dispatch;
	// 828ED9F4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828ED9F8: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828ED9FC: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828EDA00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EDA04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EDA08: 4BCAA249  bl 0x82597c50
	ctx.lr = 0x828EDA0C;
	sub_82597C50(ctx, base);
	// 828EDA0C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828EDA10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EDA14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EDA18: 4B9D25E9  bl 0x822c0000
	ctx.lr = 0x828EDA1C;
	sub_822C0000(ctx, base);
	// 828EDA1C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828EDA20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EDA24: 419A0008  beq cr6, 0x828eda2c
	if ctx.cr[6].eq {
	pc = 0x828EDA2C; continue 'dispatch;
	}
	// 828EDA28: 4B9D2E69  bl 0x822c0890
	ctx.lr = 0x828EDA2C;
	sub_822C0890(ctx, base);
	// 828EDA2C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828EDA30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EDA34: 419A0008  beq cr6, 0x828eda3c
	if ctx.cr[6].eq {
	pc = 0x828EDA3C; continue 'dispatch;
	}
	// 828EDA38: 4B9D2E59  bl 0x822c0890
	ctx.lr = 0x828EDA3C;
	sub_822C0890(ctx, base);
	// 828EDA3C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828EDA40: 419A000C  beq cr6, 0x828eda4c
	if ctx.cr[6].eq {
	pc = 0x828EDA4C; continue 'dispatch;
	}
	// 828EDA44: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828EDA48: 4B9D2E49  bl 0x822c0890
	ctx.lr = 0x828EDA4C;
	sub_822C0890(ctx, base);
	// 828EDA4C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828EDA50: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828EDA54: 488BA760  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EDA58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EDA58 size=144
    let mut pc: u32 = 0x828EDA58;
    'dispatch: loop {
        match pc {
            0x828EDA58 => {
    //   block [0x828EDA58..0x828EDAE8)
	// 828EDA58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EDA5C: 488BA709  bl 0x831a8164
	ctx.lr = 0x828EDA60;
	sub_831A8130(ctx, base);
	// 828EDA60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EDA64: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EDA68: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828EDA6C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828EDA70: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828EDA74: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828EDA78: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828EDA7C: 388B0FF0  addi r4, r11, 0xff0
	ctx.r[4].s64 = ctx.r[11].s64 + 4080;
	// 828EDA80: 38A006FB  li r5, 0x6fb
	ctx.r[5].s64 = 1787;
	// 828EDA84: 38600410  li r3, 0x410
	ctx.r[3].s64 = 1040;
	// 828EDA88: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 828EDA8C: 4850495D  bl 0x82df23e8
	ctx.lr = 0x828EDA90;
	sub_82DF23E8(ctx, base);
	// 828EDA90: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828EDA94: 41820020  beq 0x828edab4
	if ctx.cr[0].eq {
	pc = 0x828EDAB4; continue 'dispatch;
	}
	// 828EDA98: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828EDA9C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828EDAA0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828EDAA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EDAA8: 4BFFF9A1  bl 0x828ed448
	ctx.lr = 0x828EDAAC;
	sub_828ED448(ctx, base);
	// 828EDAAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EDAB0: 48000008  b 0x828edab8
	pc = 0x828EDAB8; continue 'dispatch;
	// 828EDAB4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828EDAB8: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828EDABC: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828EDAC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EDAC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EDAC8: 4BFF54E1  bl 0x828e2fa8
	ctx.lr = 0x828EDACC;
	sub_828E2FA8(ctx, base);
	// 828EDACC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828EDAD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EDAD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EDAD8: 4B9D2529  bl 0x822c0000
	ctx.lr = 0x828EDADC;
	sub_822C0000(ctx, base);
	// 828EDADC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828EDAE0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828EDAE4: 488BA6D0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EDAE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828EDAE8 size=480
    let mut pc: u32 = 0x828EDAE8;
    'dispatch: loop {
        match pc {
            0x828EDAE8 => {
    //   block [0x828EDAE8..0x828EDCC8)
	// 828EDAE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EDAEC: 488BA679  bl 0x831a8164
	ctx.lr = 0x828EDAF0;
	sub_831A8130(ctx, base);
	// 828EDAF0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EDAF4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EDAF8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828EDAFC: 3BCB0FF0  addi r30, r11, 0xff0
	ctx.r[30].s64 = ctx.r[11].s64 + 4080;
	// 828EDB00: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828EDB04: 38A0077E  li r5, 0x77e
	ctx.r[5].s64 = 1918;
	// 828EDB08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EDB0C: 38600410  li r3, 0x410
	ctx.r[3].s64 = 1040;
	// 828EDB10: 485048D9  bl 0x82df23e8
	ctx.lr = 0x828EDB14;
	sub_82DF23E8(ctx, base);
	// 828EDB14: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828EDB18: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828EDB1C: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 828EDB20: 41820024  beq 0x828edb44
	if ctx.cr[0].eq {
	pc = 0x828EDB44; continue 'dispatch;
	}
	// 828EDB24: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828EDB28: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828EDB2C: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 828EDB30: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828EDB34: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828EDB38: 4BFFF981  bl 0x828ed4b8
	ctx.lr = 0x828EDB3C;
	sub_828ED4B8(ctx, base);
	// 828EDB3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EDB40: 48000008  b 0x828edb48
	pc = 0x828EDB48; continue 'dispatch;
	// 828EDB44: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828EDB48: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828EDB4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EDB50: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828EDB54: 4BFF551D  bl 0x828e3070
	ctx.lr = 0x828EDB58;
	sub_828E3070(ctx, base);
	// 828EDB58: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828EDB5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EDB60: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828EDB64: 4B9D249D  bl 0x822c0000
	ctx.lr = 0x828EDB68;
	sub_822C0000(ctx, base);
	// 828EDB68: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828EDB6C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828EDB70: 397F0360  addi r11, r31, 0x360
	ctx.r[11].s64 = ctx.r[31].s64 + 864;
	// 828EDB74: 409A0008  bne cr6, 0x828edb7c
	if !ctx.cr[6].eq {
	pc = 0x828EDB7C; continue 'dispatch;
	}
	// 828EDB78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828EDB7C: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828EDB80: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828EDB84: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828EDB88: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828EDB8C: 419A0024  beq cr6, 0x828edbb0
	if ctx.cr[6].eq {
	pc = 0x828EDBB0; continue 'dispatch;
	}
	// 828EDB90: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828EDB94: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828EDB98: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EDB9C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828EDBA0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828EDBA4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828EDBA8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EDBAC: 4082FFE8  bne 0x828edb94
	if !ctx.cr[0].eq {
	pc = 0x828EDB94; continue 'dispatch;
	}
	// 828EDBB0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828EDBB4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828EDBB8: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828EDBBC: 419A0024  beq cr6, 0x828edbe0
	if ctx.cr[6].eq {
	pc = 0x828EDBE0; continue 'dispatch;
	}
	// 828EDBC0: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828EDBC4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828EDBC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EDBCC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828EDBD0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828EDBD4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828EDBD8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EDBDC: 4082FFE8  bne 0x828edbc4
	if !ctx.cr[0].eq {
	pc = 0x828EDBC4; continue 'dispatch;
	}
	// 828EDBE0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828EDBE4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828EDBE8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828EDBEC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828EDBF0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828EDBF4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EDBF8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EDBFC: 4BEAB335  bl 0x82798f30
	ctx.lr = 0x828EDC00;
	sub_82798F30(ctx, base);
	// 828EDC00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EDC04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EDC08: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828EDC0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EDC10: 4E800421  bctrl
	ctx.lr = 0x828EDC14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EDC14: C0030010  lfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828EDC18: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828EDC1C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EDC20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EDC24: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828EDC28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EDC2C: 4E800421  bctrl
	ctx.lr = 0x828EDC30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EDC30: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828EDC34: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828EDC38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EDC3C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828EDC40: 38A00783  li r5, 0x783
	ctx.r[5].s64 = 1923;
	// 828EDC44: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828EDC48: 4B9D2791  bl 0x822c03d8
	ctx.lr = 0x828EDC4C;
	sub_822C03D8(ctx, base);
	// 828EDC4C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828EDC50: 41820014  beq 0x828edc64
	if ctx.cr[0].eq {
	pc = 0x828EDC64; continue 'dispatch;
	}
	// 828EDC54: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828EDC58: 4BEADA11  bl 0x8279b668
	ctx.lr = 0x828EDC5C;
	sub_8279B668(ctx, base);
	// 828EDC5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EDC60: 48000008  b 0x828edc68
	pc = 0x828EDC68; continue 'dispatch;
	// 828EDC64: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828EDC68: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828EDC6C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828EDC70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EDC74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EDC78: 4BCA9FD9  bl 0x82597c50
	ctx.lr = 0x828EDC7C;
	sub_82597C50(ctx, base);
	// 828EDC7C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828EDC80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EDC84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EDC88: 4B9D2379  bl 0x822c0000
	ctx.lr = 0x828EDC8C;
	sub_822C0000(ctx, base);
	// 828EDC8C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828EDC90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EDC94: 419A0008  beq cr6, 0x828edc9c
	if ctx.cr[6].eq {
	pc = 0x828EDC9C; continue 'dispatch;
	}
	// 828EDC98: 4B9D2BF9  bl 0x822c0890
	ctx.lr = 0x828EDC9C;
	sub_822C0890(ctx, base);
	// 828EDC9C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828EDCA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EDCA4: 419A0008  beq cr6, 0x828edcac
	if ctx.cr[6].eq {
	pc = 0x828EDCAC; continue 'dispatch;
	}
	// 828EDCA8: 4B9D2BE9  bl 0x822c0890
	ctx.lr = 0x828EDCAC;
	sub_822C0890(ctx, base);
	// 828EDCAC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828EDCB0: 419A000C  beq cr6, 0x828edcbc
	if ctx.cr[6].eq {
	pc = 0x828EDCBC; continue 'dispatch;
	}
	// 828EDCB4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828EDCB8: 4B9D2BD9  bl 0x822c0890
	ctx.lr = 0x828EDCBC;
	sub_822C0890(ctx, base);
	// 828EDCBC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828EDCC0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828EDCC4: 488BA4F0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EDCC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EDCC8 size=144
    let mut pc: u32 = 0x828EDCC8;
    'dispatch: loop {
        match pc {
            0x828EDCC8 => {
    //   block [0x828EDCC8..0x828EDD58)
	// 828EDCC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EDCCC: 488BA499  bl 0x831a8164
	ctx.lr = 0x828EDCD0;
	sub_831A8130(ctx, base);
	// 828EDCD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EDCD4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EDCD8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828EDCDC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828EDCE0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828EDCE4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828EDCE8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828EDCEC: 388B0FF0  addi r4, r11, 0xff0
	ctx.r[4].s64 = ctx.r[11].s64 + 4080;
	// 828EDCF0: 38A00789  li r5, 0x789
	ctx.r[5].s64 = 1929;
	// 828EDCF4: 38600410  li r3, 0x410
	ctx.r[3].s64 = 1040;
	// 828EDCF8: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 828EDCFC: 485046ED  bl 0x82df23e8
	ctx.lr = 0x828EDD00;
	sub_82DF23E8(ctx, base);
	// 828EDD00: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828EDD04: 41820020  beq 0x828edd24
	if ctx.cr[0].eq {
	pc = 0x828EDD24; continue 'dispatch;
	}
	// 828EDD08: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828EDD0C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828EDD10: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828EDD14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EDD18: 4BFFF7A1  bl 0x828ed4b8
	ctx.lr = 0x828EDD1C;
	sub_828ED4B8(ctx, base);
	// 828EDD1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EDD20: 48000008  b 0x828edd28
	pc = 0x828EDD28; continue 'dispatch;
	// 828EDD24: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828EDD28: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828EDD2C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828EDD30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EDD34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EDD38: 4BFF5339  bl 0x828e3070
	ctx.lr = 0x828EDD3C;
	sub_828E3070(ctx, base);
	// 828EDD3C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828EDD40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EDD44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EDD48: 4B9D22B9  bl 0x822c0000
	ctx.lr = 0x828EDD4C;
	sub_822C0000(ctx, base);
	// 828EDD4C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828EDD50: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828EDD54: 488BA460  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EDD58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828EDD58 size=480
    let mut pc: u32 = 0x828EDD58;
    'dispatch: loop {
        match pc {
            0x828EDD58 => {
    //   block [0x828EDD58..0x828EDF38)
	// 828EDD58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EDD5C: 488BA409  bl 0x831a8164
	ctx.lr = 0x828EDD60;
	sub_831A8130(ctx, base);
	// 828EDD60: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EDD64: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EDD68: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828EDD6C: 3BCB0FF0  addi r30, r11, 0xff0
	ctx.r[30].s64 = ctx.r[11].s64 + 4080;
	// 828EDD70: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828EDD74: 38A007F8  li r5, 0x7f8
	ctx.r[5].s64 = 2040;
	// 828EDD78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EDD7C: 38600410  li r3, 0x410
	ctx.r[3].s64 = 1040;
	// 828EDD80: 48504669  bl 0x82df23e8
	ctx.lr = 0x828EDD84;
	sub_82DF23E8(ctx, base);
	// 828EDD84: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828EDD88: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828EDD8C: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 828EDD90: 41820024  beq 0x828eddb4
	if ctx.cr[0].eq {
	pc = 0x828EDDB4; continue 'dispatch;
	}
	// 828EDD94: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828EDD98: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828EDD9C: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 828EDDA0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828EDDA4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828EDDA8: 4BFFF781  bl 0x828ed528
	ctx.lr = 0x828EDDAC;
	sub_828ED528(ctx, base);
	// 828EDDAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EDDB0: 48000008  b 0x828eddb8
	pc = 0x828EDDB8; continue 'dispatch;
	// 828EDDB4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828EDDB8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828EDDBC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EDDC0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828EDDC4: 4BFF5375  bl 0x828e3138
	ctx.lr = 0x828EDDC8;
	sub_828E3138(ctx, base);
	// 828EDDC8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828EDDCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EDDD0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828EDDD4: 4B9D222D  bl 0x822c0000
	ctx.lr = 0x828EDDD8;
	sub_822C0000(ctx, base);
	// 828EDDD8: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828EDDDC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828EDDE0: 397F0360  addi r11, r31, 0x360
	ctx.r[11].s64 = ctx.r[31].s64 + 864;
	// 828EDDE4: 409A0008  bne cr6, 0x828eddec
	if !ctx.cr[6].eq {
	pc = 0x828EDDEC; continue 'dispatch;
	}
	// 828EDDE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828EDDEC: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828EDDF0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828EDDF4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828EDDF8: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828EDDFC: 419A0024  beq cr6, 0x828ede20
	if ctx.cr[6].eq {
	pc = 0x828EDE20; continue 'dispatch;
	}
	// 828EDE00: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828EDE04: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828EDE08: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EDE0C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828EDE10: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828EDE14: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828EDE18: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EDE1C: 4082FFE8  bne 0x828ede04
	if !ctx.cr[0].eq {
	pc = 0x828EDE04; continue 'dispatch;
	}
	// 828EDE20: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828EDE24: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828EDE28: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828EDE2C: 419A0024  beq cr6, 0x828ede50
	if ctx.cr[6].eq {
	pc = 0x828EDE50; continue 'dispatch;
	}
	// 828EDE30: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828EDE34: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828EDE38: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EDE3C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828EDE40: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828EDE44: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828EDE48: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EDE4C: 4082FFE8  bne 0x828ede34
	if !ctx.cr[0].eq {
	pc = 0x828EDE34; continue 'dispatch;
	}
	// 828EDE50: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828EDE54: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828EDE58: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828EDE5C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828EDE60: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828EDE64: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EDE68: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EDE6C: 4BEAB0C5  bl 0x82798f30
	ctx.lr = 0x828EDE70;
	sub_82798F30(ctx, base);
	// 828EDE70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EDE74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EDE78: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828EDE7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EDE80: 4E800421  bctrl
	ctx.lr = 0x828EDE84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EDE84: C0030010  lfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828EDE88: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828EDE8C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EDE90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EDE94: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828EDE98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EDE9C: 4E800421  bctrl
	ctx.lr = 0x828EDEA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EDEA0: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828EDEA4: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828EDEA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EDEAC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828EDEB0: 38A007FD  li r5, 0x7fd
	ctx.r[5].s64 = 2045;
	// 828EDEB4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828EDEB8: 4B9D2521  bl 0x822c03d8
	ctx.lr = 0x828EDEBC;
	sub_822C03D8(ctx, base);
	// 828EDEBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828EDEC0: 41820014  beq 0x828eded4
	if ctx.cr[0].eq {
	pc = 0x828EDED4; continue 'dispatch;
	}
	// 828EDEC4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828EDEC8: 4BEAD7A1  bl 0x8279b668
	ctx.lr = 0x828EDECC;
	sub_8279B668(ctx, base);
	// 828EDECC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EDED0: 48000008  b 0x828eded8
	pc = 0x828EDED8; continue 'dispatch;
	// 828EDED4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828EDED8: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828EDEDC: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828EDEE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EDEE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EDEE8: 4BCA9D69  bl 0x82597c50
	ctx.lr = 0x828EDEEC;
	sub_82597C50(ctx, base);
	// 828EDEEC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828EDEF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EDEF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EDEF8: 4B9D2109  bl 0x822c0000
	ctx.lr = 0x828EDEFC;
	sub_822C0000(ctx, base);
	// 828EDEFC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828EDF00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EDF04: 419A0008  beq cr6, 0x828edf0c
	if ctx.cr[6].eq {
	pc = 0x828EDF0C; continue 'dispatch;
	}
	// 828EDF08: 4B9D2989  bl 0x822c0890
	ctx.lr = 0x828EDF0C;
	sub_822C0890(ctx, base);
	// 828EDF0C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828EDF10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EDF14: 419A0008  beq cr6, 0x828edf1c
	if ctx.cr[6].eq {
	pc = 0x828EDF1C; continue 'dispatch;
	}
	// 828EDF18: 4B9D2979  bl 0x822c0890
	ctx.lr = 0x828EDF1C;
	sub_822C0890(ctx, base);
	// 828EDF1C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828EDF20: 419A000C  beq cr6, 0x828edf2c
	if ctx.cr[6].eq {
	pc = 0x828EDF2C; continue 'dispatch;
	}
	// 828EDF24: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828EDF28: 4B9D2969  bl 0x822c0890
	ctx.lr = 0x828EDF2C;
	sub_822C0890(ctx, base);
	// 828EDF2C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828EDF30: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828EDF34: 488BA280  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EDF38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EDF38 size=144
    let mut pc: u32 = 0x828EDF38;
    'dispatch: loop {
        match pc {
            0x828EDF38 => {
    //   block [0x828EDF38..0x828EDFC8)
	// 828EDF38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EDF3C: 488BA229  bl 0x831a8164
	ctx.lr = 0x828EDF40;
	sub_831A8130(ctx, base);
	// 828EDF40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EDF44: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EDF48: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828EDF4C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828EDF50: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828EDF54: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828EDF58: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828EDF5C: 388B0FF0  addi r4, r11, 0xff0
	ctx.r[4].s64 = ctx.r[11].s64 + 4080;
	// 828EDF60: 38A00803  li r5, 0x803
	ctx.r[5].s64 = 2051;
	// 828EDF64: 38600410  li r3, 0x410
	ctx.r[3].s64 = 1040;
	// 828EDF68: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 828EDF6C: 4850447D  bl 0x82df23e8
	ctx.lr = 0x828EDF70;
	sub_82DF23E8(ctx, base);
	// 828EDF70: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828EDF74: 41820020  beq 0x828edf94
	if ctx.cr[0].eq {
	pc = 0x828EDF94; continue 'dispatch;
	}
	// 828EDF78: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828EDF7C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828EDF80: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828EDF84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EDF88: 4BFFF5A1  bl 0x828ed528
	ctx.lr = 0x828EDF8C;
	sub_828ED528(ctx, base);
	// 828EDF8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EDF90: 48000008  b 0x828edf98
	pc = 0x828EDF98; continue 'dispatch;
	// 828EDF94: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828EDF98: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828EDF9C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828EDFA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EDFA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EDFA8: 4BFF5191  bl 0x828e3138
	ctx.lr = 0x828EDFAC;
	sub_828E3138(ctx, base);
	// 828EDFAC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828EDFB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EDFB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EDFB8: 4B9D2049  bl 0x822c0000
	ctx.lr = 0x828EDFBC;
	sub_822C0000(ctx, base);
	// 828EDFBC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828EDFC0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828EDFC4: 488BA1F0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EDFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828EDFC8 size=480
    let mut pc: u32 = 0x828EDFC8;
    'dispatch: loop {
        match pc {
            0x828EDFC8 => {
    //   block [0x828EDFC8..0x828EE1A8)
	// 828EDFC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EDFCC: 488BA199  bl 0x831a8164
	ctx.lr = 0x828EDFD0;
	sub_831A8130(ctx, base);
	// 828EDFD0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EDFD4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EDFD8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828EDFDC: 3BCB0FF0  addi r30, r11, 0xff0
	ctx.r[30].s64 = ctx.r[11].s64 + 4080;
	// 828EDFE0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828EDFE4: 38A0088C  li r5, 0x88c
	ctx.r[5].s64 = 2188;
	// 828EDFE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EDFEC: 38600410  li r3, 0x410
	ctx.r[3].s64 = 1040;
	// 828EDFF0: 485043F9  bl 0x82df23e8
	ctx.lr = 0x828EDFF4;
	sub_82DF23E8(ctx, base);
	// 828EDFF4: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828EDFF8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828EDFFC: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 828EE000: 41820024  beq 0x828ee024
	if ctx.cr[0].eq {
	pc = 0x828EE024; continue 'dispatch;
	}
	// 828EE004: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828EE008: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828EE00C: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 828EE010: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828EE014: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828EE018: 4BFFF581  bl 0x828ed598
	ctx.lr = 0x828EE01C;
	sub_828ED598(ctx, base);
	// 828EE01C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EE020: 48000008  b 0x828ee028
	pc = 0x828EE028; continue 'dispatch;
	// 828EE024: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828EE028: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828EE02C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EE030: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828EE034: 4BFF51CD  bl 0x828e3200
	ctx.lr = 0x828EE038;
	sub_828E3200(ctx, base);
	// 828EE038: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828EE03C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EE040: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828EE044: 4B9D1FBD  bl 0x822c0000
	ctx.lr = 0x828EE048;
	sub_822C0000(ctx, base);
	// 828EE048: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828EE04C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828EE050: 397F0360  addi r11, r31, 0x360
	ctx.r[11].s64 = ctx.r[31].s64 + 864;
	// 828EE054: 409A0008  bne cr6, 0x828ee05c
	if !ctx.cr[6].eq {
	pc = 0x828EE05C; continue 'dispatch;
	}
	// 828EE058: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828EE05C: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828EE060: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828EE064: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828EE068: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828EE06C: 419A0024  beq cr6, 0x828ee090
	if ctx.cr[6].eq {
	pc = 0x828EE090; continue 'dispatch;
	}
	// 828EE070: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828EE074: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828EE078: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EE07C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828EE080: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828EE084: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828EE088: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EE08C: 4082FFE8  bne 0x828ee074
	if !ctx.cr[0].eq {
	pc = 0x828EE074; continue 'dispatch;
	}
	// 828EE090: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828EE094: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828EE098: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828EE09C: 419A0024  beq cr6, 0x828ee0c0
	if ctx.cr[6].eq {
	pc = 0x828EE0C0; continue 'dispatch;
	}
	// 828EE0A0: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828EE0A4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828EE0A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EE0AC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828EE0B0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828EE0B4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828EE0B8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EE0BC: 4082FFE8  bne 0x828ee0a4
	if !ctx.cr[0].eq {
	pc = 0x828EE0A4; continue 'dispatch;
	}
	// 828EE0C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828EE0C4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828EE0C8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828EE0CC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828EE0D0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828EE0D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EE0D8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EE0DC: 4BEAAE55  bl 0x82798f30
	ctx.lr = 0x828EE0E0;
	sub_82798F30(ctx, base);
	// 828EE0E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EE0E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EE0E8: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828EE0EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EE0F0: 4E800421  bctrl
	ctx.lr = 0x828EE0F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EE0F4: C0030010  lfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828EE0F8: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828EE0FC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EE100: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EE104: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828EE108: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EE10C: 4E800421  bctrl
	ctx.lr = 0x828EE110;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EE110: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828EE114: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828EE118: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828EE11C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828EE120: 38A00891  li r5, 0x891
	ctx.r[5].s64 = 2193;
	// 828EE124: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828EE128: 4B9D22B1  bl 0x822c03d8
	ctx.lr = 0x828EE12C;
	sub_822C03D8(ctx, base);
	// 828EE12C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828EE130: 41820014  beq 0x828ee144
	if ctx.cr[0].eq {
	pc = 0x828EE144; continue 'dispatch;
	}
	// 828EE134: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828EE138: 4BEAD531  bl 0x8279b668
	ctx.lr = 0x828EE13C;
	sub_8279B668(ctx, base);
	// 828EE13C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EE140: 48000008  b 0x828ee148
	pc = 0x828EE148; continue 'dispatch;
	// 828EE144: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828EE148: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828EE14C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828EE150: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EE154: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EE158: 4BCA9AF9  bl 0x82597c50
	ctx.lr = 0x828EE15C;
	sub_82597C50(ctx, base);
	// 828EE15C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828EE160: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EE164: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EE168: 4B9D1E99  bl 0x822c0000
	ctx.lr = 0x828EE16C;
	sub_822C0000(ctx, base);
	// 828EE16C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828EE170: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EE174: 419A0008  beq cr6, 0x828ee17c
	if ctx.cr[6].eq {
	pc = 0x828EE17C; continue 'dispatch;
	}
	// 828EE178: 4B9D2719  bl 0x822c0890
	ctx.lr = 0x828EE17C;
	sub_822C0890(ctx, base);
	// 828EE17C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828EE180: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EE184: 419A0008  beq cr6, 0x828ee18c
	if ctx.cr[6].eq {
	pc = 0x828EE18C; continue 'dispatch;
	}
	// 828EE188: 4B9D2709  bl 0x822c0890
	ctx.lr = 0x828EE18C;
	sub_822C0890(ctx, base);
	// 828EE18C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828EE190: 419A000C  beq cr6, 0x828ee19c
	if ctx.cr[6].eq {
	pc = 0x828EE19C; continue 'dispatch;
	}
	// 828EE194: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828EE198: 4B9D26F9  bl 0x822c0890
	ctx.lr = 0x828EE19C;
	sub_822C0890(ctx, base);
	// 828EE19C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828EE1A0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828EE1A4: 488BA010  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EE1A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EE1A8 size=144
    let mut pc: u32 = 0x828EE1A8;
    'dispatch: loop {
        match pc {
            0x828EE1A8 => {
    //   block [0x828EE1A8..0x828EE238)
	// 828EE1A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EE1AC: 488B9FB9  bl 0x831a8164
	ctx.lr = 0x828EE1B0;
	sub_831A8130(ctx, base);
	// 828EE1B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EE1B4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EE1B8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828EE1BC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828EE1C0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828EE1C4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828EE1C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828EE1CC: 388B0FF0  addi r4, r11, 0xff0
	ctx.r[4].s64 = ctx.r[11].s64 + 4080;
	// 828EE1D0: 38A00897  li r5, 0x897
	ctx.r[5].s64 = 2199;
	// 828EE1D4: 38600410  li r3, 0x410
	ctx.r[3].s64 = 1040;
	// 828EE1D8: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 828EE1DC: 4850420D  bl 0x82df23e8
	ctx.lr = 0x828EE1E0;
	sub_82DF23E8(ctx, base);
	// 828EE1E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828EE1E4: 41820020  beq 0x828ee204
	if ctx.cr[0].eq {
	pc = 0x828EE204; continue 'dispatch;
	}
	// 828EE1E8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828EE1EC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828EE1F0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828EE1F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EE1F8: 4BFFF3A1  bl 0x828ed598
	ctx.lr = 0x828EE1FC;
	sub_828ED598(ctx, base);
	// 828EE1FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EE200: 48000008  b 0x828ee208
	pc = 0x828EE208; continue 'dispatch;
	// 828EE204: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828EE208: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828EE20C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828EE210: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EE214: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EE218: 4BFF4FE9  bl 0x828e3200
	ctx.lr = 0x828EE21C;
	sub_828E3200(ctx, base);
	// 828EE21C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828EE220: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EE224: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EE228: 4B9D1DD9  bl 0x822c0000
	ctx.lr = 0x828EE22C;
	sub_822C0000(ctx, base);
	// 828EE22C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828EE230: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828EE234: 488B9F80  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EE238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EE238 size=60
    let mut pc: u32 = 0x828EE238;
    'dispatch: loop {
        match pc {
            0x828EE238 => {
    //   block [0x828EE238..0x828EE274)
	// 828EE238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EE23C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EE240: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EE244: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EE248: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EE24C: 48027355  bl 0x829155a0
	ctx.lr = 0x828EE250;
	sub_829155A0(ctx, base);
	// 828EE250: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EE254: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EE258: 396B1F50  addi r11, r11, 0x1f50
	ctx.r[11].s64 = ctx.r[11].s64 + 8016;
	// 828EE25C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828EE260: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828EE264: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EE268: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EE26C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EE270: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EE278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EE278 size=88
    let mut pc: u32 = 0x828EE278;
    'dispatch: loop {
        match pc {
            0x828EE278 => {
    //   block [0x828EE278..0x828EE2D0)
	// 828EE278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EE27C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EE280: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828EE284: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EE288: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EE28C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EE290: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EE294: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EE298: 396B1F50  addi r11, r11, 0x1f50
	ctx.r[11].s64 = ctx.r[11].s64 + 8016;
	// 828EE29C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828EE2A0: 480272E9  bl 0x82915588
	ctx.lr = 0x828EE2A4;
	sub_82915588(ctx, base);
	// 828EE2A4: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EE2A8: 4182000C  beq 0x828ee2b4
	if ctx.cr[0].eq {
	pc = 0x828EE2B4; continue 'dispatch;
	}
	// 828EE2AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EE2B0: 4B9D1FB9  bl 0x822c0268
	ctx.lr = 0x828EE2B4;
	sub_822C0268(ctx, base);
	// 828EE2B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EE2B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EE2BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EE2C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EE2C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828EE2C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EE2CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EE2D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828EE2D0 size=244
    let mut pc: u32 = 0x828EE2D0;
    'dispatch: loop {
        match pc {
            0x828EE2D0 => {
    //   block [0x828EE2D0..0x828EE3C4)
	// 828EE2D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EE2D4: 488B9E8D  bl 0x831a8160
	ctx.lr = 0x828EE2D8;
	sub_831A8130(ctx, base);
	// 828EE2D8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EE2DC: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EE2E0: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 828EE2E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EE2E8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 828EE2EC: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828EE2F0: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 828EE2F4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828EE2F8: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828EE2FC: 485B2435  bl 0x82ea0730
	ctx.lr = 0x828EE300;
	sub_82EA0730(ctx, base);
	// 828EE300: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 828EE304: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828EE308: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 828EE30C: C02A9450  lfs f1, -0x6bb0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EE310: 4862BEE1  bl 0x82f1a1f0
	ctx.lr = 0x828EE314;
	sub_82F1A1F0(ctx, base);
	// 828EE314: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 828EE318: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828EE31C: 4182000C  beq 0x828ee328
	if ctx.cr[0].eq {
	pc = 0x828EE328; continue 'dispatch;
	}
	// 828EE320: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828EE324: 4B9F9F25  bl 0x822e8248
	ctx.lr = 0x828EE328;
	sub_822E8248(ctx, base);
	// 828EE328: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828EE32C: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EE330: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EE334: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EE338: 3BEBAA78  addi r31, r11, -0x5588
	ctx.r[31].s64 = ctx.r[11].s64 + -21896;
	// 828EE33C: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 828EE340: 48526CF1  bl 0x82e15030
	ctx.lr = 0x828EE344;
	sub_82E15030(ctx, base);
	// 828EE344: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828EE348: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828EE34C: 815D00C8  lwz r10, 0xc8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(200 as u32) ) } as u64;
	// 828EE350: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EE354: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828EE358: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EE35C: 80CB6820  lwz r6, 0x6820(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26656 as u32) ) } as u64;
	// 828EE360: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828EE364: 4E800421  bctrl
	ctx.lr = 0x828EE368;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EE368: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828EE36C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828EE370: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EE374: 419A000C  beq cr6, 0x828ee380
	if ctx.cr[6].eq {
	pc = 0x828EE380; continue 'dispatch;
	}
	// 828EE378: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828EE37C: 4B9F9EED  bl 0x822e8268
	ctx.lr = 0x828EE380;
	sub_822E8268(ctx, base);
	// 828EE380: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EE384: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828EE388: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 828EE38C: 389A0004  addi r4, r26, 4
	ctx.r[4].s64 = ctx.r[26].s64 + 4;
	// 828EE390: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EE394: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828EE398: 4BF7CD89  bl 0x8286b120
	ctx.lr = 0x828EE39C;
	sub_8286B120(ctx, base);
	// 828EE39C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828EE3A0: 419A000C  beq cr6, 0x828ee3ac
	if ctx.cr[6].eq {
	pc = 0x828EE3AC; continue 'dispatch;
	}
	// 828EE3A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828EE3A8: 4B9F9EC1  bl 0x822e8268
	ctx.lr = 0x828EE3AC;
	sub_822E8268(ctx, base);
	// 828EE3AC: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EE3B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EE3B4: 419A0008  beq cr6, 0x828ee3bc
	if ctx.cr[6].eq {
	pc = 0x828EE3BC; continue 'dispatch;
	}
	// 828EE3B8: 4B9D24D9  bl 0x822c0890
	ctx.lr = 0x828EE3BC;
	sub_822C0890(ctx, base);
	// 828EE3BC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828EE3C0: 488B9DF0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EE3C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EE3C8 size=60
    let mut pc: u32 = 0x828EE3C8;
    'dispatch: loop {
        match pc {
            0x828EE3C8 => {
    //   block [0x828EE3C8..0x828EE404)
	// 828EE3C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EE3CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EE3D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EE3D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EE3D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EE3DC: 48028AFD  bl 0x82916ed8
	ctx.lr = 0x828EE3E0;
	sub_82916ED8(ctx, base);
	// 828EE3E0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EE3E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EE3E8: 396B1F84  addi r11, r11, 0x1f84
	ctx.r[11].s64 = ctx.r[11].s64 + 8068;
	// 828EE3EC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828EE3F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828EE3F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EE3F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EE3FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EE400: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EE408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EE408 size=84
    let mut pc: u32 = 0x828EE408;
    'dispatch: loop {
        match pc {
            0x828EE408 => {
    //   block [0x828EE408..0x828EE45C)
	// 828EE408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EE40C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EE410: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828EE414: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EE418: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EE41C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828EE420: 3D40832B  lis r10, -0x7cd5
	ctx.r[10].s64 = -2094333952;
	// 828EE424: 3BEB561C  addi r31, r11, 0x561c
	ctx.r[31].s64 = ctx.r[11].s64 + 22044;
	// 828EE428: 3BCAC534  addi r30, r10, -0x3acc
	ctx.r[30].s64 = ctx.r[10].s64 + -15052;
	// 828EE42C: 4BF01355  bl 0x827ef780
	ctx.lr = 0x828EE430;
	sub_827EF780(ctx, base);
	// 828EE430: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828EE434: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828EE438: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828EE43C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828EE440: 488BBB09  bl 0x831a9f48
	ctx.lr = 0x828EE444;
	sub_831A9F48(ctx, base);
	// 828EE444: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EE448: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EE44C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EE450: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828EE454: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EE458: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EE460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EE460 size=88
    let mut pc: u32 = 0x828EE460;
    'dispatch: loop {
        match pc {
            0x828EE460 => {
    //   block [0x828EE460..0x828EE4B8)
	// 828EE460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EE464: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EE468: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828EE46C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EE470: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EE474: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EE478: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EE47C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EE480: 396B1F84  addi r11, r11, 0x1f84
	ctx.r[11].s64 = ctx.r[11].s64 + 8068;
	// 828EE484: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828EE488: 480286E1  bl 0x82916b68
	ctx.lr = 0x828EE48C;
	sub_82916B68(ctx, base);
	// 828EE48C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EE490: 4182000C  beq 0x828ee49c
	if ctx.cr[0].eq {
	pc = 0x828EE49C; continue 'dispatch;
	}
	// 828EE494: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EE498: 4B9D1DD1  bl 0x822c0268
	ctx.lr = 0x828EE49C;
	sub_822C0268(ctx, base);
	// 828EE49C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EE4A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EE4A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EE4A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EE4AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828EE4B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EE4B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EE4B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828EE4B8 size=144
    let mut pc: u32 = 0x828EE4B8;
    'dispatch: loop {
        match pc {
            0x828EE4B8 => {
    //   block [0x828EE4B8..0x828EE548)
	// 828EE4B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EE4BC: 488B9CB1  bl 0x831a816c
	ctx.lr = 0x828EE4C0;
	sub_831A8130(ctx, base);
	// 828EE4C0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828EE4C4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EE4C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EE4CC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828EE4D0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828EE4D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EE4D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EE4DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EE4E0: 4E800421  bctrl
	ctx.lr = 0x828EE4E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EE4E4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828EE4E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EE4EC: 4802827D  bl 0x82916768
	ctx.lr = 0x828EE4F0;
	sub_82916768(ctx, base);
	// 828EE4F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EE4F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EE4F8: 4801B161  bl 0x82909658
	ctx.lr = 0x828EE4FC;
	sub_82909658(ctx, base);
	// 828EE4FC: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828EE500: 13C0E8C7  vcmpequd (lvx128) v30, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828EE504: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EE548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828EE548 size=180
    let mut pc: u32 = 0x828EE548;
    'dispatch: loop {
        match pc {
            0x828EE548 => {
    //   block [0x828EE548..0x828EE5FC)
	// 828EE548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EE54C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EE550: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828EE554: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EE558: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EE55C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EE560: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EE564: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EE568: 48028831  bl 0x82916d98
	ctx.lr = 0x828EE56C;
	sub_82916D98(ctx, base);
	// 828EE56C: 807E0070  lwz r3, 0x70(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 828EE570: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828EE574: 396000D0  li r11, 0xd0
	ctx.r[11].s64 = 208;
	// 828EE578: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 828EE57C: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EE580: 13E958C7  vcmpequd (lvx128) v31, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EE600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EE600 size=216
    let mut pc: u32 = 0x828EE600;
    'dispatch: loop {
        match pc {
            0x828EE600 => {
    //   block [0x828EE600..0x828EE6D8)
	// 828EE600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EE604: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EE608: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828EE60C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EE610: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EE614: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EE618: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EE61C: 4802810D  bl 0x82916728
	ctx.lr = 0x828EE620;
	sub_82916728(ctx, base);
	// 828EE620: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EE624: 809F0070  lwz r4, 0x70(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 828EE628: 4BFF5689  bl 0x828e3cb0
	ctx.lr = 0x828EE62C;
	sub_828E3CB0(ctx, base);
	// 828EE62C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EE630: 48504B81  bl 0x82df31b0
	ctx.lr = 0x828EE634;
	sub_82DF31B0(ctx, base);
	// 828EE634: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828EE638: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EE63C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828EE640: 4BF74A61  bl 0x828630a0
	ctx.lr = 0x828EE644;
	sub_828630A0(ctx, base);
	// 828EE644: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EE648: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828EE64C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EE650: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EE654: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828EE658: 419A0024  beq cr6, 0x828ee67c
	if ctx.cr[6].eq {
	pc = 0x828EE67C; continue 'dispatch;
	}
	// 828EE65C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828EE660: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828EE664: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EE668: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828EE66C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828EE670: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828EE674: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EE678: 4082FFE8  bne 0x828ee660
	if !ctx.cr[0].eq {
	pc = 0x828EE660; continue 'dispatch;
	}
	// 828EE67C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EE680: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828EE684: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828EE688: 388B1148  addi r4, r11, 0x1148
	ctx.r[4].s64 = ctx.r[11].s64 + 4424;
	// 828EE68C: 4BF098ED  bl 0x827f7f78
	ctx.lr = 0x828EE690;
	sub_827F7F78(ctx, base);
	// 828EE690: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828EE694: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EE698: 419A0008  beq cr6, 0x828ee6a0
	if ctx.cr[6].eq {
	pc = 0x828EE6A0; continue 'dispatch;
	}
	// 828EE69C: 4B9D21F5  bl 0x822c0890
	ctx.lr = 0x828EE6A0;
	sub_822C0890(ctx, base);
	// 828EE6A0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828EE6A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EE6A8: 419A0008  beq cr6, 0x828ee6b0
	if ctx.cr[6].eq {
	pc = 0x828EE6B0; continue 'dispatch;
	}
	// 828EE6AC: 4B9D21E5  bl 0x822c0890
	ctx.lr = 0x828EE6B0;
	sub_822C0890(ctx, base);
	// 828EE6B0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828EE6B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EE6B8: 419A0008  beq cr6, 0x828ee6c0
	if ctx.cr[6].eq {
	pc = 0x828EE6C0; continue 'dispatch;
	}
	// 828EE6BC: 4B9D21D5  bl 0x822c0890
	ctx.lr = 0x828EE6C0;
	sub_822C0890(ctx, base);
	// 828EE6C0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828EE6C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EE6C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EE6CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828EE6D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EE6D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EE6D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828EE6D8 size=176
    let mut pc: u32 = 0x828EE6D8;
    'dispatch: loop {
        match pc {
            0x828EE6D8 => {
    //   block [0x828EE6D8..0x828EE788)
	// 828EE6D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EE6DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EE6E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EE6E4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828EE6E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EE6EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EE6F0: 48069DF1  bl 0x829584e0
	ctx.lr = 0x828EE6F4;
	sub_829584E0(ctx, base);
	// 828EE6F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828EE6F8: 387F0174  addi r3, r31, 0x174
	ctx.r[3].s64 = ctx.r[31].s64 + 372;
	// 828EE6FC: C00B9450  lfs f0, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828EE700: D01F0170  stfs f0, 0x170(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 828EE704: 480694F5  bl 0x82957bf8
	ctx.lr = 0x828EE708;
	sub_82957BF8(ctx, base);
	// 828EE708: 387F0184  addi r3, r31, 0x184
	ctx.r[3].s64 = ctx.r[31].s64 + 388;
	// 828EE70C: 480694ED  bl 0x82957bf8
	ctx.lr = 0x828EE710;
	sub_82957BF8(ctx, base);
	// 828EE710: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828EE714: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828EE718: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828EE71C: 387F01A0  addi r3, r31, 0x1a0
	ctx.r[3].s64 = ctx.r[31].s64 + 416;
	// 828EE720: C00BDD6C  lfs f0, -0x2294(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828EE724: C3EA89AC  lfs f31, -0x7654(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828EE728: C1A99524  lfs f13, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828EE72C: D01F0194  stfs f0, 0x194(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 828EE730: D3FF0198  stfs f31, 0x198(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 828EE734: D1BF019C  stfs f13, 0x19c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 828EE738: 480520C1  bl 0x829407f8
	ctx.lr = 0x828EE73C;
	sub_829407F8(ctx, base);
	// 828EE73C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828EE740: D3FF01B0  stfs f31, 0x1b0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), tmp.u32 ) };
	// 828EE744: 387F01C0  addi r3, r31, 0x1c0
	ctx.r[3].s64 = ctx.r[31].s64 + 448;
	// 828EE748: C00BE0B4  lfs f0, -0x1f4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8012 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828EE74C: D01F01B4  stfs f0, 0x1b4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), tmp.u32 ) };
	// 828EE750: D3FF01B8  stfs f31, 0x1b8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 828EE754: D3FF01BC  stfs f31, 0x1bc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), tmp.u32 ) };
	// 828EE758: 4BF15B89  bl 0x828042e0
	ctx.lr = 0x828EE75C;
	sub_828042E0(ctx, base);
	// 828EE75C: 387F01E0  addi r3, r31, 0x1e0
	ctx.r[3].s64 = ctx.r[31].s64 + 480;
	// 828EE760: 4BF15B81  bl 0x828042e0
	ctx.lr = 0x828EE764;
	sub_828042E0(ctx, base);
	// 828EE764: 387F0200  addi r3, r31, 0x200
	ctx.r[3].s64 = ctx.r[31].s64 + 512;
	// 828EE768: 48067059  bl 0x829557c0
	ctx.lr = 0x828EE76C;
	sub_829557C0(ctx, base);
	// 828EE76C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EE770: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EE774: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EE778: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EE77C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828EE780: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EE784: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EE788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828EE788 size=60
    let mut pc: u32 = 0x828EE788;
    'dispatch: loop {
        match pc {
            0x828EE788 => {
    //   block [0x828EE788..0x828EE7C4)
	// 828EE788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EE78C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EE790: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EE794: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EE798: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EE79C: 48069FAD  bl 0x82958748
	ctx.lr = 0x828EE7A0;
	sub_82958748(ctx, base);
	// 828EE7A0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828EE7A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EE7A8: C00B9524  lfs f0, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828EE7AC: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 828EE7B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828EE7B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EE7B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EE7BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EE7C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EE7C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828EE7C8 size=384
    let mut pc: u32 = 0x828EE7C8;
    'dispatch: loop {
        match pc {
            0x828EE7C8 => {
    //   block [0x828EE7C8..0x828EE948)
	// 828EE7C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EE7CC: 488B99A1  bl 0x831a816c
	ctx.lr = 0x828EE7D0;
	sub_831A8130(ctx, base);
	// 828EE7D0: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 828EE7D4: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 828EE7D8: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828EE7DC: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EE7E0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EE7E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EE7E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EE7EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EE7F0: 388B2558  addi r4, r11, 0x2558
	ctx.r[4].s64 = ctx.r[11].s64 + 9560;
	// 828EE7F4: 48505215  bl 0x82df3a08
	ctx.lr = 0x828EE7F8;
	sub_82DF3A08(ctx, base);
	// 828EE7F8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EE7FC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828EE800: 388B254C  addi r4, r11, 0x254c
	ctx.r[4].s64 = ctx.r[11].s64 + 9548;
	// 828EE804: 48505205  bl 0x82df3a08
	ctx.lr = 0x828EE808;
	sub_82DF3A08(ctx, base);
	// 828EE808: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828EE80C: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 828EE810: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EE814: 4BCDBCED  bl 0x825ca500
	ctx.lr = 0x828EE818;
	sub_825CA500(ctx, base);
	// 828EE818: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828EE81C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828EE820: 48504C09  bl 0x82df3428
	ctx.lr = 0x828EE824;
	sub_82DF3428(ctx, base);
	// 828EE824: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EE828: 48504C01  bl 0x82df3428
	ctx.lr = 0x828EE82C;
	sub_82DF3428(ctx, base);
	// 828EE82C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EE830: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828EE834: 388B253C  addi r4, r11, 0x253c
	ctx.r[4].s64 = ctx.r[11].s64 + 9532;
	// 828EE838: 485051D1  bl 0x82df3a08
	ctx.lr = 0x828EE83C;
	sub_82DF3A08(ctx, base);
	// 828EE83C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EE840: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EE844: 388B2534  addi r4, r11, 0x2534
	ctx.r[4].s64 = ctx.r[11].s64 + 9524;
	// 828EE848: 485051C1  bl 0x82df3a08
	ctx.lr = 0x828EE84C;
	sub_82DF3A08(ctx, base);
	// 828EE84C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828EE850: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 828EE854: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828EE858: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828EE85C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828EE860: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828EE864: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EE868: C3CA9A8C  lfs f30, -0x6574(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25972 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828EE86C: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828EE870: C3A908A4  lfs f29, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828EE874: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828EE878: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828EE87C: 4BCB4A2D  bl 0x825a32a8
	ctx.lr = 0x828EE880;
	sub_825A32A8(ctx, base);
	// 828EE880: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828EE884: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EE888: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EE88C: 4BCB2EE5  bl 0x825a1770
	ctx.lr = 0x828EE890;
	sub_825A1770(ctx, base);
	// 828EE890: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 828EE894: 48504B95  bl 0x82df3428
	ctx.lr = 0x828EE898;
	sub_82DF3428(ctx, base);
	// 828EE898: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828EE89C: 4B9DA41D  bl 0x822c8cb8
	ctx.lr = 0x828EE8A0;
	sub_822C8CB8(ctx, base);
	// 828EE8A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EE8A4: 48504B85  bl 0x82df3428
	ctx.lr = 0x828EE8A8;
	sub_82DF3428(ctx, base);
	// 828EE8A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828EE8AC: 48504B7D  bl 0x82df3428
	ctx.lr = 0x828EE8B0;
	sub_82DF3428(ctx, base);
	// 828EE8B0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EE8B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EE8B8: 388B252C  addi r4, r11, 0x252c
	ctx.r[4].s64 = ctx.r[11].s64 + 9516;
	// 828EE8BC: 4850514D  bl 0x82df3a08
	ctx.lr = 0x828EE8C0;
	sub_82DF3A08(ctx, base);
	// 828EE8C0: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828EE8C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828EE8C8: 388B5BC8  addi r4, r11, 0x5bc8
	ctx.r[4].s64 = ctx.r[11].s64 + 23496;
	// 828EE8CC: 4850513D  bl 0x82df3a08
	ctx.lr = 0x828EE8D0;
	sub_82DF3A08(ctx, base);
	// 828EE8D0: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 828EE8D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EE8D8: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828EE8DC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828EE8E0: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828EE8E4: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828EE8E8: 4BCB49C1  bl 0x825a32a8
	ctx.lr = 0x828EE8EC;
	sub_825A32A8(ctx, base);
	// 828EE8EC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828EE8F0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828EE8F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EE8F8: 4BCB2E79  bl 0x825a1770
	ctx.lr = 0x828EE8FC;
	sub_825A1770(ctx, base);
	// 828EE8FC: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 828EE900: 48504B29  bl 0x82df3428
	ctx.lr = 0x828EE904;
	sub_82DF3428(ctx, base);
	// 828EE904: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 828EE908: 4B9DA3B1  bl 0x822c8cb8
	ctx.lr = 0x828EE90C;
	sub_822C8CB8(ctx, base);
	// 828EE90C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828EE910: 48504B19  bl 0x82df3428
	ctx.lr = 0x828EE914;
	sub_82DF3428(ctx, base);
	// 828EE914: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EE918: 48504B11  bl 0x82df3428
	ctx.lr = 0x828EE91C;
	sub_82DF3428(ctx, base);
	// 828EE91C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EE920: 4BCDB3B1  bl 0x825c9cd0
	ctx.lr = 0x828EE924;
	sub_825C9CD0(ctx, base);
	// 828EE924: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EE928: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EE92C: 419A0008  beq cr6, 0x828ee934
	if ctx.cr[6].eq {
	pc = 0x828EE934; continue 'dispatch;
	}
	// 828EE930: 4B9D1F61  bl 0x822c0890
	ctx.lr = 0x828EE934;
	sub_822C0890(ctx, base);
	// 828EE934: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 828EE938: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828EE93C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828EE940: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828EE944: 488B9878  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EE948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828EE948 size=384
    let mut pc: u32 = 0x828EE948;
    'dispatch: loop {
        match pc {
            0x828EE948 => {
    //   block [0x828EE948..0x828EEAC8)
	// 828EE948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EE94C: 488B9821  bl 0x831a816c
	ctx.lr = 0x828EE950;
	sub_831A8130(ctx, base);
	// 828EE950: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 828EE954: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 828EE958: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828EE95C: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EE960: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EE964: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EE968: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EE96C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EE970: 388B2580  addi r4, r11, 0x2580
	ctx.r[4].s64 = ctx.r[11].s64 + 9600;
	// 828EE974: 48505095  bl 0x82df3a08
	ctx.lr = 0x828EE978;
	sub_82DF3A08(ctx, base);
	// 828EE978: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EE97C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828EE980: 388B2574  addi r4, r11, 0x2574
	ctx.r[4].s64 = ctx.r[11].s64 + 9588;
	// 828EE984: 48505085  bl 0x82df3a08
	ctx.lr = 0x828EE988;
	sub_82DF3A08(ctx, base);
	// 828EE988: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828EE98C: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 828EE990: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EE994: 4BCDBB6D  bl 0x825ca500
	ctx.lr = 0x828EE998;
	sub_825CA500(ctx, base);
	// 828EE998: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828EE99C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828EE9A0: 48504A89  bl 0x82df3428
	ctx.lr = 0x828EE9A4;
	sub_82DF3428(ctx, base);
	// 828EE9A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EE9A8: 48504A81  bl 0x82df3428
	ctx.lr = 0x828EE9AC;
	sub_82DF3428(ctx, base);
	// 828EE9AC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EE9B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828EE9B4: 388B253C  addi r4, r11, 0x253c
	ctx.r[4].s64 = ctx.r[11].s64 + 9532;
	// 828EE9B8: 48505051  bl 0x82df3a08
	ctx.lr = 0x828EE9BC;
	sub_82DF3A08(ctx, base);
	// 828EE9BC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EE9C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EE9C4: 388B2534  addi r4, r11, 0x2534
	ctx.r[4].s64 = ctx.r[11].s64 + 9524;
	// 828EE9C8: 48505041  bl 0x82df3a08
	ctx.lr = 0x828EE9CC;
	sub_82DF3A08(ctx, base);
	// 828EE9CC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828EE9D0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 828EE9D4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828EE9D8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828EE9DC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828EE9E0: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828EE9E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EE9E8: C3CA9A8C  lfs f30, -0x6574(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25972 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828EE9EC: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828EE9F0: C3A908A4  lfs f29, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828EE9F4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828EE9F8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828EE9FC: 4BCB48AD  bl 0x825a32a8
	ctx.lr = 0x828EEA00;
	sub_825A32A8(ctx, base);
	// 828EEA00: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828EEA04: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EEA08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EEA0C: 4BCB2D65  bl 0x825a1770
	ctx.lr = 0x828EEA10;
	sub_825A1770(ctx, base);
	// 828EEA10: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 828EEA14: 48504A15  bl 0x82df3428
	ctx.lr = 0x828EEA18;
	sub_82DF3428(ctx, base);
	// 828EEA18: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828EEA1C: 4B9DA29D  bl 0x822c8cb8
	ctx.lr = 0x828EEA20;
	sub_822C8CB8(ctx, base);
	// 828EEA20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EEA24: 48504A05  bl 0x82df3428
	ctx.lr = 0x828EEA28;
	sub_82DF3428(ctx, base);
	// 828EEA28: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828EEA2C: 485049FD  bl 0x82df3428
	ctx.lr = 0x828EEA30;
	sub_82DF3428(ctx, base);
	// 828EEA30: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EEA34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EEA38: 388B2564  addi r4, r11, 0x2564
	ctx.r[4].s64 = ctx.r[11].s64 + 9572;
	// 828EEA3C: 48504FCD  bl 0x82df3a08
	ctx.lr = 0x828EEA40;
	sub_82DF3A08(ctx, base);
	// 828EEA40: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828EEA44: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828EEA48: 388BCACC  addi r4, r11, -0x3534
	ctx.r[4].s64 = ctx.r[11].s64 + -13620;
	// 828EEA4C: 48504FBD  bl 0x82df3a08
	ctx.lr = 0x828EEA50;
	sub_82DF3A08(ctx, base);
	// 828EEA50: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 828EEA54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EEA58: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828EEA5C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828EEA60: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828EEA64: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828EEA68: 4BCB4841  bl 0x825a32a8
	ctx.lr = 0x828EEA6C;
	sub_825A32A8(ctx, base);
	// 828EEA6C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828EEA70: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828EEA74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EEA78: 4BCB2CF9  bl 0x825a1770
	ctx.lr = 0x828EEA7C;
	sub_825A1770(ctx, base);
	// 828EEA7C: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 828EEA80: 485049A9  bl 0x82df3428
	ctx.lr = 0x828EEA84;
	sub_82DF3428(ctx, base);
	// 828EEA84: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 828EEA88: 4B9DA231  bl 0x822c8cb8
	ctx.lr = 0x828EEA8C;
	sub_822C8CB8(ctx, base);
	// 828EEA8C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828EEA90: 48504999  bl 0x82df3428
	ctx.lr = 0x828EEA94;
	sub_82DF3428(ctx, base);
	// 828EEA94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EEA98: 48504991  bl 0x82df3428
	ctx.lr = 0x828EEA9C;
	sub_82DF3428(ctx, base);
	// 828EEA9C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EEAA0: 4BCDB231  bl 0x825c9cd0
	ctx.lr = 0x828EEAA4;
	sub_825C9CD0(ctx, base);
	// 828EEAA4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EEAA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EEAAC: 419A0008  beq cr6, 0x828eeab4
	if ctx.cr[6].eq {
	pc = 0x828EEAB4; continue 'dispatch;
	}
	// 828EEAB0: 4B9D1DE1  bl 0x822c0890
	ctx.lr = 0x828EEAB4;
	sub_822C0890(ctx, base);
	// 828EEAB4: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 828EEAB8: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828EEABC: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828EEAC0: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828EEAC4: 488B96F8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EEAC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828EEAC8 size=1500
    let mut pc: u32 = 0x828EEAC8;
    'dispatch: loop {
        match pc {
            0x828EEAC8 => {
    //   block [0x828EEAC8..0x828EF0A4)
	// 828EEAC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EEACC: 488B969D  bl 0x831a8168
	ctx.lr = 0x828EEAD0;
	sub_831A8130(ctx, base);
	// 828EEAD0: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 828EEAD4: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 828EEAD8: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828EEADC: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EEAE0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828EEAE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EEAE8: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 828EEAEC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EEAF0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EEAF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EEAF8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828EEAFC: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828EEB00: 419A0024  beq cr6, 0x828eeb24
	if ctx.cr[6].eq {
	pc = 0x828EEB24; continue 'dispatch;
	}
	// 828EEB04: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828EEB08: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828EEB0C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EEB10: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828EEB14: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828EEB18: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828EEB1C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EEB20: 4082FFE8  bne 0x828eeb08
	if !ctx.cr[0].eq {
	pc = 0x828EEB08; continue 'dispatch;
	}
	// 828EEB24: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828EEB28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EEB2C: 48069CED  bl 0x82958818
	ctx.lr = 0x828EEB30;
	sub_82958818(ctx, base);
	// 828EEB30: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828EEB34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EEB38: 388B3D90  addi r4, r11, 0x3d90
	ctx.r[4].s64 = ctx.r[11].s64 + 15760;
	// 828EEB3C: 48504ECD  bl 0x82df3a08
	ctx.lr = 0x828EEB40;
	sub_82DF3A08(ctx, base);
	// 828EEB40: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828EEB44: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828EEB48: 388B3D88  addi r4, r11, 0x3d88
	ctx.r[4].s64 = ctx.r[11].s64 + 15752;
	// 828EEB4C: 48504EBD  bl 0x82df3a08
	ctx.lr = 0x828EEB50;
	sub_82DF3A08(ctx, base);
	// 828EEB50: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828EEB54: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828EEB58: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EEB5C: 4BCDB9A5  bl 0x825ca500
	ctx.lr = 0x828EEB60;
	sub_825CA500(ctx, base);
	// 828EEB60: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828EEB64: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828EEB68: 485048C1  bl 0x82df3428
	ctx.lr = 0x828EEB6C;
	sub_82DF3428(ctx, base);
	// 828EEB6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EEB70: 485048B9  bl 0x82df3428
	ctx.lr = 0x828EEB74;
	sub_82DF3428(ctx, base);
	// 828EEB74: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EEB78: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EEB7C: 388B8244  addi r4, r11, -0x7dbc
	ctx.r[4].s64 = ctx.r[11].s64 + -32188;
	// 828EEB80: 48504E89  bl 0x82df3a08
	ctx.lr = 0x828EEB84;
	sub_82DF3A08(ctx, base);
	// 828EEB84: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EEB88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EEB8C: 388B8230  addi r4, r11, -0x7dd0
	ctx.r[4].s64 = ctx.r[11].s64 + -32208;
	// 828EEB90: 48504E79  bl 0x82df3a08
	ctx.lr = 0x828EEB94;
	sub_82DF3A08(ctx, base);
	// 828EEB94: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828EEB98: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828EEB9C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828EEBA0: 38BF0170  addi r5, r31, 0x170
	ctx.r[5].s64 = ctx.r[31].s64 + 368;
	// 828EEBA4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828EEBA8: C3EA08A8  lfs f31, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828EEBAC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828EEBB0: C3C908A4  lfs f30, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828EEBB4: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 828EEBB8: C06B9F7C  lfs f3, -0x6084(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24708 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828EEBBC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828EEBC0: 4BCB46E9  bl 0x825a32a8
	ctx.lr = 0x828EEBC4;
	sub_825A32A8(ctx, base);
	// 828EEBC4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828EEBC8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828EEBCC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EEBD0: 4BCB2BA1  bl 0x825a1770
	ctx.lr = 0x828EEBD4;
	sub_825A1770(ctx, base);
	// 828EEBD4: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 828EEBD8: 48504851  bl 0x82df3428
	ctx.lr = 0x828EEBDC;
	sub_82DF3428(ctx, base);
	// 828EEBDC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828EEBE0: 4B9DA0D9  bl 0x822c8cb8
	ctx.lr = 0x828EEBE4;
	sub_822C8CB8(ctx, base);
	// 828EEBE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EEBE8: 48504841  bl 0x82df3428
	ctx.lr = 0x828EEBEC;
	sub_82DF3428(ctx, base);
	// 828EEBEC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EEBF0: 48504839  bl 0x82df3428
	ctx.lr = 0x828EEBF4;
	sub_82DF3428(ctx, base);
	// 828EEBF4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EEBF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EEBFC: 388B2614  addi r4, r11, 0x2614
	ctx.r[4].s64 = ctx.r[11].s64 + 9748;
	// 828EEC00: 48504E09  bl 0x82df3a08
	ctx.lr = 0x828EEC04;
	sub_82DF3A08(ctx, base);
	// 828EEC04: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EEC08: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EEC0C: 388B2604  addi r4, r11, 0x2604
	ctx.r[4].s64 = ctx.r[11].s64 + 9732;
	// 828EEC10: 48504DF9  bl 0x82df3a08
	ctx.lr = 0x828EEC14;
	sub_82DF3A08(ctx, base);
	// 828EEC14: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 828EEC18: 38BF0194  addi r5, r31, 0x194
	ctx.r[5].s64 = ctx.r[31].s64 + 404;
	// 828EEC1C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828EEC20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EEC24: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828EEC28: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828EEC2C: C3AB9A8C  lfs f29, -0x6574(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25972 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828EEC30: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 828EEC34: 4BCB4675  bl 0x825a32a8
	ctx.lr = 0x828EEC38;
	sub_825A32A8(ctx, base);
	// 828EEC38: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828EEC3C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828EEC40: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828EEC44: 4BCB2B2D  bl 0x825a1770
	ctx.lr = 0x828EEC48;
	sub_825A1770(ctx, base);
	// 828EEC48: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 828EEC4C: 485047DD  bl 0x82df3428
	ctx.lr = 0x828EEC50;
	sub_82DF3428(ctx, base);
	// 828EEC50: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 828EEC54: 4B9DA065  bl 0x822c8cb8
	ctx.lr = 0x828EEC58;
	sub_822C8CB8(ctx, base);
	// 828EEC58: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EEC5C: 485047CD  bl 0x82df3428
	ctx.lr = 0x828EEC60;
	sub_82DF3428(ctx, base);
	// 828EEC60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EEC64: 485047C5  bl 0x82df3428
	ctx.lr = 0x828EEC68;
	sub_82DF3428(ctx, base);
	// 828EEC68: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EEC6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EEC70: 388B25E8  addi r4, r11, 0x25e8
	ctx.r[4].s64 = ctx.r[11].s64 + 9704;
	// 828EEC74: 48504D95  bl 0x82df3a08
	ctx.lr = 0x828EEC78;
	sub_82DF3A08(ctx, base);
	// 828EEC78: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EEC7C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EEC80: 388B25D4  addi r4, r11, 0x25d4
	ctx.r[4].s64 = ctx.r[11].s64 + 9684;
	// 828EEC84: 48504D85  bl 0x82df3a08
	ctx.lr = 0x828EEC88;
	sub_82DF3A08(ctx, base);
	// 828EEC88: 38BF0198  addi r5, r31, 0x198
	ctx.r[5].s64 = ctx.r[31].s64 + 408;
	// 828EEC8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EEC90: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828EEC94: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828EEC98: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 828EEC9C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828EECA0: 4BCB4609  bl 0x825a32a8
	ctx.lr = 0x828EECA4;
	sub_825A32A8(ctx, base);
	// 828EECA4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828EECA8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828EECAC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828EECB0: 4BCB2AC1  bl 0x825a1770
	ctx.lr = 0x828EECB4;
	sub_825A1770(ctx, base);
	// 828EECB4: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 828EECB8: 48504771  bl 0x82df3428
	ctx.lr = 0x828EECBC;
	sub_82DF3428(ctx, base);
	// 828EECBC: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828EECC0: 4B9D9FF9  bl 0x822c8cb8
	ctx.lr = 0x828EECC4;
	sub_822C8CB8(ctx, base);
	// 828EECC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EECC8: 48504761  bl 0x82df3428
	ctx.lr = 0x828EECCC;
	sub_82DF3428(ctx, base);
	// 828EECCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EECD0: 48504759  bl 0x82df3428
	ctx.lr = 0x828EECD4;
	sub_82DF3428(ctx, base);
	// 828EECD4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EECD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EECDC: 388B25BC  addi r4, r11, 0x25bc
	ctx.r[4].s64 = ctx.r[11].s64 + 9660;
	// 828EECE0: 48504D29  bl 0x82df3a08
	ctx.lr = 0x828EECE4;
	sub_82DF3A08(ctx, base);
	// 828EECE4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EECE8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EECEC: 388B25AC  addi r4, r11, 0x25ac
	ctx.r[4].s64 = ctx.r[11].s64 + 9644;
	// 828EECF0: 48504D19  bl 0x82df3a08
	ctx.lr = 0x828EECF4;
	sub_82DF3A08(ctx, base);
	// 828EECF4: 38BF019C  addi r5, r31, 0x19c
	ctx.r[5].s64 = ctx.r[31].s64 + 412;
	// 828EECF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EECFC: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828EED00: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 828EED04: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 828EED08: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828EED0C: 4BCB459D  bl 0x825a32a8
	ctx.lr = 0x828EED10;
	sub_825A32A8(ctx, base);
	// 828EED10: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828EED14: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828EED18: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828EED1C: 4BCB2A55  bl 0x825a1770
	ctx.lr = 0x828EED20;
	sub_825A1770(ctx, base);
	// 828EED20: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 828EED24: 48504705  bl 0x82df3428
	ctx.lr = 0x828EED28;
	sub_82DF3428(ctx, base);
	// 828EED28: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 828EED2C: 4B9D9F8D  bl 0x822c8cb8
	ctx.lr = 0x828EED30;
	sub_822C8CB8(ctx, base);
	// 828EED30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EED34: 485046F5  bl 0x82df3428
	ctx.lr = 0x828EED38;
	sub_82DF3428(ctx, base);
	// 828EED38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EED3C: 485046ED  bl 0x82df3428
	ctx.lr = 0x828EED40;
	sub_82DF3428(ctx, base);
	// 828EED40: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EED44: 4BCDAF8D  bl 0x825c9cd0
	ctx.lr = 0x828EED48;
	sub_825C9CD0(ctx, base);
	// 828EED48: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EED4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EED50: 388B25A4  addi r4, r11, 0x25a4
	ctx.r[4].s64 = ctx.r[11].s64 + 9636;
	// 828EED54: 48504CB5  bl 0x82df3a08
	ctx.lr = 0x828EED58;
	sub_82DF3A08(ctx, base);
	// 828EED58: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828EED5C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EED60: 388B5D2C  addi r4, r11, 0x5d2c
	ctx.r[4].s64 = ctx.r[11].s64 + 23852;
	// 828EED64: 48504CA5  bl 0x82df3a08
	ctx.lr = 0x828EED68;
	sub_82DF3A08(ctx, base);
	// 828EED68: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EED6C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EED70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EED74: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828EED78: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828EED7C: 419A0024  beq cr6, 0x828eeda0
	if ctx.cr[6].eq {
	pc = 0x828EEDA0; continue 'dispatch;
	}
	// 828EED80: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828EED84: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828EED88: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EED8C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828EED90: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828EED94: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828EED98: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EED9C: 4082FFE8  bne 0x828eed84
	if !ctx.cr[0].eq {
	pc = 0x828EED84; continue 'dispatch;
	}
	// 828EEDA0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828EEDA4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828EEDA8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828EEDAC: 387F0174  addi r3, r31, 0x174
	ctx.r[3].s64 = ctx.r[31].s64 + 372;
	// 828EEDB0: 48068E61  bl 0x82957c10
	ctx.lr = 0x828EEDB4;
	sub_82957C10(ctx, base);
	// 828EEDB4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EEDB8: 48504671  bl 0x82df3428
	ctx.lr = 0x828EEDBC;
	sub_82DF3428(ctx, base);
	// 828EEDBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EEDC0: 48504669  bl 0x82df3428
	ctx.lr = 0x828EEDC4;
	sub_82DF3428(ctx, base);
	// 828EEDC4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828EEDC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EEDCC: 388B3C80  addi r4, r11, 0x3c80
	ctx.r[4].s64 = ctx.r[11].s64 + 15488;
	// 828EEDD0: 48504C39  bl 0x82df3a08
	ctx.lr = 0x828EEDD4;
	sub_82DF3A08(ctx, base);
	// 828EEDD4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828EEDD8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EEDDC: 388B7C94  addi r4, r11, 0x7c94
	ctx.r[4].s64 = ctx.r[11].s64 + 31892;
	// 828EEDE0: 48504C29  bl 0x82df3a08
	ctx.lr = 0x828EEDE4;
	sub_82DF3A08(ctx, base);
	// 828EEDE4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EEDE8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EEDEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EEDF0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828EEDF4: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828EEDF8: 419A0024  beq cr6, 0x828eee1c
	if ctx.cr[6].eq {
	pc = 0x828EEE1C; continue 'dispatch;
	}
	// 828EEDFC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828EEE00: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828EEE04: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EEE08: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828EEE0C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828EEE10: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828EEE14: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EEE18: 4082FFE8  bne 0x828eee00
	if !ctx.cr[0].eq {
	pc = 0x828EEE00; continue 'dispatch;
	}
	// 828EEE1C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828EEE20: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828EEE24: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828EEE28: 387F0184  addi r3, r31, 0x184
	ctx.r[3].s64 = ctx.r[31].s64 + 388;
	// 828EEE2C: 48068DE5  bl 0x82957c10
	ctx.lr = 0x828EEE30;
	sub_82957C10(ctx, base);
	// 828EEE30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EEE34: 485045F5  bl 0x82df3428
	ctx.lr = 0x828EEE38;
	sub_82DF3428(ctx, base);
	// 828EEE38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EEE3C: 485045ED  bl 0x82df3428
	ctx.lr = 0x828EEE40;
	sub_82DF3428(ctx, base);
	// 828EEE40: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EEE44: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EEE48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EEE4C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828EEE50: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828EEE54: 419A0024  beq cr6, 0x828eee78
	if ctx.cr[6].eq {
	pc = 0x828EEE78; continue 'dispatch;
	}
	// 828EEE58: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828EEE5C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828EEE60: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EEE64: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828EEE68: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828EEE6C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828EEE70: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EEE74: 4082FFE8  bne 0x828eee5c
	if !ctx.cr[0].eq {
	pc = 0x828EEE5C; continue 'dispatch;
	}
	// 828EEE78: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828EEE7C: 387F01A0  addi r3, r31, 0x1a0
	ctx.r[3].s64 = ctx.r[31].s64 + 416;
	// 828EEE80: 48051DC1  bl 0x82940c40
	ctx.lr = 0x828EEE84;
	sub_82940C40(ctx, base);
	// 828EEE84: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EEE88: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EEE8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EEE90: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828EEE94: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828EEE98: 419A0024  beq cr6, 0x828eeebc
	if ctx.cr[6].eq {
	pc = 0x828EEEBC; continue 'dispatch;
	}
	// 828EEE9C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828EEEA0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828EEEA4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EEEA8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828EEEAC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828EEEB0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828EEEB4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EEEB8: 4082FFE8  bne 0x828eeea0
	if !ctx.cr[0].eq {
	pc = 0x828EEEA0; continue 'dispatch;
	}
	// 828EEEBC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828EEEC0: 387F01B0  addi r3, r31, 0x1b0
	ctx.r[3].s64 = ctx.r[31].s64 + 432;
	// 828EEEC4: 4BFFF905  bl 0x828ee7c8
	ctx.lr = 0x828EEEC8;
	sub_828EE7C8(ctx, base);
	// 828EEEC8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EEECC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EEED0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EEED4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828EEED8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828EEEDC: 419A0024  beq cr6, 0x828eef00
	if ctx.cr[6].eq {
	pc = 0x828EEF00; continue 'dispatch;
	}
	// 828EEEE0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828EEEE4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828EEEE8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EEEEC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828EEEF0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828EEEF4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828EEEF8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EEEFC: 4082FFE8  bne 0x828eeee4
	if !ctx.cr[0].eq {
	pc = 0x828EEEE4; continue 'dispatch;
	}
	// 828EEF00: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828EEF04: 387F01B8  addi r3, r31, 0x1b8
	ctx.r[3].s64 = ctx.r[31].s64 + 440;
	// 828EEF08: 4BFFFA41  bl 0x828ee948
	ctx.lr = 0x828EEF0C;
	sub_828EE948(ctx, base);
	// 828EEF0C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EEF10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EEF14: 388B259C  addi r4, r11, 0x259c
	ctx.r[4].s64 = ctx.r[11].s64 + 9628;
	// 828EEF18: 48504AF1  bl 0x82df3a08
	ctx.lr = 0x828EEF1C;
	sub_82DF3A08(ctx, base);
	// 828EEF1C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EEF20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EEF24: 388B2500  addi r4, r11, 0x2500
	ctx.r[4].s64 = ctx.r[11].s64 + 9472;
	// 828EEF28: 48504AE1  bl 0x82df3a08
	ctx.lr = 0x828EEF2C;
	sub_82DF3A08(ctx, base);
	// 828EEF2C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EEF30: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EEF34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EEF38: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828EEF3C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828EEF40: 419A0024  beq cr6, 0x828eef64
	if ctx.cr[6].eq {
	pc = 0x828EEF64; continue 'dispatch;
	}
	// 828EEF44: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828EEF48: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828EEF4C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EEF50: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828EEF54: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828EEF58: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828EEF5C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EEF60: 4082FFE8  bne 0x828eef48
	if !ctx.cr[0].eq {
	pc = 0x828EEF48; continue 'dispatch;
	}
	// 828EEF64: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828EEF68: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828EEF6C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828EEF70: 387F01C0  addi r3, r31, 0x1c0
	ctx.r[3].s64 = ctx.r[31].s64 + 448;
	// 828EEF74: 4BF1593D  bl 0x828048b0
	ctx.lr = 0x828EEF78;
	sub_828048B0(ctx, base);
	// 828EEF78: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EEF7C: 485044AD  bl 0x82df3428
	ctx.lr = 0x828EEF80;
	sub_82DF3428(ctx, base);
	// 828EEF80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EEF84: 485044A5  bl 0x82df3428
	ctx.lr = 0x828EEF88;
	sub_82DF3428(ctx, base);
	// 828EEF88: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EEF8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EEF90: 388B2594  addi r4, r11, 0x2594
	ctx.r[4].s64 = ctx.r[11].s64 + 9620;
	// 828EEF94: 48504A75  bl 0x82df3a08
	ctx.lr = 0x828EEF98;
	sub_82DF3A08(ctx, base);
	// 828EEF98: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EEF9C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EEFA0: 388B24F0  addi r4, r11, 0x24f0
	ctx.r[4].s64 = ctx.r[11].s64 + 9456;
	// 828EEFA4: 48504A65  bl 0x82df3a08
	ctx.lr = 0x828EEFA8;
	sub_82DF3A08(ctx, base);
	// 828EEFA8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EEFAC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EEFB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EEFB4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828EEFB8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828EEFBC: 419A0024  beq cr6, 0x828eefe0
	if ctx.cr[6].eq {
	pc = 0x828EEFE0; continue 'dispatch;
	}
	// 828EEFC0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828EEFC4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828EEFC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EEFCC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828EEFD0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828EEFD4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828EEFD8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EEFDC: 4082FFE8  bne 0x828eefc4
	if !ctx.cr[0].eq {
	pc = 0x828EEFC4; continue 'dispatch;
	}
	// 828EEFE0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828EEFE4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828EEFE8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828EEFEC: 387F01E0  addi r3, r31, 0x1e0
	ctx.r[3].s64 = ctx.r[31].s64 + 480;
	// 828EEFF0: 4BF158C1  bl 0x828048b0
	ctx.lr = 0x828EEFF4;
	sub_828048B0(ctx, base);
	// 828EEFF4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EEFF8: 48504431  bl 0x82df3428
	ctx.lr = 0x828EEFFC;
	sub_82DF3428(ctx, base);
	// 828EEFFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF000: 48504429  bl 0x82df3428
	ctx.lr = 0x828EF004;
	sub_82DF3428(ctx, base);
	// 828EF004: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EF008: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF00C: 388B81F4  addi r4, r11, -0x7e0c
	ctx.r[4].s64 = ctx.r[11].s64 + -32268;
	// 828EF010: 485049F9  bl 0x82df3a08
	ctx.lr = 0x828EF014;
	sub_82DF3A08(ctx, base);
	// 828EF014: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828EF018: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EF01C: 388BA2C4  addi r4, r11, -0x5d3c
	ctx.r[4].s64 = ctx.r[11].s64 + -23868;
	// 828EF020: 485049E9  bl 0x82df3a08
	ctx.lr = 0x828EF024;
	sub_82DF3A08(ctx, base);
	// 828EF024: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EF028: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EF02C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EF030: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828EF034: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828EF038: 419A0024  beq cr6, 0x828ef05c
	if ctx.cr[6].eq {
	pc = 0x828EF05C; continue 'dispatch;
	}
	// 828EF03C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828EF040: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828EF044: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EF048: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828EF04C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828EF050: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828EF054: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EF058: 4082FFE8  bne 0x828ef040
	if !ctx.cr[0].eq {
	pc = 0x828EF040; continue 'dispatch;
	}
	// 828EF05C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828EF060: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828EF064: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828EF068: 387F0200  addi r3, r31, 0x200
	ctx.r[3].s64 = ctx.r[31].s64 + 512;
	// 828EF06C: 4806680D  bl 0x82955878
	ctx.lr = 0x828EF070;
	sub_82955878(ctx, base);
	// 828EF070: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EF074: 485043B5  bl 0x82df3428
	ctx.lr = 0x828EF078;
	sub_82DF3428(ctx, base);
	// 828EF078: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF07C: 485043AD  bl 0x82df3428
	ctx.lr = 0x828EF080;
	sub_82DF3428(ctx, base);
	// 828EF080: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EF084: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EF088: 419A0008  beq cr6, 0x828ef090
	if ctx.cr[6].eq {
	pc = 0x828EF090; continue 'dispatch;
	}
	// 828EF08C: 4B9D1805  bl 0x822c0890
	ctx.lr = 0x828EF090;
	sub_822C0890(ctx, base);
	// 828EF090: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 828EF094: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 828EF098: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828EF09C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828EF0A0: 488B9118  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EF0A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EF0A8 size=696
    let mut pc: u32 = 0x828EF0A8;
    'dispatch: loop {
        match pc {
            0x828EF0A8 => {
    //   block [0x828EF0A8..0x828EF360)
	// 828EF0A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EF0AC: 488B90BD  bl 0x831a8168
	ctx.lr = 0x828EF0B0;
	sub_831A8130(ctx, base);
	// 828EF0B0: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EF0B4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828EF0B8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828EF0BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828EF0C0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828EF0C4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828EF0C8: 419A0290  beq cr6, 0x828ef358
	if ctx.cr[6].eq {
	pc = 0x828EF358; continue 'dispatch;
	}
	// 828EF0CC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828EF0D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF0D4: 388B12B0  addi r4, r11, 0x12b0
	ctx.r[4].s64 = ctx.r[11].s64 + 4784;
	// 828EF0D8: 48504931  bl 0x82df3a08
	ctx.lr = 0x828EF0DC;
	sub_82DF3A08(ctx, base);
	// 828EF0DC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 828EF0E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EF0E4: 388BBE80  addi r4, r11, -0x4180
	ctx.r[4].s64 = ctx.r[11].s64 + -16768;
	// 828EF0E8: 48504921  bl 0x82df3a08
	ctx.lr = 0x828EF0EC;
	sub_82DF3A08(ctx, base);
	// 828EF0EC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 828EF0F0: 38E00009  li r7, 9
	ctx.r[7].s64 = 9;
	// 828EF0F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828EF0F8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828EF0FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EF100: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828EF104: 4BCBEA8D  bl 0x825adb90
	ctx.lr = 0x828EF108;
	sub_825ADB90(ctx, base);
	// 828EF108: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828EF10C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828EF110: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EF114: 4BCB2CA5  bl 0x825a1db8
	ctx.lr = 0x828EF118;
	sub_825A1DB8(ctx, base);
	// 828EF118: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 828EF11C: 4850430D  bl 0x82df3428
	ctx.lr = 0x828EF120;
	sub_82DF3428(ctx, base);
	// 828EF120: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828EF124: 4B9D9B95  bl 0x822c8cb8
	ctx.lr = 0x828EF128;
	sub_822C8CB8(ctx, base);
	// 828EF128: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EF12C: 485042FD  bl 0x82df3428
	ctx.lr = 0x828EF130;
	sub_82DF3428(ctx, base);
	// 828EF130: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF134: 485042F5  bl 0x82df3428
	ctx.lr = 0x828EF138;
	sub_82DF3428(ctx, base);
	// 828EF138: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 828EF13C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EF140: 388BBE9C  addi r4, r11, -0x4164
	ctx.r[4].s64 = ctx.r[11].s64 + -16740;
	// 828EF144: 485048C5  bl 0x82df3a08
	ctx.lr = 0x828EF148;
	sub_82DF3A08(ctx, base);
	// 828EF148: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828EF14C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF150: 388B4858  addi r4, r11, 0x4858
	ctx.r[4].s64 = ctx.r[11].s64 + 18520;
	// 828EF154: 485048B5  bl 0x82df3a08
	ctx.lr = 0x828EF158;
	sub_82DF3A08(ctx, base);
	// 828EF158: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828EF15C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828EF160: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828EF164: 38BE0004  addi r5, r30, 4
	ctx.r[5].s64 = ctx.r[30].s64 + 4;
	// 828EF168: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828EF16C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828EF170: 4BCBEA21  bl 0x825adb90
	ctx.lr = 0x828EF174;
	sub_825ADB90(ctx, base);
	// 828EF174: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828EF178: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EF17C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EF180: 4BCB2C39  bl 0x825a1db8
	ctx.lr = 0x828EF184;
	sub_825A1DB8(ctx, base);
	// 828EF184: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 828EF188: 485042A1  bl 0x82df3428
	ctx.lr = 0x828EF18C;
	sub_82DF3428(ctx, base);
	// 828EF18C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828EF190: 4B9D9B29  bl 0x822c8cb8
	ctx.lr = 0x828EF194;
	sub_822C8CB8(ctx, base);
	// 828EF194: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF198: 48504291  bl 0x82df3428
	ctx.lr = 0x828EF19C;
	sub_82DF3428(ctx, base);
	// 828EF19C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EF1A0: 48504289  bl 0x82df3428
	ctx.lr = 0x828EF1A4;
	sub_82DF3428(ctx, base);
	// 828EF1A4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EF1A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828EF1AC: 388B2628  addi r4, r11, 0x2628
	ctx.r[4].s64 = ctx.r[11].s64 + 9768;
	// 828EF1B0: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828EF1B4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828EF1B8: 4B9D1221  bl 0x822c03d8
	ctx.lr = 0x828EF1BC;
	sub_822C03D8(ctx, base);
	// 828EF1BC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828EF1C0: 41820034  beq 0x828ef1f4
	if ctx.cr[0].eq {
	pc = 0x828EF1F4; continue 'dispatch;
	}
	// 828EF1C4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828EF1C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF1CC: 388B3DD4  addi r4, r11, 0x3dd4
	ctx.r[4].s64 = ctx.r[11].s64 + 15828;
	// 828EF1D0: 48504839  bl 0x82df3a08
	ctx.lr = 0x828EF1D4;
	sub_82DF3A08(ctx, base);
	// 828EF1D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828EF1D8: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 828EF1DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EF1E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EF1E4: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 828EF1E8: 4BCBD229  bl 0x825ac410
	ctx.lr = 0x828EF1EC;
	sub_825AC410(ctx, base);
	// 828EF1EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EF1F0: 48000008  b 0x828ef1f8
	pc = 0x828EF1F8; continue 'dispatch;
	// 828EF1F4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828EF1F8: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828EF1FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EF200: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828EF204: 4BC041B5  bl 0x824f33b8
	ctx.lr = 0x828EF208;
	sub_824F33B8(ctx, base);
	// 828EF208: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828EF20C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EF210: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828EF214: 4B9D0DED  bl 0x822c0000
	ctx.lr = 0x828EF218;
	sub_822C0000(ctx, base);
	// 828EF218: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EF21C: 4182000C  beq 0x828ef228
	if ctx.cr[0].eq {
	pc = 0x828EF228; continue 'dispatch;
	}
	// 828EF220: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF224: 48504205  bl 0x82df3428
	ctx.lr = 0x828EF228;
	sub_82DF3428(ctx, base);
	// 828EF228: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828EF22C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF230: 388B3DCC  addi r4, r11, 0x3dcc
	ctx.r[4].s64 = ctx.r[11].s64 + 15820;
	// 828EF234: 485047D5  bl 0x82df3a08
	ctx.lr = 0x828EF238;
	sub_82DF3A08(ctx, base);
	// 828EF238: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828EF23C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828EF240: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828EF244: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828EF248: 4BCBCB79  bl 0x825abdc0
	ctx.lr = 0x828EF24C;
	sub_825ABDC0(ctx, base);
	// 828EF24C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF250: 485041D9  bl 0x82df3428
	ctx.lr = 0x828EF254;
	sub_82DF3428(ctx, base);
	// 828EF254: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828EF258: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF25C: 388B3DC4  addi r4, r11, 0x3dc4
	ctx.r[4].s64 = ctx.r[11].s64 + 15812;
	// 828EF260: 485047A9  bl 0x82df3a08
	ctx.lr = 0x828EF264;
	sub_82DF3A08(ctx, base);
	// 828EF264: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828EF268: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828EF26C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828EF270: 4BCBCB51  bl 0x825abdc0
	ctx.lr = 0x828EF274;
	sub_825ABDC0(ctx, base);
	// 828EF274: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF278: 485041B1  bl 0x82df3428
	ctx.lr = 0x828EF27C;
	sub_82DF3428(ctx, base);
	// 828EF27C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828EF280: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF284: 388B3D98  addi r4, r11, 0x3d98
	ctx.r[4].s64 = ctx.r[11].s64 + 15768;
	// 828EF288: 48504781  bl 0x82df3a08
	ctx.lr = 0x828EF28C;
	sub_82DF3A08(ctx, base);
	// 828EF28C: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828EF290: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 828EF294: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828EF298: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828EF29C: 419A0024  beq cr6, 0x828ef2c0
	if ctx.cr[6].eq {
	pc = 0x828EF2C0; continue 'dispatch;
	}
	// 828EF2A0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828EF2A4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828EF2A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EF2AC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828EF2B0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828EF2B4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828EF2B8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EF2BC: 4082FFE8  bne 0x828ef2a4
	if !ctx.cr[0].eq {
	pc = 0x828EF2A4; continue 'dispatch;
	}
	// 828EF2C0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828EF2C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EF2C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EF2CC: 4BCB2E45  bl 0x825a2110
	ctx.lr = 0x828EF2D0;
	sub_825A2110(ctx, base);
	// 828EF2D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF2D4: 48504155  bl 0x82df3428
	ctx.lr = 0x828EF2D8;
	sub_82DF3428(ctx, base);
	// 828EF2D8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828EF2DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EF2E0: 388B9D24  addi r4, r11, -0x62dc
	ctx.r[4].s64 = ctx.r[11].s64 + -25308;
	// 828EF2E4: 48504725  bl 0x82df3a08
	ctx.lr = 0x828EF2E8;
	sub_82DF3A08(ctx, base);
	// 828EF2E8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828EF2EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF2F0: 388B9B58  addi r4, r11, -0x64a8
	ctx.r[4].s64 = ctx.r[11].s64 + -25768;
	// 828EF2F4: 48504715  bl 0x82df3a08
	ctx.lr = 0x828EF2F8;
	sub_82DF3A08(ctx, base);
	// 828EF2F8: 3CE00001  lis r7, 1
	ctx.r[7].s64 = 65536;
	// 828EF2FC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 828EF300: 60E7869F  ori r7, r7, 0x869f
	ctx.r[7].u64 = ctx.r[7].u64 | 34463;
	// 828EF304: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828EF308: 38BE000C  addi r5, r30, 0xc
	ctx.r[5].s64 = ctx.r[30].s64 + 12;
	// 828EF30C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828EF310: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828EF314: 4BCBE87D  bl 0x825adb90
	ctx.lr = 0x828EF318;
	sub_825ADB90(ctx, base);
	// 828EF318: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828EF31C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EF320: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EF324: 4BCB2A95  bl 0x825a1db8
	ctx.lr = 0x828EF328;
	sub_825A1DB8(ctx, base);
	// 828EF328: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 828EF32C: 485040FD  bl 0x82df3428
	ctx.lr = 0x828EF330;
	sub_82DF3428(ctx, base);
	// 828EF330: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 828EF334: 4B9D9985  bl 0x822c8cb8
	ctx.lr = 0x828EF338;
	sub_822C8CB8(ctx, base);
	// 828EF338: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF33C: 485040ED  bl 0x82df3428
	ctx.lr = 0x828EF340;
	sub_82DF3428(ctx, base);
	// 828EF340: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EF344: 485040E5  bl 0x82df3428
	ctx.lr = 0x828EF348;
	sub_82DF3428(ctx, base);
	// 828EF348: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828EF34C: 419A000C  beq cr6, 0x828ef358
	if ctx.cr[6].eq {
	pc = 0x828EF358; continue 'dispatch;
	}
	// 828EF350: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EF354: 4B9D153D  bl 0x822c0890
	ctx.lr = 0x828EF358;
	sub_822C0890(ctx, base);
	// 828EF358: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 828EF35C: 488B8E5C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EF360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828EF360 size=312
    let mut pc: u32 = 0x828EF360;
    'dispatch: loop {
        match pc {
            0x828EF360 => {
    //   block [0x828EF360..0x828EF498)
	// 828EF360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EF364: 488B8E05  bl 0x831a8168
	ctx.lr = 0x828EF368;
	sub_831A8130(ctx, base);
	// 828EF368: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EF36C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828EF370: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828EF374: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 828EF378: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EF37C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EF380: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EF384: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828EF388: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828EF38C: 419A0024  beq cr6, 0x828ef3b0
	if ctx.cr[6].eq {
	pc = 0x828EF3B0; continue 'dispatch;
	}
	// 828EF390: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828EF394: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828EF398: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EF39C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828EF3A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828EF3A4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828EF3A8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828EF3AC: 4082FFE8  bne 0x828ef394
	if !ctx.cr[0].eq {
	pc = 0x828EF394; continue 'dispatch;
	}
	// 828EF3B0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828EF3B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EF3B8: 4806A1C9  bl 0x82959580
	ctx.lr = 0x828EF3BC;
	sub_82959580(ctx, base);
	// 828EF3BC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EF3C0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828EF3C4: 388B25A4  addi r4, r11, 0x25a4
	ctx.r[4].s64 = ctx.r[11].s64 + 9636;
	// 828EF3C8: 48504641  bl 0x82df3a08
	ctx.lr = 0x828EF3CC;
	sub_82DF3A08(ctx, base);
	// 828EF3CC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828EF3D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF3D4: 388B88CC  addi r4, r11, -0x7734
	ctx.r[4].s64 = ctx.r[11].s64 + -30516;
	// 828EF3D8: 48504631  bl 0x82df3a08
	ctx.lr = 0x828EF3DC;
	sub_82DF3A08(ctx, base);
	// 828EF3DC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828EF3E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EF3E4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EF3E8: 4BCDB119  bl 0x825ca500
	ctx.lr = 0x828EF3EC;
	sub_825CA500(ctx, base);
	// 828EF3EC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828EF3F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF3F4: 48504035  bl 0x82df3428
	ctx.lr = 0x828EF3F8;
	sub_82DF3428(ctx, base);
	// 828EF3F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828EF3FC: 4850402D  bl 0x82df3428
	ctx.lr = 0x828EF400;
	sub_82DF3428(ctx, base);
	// 828EF400: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EF404: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EF408: 388B26A4  addi r4, r11, 0x26a4
	ctx.r[4].s64 = ctx.r[11].s64 + 9892;
	// 828EF40C: 485045FD  bl 0x82df3a08
	ctx.lr = 0x828EF410;
	sub_82DF3A08(ctx, base);
	// 828EF410: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EF414: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EF418: 388B2698  addi r4, r11, 0x2698
	ctx.r[4].s64 = ctx.r[11].s64 + 9880;
	// 828EF41C: 485045ED  bl 0x82df3a08
	ctx.lr = 0x828EF420;
	sub_82DF3A08(ctx, base);
	// 828EF420: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828EF424: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 828EF428: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828EF42C: 38BD00D4  addi r5, r29, 0xd4
	ctx.r[5].s64 = ctx.r[29].s64 + 212;
	// 828EF430: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828EF434: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828EF438: C06B964C  lfs f3, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828EF43C: C04A6218  lfs f2, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828EF440: C02908A4  lfs f1, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EF444: 4BCB3E65  bl 0x825a32a8
	ctx.lr = 0x828EF448;
	sub_825A32A8(ctx, base);
	// 828EF448: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828EF44C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828EF450: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828EF454: 4BCB231D  bl 0x825a1770
	ctx.lr = 0x828EF458;
	sub_825A1770(ctx, base);
	// 828EF458: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 828EF45C: 48503FCD  bl 0x82df3428
	ctx.lr = 0x828EF460;
	sub_82DF3428(ctx, base);
	// 828EF460: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828EF464: 4B9D9855  bl 0x822c8cb8
	ctx.lr = 0x828EF468;
	sub_822C8CB8(ctx, base);
	// 828EF468: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828EF46C: 48503FBD  bl 0x82df3428
	ctx.lr = 0x828EF470;
	sub_82DF3428(ctx, base);
	// 828EF470: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EF474: 48503FB5  bl 0x82df3428
	ctx.lr = 0x828EF478;
	sub_82DF3428(ctx, base);
	// 828EF478: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EF47C: 4BCDA855  bl 0x825c9cd0
	ctx.lr = 0x828EF480;
	sub_825C9CD0(ctx, base);
	// 828EF480: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EF484: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828EF488: 419A0008  beq cr6, 0x828ef490
	if ctx.cr[6].eq {
	pc = 0x828EF490; continue 'dispatch;
	}
	// 828EF48C: 4B9D1405  bl 0x822c0890
	ctx.lr = 0x828EF490;
	sub_822C0890(ctx, base);
	// 828EF490: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828EF494: 488B8D24  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EF498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828EF498 size=72
    let mut pc: u32 = 0x828EF498;
    'dispatch: loop {
        match pc {
            0x828EF498 => {
    //   block [0x828EF498..0x828EF4E0)
	// 828EF498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EF49C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EF4A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EF4A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EF4A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EF4AC: 4856D47D  bl 0x82e5c928
	ctx.lr = 0x828EF4B0;
	sub_82E5C928(ctx, base);
	// 828EF4B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828EF4B4: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828EF4B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EF4BC: 394A26C0  addi r10, r10, 0x26c0
	ctx.r[10].s64 = ctx.r[10].s64 + 9920;
	// 828EF4C0: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828EF4C4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828EF4C8: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828EF4CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828EF4D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EF4D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EF4D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EF4DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EF4E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EF4E0 size=96
    let mut pc: u32 = 0x828EF4E0;
    'dispatch: loop {
        match pc {
            0x828EF4E0 => {
    //   block [0x828EF4E0..0x828EF540)
	// 828EF4E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EF4E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EF4E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EF4EC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EF4F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EF4F4: 4BFFFFA5  bl 0x828ef498
	ctx.lr = 0x828EF4F8;
	sub_828EF498(ctx, base);
	// 828EF4F8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EF4FC: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828EF500: 396B26E8  addi r11, r11, 0x26e8
	ctx.r[11].s64 = ctx.r[11].s64 + 9960;
	// 828EF504: 388A40A4  addi r4, r10, 0x40a4
	ctx.r[4].s64 = ctx.r[10].s64 + 16548;
	// 828EF508: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828EF50C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF510: 485044F9  bl 0x82df3a08
	ctx.lr = 0x828EF514;
	sub_82DF3A08(ctx, base);
	// 828EF514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EF518: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EF51C: 4856A1CD  bl 0x82e596e8
	ctx.lr = 0x828EF520;
	sub_82E596E8(ctx, base);
	// 828EF520: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF524: 48503F05  bl 0x82df3428
	ctx.lr = 0x828EF528;
	sub_82DF3428(ctx, base);
	// 828EF528: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EF52C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EF530: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EF534: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EF538: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EF53C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EF540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EF540 size=196
    let mut pc: u32 = 0x828EF540;
    'dispatch: loop {
        match pc {
            0x828EF540 => {
    //   block [0x828EF540..0x828EF604)
	// 828EF540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EF544: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EF548: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828EF54C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EF550: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EF554: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828EF558: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828EF55C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828EF560: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828EF564: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828EF568: 4B9D13D1  bl 0x822c0938
	ctx.lr = 0x828EF56C;
	sub_822C0938(ctx, base);
	// 828EF56C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828EF570: 41820028  beq 0x828ef598
	if ctx.cr[0].eq {
	pc = 0x828EF598; continue 'dispatch;
	}
	// 828EF574: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EF578: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828EF57C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828EF580: 392B2714  addi r9, r11, 0x2714
	ctx.r[9].s64 = ctx.r[11].s64 + 10004;
	// 828EF584: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828EF588: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828EF58C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828EF590: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828EF594: 48000008  b 0x828ef59c
	pc = 0x828EF59C; continue 'dispatch;
	// 828EF598: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828EF59C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828EF5A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828EF5A4: 409A0044  bne cr6, 0x828ef5e8
	if !ctx.cr[6].eq {
	pc = 0x828EF5E8; continue 'dispatch;
	}
	// 828EF5A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828EF5AC: 419A001C  beq cr6, 0x828ef5c8
	if ctx.cr[6].eq {
	pc = 0x828EF5C8; continue 'dispatch;
	}
	// 828EF5B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EF5B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828EF5B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EF5BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828EF5C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EF5C4: 4E800421  bctrl
	ctx.lr = 0x828EF5C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EF5C8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EF5CC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828EF5D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF5D4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828EF5D8: 816BA16C  lwz r11, -0x5e94(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24212 as u32) ) } as u64;
	// 828EF5DC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828EF5E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828EF5E4: 4B9D0A1D  bl 0x822c0000
	ctx.lr = 0x828EF5E8;
	sub_822C0000(ctx, base);
	// 828EF5E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EF5EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EF5F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EF5F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EF5F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828EF5FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EF600: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EF608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EF608 size=108
    let mut pc: u32 = 0x828EF608;
    'dispatch: loop {
        match pc {
            0x828EF608 => {
    //   block [0x828EF608..0x828EF674)
	// 828EF608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EF60C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EF610: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EF614: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EF618: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EF61C: 4BFFFE7D  bl 0x828ef498
	ctx.lr = 0x828EF620;
	sub_828EF498(ctx, base);
	// 828EF620: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828EF624: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828EF628: 394A2728  addi r10, r10, 0x2728
	ctx.r[10].s64 = ctx.r[10].s64 + 10024;
	// 828EF62C: 3D20832D  lis r9, -0x7cd3
	ctx.r[9].s64 = -2094202880;
	// 828EF630: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828EF634: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF638: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828EF63C: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828EF640: 80890AF0  lwz r4, 0xaf0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2800 as u32) ) } as u64;
	// 828EF644: 485043C5  bl 0x82df3a08
	ctx.lr = 0x828EF648;
	sub_82DF3A08(ctx, base);
	// 828EF648: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EF64C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EF650: 4856A099  bl 0x82e596e8
	ctx.lr = 0x828EF654;
	sub_82E596E8(ctx, base);
	// 828EF654: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF658: 48503DD1  bl 0x82df3428
	ctx.lr = 0x828EF65C;
	sub_82DF3428(ctx, base);
	// 828EF65C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EF660: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EF664: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EF668: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EF66C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EF670: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EF678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EF678 size=112
    let mut pc: u32 = 0x828EF678;
    'dispatch: loop {
        match pc {
            0x828EF678 => {
    //   block [0x828EF678..0x828EF6E8)
	// 828EF678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EF67C: 488B8AF1  bl 0x831a816c
	ctx.lr = 0x828EF680;
	sub_831A8130(ctx, base);
	// 828EF680: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EF684: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EF688: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828EF68C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828EF690: 388B2750  addi r4, r11, 0x2750
	ctx.r[4].s64 = ctx.r[11].s64 + 10064;
	// 828EF694: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 828EF698: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 828EF69C: 48502D4D  bl 0x82df23e8
	ctx.lr = 0x828EF6A0;
	sub_82DF23E8(ctx, base);
	// 828EF6A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828EF6A4: 41820010  beq 0x828ef6b4
	if ctx.cr[0].eq {
	pc = 0x828EF6B4; continue 'dispatch;
	}
	// 828EF6A8: 4BFFFF61  bl 0x828ef608
	ctx.lr = 0x828EF6AC;
	sub_828EF608(ctx, base);
	// 828EF6AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EF6B0: 48000008  b 0x828ef6b8
	pc = 0x828EF6B8; continue 'dispatch;
	// 828EF6B4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828EF6B8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828EF6BC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828EF6C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EF6C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EF6C8: 4BFFFE79  bl 0x828ef540
	ctx.lr = 0x828EF6CC;
	sub_828EF540(ctx, base);
	// 828EF6CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828EF6D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EF6D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EF6D8: 4B9D0929  bl 0x822c0000
	ctx.lr = 0x828EF6DC;
	sub_822C0000(ctx, base);
	// 828EF6DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828EF6E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EF6E4: 488B8AD8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EF6E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828EF6E8 size=192
    let mut pc: u32 = 0x828EF6E8;
    'dispatch: loop {
        match pc {
            0x828EF6E8 => {
    //   block [0x828EF6E8..0x828EF7A8)
	// 828EF6E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EF6EC: 488B8A7D  bl 0x831a8168
	ctx.lr = 0x828EF6F0;
	sub_831A8130(ctx, base);
	// 828EF6F0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EF6F4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828EF6F8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828EF6FC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828EF700: 48864F01  bl 0x83154600
	ctx.lr = 0x828EF704;
	sub_83154600(ctx, base);
	// 828EF704: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EF708: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828EF70C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EF710: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EF714: 4BF0013D  bl 0x827ef850
	ctx.lr = 0x828EF718;
	sub_827EF850(ctx, base);
	// 828EF718: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828EF71C: 815E0034  lwz r10, 0x34(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 828EF720: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EF724: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EF728: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828EF72C: C02B029C  lfs f1, 0x29c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(668 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EF730: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828EF734: 4E800421  bctrl
	ctx.lr = 0x828EF738;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EF738: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EF73C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828EF740: 388B2750  addi r4, r11, 0x2750
	ctx.r[4].s64 = ctx.r[11].s64 + 10064;
	// 828EF744: 38A00028  li r5, 0x28
	ctx.r[5].s64 = 40;
	// 828EF748: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 828EF74C: 4B9D0C8D  bl 0x822c03d8
	ctx.lr = 0x828EF750;
	sub_822C03D8(ctx, base);
	// 828EF750: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828EF754: 41820030  beq 0x828ef784
	if ctx.cr[0].eq {
	pc = 0x828EF784; continue 'dispatch;
	}
	// 828EF758: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EF75C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828EF760: 48027009  bl 0x82916768
	ctx.lr = 0x828EF764;
	sub_82916768(ctx, base);
	// 828EF764: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EF768: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF76C: 4BC1FDAD  bl 0x8250f518
	ctx.lr = 0x828EF770;
	sub_8250F518(ctx, base);
	// 828EF770: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EF774: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EF778: 4BBA1979  bl 0x824910f0
	ctx.lr = 0x828EF77C;
	sub_824910F0(ctx, base);
	// 828EF77C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828EF780: 48000008  b 0x828ef788
	pc = 0x828EF788; continue 'dispatch;
	// 828EF784: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828EF788: 387C0064  addi r3, r28, 0x64
	ctx.r[3].s64 = ctx.r[28].s64 + 100;
	// 828EF78C: 4BA1AF55  bl 0x8230a6e0
	ctx.lr = 0x828EF790;
	sub_8230A6E0(ctx, base);
	// 828EF790: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EF794: 4182000C  beq 0x828ef7a0
	if ctx.cr[0].eq {
	pc = 0x828EF7A0; continue 'dispatch;
	}
	// 828EF798: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF79C: 485024F5  bl 0x82df1c90
	ctx.lr = 0x828EF7A0;
	sub_82DF1C90(ctx, base);
	// 828EF7A0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828EF7A4: 488B8A14  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EF7A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EF7A8 size=96
    let mut pc: u32 = 0x828EF7A8;
    'dispatch: loop {
        match pc {
            0x828EF7A8 => {
    //   block [0x828EF7A8..0x828EF808)
	// 828EF7A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EF7AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EF7B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EF7B4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EF7B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EF7BC: 4BFFFCDD  bl 0x828ef498
	ctx.lr = 0x828EF7C0;
	sub_828EF498(ctx, base);
	// 828EF7C0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EF7C4: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828EF7C8: 396B2894  addi r11, r11, 0x2894
	ctx.r[11].s64 = ctx.r[11].s64 + 10388;
	// 828EF7CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF7D0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828EF7D4: 808AA08C  lwz r4, -0x5f74(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24436 as u32) ) } as u64;
	// 828EF7D8: 48504231  bl 0x82df3a08
	ctx.lr = 0x828EF7DC;
	sub_82DF3A08(ctx, base);
	// 828EF7DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EF7E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EF7E4: 48569F05  bl 0x82e596e8
	ctx.lr = 0x828EF7E8;
	sub_82E596E8(ctx, base);
	// 828EF7E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF7EC: 48503C3D  bl 0x82df3428
	ctx.lr = 0x828EF7F0;
	sub_82DF3428(ctx, base);
	// 828EF7F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EF7F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EF7F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EF7FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EF800: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EF804: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EF808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EF808 size=164
    let mut pc: u32 = 0x828EF808;
    'dispatch: loop {
        match pc {
            0x828EF808 => {
    //   block [0x828EF808..0x828EF8AC)
	// 828EF808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EF80C: 488B8961  bl 0x831a816c
	ctx.lr = 0x828EF810;
	sub_831A8130(ctx, base);
	// 828EF810: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EF814: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EF818: 48864DE9  bl 0x83154600
	ctx.lr = 0x828EF81C;
	sub_83154600(ctx, base);
	// 828EF81C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EF820: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828EF824: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EF828: 4E800421  bctrl
	ctx.lr = 0x828EF82C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EF82C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EF830: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828EF834: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF838: 808BA020  lwz r4, -0x5fe0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24544 as u32) ) } as u64;
	// 828EF83C: 485041CD  bl 0x82df3a08
	ctx.lr = 0x828EF840;
	sub_82DF3A08(ctx, base);
	// 828EF840: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EF844: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828EF848: 4BEFAA61  bl 0x827ea2a8
	ctx.lr = 0x828EF84C;
	sub_827EA2A8(ctx, base);
	// 828EF84C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828EF850: 48503AB9  bl 0x82df3308
	ctx.lr = 0x828EF854;
	sub_82DF3308(ctx, base);
	// 828EF854: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828EF858: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF85C: 48503BCD  bl 0x82df3428
	ctx.lr = 0x828EF860;
	sub_82DF3428(ctx, base);
	// 828EF860: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EF864: 41820040  beq 0x828ef8a4
	if ctx.cr[0].eq {
	pc = 0x828EF8A4; continue 'dispatch;
	}
	// 828EF868: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828EF86C: 4BEFAAA5  bl 0x827ea310
	ctx.lr = 0x828EF870;
	sub_827EA310(ctx, base);
	// 828EF870: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EF874: 41820030  beq 0x828ef8a4
	if ctx.cr[0].eq {
	pc = 0x828EF8A4; continue 'dispatch;
	}
	// 828EF878: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EF87C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF880: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828EF884: 48504185  bl 0x82df3a08
	ctx.lr = 0x828EF888;
	sub_82DF3A08(ctx, base);
	// 828EF888: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EF88C: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 828EF890: 48864D71  bl 0x83154600
	ctx.lr = 0x828EF894;
	sub_83154600(ctx, base);
	// 828EF894: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828EF898: 4BEFFEA9  bl 0x827ef740
	ctx.lr = 0x828EF89C;
	sub_827EF740(ctx, base);
	// 828EF89C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF8A0: 48503B89  bl 0x82df3428
	ctx.lr = 0x828EF8A4;
	sub_82DF3428(ctx, base);
	// 828EF8A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828EF8A8: 488B8914  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EF8B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828EF8B0 size=196
    let mut pc: u32 = 0x828EF8B0;
    'dispatch: loop {
        match pc {
            0x828EF8B0 => {
    //   block [0x828EF8B0..0x828EF974)
	// 828EF8B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EF8B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EF8B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EF8BC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828EF8C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EF8C4: 48864D3D  bl 0x83154600
	ctx.lr = 0x828EF8C8;
	sub_83154600(ctx, base);
	// 828EF8C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EF8CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EF8D0: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828EF8D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EF8D8: 4E800421  bctrl
	ctx.lr = 0x828EF8DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EF8DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828EF8E0: C3EB08A8  lfs f31, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828EF8E4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828EF8E8: 4BEFAA81  bl 0x827ea368
	ctx.lr = 0x828EF8EC;
	sub_827EA368(ctx, base);
	// 828EF8EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828EF8F0: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828EF8F4: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828EF8F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EF8FC: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828EF900: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EF904: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828EF908: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828EF90C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EF910: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828EF914: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EF918: 4E800421  bctrl
	ctx.lr = 0x828EF91C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EF91C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EF920: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828EF924: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828EF928: 480276F9  bl 0x82917020
	ctx.lr = 0x828EF92C;
	sub_82917020(ctx, base);
	// 828EF92C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EF930: 48026E39  bl 0x82916768
	ctx.lr = 0x828EF934;
	sub_82916768(ctx, base);
	// 828EF934: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EF938: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828EF93C: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828EF940: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EF944: 4E800421  bctrl
	ctx.lr = 0x828EF948;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EF948: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EF94C: 4BEFDECD  bl 0x827ed818
	ctx.lr = 0x828EF950;
	sub_827ED818(ctx, base);
	// 828EF950: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828EF954: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828EF958: 4BFF7031  bl 0x828e6988
	ctx.lr = 0x828EF95C;
	sub_828E6988(ctx, base);
	// 828EF95C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828EF960: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EF964: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EF968: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828EF96C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EF970: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EF978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EF978 size=96
    let mut pc: u32 = 0x828EF978;
    'dispatch: loop {
        match pc {
            0x828EF978 => {
    //   block [0x828EF978..0x828EF9D8)
	// 828EF978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EF97C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EF980: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EF984: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EF988: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EF98C: 4BFFFB0D  bl 0x828ef498
	ctx.lr = 0x828EF990;
	sub_828EF498(ctx, base);
	// 828EF990: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EF994: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828EF998: 396B28BC  addi r11, r11, 0x28bc
	ctx.r[11].s64 = ctx.r[11].s64 + 10428;
	// 828EF99C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF9A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828EF9A4: 808AA090  lwz r4, -0x5f70(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24432 as u32) ) } as u64;
	// 828EF9A8: 48504061  bl 0x82df3a08
	ctx.lr = 0x828EF9AC;
	sub_82DF3A08(ctx, base);
	// 828EF9AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EF9B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EF9B4: 48569D35  bl 0x82e596e8
	ctx.lr = 0x828EF9B8;
	sub_82E596E8(ctx, base);
	// 828EF9B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EF9BC: 48503A6D  bl 0x82df3428
	ctx.lr = 0x828EF9C0;
	sub_82DF3428(ctx, base);
	// 828EF9C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EF9C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EF9C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EF9CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EF9D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EF9D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EF9D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EF9D8 size=96
    let mut pc: u32 = 0x828EF9D8;
    'dispatch: loop {
        match pc {
            0x828EF9D8 => {
    //   block [0x828EF9D8..0x828EFA38)
	// 828EF9D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EF9DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EF9E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EF9E4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EF9E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EF9EC: 4BFFFAAD  bl 0x828ef498
	ctx.lr = 0x828EF9F0;
	sub_828EF498(ctx, base);
	// 828EF9F0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EF9F4: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828EF9F8: 396B28E4  addi r11, r11, 0x28e4
	ctx.r[11].s64 = ctx.r[11].s64 + 10468;
	// 828EF9FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EFA00: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828EFA04: 808AA094  lwz r4, -0x5f6c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24428 as u32) ) } as u64;
	// 828EFA08: 48504001  bl 0x82df3a08
	ctx.lr = 0x828EFA0C;
	sub_82DF3A08(ctx, base);
	// 828EFA0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFA10: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EFA14: 48569CD5  bl 0x82e596e8
	ctx.lr = 0x828EFA18;
	sub_82E596E8(ctx, base);
	// 828EFA18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EFA1C: 48503A0D  bl 0x82df3428
	ctx.lr = 0x828EFA20;
	sub_82DF3428(ctx, base);
	// 828EFA20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFA24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EFA28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EFA2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EFA30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EFA34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EFA38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EFA38 size=136
    let mut pc: u32 = 0x828EFA38;
    'dispatch: loop {
        match pc {
            0x828EFA38 => {
    //   block [0x828EFA38..0x828EFAC0)
	// 828EFA38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EFA3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EFA40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EFA44: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EFA48: 48864BB9  bl 0x83154600
	ctx.lr = 0x828EFA4C;
	sub_83154600(ctx, base);
	// 828EFA4C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EFA50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EFA54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EFA58: 808BA028  lwz r4, -0x5fd8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24536 as u32) ) } as u64;
	// 828EFA5C: 48503FAD  bl 0x82df3a08
	ctx.lr = 0x828EFA60;
	sub_82DF3A08(ctx, base);
	// 828EFA60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EFA64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFA68: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EFA6C: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828EFA70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EFA74: 4E800421  bctrl
	ctx.lr = 0x828EFA78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EFA78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EFA7C: 485039AD  bl 0x82df3428
	ctx.lr = 0x828EFA80;
	sub_82DF3428(ctx, base);
	// 828EFA80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFA84: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828EFA88: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828EFA8C: 48027595  bl 0x82917020
	ctx.lr = 0x828EFA90;
	sub_82917020(ctx, base);
	// 828EFA90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFA94: 4BEFDD85  bl 0x827ed818
	ctx.lr = 0x828EFA98;
	sub_827ED818(ctx, base);
	// 828EFA98: 4BFF4259  bl 0x828e3cf0
	ctx.lr = 0x828EFA9C;
	sub_828E3CF0(ctx, base);
	// 828EFA9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFAA0: 4BEFDD79  bl 0x827ed818
	ctx.lr = 0x828EFAA4;
	sub_827ED818(ctx, base);
	// 828EFAA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828EFAA8: 4BFF6F91  bl 0x828e6a38
	ctx.lr = 0x828EFAAC;
	sub_828E6A38(ctx, base);
	// 828EFAAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EFAB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EFAB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EFAB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EFABC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EFAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EFAC0 size=96
    let mut pc: u32 = 0x828EFAC0;
    'dispatch: loop {
        match pc {
            0x828EFAC0 => {
    //   block [0x828EFAC0..0x828EFB20)
	// 828EFAC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EFAC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EFAC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EFACC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EFAD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EFAD4: 4BFFF9C5  bl 0x828ef498
	ctx.lr = 0x828EFAD8;
	sub_828EF498(ctx, base);
	// 828EFAD8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EFADC: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828EFAE0: 396B290C  addi r11, r11, 0x290c
	ctx.r[11].s64 = ctx.r[11].s64 + 10508;
	// 828EFAE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EFAE8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828EFAEC: 808AA098  lwz r4, -0x5f68(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24424 as u32) ) } as u64;
	// 828EFAF0: 48503F19  bl 0x82df3a08
	ctx.lr = 0x828EFAF4;
	sub_82DF3A08(ctx, base);
	// 828EFAF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFAF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EFAFC: 48569BED  bl 0x82e596e8
	ctx.lr = 0x828EFB00;
	sub_82E596E8(ctx, base);
	// 828EFB00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EFB04: 48503925  bl 0x82df3428
	ctx.lr = 0x828EFB08;
	sub_82DF3428(ctx, base);
	// 828EFB08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFB0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EFB10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EFB14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EFB18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EFB1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EFB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EFB20 size=136
    let mut pc: u32 = 0x828EFB20;
    'dispatch: loop {
        match pc {
            0x828EFB20 => {
    //   block [0x828EFB20..0x828EFBA8)
	// 828EFB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EFB24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EFB28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EFB2C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EFB30: 48864AD1  bl 0x83154600
	ctx.lr = 0x828EFB34;
	sub_83154600(ctx, base);
	// 828EFB34: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EFB38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EFB3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EFB40: 808BA02C  lwz r4, -0x5fd4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24532 as u32) ) } as u64;
	// 828EFB44: 48503EC5  bl 0x82df3a08
	ctx.lr = 0x828EFB48;
	sub_82DF3A08(ctx, base);
	// 828EFB48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EFB4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFB50: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EFB54: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828EFB58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EFB5C: 4E800421  bctrl
	ctx.lr = 0x828EFB60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EFB60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EFB64: 485038C5  bl 0x82df3428
	ctx.lr = 0x828EFB68;
	sub_82DF3428(ctx, base);
	// 828EFB68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFB6C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828EFB70: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828EFB74: 480274AD  bl 0x82917020
	ctx.lr = 0x828EFB78;
	sub_82917020(ctx, base);
	// 828EFB78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFB7C: 4BEFDC9D  bl 0x827ed818
	ctx.lr = 0x828EFB80;
	sub_827ED818(ctx, base);
	// 828EFB80: 4BFF4171  bl 0x828e3cf0
	ctx.lr = 0x828EFB84;
	sub_828E3CF0(ctx, base);
	// 828EFB84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFB88: 4BEFDC91  bl 0x827ed818
	ctx.lr = 0x828EFB8C;
	sub_827ED818(ctx, base);
	// 828EFB8C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828EFB90: 4BFF6EA9  bl 0x828e6a38
	ctx.lr = 0x828EFB94;
	sub_828E6A38(ctx, base);
	// 828EFB94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EFB98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EFB9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EFBA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EFBA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EFBA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828EFBA8 size=128
    let mut pc: u32 = 0x828EFBA8;
    'dispatch: loop {
        match pc {
            0x828EFBA8 => {
    //   block [0x828EFBA8..0x828EFC28)
	// 828EFBA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EFBAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EFBB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EFBB4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EFBB8: 48864A49  bl 0x83154600
	ctx.lr = 0x828EFBBC;
	sub_83154600(ctx, base);
	// 828EFBBC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828EFBC0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828EFBC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EFBC8: C02B4494  lfs f1, 0x4494(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17556 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828EFBCC: 4BFFE8ED  bl 0x828ee4b8
	ctx.lr = 0x828EFBD0;
	sub_828EE4B8(ctx, base);
	// 828EFBD0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EFBD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFBD8: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828EFBDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EFBE0: 4E800421  bctrl
	ctx.lr = 0x828EFBE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EFBE4: 4BEFA72D  bl 0x827ea310
	ctx.lr = 0x828EFBE8;
	sub_827EA310(ctx, base);
	// 828EFBE8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828EFBEC: 41820028  beq 0x828efc14
	if ctx.cr[0].eq {
	pc = 0x828EFC14; continue 'dispatch;
	}
	// 828EFBF0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EFBF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EFBF8: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828EFBFC: 48503E0D  bl 0x82df3a08
	ctx.lr = 0x828EFC00;
	sub_82DF3A08(ctx, base);
	// 828EFC00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EFC04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFC08: 4BEFFB39  bl 0x827ef740
	ctx.lr = 0x828EFC0C;
	sub_827EF740(ctx, base);
	// 828EFC0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EFC10: 48503819  bl 0x82df3428
	ctx.lr = 0x828EFC14;
	sub_82DF3428(ctx, base);
	// 828EFC14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EFC18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EFC1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EFC20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EFC24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EFC28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EFC28 size=96
    let mut pc: u32 = 0x828EFC28;
    'dispatch: loop {
        match pc {
            0x828EFC28 => {
    //   block [0x828EFC28..0x828EFC88)
	// 828EFC28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EFC2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EFC30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EFC34: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EFC38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EFC3C: 4BFFF85D  bl 0x828ef498
	ctx.lr = 0x828EFC40;
	sub_828EF498(ctx, base);
	// 828EFC40: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EFC44: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828EFC48: 396B2934  addi r11, r11, 0x2934
	ctx.r[11].s64 = ctx.r[11].s64 + 10548;
	// 828EFC4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EFC50: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828EFC54: 808AA09C  lwz r4, -0x5f64(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24420 as u32) ) } as u64;
	// 828EFC58: 48503DB1  bl 0x82df3a08
	ctx.lr = 0x828EFC5C;
	sub_82DF3A08(ctx, base);
	// 828EFC5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFC60: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EFC64: 48569A85  bl 0x82e596e8
	ctx.lr = 0x828EFC68;
	sub_82E596E8(ctx, base);
	// 828EFC68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EFC6C: 485037BD  bl 0x82df3428
	ctx.lr = 0x828EFC70;
	sub_82DF3428(ctx, base);
	// 828EFC70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFC74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EFC78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EFC7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EFC80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EFC84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EFC88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EFC88 size=156
    let mut pc: u32 = 0x828EFC88;
    'dispatch: loop {
        match pc {
            0x828EFC88 => {
    //   block [0x828EFC88..0x828EFD24)
	// 828EFC88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EFC8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EFC90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EFC94: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EFC98: 48864969  bl 0x83154600
	ctx.lr = 0x828EFC9C;
	sub_83154600(ctx, base);
	// 828EFC9C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EFCA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EFCA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EFCA8: 808BA030  lwz r4, -0x5fd0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24528 as u32) ) } as u64;
	// 828EFCAC: 48503D5D  bl 0x82df3a08
	ctx.lr = 0x828EFCB0;
	sub_82DF3A08(ctx, base);
	// 828EFCB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EFCB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFCB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EFCBC: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828EFCC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EFCC4: 4E800421  bctrl
	ctx.lr = 0x828EFCC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EFCC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EFCCC: 4850375D  bl 0x82df3428
	ctx.lr = 0x828EFCD0;
	sub_82DF3428(ctx, base);
	// 828EFCD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFCD4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828EFCD8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828EFCDC: 48027345  bl 0x82917020
	ctx.lr = 0x828EFCE0;
	sub_82917020(ctx, base);
	// 828EFCE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFCE4: 4BEFDB35  bl 0x827ed818
	ctx.lr = 0x828EFCE8;
	sub_827ED818(ctx, base);
	// 828EFCE8: 4BFF4009  bl 0x828e3cf0
	ctx.lr = 0x828EFCEC;
	sub_828E3CF0(ctx, base);
	// 828EFCEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFCF0: 4BEFDB29  bl 0x827ed818
	ctx.lr = 0x828EFCF4;
	sub_827ED818(ctx, base);
	// 828EFCF4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828EFCF8: 4BFF6D41  bl 0x828e6a38
	ctx.lr = 0x828EFCFC;
	sub_828E6A38(ctx, base);
	// 828EFCFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFD00: 4BEFDB19  bl 0x827ed818
	ctx.lr = 0x828EFD04;
	sub_827ED818(ctx, base);
	// 828EFD04: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828EFD08: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828EFD0C: 4BFF41ED  bl 0x828e3ef8
	ctx.lr = 0x828EFD10;
	sub_828E3EF8(ctx, base);
	// 828EFD10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EFD14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EFD18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EFD1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EFD20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EFD28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EFD28 size=92
    let mut pc: u32 = 0x828EFD28;
    'dispatch: loop {
        match pc {
            0x828EFD28 => {
    //   block [0x828EFD28..0x828EFD84)
	// 828EFD28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EFD2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EFD30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EFD34: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EFD38: 488648C9  bl 0x83154600
	ctx.lr = 0x828EFD3C;
	sub_83154600(ctx, base);
	// 828EFD3C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828EFD40: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828EFD44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EFD48: 480272D9  bl 0x82917020
	ctx.lr = 0x828EFD4C;
	sub_82917020(ctx, base);
	// 828EFD4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFD50: 4BEFDAC9  bl 0x827ed818
	ctx.lr = 0x828EFD54;
	sub_827ED818(ctx, base);
	// 828EFD54: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828EFD58: 4BFF6CE1  bl 0x828e6a38
	ctx.lr = 0x828EFD5C;
	sub_828E6A38(ctx, base);
	// 828EFD5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFD60: 4BEFDAB9  bl 0x827ed818
	ctx.lr = 0x828EFD64;
	sub_827ED818(ctx, base);
	// 828EFD64: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828EFD68: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828EFD6C: 4BFF418D  bl 0x828e3ef8
	ctx.lr = 0x828EFD70;
	sub_828E3EF8(ctx, base);
	// 828EFD70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828EFD74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EFD78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EFD7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EFD80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EFD88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EFD88 size=96
    let mut pc: u32 = 0x828EFD88;
    'dispatch: loop {
        match pc {
            0x828EFD88 => {
    //   block [0x828EFD88..0x828EFDE8)
	// 828EFD88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EFD8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EFD90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EFD94: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EFD98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EFD9C: 4BFFF6FD  bl 0x828ef498
	ctx.lr = 0x828EFDA0;
	sub_828EF498(ctx, base);
	// 828EFDA0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EFDA4: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828EFDA8: 396B295C  addi r11, r11, 0x295c
	ctx.r[11].s64 = ctx.r[11].s64 + 10588;
	// 828EFDAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EFDB0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828EFDB4: 808AA0A0  lwz r4, -0x5f60(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24416 as u32) ) } as u64;
	// 828EFDB8: 48503C51  bl 0x82df3a08
	ctx.lr = 0x828EFDBC;
	sub_82DF3A08(ctx, base);
	// 828EFDBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFDC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EFDC4: 48569925  bl 0x82e596e8
	ctx.lr = 0x828EFDC8;
	sub_82E596E8(ctx, base);
	// 828EFDC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EFDCC: 4850365D  bl 0x82df3428
	ctx.lr = 0x828EFDD0;
	sub_82DF3428(ctx, base);
	// 828EFDD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFDD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EFDD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EFDDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EFDE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EFDE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EFDE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EFDE8 size=156
    let mut pc: u32 = 0x828EFDE8;
    'dispatch: loop {
        match pc {
            0x828EFDE8 => {
    //   block [0x828EFDE8..0x828EFE84)
	// 828EFDE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EFDEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EFDF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EFDF4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EFDF8: 48864809  bl 0x83154600
	ctx.lr = 0x828EFDFC;
	sub_83154600(ctx, base);
	// 828EFDFC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EFE00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EFE04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EFE08: 808BA034  lwz r4, -0x5fcc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24524 as u32) ) } as u64;
	// 828EFE0C: 48503BFD  bl 0x82df3a08
	ctx.lr = 0x828EFE10;
	sub_82DF3A08(ctx, base);
	// 828EFE10: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EFE14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFE18: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EFE1C: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828EFE20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EFE24: 4E800421  bctrl
	ctx.lr = 0x828EFE28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EFE28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EFE2C: 485035FD  bl 0x82df3428
	ctx.lr = 0x828EFE30;
	sub_82DF3428(ctx, base);
	// 828EFE30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFE34: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828EFE38: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828EFE3C: 480271E5  bl 0x82917020
	ctx.lr = 0x828EFE40;
	sub_82917020(ctx, base);
	// 828EFE40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFE44: 4BEFD9D5  bl 0x827ed818
	ctx.lr = 0x828EFE48;
	sub_827ED818(ctx, base);
	// 828EFE48: 4BFF3EA9  bl 0x828e3cf0
	ctx.lr = 0x828EFE4C;
	sub_828E3CF0(ctx, base);
	// 828EFE4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFE50: 4BEFD9C9  bl 0x827ed818
	ctx.lr = 0x828EFE54;
	sub_827ED818(ctx, base);
	// 828EFE54: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828EFE58: 4BFF6BE1  bl 0x828e6a38
	ctx.lr = 0x828EFE5C;
	sub_828E6A38(ctx, base);
	// 828EFE5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFE60: 4BEFD9B9  bl 0x827ed818
	ctx.lr = 0x828EFE64;
	sub_827ED818(ctx, base);
	// 828EFE64: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828EFE68: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828EFE6C: 4BFF408D  bl 0x828e3ef8
	ctx.lr = 0x828EFE70;
	sub_828E3EF8(ctx, base);
	// 828EFE70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EFE74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EFE78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EFE7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EFE80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EFE88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EFE88 size=92
    let mut pc: u32 = 0x828EFE88;
    'dispatch: loop {
        match pc {
            0x828EFE88 => {
    //   block [0x828EFE88..0x828EFEE4)
	// 828EFE88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EFE8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EFE90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EFE94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EFE98: 48864769  bl 0x83154600
	ctx.lr = 0x828EFE9C;
	sub_83154600(ctx, base);
	// 828EFE9C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828EFEA0: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828EFEA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EFEA8: 48027179  bl 0x82917020
	ctx.lr = 0x828EFEAC;
	sub_82917020(ctx, base);
	// 828EFEAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFEB0: 4BEFD969  bl 0x827ed818
	ctx.lr = 0x828EFEB4;
	sub_827ED818(ctx, base);
	// 828EFEB4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828EFEB8: 4BFF6B81  bl 0x828e6a38
	ctx.lr = 0x828EFEBC;
	sub_828E6A38(ctx, base);
	// 828EFEBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFEC0: 4BEFD959  bl 0x827ed818
	ctx.lr = 0x828EFEC4;
	sub_827ED818(ctx, base);
	// 828EFEC4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828EFEC8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828EFECC: 4BFF402D  bl 0x828e3ef8
	ctx.lr = 0x828EFED0;
	sub_828E3EF8(ctx, base);
	// 828EFED0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828EFED4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EFED8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EFEDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EFEE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EFEE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EFEE8 size=96
    let mut pc: u32 = 0x828EFEE8;
    'dispatch: loop {
        match pc {
            0x828EFEE8 => {
    //   block [0x828EFEE8..0x828EFF48)
	// 828EFEE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EFEEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EFEF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EFEF4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EFEF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EFEFC: 4BFFF59D  bl 0x828ef498
	ctx.lr = 0x828EFF00;
	sub_828EF498(ctx, base);
	// 828EFF00: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828EFF04: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828EFF08: 396B2984  addi r11, r11, 0x2984
	ctx.r[11].s64 = ctx.r[11].s64 + 10628;
	// 828EFF0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EFF10: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828EFF14: 808AA0A4  lwz r4, -0x5f5c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24412 as u32) ) } as u64;
	// 828EFF18: 48503AF1  bl 0x82df3a08
	ctx.lr = 0x828EFF1C;
	sub_82DF3A08(ctx, base);
	// 828EFF1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFF20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EFF24: 485697C5  bl 0x82e596e8
	ctx.lr = 0x828EFF28;
	sub_82E596E8(ctx, base);
	// 828EFF28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EFF2C: 485034FD  bl 0x82df3428
	ctx.lr = 0x828EFF30;
	sub_82DF3428(ctx, base);
	// 828EFF30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFF34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EFF38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EFF3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EFF40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EFF44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EFF48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EFF48 size=136
    let mut pc: u32 = 0x828EFF48;
    'dispatch: loop {
        match pc {
            0x828EFF48 => {
    //   block [0x828EFF48..0x828EFFD0)
	// 828EFF48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EFF4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EFF50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EFF54: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EFF58: 488646A9  bl 0x83154600
	ctx.lr = 0x828EFF5C;
	sub_83154600(ctx, base);
	// 828EFF5C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828EFF60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EFF64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EFF68: 808BA038  lwz r4, -0x5fc8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24520 as u32) ) } as u64;
	// 828EFF6C: 48503A9D  bl 0x82df3a08
	ctx.lr = 0x828EFF70;
	sub_82DF3A08(ctx, base);
	// 828EFF70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828EFF74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFF78: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828EFF7C: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828EFF80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828EFF84: 4E800421  bctrl
	ctx.lr = 0x828EFF88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828EFF88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828EFF8C: 4850349D  bl 0x82df3428
	ctx.lr = 0x828EFF90;
	sub_82DF3428(ctx, base);
	// 828EFF90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFF94: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828EFF98: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828EFF9C: 48027085  bl 0x82917020
	ctx.lr = 0x828EFFA0;
	sub_82917020(ctx, base);
	// 828EFFA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFFA4: 4BEFD875  bl 0x827ed818
	ctx.lr = 0x828EFFA8;
	sub_827ED818(ctx, base);
	// 828EFFA8: 4BFF3D49  bl 0x828e3cf0
	ctx.lr = 0x828EFFAC;
	sub_828E3CF0(ctx, base);
	// 828EFFAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFFB0: 4BEFD869  bl 0x827ed818
	ctx.lr = 0x828EFFB4;
	sub_827ED818(ctx, base);
	// 828EFFB4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828EFFB8: 4BFF6A81  bl 0x828e6a38
	ctx.lr = 0x828EFFBC;
	sub_828E6A38(ctx, base);
	// 828EFFBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828EFFC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828EFFC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828EFFC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828EFFCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828EFFD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828EFFD0 size=72
    let mut pc: u32 = 0x828EFFD0;
    'dispatch: loop {
        match pc {
            0x828EFFD0 => {
    //   block [0x828EFFD0..0x828F0018)
	// 828EFFD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828EFFD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828EFFD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828EFFDC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828EFFE0: 48864621  bl 0x83154600
	ctx.lr = 0x828EFFE4;
	sub_83154600(ctx, base);
	// 828EFFE4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828EFFE8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828EFFEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828EFFF0: 48027031  bl 0x82917020
	ctx.lr = 0x828EFFF4;
	sub_82917020(ctx, base);
	// 828EFFF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828EFFF8: 4BEFD821  bl 0x827ed818
	ctx.lr = 0x828EFFFC;
	sub_827ED818(ctx, base);
	// 828EFFFC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F0000: 4BFF6A39  bl 0x828e6a38
	ctx.lr = 0x828F0004;
	sub_828E6A38(ctx, base);
	// 828F0004: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F0008: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F000C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F0010: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F0014: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F0018 size=104
    let mut pc: u32 = 0x828F0018;
    'dispatch: loop {
        match pc {
            0x828F0018 => {
    //   block [0x828F0018..0x828F0080)
	// 828F0018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F001C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F0020: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F0024: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F0028: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F002C: 4BFFF46D  bl 0x828ef498
	ctx.lr = 0x828F0030;
	sub_828EF498(ctx, base);
	// 828F0030: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F0034: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828F0038: 396B29AC  addi r11, r11, 0x29ac
	ctx.r[11].s64 = ctx.r[11].s64 + 10668;
	// 828F003C: 915F0064  stw r10, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828F0040: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828F0044: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F0048: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F004C: 808A0B28  lwz r4, 0xb28(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2856 as u32) ) } as u64;
	// 828F0050: 485039B9  bl 0x82df3a08
	ctx.lr = 0x828F0054;
	sub_82DF3A08(ctx, base);
	// 828F0054: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0058: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F005C: 4856968D  bl 0x82e596e8
	ctx.lr = 0x828F0060;
	sub_82E596E8(ctx, base);
	// 828F0060: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0064: 485033C5  bl 0x82df3428
	ctx.lr = 0x828F0068;
	sub_82DF3428(ctx, base);
	// 828F0068: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F006C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F0070: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F0074: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F0078: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F007C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F0080 size=404
    let mut pc: u32 = 0x828F0080;
    'dispatch: loop {
        match pc {
            0x828F0080 => {
    //   block [0x828F0080..0x828F0214)
	// 828F0080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F0084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F0088: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F008C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F0090: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828F0094: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F0098: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F009C: 48864565  bl 0x83154600
	ctx.lr = 0x828F00A0;
	sub_83154600(ctx, base);
	// 828F00A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F00A4: 480266C5  bl 0x82916768
	ctx.lr = 0x828F00A8;
	sub_82916768(ctx, base);
	// 828F00A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F00AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F00B0: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828F00B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F00B8: 4E800421  bctrl
	ctx.lr = 0x828F00BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F00BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F00C0: 480266A9  bl 0x82916768
	ctx.lr = 0x828F00C4;
	sub_82916768(ctx, base);
	// 828F00C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F00C8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F00CC: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828F00D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F00D4: 4E800421  bctrl
	ctx.lr = 0x828F00D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F00D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F00DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F00E0: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828F00E4: 4BEFD735  bl 0x827ed818
	ctx.lr = 0x828F00E8;
	sub_827ED818(ctx, base);
	// 828F00E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F00EC: 816B01B0  lwz r11, 0x1b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(432 as u32) ) } as u64;
	// 828F00F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F00F4: 4E800421  bctrl
	ctx.lr = 0x828F00F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F00F8: C0030088  lfs f0, 0x88(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F00FC: D01E0060  stfs f0, 0x60(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828F0100: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0104: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0108: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F010C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F0110: 4E800421  bctrl
	ctx.lr = 0x828F0114;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F0114: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F0118: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828F011C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0120: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F0124: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828F0128: 41990030  bgt cr6, 0x828f0158
	if ctx.cr[6].gt {
	pc = 0x828F0158; continue 'dispatch;
	}
	// 828F012C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828F0130: 48026EF1  bl 0x82917020
	ctx.lr = 0x828F0134;
	sub_82917020(ctx, base);
	// 828F0134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0138: 4BEFD6E1  bl 0x827ed818
	ctx.lr = 0x828F013C;
	sub_827ED818(ctx, base);
	// 828F013C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0140: 816B01A8  lwz r11, 0x1a8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(424 as u32) ) } as u64;
	// 828F0144: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F0148: 4E800421  bctrl
	ctx.lr = 0x828F014C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F014C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F0150: 808BA050  lwz r4, -0x5fb0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24496 as u32) ) } as u64;
	// 828F0154: 48000024  b 0x828f0178
	pc = 0x828F0178; continue 'dispatch;
	// 828F0158: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828F015C: 48026EC5  bl 0x82917020
	ctx.lr = 0x828F0160;
	sub_82917020(ctx, base);
	// 828F0160: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828F0164: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 828F0168: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F016C: 48026EB5  bl 0x82917020
	ctx.lr = 0x828F0170;
	sub_82917020(ctx, base);
	// 828F0170: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F0174: 808BA04C  lwz r4, -0x5fb4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24500 as u32) ) } as u64;
	// 828F0178: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F017C: 4850388D  bl 0x82df3a08
	ctx.lr = 0x828F0180;
	sub_82DF3A08(ctx, base);
	// 828F0180: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0184: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0188: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F018C: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F0190: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F0194: 4E800421  bctrl
	ctx.lr = 0x828F0198;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F0198: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F019C: 4850328D  bl 0x82df3428
	ctx.lr = 0x828F01A0;
	sub_82DF3428(ctx, base);
	// 828F01A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F01A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F01A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F01AC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F01B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F01B4: 4E800421  bctrl
	ctx.lr = 0x828F01B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F01B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F01BC: 480265AD  bl 0x82916768
	ctx.lr = 0x828F01C0;
	sub_82916768(ctx, base);
	// 828F01C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F01C4: 816B0154  lwz r11, 0x154(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(340 as u32) ) } as u64;
	// 828F01C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F01CC: 4E800421  bctrl
	ctx.lr = 0x828F01D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F01D0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F01D4: 41820024  beq 0x828f01f8
	if ctx.cr[0].eq {
	pc = 0x828F01F8; continue 'dispatch;
	}
	// 828F01D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F01DC: C3E30054  lfs f31, 0x54(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828F01E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F01E4: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828F01E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F01EC: 4E800421  bctrl
	ctx.lr = 0x828F01F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F01F0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F01F4: 4BEFA175  bl 0x827ea368
	ctx.lr = 0x828F01F8;
	sub_827EA368(ctx, base);
	// 828F01F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F01FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F0200: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F0204: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828F0208: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F020C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F0210: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F0218 size=444
    let mut pc: u32 = 0x828F0218;
    'dispatch: loop {
        match pc {
            0x828F0218 => {
    //   block [0x828F0218..0x828F03D4)
	// 828F0218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F021C: 488B7F51  bl 0x831a816c
	ctx.lr = 0x828F0220;
	sub_831A8130(ctx, base);
	// 828F0220: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828F0224: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F0228: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F022C: 488643D5  bl 0x83154600
	ctx.lr = 0x828F0230;
	sub_83154600(ctx, base);
	// 828F0230: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F0234: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0238: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828F023C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F0240: 4E800421  bctrl
	ctx.lr = 0x828F0244;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F0244: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F0248: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F024C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828F0250: 419800F0  blt cr6, 0x828f0340
	if ctx.cr[6].lt {
	pc = 0x828F0340; continue 'dispatch;
	}
	// 828F0254: 419A0048  beq cr6, 0x828f029c
	if ctx.cr[6].eq {
	pc = 0x828F029C; continue 'dispatch;
	}
	// 828F0258: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 828F025C: 4098016C  bge cr6, 0x828f03c8
	if !ctx.cr[6].lt {
	pc = 0x828F03C8; continue 'dispatch;
	}
	// 828F0260: 4BEFA0B1  bl 0x827ea310
	ctx.lr = 0x828F0264;
	sub_827EA310(ctx, base);
	// 828F0264: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F0268: 41820160  beq 0x828f03c8
	if ctx.cr[0].eq {
	pc = 0x828F03C8; continue 'dispatch;
	}
	// 828F026C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F0270: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0274: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828F0278: 48503791  bl 0x82df3a08
	ctx.lr = 0x828F027C;
	sub_82DF3A08(ctx, base);
	// 828F027C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F0280: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 828F0284: 4886437D  bl 0x83154600
	ctx.lr = 0x828F0288;
	sub_83154600(ctx, base);
	// 828F0288: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F028C: 4BEFF4B5  bl 0x827ef740
	ctx.lr = 0x828F0290;
	sub_827EF740(ctx, base);
	// 828F0290: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0294: 48503195  bl 0x82df3428
	ctx.lr = 0x828F0298;
	sub_82DF3428(ctx, base);
	// 828F0298: 48000130  b 0x828f03c8
	pc = 0x828F03C8; continue 'dispatch;
	// 828F029C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F02A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F02A4: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F02A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F02AC: 4E800421  bctrl
	ctx.lr = 0x828F02B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F02B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F02B4: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828F02B8: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 828F02BC: 41990030  bgt cr6, 0x828f02ec
	if ctx.cr[6].gt {
	pc = 0x828F02EC; continue 'dispatch;
	}
	// 828F02C0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F02C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F02C8: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828F02CC: 4850373D  bl 0x82df3a08
	ctx.lr = 0x828F02D0;
	sub_82DF3A08(ctx, base);
	// 828F02D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F02D4: 3BE10054  addi r31, r1, 0x54
	ctx.r[31].s64 = ctx.r[1].s64 + 84;
	// 828F02D8: 48864329  bl 0x83154600
	ctx.lr = 0x828F02DC;
	sub_83154600(ctx, base);
	// 828F02DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F02E0: 4BEFF461  bl 0x827ef740
	ctx.lr = 0x828F02E4;
	sub_827EF740(ctx, base);
	// 828F02E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F02E8: 4BFFFFAC  b 0x828f0294
	pc = 0x828F0294; continue 'dispatch;
	// 828F02EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F02F0: 48569489  bl 0x82e59778
	ctx.lr = 0x828F02F4;
	sub_82E59778(ctx, base);
	// 828F02F4: C01E0060  lfs f0, 0x60(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F02F8: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 828F02FC: D01E0060  stfs f0, 0x60(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828F0300: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 828F0304: 409800C4  bge cr6, 0x828f03c8
	if !ctx.cr[6].lt {
	pc = 0x828F03C8; continue 'dispatch;
	}
	// 828F0308: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F030C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F0310: 808BF460  lwz r4, -0xba0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2976 as u32) ) } as u64;
	// 828F0314: 485036F5  bl 0x82df3a08
	ctx.lr = 0x828F0318;
	sub_82DF3A08(ctx, base);
	// 828F0318: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F031C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F0320: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0324: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F0328: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F032C: 4E800421  bctrl
	ctx.lr = 0x828F0330;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F0330: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F0334: 485030F5  bl 0x82df3428
	ctx.lr = 0x828F0338;
	sub_82DF3428(ctx, base);
	// 828F0338: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 828F033C: 48000088  b 0x828f03c4
	pc = 0x828F03C4; continue 'dispatch;
	// 828F0340: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F0344: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828F0348: 808BA04C  lwz r4, -0x5fb4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24500 as u32) ) } as u64;
	// 828F034C: 485036BD  bl 0x82df3a08
	ctx.lr = 0x828F0350;
	sub_82DF3A08(ctx, base);
	// 828F0350: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F0354: 3BE1005C  addi r31, r1, 0x5c
	ctx.r[31].s64 = ctx.r[1].s64 + 92;
	// 828F0358: 4BEF9F51  bl 0x827ea2a8
	ctx.lr = 0x828F035C;
	sub_827EA2A8(ctx, base);
	// 828F035C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F0360: 48502FA9  bl 0x82df3308
	ctx.lr = 0x828F0364;
	sub_82DF3308(ctx, base);
	// 828F0364: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F0368: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828F036C: 485030BD  bl 0x82df3428
	ctx.lr = 0x828F0370;
	sub_82DF3428(ctx, base);
	// 828F0370: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F0374: 4082003C  bne 0x828f03b0
	if !ctx.cr[0].eq {
	pc = 0x828F03B0; continue 'dispatch;
	}
	// 828F0378: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F037C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F0380: 808BA050  lwz r4, -0x5fb0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24496 as u32) ) } as u64;
	// 828F0384: 48503685  bl 0x82df3a08
	ctx.lr = 0x828F0388;
	sub_82DF3A08(ctx, base);
	// 828F0388: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F038C: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 828F0390: 4BEF9F19  bl 0x827ea2a8
	ctx.lr = 0x828F0394;
	sub_827EA2A8(ctx, base);
	// 828F0394: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F0398: 48502F71  bl 0x82df3308
	ctx.lr = 0x828F039C;
	sub_82DF3308(ctx, base);
	// 828F039C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F03A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F03A4: 48503085  bl 0x82df3428
	ctx.lr = 0x828F03A8;
	sub_82DF3428(ctx, base);
	// 828F03A8: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F03AC: 4182001C  beq 0x828f03c8
	if ctx.cr[0].eq {
	pc = 0x828F03C8; continue 'dispatch;
	}
	// 828F03B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F03B4: 4BEF9F5D  bl 0x827ea310
	ctx.lr = 0x828F03B8;
	sub_827EA310(ctx, base);
	// 828F03B8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F03BC: 4182000C  beq 0x828f03c8
	if ctx.cr[0].eq {
	pc = 0x828F03C8; continue 'dispatch;
	}
	// 828F03C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F03C4: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828F03C8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828F03CC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828F03D0: 488B7DEC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F03D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F03D8 size=188
    let mut pc: u32 = 0x828F03D8;
    'dispatch: loop {
        match pc {
            0x828F03D8 => {
    //   block [0x828F03D8..0x828F0494)
	// 828F03D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F03DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F03E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F03E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F03E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F03EC: 48864215  bl 0x83154600
	ctx.lr = 0x828F03F0;
	sub_83154600(ctx, base);
	// 828F03F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F03F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F03F8: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F03FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F0400: 4E800421  bctrl
	ctx.lr = 0x828F0404;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F0404: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F0408: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F040C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828F0410: 40990014  ble cr6, 0x828f0424
	if !ctx.cr[6].gt {
	pc = 0x828F0424; continue 'dispatch;
	}
	// 828F0414: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828F0418: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828F041C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0420: 48026C01  bl 0x82917020
	ctx.lr = 0x828F0424;
	sub_82917020(ctx, base);
	// 828F0424: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828F0428: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 828F042C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0430: 48026BF1  bl 0x82917020
	ctx.lr = 0x828F0434;
	sub_82917020(ctx, base);
	// 828F0434: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0438: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F043C: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 828F0440: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F0444: 4E800421  bctrl
	ctx.lr = 0x828F0448;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F0448: 88830010  lbz r4, 0x10(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F044C: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F0450: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0454: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F0458: 4E800421  bctrl
	ctx.lr = 0x828F045C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F045C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0460: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0464: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828F0468: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F046C: 4E800421  bctrl
	ctx.lr = 0x828F0470;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F0470: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F0474: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F0478: 4BEF9EF1  bl 0x827ea368
	ctx.lr = 0x828F047C;
	sub_827EA368(ctx, base);
	// 828F047C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F0480: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F0484: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F0488: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F048C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F0490: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F0498 size=96
    let mut pc: u32 = 0x828F0498;
    'dispatch: loop {
        match pc {
            0x828F0498 => {
    //   block [0x828F0498..0x828F04F8)
	// 828F0498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F049C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F04A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F04A4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F04A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F04AC: 4BFFEFED  bl 0x828ef498
	ctx.lr = 0x828F04B0;
	sub_828EF498(ctx, base);
	// 828F04B0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F04B4: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828F04B8: 396B29D4  addi r11, r11, 0x29d4
	ctx.r[11].s64 = ctx.r[11].s64 + 10708;
	// 828F04BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F04C0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F04C4: 808A0B34  lwz r4, 0xb34(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2868 as u32) ) } as u64;
	// 828F04C8: 48503541  bl 0x82df3a08
	ctx.lr = 0x828F04CC;
	sub_82DF3A08(ctx, base);
	// 828F04CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F04D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F04D4: 48569215  bl 0x82e596e8
	ctx.lr = 0x828F04D8;
	sub_82E596E8(ctx, base);
	// 828F04D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F04DC: 48502F4D  bl 0x82df3428
	ctx.lr = 0x828F04E0;
	sub_82DF3428(ctx, base);
	// 828F04E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F04E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F04E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F04EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F04F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F04F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F04F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F04F8 size=168
    let mut pc: u32 = 0x828F04F8;
    'dispatch: loop {
        match pc {
            0x828F04F8 => {
    //   block [0x828F04F8..0x828F05A0)
	// 828F04F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F04FC: 488B7C71  bl 0x831a816c
	ctx.lr = 0x828F0500;
	sub_831A8130(ctx, base);
	// 828F0500: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F0504: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F0508: 488640F9  bl 0x83154600
	ctx.lr = 0x828F050C;
	sub_83154600(ctx, base);
	// 828F050C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F0510: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0514: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828F0518: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F051C: 4E800421  bctrl
	ctx.lr = 0x828F0520;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F0520: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828F0524: 4BEF9DED  bl 0x827ea310
	ctx.lr = 0x828F0528;
	sub_827EA310(ctx, base);
	// 828F0528: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F052C: 41820008  beq 0x828f0534
	if ctx.cr[0].eq {
	pc = 0x828F0534; continue 'dispatch;
	}
	// 828F0530: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828F0534: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F0538: 41820060  beq 0x828f0598
	if ctx.cr[0].eq {
	pc = 0x828F0598; continue 'dispatch;
	}
	// 828F053C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0540: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0544: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F0548: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F054C: 4E800421  bctrl
	ctx.lr = 0x828F0550;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F0550: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F0554: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0558: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F055C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828F0560: 41990010  bgt cr6, 0x828f0570
	if ctx.cr[6].gt {
	pc = 0x828F0570; continue 'dispatch;
	}
	// 828F0564: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F0568: 808B0B28  lwz r4, 0xb28(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2856 as u32) ) } as u64;
	// 828F056C: 4800000C  b 0x828f0578
	pc = 0x828F0578; continue 'dispatch;
	// 828F0570: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F0574: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828F0578: 48503491  bl 0x82df3a08
	ctx.lr = 0x828F057C;
	sub_82DF3A08(ctx, base);
	// 828F057C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F0580: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 828F0584: 4886407D  bl 0x83154600
	ctx.lr = 0x828F0588;
	sub_83154600(ctx, base);
	// 828F0588: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F058C: 4BEFF1B5  bl 0x827ef740
	ctx.lr = 0x828F0590;
	sub_827EF740(ctx, base);
	// 828F0590: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0594: 48502E95  bl 0x82df3428
	ctx.lr = 0x828F0598;
	sub_82DF3428(ctx, base);
	// 828F0598: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F059C: 488B7C20  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F05A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F05A0 size=196
    let mut pc: u32 = 0x828F05A0;
    'dispatch: loop {
        match pc {
            0x828F05A0 => {
    //   block [0x828F05A0..0x828F0664)
	// 828F05A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F05A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F05A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F05AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F05B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F05B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F05B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F05BC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F05C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F05C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F05C8: 4B9D0371  bl 0x822c0938
	ctx.lr = 0x828F05CC;
	sub_822C0938(ctx, base);
	// 828F05CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F05D0: 41820028  beq 0x828f05f8
	if ctx.cr[0].eq {
	pc = 0x828F05F8; continue 'dispatch;
	}
	// 828F05D4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F05D8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F05DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F05E0: 392B27CC  addi r9, r11, 0x27cc
	ctx.r[9].s64 = ctx.r[11].s64 + 10188;
	// 828F05E4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F05E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F05EC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F05F0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F05F4: 48000008  b 0x828f05fc
	pc = 0x828F05FC; continue 'dispatch;
	// 828F05F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F05FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F0600: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F0604: 409A0044  bne cr6, 0x828f0648
	if !ctx.cr[6].eq {
	pc = 0x828F0648; continue 'dispatch;
	}
	// 828F0608: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F060C: 419A001C  beq cr6, 0x828f0628
	if ctx.cr[6].eq {
	pc = 0x828F0628; continue 'dispatch;
	}
	// 828F0610: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0614: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F0618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F061C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F0620: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F0624: 4E800421  bctrl
	ctx.lr = 0x828F0628;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F0628: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F062C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F0630: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0634: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F0638: 816BA1F4  lwz r11, -0x5e0c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24076 as u32) ) } as u64;
	// 828F063C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F0640: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F0644: 4B9CF9BD  bl 0x822c0000
	ctx.lr = 0x828F0648;
	sub_822C0000(ctx, base);
	// 828F0648: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F064C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F0650: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F0654: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F0658: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F065C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F0660: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F0668 size=196
    let mut pc: u32 = 0x828F0668;
    'dispatch: loop {
        match pc {
            0x828F0668 => {
    //   block [0x828F0668..0x828F072C)
	// 828F0668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F066C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F0670: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F0674: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F0678: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F067C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F0680: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F0684: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F0688: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F068C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F0690: 4B9D02A9  bl 0x822c0938
	ctx.lr = 0x828F0694;
	sub_822C0938(ctx, base);
	// 828F0694: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F0698: 41820028  beq 0x828f06c0
	if ctx.cr[0].eq {
	pc = 0x828F06C0; continue 'dispatch;
	}
	// 828F069C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F06A0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F06A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F06A8: 392B27E0  addi r9, r11, 0x27e0
	ctx.r[9].s64 = ctx.r[11].s64 + 10208;
	// 828F06AC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F06B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F06B4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F06B8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F06BC: 48000008  b 0x828f06c4
	pc = 0x828F06C4; continue 'dispatch;
	// 828F06C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F06C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F06C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F06CC: 409A0044  bne cr6, 0x828f0710
	if !ctx.cr[6].eq {
	pc = 0x828F0710; continue 'dispatch;
	}
	// 828F06D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F06D4: 419A001C  beq cr6, 0x828f06f0
	if ctx.cr[6].eq {
	pc = 0x828F06F0; continue 'dispatch;
	}
	// 828F06D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F06DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F06E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F06E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F06E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F06EC: 4E800421  bctrl
	ctx.lr = 0x828F06F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F06F0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F06F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F06F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F06FC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F0700: 816BA1F4  lwz r11, -0x5e0c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24076 as u32) ) } as u64;
	// 828F0704: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F0708: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F070C: 4B9CF8F5  bl 0x822c0000
	ctx.lr = 0x828F0710;
	sub_822C0000(ctx, base);
	// 828F0710: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F0714: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F0718: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F071C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F0720: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F0724: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F0728: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F0730 size=196
    let mut pc: u32 = 0x828F0730;
    'dispatch: loop {
        match pc {
            0x828F0730 => {
    //   block [0x828F0730..0x828F07F4)
	// 828F0730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F0734: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F0738: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F073C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F0740: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F0744: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F0748: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F074C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F0750: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F0754: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F0758: 4B9D01E1  bl 0x822c0938
	ctx.lr = 0x828F075C;
	sub_822C0938(ctx, base);
	// 828F075C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F0760: 41820028  beq 0x828f0788
	if ctx.cr[0].eq {
	pc = 0x828F0788; continue 'dispatch;
	}
	// 828F0764: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F0768: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F076C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F0770: 392B27F4  addi r9, r11, 0x27f4
	ctx.r[9].s64 = ctx.r[11].s64 + 10228;
	// 828F0774: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F0778: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F077C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F0780: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F0784: 48000008  b 0x828f078c
	pc = 0x828F078C; continue 'dispatch;
	// 828F0788: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F078C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F0790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F0794: 409A0044  bne cr6, 0x828f07d8
	if !ctx.cr[6].eq {
	pc = 0x828F07D8; continue 'dispatch;
	}
	// 828F0798: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F079C: 419A001C  beq cr6, 0x828f07b8
	if ctx.cr[6].eq {
	pc = 0x828F07B8; continue 'dispatch;
	}
	// 828F07A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F07A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F07A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F07AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F07B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F07B4: 4E800421  bctrl
	ctx.lr = 0x828F07B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F07B8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F07BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F07C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F07C4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F07C8: 816BA1F4  lwz r11, -0x5e0c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24076 as u32) ) } as u64;
	// 828F07CC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F07D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F07D4: 4B9CF82D  bl 0x822c0000
	ctx.lr = 0x828F07D8;
	sub_822C0000(ctx, base);
	// 828F07D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F07DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F07E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F07E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F07E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F07EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F07F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F07F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F07F8 size=196
    let mut pc: u32 = 0x828F07F8;
    'dispatch: loop {
        match pc {
            0x828F07F8 => {
    //   block [0x828F07F8..0x828F08BC)
	// 828F07F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F07FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F0800: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F0804: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F0808: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F080C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F0810: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F0814: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F0818: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F081C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F0820: 4B9D0119  bl 0x822c0938
	ctx.lr = 0x828F0824;
	sub_822C0938(ctx, base);
	// 828F0824: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F0828: 41820028  beq 0x828f0850
	if ctx.cr[0].eq {
	pc = 0x828F0850; continue 'dispatch;
	}
	// 828F082C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F0830: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F0834: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F0838: 392B2808  addi r9, r11, 0x2808
	ctx.r[9].s64 = ctx.r[11].s64 + 10248;
	// 828F083C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F0840: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F0844: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F0848: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F084C: 48000008  b 0x828f0854
	pc = 0x828F0854; continue 'dispatch;
	// 828F0850: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F0854: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F0858: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F085C: 409A0044  bne cr6, 0x828f08a0
	if !ctx.cr[6].eq {
	pc = 0x828F08A0; continue 'dispatch;
	}
	// 828F0860: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F0864: 419A001C  beq cr6, 0x828f0880
	if ctx.cr[6].eq {
	pc = 0x828F0880; continue 'dispatch;
	}
	// 828F0868: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F086C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F0870: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0874: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F0878: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F087C: 4E800421  bctrl
	ctx.lr = 0x828F0880;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F0880: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F0884: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F0888: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F088C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F0890: 816BA1F4  lwz r11, -0x5e0c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24076 as u32) ) } as u64;
	// 828F0894: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F0898: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F089C: 4B9CF765  bl 0x822c0000
	ctx.lr = 0x828F08A0;
	sub_822C0000(ctx, base);
	// 828F08A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F08A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F08A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F08AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F08B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F08B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F08B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F08C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F08C0 size=196
    let mut pc: u32 = 0x828F08C0;
    'dispatch: loop {
        match pc {
            0x828F08C0 => {
    //   block [0x828F08C0..0x828F0984)
	// 828F08C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F08C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F08C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F08CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F08D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F08D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F08D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F08DC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F08E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F08E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F08E8: 4B9D0051  bl 0x822c0938
	ctx.lr = 0x828F08EC;
	sub_822C0938(ctx, base);
	// 828F08EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F08F0: 41820028  beq 0x828f0918
	if ctx.cr[0].eq {
	pc = 0x828F0918; continue 'dispatch;
	}
	// 828F08F4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F08F8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F08FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F0900: 392B281C  addi r9, r11, 0x281c
	ctx.r[9].s64 = ctx.r[11].s64 + 10268;
	// 828F0904: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F0908: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F090C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F0910: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F0914: 48000008  b 0x828f091c
	pc = 0x828F091C; continue 'dispatch;
	// 828F0918: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F091C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F0920: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F0924: 409A0044  bne cr6, 0x828f0968
	if !ctx.cr[6].eq {
	pc = 0x828F0968; continue 'dispatch;
	}
	// 828F0928: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F092C: 419A001C  beq cr6, 0x828f0948
	if ctx.cr[6].eq {
	pc = 0x828F0948; continue 'dispatch;
	}
	// 828F0930: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0934: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F0938: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F093C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F0940: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F0944: 4E800421  bctrl
	ctx.lr = 0x828F0948;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F0948: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F094C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F0950: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0954: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F0958: 816BA1F4  lwz r11, -0x5e0c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24076 as u32) ) } as u64;
	// 828F095C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F0960: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F0964: 4B9CF69D  bl 0x822c0000
	ctx.lr = 0x828F0968;
	sub_822C0000(ctx, base);
	// 828F0968: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F096C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F0970: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F0974: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F0978: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F097C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F0980: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F0988 size=196
    let mut pc: u32 = 0x828F0988;
    'dispatch: loop {
        match pc {
            0x828F0988 => {
    //   block [0x828F0988..0x828F0A4C)
	// 828F0988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F098C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F0990: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F0994: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F0998: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F099C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F09A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F09A4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F09A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F09AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F09B0: 4B9CFF89  bl 0x822c0938
	ctx.lr = 0x828F09B4;
	sub_822C0938(ctx, base);
	// 828F09B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F09B8: 41820028  beq 0x828f09e0
	if ctx.cr[0].eq {
	pc = 0x828F09E0; continue 'dispatch;
	}
	// 828F09BC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F09C0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F09C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F09C8: 392B2830  addi r9, r11, 0x2830
	ctx.r[9].s64 = ctx.r[11].s64 + 10288;
	// 828F09CC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F09D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F09D4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F09D8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F09DC: 48000008  b 0x828f09e4
	pc = 0x828F09E4; continue 'dispatch;
	// 828F09E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F09E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F09E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F09EC: 409A0044  bne cr6, 0x828f0a30
	if !ctx.cr[6].eq {
	pc = 0x828F0A30; continue 'dispatch;
	}
	// 828F09F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F09F4: 419A001C  beq cr6, 0x828f0a10
	if ctx.cr[6].eq {
	pc = 0x828F0A10; continue 'dispatch;
	}
	// 828F09F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F09FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F0A00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0A04: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F0A08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F0A0C: 4E800421  bctrl
	ctx.lr = 0x828F0A10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F0A10: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F0A14: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F0A18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0A1C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F0A20: 816BA1F4  lwz r11, -0x5e0c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24076 as u32) ) } as u64;
	// 828F0A24: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F0A28: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F0A2C: 4B9CF5D5  bl 0x822c0000
	ctx.lr = 0x828F0A30;
	sub_822C0000(ctx, base);
	// 828F0A30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F0A34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F0A38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F0A3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F0A40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F0A44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F0A48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F0A50 size=196
    let mut pc: u32 = 0x828F0A50;
    'dispatch: loop {
        match pc {
            0x828F0A50 => {
    //   block [0x828F0A50..0x828F0B14)
	// 828F0A50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F0A54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F0A58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F0A5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F0A60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F0A64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F0A68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F0A6C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F0A70: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F0A74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F0A78: 4B9CFEC1  bl 0x822c0938
	ctx.lr = 0x828F0A7C;
	sub_822C0938(ctx, base);
	// 828F0A7C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F0A80: 41820028  beq 0x828f0aa8
	if ctx.cr[0].eq {
	pc = 0x828F0AA8; continue 'dispatch;
	}
	// 828F0A84: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F0A88: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F0A8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F0A90: 392B2844  addi r9, r11, 0x2844
	ctx.r[9].s64 = ctx.r[11].s64 + 10308;
	// 828F0A94: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F0A98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F0A9C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F0AA0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F0AA4: 48000008  b 0x828f0aac
	pc = 0x828F0AAC; continue 'dispatch;
	// 828F0AA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F0AAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F0AB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F0AB4: 409A0044  bne cr6, 0x828f0af8
	if !ctx.cr[6].eq {
	pc = 0x828F0AF8; continue 'dispatch;
	}
	// 828F0AB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F0ABC: 419A001C  beq cr6, 0x828f0ad8
	if ctx.cr[6].eq {
	pc = 0x828F0AD8; continue 'dispatch;
	}
	// 828F0AC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0AC4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F0AC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0ACC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F0AD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F0AD4: 4E800421  bctrl
	ctx.lr = 0x828F0AD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F0AD8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F0ADC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F0AE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0AE4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F0AE8: 816BA1F4  lwz r11, -0x5e0c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24076 as u32) ) } as u64;
	// 828F0AEC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F0AF0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F0AF4: 4B9CF50D  bl 0x822c0000
	ctx.lr = 0x828F0AF8;
	sub_822C0000(ctx, base);
	// 828F0AF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F0AFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F0B00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F0B04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F0B08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F0B0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F0B10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F0B18 size=196
    let mut pc: u32 = 0x828F0B18;
    'dispatch: loop {
        match pc {
            0x828F0B18 => {
    //   block [0x828F0B18..0x828F0BDC)
	// 828F0B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F0B1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F0B20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F0B24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F0B28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F0B2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F0B30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F0B34: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F0B38: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F0B3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F0B40: 4B9CFDF9  bl 0x822c0938
	ctx.lr = 0x828F0B44;
	sub_822C0938(ctx, base);
	// 828F0B44: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F0B48: 41820028  beq 0x828f0b70
	if ctx.cr[0].eq {
	pc = 0x828F0B70; continue 'dispatch;
	}
	// 828F0B4C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F0B50: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F0B54: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F0B58: 392B2858  addi r9, r11, 0x2858
	ctx.r[9].s64 = ctx.r[11].s64 + 10328;
	// 828F0B5C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F0B60: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F0B64: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F0B68: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F0B6C: 48000008  b 0x828f0b74
	pc = 0x828F0B74; continue 'dispatch;
	// 828F0B70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F0B74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F0B78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F0B7C: 409A0044  bne cr6, 0x828f0bc0
	if !ctx.cr[6].eq {
	pc = 0x828F0BC0; continue 'dispatch;
	}
	// 828F0B80: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F0B84: 419A001C  beq cr6, 0x828f0ba0
	if ctx.cr[6].eq {
	pc = 0x828F0BA0; continue 'dispatch;
	}
	// 828F0B88: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0B8C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F0B90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0B94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F0B98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F0B9C: 4E800421  bctrl
	ctx.lr = 0x828F0BA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F0BA0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F0BA4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F0BA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0BAC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F0BB0: 816BA1F4  lwz r11, -0x5e0c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24076 as u32) ) } as u64;
	// 828F0BB4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F0BB8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F0BBC: 4B9CF445  bl 0x822c0000
	ctx.lr = 0x828F0BC0;
	sub_822C0000(ctx, base);
	// 828F0BC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F0BC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F0BC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F0BCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F0BD0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F0BD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F0BD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F0BE0 size=196
    let mut pc: u32 = 0x828F0BE0;
    'dispatch: loop {
        match pc {
            0x828F0BE0 => {
    //   block [0x828F0BE0..0x828F0CA4)
	// 828F0BE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F0BE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F0BE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F0BEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F0BF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F0BF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F0BF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F0BFC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F0C00: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F0C04: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F0C08: 4B9CFD31  bl 0x822c0938
	ctx.lr = 0x828F0C0C;
	sub_822C0938(ctx, base);
	// 828F0C0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F0C10: 41820028  beq 0x828f0c38
	if ctx.cr[0].eq {
	pc = 0x828F0C38; continue 'dispatch;
	}
	// 828F0C14: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F0C18: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F0C1C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F0C20: 392B286C  addi r9, r11, 0x286c
	ctx.r[9].s64 = ctx.r[11].s64 + 10348;
	// 828F0C24: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F0C28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F0C2C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F0C30: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F0C34: 48000008  b 0x828f0c3c
	pc = 0x828F0C3C; continue 'dispatch;
	// 828F0C38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F0C3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F0C40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F0C44: 409A0044  bne cr6, 0x828f0c88
	if !ctx.cr[6].eq {
	pc = 0x828F0C88; continue 'dispatch;
	}
	// 828F0C48: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F0C4C: 419A001C  beq cr6, 0x828f0c68
	if ctx.cr[6].eq {
	pc = 0x828F0C68; continue 'dispatch;
	}
	// 828F0C50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0C54: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F0C58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0C5C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F0C60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F0C64: 4E800421  bctrl
	ctx.lr = 0x828F0C68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F0C68: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F0C6C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F0C70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0C74: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F0C78: 816BA1F4  lwz r11, -0x5e0c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24076 as u32) ) } as u64;
	// 828F0C7C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F0C80: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F0C84: 4B9CF37D  bl 0x822c0000
	ctx.lr = 0x828F0C88;
	sub_822C0000(ctx, base);
	// 828F0C88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F0C8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F0C90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F0C94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F0C98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F0C9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F0CA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F0CA8 size=196
    let mut pc: u32 = 0x828F0CA8;
    'dispatch: loop {
        match pc {
            0x828F0CA8 => {
    //   block [0x828F0CA8..0x828F0D6C)
	// 828F0CA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F0CAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F0CB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F0CB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F0CB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F0CBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F0CC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F0CC4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F0CC8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F0CCC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F0CD0: 4B9CFC69  bl 0x822c0938
	ctx.lr = 0x828F0CD4;
	sub_822C0938(ctx, base);
	// 828F0CD4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F0CD8: 41820028  beq 0x828f0d00
	if ctx.cr[0].eq {
	pc = 0x828F0D00; continue 'dispatch;
	}
	// 828F0CDC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F0CE0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F0CE4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F0CE8: 392B2880  addi r9, r11, 0x2880
	ctx.r[9].s64 = ctx.r[11].s64 + 10368;
	// 828F0CEC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F0CF0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F0CF4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F0CF8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F0CFC: 48000008  b 0x828f0d04
	pc = 0x828F0D04; continue 'dispatch;
	// 828F0D00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F0D04: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F0D08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F0D0C: 409A0044  bne cr6, 0x828f0d50
	if !ctx.cr[6].eq {
	pc = 0x828F0D50; continue 'dispatch;
	}
	// 828F0D10: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F0D14: 419A001C  beq cr6, 0x828f0d30
	if ctx.cr[6].eq {
	pc = 0x828F0D30; continue 'dispatch;
	}
	// 828F0D18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0D1C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F0D20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0D24: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F0D28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F0D2C: 4E800421  bctrl
	ctx.lr = 0x828F0D30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F0D30: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F0D34: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F0D38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0D3C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F0D40: 816BA1F4  lwz r11, -0x5e0c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24076 as u32) ) } as u64;
	// 828F0D44: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F0D48: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F0D4C: 4B9CF2B5  bl 0x822c0000
	ctx.lr = 0x828F0D50;
	sub_822C0000(ctx, base);
	// 828F0D50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F0D54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F0D58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F0D5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F0D60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F0D64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F0D68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F0D70 size=108
    let mut pc: u32 = 0x828F0D70;
    'dispatch: loop {
        match pc {
            0x828F0D70 => {
    //   block [0x828F0D70..0x828F0DDC)
	// 828F0D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F0D74: 488B73F9  bl 0x831a816c
	ctx.lr = 0x828F0D78;
	sub_831A8130(ctx, base);
	// 828F0D78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F0D7C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828F0D80: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F0D84: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F0D88: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F0D8C: 41820038  beq 0x828f0dc4
	if ctx.cr[0].eq {
	pc = 0x828F0DC4; continue 'dispatch;
	}
	// 828F0D90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0D94: 488B8BF5  bl 0x831a9988
	ctx.lr = 0x828F0D98;
	sub_831A9988(ctx, base);
	// 828F0D98: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828F0D9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F0DA0: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 828F0DA4: 488B7355  bl 0x831a80f8
	ctx.lr = 0x828F0DA8;
	sub_831A80F8(ctx, base);
	// 828F0DA8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F0DAC: 41820018  beq 0x828f0dc4
	if ctx.cr[0].eq {
	pc = 0x828F0DC4; continue 'dispatch;
	}
	// 828F0DB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F0DB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F0DB8: 4BF8D3E1  bl 0x8287e198
	ctx.lr = 0x828F0DBC;
	sub_8287E198(ctx, base);
	// 828F0DBC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828F0DC0: 48000014  b 0x828f0dd4
	pc = 0x828F0DD4; continue 'dispatch;
	// 828F0DC4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828F0DC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F0DCC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F0DD0: 4888D6B9  bl 0x8317e488
	ctx.lr = 0x828F0DD4;
	sub_8317E488(ctx, base);
	// 828F0DD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F0DD8: 488B73E4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F0DE0 size=96
    let mut pc: u32 = 0x828F0DE0;
    'dispatch: loop {
        match pc {
            0x828F0DE0 => {
    //   block [0x828F0DE0..0x828F0E40)
	// 828F0DE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F0DE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F0DE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F0DEC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F0DF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F0DF4: 4BFFE6A5  bl 0x828ef498
	ctx.lr = 0x828F0DF8;
	sub_828EF498(ctx, base);
	// 828F0DF8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F0DFC: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828F0E00: 396B29FC  addi r11, r11, 0x29fc
	ctx.r[11].s64 = ctx.r[11].s64 + 10748;
	// 828F0E04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0E08: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F0E0C: 808A0B30  lwz r4, 0xb30(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2864 as u32) ) } as u64;
	// 828F0E10: 48502BF9  bl 0x82df3a08
	ctx.lr = 0x828F0E14;
	sub_82DF3A08(ctx, base);
	// 828F0E14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0E18: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F0E1C: 485688CD  bl 0x82e596e8
	ctx.lr = 0x828F0E20;
	sub_82E596E8(ctx, base);
	// 828F0E20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0E24: 48502605  bl 0x82df3428
	ctx.lr = 0x828F0E28;
	sub_82DF3428(ctx, base);
	// 828F0E28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0E2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F0E30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F0E34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F0E38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F0E3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F0E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F0E40 size=684
    let mut pc: u32 = 0x828F0E40;
    'dispatch: loop {
        match pc {
            0x828F0E40 => {
    //   block [0x828F0E40..0x828F10EC)
	// 828F0E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F0E44: 488B7325  bl 0x831a8168
	ctx.lr = 0x828F0E48;
	sub_831A8130(ctx, base);
	// 828F0E48: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 828F0E4C: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828F0E50: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F0E54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F0E58: 488637A9  bl 0x83154600
	ctx.lr = 0x828F0E5C;
	sub_83154600(ctx, base);
	// 828F0E5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F0E60: 48025909  bl 0x82916768
	ctx.lr = 0x828F0E64;
	sub_82916768(ctx, base);
	// 828F0E64: 48018725  bl 0x82909588
	ctx.lr = 0x828F0E68;
	sub_82909588(ctx, base);
	// 828F0E68: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 828F0E6C: 4804F5E5  bl 0x82940450
	ctx.lr = 0x828F0E70;
	sub_82940450(ctx, base);
	// 828F0E70: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F0E74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F0E78: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F0E7C: 48051855  bl 0x829426d0
	ctx.lr = 0x828F0E80;
	sub_829426D0(ctx, base);
	// 828F0E80: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0E84: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0E88: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828F0E8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F0E90: 4E800421  bctrl
	ctx.lr = 0x828F0E94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F0E94: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828F0E98: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828F0E9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F0EA0: 419A000C  beq cr6, 0x828f0eac
	if ctx.cr[6].eq {
	pc = 0x828F0EAC; continue 'dispatch;
	}
	// 828F0EA4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828F0EA8: 4B9CF9E9  bl 0x822c0890
	ctx.lr = 0x828F0EAC;
	sub_822C0890(ctx, base);
	// 828F0EAC: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F0EB0: 4182002C  beq 0x828f0edc
	if ctx.cr[0].eq {
	pc = 0x828F0EDC; continue 'dispatch;
	}
	// 828F0EB4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F0EB8: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828F0EBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0EC0: 48502B49  bl 0x82df3a08
	ctx.lr = 0x828F0EC4;
	sub_82DF3A08(ctx, base);
	// 828F0EC4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F0EC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0ECC: 4BEFE875  bl 0x827ef740
	ctx.lr = 0x828F0ED0;
	sub_827EF740(ctx, base);
	// 828F0ED0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F0ED4: 48502555  bl 0x82df3428
	ctx.lr = 0x828F0ED8;
	sub_82DF3428(ctx, base);
	// 828F0ED8: 48000204  b 0x828f10dc
	pc = 0x828F10DC; continue 'dispatch;
	// 828F0EDC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F0EE0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F0EE4: 480517ED  bl 0x829426d0
	ctx.lr = 0x828F0EE8;
	sub_829426D0(ctx, base);
	// 828F0EE8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0EEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0EF0: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F0EF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F0EF8: 4E800421  bctrl
	ctx.lr = 0x828F0EFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F0EFC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828F0F00: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F0F04: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828F0F08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F0F0C: 557DDFFE  rlwinm r29, r11, 0x1b, 0x1f, 0x1f
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828F0F10: 419A0008  beq cr6, 0x828f0f18
	if ctx.cr[6].eq {
	pc = 0x828F0F18; continue 'dispatch;
	}
	// 828F0F14: 4B9CF97D  bl 0x822c0890
	ctx.lr = 0x828F0F18;
	sub_822C0890(ctx, base);
	// 828F0F18: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F0F1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0F20: 41820024  beq 0x828f0f44
	if ctx.cr[0].eq {
	pc = 0x828F0F44; continue 'dispatch;
	}
	// 828F0F24: 48025845  bl 0x82916768
	ctx.lr = 0x828F0F28;
	sub_82916768(ctx, base);
	// 828F0F28: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F0F2C: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828F0F30: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F0F34: 4801DE45  bl 0x8290ed78
	ctx.lr = 0x828F0F38;
	sub_8290ED78(ctx, base);
	// 828F0F38: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F0F3C: 808B0B10  lwz r4, 0xb10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2832 as u32) ) } as u64;
	// 828F0F40: 4BFFFF7C  b 0x828f0ebc
	pc = 0x828F0EBC; continue 'dispatch;
	// 828F0F44: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F0F48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F0F4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F0F50: 4E800421  bctrl
	ctx.lr = 0x828F0F54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F0F54: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F0F58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F0F5C: 4802580D  bl 0x82916768
	ctx.lr = 0x828F0F60;
	sub_82916768(ctx, base);
	// 828F0F60: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F0F64: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828F0F68: 480186F1  bl 0x82909658
	ctx.lr = 0x828F0F6C;
	sub_82909658(ctx, base);
	// 828F0F6C: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828F0F70: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828F0F74: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F10F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F10F0 size=620
    let mut pc: u32 = 0x828F10F0;
    'dispatch: loop {
        match pc {
            0x828F10F0 => {
    //   block [0x828F10F0..0x828F135C)
	// 828F10F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F10F4: 488B7061  bl 0x831a8154
	ctx.lr = 0x828F10F8;
	sub_831A8130(ctx, base);
	// 828F10F8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F10FC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828F1100: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 828F1104: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 828F1108: 488634F9  bl 0x83154600
	ctx.lr = 0x828F110C;
	sub_83154600(ctx, base);
	// 828F110C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F1110: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F1114: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F1118: 808BA07C  lwz r4, -0x5f84(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24452 as u32) ) } as u64;
	// 828F111C: 485028ED  bl 0x82df3a08
	ctx.lr = 0x828F1120;
	sub_82DF3A08(ctx, base);
	// 828F1120: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1124: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1128: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F112C: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F1130: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F1134: 4E800421  bctrl
	ctx.lr = 0x828F1138;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F1138: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F113C: 485022ED  bl 0x82df3428
	ctx.lr = 0x828F1140;
	sub_82DF3428(ctx, base);
	// 828F1140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1144: 48025625  bl 0x82916768
	ctx.lr = 0x828F1148;
	sub_82916768(ctx, base);
	// 828F1148: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F114C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F1150: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828F1154: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F1158: 4E800421  bctrl
	ctx.lr = 0x828F115C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F115C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1160: 48025609  bl 0x82916768
	ctx.lr = 0x828F1164;
	sub_82916768(ctx, base);
	// 828F1164: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1168: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F116C: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828F1170: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F1174: 4E800421  bctrl
	ctx.lr = 0x828F1178;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F1178: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F117C: 480255ED  bl 0x82916768
	ctx.lr = 0x828F1180;
	sub_82916768(ctx, base);
	// 828F1180: 48018409  bl 0x82909588
	ctx.lr = 0x828F1184;
	sub_82909588(ctx, base);
	// 828F1184: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F1188: 4804F321  bl 0x829404a8
	ctx.lr = 0x828F118C;
	sub_829404A8(ctx, base);
	// 828F118C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F1190: 48050E59  bl 0x82941fe8
	ctx.lr = 0x828F1194;
	sub_82941FE8(ctx, base);
	// 828F1194: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F1198: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F119C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F11A0: 3B8B2A20  addi r28, r11, 0x2a20
	ctx.r[28].s64 = ctx.r[11].s64 + 10784;
	// 828F11A4: 38A00061  li r5, 0x61
	ctx.r[5].s64 = 97;
	// 828F11A8: C00A08A8  lfs f0, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F11AC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828F11B0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828F11B4: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828F11B8: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828F11BC: 4B9CF21D  bl 0x822c03d8
	ctx.lr = 0x828F11C0;
	sub_822C03D8(ctx, base);
	// 828F11C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F11C4: 41820018  beq 0x828f11dc
	if ctx.cr[0].eq {
	pc = 0x828F11DC; continue 'dispatch;
	}
	// 828F11C8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828F11CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F11D0: 48050E39  bl 0x82942008
	ctx.lr = 0x828F11D4;
	sub_82942008(ctx, base);
	// 828F11D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F11D8: 48000008  b 0x828f11e0
	pc = 0x828F11E0; continue 'dispatch;
	// 828F11DC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828F11E0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828F11E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F11E8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F11EC: 4BF7CC45  bl 0x8286de30
	ctx.lr = 0x828F11F0;
	sub_8286DE30(ctx, base);
	// 828F11F0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828F11F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F11F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F11FC: 4B9CEE05  bl 0x822c0000
	ctx.lr = 0x828F1200;
	sub_822C0000(ctx, base);
	// 828F1200: 83010054  lwz r24, 0x54(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F1204: 83410050  lwz r26, 0x50(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F1208: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 828F120C: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 828F1210: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 828F1214: 419A0024  beq cr6, 0x828f1238
	if ctx.cr[6].eq {
	pc = 0x828F1238; continue 'dispatch;
	}
	// 828F1218: 39780004  addi r11, r24, 4
	ctx.r[11].s64 = ctx.r[24].s64 + 4;
	// 828F121C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828F1220: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F1224: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828F1228: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828F122C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F1230: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F1234: 4082FFE8  bne 0x828f121c
	if !ctx.cr[0].eq {
	pc = 0x828F121C; continue 'dispatch;
	}
	// 828F1238: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F123C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F1240: 4804F271  bl 0x829404b0
	ctx.lr = 0x828F1244;
	sub_829404B0(ctx, base);
	// 828F1244: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1248: 4BEFC5D1  bl 0x827ed818
	ctx.lr = 0x828F124C;
	sub_827ED818(ctx, base);
	// 828F124C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1250: 816B01B0  lwz r11, 0x1b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(432 as u32) ) } as u64;
	// 828F1254: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F1258: 4E800421  bctrl
	ctx.lr = 0x828F125C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F125C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828F1260: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828F1264: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F1268: 38A00066  li r5, 0x66
	ctx.r[5].s64 = 102;
	// 828F126C: 3860002C  li r3, 0x2c
	ctx.r[3].s64 = 44;
	// 828F1270: 4B9CF169  bl 0x822c03d8
	ctx.lr = 0x828F1274;
	sub_822C03D8(ctx, base);
	// 828F1274: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828F1278: 41820030  beq 0x828f12a8
	if ctx.cr[0].eq {
	pc = 0x828F12A8; continue 'dispatch;
	}
	// 828F127C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828F1280: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F1284: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 828F1288: 48051449  bl 0x829426d0
	ctx.lr = 0x828F128C;
	sub_829426D0(ctx, base);
	// 828F128C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828F1290: 38BB01A0  addi r5, r27, 0x1a0
	ctx.r[5].s64 = ctx.r[27].s64 + 416;
	// 828F1294: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F1298: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F129C: 4804FB25  bl 0x82940dc0
	ctx.lr = 0x828F12A0;
	sub_82940DC0(ctx, base);
	// 828F12A0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F12A4: 48000008  b 0x828f12ac
	pc = 0x828F12AC; continue 'dispatch;
	// 828F12A8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828F12AC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828F12B0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F12B4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F12B8: 4BFDB131  bl 0x828cc3e8
	ctx.lr = 0x828F12BC;
	sub_828CC3E8(ctx, base);
	// 828F12BC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828F12C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F12C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F12C8: 4B9CED39  bl 0x822c0000
	ctx.lr = 0x828F12CC;
	sub_822C0000(ctx, base);
	// 828F12CC: 572B07FF  clrlwi. r11, r25, 0x1f
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F12D0: 41820014  beq 0x828f12e4
	if ctx.cr[0].eq {
	pc = 0x828F12E4; continue 'dispatch;
	}
	// 828F12D4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F12D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F12DC: 419A0008  beq cr6, 0x828f12e4
	if ctx.cr[6].eq {
	pc = 0x828F12E4; continue 'dispatch;
	}
	// 828F12E0: 4B9CF5B1  bl 0x822c0890
	ctx.lr = 0x828F12E4;
	sub_822C0890(ctx, base);
	// 828F12E4: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F12E8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F12EC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828F12F0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828F12F4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828F12F8: 419A0024  beq cr6, 0x828f131c
	if ctx.cr[6].eq {
	pc = 0x828F131C; continue 'dispatch;
	}
	// 828F12FC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 828F1300: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828F1304: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F1308: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828F130C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828F1310: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F1314: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F1318: 4082FFE8  bne 0x828f1300
	if !ctx.cr[0].eq {
	pc = 0x828F1300; continue 'dispatch;
	}
	// 828F131C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F1320: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F1324: 4804F18D  bl 0x829404b0
	ctx.lr = 0x828F1328;
	sub_829404B0(ctx, base);
	// 828F1328: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828F132C: 419A000C  beq cr6, 0x828f1338
	if ctx.cr[6].eq {
	pc = 0x828F1338; continue 'dispatch;
	}
	// 828F1330: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F1334: 4B9CF55D  bl 0x822c0890
	ctx.lr = 0x828F1338;
	sub_822C0890(ctx, base);
	// 828F1338: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 828F133C: 419A000C  beq cr6, 0x828f1348
	if ctx.cr[6].eq {
	pc = 0x828F1348; continue 'dispatch;
	}
	// 828F1340: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828F1344: 4B9CF54D  bl 0x822c0890
	ctx.lr = 0x828F1348;
	sub_822C0890(ctx, base);
	// 828F1348: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F134C: 480257B5  bl 0x82916b00
	ctx.lr = 0x828F1350;
	sub_82916B00(ctx, base);
	// 828F1350: 98770064  stb r3, 0x64(r23)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[23].u32.wrapping_add(100 as u32), ctx.r[3].u8 ) };
	// 828F1354: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828F1358: 488B6E4C  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F1360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F1360 size=112
    let mut pc: u32 = 0x828F1360;
    'dispatch: loop {
        match pc {
            0x828F1360 => {
    //   block [0x828F1360..0x828F13D0)
	// 828F1360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F1364: 488B6E09  bl 0x831a816c
	ctx.lr = 0x828F1368;
	sub_831A8130(ctx, base);
	// 828F1368: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F136C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F1370: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F1374: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F1378: 388B2A20  addi r4, r11, 0x2a20
	ctx.r[4].s64 = ctx.r[11].s64 + 10784;
	// 828F137C: 38A000DE  li r5, 0xde
	ctx.r[5].s64 = 222;
	// 828F1380: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 828F1384: 48501065  bl 0x82df23e8
	ctx.lr = 0x828F1388;
	sub_82DF23E8(ctx, base);
	// 828F1388: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F138C: 41820010  beq 0x828f139c
	if ctx.cr[0].eq {
	pc = 0x828F139C; continue 'dispatch;
	}
	// 828F1390: 4BFFFA51  bl 0x828f0de0
	ctx.lr = 0x828F1394;
	sub_828F0DE0(ctx, base);
	// 828F1394: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F1398: 48000008  b 0x828f13a0
	pc = 0x828F13A0; continue 'dispatch;
	// 828F139C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F13A0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F13A4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828F13A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F13AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F13B0: 4BFFF1F1  bl 0x828f05a0
	ctx.lr = 0x828F13B4;
	sub_828F05A0(ctx, base);
	// 828F13B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F13B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F13BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F13C0: 4B9CEC41  bl 0x822c0000
	ctx.lr = 0x828F13C4;
	sub_822C0000(ctx, base);
	// 828F13C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F13C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F13CC: 488B6DF0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F13D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F13D0 size=392
    let mut pc: u32 = 0x828F13D0;
    'dispatch: loop {
        match pc {
            0x828F13D0 => {
    //   block [0x828F13D0..0x828F1558)
	// 828F13D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F13D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F13D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F13DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F13E0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828F13E4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F13E8: 48863219  bl 0x83154600
	ctx.lr = 0x828F13EC;
	sub_83154600(ctx, base);
	// 828F13EC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F13F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F13F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F13F8: 808BA020  lwz r4, -0x5fe0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24544 as u32) ) } as u64;
	// 828F13FC: 4850260D  bl 0x82df3a08
	ctx.lr = 0x828F1400;
	sub_82DF3A08(ctx, base);
	// 828F1400: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1404: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1408: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F140C: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F1410: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F1414: 4E800421  bctrl
	ctx.lr = 0x828F1418;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F1418: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F141C: 4850200D  bl 0x82df3428
	ctx.lr = 0x828F1420;
	sub_82DF3428(ctx, base);
	// 828F1420: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1424: 48025345  bl 0x82916768
	ctx.lr = 0x828F1428;
	sub_82916768(ctx, base);
	// 828F1428: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F142C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F1430: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828F1434: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F1438: 4E800421  bctrl
	ctx.lr = 0x828F143C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F143C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1440: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828F1444: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828F1448: 48025BD9  bl 0x82917020
	ctx.lr = 0x828F144C;
	sub_82917020(ctx, base);
	// 828F144C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1450: 4BEFC3C9  bl 0x827ed818
	ctx.lr = 0x828F1454;
	sub_827ED818(ctx, base);
	// 828F1454: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1458: 816B01B0  lwz r11, 0x1b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(432 as u32) ) } as u64;
	// 828F145C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F1460: 4E800421  bctrl
	ctx.lr = 0x828F1464;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F1464: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1468: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F146C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1470: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828F1474: C3FE0200  lfs f31, 0x200(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(512 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828F1478: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F147C: 4E800421  bctrl
	ctx.lr = 0x828F1480;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F1480: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F1484: 4BEF8EE5  bl 0x827ea368
	ctx.lr = 0x828F1488;
	sub_827EA368(ctx, base);
	// 828F1488: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F148C: C1BE0214  lfs f13, 0x214(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F1490: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1494: C19E0218  lfs f12, 0x218(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(536 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828F1498: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828F149C: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828F14A0: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828F14A4: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F14A8: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828F14AC: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828F14B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F14B4: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828F14B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F14BC: 4E800421  bctrl
	ctx.lr = 0x828F14C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F14C0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828F14C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F14C8: 388B5D2C  addi r4, r11, 0x5d2c
	ctx.r[4].s64 = ctx.r[11].s64 + 23852;
	// 828F14CC: 4850253D  bl 0x82df3a08
	ctx.lr = 0x828F14D0;
	sub_82DF3A08(ctx, base);
	// 828F14D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F14D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F14D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F14DC: 816B0098  lwz r11, 0x98(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) } as u64;
	// 828F14E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F14E4: 4E800421  bctrl
	ctx.lr = 0x828F14E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F14E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F14EC: 48501F3D  bl 0x82df3428
	ctx.lr = 0x828F14F0;
	sub_82DF3428(ctx, base);
	// 828F14F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F14F4: 4BEFC325  bl 0x827ed818
	ctx.lr = 0x828F14F8;
	sub_827ED818(ctx, base);
	// 828F14F8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F14FC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828F1500: 4BFF5489  bl 0x828e6988
	ctx.lr = 0x828F1504;
	sub_828E6988(ctx, base);
	// 828F1504: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1508: 48025261  bl 0x82916768
	ctx.lr = 0x828F150C;
	sub_82916768(ctx, base);
	// 828F150C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1510: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828F1514: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F1518: 38AA2A98  addi r5, r10, 0x2a98
	ctx.r[5].s64 = ctx.r[10].s64 + 10904;
	// 828F151C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F1520: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828F1524: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F1528: 4E800421  bctrl
	ctx.lr = 0x828F152C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F152C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828F1530: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F1534: 419A0008  beq cr6, 0x828f153c
	if ctx.cr[6].eq {
	pc = 0x828F153C; continue 'dispatch;
	}
	// 828F1538: 4B9CF359  bl 0x822c0890
	ctx.lr = 0x828F153C;
	sub_822C0890(ctx, base);
	// 828F153C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828F1540: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F1544: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F1548: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828F154C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F1550: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F1554: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F1558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F1558 size=112
    let mut pc: u32 = 0x828F1558;
    'dispatch: loop {
        match pc {
            0x828F1558 => {
    //   block [0x828F1558..0x828F15C8)
	// 828F1558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F155C: 488B6C11  bl 0x831a816c
	ctx.lr = 0x828F1560;
	sub_831A8130(ctx, base);
	// 828F1560: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F1564: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F1568: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F156C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F1570: 388B2A20  addi r4, r11, 0x2a20
	ctx.r[4].s64 = ctx.r[11].s64 + 10784;
	// 828F1574: 38A0012B  li r5, 0x12b
	ctx.r[5].s64 = 299;
	// 828F1578: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828F157C: 48500E6D  bl 0x82df23e8
	ctx.lr = 0x828F1580;
	sub_82DF23E8(ctx, base);
	// 828F1580: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F1584: 41820010  beq 0x828f1594
	if ctx.cr[0].eq {
	pc = 0x828F1594; continue 'dispatch;
	}
	// 828F1588: 4BFFE221  bl 0x828ef7a8
	ctx.lr = 0x828F158C;
	sub_828EF7A8(ctx, base);
	// 828F158C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F1590: 48000008  b 0x828f1598
	pc = 0x828F1598; continue 'dispatch;
	// 828F1594: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F1598: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F159C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828F15A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F15A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F15A8: 4BFFF0C1  bl 0x828f0668
	ctx.lr = 0x828F15AC;
	sub_828F0668(ctx, base);
	// 828F15AC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F15B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F15B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F15B8: 4B9CEA49  bl 0x822c0000
	ctx.lr = 0x828F15BC;
	sub_822C0000(ctx, base);
	// 828F15BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F15C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F15C4: 488B6BF8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F15C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F15C8 size=112
    let mut pc: u32 = 0x828F15C8;
    'dispatch: loop {
        match pc {
            0x828F15C8 => {
    //   block [0x828F15C8..0x828F1638)
	// 828F15C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F15CC: 488B6BA1  bl 0x831a816c
	ctx.lr = 0x828F15D0;
	sub_831A8130(ctx, base);
	// 828F15D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F15D4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F15D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F15DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F15E0: 388B2A20  addi r4, r11, 0x2a20
	ctx.r[4].s64 = ctx.r[11].s64 + 10784;
	// 828F15E4: 38A00171  li r5, 0x171
	ctx.r[5].s64 = 369;
	// 828F15E8: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828F15EC: 48500DFD  bl 0x82df23e8
	ctx.lr = 0x828F15F0;
	sub_82DF23E8(ctx, base);
	// 828F15F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F15F4: 41820010  beq 0x828f1604
	if ctx.cr[0].eq {
	pc = 0x828F1604; continue 'dispatch;
	}
	// 828F15F8: 4BFFE381  bl 0x828ef978
	ctx.lr = 0x828F15FC;
	sub_828EF978(ctx, base);
	// 828F15FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F1600: 48000008  b 0x828f1608
	pc = 0x828F1608; continue 'dispatch;
	// 828F1604: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F1608: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F160C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828F1610: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F1614: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F1618: 4BFFF119  bl 0x828f0730
	ctx.lr = 0x828F161C;
	sub_828F0730(ctx, base);
	// 828F161C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F1620: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F1624: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F1628: 4B9CE9D9  bl 0x822c0000
	ctx.lr = 0x828F162C;
	sub_822C0000(ctx, base);
	// 828F162C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F1630: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F1634: 488B6B88  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F1638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F1638 size=112
    let mut pc: u32 = 0x828F1638;
    'dispatch: loop {
        match pc {
            0x828F1638 => {
    //   block [0x828F1638..0x828F16A8)
	// 828F1638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F163C: 488B6B31  bl 0x831a816c
	ctx.lr = 0x828F1640;
	sub_831A8130(ctx, base);
	// 828F1640: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F1644: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F1648: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F164C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F1650: 388B2A20  addi r4, r11, 0x2a20
	ctx.r[4].s64 = ctx.r[11].s64 + 10784;
	// 828F1654: 38A001AC  li r5, 0x1ac
	ctx.r[5].s64 = 428;
	// 828F1658: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828F165C: 48500D8D  bl 0x82df23e8
	ctx.lr = 0x828F1660;
	sub_82DF23E8(ctx, base);
	// 828F1660: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F1664: 41820010  beq 0x828f1674
	if ctx.cr[0].eq {
	pc = 0x828F1674; continue 'dispatch;
	}
	// 828F1668: 4BFFE371  bl 0x828ef9d8
	ctx.lr = 0x828F166C;
	sub_828EF9D8(ctx, base);
	// 828F166C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F1670: 48000008  b 0x828f1678
	pc = 0x828F1678; continue 'dispatch;
	// 828F1674: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F1678: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F167C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828F1680: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F1684: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F1688: 4BFFF171  bl 0x828f07f8
	ctx.lr = 0x828F168C;
	sub_828F07F8(ctx, base);
	// 828F168C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F1690: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F1694: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F1698: 4B9CE969  bl 0x822c0000
	ctx.lr = 0x828F169C;
	sub_822C0000(ctx, base);
	// 828F169C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F16A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F16A4: 488B6B18  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F16A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F16A8 size=112
    let mut pc: u32 = 0x828F16A8;
    'dispatch: loop {
        match pc {
            0x828F16A8 => {
    //   block [0x828F16A8..0x828F1718)
	// 828F16A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F16AC: 488B6AC1  bl 0x831a816c
	ctx.lr = 0x828F16B0;
	sub_831A8130(ctx, base);
	// 828F16B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F16B4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F16B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F16BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F16C0: 388B2A20  addi r4, r11, 0x2a20
	ctx.r[4].s64 = ctx.r[11].s64 + 10784;
	// 828F16C4: 38A001E7  li r5, 0x1e7
	ctx.r[5].s64 = 487;
	// 828F16C8: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828F16CC: 48500D1D  bl 0x82df23e8
	ctx.lr = 0x828F16D0;
	sub_82DF23E8(ctx, base);
	// 828F16D0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F16D4: 41820010  beq 0x828f16e4
	if ctx.cr[0].eq {
	pc = 0x828F16E4; continue 'dispatch;
	}
	// 828F16D8: 4BFFE3E9  bl 0x828efac0
	ctx.lr = 0x828F16DC;
	sub_828EFAC0(ctx, base);
	// 828F16DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F16E0: 48000008  b 0x828f16e8
	pc = 0x828F16E8; continue 'dispatch;
	// 828F16E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F16E8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F16EC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828F16F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F16F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F16F8: 4BFFF1C9  bl 0x828f08c0
	ctx.lr = 0x828F16FC;
	sub_828F08C0(ctx, base);
	// 828F16FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F1700: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F1704: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F1708: 4B9CE8F9  bl 0x822c0000
	ctx.lr = 0x828F170C;
	sub_822C0000(ctx, base);
	// 828F170C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F1710: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F1714: 488B6AA8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F1718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F1718 size=112
    let mut pc: u32 = 0x828F1718;
    'dispatch: loop {
        match pc {
            0x828F1718 => {
    //   block [0x828F1718..0x828F1788)
	// 828F1718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F171C: 488B6A51  bl 0x831a816c
	ctx.lr = 0x828F1720;
	sub_831A8130(ctx, base);
	// 828F1720: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F1724: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F1728: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F172C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F1730: 388B2A20  addi r4, r11, 0x2a20
	ctx.r[4].s64 = ctx.r[11].s64 + 10784;
	// 828F1734: 38A00226  li r5, 0x226
	ctx.r[5].s64 = 550;
	// 828F1738: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828F173C: 48500CAD  bl 0x82df23e8
	ctx.lr = 0x828F1740;
	sub_82DF23E8(ctx, base);
	// 828F1740: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F1744: 41820010  beq 0x828f1754
	if ctx.cr[0].eq {
	pc = 0x828F1754; continue 'dispatch;
	}
	// 828F1748: 4BFFE4E1  bl 0x828efc28
	ctx.lr = 0x828F174C;
	sub_828EFC28(ctx, base);
	// 828F174C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F1750: 48000008  b 0x828f1758
	pc = 0x828F1758; continue 'dispatch;
	// 828F1754: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F1758: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F175C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828F1760: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F1764: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F1768: 4BFFF221  bl 0x828f0988
	ctx.lr = 0x828F176C;
	sub_828F0988(ctx, base);
	// 828F176C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F1770: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F1774: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F1778: 4B9CE889  bl 0x822c0000
	ctx.lr = 0x828F177C;
	sub_822C0000(ctx, base);
	// 828F177C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F1780: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F1784: 488B6A38  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F1788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F1788 size=112
    let mut pc: u32 = 0x828F1788;
    'dispatch: loop {
        match pc {
            0x828F1788 => {
    //   block [0x828F1788..0x828F17F8)
	// 828F1788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F178C: 488B69E1  bl 0x831a816c
	ctx.lr = 0x828F1790;
	sub_831A8130(ctx, base);
	// 828F1790: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F1794: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F1798: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F179C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F17A0: 388B2A20  addi r4, r11, 0x2a20
	ctx.r[4].s64 = ctx.r[11].s64 + 10784;
	// 828F17A4: 38A00265  li r5, 0x265
	ctx.r[5].s64 = 613;
	// 828F17A8: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828F17AC: 48500C3D  bl 0x82df23e8
	ctx.lr = 0x828F17B0;
	sub_82DF23E8(ctx, base);
	// 828F17B0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F17B4: 41820010  beq 0x828f17c4
	if ctx.cr[0].eq {
	pc = 0x828F17C4; continue 'dispatch;
	}
	// 828F17B8: 4BFFE5D1  bl 0x828efd88
	ctx.lr = 0x828F17BC;
	sub_828EFD88(ctx, base);
	// 828F17BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F17C0: 48000008  b 0x828f17c8
	pc = 0x828F17C8; continue 'dispatch;
	// 828F17C4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F17C8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F17CC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828F17D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F17D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F17D8: 4BFFF279  bl 0x828f0a50
	ctx.lr = 0x828F17DC;
	sub_828F0A50(ctx, base);
	// 828F17DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F17E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F17E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F17E8: 4B9CE819  bl 0x822c0000
	ctx.lr = 0x828F17EC;
	sub_822C0000(ctx, base);
	// 828F17EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F17F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F17F4: 488B69C8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F17F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F17F8 size=112
    let mut pc: u32 = 0x828F17F8;
    'dispatch: loop {
        match pc {
            0x828F17F8 => {
    //   block [0x828F17F8..0x828F1868)
	// 828F17F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F17FC: 488B6971  bl 0x831a816c
	ctx.lr = 0x828F1800;
	sub_831A8130(ctx, base);
	// 828F1800: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F1804: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F1808: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F180C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F1810: 388B2A20  addi r4, r11, 0x2a20
	ctx.r[4].s64 = ctx.r[11].s64 + 10784;
	// 828F1814: 38A002A0  li r5, 0x2a0
	ctx.r[5].s64 = 672;
	// 828F1818: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828F181C: 48500BCD  bl 0x82df23e8
	ctx.lr = 0x828F1820;
	sub_82DF23E8(ctx, base);
	// 828F1820: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F1824: 41820010  beq 0x828f1834
	if ctx.cr[0].eq {
	pc = 0x828F1834; continue 'dispatch;
	}
	// 828F1828: 4BFFE6C1  bl 0x828efee8
	ctx.lr = 0x828F182C;
	sub_828EFEE8(ctx, base);
	// 828F182C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F1830: 48000008  b 0x828f1838
	pc = 0x828F1838; continue 'dispatch;
	// 828F1834: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F1838: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F183C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828F1840: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F1844: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F1848: 4BFFF2D1  bl 0x828f0b18
	ctx.lr = 0x828F184C;
	sub_828F0B18(ctx, base);
	// 828F184C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F1850: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F1854: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F1858: 4B9CE7A9  bl 0x822c0000
	ctx.lr = 0x828F185C;
	sub_822C0000(ctx, base);
	// 828F185C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F1860: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F1864: 488B6958  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F1868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F1868 size=112
    let mut pc: u32 = 0x828F1868;
    'dispatch: loop {
        match pc {
            0x828F1868 => {
    //   block [0x828F1868..0x828F18D8)
	// 828F1868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F186C: 488B6901  bl 0x831a816c
	ctx.lr = 0x828F1870;
	sub_831A8130(ctx, base);
	// 828F1870: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F1874: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F1878: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F187C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F1880: 388B2A20  addi r4, r11, 0x2a20
	ctx.r[4].s64 = ctx.r[11].s64 + 10784;
	// 828F1884: 38A00326  li r5, 0x326
	ctx.r[5].s64 = 806;
	// 828F1888: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 828F188C: 48500B5D  bl 0x82df23e8
	ctx.lr = 0x828F1890;
	sub_82DF23E8(ctx, base);
	// 828F1890: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F1894: 41820010  beq 0x828f18a4
	if ctx.cr[0].eq {
	pc = 0x828F18A4; continue 'dispatch;
	}
	// 828F1898: 4BFFE781  bl 0x828f0018
	ctx.lr = 0x828F189C;
	sub_828F0018(ctx, base);
	// 828F189C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F18A0: 48000008  b 0x828f18a8
	pc = 0x828F18A8; continue 'dispatch;
	// 828F18A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F18A8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F18AC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828F18B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F18B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F18B8: 4BFFF329  bl 0x828f0be0
	ctx.lr = 0x828F18BC;
	sub_828F0BE0(ctx, base);
	// 828F18BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F18C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F18C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F18C8: 4B9CE739  bl 0x822c0000
	ctx.lr = 0x828F18CC;
	sub_822C0000(ctx, base);
	// 828F18CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F18D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F18D4: 488B68E8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F18D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F18D8 size=292
    let mut pc: u32 = 0x828F18D8;
    'dispatch: loop {
        match pc {
            0x828F18D8 => {
    //   block [0x828F18D8..0x828F19FC)
	// 828F18D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F18DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F18E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F18E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F18E8: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F1A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F1A00 size=112
    let mut pc: u32 = 0x828F1A00;
    'dispatch: loop {
        match pc {
            0x828F1A00 => {
    //   block [0x828F1A00..0x828F1A70)
	// 828F1A00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F1A04: 488B6769  bl 0x831a816c
	ctx.lr = 0x828F1A08;
	sub_831A8130(ctx, base);
	// 828F1A08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F1A0C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F1A10: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F1A14: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F1A18: 388B2A20  addi r4, r11, 0x2a20
	ctx.r[4].s64 = ctx.r[11].s64 + 10784;
	// 828F1A1C: 38A00372  li r5, 0x372
	ctx.r[5].s64 = 882;
	// 828F1A20: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828F1A24: 485009C5  bl 0x82df23e8
	ctx.lr = 0x828F1A28;
	sub_82DF23E8(ctx, base);
	// 828F1A28: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F1A2C: 41820010  beq 0x828f1a3c
	if ctx.cr[0].eq {
	pc = 0x828F1A3C; continue 'dispatch;
	}
	// 828F1A30: 4BFFEA69  bl 0x828f0498
	ctx.lr = 0x828F1A34;
	sub_828F0498(ctx, base);
	// 828F1A34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F1A38: 48000008  b 0x828f1a40
	pc = 0x828F1A40; continue 'dispatch;
	// 828F1A3C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F1A40: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F1A44: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828F1A48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F1A4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F1A50: 4BFFF259  bl 0x828f0ca8
	ctx.lr = 0x828F1A54;
	sub_828F0CA8(ctx, base);
	// 828F1A54: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F1A58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F1A5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F1A60: 4B9CE5A1  bl 0x822c0000
	ctx.lr = 0x828F1A64;
	sub_822C0000(ctx, base);
	// 828F1A64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F1A68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F1A6C: 488B6750  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F1A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F1A70 size=368
    let mut pc: u32 = 0x828F1A70;
    'dispatch: loop {
        match pc {
            0x828F1A70 => {
    //   block [0x828F1A70..0x828F1BE0)
	// 828F1A70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F1A74: 488B66F5  bl 0x831a8168
	ctx.lr = 0x828F1A78;
	sub_831A8130(ctx, base);
	// 828F1A78: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F1A7C: 48862B85  bl 0x83154600
	ctx.lr = 0x828F1A80;
	sub_83154600(ctx, base);
	// 828F1A80: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F1A84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F1A88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F1A8C: 808BA024  lwz r4, -0x5fdc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24540 as u32) ) } as u64;
	// 828F1A90: 48501F79  bl 0x82df3a08
	ctx.lr = 0x828F1A94;
	sub_82DF3A08(ctx, base);
	// 828F1A94: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1A98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1A9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F1AA0: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F1AA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F1AA8: 4E800421  bctrl
	ctx.lr = 0x828F1AAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F1AAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F1AB0: 48501979  bl 0x82df3428
	ctx.lr = 0x828F1AB4;
	sub_82DF3428(ctx, base);
	// 828F1AB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1AB8: 48024CB1  bl 0x82916768
	ctx.lr = 0x828F1ABC;
	sub_82916768(ctx, base);
	// 828F1ABC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1AC0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F1AC4: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828F1AC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F1ACC: 4E800421  bctrl
	ctx.lr = 0x828F1AD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F1AD0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828F1AD4: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828F1AD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1ADC: 48025545  bl 0x82917020
	ctx.lr = 0x828F1AE0;
	sub_82917020(ctx, base);
	// 828F1AE0: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 828F1AE4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F1AE8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828F1AEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F1AF0: 4BF8ED81  bl 0x82880870
	ctx.lr = 0x828F1AF4;
	sub_82880870(ctx, base);
	// 828F1AF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1AF8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828F1AFC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1B00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1B04: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828F1B08: 419A0024  beq cr6, 0x828f1b2c
	if ctx.cr[6].eq {
	pc = 0x828F1B2C; continue 'dispatch;
	}
	// 828F1B0C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828F1B10: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828F1B14: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F1B18: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828F1B1C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828F1B20: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F1B24: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F1B28: 4082FFE8  bne 0x828f1b10
	if !ctx.cr[0].eq {
	pc = 0x828F1B10; continue 'dispatch;
	}
	// 828F1B2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1B30: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 828F1B34: 48024C35  bl 0x82916768
	ctx.lr = 0x828F1B38;
	sub_82916768(ctx, base);
	// 828F1B38: 38630028  addi r3, r3, 0x28
	ctx.r[3].s64 = ctx.r[3].s64 + 40;
	// 828F1B3C: 4871747D  bl 0x83008fb8
	ctx.lr = 0x828F1B40;
	sub_83008FB8(ctx, base);
	// 828F1B40: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F1B44: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F1B48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1B4C: 3B8B2A20  addi r28, r11, 0x2a20
	ctx.r[28].s64 = ctx.r[11].s64 + 10784;
	// 828F1B50: 48024C19  bl 0x82916768
	ctx.lr = 0x828F1B54;
	sub_82916768(ctx, base);
	// 828F1B54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F1B58: 38630028  addi r3, r3, 0x28
	ctx.r[3].s64 = ctx.r[3].s64 + 40;
	// 828F1B5C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828F1B60: 38A00146  li r5, 0x146
	ctx.r[5].s64 = 326;
	// 828F1B64: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828F1B68: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828F1B6C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F1B70: 48566ED1  bl 0x82e58a40
	ctx.lr = 0x828F1B74;
	sub_82E58A40(ctx, base);
	// 828F1B74: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828F1B78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F1B7C: 419A0008  beq cr6, 0x828f1b84
	if ctx.cr[6].eq {
	pc = 0x828F1B84; continue 'dispatch;
	}
	// 828F1B80: 4B9CED11  bl 0x822c0890
	ctx.lr = 0x828F1B84;
	sub_822C0890(ctx, base);
	// 828F1B84: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F1B88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F1B8C: 419A0008  beq cr6, 0x828f1b94
	if ctx.cr[6].eq {
	pc = 0x828F1B94; continue 'dispatch;
	}
	// 828F1B90: 4B9CED01  bl 0x822c0890
	ctx.lr = 0x828F1B94;
	sub_822C0890(ctx, base);
	// 828F1B94: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828F1B98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F1B9C: 388B7C94  addi r4, r11, 0x7c94
	ctx.r[4].s64 = ctx.r[11].s64 + 31892;
	// 828F1BA0: 48501E69  bl 0x82df3a08
	ctx.lr = 0x828F1BA4;
	sub_82DF3A08(ctx, base);
	// 828F1BA4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1BA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F1BAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1BB0: 816B0098  lwz r11, 0x98(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) } as u64;
	// 828F1BB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F1BB8: 4E800421  bctrl
	ctx.lr = 0x828F1BBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F1BBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F1BC0: 48501869  bl 0x82df3428
	ctx.lr = 0x828F1BC4;
	sub_82DF3428(ctx, base);
	// 828F1BC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1BC8: 4BEFBC51  bl 0x827ed818
	ctx.lr = 0x828F1BCC;
	sub_827ED818(ctx, base);
	// 828F1BCC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F1BD0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828F1BD4: 4BFF4DB5  bl 0x828e6988
	ctx.lr = 0x828F1BD8;
	sub_828E6988(ctx, base);
	// 828F1BD8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828F1BDC: 488B65DC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F1BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F1BE0 size=268
    let mut pc: u32 = 0x828F1BE0;
    'dispatch: loop {
        match pc {
            0x828F1BE0 => {
    //   block [0x828F1BE0..0x828F1CEC)
	// 828F1BE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F1BE4: 488B6585  bl 0x831a8168
	ctx.lr = 0x828F1BE8;
	sub_831A8130(ctx, base);
	// 828F1BE8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F1BEC: 48862A15  bl 0x83154600
	ctx.lr = 0x828F1BF0;
	sub_83154600(ctx, base);
	// 828F1BF0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828F1BF4: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828F1BF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F1BFC: 48025425  bl 0x82917020
	ctx.lr = 0x828F1C00;
	sub_82917020(ctx, base);
	// 828F1C00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1C04: 48024B65  bl 0x82916768
	ctx.lr = 0x828F1C08;
	sub_82916768(ctx, base);
	// 828F1C08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1C0C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F1C10: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828F1C14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F1C18: 4E800421  bctrl
	ctx.lr = 0x828F1C1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F1C1C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 828F1C20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F1C24: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828F1C28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F1C2C: 4BF8EC45  bl 0x82880870
	ctx.lr = 0x828F1C30;
	sub_82880870(ctx, base);
	// 828F1C30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1C34: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828F1C38: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1C3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1C40: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828F1C44: 419A0024  beq cr6, 0x828f1c68
	if ctx.cr[6].eq {
	pc = 0x828F1C68; continue 'dispatch;
	}
	// 828F1C48: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828F1C4C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828F1C50: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F1C54: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828F1C58: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828F1C5C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F1C60: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F1C64: 4082FFE8  bne 0x828f1c4c
	if !ctx.cr[0].eq {
	pc = 0x828F1C4C; continue 'dispatch;
	}
	// 828F1C68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1C6C: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 828F1C70: 48024AF9  bl 0x82916768
	ctx.lr = 0x828F1C74;
	sub_82916768(ctx, base);
	// 828F1C74: 38630028  addi r3, r3, 0x28
	ctx.r[3].s64 = ctx.r[3].s64 + 40;
	// 828F1C78: 48717341  bl 0x83008fb8
	ctx.lr = 0x828F1C7C;
	sub_83008FB8(ctx, base);
	// 828F1C7C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F1C80: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F1C84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1C88: 3B8B2A20  addi r28, r11, 0x2a20
	ctx.r[28].s64 = ctx.r[11].s64 + 10784;
	// 828F1C8C: 48024ADD  bl 0x82916768
	ctx.lr = 0x828F1C90;
	sub_82916768(ctx, base);
	// 828F1C90: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F1C94: 38630028  addi r3, r3, 0x28
	ctx.r[3].s64 = ctx.r[3].s64 + 40;
	// 828F1C98: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828F1C9C: 38A00167  li r5, 0x167
	ctx.r[5].s64 = 359;
	// 828F1CA0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828F1CA4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828F1CA8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F1CAC: 48566D95  bl 0x82e58a40
	ctx.lr = 0x828F1CB0;
	sub_82E58A40(ctx, base);
	// 828F1CB0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828F1CB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F1CB8: 419A0008  beq cr6, 0x828f1cc0
	if ctx.cr[6].eq {
	pc = 0x828F1CC0; continue 'dispatch;
	}
	// 828F1CBC: 4B9CEBD5  bl 0x822c0890
	ctx.lr = 0x828F1CC0;
	sub_822C0890(ctx, base);
	// 828F1CC0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F1CC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F1CC8: 419A0008  beq cr6, 0x828f1cd0
	if ctx.cr[6].eq {
	pc = 0x828F1CD0; continue 'dispatch;
	}
	// 828F1CCC: 4B9CEBC5  bl 0x822c0890
	ctx.lr = 0x828F1CD0;
	sub_822C0890(ctx, base);
	// 828F1CD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1CD4: 4BEFBB45  bl 0x827ed818
	ctx.lr = 0x828F1CD8;
	sub_827ED818(ctx, base);
	// 828F1CD8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F1CDC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828F1CE0: 4BFF4CA9  bl 0x828e6988
	ctx.lr = 0x828F1CE4;
	sub_828E6988(ctx, base);
	// 828F1CE4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828F1CE8: 488B64D0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F1CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F1CF0 size=196
    let mut pc: u32 = 0x828F1CF0;
    'dispatch: loop {
        match pc {
            0x828F1CF0 => {
    //   block [0x828F1CF0..0x828F1DB4)
	// 828F1CF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F1CF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F1CF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F1CFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F1D00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F1D04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F1D08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F1D0C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F1D10: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F1D14: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F1D18: 4B9CEC21  bl 0x822c0938
	ctx.lr = 0x828F1D1C;
	sub_822C0938(ctx, base);
	// 828F1D1C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F1D20: 41820028  beq 0x828f1d48
	if ctx.cr[0].eq {
	pc = 0x828F1D48; continue 'dispatch;
	}
	// 828F1D24: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F1D28: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F1D2C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F1D30: 392B2AB8  addi r9, r11, 0x2ab8
	ctx.r[9].s64 = ctx.r[11].s64 + 10936;
	// 828F1D34: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F1D38: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F1D3C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F1D40: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F1D44: 48000008  b 0x828f1d4c
	pc = 0x828F1D4C; continue 'dispatch;
	// 828F1D48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F1D4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F1D50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1D54: 409A0044  bne cr6, 0x828f1d98
	if !ctx.cr[6].eq {
	pc = 0x828F1D98; continue 'dispatch;
	}
	// 828F1D58: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F1D5C: 419A001C  beq cr6, 0x828f1d78
	if ctx.cr[6].eq {
	pc = 0x828F1D78; continue 'dispatch;
	}
	// 828F1D60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1D64: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F1D68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1D6C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F1D70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F1D74: 4E800421  bctrl
	ctx.lr = 0x828F1D78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F1D78: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F1D7C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F1D80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F1D84: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F1D88: 816BA798  lwz r11, -0x5868(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22632 as u32) ) } as u64;
	// 828F1D8C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F1D90: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F1D94: 4B9CE26D  bl 0x822c0000
	ctx.lr = 0x828F1D98;
	sub_822C0000(ctx, base);
	// 828F1D98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F1D9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F1DA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F1DA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F1DA8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F1DAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F1DB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F1DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F1DB8 size=96
    let mut pc: u32 = 0x828F1DB8;
    'dispatch: loop {
        match pc {
            0x828F1DB8 => {
    //   block [0x828F1DB8..0x828F1E18)
	// 828F1DB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F1DBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F1DC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F1DC4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F1DC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F1DCC: 4BFFD715  bl 0x828ef4e0
	ctx.lr = 0x828F1DD0;
	sub_828EF4E0(ctx, base);
	// 828F1DD0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F1DD4: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828F1DD8: 396B2ACC  addi r11, r11, 0x2acc
	ctx.r[11].s64 = ctx.r[11].s64 + 10956;
	// 828F1DDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F1DE0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F1DE4: 808A0AF4  lwz r4, 0xaf4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2804 as u32) ) } as u64;
	// 828F1DE8: 48501C21  bl 0x82df3a08
	ctx.lr = 0x828F1DEC;
	sub_82DF3A08(ctx, base);
	// 828F1DEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1DF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F1DF4: 485678F5  bl 0x82e596e8
	ctx.lr = 0x828F1DF8;
	sub_82E596E8(ctx, base);
	// 828F1DF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F1DFC: 4850162D  bl 0x82df3428
	ctx.lr = 0x828F1E00;
	sub_82DF3428(ctx, base);
	// 828F1E00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1E04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F1E08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F1E0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F1E10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F1E14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F1E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F1E18 size=348
    let mut pc: u32 = 0x828F1E18;
    'dispatch: loop {
        match pc {
            0x828F1E18 => {
    //   block [0x828F1E18..0x828F1F74)
	// 828F1E18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F1E1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F1E20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F1E24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F1E28: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828F1E2C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F1E30: 488627D1  bl 0x83154600
	ctx.lr = 0x828F1E34;
	sub_83154600(ctx, base);
	// 828F1E34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F1E38: 4BEFB9E1  bl 0x827ed818
	ctx.lr = 0x828F1E3C;
	sub_827ED818(ctx, base);
	// 828F1E3C: 4BFF07E5  bl 0x828e2620
	ctx.lr = 0x828F1E40;
	sub_828E2620(ctx, base);
	// 828F1E40: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F1E44: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F1E48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F1E4C: 409A00B8  bne cr6, 0x828f1f04
	if !ctx.cr[6].eq {
	pc = 0x828F1F04; continue 'dispatch;
	}
	// 828F1E50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1E54: 48024915  bl 0x82916768
	ctx.lr = 0x828F1E58;
	sub_82916768(ctx, base);
	// 828F1E58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1E5C: 816B0158  lwz r11, 0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(344 as u32) ) } as u64;
	// 828F1E60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F1E64: 4E800421  bctrl
	ctx.lr = 0x828F1E68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F1E68: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F1E6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1E70: C1BE007C  lfs f13, 0x7c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F1E74: C01E0080  lfs f0, 0x80(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F1E78: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 828F1E7C: C1BE0078  lfs f13, 0x78(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F1E80: EFE0682A  fadds f31, f0, f13
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 828F1E84: 480248E5  bl 0x82916768
	ctx.lr = 0x828F1E88;
	sub_82916768(ctx, base);
	// 828F1E88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F1E8C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F1E90: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828F1E94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F1E98: 4E800421  bctrl
	ctx.lr = 0x828F1E9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F1E9C: C01E0078  lfs f0, 0x78(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F1EA0: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828F1EA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F1EA8: 40980028  bge cr6, 0x828f1ed0
	if !ctx.cr[6].lt {
	pc = 0x828F1ED0; continue 'dispatch;
	}
	// 828F1EAC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F1EB0: 808B0AFC  lwz r4, 0xafc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2812 as u32) ) } as u64;
	// 828F1EB4: 48501B55  bl 0x82df3a08
	ctx.lr = 0x828F1EB8;
	sub_82DF3A08(ctx, base);
	// 828F1EB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F1EBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1EC0: 4BEFD881  bl 0x827ef740
	ctx.lr = 0x828F1EC4;
	sub_827EF740(ctx, base);
	// 828F1EC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F1EC8: 48501561  bl 0x82df3428
	ctx.lr = 0x828F1ECC;
	sub_82DF3428(ctx, base);
	// 828F1ECC: 4800008C  b 0x828f1f58
	pc = 0x828F1F58; continue 'dispatch;
	// 828F1ED0: EC010028  fsubs f0, f1, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 828F1ED4: C1BE007C  lfs f13, 0x7c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F1ED8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828F1EDC: 40980010  bge cr6, 0x828f1eec
	if !ctx.cr[6].lt {
	pc = 0x828F1EEC; continue 'dispatch;
	}
	// 828F1EE0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F1EE4: 808B0AF8  lwz r4, 0xaf8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2808 as u32) ) } as u64;
	// 828F1EE8: 4BFFFFCC  b 0x828f1eb4
	pc = 0x828F1EB4; continue 'dispatch;
	// 828F1EEC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828F1EF0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F1EF4: C1BE0080  lfs f13, 0x80(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F1EF8: 808B0B18  lwz r4, 0xb18(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2840 as u32) ) } as u64;
	// 828F1EFC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828F1F00: 4BFFFFB4  b 0x828f1eb4
	pc = 0x828F1EB4; continue 'dispatch;
	// 828F1F04: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828F1F08: 409A0050  bne cr6, 0x828f1f58
	if !ctx.cr[6].eq {
	pc = 0x828F1F58; continue 'dispatch;
	}
	// 828F1F0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F1F10: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F1F14: 48024E85  bl 0x82916d98
	ctx.lr = 0x828F1F18;
	sub_82916D98(ctx, base);
	// 828F1F18: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F1F1C: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828F1F20: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F1F24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F1F28: 9149007C  stw r10, 0x7c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 828F1F2C: 808B0B00  lwz r4, 0xb00(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2816 as u32) ) } as u64;
	// 828F1F30: 48501AD9  bl 0x82df3a08
	ctx.lr = 0x828F1F34;
	sub_82DF3A08(ctx, base);
	// 828F1F34: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F1F38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F1F3C: 4BEFD805  bl 0x827ef740
	ctx.lr = 0x828F1F40;
	sub_827EF740(ctx, base);
	// 828F1F40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F1F44: 485014E5  bl 0x82df3428
	ctx.lr = 0x828F1F48;
	sub_82DF3428(ctx, base);
	// 828F1F48: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828F1F4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F1F50: 419A0008  beq cr6, 0x828f1f58
	if ctx.cr[6].eq {
	pc = 0x828F1F58; continue 'dispatch;
	}
	// 828F1F54: 4B9CE93D  bl 0x822c0890
	ctx.lr = 0x828F1F58;
	sub_822C0890(ctx, base);
	// 828F1F58: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F1F5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F1F60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F1F64: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828F1F68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F1F6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F1F70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F1F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F1F78 size=112
    let mut pc: u32 = 0x828F1F78;
    'dispatch: loop {
        match pc {
            0x828F1F78 => {
    //   block [0x828F1F78..0x828F1FE8)
	// 828F1F78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F1F7C: 488B61F1  bl 0x831a816c
	ctx.lr = 0x828F1F80;
	sub_831A8130(ctx, base);
	// 828F1F80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F1F84: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F1F88: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F1F8C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F1F90: 388B2AF8  addi r4, r11, 0x2af8
	ctx.r[4].s64 = ctx.r[11].s64 + 11000;
	// 828F1F94: 38A00072  li r5, 0x72
	ctx.r[5].s64 = 114;
	// 828F1F98: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828F1F9C: 4850044D  bl 0x82df23e8
	ctx.lr = 0x828F1FA0;
	sub_82DF23E8(ctx, base);
	// 828F1FA0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F1FA4: 41820010  beq 0x828f1fb4
	if ctx.cr[0].eq {
	pc = 0x828F1FB4; continue 'dispatch;
	}
	// 828F1FA8: 4BFFFE11  bl 0x828f1db8
	ctx.lr = 0x828F1FAC;
	sub_828F1DB8(ctx, base);
	// 828F1FAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F1FB0: 48000008  b 0x828f1fb8
	pc = 0x828F1FB8; continue 'dispatch;
	// 828F1FB4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F1FB8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F1FBC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828F1FC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F1FC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F1FC8: 4BFFFD29  bl 0x828f1cf0
	ctx.lr = 0x828F1FCC;
	sub_828F1CF0(ctx, base);
	// 828F1FCC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F1FD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F1FD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F1FD8: 4B9CE029  bl 0x822c0000
	ctx.lr = 0x828F1FDC;
	sub_822C0000(ctx, base);
	// 828F1FDC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F1FE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F1FE4: 488B61D8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F1FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F1FE8 size=96
    let mut pc: u32 = 0x828F1FE8;
    'dispatch: loop {
        match pc {
            0x828F1FE8 => {
    //   block [0x828F1FE8..0x828F2048)
	// 828F1FE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F1FEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F1FF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F1FF4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F1FF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F1FFC: 48862605  bl 0x83154600
	ctx.lr = 0x828F2000;
	sub_83154600(ctx, base);
	// 828F2000: 48024769  bl 0x82916768
	ctx.lr = 0x828F2004;
	sub_82916768(ctx, base);
	// 828F2004: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F2008: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 828F200C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F2010: 4801CD69  bl 0x8290ed78
	ctx.lr = 0x828F2014;
	sub_8290ED78(ctx, base);
	// 828F2014: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F2018: 488625E9  bl 0x83154600
	ctx.lr = 0x828F201C;
	sub_83154600(ctx, base);
	// 828F201C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828F2020: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 828F2024: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2028: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 828F202C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F2030: 4E800421  bctrl
	ctx.lr = 0x828F2034;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F2034: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F2038: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F203C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F2040: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F2044: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F2048 size=196
    let mut pc: u32 = 0x828F2048;
    'dispatch: loop {
        match pc {
            0x828F2048 => {
    //   block [0x828F2048..0x828F210C)
	// 828F2048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F204C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F2050: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F2054: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F2058: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F205C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F2060: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F2064: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F2068: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F206C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F2070: 4B9CE8C9  bl 0x822c0938
	ctx.lr = 0x828F2074;
	sub_822C0938(ctx, base);
	// 828F2074: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F2078: 41820028  beq 0x828f20a0
	if ctx.cr[0].eq {
	pc = 0x828F20A0; continue 'dispatch;
	}
	// 828F207C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F2080: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F2084: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F2088: 392B2B78  addi r9, r11, 0x2b78
	ctx.r[9].s64 = ctx.r[11].s64 + 11128;
	// 828F208C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F2090: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F2094: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F2098: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F209C: 48000008  b 0x828f20a4
	pc = 0x828F20A4; continue 'dispatch;
	// 828F20A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F20A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F20A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F20AC: 409A0044  bne cr6, 0x828f20f0
	if !ctx.cr[6].eq {
	pc = 0x828F20F0; continue 'dispatch;
	}
	// 828F20B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F20B4: 419A001C  beq cr6, 0x828f20d0
	if ctx.cr[6].eq {
	pc = 0x828F20D0; continue 'dispatch;
	}
	// 828F20B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F20BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F20C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F20C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F20C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F20CC: 4E800421  bctrl
	ctx.lr = 0x828F20D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F20D0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F20D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F20D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F20DC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F20E0: 816BA824  lwz r11, -0x57dc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22492 as u32) ) } as u64;
	// 828F20E4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F20E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F20EC: 4B9CDF15  bl 0x822c0000
	ctx.lr = 0x828F20F0;
	sub_822C0000(ctx, base);
	// 828F20F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F20F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F20F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F20FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F2100: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F2104: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F2108: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F2110 size=108
    let mut pc: u32 = 0x828F2110;
    'dispatch: loop {
        match pc {
            0x828F2110 => {
    //   block [0x828F2110..0x828F217C)
	// 828F2110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F2114: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F2118: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F211C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F2120: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F2124: 4BFFD375  bl 0x828ef498
	ctx.lr = 0x828F2128;
	sub_828EF498(ctx, base);
	// 828F2128: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828F212C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F2130: 394A2B8C  addi r10, r10, 0x2b8c
	ctx.r[10].s64 = ctx.r[10].s64 + 11148;
	// 828F2134: 3D20832D  lis r9, -0x7cd3
	ctx.r[9].s64 = -2094202880;
	// 828F2138: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828F213C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F2140: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828F2144: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828F2148: 80890B24  lwz r4, 0xb24(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828F214C: 485018BD  bl 0x82df3a08
	ctx.lr = 0x828F2150;
	sub_82DF3A08(ctx, base);
	// 828F2150: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F2154: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F2158: 48567591  bl 0x82e596e8
	ctx.lr = 0x828F215C;
	sub_82E596E8(ctx, base);
	// 828F215C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F2160: 485012C9  bl 0x82df3428
	ctx.lr = 0x828F2164;
	sub_82DF3428(ctx, base);
	// 828F2164: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F2168: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F216C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F2170: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F2174: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F2178: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F2180 size=872
    let mut pc: u32 = 0x828F2180;
    'dispatch: loop {
        match pc {
            0x828F2180 => {
    //   block [0x828F2180..0x828F24E8)
	// 828F2180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F2184: 488B5FD9  bl 0x831a815c
	ctx.lr = 0x828F2188;
	sub_831A8130(ctx, base);
	// 828F2188: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F218C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828F2190: 48862471  bl 0x83154600
	ctx.lr = 0x828F2194;
	sub_83154600(ctx, base);
	// 828F2194: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F2198: 480245D1  bl 0x82916768
	ctx.lr = 0x828F219C;
	sub_82916768(ctx, base);
	// 828F219C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F21A0: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828F21A4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F21A8: 4801CBD1  bl 0x8290ed78
	ctx.lr = 0x828F21AC;
	sub_8290ED78(ctx, base);
	// 828F21AC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F21B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F21B4: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828F21B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F21BC: 4E800421  bctrl
	ctx.lr = 0x828F21C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F21C0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F21C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F21C8: 808BA054  lwz r4, -0x5fac(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24492 as u32) ) } as u64;
	// 828F21CC: 4850183D  bl 0x82df3a08
	ctx.lr = 0x828F21D0;
	sub_82DF3A08(ctx, base);
	// 828F21D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F21D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F21D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F21DC: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F21E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F21E4: 4E800421  bctrl
	ctx.lr = 0x828F21E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F21E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F21EC: 4850123D  bl 0x82df3428
	ctx.lr = 0x828F21F0;
	sub_82DF3428(ctx, base);
	// 828F21F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F21F4: 4BEFB625  bl 0x827ed818
	ctx.lr = 0x828F21F8;
	sub_827ED818(ctx, base);
	// 828F21F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F21FC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2200: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F2204: 816A0080  lwz r11, 0x80(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 828F2208: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F220C: 4E800421  bctrl
	ctx.lr = 0x828F2210;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F2210: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828F2214: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F2218: C00B7BC4  lfs f0, 0x7bc4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F221C: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 828F2220: D01A0060  stfs f0, 0x60(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828F2224: 48024545  bl 0x82916768
	ctx.lr = 0x828F2228;
	sub_82916768(ctx, base);
	// 828F2228: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F222C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F2230: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828F2234: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F2238: 4E800421  bctrl
	ctx.lr = 0x828F223C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F223C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F2240: 48024529  bl 0x82916768
	ctx.lr = 0x828F2244;
	sub_82916768(ctx, base);
	// 828F2244: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2248: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F224C: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828F2250: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F2254: 4E800421  bctrl
	ctx.lr = 0x828F2258;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F2258: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 828F225C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F2260: 933A0064  stw r25, 0x64(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 828F2264: 933A0068  stw r25, 0x68(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(104 as u32), ctx.r[25].u32 ) };
	// 828F2268: 48024501  bl 0x82916768
	ctx.lr = 0x828F226C;
	sub_82916768(ctx, base);
	// 828F226C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2270: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 828F2274: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F2278: 4E800421  bctrl
	ctx.lr = 0x828F227C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F227C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F2280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F2284: 4BEFB595  bl 0x827ed818
	ctx.lr = 0x828F2288;
	sub_827ED818(ctx, base);
	// 828F2288: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F228C: 816B01B0  lwz r11, 0x1b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(432 as u32) ) } as u64;
	// 828F2290: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F2294: 4E800421  bctrl
	ctx.lr = 0x828F2298;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F2298: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828F229C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F22A0: 4804DAF1  bl 0x8293fd90
	ctx.lr = 0x828F22A4;
	sub_8293FD90(ctx, base);
	// 828F22A4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F22A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F22AC: 3B8B2BB0  addi r28, r11, 0x2bb0
	ctx.r[28].s64 = ctx.r[11].s64 + 11184;
	// 828F22B0: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828F22B4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828F22B8: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 828F22BC: 4B9CE11D  bl 0x822c03d8
	ctx.lr = 0x828F22C0;
	sub_822C03D8(ctx, base);
	// 828F22C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F22C4: 41820018  beq 0x828f22dc
	if ctx.cr[0].eq {
	pc = 0x828F22DC; continue 'dispatch;
	}
	// 828F22C8: 38BB013C  addi r5, r27, 0x13c
	ctx.r[5].s64 = ctx.r[27].s64 + 316;
	// 828F22CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F22D0: 4804ED31  bl 0x82941000
	ctx.lr = 0x828F22D4;
	sub_82941000(ctx, base);
	// 828F22D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F22D8: 48000008  b 0x828f22e0
	pc = 0x828F22E0; continue 'dispatch;
	// 828F22DC: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 828F22E0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828F22E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F22E8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F22EC: 4BF7FA3D  bl 0x82871d28
	ctx.lr = 0x828F22F0;
	sub_82871D28(ctx, base);
	// 828F22F0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828F22F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F22F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F22FC: 4B9CDD05  bl 0x822c0000
	ctx.lr = 0x828F2300;
	sub_822C0000(ctx, base);
	// 828F2300: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F2304: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F2308: 4804DB99  bl 0x8293fea0
	ctx.lr = 0x828F230C;
	sub_8293FEA0(ctx, base);
	// 828F230C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828F2310: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F2314: 38A00069  li r5, 0x69
	ctx.r[5].s64 = 105;
	// 828F2318: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F231C: 4B9CE0BD  bl 0x822c03d8
	ctx.lr = 0x828F2320;
	sub_822C03D8(ctx, base);
	// 828F2320: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F2324: 41820018  beq 0x828f233c
	if ctx.cr[0].eq {
	pc = 0x828F233C; continue 'dispatch;
	}
	// 828F2328: 38BB0148  addi r5, r27, 0x148
	ctx.r[5].s64 = ctx.r[27].s64 + 328;
	// 828F232C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F2330: 48050C41  bl 0x82942f70
	ctx.lr = 0x828F2334;
	sub_82942F70(ctx, base);
	// 828F2334: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F2338: 48000008  b 0x828f2340
	pc = 0x828F2340; continue 'dispatch;
	// 828F233C: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 828F2340: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828F2344: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F2348: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F234C: 4BF7FAA5  bl 0x82871df0
	ctx.lr = 0x828F2350;
	sub_82871DF0(ctx, base);
	// 828F2350: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828F2354: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F2358: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F235C: 4B9CDCA5  bl 0x822c0000
	ctx.lr = 0x828F2360;
	sub_822C0000(ctx, base);
	// 828F2360: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F2364: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F2368: 4804DB39  bl 0x8293fea0
	ctx.lr = 0x828F236C;
	sub_8293FEA0(ctx, base);
	// 828F236C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828F2370: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F2374: 38A0006B  li r5, 0x6b
	ctx.r[5].s64 = 107;
	// 828F2378: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828F237C: 4B9CE05D  bl 0x822c03d8
	ctx.lr = 0x828F2380;
	sub_822C03D8(ctx, base);
	// 828F2380: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F2384: 41820018  beq 0x828f239c
	if ctx.cr[0].eq {
	pc = 0x828F239C; continue 'dispatch;
	}
	// 828F2388: 38BB0150  addi r5, r27, 0x150
	ctx.r[5].s64 = ctx.r[27].s64 + 336;
	// 828F238C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F2390: 48050FF9  bl 0x82943388
	ctx.lr = 0x828F2394;
	sub_82943388(ctx, base);
	// 828F2394: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F2398: 48000008  b 0x828f23a0
	pc = 0x828F23A0; continue 'dispatch;
	// 828F239C: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 828F23A0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828F23A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F23A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F23AC: 4BF7FB0D  bl 0x82871eb8
	ctx.lr = 0x828F23B0;
	sub_82871EB8(ctx, base);
	// 828F23B0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828F23B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F23B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F23BC: 4B9CDC45  bl 0x822c0000
	ctx.lr = 0x828F23C0;
	sub_822C0000(ctx, base);
	// 828F23C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F23C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F23C8: 4804DAD9  bl 0x8293fea0
	ctx.lr = 0x828F23CC;
	sub_8293FEA0(ctx, base);
	// 828F23CC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828F23D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F23D4: 38A0006D  li r5, 0x6d
	ctx.r[5].s64 = 109;
	// 828F23D8: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 828F23DC: 4B9CDFFD  bl 0x822c03d8
	ctx.lr = 0x828F23E0;
	sub_822C03D8(ctx, base);
	// 828F23E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F23E4: 41820018  beq 0x828f23fc
	if ctx.cr[0].eq {
	pc = 0x828F23FC; continue 'dispatch;
	}
	// 828F23E8: 38BB0160  addi r5, r27, 0x160
	ctx.r[5].s64 = ctx.r[27].s64 + 352;
	// 828F23EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F23F0: 48050531  bl 0x82942920
	ctx.lr = 0x828F23F4;
	sub_82942920(ctx, base);
	// 828F23F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F23F8: 48000008  b 0x828f2400
	pc = 0x828F2400; continue 'dispatch;
	// 828F23FC: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 828F2400: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828F2404: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F2408: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F240C: 4BF7FB75  bl 0x82871f80
	ctx.lr = 0x828F2410;
	sub_82871F80(ctx, base);
	// 828F2410: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828F2414: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F2418: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F241C: 4B9CDBE5  bl 0x822c0000
	ctx.lr = 0x828F2420;
	sub_822C0000(ctx, base);
	// 828F2420: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F2424: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F2428: 4804DA79  bl 0x8293fea0
	ctx.lr = 0x828F242C;
	sub_8293FEA0(ctx, base);
	// 828F242C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828F2430: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F2434: 38A00070  li r5, 0x70
	ctx.r[5].s64 = 112;
	// 828F2438: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 828F243C: 4B9CDF9D  bl 0x822c03d8
	ctx.lr = 0x828F2440;
	sub_822C03D8(ctx, base);
	// 828F2440: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F2444: 41820018  beq 0x828f245c
	if ctx.cr[0].eq {
	pc = 0x828F245C; continue 'dispatch;
	}
	// 828F2448: 38BB01A0  addi r5, r27, 0x1a0
	ctx.r[5].s64 = ctx.r[27].s64 + 416;
	// 828F244C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F2450: 4804EA49  bl 0x82940e98
	ctx.lr = 0x828F2454;
	sub_82940E98(ctx, base);
	// 828F2454: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F2458: 48000008  b 0x828f2460
	pc = 0x828F2460; continue 'dispatch;
	// 828F245C: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 828F2460: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828F2464: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F2468: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F246C: 4BFE5ACD  bl 0x828d7f38
	ctx.lr = 0x828F2470;
	sub_828D7F38(ctx, base);
	// 828F2470: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828F2474: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F2478: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F247C: 4B9CDB85  bl 0x822c0000
	ctx.lr = 0x828F2480;
	sub_822C0000(ctx, base);
	// 828F2480: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F2484: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F2488: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828F248C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828F2490: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828F2494: 419A0024  beq cr6, 0x828f24b8
	if ctx.cr[6].eq {
	pc = 0x828F24B8; continue 'dispatch;
	}
	// 828F2498: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 828F249C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828F24A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F24A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828F24A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828F24AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F24B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F24B4: 4082FFE8  bne 0x828f249c
	if !ctx.cr[0].eq {
	pc = 0x828F249C; continue 'dispatch;
	}
	// 828F24B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F24BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F24C0: 4804D9E1  bl 0x8293fea0
	ctx.lr = 0x828F24C4;
	sub_8293FEA0(ctx, base);
	// 828F24C4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828F24C8: 419A000C  beq cr6, 0x828f24d4
	if ctx.cr[6].eq {
	pc = 0x828F24D4; continue 'dispatch;
	}
	// 828F24CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F24D0: 4B9CE3C1  bl 0x822c0890
	ctx.lr = 0x828F24D4;
	sub_822C0890(ctx, base);
	// 828F24D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F24D8: 48024629  bl 0x82916b00
	ctx.lr = 0x828F24DC;
	sub_82916B00(ctx, base);
	// 828F24DC: 987A006C  stb r3, 0x6c(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(108 as u32), ctx.r[3].u8 ) };
	// 828F24E0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828F24E4: 488B5CC8  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F24E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F24E8 size=112
    let mut pc: u32 = 0x828F24E8;
    'dispatch: loop {
        match pc {
            0x828F24E8 => {
    //   block [0x828F24E8..0x828F2558)
	// 828F24E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F24EC: 488B5C81  bl 0x831a816c
	ctx.lr = 0x828F24F0;
	sub_831A8130(ctx, base);
	// 828F24F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F24F4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F24F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F24FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F2500: 388B2BB0  addi r4, r11, 0x2bb0
	ctx.r[4].s64 = ctx.r[11].s64 + 11184;
	// 828F2504: 38A00121  li r5, 0x121
	ctx.r[5].s64 = 289;
	// 828F2508: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 828F250C: 484FFEDD  bl 0x82df23e8
	ctx.lr = 0x828F2510;
	sub_82DF23E8(ctx, base);
	// 828F2510: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F2514: 41820010  beq 0x828f2524
	if ctx.cr[0].eq {
	pc = 0x828F2524; continue 'dispatch;
	}
	// 828F2518: 4BFFFBF9  bl 0x828f2110
	ctx.lr = 0x828F251C;
	sub_828F2110(ctx, base);
	// 828F251C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F2520: 48000008  b 0x828f2528
	pc = 0x828F2528; continue 'dispatch;
	// 828F2524: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F2528: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F252C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828F2530: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F2534: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F2538: 4BFFFB11  bl 0x828f2048
	ctx.lr = 0x828F253C;
	sub_828F2048(ctx, base);
	// 828F253C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F2540: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F2544: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F2548: 4B9CDAB9  bl 0x822c0000
	ctx.lr = 0x828F254C;
	sub_822C0000(ctx, base);
	// 828F254C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F2550: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F2554: 488B5C68  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F2558 size=372
    let mut pc: u32 = 0x828F2558;
    'dispatch: loop {
        match pc {
            0x828F2558 => {
    //   block [0x828F2558..0x828F26CC)
	// 828F2558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F255C: 488B5C0D  bl 0x831a8168
	ctx.lr = 0x828F2560;
	sub_831A8130(ctx, base);
	// 828F2560: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F2564: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F2568: 48862099  bl 0x83154600
	ctx.lr = 0x828F256C;
	sub_83154600(ctx, base);
	// 828F256C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F2570: 480241F9  bl 0x82916768
	ctx.lr = 0x828F2574;
	sub_82916768(ctx, base);
	// 828F2574: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2578: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 828F257C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F2580: 4E800421  bctrl
	ctx.lr = 0x828F2584;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F2584: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F2588: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F258C: 485671ED  bl 0x82e59778
	ctx.lr = 0x828F2590;
	sub_82E59778(ctx, base);
	// 828F2590: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F2594: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F2598: 4804D699  bl 0x8293fc30
	ctx.lr = 0x828F259C;
	sub_8293FC30(ctx, base);
	// 828F259C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F25A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F25A4: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F25A8: 4804CA19  bl 0x8293efc0
	ctx.lr = 0x828F25AC;
	sub_8293EFC0(ctx, base);
	// 828F25AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F25B0: 817D003C  lwz r11, 0x3c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 828F25B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F25B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F25BC: 4E800421  bctrl
	ctx.lr = 0x828F25C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F25C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F25C4: 4BEFB255  bl 0x827ed818
	ctx.lr = 0x828F25C8;
	sub_827ED818(ctx, base);
	// 828F25C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F25CC: 816B01B0  lwz r11, 0x1b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(432 as u32) ) } as u64;
	// 828F25D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F25D4: 4E800421  bctrl
	ctx.lr = 0x828F25D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F25D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F25DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F25E0: 48024189  bl 0x82916768
	ctx.lr = 0x828F25E4;
	sub_82916768(ctx, base);
	// 828F25E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F25E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F25EC: 4801706D  bl 0x82909658
	ctx.lr = 0x828F25F0;
	sub_82909658(ctx, base);
	// 828F25F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F25F4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828F25F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F25FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2600: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F2604: 4E800421  bctrl
	ctx.lr = 0x828F2608;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F2608: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828F260C: 13E0E0C7  vcmpequd (lvx128) v31, v0, v28
	tmp.u32 = ctx.r[28].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828F2610: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F26D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F26D0 size=476
    let mut pc: u32 = 0x828F26D0;
    'dispatch: loop {
        match pc {
            0x828F26D0 => {
    //   block [0x828F26D0..0x828F28AC)
	// 828F26D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F26D4: 488B5A95  bl 0x831a8168
	ctx.lr = 0x828F26D8;
	sub_831A8130(ctx, base);
	// 828F26D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F26DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F26E0: 48861F21  bl 0x83154600
	ctx.lr = 0x828F26E4;
	sub_83154600(ctx, base);
	// 828F26E4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F26E8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F26EC: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828F26F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F26F4: 4E800421  bctrl
	ctx.lr = 0x828F26F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F26F8: 817E0068  lwz r11, 0x68(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 828F26FC: 3BFE0068  addi r31, r30, 0x68
	ctx.r[31].s64 = ctx.r[30].s64 + 104;
	// 828F2700: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F2704: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828F2708: 41820010  beq 0x828f2718
	if ctx.cr[0].eq {
	pc = 0x828F2718; continue 'dispatch;
	}
	// 828F270C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F2710: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828F2714: 48000138  b 0x828f284c
	pc = 0x828F284C; continue 'dispatch;
	// 828F2718: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F271C: 556AD7FF  rlwinm. r10, r11, 0x1a, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828F2720: 4182001C  beq 0x828f273c
	if ctx.cr[0].eq {
	pc = 0x828F273C; continue 'dispatch;
	}
	// 828F2724: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828F2728: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828F272C: 556B06B0  rlwinm r11, r11, 0, 0x1a, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828F2730: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828F2734: 808AA05C  lwz r4, -0x5fa4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24484 as u32) ) } as u64;
	// 828F2738: 480000E0  b 0x828f2818
	pc = 0x828F2818; continue 'dispatch;
	// 828F273C: 556ADFFF  rlwinm. r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828F2740: 4182001C  beq 0x828f275c
	if ctx.cr[0].eq {
	pc = 0x828F275C; continue 'dispatch;
	}
	// 828F2744: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F2748: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828F274C: 556B06F2  rlwinm r11, r11, 0, 0x1b, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828F2750: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828F2754: 808AA064  lwz r4, -0x5f9c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24476 as u32) ) } as u64;
	// 828F2758: 480000C0  b 0x828f2818
	pc = 0x828F2818; continue 'dispatch;
	// 828F275C: 556AF7FF  rlwinm. r10, r11, 0x1e, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828F2760: 4182001C  beq 0x828f277c
	if ctx.cr[0].eq {
	pc = 0x828F277C; continue 'dispatch;
	}
	// 828F2764: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F2768: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828F276C: 556B07B8  rlwinm r11, r11, 0, 0x1e, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828F2770: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828F2774: 808AA060  lwz r4, -0x5fa0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24480 as u32) ) } as u64;
	// 828F2778: 480000A0  b 0x828f2818
	pc = 0x828F2818; continue 'dispatch;
	// 828F277C: 556AFFFF  rlwinm. r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828F2780: 4182001C  beq 0x828f279c
	if ctx.cr[0].eq {
	pc = 0x828F279C; continue 'dispatch;
	}
	// 828F2784: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F2788: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828F278C: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828F2790: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828F2794: 808AA068  lwz r4, -0x5f98(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24472 as u32) ) } as u64;
	// 828F2798: 48000080  b 0x828f2818
	pc = 0x828F2818; continue 'dispatch;
	// 828F279C: 556AC7FF  rlwinm. r10, r11, 0x18, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828F27A0: 4182001C  beq 0x828f27bc
	if ctx.cr[0].eq {
	pc = 0x828F27BC; continue 'dispatch;
	}
	// 828F27A4: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F27A8: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828F27AC: 556B062C  rlwinm r11, r11, 0, 0x18, 0x16
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828F27B0: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828F27B4: 808AA06C  lwz r4, -0x5f94(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24468 as u32) ) } as u64;
	// 828F27B8: 48000060  b 0x828f2818
	pc = 0x828F2818; continue 'dispatch;
	// 828F27BC: 556AE7FF  rlwinm. r10, r11, 0x1c, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828F27C0: 4182001C  beq 0x828f27dc
	if ctx.cr[0].eq {
	pc = 0x828F27DC; continue 'dispatch;
	}
	// 828F27C4: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F27C8: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828F27CC: 556B0734  rlwinm r11, r11, 0, 0x1c, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828F27D0: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828F27D4: 808AA070  lwz r4, -0x5f90(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24464 as u32) ) } as u64;
	// 828F27D8: 48000040  b 0x828f2818
	pc = 0x828F2818; continue 'dispatch;
	// 828F27DC: 556ACFFF  rlwinm. r10, r11, 0x19, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828F27E0: 4182001C  beq 0x828f27fc
	if ctx.cr[0].eq {
	pc = 0x828F27FC; continue 'dispatch;
	}
	// 828F27E4: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F27E8: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828F27EC: 556B066E  rlwinm r11, r11, 0, 0x19, 0x17
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828F27F0: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828F27F4: 808AA074  lwz r4, -0x5f8c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24460 as u32) ) } as u64;
	// 828F27F8: 48000020  b 0x828f2818
	pc = 0x828F2818; continue 'dispatch;
	// 828F27FC: 556BEFFF  rlwinm. r11, r11, 0x1d, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F2800: 4182004C  beq 0x828f284c
	if ctx.cr[0].eq {
	pc = 0x828F284C; continue 'dispatch;
	}
	// 828F2804: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F2808: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828F280C: 556B0776  rlwinm r11, r11, 0, 0x1d, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828F2810: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828F2814: 808AA078  lwz r4, -0x5f88(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24456 as u32) ) } as u64;
	// 828F2818: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F281C: 485011ED  bl 0x82df3a08
	ctx.lr = 0x828F2820;
	sub_82DF3A08(ctx, base);
	// 828F2820: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2824: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F2828: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F282C: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F2830: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F2834: 4E800421  bctrl
	ctx.lr = 0x828F2838;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F2838: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F283C: 48500BED  bl 0x82df3428
	ctx.lr = 0x828F2840;
	sub_82DF3428(ctx, base);
	// 828F2840: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2844: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828F2848: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F284C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2850: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F2854: 41820050  beq 0x828f28a4
	if ctx.cr[0].eq {
	pc = 0x828F28A4; continue 'dispatch;
	}
	// 828F2858: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F285C: 4BEF7AB5  bl 0x827ea310
	ctx.lr = 0x828F2860;
	sub_827EA310(ctx, base);
	// 828F2860: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F2864: 41820040  beq 0x828f28a4
	if ctx.cr[0].eq {
	pc = 0x828F28A4; continue 'dispatch;
	}
	// 828F2868: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F286C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F2870: 808BA054  lwz r4, -0x5fac(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24492 as u32) ) } as u64;
	// 828F2874: 48501195  bl 0x82df3a08
	ctx.lr = 0x828F2878;
	sub_82DF3A08(ctx, base);
	// 828F2878: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F287C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F2880: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F2884: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F2888: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F288C: 4E800421  bctrl
	ctx.lr = 0x828F2890;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F2890: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F2894: 48500B95  bl 0x82df3428
	ctx.lr = 0x828F2898;
	sub_82DF3428(ctx, base);
	// 828F2898: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F289C: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828F28A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F28A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F28A8: 488B5910  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F28B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F28B0 size=228
    let mut pc: u32 = 0x828F28B0;
    'dispatch: loop {
        match pc {
            0x828F28B0 => {
    //   block [0x828F28B0..0x828F2994)
	// 828F28B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F28B4: 488B58B9  bl 0x831a816c
	ctx.lr = 0x828F28B8;
	sub_831A8130(ctx, base);
	// 828F28B8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F28BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F28C0: 48861D41  bl 0x83154600
	ctx.lr = 0x828F28C4;
	sub_83154600(ctx, base);
	// 828F28C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F28C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F28CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F28D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F28D4: 4E800421  bctrl
	ctx.lr = 0x828F28D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F28D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F28DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F28E0: 48023E89  bl 0x82916768
	ctx.lr = 0x828F28E4;
	sub_82916768(ctx, base);
	// 828F28E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F28E8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828F28EC: 48016D6D  bl 0x82909658
	ctx.lr = 0x828F28F0;
	sub_82909658(ctx, base);
	// 828F28F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F28F4: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828F28F8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 828F28FC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828F2900: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F2904: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F2998 size=92
    let mut pc: u32 = 0x828F2998;
    'dispatch: loop {
        match pc {
            0x828F2998 => {
    //   block [0x828F2998..0x828F29F4)
	// 828F2998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F299C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F29A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F29A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F29A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F29AC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F29B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F29B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F29B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F29BC: 808BA8AC  lwz r4, -0x5754(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22356 as u32) ) } as u64;
	// 828F29C0: 48501049  bl 0x82df3a08
	ctx.lr = 0x828F29C4;
	sub_82DF3A08(ctx, base);
	// 828F29C4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828F29C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F29CC: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828F29D0: 4801B481  bl 0x8290de50
	ctx.lr = 0x828F29D4;
	sub_8290DE50(ctx, base);
	// 828F29D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F29D8: 48500A51  bl 0x82df3428
	ctx.lr = 0x828F29DC;
	sub_82DF3428(ctx, base);
	// 828F29DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F29E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F29E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F29E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F29EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F29F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F29F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F29F8 size=96
    let mut pc: u32 = 0x828F29F8;
    'dispatch: loop {
        match pc {
            0x828F29F8 => {
    //   block [0x828F29F8..0x828F2A58)
	// 828F29F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F29FC: 488B5771  bl 0x831a816c
	ctx.lr = 0x828F2A00;
	sub_831A8130(ctx, base);
	// 828F2A00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F2A04: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F2A08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F2A0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F2A10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F2A14: 808BB408  lwz r4, -0x4bf8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19448 as u32) ) } as u64;
	// 828F2A18: 48500FF1  bl 0x82df3a08
	ctx.lr = 0x828F2A1C;
	sub_82DF3A08(ctx, base);
	// 828F2A1C: 387F00FC  addi r3, r31, 0xfc
	ctx.r[3].s64 = ctx.r[31].s64 + 252;
	// 828F2A20: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828F2A24: 48567CAD  bl 0x82e5a6d0
	ctx.lr = 0x828F2A28;
	sub_82E5A6D0(ctx, base);
	// 828F2A28: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F2A2C: 485008DD  bl 0x82df3308
	ctx.lr = 0x828F2A30;
	sub_82DF3308(ctx, base);
	// 828F2A30: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F2A34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F2A38: 485009F1  bl 0x82df3428
	ctx.lr = 0x828F2A3C;
	sub_82DF3428(ctx, base);
	// 828F2A3C: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F2A40: 40820010  bne 0x828f2a50
	if !ctx.cr[0].eq {
	pc = 0x828F2A50; continue 'dispatch;
	}
	// 828F2A44: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F2A48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F2A4C: 4B9CD5B5  bl 0x822c0000
	ctx.lr = 0x828F2A50;
	sub_822C0000(ctx, base);
	// 828F2A50: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F2A54: 488B5768  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2A58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F2A58 size=52
    let mut pc: u32 = 0x828F2A58;
    'dispatch: loop {
        match pc {
            0x828F2A58 => {
    //   block [0x828F2A58..0x828F2A8C)
	// 828F2A58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F2A5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F2A60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F2A64: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F2A68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F2A6C: 4BEF977D  bl 0x827ec1e8
	ctx.lr = 0x828F2A70;
	sub_827EC1E8(ctx, base);
	// 828F2A70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F2A74: 4B9FA6DD  bl 0x822ed150
	ctx.lr = 0x828F2A78;
	sub_822ED150(ctx, base);
	// 828F2A78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F2A7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F2A80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F2A84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F2A88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F2A90 size=68
    let mut pc: u32 = 0x828F2A90;
    'dispatch: loop {
        match pc {
            0x828F2A90 => {
    //   block [0x828F2A90..0x828F2AD4)
	// 828F2A90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F2A94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F2A98: DBE1FFF0  stfd f31, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 828F2A9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F2AA0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828F2AA4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F2AA8: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F2AAC: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828F2AB0: 40980010  bge cr6, 0x828f2ac0
	if !ctx.cr[6].lt {
	pc = 0x828F2AC0; continue 'dispatch;
	}
	// 828F2AB4: 4BEF9735  bl 0x827ec1e8
	ctx.lr = 0x828F2AB8;
	sub_827EC1E8(ctx, base);
	// 828F2AB8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F2ABC: 4B9FB09D  bl 0x822edb58
	ctx.lr = 0x828F2AC0;
	sub_822EDB58(ctx, base);
	// 828F2AC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F2AC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F2AC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F2ACC: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F2AD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F2AD8 size=12
    let mut pc: u32 = 0x828F2AD8;
    'dispatch: loop {
        match pc {
            0x828F2AD8 => {
    //   block [0x828F2AD8..0x828F2AE4)
	// 828F2AD8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828F2ADC: 386BAAAC  addi r3, r11, -0x5554
	ctx.r[3].s64 = ctx.r[11].s64 + -21844;
	// 828F2AE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2AE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F2AE8 size=12
    let mut pc: u32 = 0x828F2AE8;
    'dispatch: loop {
        match pc {
            0x828F2AE8 => {
    //   block [0x828F2AE8..0x828F2AF4)
	// 828F2AE8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828F2AEC: 386BAAB8  addi r3, r11, -0x5548
	ctx.r[3].s64 = ctx.r[11].s64 + -21832;
	// 828F2AF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F2AF8 size=8
    let mut pc: u32 = 0x828F2AF8;
    'dispatch: loop {
        match pc {
            0x828F2AF8 => {
    //   block [0x828F2AF8..0x828F2B00)
	// 828F2AF8: 38630394  addi r3, r3, 0x394
	ctx.r[3].s64 = ctx.r[3].s64 + 916;
	// 828F2AFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F2B00 size=12
    let mut pc: u32 = 0x828F2B00;
    'dispatch: loop {
        match pc {
            0x828F2B00 => {
    //   block [0x828F2B00..0x828F2B0C)
	// 828F2B00: 89640018  lbz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 828F2B04: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F2B08: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2B0C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F2B0C size=8
    let mut pc: u32 = 0x828F2B0C;
    'dispatch: loop {
        match pc {
            0x828F2B0C => {
    //   block [0x828F2B0C..0x828F2B14)
	// 828F2B0C: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 828F2B10: 4BC1DAC0  b 0x825105d0
	sub_825105D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2B14(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F2B14 size=4
    let mut pc: u32 = 0x828F2B14;
    'dispatch: loop {
        match pc {
            0x828F2B14 => {
    //   block [0x828F2B14..0x828F2B18)
	// 828F2B14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F2B18 size=116
    let mut pc: u32 = 0x828F2B18;
    'dispatch: loop {
        match pc {
            0x828F2B18 => {
    //   block [0x828F2B18..0x828F2B8C)
	// 828F2B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F2B1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F2B20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F2B24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F2B28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F2B2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F2B30: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F2B34: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828F2B38: 409A000C  bne cr6, 0x828f2b44
	if !ctx.cr[6].eq {
	pc = 0x828F2B44; continue 'dispatch;
	}
	// 828F2B3C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2B40: 48000030  b 0x828f2b70
	pc = 0x828F2B70; continue 'dispatch;
	// 828F2B44: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828F2B48: 419A0024  beq cr6, 0x828f2b6c
	if ctx.cr[6].eq {
	pc = 0x828F2B6C; continue 'dispatch;
	}
	// 828F2B4C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F2B50: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2B54: 388BA9D0  addi r4, r11, -0x5630
	ctx.r[4].s64 = ctx.r[11].s64 + -22064;
	// 828F2B58: 488B55A1  bl 0x831a80f8
	ctx.lr = 0x828F2B5C;
	sub_831A80F8(ctx, base);
	// 828F2B5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F2B60: 4182000C  beq 0x828f2b6c
	if ctx.cr[0].eq {
	pc = 0x828F2B6C; continue 'dispatch;
	}
	// 828F2B64: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828F2B68: 4800000C  b 0x828f2b74
	pc = 0x828F2B74; continue 'dispatch;
	// 828F2B6C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F2B70: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F2B74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F2B78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F2B7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F2B80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F2B84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F2B88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F2B90 size=144
    let mut pc: u32 = 0x828F2B90;
    'dispatch: loop {
        match pc {
            0x828F2B90 => {
    //   block [0x828F2B90..0x828F2C20)
	// 828F2B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F2B94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F2B98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F2B9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F2BA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F2BA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F2BA8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F2BAC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828F2BB0: 409A0028  bne cr6, 0x828f2bd8
	if !ctx.cr[6].eq {
	pc = 0x828F2BD8; continue 'dispatch;
	}
	// 828F2BB4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F2BB8: 419A0050  beq cr6, 0x828f2c08
	if ctx.cr[6].eq {
	pc = 0x828F2C08; continue 'dispatch;
	}
	// 828F2BBC: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828F2BC0: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828F2BC4: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828F2BC8: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828F2BCC: E97E0010  ld r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	// 828F2BD0: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 828F2BD4: 48000034  b 0x828f2c08
	pc = 0x828F2C08; continue 'dispatch;
	// 828F2BD8: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828F2BDC: 419A002C  beq cr6, 0x828f2c08
	if ctx.cr[6].eq {
	pc = 0x828F2C08; continue 'dispatch;
	}
	// 828F2BE0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F2BE4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2BE8: 388BAA20  addi r4, r11, -0x55e0
	ctx.r[4].s64 = ctx.r[11].s64 + -21984;
	// 828F2BEC: 488B550D  bl 0x831a80f8
	ctx.lr = 0x828F2BF0;
	sub_831A80F8(ctx, base);
	// 828F2BF0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F2BF4: 4182000C  beq 0x828f2c00
	if ctx.cr[0].eq {
	pc = 0x828F2C00; continue 'dispatch;
	}
	// 828F2BF8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828F2BFC: 4800000C  b 0x828f2c08
	pc = 0x828F2C08; continue 'dispatch;
	// 828F2C00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F2C04: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F2C08: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F2C0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F2C10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F2C14: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F2C18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F2C1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F2C20 size=136
    let mut pc: u32 = 0x828F2C20;
    'dispatch: loop {
        match pc {
            0x828F2C20 => {
    //   block [0x828F2C20..0x828F2CA8)
	// 828F2C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F2C24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F2C28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F2C2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F2C30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F2C34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F2C38: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F2C3C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828F2C40: 409A0020  bne cr6, 0x828f2c60
	if !ctx.cr[6].eq {
	pc = 0x828F2C60; continue 'dispatch;
	}
	// 828F2C44: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F2C48: 419A0048  beq cr6, 0x828f2c90
	if ctx.cr[6].eq {
	pc = 0x828F2C90; continue 'dispatch;
	}
	// 828F2C4C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828F2C50: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828F2C54: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828F2C58: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828F2C5C: 48000034  b 0x828f2c90
	pc = 0x828F2C90; continue 'dispatch;
	// 828F2C60: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828F2C64: 419A002C  beq cr6, 0x828f2c90
	if ctx.cr[6].eq {
	pc = 0x828F2C90; continue 'dispatch;
	}
	// 828F2C68: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F2C6C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2C70: 388BAAF8  addi r4, r11, -0x5508
	ctx.r[4].s64 = ctx.r[11].s64 + -21768;
	// 828F2C74: 488B5485  bl 0x831a80f8
	ctx.lr = 0x828F2C78;
	sub_831A80F8(ctx, base);
	// 828F2C78: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F2C7C: 4182000C  beq 0x828f2c88
	if ctx.cr[0].eq {
	pc = 0x828F2C88; continue 'dispatch;
	}
	// 828F2C80: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828F2C84: 4800000C  b 0x828f2c90
	pc = 0x828F2C90; continue 'dispatch;
	// 828F2C88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F2C8C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F2C90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F2C94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F2C98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F2C9C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F2CA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F2CA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F2CA8 size=204
    let mut pc: u32 = 0x828F2CA8;
    'dispatch: loop {
        match pc {
            0x828F2CA8 => {
    //   block [0x828F2CA8..0x828F2D74)
	// 828F2CA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F2CAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F2CB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F2CB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F2CB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F2CBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F2CC0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F2CC4: 4801E55D  bl 0x82911220
	ctx.lr = 0x828F2CC8;
	sub_82911220(ctx, base);
	// 828F2CC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F2CCC: 4BEF9495  bl 0x827ec160
	ctx.lr = 0x828F2CD0;
	sub_827EC160(ctx, base);
	// 828F2CD0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2CD4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2CD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F2CDC: 4E800421  bctrl
	ctx.lr = 0x828F2CE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F2CE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F2CE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F2CE8: 481CF2A9  bl 0x82ac1f90
	ctx.lr = 0x828F2CEC;
	sub_82AC1F90(ctx, base);
	// 828F2CEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F2CF0: 4BEF9471  bl 0x827ec160
	ctx.lr = 0x828F2CF4;
	sub_827EC160(ctx, base);
	// 828F2CF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2CF8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F2CFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F2D00: 4E800421  bctrl
	ctx.lr = 0x828F2D04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F2D04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F2D08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F2D0C: 481B87CD  bl 0x82aab4d8
	ctx.lr = 0x828F2D10;
	sub_82AAB4D8(ctx, base);
	// 828F2D10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F2D14: 807F01CC  lwz r3, 0x1cc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 828F2D18: 4BEF7479  bl 0x827ea190
	ctx.lr = 0x828F2D1C;
	sub_827EA190(ctx, base);
	// 828F2D1C: 807F0360  lwz r3, 0x360(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(864 as u32) ) } as u64;
	// 828F2D20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F2D24: 419A0018  beq cr6, 0x828f2d3c
	if ctx.cr[6].eq {
	pc = 0x828F2D3C; continue 'dispatch;
	}
	// 828F2D28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2D2C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F2D30: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F2D34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F2D38: 4E800421  bctrl
	ctx.lr = 0x828F2D3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F2D3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F2D40: 807F0368  lwz r3, 0x368(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(872 as u32) ) } as u64;
	// 828F2D44: 4802FC35  bl 0x82922978
	ctx.lr = 0x828F2D48;
	sub_82922978(ctx, base);
	// 828F2D48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2D4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F2D50: 816B00C4  lwz r11, 0xc4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) } as u64;
	// 828F2D54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F2D58: 4E800421  bctrl
	ctx.lr = 0x828F2D5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F2D5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F2D60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F2D64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F2D68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F2D6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F2D70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F2D78 size=152
    let mut pc: u32 = 0x828F2D78;
    'dispatch: loop {
        match pc {
            0x828F2D78 => {
    //   block [0x828F2D78..0x828F2E10)
	// 828F2D78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F2D7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F2D80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F2D84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F2D88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F2D8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F2D90: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F2D94: 807F0360  lwz r3, 0x360(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(864 as u32) ) } as u64;
	// 828F2D98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2D9C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 828F2DA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F2DA4: 4E800421  bctrl
	ctx.lr = 0x828F2DA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F2DA8: 807F0360  lwz r3, 0x360(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(864 as u32) ) } as u64;
	// 828F2DAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2DB0: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828F2DB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F2DB8: 4E800421  bctrl
	ctx.lr = 0x828F2DBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F2DBC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F2DC0: 41820038  beq 0x828f2df8
	if ctx.cr[0].eq {
	pc = 0x828F2DF8; continue 'dispatch;
	}
	// 828F2DC4: 807F0360  lwz r3, 0x360(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(864 as u32) ) } as u64;
	// 828F2DC8: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F2DCC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F2DD0: 41820018  beq 0x828f2de8
	if ctx.cr[0].eq {
	pc = 0x828F2DE8; continue 'dispatch;
	}
	// 828F2DD4: 48002E9D  bl 0x828f5c70
	ctx.lr = 0x828F2DD8;
	sub_828F5C70(ctx, base);
	// 828F2DD8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F2DDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F2DE0: 4BC1EEE1  bl 0x82511cc0
	ctx.lr = 0x828F2DE4;
	sub_82511CC0(ctx, base);
	// 828F2DE4: 48000014  b 0x828f2df8
	pc = 0x828F2DF8; continue 'dispatch;
	// 828F2DE8: 48002E89  bl 0x828f5c70
	ctx.lr = 0x828F2DEC;
	sub_828F5C70(ctx, base);
	// 828F2DEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F2DF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F2DF4: 4BC1EEAD  bl 0x82511ca0
	ctx.lr = 0x828F2DF8;
	sub_82511CA0(ctx, base);
	// 828F2DF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F2DFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F2E00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F2E04: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F2E08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F2E0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F2E10 size=168
    let mut pc: u32 = 0x828F2E10;
    'dispatch: loop {
        match pc {
            0x828F2E10 => {
    //   block [0x828F2E10..0x828F2EB8)
	// 828F2E10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F2E14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F2E18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F2E1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F2E20: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F2E24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F2E28: 48015F01  bl 0x82908d28
	ctx.lr = 0x828F2E2C;
	sub_82908D28(ctx, base);
	// 828F2E2C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828F2E30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F2E34: 396BAAB8  addi r11, r11, -0x5548
	ctx.r[11].s64 = ctx.r[11].s64 + -21832;
	// 828F2E38: 808B0050  lwz r4, 0x50(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F2E3C: 4801B715  bl 0x8290e550
	ctx.lr = 0x828F2E40;
	sub_8290E550(ctx, base);
	// 828F2E40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F2E44: 4801D54D  bl 0x82910390
	ctx.lr = 0x828F2E48;
	sub_82910390(ctx, base);
	// 828F2E48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F2E4C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F2E50: 4BEF9421  bl 0x827ec270
	ctx.lr = 0x828F2E54;
	sub_827EC270(ctx, base);
	// 828F2E54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F2E58: 4BEF9309  bl 0x827ec160
	ctx.lr = 0x828F2E5C;
	sub_827EC160(ctx, base);
	// 828F2E5C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F2E60: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2E64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F2E68: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828F2E6C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2E70: 816A0018  lwz r11, 0x18(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 828F2E74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F2E78: 4E800421  bctrl
	ctx.lr = 0x828F2E7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F2E7C: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828F2E80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F2E84: 815F00D8  lwz r10, 0xd8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 828F2E88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F2E8C: C02B7BC8  lfs f1, 0x7bc8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31688 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F2E90: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828F2E94: 4E800421  bctrl
	ctx.lr = 0x828F2E98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F2E98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F2E9C: 4BC1D735  bl 0x825105d0
	ctx.lr = 0x828F2EA0;
	sub_825105D0(ctx, base);
	// 828F2EA0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F2EA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F2EA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F2EAC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F2EB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F2EB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F2EB8 size=16
    let mut pc: u32 = 0x828F2EB8;
    'dispatch: loop {
        match pc {
            0x828F2EB8 => {
    //   block [0x828F2EB8..0x828F2EC8)
	// 828F2EB8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828F2EBC: 396BAAB8  addi r11, r11, -0x5548
	ctx.r[11].s64 = ctx.r[11].s64 + -21832;
	// 828F2EC0: 386B0100  addi r3, r11, 0x100
	ctx.r[3].s64 = ctx.r[11].s64 + 256;
	// 828F2EC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F2EC8 size=16
    let mut pc: u32 = 0x828F2EC8;
    'dispatch: loop {
        match pc {
            0x828F2EC8 => {
    //   block [0x828F2EC8..0x828F2ED8)
	// 828F2EC8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828F2ECC: 396BAAB8  addi r11, r11, -0x5548
	ctx.r[11].s64 = ctx.r[11].s64 + -21832;
	// 828F2ED0: 386B004C  addi r3, r11, 0x4c
	ctx.r[3].s64 = ctx.r[11].s64 + 76;
	// 828F2ED4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F2ED8 size=200
    let mut pc: u32 = 0x828F2ED8;
    'dispatch: loop {
        match pc {
            0x828F2ED8 => {
    //   block [0x828F2ED8..0x828F2FA0)
	// 828F2ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F2EDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F2EE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F2EE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F2EE8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F2EEC: 83C300F4  lwz r30, 0xf4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(244 as u32) ) } as u64;
	// 828F2EF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F2EF4: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828F2EF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F2EFC: 48024135  bl 0x82917030
	ctx.lr = 0x828F2F00;
	sub_82917030(ctx, base);
	// 828F2F00: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F2F04: 40820018  bne 0x828f2f1c
	if !ctx.cr[0].eq {
	pc = 0x828F2F1C; continue 'dispatch;
	}
	// 828F2F08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F2F0C: 48023BF5  bl 0x82916b00
	ctx.lr = 0x828F2F10;
	sub_82916B00(ctx, base);
	// 828F2F10: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F2F14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F2F18: 41820008  beq 0x828f2f20
	if ctx.cr[0].eq {
	pc = 0x828F2F20; continue 'dispatch;
	}
	// 828F2F1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F2F20: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 828F2F24: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828F2F28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F2F2C: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 828F2F30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F2F34: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F2F38: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828F2F3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F2F40: 4E800421  bctrl
	ctx.lr = 0x828F2F44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F2F44: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F2F48: 39400040  li r10, 0x40
	ctx.r[10].s64 = 64;
	// 828F2F4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F2F50: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F2FA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F2FA0 size=196
    let mut pc: u32 = 0x828F2FA0;
    'dispatch: loop {
        match pc {
            0x828F2FA0 => {
    //   block [0x828F2FA0..0x828F3064)
	// 828F2FA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F2FA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F2FA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F2FAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F2FB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F2FB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F2FB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F2FBC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F2FC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F2FC4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F2FC8: 4B9CD971  bl 0x822c0938
	ctx.lr = 0x828F2FCC;
	sub_822C0938(ctx, base);
	// 828F2FCC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F2FD0: 41820028  beq 0x828f2ff8
	if ctx.cr[0].eq {
	pc = 0x828F2FF8; continue 'dispatch;
	}
	// 828F2FD4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F2FD8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F2FDC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F2FE0: 392B2CAC  addi r9, r11, 0x2cac
	ctx.r[9].s64 = ctx.r[11].s64 + 11436;
	// 828F2FE4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F2FE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F2FEC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F2FF0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F2FF4: 48000008  b 0x828f2ffc
	pc = 0x828F2FFC; continue 'dispatch;
	// 828F2FF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F2FFC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F3000: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3004: 409A0044  bne cr6, 0x828f3048
	if !ctx.cr[6].eq {
	pc = 0x828F3048; continue 'dispatch;
	}
	// 828F3008: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F300C: 419A001C  beq cr6, 0x828f3028
	if ctx.cr[6].eq {
	pc = 0x828F3028; continue 'dispatch;
	}
	// 828F3010: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3014: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F3018: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F301C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3020: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F3024: 4E800421  bctrl
	ctx.lr = 0x828F3028;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F3028: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F302C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F3030: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F3034: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F3038: 816BA8BC  lwz r11, -0x5744(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22340 as u32) ) } as u64;
	// 828F303C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F3040: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F3044: 4B9CCFBD  bl 0x822c0000
	ctx.lr = 0x828F3048;
	sub_822C0000(ctx, base);
	// 828F3048: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F304C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F3050: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F3054: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F3058: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F305C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F3060: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F3068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F3068 size=196
    let mut pc: u32 = 0x828F3068;
    'dispatch: loop {
        match pc {
            0x828F3068 => {
    //   block [0x828F3068..0x828F312C)
	// 828F3068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F306C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F3070: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F3074: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F3078: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F307C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F3080: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F3084: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F3088: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F308C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F3090: 4B9CD8A9  bl 0x822c0938
	ctx.lr = 0x828F3094;
	sub_822C0938(ctx, base);
	// 828F3094: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F3098: 41820028  beq 0x828f30c0
	if ctx.cr[0].eq {
	pc = 0x828F30C0; continue 'dispatch;
	}
	// 828F309C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F30A0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F30A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F30A8: 392B2CC0  addi r9, r11, 0x2cc0
	ctx.r[9].s64 = ctx.r[11].s64 + 11456;
	// 828F30AC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F30B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F30B4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F30B8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F30BC: 48000008  b 0x828f30c4
	pc = 0x828F30C4; continue 'dispatch;
	// 828F30C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F30C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F30C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F30CC: 409A0044  bne cr6, 0x828f3110
	if !ctx.cr[6].eq {
	pc = 0x828F3110; continue 'dispatch;
	}
	// 828F30D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F30D4: 419A001C  beq cr6, 0x828f30f0
	if ctx.cr[6].eq {
	pc = 0x828F30F0; continue 'dispatch;
	}
	// 828F30D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F30DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F30E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F30E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F30E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F30EC: 4E800421  bctrl
	ctx.lr = 0x828F30F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F30F0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F30F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F30F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F30FC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F3100: 816BA8BC  lwz r11, -0x5744(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22340 as u32) ) } as u64;
	// 828F3104: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F3108: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F310C: 4B9CCEF5  bl 0x822c0000
	ctx.lr = 0x828F3110;
	sub_822C0000(ctx, base);
	// 828F3110: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F3114: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F3118: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F311C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F3120: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F3124: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F3128: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F3130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F3130 size=196
    let mut pc: u32 = 0x828F3130;
    'dispatch: loop {
        match pc {
            0x828F3130 => {
    //   block [0x828F3130..0x828F31F4)
	// 828F3130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F3134: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F3138: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F313C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F3140: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F3144: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F3148: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F314C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F3150: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F3154: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F3158: 4B9CD7E1  bl 0x822c0938
	ctx.lr = 0x828F315C;
	sub_822C0938(ctx, base);
	// 828F315C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F3160: 41820028  beq 0x828f3188
	if ctx.cr[0].eq {
	pc = 0x828F3188; continue 'dispatch;
	}
	// 828F3164: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F3168: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F316C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F3170: 392B2CD4  addi r9, r11, 0x2cd4
	ctx.r[9].s64 = ctx.r[11].s64 + 11476;
	// 828F3174: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F3178: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F317C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F3180: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F3184: 48000008  b 0x828f318c
	pc = 0x828F318C; continue 'dispatch;
	// 828F3188: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F318C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F3190: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3194: 409A0044  bne cr6, 0x828f31d8
	if !ctx.cr[6].eq {
	pc = 0x828F31D8; continue 'dispatch;
	}
	// 828F3198: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F319C: 419A001C  beq cr6, 0x828f31b8
	if ctx.cr[6].eq {
	pc = 0x828F31B8; continue 'dispatch;
	}
	// 828F31A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F31A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F31A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F31AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F31B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F31B4: 4E800421  bctrl
	ctx.lr = 0x828F31B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F31B8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F31BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F31C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F31C4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F31C8: 816BA8BC  lwz r11, -0x5744(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22340 as u32) ) } as u64;
	// 828F31CC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F31D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F31D4: 4B9CCE2D  bl 0x822c0000
	ctx.lr = 0x828F31D8;
	sub_822C0000(ctx, base);
	// 828F31D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F31DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F31E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F31E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F31E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F31EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F31F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F31F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F31F8 size=72
    let mut pc: u32 = 0x828F31F8;
    'dispatch: loop {
        match pc {
            0x828F31F8 => {
    //   block [0x828F31F8..0x828F3240)
	// 828F31F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F31FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F3200: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F3204: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828F3208: 419A001C  beq cr6, 0x828f3224
	if ctx.cr[6].eq {
	pc = 0x828F3224; continue 'dispatch;
	}
	// 828F320C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828F3210: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828F3214: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828F3218: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F321C: 4BFFF8FD  bl 0x828f2b18
	ctx.lr = 0x828F3220;
	sub_828F2B18(ctx, base);
	// 828F3220: 48000010  b 0x828f3230
	pc = 0x828F3230; continue 'dispatch;
	// 828F3224: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F3228: 396BA9D0  addi r11, r11, -0x5630
	ctx.r[11].s64 = ctx.r[11].s64 + -22064;
	// 828F322C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F3230: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F3234: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F3238: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F323C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F3240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F3240 size=172
    let mut pc: u32 = 0x828F3240;
    'dispatch: loop {
        match pc {
            0x828F3240 => {
    //   block [0x828F3240..0x828F32EC)
	// 828F3240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F3244: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F3248: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F324C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F3250: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F3254: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F3258: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F325C: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828F3260: 396B2EBC  addi r11, r11, 0x2ebc
	ctx.r[11].s64 = ctx.r[11].s64 + 11964;
	// 828F3264: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828F3268: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828F326C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F3270: 394A2CFC  addi r10, r10, 0x2cfc
	ctx.r[10].s64 = ctx.r[10].s64 + 11516;
	// 828F3274: 807F0388  lwz r3, 0x388(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(904 as u32) ) } as u64;
	// 828F3278: 39292CE8  addi r9, r9, 0x2ce8
	ctx.r[9].s64 = ctx.r[9].s64 + 11496;
	// 828F327C: 39682EA0  addi r11, r8, 0x2ea0
	ctx.r[11].s64 = ctx.r[8].s64 + 11936;
	// 828F3280: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828F3284: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828F3288: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828F328C: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828F3290: 4B9CCFD9  bl 0x822c0268
	ctx.lr = 0x828F3294;
	sub_822C0268(ctx, base);
	// 828F3294: 807F0384  lwz r3, 0x384(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(900 as u32) ) } as u64;
	// 828F3298: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F329C: 419A0008  beq cr6, 0x828f32a4
	if ctx.cr[6].eq {
	pc = 0x828F32A4; continue 'dispatch;
	}
	// 828F32A0: 4B9CD5F1  bl 0x822c0890
	ctx.lr = 0x828F32A4;
	sub_822C0890(ctx, base);
	// 828F32A4: 807F037C  lwz r3, 0x37c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(892 as u32) ) } as u64;
	// 828F32A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F32AC: 419A0008  beq cr6, 0x828f32b4
	if ctx.cr[6].eq {
	pc = 0x828F32B4; continue 'dispatch;
	}
	// 828F32B0: 4B9CD5E1  bl 0x822c0890
	ctx.lr = 0x828F32B4;
	sub_822C0890(ctx, base);
	// 828F32B4: 807F0374  lwz r3, 0x374(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(884 as u32) ) } as u64;
	// 828F32B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F32BC: 419A0008  beq cr6, 0x828f32c4
	if ctx.cr[6].eq {
	pc = 0x828F32C4; continue 'dispatch;
	}
	// 828F32C0: 4B9CD5D1  bl 0x822c0890
	ctx.lr = 0x828F32C4;
	sub_822C0890(ctx, base);
	// 828F32C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F32C8: 4801D9C9  bl 0x82910c90
	ctx.lr = 0x828F32CC;
	sub_82910C90(ctx, base);
	// 828F32CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F32D0: 4BEB4389  bl 0x827a7658
	ctx.lr = 0x828F32D4;
	sub_827A7658(ctx, base);
	// 828F32D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F32D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F32DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F32E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F32E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F32E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F32F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F32F0 size=8
    let mut pc: u32 = 0x828F32F0;
    'dispatch: loop {
        match pc {
            0x828F32F0 => {
    //   block [0x828F32F0..0x828F32F8)
	// 828F32F0: 3863FFC8  addi r3, r3, -0x38
	ctx.r[3].s64 = ctx.r[3].s64 + -56;
	// 828F32F4: 4800055C  b 0x828f3850
	sub_828F3850(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F32F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F32F8 size=8
    let mut pc: u32 = 0x828F32F8;
    'dispatch: loop {
        match pc {
            0x828F32F8 => {
    //   block [0x828F32F8..0x828F3300)
	// 828F32F8: 3863FDE8  addi r3, r3, -0x218
	ctx.r[3].s64 = ctx.r[3].s64 + -536;
	// 828F32FC: 48000554  b 0x828f3850
	sub_828F3850(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F3300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F3300 size=8
    let mut pc: u32 = 0x828F3300;
    'dispatch: loop {
        match pc {
            0x828F3300 => {
    //   block [0x828F3300..0x828F3308)
	// 828F3300: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828F3304: 4800054C  b 0x828f3850
	sub_828F3850(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F3308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F3308 size=132
    let mut pc: u32 = 0x828F3308;
    'dispatch: loop {
        match pc {
            0x828F3308 => {
    //   block [0x828F3308..0x828F338C)
	// 828F3308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F330C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F3310: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F3314: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F3318: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F331C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F3320: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F3324: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828F3328: 807F01E8  lwz r3, 0x1e8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 828F332C: 4B9FA6D5  bl 0x822eda00
	ctx.lr = 0x828F3330;
	sub_822EDA00(ctx, base);
	// 828F3330: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828F3334: C00100A0  lfs f0, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F3338: C1A100A4  lfs f13, 0xa4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F333C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 828F3340: C18100A8  lfs f12, 0xa8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828F3344: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828F3348: C16100AC  lfs f11, 0xac(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828F334C: 807F01E8  lwz r3, 0x1e8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) } as u64;
	// 828F3350: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828F3354: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828F3358: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828F335C: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828F3360: D161005C  stfs f11, 0x5c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828F3364: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F3390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F3390 size=100
    let mut pc: u32 = 0x828F3390;
    'dispatch: loop {
        match pc {
            0x828F3390 => {
    //   block [0x828F3390..0x828F33F4)
	// 828F3390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F3394: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F3398: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F339C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F33A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F33A4: 3BE30010  addi r31, r3, 0x10
	ctx.r[31].s64 = ctx.r[3].s64 + 16;
	// 828F33A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F33AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F33B0: 480162A9  bl 0x82909658
	ctx.lr = 0x828F33B4;
	sub_82909658(ctx, base);
	// 828F33B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F33B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F33BC: 481202C5  bl 0x82a13680
	ctx.lr = 0x828F33C0;
	sub_82A13680(ctx, base);
	// 828F33C0: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828F33C4: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828F33C8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F33F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F33F8 size=84
    let mut pc: u32 = 0x828F33F8;
    'dispatch: loop {
        match pc {
            0x828F33F8 => {
    //   block [0x828F33F8..0x828F344C)
	// 828F33F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F33FC: 488B4D71  bl 0x831a816c
	ctx.lr = 0x828F3400;
	sub_831A8130(ctx, base);
	// 828F3400: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F3404: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F3408: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F340C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F3410: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 828F3414: 409A0008  bne cr6, 0x828f341c
	if !ctx.cr[6].eq {
	pc = 0x828F341C; continue 'dispatch;
	}
	// 828F3418: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F341C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F3420: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828F3424: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F3428: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F342C: 4BFFFB75  bl 0x828f2fa0
	ctx.lr = 0x828F3430;
	sub_828F2FA0(ctx, base);
	// 828F3430: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F3434: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F3438: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F343C: 4B9CCBC5  bl 0x822c0000
	ctx.lr = 0x828F3440;
	sub_822C0000(ctx, base);
	// 828F3440: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F3444: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F3448: 488B4D74  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F3450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F3450 size=72
    let mut pc: u32 = 0x828F3450;
    'dispatch: loop {
        match pc {
            0x828F3450 => {
    //   block [0x828F3450..0x828F3498)
	// 828F3450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F3454: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F3458: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F345C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828F3460: 419A001C  beq cr6, 0x828f347c
	if ctx.cr[6].eq {
	pc = 0x828F347C; continue 'dispatch;
	}
	// 828F3464: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828F3468: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828F346C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828F3470: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F3474: 4BFFF71D  bl 0x828f2b90
	ctx.lr = 0x828F3478;
	sub_828F2B90(ctx, base);
	// 828F3478: 48000010  b 0x828f3488
	pc = 0x828F3488; continue 'dispatch;
	// 828F347C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F3480: 396BAA20  addi r11, r11, -0x55e0
	ctx.r[11].s64 = ctx.r[11].s64 + -21984;
	// 828F3484: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F3488: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F348C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F3490: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F3494: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F3498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F3498 size=72
    let mut pc: u32 = 0x828F3498;
    'dispatch: loop {
        match pc {
            0x828F3498 => {
    //   block [0x828F3498..0x828F34E0)
	// 828F3498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F349C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F34A0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F34A4: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828F34A8: 419A001C  beq cr6, 0x828f34c4
	if ctx.cr[6].eq {
	pc = 0x828F34C4; continue 'dispatch;
	}
	// 828F34AC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828F34B0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828F34B4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828F34B8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F34BC: 4BFFF765  bl 0x828f2c20
	ctx.lr = 0x828F34C0;
	sub_828F2C20(ctx, base);
	// 828F34C0: 48000010  b 0x828f34d0
	pc = 0x828F34D0; continue 'dispatch;
	// 828F34C4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F34C8: 396BAAF8  addi r11, r11, -0x5508
	ctx.r[11].s64 = ctx.r[11].s64 + -21768;
	// 828F34CC: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F34D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F34D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F34D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F34DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F34E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F34E0 size=668
    let mut pc: u32 = 0x828F34E0;
    'dispatch: loop {
        match pc {
            0x828F34E0 => {
    //   block [0x828F34E0..0x828F377C)
	// 828F34E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F34E4: 488B4C85  bl 0x831a8168
	ctx.lr = 0x828F34E8;
	sub_831A8130(ctx, base);
	// 828F34E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F34EC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828F34F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F34F4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F34F8: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828F34FC: 41820038  beq 0x828f3534
	if ctx.cr[0].eq {
	pc = 0x828F3534; continue 'dispatch;
	}
	// 828F3500: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F3504: 488B6485  bl 0x831a9988
	ctx.lr = 0x828F3508;
	sub_831A9988(ctx, base);
	// 828F3508: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 828F350C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F3510: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 828F3514: 488B4BE5  bl 0x831a80f8
	ctx.lr = 0x828F3518;
	sub_831A80F8(ctx, base);
	// 828F3518: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F351C: 41820018  beq 0x828f3534
	if ctx.cr[0].eq {
	pc = 0x828F3534; continue 'dispatch;
	}
	// 828F3520: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F3524: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828F3528: 481A12F1  bl 0x82a94818
	ctx.lr = 0x828F352C;
	sub_82A94818(ctx, base);
	// 828F352C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828F3530: 48000244  b 0x828f3774
	pc = 0x828F3774; continue 'dispatch;
	// 828F3534: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828F3538: 419A022C  beq cr6, 0x828f3764
	if ctx.cr[6].eq {
	pc = 0x828F3764; continue 'dispatch;
	}
	// 828F353C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F3540: 488B6449  bl 0x831a9988
	ctx.lr = 0x828F3544;
	sub_831A9988(ctx, base);
	// 828F3544: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 828F3548: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F354C: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 828F3550: 488B4BA9  bl 0x831a80f8
	ctx.lr = 0x828F3554;
	sub_831A80F8(ctx, base);
	// 828F3554: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F3558: 41820014  beq 0x828f356c
	if ctx.cr[0].eq {
	pc = 0x828F356C; continue 'dispatch;
	}
	// 828F355C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F3560: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828F3564: 4BFE697D  bl 0x828d9ee0
	ctx.lr = 0x828F3568;
	sub_828D9EE0(ctx, base);
	// 828F3568: 4BFFFFC4  b 0x828f352c
	pc = 0x828F352C; continue 'dispatch;
	// 828F356C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828F3570: 419A01F4  beq cr6, 0x828f3764
	if ctx.cr[6].eq {
	pc = 0x828F3764; continue 'dispatch;
	}
	// 828F3574: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F3578: 488B6411  bl 0x831a9988
	ctx.lr = 0x828F357C;
	sub_831A9988(ctx, base);
	// 828F357C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828F3580: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F3584: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 828F3588: 488B4B71  bl 0x831a80f8
	ctx.lr = 0x828F358C;
	sub_831A80F8(ctx, base);
	// 828F358C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F3590: 41820014  beq 0x828f35a4
	if ctx.cr[0].eq {
	pc = 0x828F35A4; continue 'dispatch;
	}
	// 828F3594: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F3598: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828F359C: 4BD6E15D  bl 0x826616f8
	ctx.lr = 0x828F35A0;
	sub_826616F8(ctx, base);
	// 828F35A0: 4BFFFF8C  b 0x828f352c
	pc = 0x828F352C; continue 'dispatch;
	// 828F35A4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828F35A8: 419A01BC  beq cr6, 0x828f3764
	if ctx.cr[6].eq {
	pc = 0x828F3764; continue 'dispatch;
	}
	// 828F35AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F35B0: 488B63D9  bl 0x831a9988
	ctx.lr = 0x828F35B4;
	sub_831A9988(ctx, base);
	// 828F35B4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828F35B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F35BC: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 828F35C0: 488B4B39  bl 0x831a80f8
	ctx.lr = 0x828F35C4;
	sub_831A80F8(ctx, base);
	// 828F35C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F35C8: 41820014  beq 0x828f35dc
	if ctx.cr[0].eq {
	pc = 0x828F35DC; continue 'dispatch;
	}
	// 828F35CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F35D0: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828F35D4: 4BEF79ED  bl 0x827eafc0
	ctx.lr = 0x828F35D8;
	sub_827EAFC0(ctx, base);
	// 828F35D8: 4BFFFF54  b 0x828f352c
	pc = 0x828F352C; continue 'dispatch;
	// 828F35DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828F35E0: 419A0184  beq cr6, 0x828f3764
	if ctx.cr[6].eq {
	pc = 0x828F3764; continue 'dispatch;
	}
	// 828F35E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F35E8: 488B63A1  bl 0x831a9988
	ctx.lr = 0x828F35EC;
	sub_831A9988(ctx, base);
	// 828F35EC: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828F35F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F35F4: 386B5CEC  addi r3, r11, 0x5cec
	ctx.r[3].s64 = ctx.r[11].s64 + 23788;
	// 828F35F8: 488B4B01  bl 0x831a80f8
	ctx.lr = 0x828F35FC;
	sub_831A80F8(ctx, base);
	// 828F35FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F3600: 41820014  beq 0x828f3614
	if ctx.cr[0].eq {
	pc = 0x828F3614; continue 'dispatch;
	}
	// 828F3604: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F3608: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828F360C: 4BFDB61D  bl 0x828cec28
	ctx.lr = 0x828F3610;
	sub_828CEC28(ctx, base);
	// 828F3610: 4BFFFF1C  b 0x828f352c
	pc = 0x828F352C; continue 'dispatch;
	// 828F3614: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828F3618: 419A014C  beq cr6, 0x828f3764
	if ctx.cr[6].eq {
	pc = 0x828F3764; continue 'dispatch;
	}
	// 828F361C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F3620: 488B6369  bl 0x831a9988
	ctx.lr = 0x828F3624;
	sub_831A9988(ctx, base);
	// 828F3624: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828F3628: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F362C: 386B5CC4  addi r3, r11, 0x5cc4
	ctx.r[3].s64 = ctx.r[11].s64 + 23748;
	// 828F3630: 488B4AC9  bl 0x831a80f8
	ctx.lr = 0x828F3634;
	sub_831A80F8(ctx, base);
	// 828F3634: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F3638: 41820014  beq 0x828f364c
	if ctx.cr[0].eq {
	pc = 0x828F364C; continue 'dispatch;
	}
	// 828F363C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F3640: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828F3644: 4BFDB3DD  bl 0x828cea20
	ctx.lr = 0x828F3648;
	sub_828CEA20(ctx, base);
	// 828F3648: 4BFFFEE4  b 0x828f352c
	pc = 0x828F352C; continue 'dispatch;
	// 828F364C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828F3650: 419A0114  beq cr6, 0x828f3764
	if ctx.cr[6].eq {
	pc = 0x828F3764; continue 'dispatch;
	}
	// 828F3654: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F3658: 488B6331  bl 0x831a9988
	ctx.lr = 0x828F365C;
	sub_831A9988(ctx, base);
	// 828F365C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 828F3660: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F3664: 386B3A18  addi r3, r11, 0x3a18
	ctx.r[3].s64 = ctx.r[11].s64 + 14872;
	// 828F3668: 488B4A91  bl 0x831a80f8
	ctx.lr = 0x828F366C;
	sub_831A80F8(ctx, base);
	// 828F366C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F3670: 41820014  beq 0x828f3684
	if ctx.cr[0].eq {
	pc = 0x828F3684; continue 'dispatch;
	}
	// 828F3674: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F3678: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828F367C: 4BFDB655  bl 0x828cecd0
	ctx.lr = 0x828F3680;
	sub_828CECD0(ctx, base);
	// 828F3680: 4BFFFEAC  b 0x828f352c
	pc = 0x828F352C; continue 'dispatch;
	// 828F3684: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828F3688: 419A00DC  beq cr6, 0x828f3764
	if ctx.cr[6].eq {
	pc = 0x828F3764; continue 'dispatch;
	}
	// 828F368C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F3690: 488B62F9  bl 0x831a9988
	ctx.lr = 0x828F3694;
	sub_831A9988(ctx, base);
	// 828F3694: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 828F3698: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F369C: 386B3A44  addi r3, r11, 0x3a44
	ctx.r[3].s64 = ctx.r[11].s64 + 14916;
	// 828F36A0: 488B4A59  bl 0x831a80f8
	ctx.lr = 0x828F36A4;
	sub_831A80F8(ctx, base);
	// 828F36A4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F36A8: 41820014  beq 0x828f36bc
	if ctx.cr[0].eq {
	pc = 0x828F36BC; continue 'dispatch;
	}
	// 828F36AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F36B0: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828F36B4: 4BFFF825  bl 0x828f2ed8
	ctx.lr = 0x828F36B8;
	sub_828F2ED8(ctx, base);
	// 828F36B8: 4BFFFE74  b 0x828f352c
	pc = 0x828F352C; continue 'dispatch;
	// 828F36BC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828F36C0: 419A00A4  beq cr6, 0x828f3764
	if ctx.cr[6].eq {
	pc = 0x828F3764; continue 'dispatch;
	}
	// 828F36C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F36C8: 488B62C1  bl 0x831a9988
	ctx.lr = 0x828F36CC;
	sub_831A9988(ctx, base);
	// 828F36CC: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 828F36D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F36D4: 386B1FA4  addi r3, r11, 0x1fa4
	ctx.r[3].s64 = ctx.r[11].s64 + 8100;
	// 828F36D8: 488B4A21  bl 0x831a80f8
	ctx.lr = 0x828F36DC;
	sub_831A80F8(ctx, base);
	// 828F36DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F36E0: 41820014  beq 0x828f36f4
	if ctx.cr[0].eq {
	pc = 0x828F36F4; continue 'dispatch;
	}
	// 828F36E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F36E8: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828F36EC: 4BFCA995  bl 0x828be080
	ctx.lr = 0x828F36F0;
	sub_828BE080(ctx, base);
	// 828F36F0: 4BFFFE3C  b 0x828f352c
	pc = 0x828F352C; continue 'dispatch;
	// 828F36F4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828F36F8: 419A006C  beq cr6, 0x828f3764
	if ctx.cr[6].eq {
	pc = 0x828F3764; continue 'dispatch;
	}
	// 828F36FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F3700: 488B6289  bl 0x831a9988
	ctx.lr = 0x828F3704;
	sub_831A9988(ctx, base);
	// 828F3704: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 828F3708: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F370C: 386B2380  addi r3, r11, 0x2380
	ctx.r[3].s64 = ctx.r[11].s64 + 9088;
	// 828F3710: 488B49E9  bl 0x831a80f8
	ctx.lr = 0x828F3714;
	sub_831A80F8(ctx, base);
	// 828F3714: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F3718: 41820014  beq 0x828f372c
	if ctx.cr[0].eq {
	pc = 0x828F372C; continue 'dispatch;
	}
	// 828F371C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F3720: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828F3724: 4BFDB62D  bl 0x828ced50
	ctx.lr = 0x828F3728;
	sub_828CED50(ctx, base);
	// 828F3728: 4BFFFE04  b 0x828f352c
	pc = 0x828F352C; continue 'dispatch;
	// 828F372C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828F3730: 419A0034  beq cr6, 0x828f3764
	if ctx.cr[6].eq {
	pc = 0x828F3764; continue 'dispatch;
	}
	// 828F3734: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F3738: 488B6251  bl 0x831a9988
	ctx.lr = 0x828F373C;
	sub_831A9988(ctx, base);
	// 828F373C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828F3740: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F3744: 386BE2F0  addi r3, r11, -0x1d10
	ctx.r[3].s64 = ctx.r[11].s64 + -7440;
	// 828F3748: 488B49B1  bl 0x831a80f8
	ctx.lr = 0x828F374C;
	sub_831A80F8(ctx, base);
	// 828F374C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F3750: 41820014  beq 0x828f3764
	if ctx.cr[0].eq {
	pc = 0x828F3764; continue 'dispatch;
	}
	// 828F3754: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F3758: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828F375C: 4BFFF3A5  bl 0x828f2b00
	ctx.lr = 0x828F3760;
	sub_828F2B00(ctx, base);
	// 828F3760: 4BFFFDCC  b 0x828f352c
	pc = 0x828F352C; continue 'dispatch;
	// 828F3764: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F3768: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F376C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F3770: 4801C321  bl 0x8290fa90
	ctx.lr = 0x828F3774;
	sub_8290FA90(ctx, base);
	// 828F3774: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F3778: 488B4A40  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F3780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F3780 size=204
    let mut pc: u32 = 0x828F3780;
    'dispatch: loop {
        match pc {
            0x828F3780 => {
    //   block [0x828F3780..0x828F384C)
	// 828F3780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F3784: 488B49E5  bl 0x831a8168
	ctx.lr = 0x828F3788;
	sub_831A8130(ctx, base);
	// 828F3788: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F378C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F3790: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828F3794: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828F3798: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 828F379C: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828F37A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F37A4: 38C0001F  li r6, 0x1f
	ctx.r[6].s64 = 31;
	// 828F37A8: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 828F37AC: 4801D36D  bl 0x82910b18
	ctx.lr = 0x828F37B0;
	sub_82910B18(ctx, base);
	// 828F37B0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F37B4: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828F37B8: 396B2EBC  addi r11, r11, 0x2ebc
	ctx.r[11].s64 = ctx.r[11].s64 + 11964;
	// 828F37BC: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828F37C0: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828F37C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F37C8: 394A2CFC  addi r10, r10, 0x2cfc
	ctx.r[10].s64 = ctx.r[10].s64 + 11516;
	// 828F37CC: 39292CE8  addi r9, r9, 0x2ce8
	ctx.r[9].s64 = ctx.r[9].s64 + 11496;
	// 828F37D0: 39682EA0  addi r11, r8, 0x2ea0
	ctx.r[11].s64 = ctx.r[8].s64 + 11936;
	// 828F37D4: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828F37D8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828F37DC: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828F37E0: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828F37E4: 387F0394  addi r3, r31, 0x394
	ctx.r[3].s64 = ctx.r[31].s64 + 916;
	// 828F37E8: 93DF0370  stw r30, 0x370(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(880 as u32), ctx.r[30].u32 ) };
	// 828F37EC: 93DF0374  stw r30, 0x374(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(884 as u32), ctx.r[30].u32 ) };
	// 828F37F0: 93DF0378  stw r30, 0x378(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(888 as u32), ctx.r[30].u32 ) };
	// 828F37F4: 93DF037C  stw r30, 0x37c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), ctx.r[30].u32 ) };
	// 828F37F8: 93DF0380  stw r30, 0x380(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(896 as u32), ctx.r[30].u32 ) };
	// 828F37FC: 93DF0384  stw r30, 0x384(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(900 as u32), ctx.r[30].u32 ) };
	// 828F3800: 93DF0388  stw r30, 0x388(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(904 as u32), ctx.r[30].u32 ) };
	// 828F3804: 93BF038C  stw r29, 0x38c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(908 as u32), ctx.r[29].u32 ) };
	// 828F3808: 939F0390  stw r28, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[28].u32 ) };
	// 828F380C: 480027BD  bl 0x828f5fc8
	ctx.lr = 0x828F3810;
	sub_828F5FC8(ctx, base);
	// 828F3810: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F3814: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F3818: 388B2F18  addi r4, r11, 0x2f18
	ctx.r[4].s64 = ctx.r[11].s64 + 12056;
	// 828F381C: 38A00094  li r5, 0x94
	ctx.r[5].s64 = 148;
	// 828F3820: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828F3824: 4B9CCBB5  bl 0x822c03d8
	ctx.lr = 0x828F3828;
	sub_822C03D8(ctx, base);
	// 828F3828: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F382C: 4182000C  beq 0x828f3838
	if ctx.cr[0].eq {
	pc = 0x828F3838; continue 'dispatch;
	}
	// 828F3830: 480027C1  bl 0x828f5ff0
	ctx.lr = 0x828F3834;
	sub_828F5FF0(ctx, base);
	// 828F3834: 48000008  b 0x828f383c
	pc = 0x828F383C; continue 'dispatch;
	// 828F3838: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F383C: 907F0388  stw r3, 0x388(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(904 as u32), ctx.r[3].u32 ) };
	// 828F3840: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F3844: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F3848: 488B4970  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F3850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F3850 size=76
    let mut pc: u32 = 0x828F3850;
    'dispatch: loop {
        match pc {
            0x828F3850 => {
    //   block [0x828F3850..0x828F389C)
	// 828F3850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F3854: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F3858: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F385C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F3860: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F3864: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F3868: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F386C: 4BFFF9D5  bl 0x828f3240
	ctx.lr = 0x828F3870;
	sub_828F3240(ctx, base);
	// 828F3870: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F3874: 4182000C  beq 0x828f3880
	if ctx.cr[0].eq {
	pc = 0x828F3880; continue 'dispatch;
	}
	// 828F3878: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F387C: 484FEB5D  bl 0x82df23d8
	ctx.lr = 0x828F3880;
	sub_82DF23D8(ctx, base);
	// 828F3880: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F3884: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F3888: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F388C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F3890: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F3894: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F3898: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F38A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F38A0 size=116
    let mut pc: u32 = 0x828F38A0;
    'dispatch: loop {
        match pc {
            0x828F38A0 => {
    //   block [0x828F38A0..0x828F3914)
	// 828F38A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F38A4: 488B48C1  bl 0x831a8164
	ctx.lr = 0x828F38A8;
	sub_831A8130(ctx, base);
	// 828F38A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F38AC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F38B0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828F38B4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F38B8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828F38BC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828F38C0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F38C4: 388B2F18  addi r4, r11, 0x2f18
	ctx.r[4].s64 = ctx.r[11].s64 + 12056;
	// 828F38C8: 38A000AF  li r5, 0xaf
	ctx.r[5].s64 = 175;
	// 828F38CC: 386003A0  li r3, 0x3a0
	ctx.r[3].s64 = 928;
	// 828F38D0: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 828F38D4: 484FEB15  bl 0x82df23e8
	ctx.lr = 0x828F38D8;
	sub_82DF23E8(ctx, base);
	// 828F38D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F38DC: 41820020  beq 0x828f38fc
	if ctx.cr[0].eq {
	pc = 0x828F38FC; continue 'dispatch;
	}
	// 828F38E0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828F38E4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828F38E8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828F38EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F38F0: 4BFFFE91  bl 0x828f3780
	ctx.lr = 0x828F38F4;
	sub_828F3780(ctx, base);
	// 828F38F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F38F8: 48000008  b 0x828f3900
	pc = 0x828F3900; continue 'dispatch;
	// 828F38FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F3900: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828F3904: 4BFFFAF5  bl 0x828f33f8
	ctx.lr = 0x828F3908;
	sub_828F33F8(ctx, base);
	// 828F3908: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828F390C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F3910: 488B48A4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F3918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F3918 size=144
    let mut pc: u32 = 0x828F3918;
    'dispatch: loop {
        match pc {
            0x828F3918 => {
    //   block [0x828F3918..0x828F39A8)
	// 828F3918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F391C: 488B4845  bl 0x831a8160
	ctx.lr = 0x828F3920;
	sub_831A8130(ctx, base);
	// 828F3920: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F3924: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F3928: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828F392C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F3930: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828F3934: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828F3938: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F393C: 388B2F18  addi r4, r11, 0x2f18
	ctx.r[4].s64 = ctx.r[11].s64 + 12056;
	// 828F3940: 38A000B5  li r5, 0xb5
	ctx.r[5].s64 = 181;
	// 828F3944: 386003A0  li r3, 0x3a0
	ctx.r[3].s64 = 928;
	// 828F3948: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 828F394C: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 828F3950: 484FEA99  bl 0x82df23e8
	ctx.lr = 0x828F3954;
	sub_82DF23E8(ctx, base);
	// 828F3954: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F3958: 41820020  beq 0x828f3978
	if ctx.cr[0].eq {
	pc = 0x828F3978; continue 'dispatch;
	}
	// 828F395C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828F3960: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828F3964: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828F3968: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F396C: 4BFFFE15  bl 0x828f3780
	ctx.lr = 0x828F3970;
	sub_828F3780(ctx, base);
	// 828F3970: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F3974: 48000008  b 0x828f397c
	pc = 0x828F397C; continue 'dispatch;
	// 828F3978: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F397C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3980: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828F3984: 91640394  stw r11, 0x394(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(916 as u32), ctx.r[11].u32 ) };
	// 828F3988: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F398C: 91640398  stw r11, 0x398(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(920 as u32), ctx.r[11].u32 ) };
	// 828F3990: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F3994: 9164039C  stw r11, 0x39c(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(924 as u32), ctx.r[11].u32 ) };
	// 828F3998: 4BFFFA61  bl 0x828f33f8
	ctx.lr = 0x828F399C;
	sub_828F33F8(ctx, base);
	// 828F399C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828F39A0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828F39A4: 488B480C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F39A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F39A8 size=212
    let mut pc: u32 = 0x828F39A8;
    'dispatch: loop {
        match pc {
            0x828F39A8 => {
    //   block [0x828F39A8..0x828F3A7C)
	// 828F39A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F39AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F39B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F39B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F39B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F39BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F39C0: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 828F39C4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F39C8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F39CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F39D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F39D4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F39D8: 419A0024  beq cr6, 0x828f39fc
	if ctx.cr[6].eq {
	pc = 0x828F39FC; continue 'dispatch;
	}
	// 828F39DC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828F39E0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828F39E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F39E8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828F39EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828F39F0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F39F4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F39F8: 4082FFE8  bne 0x828f39e0
	if !ctx.cr[0].eq {
	pc = 0x828F39E0; continue 'dispatch;
	}
	// 828F39FC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828F3A00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F3A04: 386BAAB8  addi r3, r11, -0x5548
	ctx.r[3].s64 = ctx.r[11].s64 + -21832;
	// 828F3A08: 48002D09  bl 0x828f6710
	ctx.lr = 0x828F3A0C;
	sub_828F6710(ctx, base);
	// 828F3A0C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3A10: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3A14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3A18: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F3A1C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F3A20: 419A0024  beq cr6, 0x828f3a44
	if ctx.cr[6].eq {
	pc = 0x828F3A44; continue 'dispatch;
	}
	// 828F3A24: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828F3A28: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828F3A2C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F3A30: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828F3A34: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828F3A38: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F3A3C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F3A40: 4082FFE8  bne 0x828f3a28
	if !ctx.cr[0].eq {
	pc = 0x828F3A28; continue 'dispatch;
	}
	// 828F3A44: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F3A48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F3A4C: 386BAC10  addi r3, r11, -0x53f0
	ctx.r[3].s64 = ctx.r[11].s64 + -21488;
	// 828F3A50: 48021671  bl 0x829150c0
	ctx.lr = 0x828F3A54;
	sub_829150C0(ctx, base);
	// 828F3A54: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3A58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F3A5C: 419A0008  beq cr6, 0x828f3a64
	if ctx.cr[6].eq {
	pc = 0x828F3A64; continue 'dispatch;
	}
	// 828F3A60: 4B9CCE31  bl 0x822c0890
	ctx.lr = 0x828F3A64;
	sub_822C0890(ctx, base);
	// 828F3A64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F3A68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F3A6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F3A70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F3A74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F3A78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F3A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F3A80 size=452
    let mut pc: u32 = 0x828F3A80;
    'dispatch: loop {
        match pc {
            0x828F3A80 => {
    //   block [0x828F3A80..0x828F3C44)
	// 828F3A80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F3A84: 488B46E1  bl 0x831a8164
	ctx.lr = 0x828F3A88;
	sub_831A8130(ctx, base);
	// 828F3A88: 9421FD70  stwu r1, -0x290(r1)
	ea = ctx.r[1].u32.wrapping_add(-656 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F3A8C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F3A90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F3A94: 3B9E00FC  addi r28, r30, 0xfc
	ctx.r[28].s64 = ctx.r[30].s64 + 252;
	// 828F3A98: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F3A9C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828F3AA0: 48566A81  bl 0x82e5a520
	ctx.lr = 0x828F3AA4;
	sub_82E5A520(ctx, base);
	// 828F3AA4: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F3AA8: 83630000  lwz r27, 0(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3AAC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828F3AB0: 419A0024  beq cr6, 0x828f3ad4
	if ctx.cr[6].eq {
	pc = 0x828F3AD4; continue 'dispatch;
	}
	// 828F3AB4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 828F3AB8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828F3ABC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F3AC0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828F3AC4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828F3AC8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F3ACC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F3AD0: 4082FFE8  bne 0x828f3ab8
	if !ctx.cr[0].eq {
	pc = 0x828F3AB8; continue 'dispatch;
	}
	// 828F3AD4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828F3AD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F3ADC: 419A0008  beq cr6, 0x828f3ae4
	if ctx.cr[6].eq {
	pc = 0x828F3AE4; continue 'dispatch;
	}
	// 828F3AE0: 4B9CCDB1  bl 0x822c0890
	ctx.lr = 0x828F3AE4;
	sub_822C0890(ctx, base);
	// 828F3AE4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F3AE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F3AEC: 388B2F98  addi r4, r11, 0x2f98
	ctx.r[4].s64 = ctx.r[11].s64 + 12184;
	// 828F3AF0: 484FFF19  bl 0x82df3a08
	ctx.lr = 0x828F3AF4;
	sub_82DF3A08(ctx, base);
	// 828F3AF4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828F3AF8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F3AFC: 3B8B7688  addi r28, r11, 0x7688
	ctx.r[28].s64 = ctx.r[11].s64 + 30344;
	// 828F3B00: 48566BD1  bl 0x82e5a6d0
	ctx.lr = 0x828F3B04;
	sub_82E5A6D0(ctx, base);
	// 828F3B04: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 828F3B08: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F3B0C: 388B5E50  addi r4, r11, 0x5e50
	ctx.r[4].s64 = ctx.r[11].s64 + 24144;
	// 828F3B10: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3B14: 4850018D  bl 0x82df3ca0
	ctx.lr = 0x828F3B18;
	sub_82DF3CA0(ctx, base);
	// 828F3B18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F3B1C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F3B20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F3B24: 485001D5  bl 0x82df3cf8
	ctx.lr = 0x828F3B28;
	sub_82DF3CF8(ctx, base);
	// 828F3B28: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F3B2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F3B30: 484FFD81  bl 0x82df38b0
	ctx.lr = 0x828F3B34;
	sub_82DF38B0(ctx, base);
	// 828F3B34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F3B38: 484FF8F1  bl 0x82df3428
	ctx.lr = 0x828F3B3C;
	sub_82DF3428(ctx, base);
	// 828F3B3C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3B40: 484FF8E9  bl 0x82df3428
	ctx.lr = 0x828F3B44;
	sub_82DF3428(ctx, base);
	// 828F3B44: C03B0060  lfs f1, 0x60(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(96 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F3B48: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 828F3B4C: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 828F3B50: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F3B54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F3B58: 388B2F88  addi r4, r11, 0x2f88
	ctx.r[4].s64 = ctx.r[11].s64 + 12168;
	// 828F3B5C: 488B4F7D  bl 0x831a8ad8
	ctx.lr = 0x828F3B60;
	sub_831A8AD8(ctx, base);
	// 828F3B60: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828F3B64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F3B68: 484FFEA1  bl 0x82df3a08
	ctx.lr = 0x828F3B6C;
	sub_82DF3A08(ctx, base);
	// 828F3B6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F3B70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F3B74: 484FFD3D  bl 0x82df38b0
	ctx.lr = 0x828F3B78;
	sub_82DF38B0(ctx, base);
	// 828F3B78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F3B7C: 484FF8AD  bl 0x82df3428
	ctx.lr = 0x828F3B80;
	sub_82DF3428(ctx, base);
	// 828F3B80: 807E01CC  lwz r3, 0x1cc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(460 as u32) ) } as u64;
	// 828F3B84: 4BEF6725  bl 0x827ea2a8
	ctx.lr = 0x828F3B88;
	sub_827EA2A8(ctx, base);
	// 828F3B88: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F3B8C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F3B90: 388B8FA0  addi r4, r11, -0x7060
	ctx.r[4].s64 = ctx.r[11].s64 + -28768;
	// 828F3B94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F3B98: 48500109  bl 0x82df3ca0
	ctx.lr = 0x828F3B9C;
	sub_82DF3CA0(ctx, base);
	// 828F3B9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F3BA0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3BA4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F3BA8: 48500151  bl 0x82df3cf8
	ctx.lr = 0x828F3BAC;
	sub_82DF3CF8(ctx, base);
	// 828F3BAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F3BB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F3BB4: 484FFCFD  bl 0x82df38b0
	ctx.lr = 0x828F3BB8;
	sub_82DF38B0(ctx, base);
	// 828F3BB8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3BBC: 484FF86D  bl 0x82df3428
	ctx.lr = 0x828F3BC0;
	sub_82DF3428(ctx, base);
	// 828F3BC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F3BC4: 484FF865  bl 0x82df3428
	ctx.lr = 0x828F3BC8;
	sub_82DF3428(ctx, base);
	// 828F3BC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F3BCC: 4811FAB5  bl 0x82a13680
	ctx.lr = 0x828F3BD0;
	sub_82A13680(ctx, base);
	// 828F3BD0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F3BD4: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828F3BD8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F3BDC: 388A8F80  addi r4, r10, -0x7080
	ctx.r[4].s64 = ctx.r[10].s64 + -28800;
	// 828F3BE0: C06B0008  lfs f3, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828F3BE4: C04B0004  lfs f2, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828F3BE8: C02B0000  lfs f1, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F3BEC: D8610030  stfd f3, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.f[3].u64 ) };
	// 828F3BF0: E8E10030  ld r7, 0x30(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(48 as u32) ) };
	// 828F3BF4: D8410028  stfd f2, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[2].u64 ) };
	// 828F3BF8: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 828F3BFC: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 828F3C00: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 828F3C04: 488B4ED5  bl 0x831a8ad8
	ctx.lr = 0x828F3C08;
	sub_831A8AD8(ctx, base);
	// 828F3C08: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828F3C0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F3C10: 484FFDF9  bl 0x82df3a08
	ctx.lr = 0x828F3C14;
	sub_82DF3A08(ctx, base);
	// 828F3C14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F3C18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F3C1C: 484FFC95  bl 0x82df38b0
	ctx.lr = 0x828F3C20;
	sub_82DF38B0(ctx, base);
	// 828F3C20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F3C24: 484FF805  bl 0x82df3428
	ctx.lr = 0x828F3C28;
	sub_82DF3428(ctx, base);
	// 828F3C28: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828F3C2C: 419A000C  beq cr6, 0x828f3c38
	if ctx.cr[6].eq {
	pc = 0x828F3C38; continue 'dispatch;
	}
	// 828F3C30: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F3C34: 4B9CCC5D  bl 0x822c0890
	ctx.lr = 0x828F3C38;
	sub_822C0890(ctx, base);
	// 828F3C38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F3C3C: 38210290  addi r1, r1, 0x290
	ctx.r[1].s64 = ctx.r[1].s64 + 656;
	// 828F3C40: 488B4574  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F3C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F3C48 size=92
    let mut pc: u32 = 0x828F3C48;
    'dispatch: loop {
        match pc {
            0x828F3C48 => {
    //   block [0x828F3C48..0x828F3CA4)
	// 828F3C48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F3C4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F3C50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F3C54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F3C58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F3C5C: 2F050007  cmpwi cr6, r5, 7
	ctx.cr[6].compare_i32(ctx.r[5].s32, 7, &mut ctx.xer);
	// 828F3C60: 419A0014  beq cr6, 0x828f3c74
	if ctx.cr[6].eq {
	pc = 0x828F3C74; continue 'dispatch;
	}
	// 828F3C64: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F3C68: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F3C6C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828F3C70: 48000020  b 0x828f3c90
	pc = 0x828F3C90; continue 'dispatch;
	// 828F3C74: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3C78: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828F3C7C: 38AA2FA8  addi r5, r10, 0x2fa8
	ctx.r[5].s64 = ctx.r[10].s64 + 12200;
	// 828F3C80: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828F3C84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F3C88: 4E800421  bctrl
	ctx.lr = 0x828F3C8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F3C8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F3C90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F3C94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F3C98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F3C9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F3CA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F3CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F3CA8 size=112
    let mut pc: u32 = 0x828F3CA8;
    'dispatch: loop {
        match pc {
            0x828F3CA8 => {
    //   block [0x828F3CA8..0x828F3D18)
	// 828F3CA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F3CAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F3CB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F3CB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F3CB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F3CBC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828F3CC0: 419A0028  beq cr6, 0x828f3ce8
	if ctx.cr[6].eq {
	pc = 0x828F3CE8; continue 'dispatch;
	}
	// 828F3CC4: 2F050002  cmpwi cr6, r5, 2
	ctx.cr[6].compare_i32(ctx.r[5].s32, 2, &mut ctx.xer);
	// 828F3CC8: 419A0014  beq cr6, 0x828f3cdc
	if ctx.cr[6].eq {
	pc = 0x828F3CDC; continue 'dispatch;
	}
	// 828F3CCC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F3CD0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F3CD4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828F3CD8: 4800002C  b 0x828f3d04
	pc = 0x828F3D04; continue 'dispatch;
	// 828F3CDC: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828F3CE0: 38AA2FCC  addi r5, r10, 0x2fcc
	ctx.r[5].s64 = ctx.r[10].s64 + 12236;
	// 828F3CE4: 4800000C  b 0x828f3cf0
	pc = 0x828F3CF0; continue 'dispatch;
	// 828F3CE8: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828F3CEC: 38AA2FB8  addi r5, r10, 0x2fb8
	ctx.r[5].s64 = ctx.r[10].s64 + 12216;
	// 828F3CF0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3CF4: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828F3CF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F3CFC: 4E800421  bctrl
	ctx.lr = 0x828F3D00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F3D00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F3D04: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F3D08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F3D0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F3D10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F3D14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F3D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F3D18 size=112
    let mut pc: u32 = 0x828F3D18;
    'dispatch: loop {
        match pc {
            0x828F3D18 => {
    //   block [0x828F3D18..0x828F3D88)
	// 828F3D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F3D1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F3D20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F3D24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F3D28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F3D2C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F3D30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F3D34: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828F3D38: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3D3C: 4BFFF32D  bl 0x828f3068
	ctx.lr = 0x828F3D40;
	sub_828F3068(ctx, base);
	// 828F3D40: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828F3D44: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F3D48: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3D4C: 4B9CC2B5  bl 0x822c0000
	ctx.lr = 0x828F3D50;
	sub_822C0000(ctx, base);
	// 828F3D50: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F3D54: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F3D58: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F3D5C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F3D60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F3D64: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F3D68: 419A0008  beq cr6, 0x828f3d70
	if ctx.cr[6].eq {
	pc = 0x828F3D70; continue 'dispatch;
	}
	// 828F3D6C: 4B9CCB25  bl 0x822c0890
	ctx.lr = 0x828F3D70;
	sub_822C0890(ctx, base);
	// 828F3D70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F3D74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F3D78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F3D7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F3D80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F3D84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F3D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F3D88 size=112
    let mut pc: u32 = 0x828F3D88;
    'dispatch: loop {
        match pc {
            0x828F3D88 => {
    //   block [0x828F3D88..0x828F3DF8)
	// 828F3D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F3D8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F3D90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F3D94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F3D98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F3D9C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F3DA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F3DA4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828F3DA8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3DAC: 4BFFF385  bl 0x828f3130
	ctx.lr = 0x828F3DB0;
	sub_828F3130(ctx, base);
	// 828F3DB0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828F3DB4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F3DB8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3DBC: 4B9CC245  bl 0x822c0000
	ctx.lr = 0x828F3DC0;
	sub_822C0000(ctx, base);
	// 828F3DC0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F3DC4: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F3DC8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F3DCC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F3DD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F3DD4: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F3DD8: 419A0008  beq cr6, 0x828f3de0
	if ctx.cr[6].eq {
	pc = 0x828F3DE0; continue 'dispatch;
	}
	// 828F3DDC: 4B9CCAB5  bl 0x822c0890
	ctx.lr = 0x828F3DE0;
	sub_822C0890(ctx, base);
	// 828F3DE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F3DE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F3DE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F3DEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F3DF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F3DF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F3DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F3DF8 size=180
    let mut pc: u32 = 0x828F3DF8;
    'dispatch: loop {
        match pc {
            0x828F3DF8 => {
    //   block [0x828F3DF8..0x828F3EAC)
	// 828F3DF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F3DFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F3E00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F3E04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F3E08: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F3E0C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F3E10: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F3E14: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F3E18: 419A007C  beq cr6, 0x828f3e94
	if ctx.cr[6].eq {
	pc = 0x828F3E94; continue 'dispatch;
	}
	// 828F3E1C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F3E20: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3E24: 388BEC9C  addi r4, r11, -0x1364
	ctx.r[4].s64 = ctx.r[11].s64 + -4964;
	// 828F3E28: 484FFBE1  bl 0x82df3a08
	ctx.lr = 0x828F3E2C;
	sub_82DF3A08(ctx, base);
	// 828F3E2C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F3E30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F3E34: 388BEC90  addi r4, r11, -0x1370
	ctx.r[4].s64 = ctx.r[11].s64 + -4976;
	// 828F3E38: 484FFBD1  bl 0x82df3a08
	ctx.lr = 0x828F3E3C;
	sub_82DF3A08(ctx, base);
	// 828F3E3C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828F3E40: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F3E44: 80BE0388  lwz r5, 0x388(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(904 as u32) ) } as u64;
	// 828F3E48: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828F3E4C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828F3E50: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F3E54: C06B9528  lfs f3, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828F3E58: C04A08A8  lfs f2, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828F3E5C: C0299534  lfs f1, -0x6acc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F3E60: 4BCB9C59  bl 0x825adab8
	ctx.lr = 0x828F3E64;
	sub_825ADAB8(ctx, base);
	// 828F3E64: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F3E68: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F3E6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F3E70: 4BCAD7E1  bl 0x825a1650
	ctx.lr = 0x828F3E74;
	sub_825A1650(ctx, base);
	// 828F3E74: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 828F3E78: 484FF5B1  bl 0x82df3428
	ctx.lr = 0x828F3E7C;
	sub_82DF3428(ctx, base);
	// 828F3E7C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828F3E80: 4B9D4E39  bl 0x822c8cb8
	ctx.lr = 0x828F3E84;
	sub_822C8CB8(ctx, base);
	// 828F3E84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F3E88: 484FF5A1  bl 0x82df3428
	ctx.lr = 0x828F3E8C;
	sub_82DF3428(ctx, base);
	// 828F3E8C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F3E90: 484FF599  bl 0x82df3428
	ctx.lr = 0x828F3E94;
	sub_82DF3428(ctx, base);
	// 828F3E94: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828F3E98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F3E9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F3EA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F3EA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F3EA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F3EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F3EB0 size=380
    let mut pc: u32 = 0x828F3EB0;
    'dispatch: loop {
        match pc {
            0x828F3EB0 => {
    //   block [0x828F3EB0..0x828F402C)
	// 828F3EB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F3EB4: 488B42A5  bl 0x831a8158
	ctx.lr = 0x828F3EB8;
	sub_831A8130(ctx, base);
	// 828F3EB8: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 828F3EBC: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F3EC0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3EC4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 828F3EC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F3ECC: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 828F3ED0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F3ED4: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 828F3ED8: 409A0008  bne cr6, 0x828f3ee0
	if !ctx.cr[6].eq {
	pc = 0x828F3EE0; continue 'dispatch;
	}
	// 828F3EDC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828F3EE0: 4BC341A9  bl 0x82528088
	ctx.lr = 0x828F3EE4;
	sub_82528088(ctx, base);
	// 828F3EE4: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828F3EE8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828F3EEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F3EF0: 4BEF8271  bl 0x827ec160
	ctx.lr = 0x828F3EF4;
	sub_827EC160(ctx, base);
	// 828F3EF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3EF8: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 828F3EFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F3F00: 4E800421  bctrl
	ctx.lr = 0x828F3F04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F3F04: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 828F3F08: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828F3F0C: C3E30000  lfs f31, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828F3F10: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828F3F14: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828F3F18: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F3F1C: 817C6810  lwz r11, 0x6810(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26640 as u32) ) } as u64;
	// 828F3F20: 38882F18  addi r4, r8, 0x2f18
	ctx.r[4].s64 = ctx.r[8].s64 + 12056;
	// 828F3F24: C00A2C9C  lfs f0, 0x2c9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11420 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F3F28: 38A00311  li r5, 0x311
	ctx.r[5].s64 = 785;
	// 828F3F2C: EDBF002A  fadds f13, f31, f0
	ctx.f[13].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 828F3F30: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F3F34: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828F3F38: 38600200  li r3, 0x200
	ctx.r[3].s64 = 512;
	// 828F3F3C: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828F3F40: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828F3F44: 917F0258  stw r11, 0x258(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(600 as u32), ctx.r[11].u32 ) };
	// 828F3F48: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828F3F4C: 484FE49D  bl 0x82df23e8
	ctx.lr = 0x828F3F50;
	sub_82DF23E8(ctx, base);
	// 828F3F50: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828F3F54: 41820080  beq 0x828f3fd4
	if ctx.cr[0].eq {
	pc = 0x828F3FD4; continue 'dispatch;
	}
	// 828F3F58: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F3F5C: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 828F3F60: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828F3F64: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 828F3F68: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828F3F6C: 485AC7C5  bl 0x82ea0730
	ctx.lr = 0x828F3F70;
	sub_82EA0730(ctx, base);
	// 828F3F70: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 828F3F74: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F3F78: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 828F3F7C: 48626275  bl 0x82f1a1f0
	ctx.lr = 0x828F3F80;
	sub_82F1A1F0(ctx, base);
	// 828F3F80: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828F3F84: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828F3F88: 839C6810  lwz r28, 0x6810(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26640 as u32) ) } as u64;
	// 828F3F8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F3F90: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F3F94: 3BCBBA80  addi r30, r11, -0x4580
	ctx.r[30].s64 = ctx.r[11].s64 + -17792;
	// 828F3F98: 3B400003  li r26, 3
	ctx.r[26].s64 = 3;
	// 828F3F9C: 3B210060  addi r25, r1, 0x60
	ctx.r[25].s64 = ctx.r[1].s64 + 96;
	// 828F3FA0: 3B010050  addi r24, r1, 0x50
	ctx.r[24].s64 = ctx.r[1].s64 + 80;
	// 828F3FA4: 4BC1B575  bl 0x8250f518
	ctx.lr = 0x828F3FA8;
	sub_8250F518(ctx, base);
	// 828F3FA8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F3FAC: 389F0038  addi r4, r31, 0x38
	ctx.r[4].s64 = ctx.r[31].s64 + 56;
	// 828F3FB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F3FB4: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 828F3FB8: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 828F3FBC: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 828F3FC0: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 828F3FC4: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 828F3FC8: 481F3319  bl 0x82ae72e0
	ctx.lr = 0x828F3FCC;
	sub_82AE72E0(ctx, base);
	// 828F3FCC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F3FD0: 48000008  b 0x828f3fd8
	pc = 0x828F3FD8; continue 'dispatch;
	// 828F3FD4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F3FD8: 3BFF01E4  addi r31, r31, 0x1e4
	ctx.r[31].s64 = ctx.r[31].s64 + 484;
	// 828F3FDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F3FE0: 4BA80279  bl 0x82374258
	ctx.lr = 0x828F3FE4;
	sub_82374258(ctx, base);
	// 828F3FE4: 574B07BD  rlwinm. r11, r26, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F3FE8: 41820010  beq 0x828f3ff8
	if ctx.cr[0].eq {
	pc = 0x828F3FF8; continue 'dispatch;
	}
	// 828F3FEC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F3FF0: 575A07FA  rlwinm r26, r26, 0, 0x1f, 0x1d
	ctx.r[26].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 828F3FF4: 484FDC9D  bl 0x82df1c90
	ctx.lr = 0x828F3FF8;
	sub_82DF1C90(ctx, base);
	// 828F3FF8: 574B07FF  clrlwi. r11, r26, 0x1f
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F3FFC: 41820014  beq 0x828f4010
	if ctx.cr[0].eq {
	pc = 0x828F4010; continue 'dispatch;
	}
	// 828F4000: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F4004: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F4008: 419A0008  beq cr6, 0x828f4010
	if ctx.cr[6].eq {
	pc = 0x828F4010; continue 'dispatch;
	}
	// 828F400C: 4B9F425D  bl 0x822e8268
	ctx.lr = 0x828F4010;
	sub_822E8268(ctx, base);
	// 828F4010: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F4014: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4018: C02BEE7C  lfs f1, -0x1184(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4484 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F401C: 481EF335  bl 0x82ae3350
	ctx.lr = 0x828F4020;
	sub_82AE3350(ctx, base);
	// 828F4020: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828F4024: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 828F4028: 488B4180  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F4030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F4030 size=740
    let mut pc: u32 = 0x828F4030;
    'dispatch: loop {
        match pc {
            0x828F4030 => {
    //   block [0x828F4030..0x828F4314)
	// 828F4030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F4034: 488B4131  bl 0x831a8164
	ctx.lr = 0x828F4038;
	sub_831A8130(ctx, base);
	// 828F4038: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828F403C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F4040: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828F4044: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828F4048: 807B0370  lwz r3, 0x370(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(880 as u32) ) } as u64;
	// 828F404C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F4050: 419A02B8  beq cr6, 0x828f4308
	if ctx.cr[6].eq {
	pc = 0x828F4308; continue 'dispatch;
	}
	// 828F4054: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F4058: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828F405C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F4060: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4064: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F4068: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F406C: 4E800421  bctrl
	ctx.lr = 0x828F4070;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F4070: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F4074: 41820294  beq 0x828f4308
	if ctx.cr[0].eq {
	pc = 0x828F4308; continue 'dispatch;
	}
	// 828F4078: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F407C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4080: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828F4084: 484FF985  bl 0x82df3a08
	ctx.lr = 0x828F4088;
	sub_82DF3A08(ctx, base);
	// 828F4088: 3BDB010C  addi r30, r27, 0x10c
	ctx.r[30].s64 = ctx.r[27].s64 + 268;
	// 828F408C: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 828F4090: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F4094: 4856663D  bl 0x82e5a6d0
	ctx.lr = 0x828F4098;
	sub_82E5A6D0(ctx, base);
	// 828F4098: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F409C: 484FF205  bl 0x82df32a0
	ctx.lr = 0x828F40A0;
	sub_82DF32A0(ctx, base);
	// 828F40A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F40A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F40A8: 484FF381  bl 0x82df3428
	ctx.lr = 0x828F40AC;
	sub_82DF3428(ctx, base);
	// 828F40AC: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F40B0: 41820258  beq 0x828f4308
	if ctx.cr[0].eq {
	pc = 0x828F4308; continue 'dispatch;
	}
	// 828F40B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F40B8: 83FB0378  lwz r31, 0x378(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(888 as u32) ) } as u64;
	// 828F40BC: 48566615  bl 0x82e5a6d0
	ctx.lr = 0x828F40C0;
	sub_82E5A6D0(ctx, base);
	// 828F40C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F40C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F40C8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F40CC: 4802DFC5  bl 0x82922090
	ctx.lr = 0x828F40D0;
	sub_82922090(ctx, base);
	// 828F40D0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828F40D4: 41820234  beq 0x828f4308
	if ctx.cr[0].eq {
	pc = 0x828F4308; continue 'dispatch;
	}
	// 828F40D8: 3BBB0010  addi r29, r27, 0x10
	ctx.r[29].s64 = ctx.r[27].s64 + 16;
	// 828F40DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F40E0: 4BEF8081  bl 0x827ec160
	ctx.lr = 0x828F40E4;
	sub_827EC160(ctx, base);
	// 828F40E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F40E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F40EC: 48022CAD  bl 0x82916d98
	ctx.lr = 0x828F40F0;
	sub_82916D98(ctx, base);
	// 828F40F0: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	// 828F40F4: 80E10060  lwz r7, 0x60(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828F40F8: 394000D0  li r10, 0xd0
	ctx.r[10].s64 = 208;
	// 828F40FC: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 828F4100: 390000E0  li r8, 0xe0
	ctx.r[8].s64 = 224;
	// 828F4104: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F4108: 13FC58C7  vcmpequd (lvx128) v31, v28, v11
	tmp.u32 = ctx.r[28].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828F410C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F4318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F4318 size=400
    let mut pc: u32 = 0x828F4318;
    'dispatch: loop {
        match pc {
            0x828F4318 => {
    //   block [0x828F4318..0x828F44A8)
	// 828F4318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F431C: 488B3E49  bl 0x831a8164
	ctx.lr = 0x828F4320;
	sub_831A8130(ctx, base);
	// 828F4320: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F4324: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F4328: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828F432C: 48015F15  bl 0x8290a240
	ctx.lr = 0x828F4330;
	sub_8290A240(ctx, base);
	// 828F4330: 807F0360  lwz r3, 0x360(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(864 as u32) ) } as u64;
	// 828F4334: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F4338: 419A0168  beq cr6, 0x828f44a0
	if ctx.cr[6].eq {
	pc = 0x828F44A0; continue 'dispatch;
	}
	// 828F433C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F4340: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828F4344: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828F4348: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828F434C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4350: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828F4354: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F4358: 4E800421  bctrl
	ctx.lr = 0x828F435C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F435C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F4360: 41820140  beq 0x828f44a0
	if ctx.cr[0].eq {
	pc = 0x828F44A0; continue 'dispatch;
	}
	// 828F4364: 897C001C  lbz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 828F4368: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F436C: 41820018  beq 0x828f4384
	if ctx.cr[0].eq {
	pc = 0x828F4384; continue 'dispatch;
	}
	// 828F4370: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 828F4374: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 828F4378: 13FC58C7  vcmpequd (lvx128) v31, v28, v11
	tmp.u32 = ctx.r[28].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F44A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F44A8 size=608
    let mut pc: u32 = 0x828F44A8;
    'dispatch: loop {
        match pc {
            0x828F44A8 => {
    //   block [0x828F44A8..0x828F4708)
	// 828F44A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F44AC: 488B3CB1  bl 0x831a815c
	ctx.lr = 0x828F44B0;
	sub_831A8130(ctx, base);
	// 828F44B0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F44B4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F44B8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828F44BC: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828F44C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F44C4: 388B2FF0  addi r4, r11, 0x2ff0
	ctx.r[4].s64 = ctx.r[11].s64 + 12272;
	// 828F44C8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828F44CC: 484FF53D  bl 0x82df3a08
	ctx.lr = 0x828F44D0;
	sub_82DF3A08(ctx, base);
	// 828F44D0: 3BDC010C  addi r30, r28, 0x10c
	ctx.r[30].s64 = ctx.r[28].s64 + 268;
	// 828F44D4: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 828F44D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F44DC: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828F44E0: 485661F1  bl 0x82e5a6d0
	ctx.lr = 0x828F44E4;
	sub_82E5A6D0(ctx, base);
	// 828F44E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F44E8: 484FEE21  bl 0x82df3308
	ctx.lr = 0x828F44EC;
	sub_82DF3308(ctx, base);
	// 828F44EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F44F0: 408200C8  bne 0x828f45b8
	if !ctx.cr[0].eq {
	pc = 0x828F45B8; continue 'dispatch;
	}
	// 828F44F4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F44F8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828F44FC: 3BAB2FE8  addi r29, r11, 0x2fe8
	ctx.r[29].s64 = ctx.r[11].s64 + 12264;
	// 828F4500: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F4504: 484FF505  bl 0x82df3a08
	ctx.lr = 0x828F4508;
	sub_82DF3A08(ctx, base);
	// 828F4508: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F450C: 3BE00003  li r31, 3
	ctx.r[31].s64 = 3;
	// 828F4510: 3B21005C  addi r25, r1, 0x5c
	ctx.r[25].s64 = ctx.r[1].s64 + 92;
	// 828F4514: 485661BD  bl 0x82e5a6d0
	ctx.lr = 0x828F4518;
	sub_82E5A6D0(ctx, base);
	// 828F4518: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828F451C: 484FEDED  bl 0x82df3308
	ctx.lr = 0x828F4520;
	sub_82DF3308(ctx, base);
	// 828F4520: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F4524: 40820094  bne 0x828f45b8
	if !ctx.cr[0].eq {
	pc = 0x828F45B8; continue 'dispatch;
	}
	// 828F4528: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F452C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F4530: 388B953C  addi r4, r11, -0x6ac4
	ctx.r[4].s64 = ctx.r[11].s64 + -27332;
	// 828F4534: 484FF4D5  bl 0x82df3a08
	ctx.lr = 0x828F4538;
	sub_82DF3A08(ctx, base);
	// 828F4538: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F453C: 3BE00007  li r31, 7
	ctx.r[31].s64 = 7;
	// 828F4540: 3B210058  addi r25, r1, 0x58
	ctx.r[25].s64 = ctx.r[1].s64 + 88;
	// 828F4544: 4856618D  bl 0x82e5a6d0
	ctx.lr = 0x828F4548;
	sub_82E5A6D0(ctx, base);
	// 828F4548: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828F454C: 484FEDBD  bl 0x82df3308
	ctx.lr = 0x828F4550;
	sub_82DF3308(ctx, base);
	// 828F4550: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F4554: 40820064  bne 0x828f45b8
	if !ctx.cr[0].eq {
	pc = 0x828F45B8; continue 'dispatch;
	}
	// 828F4558: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F455C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F4560: 388B2FDC  addi r4, r11, 0x2fdc
	ctx.r[4].s64 = ctx.r[11].s64 + 12252;
	// 828F4564: 484FF4A5  bl 0x82df3a08
	ctx.lr = 0x828F4568;
	sub_82DF3A08(ctx, base);
	// 828F4568: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F456C: 3BE0000F  li r31, 0xf
	ctx.r[31].s64 = 15;
	// 828F4570: 3B210054  addi r25, r1, 0x54
	ctx.r[25].s64 = ctx.r[1].s64 + 84;
	// 828F4574: 4856615D  bl 0x82e5a6d0
	ctx.lr = 0x828F4578;
	sub_82E5A6D0(ctx, base);
	// 828F4578: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828F457C: 484FED8D  bl 0x82df3308
	ctx.lr = 0x828F4580;
	sub_82DF3308(ctx, base);
	// 828F4580: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F4584: 40820034  bne 0x828f45b8
	if !ctx.cr[0].eq {
	pc = 0x828F45B8; continue 'dispatch;
	}
	// 828F4588: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F458C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4590: 484FF479  bl 0x82df3a08
	ctx.lr = 0x828F4594;
	sub_82DF3A08(ctx, base);
	// 828F4594: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F4598: 3BE0001F  li r31, 0x1f
	ctx.r[31].s64 = 31;
	// 828F459C: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828F45A0: 48566131  bl 0x82e5a6d0
	ctx.lr = 0x828F45A4;
	sub_82E5A6D0(ctx, base);
	// 828F45A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F45A8: 484FED61  bl 0x82df3308
	ctx.lr = 0x828F45AC;
	sub_82DF3308(ctx, base);
	// 828F45AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F45B0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828F45B4: 41820008  beq 0x828f45bc
	if ctx.cr[0].eq {
	pc = 0x828F45BC; continue 'dispatch;
	}
	// 828F45B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F45BC: 57EA06F7  rlwinm. r10, r31, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828F45C0: 557D063E  clrlwi r29, r11, 0x18
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F45C4: 41820010  beq 0x828f45d4
	if ctx.cr[0].eq {
	pc = 0x828F45D4; continue 'dispatch;
	}
	// 828F45C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F45CC: 57FF0734  rlwinm r31, r31, 0, 0x1c, 0x1a
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 828F45D0: 484FEE59  bl 0x82df3428
	ctx.lr = 0x828F45D4;
	sub_82DF3428(ctx, base);
	// 828F45D4: 57EB0739  rlwinm. r11, r31, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F45D8: 41820010  beq 0x828f45e8
	if ctx.cr[0].eq {
	pc = 0x828F45E8; continue 'dispatch;
	}
	// 828F45DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F45E0: 57FF0776  rlwinm r31, r31, 0, 0x1d, 0x1b
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 828F45E4: 484FEE45  bl 0x82df3428
	ctx.lr = 0x828F45E8;
	sub_82DF3428(ctx, base);
	// 828F45E8: 57EB077B  rlwinm. r11, r31, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F45EC: 41820010  beq 0x828f45fc
	if ctx.cr[0].eq {
	pc = 0x828F45FC; continue 'dispatch;
	}
	// 828F45F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F45F4: 57FF07B8  rlwinm r31, r31, 0, 0x1e, 0x1c
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 828F45F8: 484FEE31  bl 0x82df3428
	ctx.lr = 0x828F45FC;
	sub_82DF3428(ctx, base);
	// 828F45FC: 57EB07BD  rlwinm. r11, r31, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F4600: 41820010  beq 0x828f4610
	if ctx.cr[0].eq {
	pc = 0x828F4610; continue 'dispatch;
	}
	// 828F4604: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828F4608: 57FF07FA  rlwinm r31, r31, 0, 0x1f, 0x1d
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 828F460C: 484FEE1D  bl 0x82df3428
	ctx.lr = 0x828F4610;
	sub_82DF3428(ctx, base);
	// 828F4610: 57EB07FF  clrlwi. r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F4614: 4182000C  beq 0x828f4620
	if ctx.cr[0].eq {
	pc = 0x828F4620; continue 'dispatch;
	}
	// 828F4618: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F461C: 484FEE0D  bl 0x82df3428
	ctx.lr = 0x828F4620;
	sub_82DF3428(ctx, base);
	// 828F4620: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F4624: 408200DC  bne 0x828f4700
	if !ctx.cr[0].eq {
	pc = 0x828F4700; continue 'dispatch;
	}
	// 828F4628: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F462C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F4630: 808B0B88  lwz r4, 0xb88(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2952 as u32) ) } as u64;
	// 828F4634: 484FF3D5  bl 0x82df3a08
	ctx.lr = 0x828F4638;
	sub_82DF3A08(ctx, base);
	// 828F4638: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F463C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F4640: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F4644: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828F4648: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F464C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828F4650: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F4654: 4856A30D  bl 0x82e5e960
	ctx.lr = 0x828F4658;
	sub_82E5E960(ctx, base);
	// 828F4658: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828F465C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F4660: 419A0008  beq cr6, 0x828f4668
	if ctx.cr[6].eq {
	pc = 0x828F4668; continue 'dispatch;
	}
	// 828F4664: 4B9CC22D  bl 0x822c0890
	ctx.lr = 0x828F4668;
	sub_822C0890(ctx, base);
	// 828F4668: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 828F466C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828F4670: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828F4674: 4BF73E45  bl 0x828684b8
	ctx.lr = 0x828F4678;
	sub_828684B8(ctx, base);
	// 828F4678: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F467C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828F4680: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F4684: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F4688: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 828F468C: 419A0024  beq cr6, 0x828f46b0
	if ctx.cr[6].eq {
	pc = 0x828F46B0; continue 'dispatch;
	}
	// 828F4690: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828F4694: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828F4698: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F469C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828F46A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828F46A4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F46A8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F46AC: 4082FFE8  bne 0x828f4694
	if !ctx.cr[0].eq {
	pc = 0x828F4694; continue 'dispatch;
	}
	// 828F46B0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828F46B4: 3BE10068  addi r31, r1, 0x68
	ctx.r[31].s64 = ctx.r[1].s64 + 104;
	// 828F46B8: 48713A71  bl 0x83008128
	ctx.lr = 0x828F46BC;
	sub_83008128(ctx, base);
	// 828F46BC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F46C0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828F46C4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828F46C8: 388A2F18  addi r4, r10, 0x2f18
	ctx.r[4].s64 = ctx.r[10].s64 + 12056;
	// 828F46CC: 38A0039C  li r5, 0x39c
	ctx.r[5].s64 = 924;
	// 828F46D0: 387C0038  addi r3, r28, 0x38
	ctx.r[3].s64 = ctx.r[28].s64 + 56;
	// 828F46D4: C02B2C9C  lfs f1, 0x2c9c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11420 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F46D8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828F46DC: 48564365  bl 0x82e58a40
	ctx.lr = 0x828F46E0;
	sub_82E58A40(ctx, base);
	// 828F46E0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828F46E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F46E8: 419A0008  beq cr6, 0x828f46f0
	if ctx.cr[6].eq {
	pc = 0x828F46F0; continue 'dispatch;
	}
	// 828F46EC: 4B9CC1A5  bl 0x822c0890
	ctx.lr = 0x828F46F0;
	sub_822C0890(ctx, base);
	// 828F46F0: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828F46F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F46F8: 419A0008  beq cr6, 0x828f4700
	if ctx.cr[6].eq {
	pc = 0x828F4700; continue 'dispatch;
	}
	// 828F46FC: 4B9CC195  bl 0x822c0890
	ctx.lr = 0x828F4700;
	sub_822C0890(ctx, base);
	// 828F4700: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828F4704: 488B3AA8  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F4708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828F4708 size=32
    let mut pc: u32 = 0x828F4708;
    'dispatch: loop {
        match pc {
            0x828F4708 => {
    //   block [0x828F4708..0x828F4728)
	// 828F4708: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F470C: C023000C  lfs f1, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F4710: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F4714: 88A30010  lbz r5, 0x10(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F4718: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F471C: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828F4720: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828F4724: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F4728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F4728 size=128
    let mut pc: u32 = 0x828F4728;
    'dispatch: loop {
        match pc {
            0x828F4728 => {
    //   block [0x828F4728..0x828F47A8)
	// 828F4728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F472C: 488B3A41  bl 0x831a816c
	ctx.lr = 0x828F4730;
	sub_831A8130(ctx, base);
	// 828F4730: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F4734: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 828F4738: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828F473C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F4740: 3BEBAA80  addi r31, r11, -0x5580
	ctx.r[31].s64 = ctx.r[11].s64 + -21888;
	// 828F4744: 816AAA88  lwz r11, -0x5578(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21880 as u32) ) } as u64;
	// 828F4748: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828F474C: 40820024  bne 0x828f4770
	if !ctx.cr[0].eq {
	pc = 0x828F4770; continue 'dispatch;
	}
	// 828F4750: 3D208236  lis r9, -0x7dca
	ctx.r[9].s64 = -2110390272;
	// 828F4754: 3D00828F  lis r8, -0x7d71
	ctx.r[8].s64 = -2104557568;
	// 828F4758: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828F475C: 3929A778  addi r9, r9, -0x5888
	ctx.r[9].s64 = ctx.r[9].s64 + -22664;
	// 828F4760: 390831F8  addi r8, r8, 0x31f8
	ctx.r[8].s64 = ctx.r[8].s64 + 12792;
	// 828F4764: 916AAA88  stw r11, -0x5578(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-21880 as u32), ctx.r[11].u32 ) };
	// 828F4768: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828F476C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828F4770: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828F4774: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828F4778: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F477C: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 828F4780: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828F4784: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F4788: 4BFD3151  bl 0x828c78d8
	ctx.lr = 0x828F478C;
	sub_828C78D8(ctx, base);
	// 828F478C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F4790: 4182000C  beq 0x828f479c
	if ctx.cr[0].eq {
	pc = 0x828F479C; continue 'dispatch;
	}
	// 828F4794: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F4798: 48000008  b 0x828f47a0
	pc = 0x828F47A0; continue 'dispatch;
	// 828F479C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828F47A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F47A4: 488B3A18  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F47A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F47A8 size=484
    let mut pc: u32 = 0x828F47A8;
    'dispatch: loop {
        match pc {
            0x828F47A8 => {
    //   block [0x828F47A8..0x828F498C)
	// 828F47A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F47AC: 488B39B5  bl 0x831a8160
	ctx.lr = 0x828F47B0;
	sub_831A8130(ctx, base);
	// 828F47B0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F47B4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F47B8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828F47BC: 3BAB2F18  addi r29, r11, 0x2f18
	ctx.r[29].s64 = ctx.r[11].s64 + 12056;
	// 828F47C0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F47C4: 38A000A4  li r5, 0xa4
	ctx.r[5].s64 = 164;
	// 828F47C8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F47CC: 386003A0  li r3, 0x3a0
	ctx.r[3].s64 = 928;
	// 828F47D0: 484FDC19  bl 0x82df23e8
	ctx.lr = 0x828F47D4;
	sub_82DF23E8(ctx, base);
	// 828F47D4: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828F47D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F47DC: 3B8BBA80  addi r28, r11, -0x4580
	ctx.r[28].s64 = ctx.r[11].s64 + -17792;
	// 828F47E0: 41820024  beq 0x828f4804
	if ctx.cr[0].eq {
	pc = 0x828F4804; continue 'dispatch;
	}
	// 828F47E4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828F47E8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F47EC: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 828F47F0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828F47F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F47F8: 4BFFEF89  bl 0x828f3780
	ctx.lr = 0x828F47FC;
	sub_828F3780(ctx, base);
	// 828F47FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F4800: 48000008  b 0x828f4808
	pc = 0x828F4808; continue 'dispatch;
	// 828F4804: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F4808: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828F480C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F4810: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F4814: 4BFFE78D  bl 0x828f2fa0
	ctx.lr = 0x828F4818;
	sub_828F2FA0(ctx, base);
	// 828F4818: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F481C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F4820: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F4824: 4B9CB7DD  bl 0x822c0000
	ctx.lr = 0x828F4828;
	sub_822C0000(ctx, base);
	// 828F4828: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F482C: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F4830: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828F4834: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 828F4838: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828F483C: 419A0024  beq cr6, 0x828f4860
	if ctx.cr[6].eq {
	pc = 0x828F4860; continue 'dispatch;
	}
	// 828F4840: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 828F4844: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828F4848: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F484C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828F4850: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828F4854: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F4858: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F485C: 4082FFE8  bne 0x828f4844
	if !ctx.cr[0].eq {
	pc = 0x828F4844; continue 'dispatch;
	}
	// 828F4860: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828F4864: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 828F4868: 409A0008  bne cr6, 0x828f4870
	if !ctx.cr[6].eq {
	pc = 0x828F4870; continue 'dispatch;
	}
	// 828F486C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F4870: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828F4874: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828F4878: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 828F487C: 419A0024  beq cr6, 0x828f48a0
	if ctx.cr[6].eq {
	pc = 0x828F48A0; continue 'dispatch;
	}
	// 828F4880: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 828F4884: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828F4888: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F488C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828F4890: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828F4894: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F4898: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F489C: 4082FFE8  bne 0x828f4884
	if !ctx.cr[0].eq {
	pc = 0x828F4884; continue 'dispatch;
	}
	// 828F48A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F48A4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828F48A8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828F48AC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828F48B0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F48B4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F48B8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F48BC: 4BEA4675  bl 0x82798f30
	ctx.lr = 0x828F48C0;
	sub_82798F30(ctx, base);
	// 828F48C0: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F48C4: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 828F48C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F48CC: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828F48D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F48D4: 4E800421  bctrl
	ctx.lr = 0x828F48D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F48D8: C0030010  lfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F48DC: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828F48E0: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F48E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F48E8: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828F48EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F48F0: 4E800421  bctrl
	ctx.lr = 0x828F48F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F48F4: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F48F8: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828F48FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F4900: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F4904: 38A000A9  li r5, 0xa9
	ctx.r[5].s64 = 169;
	// 828F4908: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828F490C: 4B9CBACD  bl 0x822c03d8
	ctx.lr = 0x828F4910;
	sub_822C03D8(ctx, base);
	// 828F4910: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F4914: 41820014  beq 0x828f4928
	if ctx.cr[0].eq {
	pc = 0x828F4928; continue 'dispatch;
	}
	// 828F4918: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828F491C: 4BEA6D4D  bl 0x8279b668
	ctx.lr = 0x828F4920;
	sub_8279B668(ctx, base);
	// 828F4920: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F4924: 48000008  b 0x828f492c
	pc = 0x828F492C; continue 'dispatch;
	// 828F4928: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F492C: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F4930: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 828F4934: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F4938: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F493C: 4BCA3315  bl 0x82597c50
	ctx.lr = 0x828F4940;
	sub_82597C50(ctx, base);
	// 828F4940: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F4944: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F4948: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F494C: 4B9CB6B5  bl 0x822c0000
	ctx.lr = 0x828F4950;
	sub_822C0000(ctx, base);
	// 828F4950: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828F4954: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F4958: 419A0008  beq cr6, 0x828f4960
	if ctx.cr[6].eq {
	pc = 0x828F4960; continue 'dispatch;
	}
	// 828F495C: 4B9CBF35  bl 0x822c0890
	ctx.lr = 0x828F4960;
	sub_822C0890(ctx, base);
	// 828F4960: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F4964: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F4968: 419A0008  beq cr6, 0x828f4970
	if ctx.cr[6].eq {
	pc = 0x828F4970; continue 'dispatch;
	}
	// 828F496C: 4B9CBF25  bl 0x822c0890
	ctx.lr = 0x828F4970;
	sub_822C0890(ctx, base);
	// 828F4970: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 828F4974: 419A000C  beq cr6, 0x828f4980
	if ctx.cr[6].eq {
	pc = 0x828F4980; continue 'dispatch;
	}
	// 828F4978: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828F497C: 4B9CBF15  bl 0x822c0890
	ctx.lr = 0x828F4980;
	sub_822C0890(ctx, base);
	// 828F4980: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828F4984: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828F4988: 488B3828  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F4990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F4990 size=128
    let mut pc: u32 = 0x828F4990;
    'dispatch: loop {
        match pc {
            0x828F4990 => {
    //   block [0x828F4990..0x828F4A10)
	// 828F4990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F4994: 488B37D9  bl 0x831a816c
	ctx.lr = 0x828F4998;
	sub_831A8130(ctx, base);
	// 828F4998: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F499C: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 828F49A0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828F49A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F49A8: 3BEBAA8C  addi r31, r11, -0x5574
	ctx.r[31].s64 = ctx.r[11].s64 + -21876;
	// 828F49AC: 816AAA94  lwz r11, -0x556c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21868 as u32) ) } as u64;
	// 828F49B0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828F49B4: 40820024  bne 0x828f49d8
	if !ctx.cr[0].eq {
	pc = 0x828F49D8; continue 'dispatch;
	}
	// 828F49B8: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 828F49BC: 3D00828F  lis r8, -0x7d71
	ctx.r[8].s64 = -2104557568;
	// 828F49C0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828F49C4: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 828F49C8: 39083498  addi r8, r8, 0x3498
	ctx.r[8].s64 = ctx.r[8].s64 + 13464;
	// 828F49CC: 916AAA94  stw r11, -0x556c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-21868 as u32), ctx.r[11].u32 ) };
	// 828F49D0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828F49D4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828F49D8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828F49DC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828F49E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F49E4: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828F49E8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828F49EC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F49F0: 4BD5FBD1  bl 0x826545c0
	ctx.lr = 0x828F49F4;
	sub_826545C0(ctx, base);
	// 828F49F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F49F8: 4182000C  beq 0x828f4a04
	if ctx.cr[0].eq {
	pc = 0x828F4A04; continue 'dispatch;
	}
	// 828F49FC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F4A00: 48000008  b 0x828f4a08
	pc = 0x828F4A08; continue 'dispatch;
	// 828F4A04: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828F4A08: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F4A0C: 488B37B0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F4A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F4A10 size=128
    let mut pc: u32 = 0x828F4A10;
    'dispatch: loop {
        match pc {
            0x828F4A10 => {
    //   block [0x828F4A10..0x828F4A90)
	// 828F4A10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F4A14: 488B3759  bl 0x831a816c
	ctx.lr = 0x828F4A18;
	sub_831A8130(ctx, base);
	// 828F4A18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F4A1C: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 828F4A20: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828F4A24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F4A28: 3BEBAA98  addi r31, r11, -0x5568
	ctx.r[31].s64 = ctx.r[11].s64 + -21864;
	// 828F4A2C: 816AAAA0  lwz r11, -0x5560(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21856 as u32) ) } as u64;
	// 828F4A30: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828F4A34: 40820024  bne 0x828f4a58
	if !ctx.cr[0].eq {
	pc = 0x828F4A58; continue 'dispatch;
	}
	// 828F4A38: 3D20828F  lis r9, -0x7d71
	ctx.r[9].s64 = -2104557568;
	// 828F4A3C: 3D00828F  lis r8, -0x7d71
	ctx.r[8].s64 = -2104557568;
	// 828F4A40: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828F4A44: 39294708  addi r9, r9, 0x4708
	ctx.r[9].s64 = ctx.r[9].s64 + 18184;
	// 828F4A48: 39083450  addi r8, r8, 0x3450
	ctx.r[8].s64 = ctx.r[8].s64 + 13392;
	// 828F4A4C: 916AAAA0  stw r11, -0x5560(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-21856 as u32), ctx.r[11].u32 ) };
	// 828F4A50: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828F4A54: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828F4A58: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828F4A5C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828F4A60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F4A64: 38FE0008  addi r7, r30, 8
	ctx.r[7].s64 = ctx.r[30].s64 + 8;
	// 828F4A68: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828F4A6C: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F4A70: 4BFEEF61  bl 0x828e39d0
	ctx.lr = 0x828F4A74;
	sub_828E39D0(ctx, base);
	// 828F4A74: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F4A78: 4182000C  beq 0x828f4a84
	if ctx.cr[0].eq {
	pc = 0x828F4A84; continue 'dispatch;
	}
	// 828F4A7C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F4A80: 48000008  b 0x828f4a88
	pc = 0x828F4A88; continue 'dispatch;
	// 828F4A84: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828F4A88: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F4A8C: 488B3730  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F4A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F4A90 size=4424
    let mut pc: u32 = 0x828F4A90;
    'dispatch: loop {
        match pc {
            0x828F4A90 => {
    //   block [0x828F4A90..0x828F5BD8)
	// 828F4A90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F4A94: 488B36A1  bl 0x831a8134
	ctx.lr = 0x828F4A98;
	sub_831A8130(ctx, base);
	// 828F4A98: DBC1FF60  stfd f30, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[30].u64 ) };
	// 828F4A9C: DBE1FF68  stfd f31, -0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[31].u64 ) };
	// 828F4AA0: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F4AA4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F4AA8: 7C932378  mr r19, r4
	ctx.r[19].u64 = ctx.r[4].u64;
	// 828F4AAC: 7CB22B78  mr r18, r5
	ctx.r[18].u64 = ctx.r[5].u64;
	// 828F4AB0: 7CD43378  mr r20, r6
	ctx.r[20].u64 = ctx.r[6].u64;
	// 828F4AB4: 4801C2DD  bl 0x82910d90
	ctx.lr = 0x828F4AB8;
	sub_82910D90(ctx, base);
	// 828F4AB8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828F4ABC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F4AC0: 4BC1A8B1  bl 0x8250f370
	ctx.lr = 0x828F4AC4;
	sub_8250F370(ctx, base);
	// 828F4AC4: 363DFFF0  addic. r17, r29, -0x10
	ctx.xer.ca = (ctx.r[29].u32 > (!(-16 as u32)));
	ctx.r[17].s64 = ctx.r[29].s64 + -16;
	ctx.cr[0].compare_i32(ctx.r[17].s32, 0, &mut ctx.xer);
	// 828F4AC8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828F4ACC: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 828F4AD0: 40820008  bne 0x828f4ad8
	if !ctx.cr[0].eq {
	pc = 0x828F4AD8; continue 'dispatch;
	}
	// 828F4AD4: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 828F4AD8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828F4ADC: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 828F4AE0: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 828F4AE4: 484FEF25  bl 0x82df3a08
	ctx.lr = 0x828F4AE8;
	sub_82DF3A08(ctx, base);
	// 828F4AE8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F4AEC: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 828F4AF0: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 828F4AF4: 4BC13C8D  bl 0x82508780
	ctx.lr = 0x828F4AF8;
	sub_82508780(ctx, base);
	// 828F4AF8: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 828F4AFC: 484FE92D  bl 0x82df3428
	ctx.lr = 0x828F4B00;
	sub_82DF3428(ctx, base);
	// 828F4B00: 2B110000  cmplwi cr6, r17, 0
	ctx.cr[6].compare_u32(ctx.r[17].u32, 0 as u32, &mut ctx.xer);
	// 828F4B04: 389D0028  addi r4, r29, 0x28
	ctx.r[4].s64 = ctx.r[29].s64 + 40;
	// 828F4B08: 409A0008  bne cr6, 0x828f4b10
	if !ctx.cr[6].eq {
	pc = 0x828F4B10; continue 'dispatch;
	}
	// 828F4B0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F4B10: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 828F4B14: 4BC13C8D  bl 0x825087a0
	ctx.lr = 0x828F4B18;
	sub_825087A0(ctx, base);
	// 828F4B18: 2B110000  cmplwi cr6, r17, 0
	ctx.cr[6].compare_u32(ctx.r[17].u32, 0 as u32, &mut ctx.xer);
	// 828F4B1C: 3BFD0028  addi r31, r29, 0x28
	ctx.r[31].s64 = ctx.r[29].s64 + 40;
	// 828F4B20: 409A0008  bne cr6, 0x828f4b28
	if !ctx.cr[6].eq {
	pc = 0x828F4B28; continue 'dispatch;
	}
	// 828F4B24: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 828F4B28: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828F4B2C: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 828F4B30: 808BD070  lwz r4, -0x2f90(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12176 as u32) ) } as u64;
	// 828F4B34: 484FEED5  bl 0x82df3a08
	ctx.lr = 0x828F4B38;
	sub_82DF3A08(ctx, base);
	// 828F4B38: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F4B3C: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 828F4B40: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 828F4B44: 4BC13CAD  bl 0x825087f0
	ctx.lr = 0x828F4B48;
	sub_825087F0(ctx, base);
	// 828F4B48: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 828F4B4C: 484FE8DD  bl 0x82df3428
	ctx.lr = 0x828F4B50;
	sub_82DF3428(ctx, base);
	// 828F4B50: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F4B54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4B58: 3B0BA8AC  addi r24, r11, -0x5754
	ctx.r[24].s64 = ctx.r[11].s64 + -22356;
	// 828F4B5C: 8098000C  lwz r4, 0xc(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F4B60: 484FEEA9  bl 0x82df3a08
	ctx.lr = 0x828F4B64;
	sub_82DF3A08(ctx, base);
	// 828F4B64: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828F4B68: 80980008  lwz r4, 8(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F4B6C: 484FEE9D  bl 0x82df3a08
	ctx.lr = 0x828F4B70;
	sub_82DF3A08(ctx, base);
	// 828F4B70: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F4B74: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828F4B78: 808BACA8  lwz r4, -0x5358(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21336 as u32) ) } as u64;
	// 828F4B7C: 484FEE8D  bl 0x82df3a08
	ctx.lr = 0x828F4B80;
	sub_82DF3A08(ctx, base);
	// 828F4B80: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 828F4B84: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 828F4B88: 38C10088  addi r6, r1, 0x88
	ctx.r[6].s64 = ctx.r[1].s64 + 136;
	// 828F4B8C: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 828F4B90: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 828F4B94: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F4B98: 4801CF61  bl 0x82911af8
	ctx.lr = 0x828F4B9C;
	sub_82911AF8(ctx, base);
	// 828F4B9C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828F4BA0: 484FE889  bl 0x82df3428
	ctx.lr = 0x828F4BA4;
	sub_82DF3428(ctx, base);
	// 828F4BA4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828F4BA8: 484FE881  bl 0x82df3428
	ctx.lr = 0x828F4BAC;
	sub_82DF3428(ctx, base);
	// 828F4BAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4BB0: 484FE879  bl 0x82df3428
	ctx.lr = 0x828F4BB4;
	sub_82DF3428(ctx, base);
	// 828F4BB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F4BB8: 4801BD09  bl 0x829108c0
	ctx.lr = 0x828F4BBC;
	sub_829108C0(ctx, base);
	// 828F4BBC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F4BC0: 41820010  beq 0x828f4bd0
	if ctx.cr[0].eq {
	pc = 0x828F4BD0; continue 'dispatch;
	}
	// 828F4BC4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F4BC8: 4BC1BA09  bl 0x825105d0
	ctx.lr = 0x828F4BCC;
	sub_825105D0(ctx, base);
	// 828F4BCC: 48000FFC  b 0x828f5bc8
	pc = 0x828F5BC8; continue 'dispatch;
	// 828F4BD0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F4BD4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F4BD8: 3AAB2F18  addi r21, r11, 0x2f18
	ctx.r[21].s64 = ctx.r[11].s64 + 12056;
	// 828F4BDC: 38A000D5  li r5, 0xd5
	ctx.r[5].s64 = 213;
	// 828F4BE0: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828F4BE4: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828F4BE8: 4B9CB7F1  bl 0x822c03d8
	ctx.lr = 0x828F4BEC;
	sub_822C03D8(ctx, base);
	// 828F4BEC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828F4BF0: 41820020  beq 0x828f4c10
	if ctx.cr[0].eq {
	pc = 0x828F4C10; continue 'dispatch;
	}
	// 828F4BF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F4BF8: 4BEF60B9  bl 0x827eacb0
	ctx.lr = 0x828F4BFC;
	sub_827EACB0(ctx, base);
	// 828F4BFC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F4C00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F4C04: 396B09D8  addi r11, r11, 0x9d8
	ctx.r[11].s64 = ctx.r[11].s64 + 2520;
	// 828F4C08: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F4C0C: 48000008  b 0x828f4c14
	pc = 0x828F4C14; continue 'dispatch;
	// 828F4C10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F4C14: 3BFD01CC  addi r31, r29, 0x1cc
	ctx.r[31].s64 = ctx.r[29].s64 + 460;
	// 828F4C18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F4C1C: 4BF73665  bl 0x82868280
	ctx.lr = 0x828F4C20;
	sub_82868280(ctx, base);
	// 828F4C20: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F4C24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4C28: 808BACAC  lwz r4, -0x5354(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21332 as u32) ) } as u64;
	// 828F4C2C: 484FEDDD  bl 0x82df3a08
	ctx.lr = 0x828F4C30;
	sub_82DF3A08(ctx, base);
	// 828F4C30: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828F4C34: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F4C38: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 828F4C3C: 3B4BAAB8  addi r26, r11, -0x5548
	ctx.r[26].s64 = ctx.r[11].s64 + -21832;
	// 828F4C40: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 828F4C44: 837D01CC  lwz r27, 0x1cc(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(460 as u32) ) } as u64;
	// 828F4C48: C3EBAAB8  lfs f31, -0x5548(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21832 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828F4C4C: 4BC1A87D  bl 0x8250f4c8
	ctx.lr = 0x828F4C50;
	sub_8250F4C8(ctx, base);
	// 828F4C50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F4C54: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828F4C58: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F4C5C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F4C60: 4BEF5D09  bl 0x827ea968
	ctx.lr = 0x828F4C64;
	sub_827EA968(ctx, base);
	// 828F4C64: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 828F4C68: 484FD029  bl 0x82df1c90
	ctx.lr = 0x828F4C6C;
	sub_82DF1C90(ctx, base);
	// 828F4C6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4C70: 484FE7B9  bl 0x82df3428
	ctx.lr = 0x828F4C74;
	sub_82DF3428(ctx, base);
	// 828F4C74: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F4C78: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828F4C7C: 807D01CC  lwz r3, 0x1cc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(460 as u32) ) } as u64;
	// 828F4C80: 388AACB8  addi r4, r10, -0x5348
	ctx.r[4].s64 = ctx.r[10].s64 + -21320;
	// 828F4C84: 80AB30E0  lwz r5, 0x30e0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12512 as u32) ) } as u64;
	// 828F4C88: 4BEF5A39  bl 0x827ea6c0
	ctx.lr = 0x828F4C8C;
	sub_827EA6C0(ctx, base);
	// 828F4C8C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F4C90: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828F4C94: 4BEF7935  bl 0x827ec5c8
	ctx.lr = 0x828F4C98;
	sub_827EC5C8(ctx, base);
	// 828F4C98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F4C9C: 807D01CC  lwz r3, 0x1cc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(460 as u32) ) } as u64;
	// 828F4CA0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4CA4: 4BEF5A25  bl 0x827ea6c8
	ctx.lr = 0x828F4CA8;
	sub_827EA6C8(ctx, base);
	// 828F4CA8: 806100F4  lwz r3, 0xf4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 828F4CAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F4CB0: 419A0008  beq cr6, 0x828f4cb8
	if ctx.cr[6].eq {
	pc = 0x828F4CB8; continue 'dispatch;
	}
	// 828F4CB4: 4B9CBBDD  bl 0x822c0890
	ctx.lr = 0x828F4CB8;
	sub_822C0890(ctx, base);
	// 828F4CB8: 3F80832D  lis r28, -0x7cd3
	ctx.r[28].s64 = -2094202880;
	// 828F4CBC: 93C1008C  stw r30, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 828F4CC0: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 828F4CC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4CC8: 396B6930  addi r11, r11, 0x6930
	ctx.r[11].s64 = ctx.r[11].s64 + 26928;
	// 828F4CCC: 809CB3B0  lwz r4, -0x4c50(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-19536 as u32) ) } as u64;
	// 828F4CD0: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 828F4CD4: 484FED35  bl 0x82df3a08
	ctx.lr = 0x828F4CD8;
	sub_82DF3A08(ctx, base);
	// 828F4CD8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F4CDC: 996100A8  stb r11, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u8 ) };
	// 828F4CE0: C01A012C  lfs f0, 0x12c(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(300 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F4CE4: 3B3DFFF0  addi r25, r29, -0x10
	ctx.r[25].s64 = ctx.r[29].s64 + -16;
	// 828F4CE8: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 828F4CEC: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 828F4CF0: 916100CC  stw r11, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 828F4CF4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F4CF8: 816100A8  lwz r11, 0xa8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 828F4CFC: 932100C8  stw r25, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[25].u32 ) };
	// 828F4D00: E8810088  ld r4, 0x88(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 828F4D04: E8A100C8  ld r5, 0xc8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	// 828F4D08: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F4D0C: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 828F4D10: E8C100D0  ld r6, 0xd0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	// 828F4D14: 4BFFFCFD  bl 0x828f4a10
	ctx.lr = 0x828F4D18;
	sub_828F4A10(ctx, base);
	// 828F4D18: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828F4D1C: C03A0130  lfs f1, 0x130(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(304 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F4D20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F4D24: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4D28: 4BEF5A89  bl 0x827ea7b0
	ctx.lr = 0x828F4D2C;
	sub_827EA7B0(ctx, base);
	// 828F4D2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4D30: 484FE6F9  bl 0x82df3428
	ctx.lr = 0x828F4D34;
	sub_82DF3428(ctx, base);
	// 828F4D34: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828F4D38: 80980004  lwz r4, 4(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F4D3C: 484FECCD  bl 0x82df3a08
	ctx.lr = 0x828F4D40;
	sub_82DF3A08(ctx, base);
	// 828F4D40: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 828F4D44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F4D48: 80940000  lwz r4, 0(r20)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4D4C: 4801CBD5  bl 0x82911920
	ctx.lr = 0x828F4D50;
	sub_82911920(ctx, base);
	// 828F4D50: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828F4D54: 484FE6D5  bl 0x82df3428
	ctx.lr = 0x828F4D58;
	sub_82DF3428(ctx, base);
	// 828F4D58: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F4D5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4D60: 808BF3F8  lwz r4, -0xc08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3080 as u32) ) } as u64;
	// 828F4D64: 484FECA5  bl 0x82df3a08
	ctx.lr = 0x828F4D68;
	sub_82DF3A08(ctx, base);
	// 828F4D68: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F4D6C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4D70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F4D74: C3CB6150  lfs f30, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828F4D78: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828F4D7C: 4BEF55BD  bl 0x827ea338
	ctx.lr = 0x828F4D80;
	sub_827EA338(ctx, base);
	// 828F4D80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4D84: 484FE6A5  bl 0x82df3428
	ctx.lr = 0x828F4D88;
	sub_82DF3428(ctx, base);
	// 828F4D88: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F4D8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4D90: 808BF3FC  lwz r4, -0xc04(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3076 as u32) ) } as u64;
	// 828F4D94: 484FEC75  bl 0x82df3a08
	ctx.lr = 0x828F4D98;
	sub_82DF3A08(ctx, base);
	// 828F4D98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F4D9C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4DA0: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828F4DA4: 4BEF5595  bl 0x827ea338
	ctx.lr = 0x828F4DA8;
	sub_827EA338(ctx, base);
	// 828F4DA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4DAC: 484FE67D  bl 0x82df3428
	ctx.lr = 0x828F4DB0;
	sub_82DF3428(ctx, base);
	// 828F4DB0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F4DB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4DB8: 808BB3F4  lwz r4, -0x4c0c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19468 as u32) ) } as u64;
	// 828F4DBC: 484FEC4D  bl 0x82df3a08
	ctx.lr = 0x828F4DC0;
	sub_82DF3A08(ctx, base);
	// 828F4DC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F4DC4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4DC8: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828F4DCC: 4BEF556D  bl 0x827ea338
	ctx.lr = 0x828F4DD0;
	sub_827EA338(ctx, base);
	// 828F4DD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4DD4: 484FE655  bl 0x82df3428
	ctx.lr = 0x828F4DD8;
	sub_82DF3428(ctx, base);
	// 828F4DD8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F4DDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4DE0: 808BB3F8  lwz r4, -0x4c08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19464 as u32) ) } as u64;
	// 828F4DE4: 484FEC25  bl 0x82df3a08
	ctx.lr = 0x828F4DE8;
	sub_82DF3A08(ctx, base);
	// 828F4DE8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F4DEC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4DF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F4DF4: 3B6B2C94  addi r27, r11, 0x2c94
	ctx.r[27].s64 = ctx.r[11].s64 + 11412;
	// 828F4DF8: C3FB0008  lfs f31, 8(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828F4DFC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F4E00: 4BEF5539  bl 0x827ea338
	ctx.lr = 0x828F4E04;
	sub_827EA338(ctx, base);
	// 828F4E04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4E08: 484FE621  bl 0x82df3428
	ctx.lr = 0x828F4E0C;
	sub_82DF3428(ctx, base);
	// 828F4E0C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F4E10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4E14: 808BB3D0  lwz r4, -0x4c30(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19504 as u32) ) } as u64;
	// 828F4E18: 484FEBF1  bl 0x82df3a08
	ctx.lr = 0x828F4E1C;
	sub_82DF3A08(ctx, base);
	// 828F4E1C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F4E20: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4E24: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F4E28: 4BEF5511  bl 0x827ea338
	ctx.lr = 0x828F4E2C;
	sub_827EA338(ctx, base);
	// 828F4E2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4E30: 484FE5F9  bl 0x82df3428
	ctx.lr = 0x828F4E34;
	sub_82DF3428(ctx, base);
	// 828F4E34: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F4E38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4E3C: 808BB3D4  lwz r4, -0x4c2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19500 as u32) ) } as u64;
	// 828F4E40: 484FEBC9  bl 0x82df3a08
	ctx.lr = 0x828F4E44;
	sub_82DF3A08(ctx, base);
	// 828F4E44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F4E48: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4E4C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F4E50: 4BEF54E9  bl 0x827ea338
	ctx.lr = 0x828F4E54;
	sub_827EA338(ctx, base);
	// 828F4E54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4E58: 484FE5D1  bl 0x82df3428
	ctx.lr = 0x828F4E5C;
	sub_82DF3428(ctx, base);
	// 828F4E5C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F4E60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4E64: 808BB3D8  lwz r4, -0x4c28(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19496 as u32) ) } as u64;
	// 828F4E68: 484FEBA1  bl 0x82df3a08
	ctx.lr = 0x828F4E6C;
	sub_82DF3A08(ctx, base);
	// 828F4E6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F4E70: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4E74: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F4E78: 4BEF54C1  bl 0x827ea338
	ctx.lr = 0x828F4E7C;
	sub_827EA338(ctx, base);
	// 828F4E7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4E80: 484FE5A9  bl 0x82df3428
	ctx.lr = 0x828F4E84;
	sub_82DF3428(ctx, base);
	// 828F4E84: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F4E88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4E8C: 808BB3DC  lwz r4, -0x4c24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19492 as u32) ) } as u64;
	// 828F4E90: 484FEB79  bl 0x82df3a08
	ctx.lr = 0x828F4E94;
	sub_82DF3A08(ctx, base);
	// 828F4E94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F4E98: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4E9C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F4EA0: 4BEF5499  bl 0x827ea338
	ctx.lr = 0x828F4EA4;
	sub_827EA338(ctx, base);
	// 828F4EA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4EA8: 484FE581  bl 0x82df3428
	ctx.lr = 0x828F4EAC;
	sub_82DF3428(ctx, base);
	// 828F4EAC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F4EB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4EB4: 808BB3E0  lwz r4, -0x4c20(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19488 as u32) ) } as u64;
	// 828F4EB8: 484FEB51  bl 0x82df3a08
	ctx.lr = 0x828F4EBC;
	sub_82DF3A08(ctx, base);
	// 828F4EBC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F4EC0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4EC4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F4EC8: 4BEF5471  bl 0x827ea338
	ctx.lr = 0x828F4ECC;
	sub_827EA338(ctx, base);
	// 828F4ECC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4ED0: 484FE559  bl 0x82df3428
	ctx.lr = 0x828F4ED4;
	sub_82DF3428(ctx, base);
	// 828F4ED4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F4ED8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4EDC: 808BB3E4  lwz r4, -0x4c1c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19484 as u32) ) } as u64;
	// 828F4EE0: 484FEB29  bl 0x82df3a08
	ctx.lr = 0x828F4EE4;
	sub_82DF3A08(ctx, base);
	// 828F4EE4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F4EE8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4EEC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F4EF0: 4BEF5449  bl 0x827ea338
	ctx.lr = 0x828F4EF4;
	sub_827EA338(ctx, base);
	// 828F4EF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4EF8: 484FE531  bl 0x82df3428
	ctx.lr = 0x828F4EFC;
	sub_82DF3428(ctx, base);
	// 828F4EFC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F4F00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4F04: 808BB3E8  lwz r4, -0x4c18(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19480 as u32) ) } as u64;
	// 828F4F08: 484FEB01  bl 0x82df3a08
	ctx.lr = 0x828F4F0C;
	sub_82DF3A08(ctx, base);
	// 828F4F0C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F4F10: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4F14: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F4F18: 4BEF5421  bl 0x827ea338
	ctx.lr = 0x828F4F1C;
	sub_827EA338(ctx, base);
	// 828F4F1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4F20: 484FE509  bl 0x82df3428
	ctx.lr = 0x828F4F24;
	sub_82DF3428(ctx, base);
	// 828F4F24: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F4F28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4F2C: 808BB3EC  lwz r4, -0x4c14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19476 as u32) ) } as u64;
	// 828F4F30: 484FEAD9  bl 0x82df3a08
	ctx.lr = 0x828F4F34;
	sub_82DF3A08(ctx, base);
	// 828F4F34: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4F38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F4F3C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F4F40: 4BEF53F9  bl 0x827ea338
	ctx.lr = 0x828F4F44;
	sub_827EA338(ctx, base);
	// 828F4F44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4F48: 484FE4E1  bl 0x82df3428
	ctx.lr = 0x828F4F4C;
	sub_82DF3428(ctx, base);
	// 828F4F4C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F4F50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4F54: 808BB3F0  lwz r4, -0x4c10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19472 as u32) ) } as u64;
	// 828F4F58: 484FEAB1  bl 0x82df3a08
	ctx.lr = 0x828F4F5C;
	sub_82DF3A08(ctx, base);
	// 828F4F5C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F4F60: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4F64: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F4F68: 4BEF53D1  bl 0x827ea338
	ctx.lr = 0x828F4F6C;
	sub_827EA338(ctx, base);
	// 828F4F6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4F70: 484FE4B9  bl 0x82df3428
	ctx.lr = 0x828F4F74;
	sub_82DF3428(ctx, base);
	// 828F4F74: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F4F78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4F7C: 808BB3C4  lwz r4, -0x4c3c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19516 as u32) ) } as u64;
	// 828F4F80: 484FEA89  bl 0x82df3a08
	ctx.lr = 0x828F4F84;
	sub_82DF3A08(ctx, base);
	// 828F4F84: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F4F88: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4F8C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F4F90: 4BEF53A9  bl 0x827ea338
	ctx.lr = 0x828F4F94;
	sub_827EA338(ctx, base);
	// 828F4F94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4F98: 484FE491  bl 0x82df3428
	ctx.lr = 0x828F4F9C;
	sub_82DF3428(ctx, base);
	// 828F4F9C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F4FA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4FA4: 808BB3C8  lwz r4, -0x4c38(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19512 as u32) ) } as u64;
	// 828F4FA8: 484FEA61  bl 0x82df3a08
	ctx.lr = 0x828F4FAC;
	sub_82DF3A08(ctx, base);
	// 828F4FAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F4FB0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4FB4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F4FB8: 4BEF5381  bl 0x827ea338
	ctx.lr = 0x828F4FBC;
	sub_827EA338(ctx, base);
	// 828F4FBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4FC0: 484FE469  bl 0x82df3428
	ctx.lr = 0x828F4FC4;
	sub_82DF3428(ctx, base);
	// 828F4FC4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F4FC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4FCC: 808BB3CC  lwz r4, -0x4c34(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19508 as u32) ) } as u64;
	// 828F4FD0: 484FEA39  bl 0x82df3a08
	ctx.lr = 0x828F4FD4;
	sub_82DF3A08(ctx, base);
	// 828F4FD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F4FD8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F4FDC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F4FE0: 4BEF5359  bl 0x827ea338
	ctx.lr = 0x828F4FE4;
	sub_827EA338(ctx, base);
	// 828F4FE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4FE8: 484FE441  bl 0x82df3428
	ctx.lr = 0x828F4FEC;
	sub_82DF3428(ctx, base);
	// 828F4FEC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F4FF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F4FF4: 808BF460  lwz r4, -0xba0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2976 as u32) ) } as u64;
	// 828F4FF8: 484FEA11  bl 0x82df3a08
	ctx.lr = 0x828F4FFC;
	sub_82DF3A08(ctx, base);
	// 828F4FFC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F5000: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F5004: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828F5008: 4BEF5331  bl 0x827ea338
	ctx.lr = 0x828F500C;
	sub_827EA338(ctx, base);
	// 828F500C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5010: 484FE419  bl 0x82df3428
	ctx.lr = 0x828F5014;
	sub_82DF3428(ctx, base);
	// 828F5014: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F5018: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F501C: 808BF45C  lwz r4, -0xba4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2980 as u32) ) } as u64;
	// 828F5020: 484FE9E9  bl 0x82df3a08
	ctx.lr = 0x828F5024;
	sub_82DF3A08(ctx, base);
	// 828F5024: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F5028: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F502C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828F5030: 4BEF5309  bl 0x827ea338
	ctx.lr = 0x828F5034;
	sub_827EA338(ctx, base);
	// 828F5034: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5038: 484FE3F1  bl 0x82df3428
	ctx.lr = 0x828F503C;
	sub_82DF3428(ctx, base);
	// 828F503C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5040: 809CB3B0  lwz r4, -0x4c50(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-19536 as u32) ) } as u64;
	// 828F5044: 484FE9C5  bl 0x82df3a08
	ctx.lr = 0x828F5048;
	sub_82DF3A08(ctx, base);
	// 828F5048: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F504C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F5050: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F5054: 4BEF52E5  bl 0x827ea338
	ctx.lr = 0x828F5058;
	sub_827EA338(ctx, base);
	// 828F5058: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F505C: 484FE3CD  bl 0x82df3428
	ctx.lr = 0x828F5060;
	sub_82DF3428(ctx, base);
	// 828F5060: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F5064: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5068: 808BF46C  lwz r4, -0xb94(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2964 as u32) ) } as u64;
	// 828F506C: 484FE99D  bl 0x82df3a08
	ctx.lr = 0x828F5070;
	sub_82DF3A08(ctx, base);
	// 828F5070: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F5074: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F5078: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F507C: 4BEF52BD  bl 0x827ea338
	ctx.lr = 0x828F5080;
	sub_827EA338(ctx, base);
	// 828F5080: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5084: 484FE3A5  bl 0x82df3428
	ctx.lr = 0x828F5088;
	sub_82DF3428(ctx, base);
	// 828F5088: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F508C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5090: 808BF470  lwz r4, -0xb90(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2960 as u32) ) } as u64;
	// 828F5094: 484FE975  bl 0x82df3a08
	ctx.lr = 0x828F5098;
	sub_82DF3A08(ctx, base);
	// 828F5098: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F509C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F50A0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F50A4: 4BEF5295  bl 0x827ea338
	ctx.lr = 0x828F50A8;
	sub_827EA338(ctx, base);
	// 828F50A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F50AC: 484FE37D  bl 0x82df3428
	ctx.lr = 0x828F50B0;
	sub_82DF3428(ctx, base);
	// 828F50B0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F50B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F50B8: 808BF47C  lwz r4, -0xb84(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2948 as u32) ) } as u64;
	// 828F50BC: 484FE94D  bl 0x82df3a08
	ctx.lr = 0x828F50C0;
	sub_82DF3A08(ctx, base);
	// 828F50C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F50C4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F50C8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F50CC: 4BEF526D  bl 0x827ea338
	ctx.lr = 0x828F50D0;
	sub_827EA338(ctx, base);
	// 828F50D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F50D4: 484FE355  bl 0x82df3428
	ctx.lr = 0x828F50D8;
	sub_82DF3428(ctx, base);
	// 828F50D8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F50DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F50E0: 808BF468  lwz r4, -0xb98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2968 as u32) ) } as u64;
	// 828F50E4: 484FE925  bl 0x82df3a08
	ctx.lr = 0x828F50E8;
	sub_82DF3A08(ctx, base);
	// 828F50E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F50EC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F50F0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F50F4: 4BEF5245  bl 0x827ea338
	ctx.lr = 0x828F50F8;
	sub_827EA338(ctx, base);
	// 828F50F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F50FC: 484FE32D  bl 0x82df3428
	ctx.lr = 0x828F5100;
	sub_82DF3428(ctx, base);
	// 828F5100: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F5104: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5108: 808BF480  lwz r4, -0xb80(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2944 as u32) ) } as u64;
	// 828F510C: 484FE8FD  bl 0x82df3a08
	ctx.lr = 0x828F5110;
	sub_82DF3A08(ctx, base);
	// 828F5110: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F5114: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F5118: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F511C: 4BEF521D  bl 0x827ea338
	ctx.lr = 0x828F5120;
	sub_827EA338(ctx, base);
	// 828F5120: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5124: 484FE305  bl 0x82df3428
	ctx.lr = 0x828F5128;
	sub_82DF3428(ctx, base);
	// 828F5128: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F512C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5130: 808BF450  lwz r4, -0xbb0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2992 as u32) ) } as u64;
	// 828F5134: 484FE8D5  bl 0x82df3a08
	ctx.lr = 0x828F5138;
	sub_82DF3A08(ctx, base);
	// 828F5138: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F513C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F5140: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F5144: 4BEF51F5  bl 0x827ea338
	ctx.lr = 0x828F5148;
	sub_827EA338(ctx, base);
	// 828F5148: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F514C: 484FE2DD  bl 0x82df3428
	ctx.lr = 0x828F5150;
	sub_82DF3428(ctx, base);
	// 828F5150: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828F5154: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F5158: 38A00108  li r5, 0x108
	ctx.r[5].s64 = 264;
	// 828F515C: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 828F5160: 4B9CB279  bl 0x822c03d8
	ctx.lr = 0x828F5164;
	sub_822C03D8(ctx, base);
	// 828F5164: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F5168: 41820020  beq 0x828f5188
	if ctx.cr[0].eq {
	pc = 0x828F5188; continue 'dispatch;
	}
	// 828F516C: 2B110000  cmplwi cr6, r17, 0
	ctx.cr[6].compare_u32(ctx.r[17].u32, 0 as u32, &mut ctx.xer);
	// 828F5170: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F5174: 409A0008  bne cr6, 0x828f517c
	if !ctx.cr[6].eq {
	pc = 0x828F517C; continue 'dispatch;
	}
	// 828F5178: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F517C: 48000D1D  bl 0x828f5e98
	ctx.lr = 0x828F5180;
	sub_828F5E98(ctx, base);
	// 828F5180: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F5184: 48000008  b 0x828f518c
	pc = 0x828F518C; continue 'dispatch;
	// 828F5188: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F518C: 387D00E4  addi r3, r29, 0xe4
	ctx.r[3].s64 = ctx.r[29].s64 + 228;
	// 828F5190: 4BFFEB89  bl 0x828f3d18
	ctx.lr = 0x828F5194;
	sub_828F3D18(ctx, base);
	// 828F5194: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F5198: 4BEF6FC9  bl 0x827ec160
	ctx.lr = 0x828F519C;
	sub_827EC160(ctx, base);
	// 828F519C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828F51A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F51A4: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F51A8: 4811E4D9  bl 0x82a13680
	ctx.lr = 0x828F51AC;
	sub_82A13680(ctx, base);
	// 828F51AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F51B0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F51B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F51B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F51BC: 4E800421  bctrl
	ctx.lr = 0x828F51C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F51C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F51C4: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F51C8: 4811E4C1  bl 0x82a13688
	ctx.lr = 0x828F51CC;
	sub_82A13688(ctx, base);
	// 828F51CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F51D0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 828F51D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F51D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F51DC: 4E800421  bctrl
	ctx.lr = 0x828F51E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F51E0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828F51E4: 4802C195  bl 0x82921378
	ctx.lr = 0x828F51E8;
	sub_82921378(ctx, base);
	// 828F51E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F51EC: C1BB0004  lfs f13, 4(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F51F0: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 828F51F4: C19B000C  lfs f12, 0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828F51F8: 93C100AC  stw r30, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[30].u32 ) };
	// 828F51FC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F5200: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F5204: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 828F5208: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F520C: C01A0000  lfs f0, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F5210: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 828F5214: D1A100A0  stfs f13, 0xa0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 828F5218: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 828F521C: D00100A4  stfs f0, 0xa4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 828F5220: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828F5224: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F5228: 4E800421  bctrl
	ctx.lr = 0x828F522C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F522C: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 828F5230: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828F5234: 4BFFEC7D  bl 0x828f3eb0
	ctx.lr = 0x828F5238;
	sub_828F3EB0(ctx, base);
	// 828F5238: 817D00FC  lwz r11, 0xfc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(252 as u32) ) } as u64;
	// 828F523C: 3BFD00FC  addi r31, r29, 0xfc
	ctx.r[31].s64 = ctx.r[29].s64 + 252;
	// 828F5240: 809D00E4  lwz r4, 0xe4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(228 as u32) ) } as u64;
	// 828F5244: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F5248: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F524C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F5250: 4E800421  bctrl
	ctx.lr = 0x828F5254;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F5254: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F5258: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828F525C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F5260: 388B99B8  addi r4, r11, -0x6648
	ctx.r[4].s64 = ctx.r[11].s64 + -26184;
	// 828F5264: 4BFFF4C5  bl 0x828f4728
	ctx.lr = 0x828F5268;
	sub_828F4728(ctx, base);
	// 828F5268: 3EE0832D  lis r23, -0x7cd3
	ctx.r[23].s64 = -2094202880;
	// 828F526C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5270: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 828F5274: 80970AF0  lwz r4, 0xaf0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(2800 as u32) ) } as u64;
	// 828F5278: 484FE791  bl 0x82df3a08
	ctx.lr = 0x828F527C;
	sub_82DF3A08(ctx, base);
	// 828F527C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F5280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F5284: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F5288: 48566ED1  bl 0x82e5c158
	ctx.lr = 0x828F528C;
	sub_82E5C158(ctx, base);
	// 828F528C: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F5290: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828F5294: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F5298: 388B9A28  addi r4, r11, -0x65d8
	ctx.r[4].s64 = ctx.r[11].s64 + -26072;
	// 828F529C: 4BFFF48D  bl 0x828f4728
	ctx.lr = 0x828F52A0;
	sub_828F4728(ctx, base);
	// 828F52A0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F52A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F52A8: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 828F52AC: 808BB404  lwz r4, -0x4bfc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19452 as u32) ) } as u64;
	// 828F52B0: 484FE759  bl 0x82df3a08
	ctx.lr = 0x828F52B4;
	sub_82DF3A08(ctx, base);
	// 828F52B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F52B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F52BC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F52C0: 48566E99  bl 0x82e5c158
	ctx.lr = 0x828F52C4;
	sub_82E5C158(ctx, base);
	// 828F52C4: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F52C8: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828F52CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F52D0: 388B9A98  addi r4, r11, -0x6568
	ctx.r[4].s64 = ctx.r[11].s64 + -25960;
	// 828F52D4: 4BFFF455  bl 0x828f4728
	ctx.lr = 0x828F52D8;
	sub_828F4728(ctx, base);
	// 828F52D8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F52DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F52E0: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 828F52E4: 808B0AF8  lwz r4, 0xaf8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2808 as u32) ) } as u64;
	// 828F52E8: 484FE721  bl 0x82df3a08
	ctx.lr = 0x828F52EC;
	sub_82DF3A08(ctx, base);
	// 828F52EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F52F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F52F4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F52F8: 48566E61  bl 0x82e5c158
	ctx.lr = 0x828F52FC;
	sub_82E5C158(ctx, base);
	// 828F52FC: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F5300: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828F5304: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F5308: 388B9160  addi r4, r11, -0x6ea0
	ctx.r[4].s64 = ctx.r[11].s64 + -28320;
	// 828F530C: 4BFFF41D  bl 0x828f4728
	ctx.lr = 0x828F5310;
	sub_828F4728(ctx, base);
	// 828F5310: 3EC0832D  lis r22, -0x7cd3
	ctx.r[22].s64 = -2094202880;
	// 828F5314: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5318: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 828F531C: 8096B408  lwz r4, -0x4bf8(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(-19448 as u32) ) } as u64;
	// 828F5320: 484FE6E9  bl 0x82df3a08
	ctx.lr = 0x828F5324;
	sub_82DF3A08(ctx, base);
	// 828F5324: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F5328: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F532C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F5330: 48566E29  bl 0x82e5c158
	ctx.lr = 0x828F5334;
	sub_82E5C158(ctx, base);
	// 828F5334: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F5338: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828F533C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F5340: 388BB188  addi r4, r11, -0x4e78
	ctx.r[4].s64 = ctx.r[11].s64 + -20088;
	// 828F5344: 4BFFF3E5  bl 0x828f4728
	ctx.lr = 0x828F5348;
	sub_828F4728(ctx, base);
	// 828F5348: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F534C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5350: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 828F5354: 808B0AFC  lwz r4, 0xafc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2812 as u32) ) } as u64;
	// 828F5358: 484FE6B1  bl 0x82df3a08
	ctx.lr = 0x828F535C;
	sub_82DF3A08(ctx, base);
	// 828F535C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F5360: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F5364: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F5368: 48566DF1  bl 0x82e5c158
	ctx.lr = 0x828F536C;
	sub_82E5C158(ctx, base);
	// 828F536C: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F5370: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828F5374: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F5378: 388BB380  addi r4, r11, -0x4c80
	ctx.r[4].s64 = ctx.r[11].s64 + -19584;
	// 828F537C: 4BFFF3AD  bl 0x828f4728
	ctx.lr = 0x828F5380;
	sub_828F4728(ctx, base);
	// 828F5380: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F5384: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5388: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 828F538C: 808B0B10  lwz r4, 0xb10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2832 as u32) ) } as u64;
	// 828F5390: 484FE679  bl 0x82df3a08
	ctx.lr = 0x828F5394;
	sub_82DF3A08(ctx, base);
	// 828F5394: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F5398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F539C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F53A0: 48566DB9  bl 0x82e5c158
	ctx.lr = 0x828F53A4;
	sub_82E5C158(ctx, base);
	// 828F53A4: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F53A8: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828F53AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F53B0: 388B89B8  addi r4, r11, -0x7648
	ctx.r[4].s64 = ctx.r[11].s64 + -30280;
	// 828F53B4: 4BFFF375  bl 0x828f4728
	ctx.lr = 0x828F53B8;
	sub_828F4728(ctx, base);
	// 828F53B8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F53BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F53C0: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 828F53C4: 808B0B08  lwz r4, 0xb08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2824 as u32) ) } as u64;
	// 828F53C8: 484FE641  bl 0x82df3a08
	ctx.lr = 0x828F53CC;
	sub_82DF3A08(ctx, base);
	// 828F53CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F53D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F53D4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F53D8: 48566D81  bl 0x82e5c158
	ctx.lr = 0x828F53DC;
	sub_82E5C158(ctx, base);
	// 828F53DC: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F53E0: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828F53E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F53E8: 388BA248  addi r4, r11, -0x5db8
	ctx.r[4].s64 = ctx.r[11].s64 + -23992;
	// 828F53EC: 4BFFF33D  bl 0x828f4728
	ctx.lr = 0x828F53F0;
	sub_828F4728(ctx, base);
	// 828F53F0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F53F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F53F8: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 828F53FC: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828F5400: 484FE609  bl 0x82df3a08
	ctx.lr = 0x828F5404;
	sub_82DF3A08(ctx, base);
	// 828F5404: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F5408: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F540C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F5410: 48566D49  bl 0x82e5c158
	ctx.lr = 0x828F5414;
	sub_82E5C158(ctx, base);
	// 828F5414: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F5418: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828F541C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F5420: 388B8BD8  addi r4, r11, -0x7428
	ctx.r[4].s64 = ctx.r[11].s64 + -29736;
	// 828F5424: 4BFFF305  bl 0x828f4728
	ctx.lr = 0x828F5428;
	sub_828F4728(ctx, base);
	// 828F5428: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F542C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5430: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 828F5434: 808B0B30  lwz r4, 0xb30(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2864 as u32) ) } as u64;
	// 828F5438: 484FE5D1  bl 0x82df3a08
	ctx.lr = 0x828F543C;
	sub_82DF3A08(ctx, base);
	// 828F543C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F5440: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F5444: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F5448: 48566D11  bl 0x82e5c158
	ctx.lr = 0x828F544C;
	sub_82E5C158(ctx, base);
	// 828F544C: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F5450: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828F5454: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F5458: 388B8618  addi r4, r11, -0x79e8
	ctx.r[4].s64 = ctx.r[11].s64 + -31208;
	// 828F545C: 4BFFF2CD  bl 0x828f4728
	ctx.lr = 0x828F5460;
	sub_828F4728(ctx, base);
	// 828F5460: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F5464: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5468: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 828F546C: 808B0B88  lwz r4, 0xb88(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2952 as u32) ) } as u64;
	// 828F5470: 484FE599  bl 0x82df3a08
	ctx.lr = 0x828F5474;
	sub_82DF3A08(ctx, base);
	// 828F5474: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F5478: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F547C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F5480: 48566CD9  bl 0x82e5c158
	ctx.lr = 0x828F5484;
	sub_82E5C158(ctx, base);
	// 828F5484: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F5488: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828F548C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F5490: 388B87B0  addi r4, r11, -0x7850
	ctx.r[4].s64 = ctx.r[11].s64 + -30800;
	// 828F5494: 4BFFF295  bl 0x828f4728
	ctx.lr = 0x828F5498;
	sub_828F4728(ctx, base);
	// 828F5498: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F549C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F54A0: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 828F54A4: 808B0B34  lwz r4, 0xb34(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2868 as u32) ) } as u64;
	// 828F54A8: 484FE561  bl 0x82df3a08
	ctx.lr = 0x828F54AC;
	sub_82DF3A08(ctx, base);
	// 828F54AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F54B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F54B4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F54B8: 48566CA1  bl 0x82e5c158
	ctx.lr = 0x828F54BC;
	sub_82E5C158(ctx, base);
	// 828F54BC: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F54C0: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828F54C4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F54C8: 388B8820  addi r4, r11, -0x77e0
	ctx.r[4].s64 = ctx.r[11].s64 + -30688;
	// 828F54CC: 4BFFF25D  bl 0x828f4728
	ctx.lr = 0x828F54D0;
	sub_828F4728(ctx, base);
	// 828F54D0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F54D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F54D8: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 828F54DC: 808B0B28  lwz r4, 0xb28(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2856 as u32) ) } as u64;
	// 828F54E0: 484FE529  bl 0x82df3a08
	ctx.lr = 0x828F54E4;
	sub_82DF3A08(ctx, base);
	// 828F54E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F54E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F54EC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F54F0: 48566C69  bl 0x82e5c158
	ctx.lr = 0x828F54F4;
	sub_82E5C158(ctx, base);
	// 828F54F4: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F54F8: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828F54FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F5500: 388B8A60  addi r4, r11, -0x75a0
	ctx.r[4].s64 = ctx.r[11].s64 + -30112;
	// 828F5504: 4BF73BA5  bl 0x828690a8
	ctx.lr = 0x828F5508;
	sub_828690A8(ctx, base);
	// 828F5508: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F550C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5510: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 828F5514: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828F5518: 484FE4F1  bl 0x82df3a08
	ctx.lr = 0x828F551C;
	sub_82DF3A08(ctx, base);
	// 828F551C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F5520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F5524: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F5528: 48566C31  bl 0x82e5c158
	ctx.lr = 0x828F552C;
	sub_82E5C158(ctx, base);
	// 828F552C: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F5530: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828F5534: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F5538: 388BC038  addi r4, r11, -0x3fc8
	ctx.r[4].s64 = ctx.r[11].s64 + -16328;
	// 828F553C: 4BF73B6D  bl 0x828690a8
	ctx.lr = 0x828F5540;
	sub_828690A8(ctx, base);
	// 828F5540: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F5544: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5548: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 828F554C: 808B0B70  lwz r4, 0xb70(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2928 as u32) ) } as u64;
	// 828F5550: 484FE4B9  bl 0x82df3a08
	ctx.lr = 0x828F5554;
	sub_82DF3A08(ctx, base);
	// 828F5554: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F5558: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F555C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F5560: 48566BF9  bl 0x82e5c158
	ctx.lr = 0x828F5564;
	sub_82E5C158(ctx, base);
	// 828F5564: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F5568: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828F556C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F5570: 388B10F8  addi r4, r11, 0x10f8
	ctx.r[4].s64 = ctx.r[11].s64 + 4344;
	// 828F5574: 4BF73B35  bl 0x828690a8
	ctx.lr = 0x828F5578;
	sub_828690A8(ctx, base);
	// 828F5578: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F557C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5580: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 828F5584: 808B0B7C  lwz r4, 0xb7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2940 as u32) ) } as u64;
	// 828F5588: 484FE481  bl 0x82df3a08
	ctx.lr = 0x828F558C;
	sub_82DF3A08(ctx, base);
	// 828F558C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F5590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F5594: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F5598: 48566BC1  bl 0x82e5c158
	ctx.lr = 0x828F559C;
	sub_82E5C158(ctx, base);
	// 828F559C: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F55A0: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828F55A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F55A8: 388BBFA0  addi r4, r11, -0x4060
	ctx.r[4].s64 = ctx.r[11].s64 + -16480;
	// 828F55AC: 4BF73AFD  bl 0x828690a8
	ctx.lr = 0x828F55B0;
	sub_828690A8(ctx, base);
	// 828F55B0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F55B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F55B8: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 828F55BC: 808B0B98  lwz r4, 0xb98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2968 as u32) ) } as u64;
	// 828F55C0: 484FE449  bl 0x82df3a08
	ctx.lr = 0x828F55C4;
	sub_82DF3A08(ctx, base);
	// 828F55C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F55C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F55CC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F55D0: 48566B89  bl 0x82e5c158
	ctx.lr = 0x828F55D4;
	sub_82E5C158(ctx, base);
	// 828F55D4: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F55D8: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 828F55DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F55E0: 388B9CE0  addi r4, r11, -0x6320
	ctx.r[4].s64 = ctx.r[11].s64 + -25376;
	// 828F55E4: 4BF73AC5  bl 0x828690a8
	ctx.lr = 0x828F55E8;
	sub_828690A8(ctx, base);
	// 828F55E8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F55EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F55F0: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 828F55F4: 808B0B50  lwz r4, 0xb50(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2896 as u32) ) } as u64;
	// 828F55F8: 484FE411  bl 0x82df3a08
	ctx.lr = 0x828F55FC;
	sub_82DF3A08(ctx, base);
	// 828F55FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F5600: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F5604: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F5608: 48566B51  bl 0x82e5c158
	ctx.lr = 0x828F560C;
	sub_82E5C158(ctx, base);
	// 828F560C: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F5610: 3D608292  lis r11, -0x7d6e
	ctx.r[11].s64 = -2104360960;
	// 828F5614: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F5618: 388B4378  addi r4, r11, 0x4378
	ctx.r[4].s64 = ctx.r[11].s64 + 17272;
	// 828F561C: 4BF73A8D  bl 0x828690a8
	ctx.lr = 0x828F5620;
	sub_828690A8(ctx, base);
	// 828F5620: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F5624: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5628: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 828F562C: 808B0B58  lwz r4, 0xb58(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2904 as u32) ) } as u64;
	// 828F5630: 484FE3D9  bl 0x82df3a08
	ctx.lr = 0x828F5634;
	sub_82DF3A08(ctx, base);
	// 828F5634: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F5638: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F563C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F5640: 48566B19  bl 0x82e5c158
	ctx.lr = 0x828F5644;
	sub_82E5C158(ctx, base);
	// 828F5644: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F5648: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828F564C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F5650: 388B55E8  addi r4, r11, 0x55e8
	ctx.r[4].s64 = ctx.r[11].s64 + 21992;
	// 828F5654: 4BF73A55  bl 0x828690a8
	ctx.lr = 0x828F5658;
	sub_828690A8(ctx, base);
	// 828F5658: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F565C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5660: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 828F5664: 808B0B5C  lwz r4, 0xb5c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2908 as u32) ) } as u64;
	// 828F5668: 484FE3A1  bl 0x82df3a08
	ctx.lr = 0x828F566C;
	sub_82DF3A08(ctx, base);
	// 828F566C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F5670: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F5674: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F5678: 48566AE1  bl 0x82e5c158
	ctx.lr = 0x828F567C;
	sub_82E5C158(ctx, base);
	// 828F567C: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F5680: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828F5684: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F5688: 388B9EF8  addi r4, r11, -0x6108
	ctx.r[4].s64 = ctx.r[11].s64 + -24840;
	// 828F568C: 4BF73A1D  bl 0x828690a8
	ctx.lr = 0x828F5690;
	sub_828690A8(ctx, base);
	// 828F5690: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F5694: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5698: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 828F569C: 808B0B64  lwz r4, 0xb64(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2916 as u32) ) } as u64;
	// 828F56A0: 484FE369  bl 0x82df3a08
	ctx.lr = 0x828F56A4;
	sub_82DF3A08(ctx, base);
	// 828F56A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F56A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F56AC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F56B0: 48566AA9  bl 0x82e5c158
	ctx.lr = 0x828F56B4;
	sub_82E5C158(ctx, base);
	// 828F56B4: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F56B8: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828F56BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F56C0: 388B4700  addi r4, r11, 0x4700
	ctx.r[4].s64 = ctx.r[11].s64 + 18176;
	// 828F56C4: 4BF739E5  bl 0x828690a8
	ctx.lr = 0x828F56C8;
	sub_828690A8(ctx, base);
	// 828F56C8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F56CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F56D0: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 828F56D4: 808B0B68  lwz r4, 0xb68(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2920 as u32) ) } as u64;
	// 828F56D8: 484FE331  bl 0x82df3a08
	ctx.lr = 0x828F56DC;
	sub_82DF3A08(ctx, base);
	// 828F56DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F56E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F56E4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F56E8: 48566A71  bl 0x82e5c158
	ctx.lr = 0x828F56EC;
	sub_82E5C158(ctx, base);
	// 828F56EC: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F56F0: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828F56F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F56F8: 388B9260  addi r4, r11, -0x6da0
	ctx.r[4].s64 = ctx.r[11].s64 + -28064;
	// 828F56FC: 4BF739AD  bl 0x828690a8
	ctx.lr = 0x828F5700;
	sub_828690A8(ctx, base);
	// 828F5700: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F5704: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5708: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 828F570C: 808B0B4C  lwz r4, 0xb4c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2892 as u32) ) } as u64;
	// 828F5710: 484FE2F9  bl 0x82df3a08
	ctx.lr = 0x828F5714;
	sub_82DF3A08(ctx, base);
	// 828F5714: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F5718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F571C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F5720: 48566A39  bl 0x82e5c158
	ctx.lr = 0x828F5724;
	sub_82E5C158(ctx, base);
	// 828F5724: 817D0164  lwz r11, 0x164(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(356 as u32) ) } as u64;
	// 828F5728: 3B9D0164  addi r28, r29, 0x164
	ctx.r[28].s64 = ctx.r[29].s64 + 356;
	// 828F572C: 809D00E4  lwz r4, 0xe4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(228 as u32) ) } as u64;
	// 828F5730: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F5734: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F5738: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F573C: 4E800421  bctrl
	ctx.lr = 0x828F5740;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F5740: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F5744: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828F5748: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F574C: 388BD8C8  addi r4, r11, -0x2738
	ctx.r[4].s64 = ctx.r[11].s64 + -10040;
	// 828F5750: 4BF73959  bl 0x828690a8
	ctx.lr = 0x828F5754;
	sub_828690A8(ctx, base);
	// 828F5754: 3E00832D  lis r16, -0x7cd3
	ctx.r[16].s64 = -2094202880;
	// 828F5758: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F575C: 39E10060  addi r15, r1, 0x60
	ctx.r[15].s64 = ctx.r[1].s64 + 96;
	// 828F5760: 80900BD8  lwz r4, 0xbd8(r16)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(3032 as u32) ) } as u64;
	// 828F5764: 484FE2A5  bl 0x82df3a08
	ctx.lr = 0x828F5768;
	sub_82DF3A08(ctx, base);
	// 828F5768: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F576C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F5770: 7DE57B78  mr r5, r15
	ctx.r[5].u64 = ctx.r[15].u64;
	// 828F5774: 485669E5  bl 0x82e5c158
	ctx.lr = 0x828F5778;
	sub_82E5C158(ctx, base);
	// 828F5778: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F577C: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828F5780: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F5784: 388BDE20  addi r4, r11, -0x21e0
	ctx.r[4].s64 = ctx.r[11].s64 + -8672;
	// 828F5788: 4BF73921  bl 0x828690a8
	ctx.lr = 0x828F578C;
	sub_828690A8(ctx, base);
	// 828F578C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F5790: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5794: 39E10060  addi r15, r1, 0x60
	ctx.r[15].s64 = ctx.r[1].s64 + 96;
	// 828F5798: 808B0BE0  lwz r4, 0xbe0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3040 as u32) ) } as u64;
	// 828F579C: 484FE26D  bl 0x82df3a08
	ctx.lr = 0x828F57A0;
	sub_82DF3A08(ctx, base);
	// 828F57A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F57A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F57A8: 7DE57B78  mr r5, r15
	ctx.r[5].u64 = ctx.r[15].u64;
	// 828F57AC: 485669AD  bl 0x82e5c158
	ctx.lr = 0x828F57B0;
	sub_82E5C158(ctx, base);
	// 828F57B0: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F57B4: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828F57B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F57BC: 388BE810  addi r4, r11, -0x17f0
	ctx.r[4].s64 = ctx.r[11].s64 + -6128;
	// 828F57C0: 4BF738E9  bl 0x828690a8
	ctx.lr = 0x828F57C4;
	sub_828690A8(ctx, base);
	// 828F57C4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F57C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F57CC: 39E10060  addi r15, r1, 0x60
	ctx.r[15].s64 = ctx.r[1].s64 + 96;
	// 828F57D0: 808B0BE8  lwz r4, 0xbe8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3048 as u32) ) } as u64;
	// 828F57D4: 484FE235  bl 0x82df3a08
	ctx.lr = 0x828F57D8;
	sub_82DF3A08(ctx, base);
	// 828F57D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F57DC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F57E0: 7DE57B78  mr r5, r15
	ctx.r[5].u64 = ctx.r[15].u64;
	// 828F57E4: 48566975  bl 0x82e5c158
	ctx.lr = 0x828F57E8;
	sub_82E5C158(ctx, base);
	// 828F57E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F57EC: 80900BD8  lwz r4, 0xbd8(r16)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(3032 as u32) ) } as u64;
	// 828F57F0: 484FE219  bl 0x82df3a08
	ctx.lr = 0x828F57F4;
	sub_82DF3A08(ctx, base);
	// 828F57F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F57F8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F57FC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828F5800: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 828F5804: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F5808: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828F580C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828F5810: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F5814: 4856914D  bl 0x82e5e960
	ctx.lr = 0x828F5818;
	sub_82E5E960(ctx, base);
	// 828F5818: 8061010C  lwz r3, 0x10c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 828F581C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F5820: 419A0008  beq cr6, 0x828f5828
	if ctx.cr[6].eq {
	pc = 0x828F5828; continue 'dispatch;
	}
	// 828F5824: 4B9CB06D  bl 0x822c0890
	ctx.lr = 0x828F5828;
	sub_822C0890(ctx, base);
	// 828F5828: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828F582C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F5830: 38A0015A  li r5, 0x15a
	ctx.r[5].s64 = 346;
	// 828F5834: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828F5838: 4B9CABA1  bl 0x822c03d8
	ctx.lr = 0x828F583C;
	sub_822C03D8(ctx, base);
	// 828F583C: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 828F5840: 41820028  beq 0x828f5868
	if ctx.cr[0].eq {
	pc = 0x828F5868; continue 'dispatch;
	}
	// 828F5844: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F5848: 4BEF6919  bl 0x827ec160
	ctx.lr = 0x828F584C;
	sub_827EC160(ctx, base);
	// 828F584C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828F5850: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 828F5854: 80B80000  lwz r5, 0(r24)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F5858: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F585C: 4802CF65  bl 0x829227c0
	ctx.lr = 0x828F5860;
	sub_829227C0(ctx, base);
	// 828F5860: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F5864: 48000008  b 0x828f586c
	pc = 0x828F586C; continue 'dispatch;
	// 828F5868: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F586C: 387D0368  addi r3, r29, 0x368
	ctx.r[3].s64 = ctx.r[29].s64 + 872;
	// 828F5870: 4BF73749  bl 0x82868fb8
	ctx.lr = 0x828F5874;
	sub_82868FB8(ctx, base);
	// 828F5874: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F5878: 4BC1D221  bl 0x82512a98
	ctx.lr = 0x828F587C;
	sub_82512A98(ctx, base);
	// 828F587C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828F5880: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F5884: 38A00160  li r5, 0x160
	ctx.r[5].s64 = 352;
	// 828F5888: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 828F588C: 4B9CAB4D  bl 0x822c03d8
	ctx.lr = 0x828F5890;
	sub_822C03D8(ctx, base);
	// 828F5890: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F5894: 41820020  beq 0x828f58b4
	if ctx.cr[0].eq {
	pc = 0x828F58B4; continue 'dispatch;
	}
	// 828F5898: 2B110000  cmplwi cr6, r17, 0
	ctx.cr[6].compare_u32(ctx.r[17].u32, 0 as u32, &mut ctx.xer);
	// 828F589C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F58A0: 409A0008  bne cr6, 0x828f58a8
	if !ctx.cr[6].eq {
	pc = 0x828F58A8; continue 'dispatch;
	}
	// 828F58A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F58A8: 48000331  bl 0x828f5bd8
	ctx.lr = 0x828F58AC;
	sub_828F5BD8(ctx, base);
	// 828F58AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F58B0: 48000008  b 0x828f58b8
	pc = 0x828F58B8; continue 'dispatch;
	// 828F58B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F58B8: 387D0360  addi r3, r29, 0x360
	ctx.r[3].s64 = ctx.r[29].s64 + 864;
	// 828F58BC: 4BFFE4CD  bl 0x828f3d88
	ctx.lr = 0x828F58C0;
	sub_828F3D88(ctx, base);
	// 828F58C0: 807D0360  lwz r3, 0x360(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(864 as u32) ) } as u64;
	// 828F58C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F58C8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828F58CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F58D0: 4E800421  bctrl
	ctx.lr = 0x828F58D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F58D4: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 828F58D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F58DC: 48018725  bl 0x8290e000
	ctx.lr = 0x828F58E0;
	sub_8290E000(ctx, base);
	// 828F58E0: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828F58E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F58E8: 38A00168  li r5, 0x168
	ctx.r[5].s64 = 360;
	// 828F58EC: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 828F58F0: 4B9CAAE9  bl 0x822c03d8
	ctx.lr = 0x828F58F4;
	sub_822C03D8(ctx, base);
	// 828F58F4: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 828F58F8: 41820040  beq 0x828f5938
	if ctx.cr[0].eq {
	pc = 0x828F5938; continue 'dispatch;
	}
	// 828F58FC: 2B110000  cmplwi cr6, r17, 0
	ctx.cr[6].compare_u32(ctx.r[17].u32, 0 as u32, &mut ctx.xer);
	// 828F5900: 7FB8EB78  mr r24, r29
	ctx.r[24].u64 = ctx.r[29].u64;
	// 828F5904: 409A0008  bne cr6, 0x828f590c
	if !ctx.cr[6].eq {
	pc = 0x828F590C; continue 'dispatch;
	}
	// 828F5908: 7FD8F378  mr r24, r30
	ctx.r[24].u64 = ctx.r[30].u64;
	// 828F590C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F5910: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F5914: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 828F5918: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F591C: 4E800421  bctrl
	ctx.lr = 0x828F5920;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F5920: 38A30034  addi r5, r3, 0x34
	ctx.r[5].s64 = ctx.r[3].s64 + 52;
	// 828F5924: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828F5928: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F592C: 4804E2F5  bl 0x82943c20
	ctx.lr = 0x828F5930;
	sub_82943C20(ctx, base);
	// 828F5930: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828F5934: 48000008  b 0x828f593c
	pc = 0x828F593C; continue 'dispatch;
	// 828F5938: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 828F593C: 93810090  stw r28, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[28].u32 ) };
	// 828F5940: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828F5944: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 828F5948: 4BF71041  bl 0x82866988
	ctx.lr = 0x828F594C;
	sub_82866988(ctx, base);
	// 828F594C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F5950: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828F5954: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 828F5958: 4B9CA6A9  bl 0x822c0000
	ctx.lr = 0x828F595C;
	sub_822C0000(ctx, base);
	// 828F595C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 828F5960: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 828F5964: 4BF72A6D  bl 0x828683d0
	ctx.lr = 0x828F5968;
	sub_828683D0(ctx, base);
	// 828F5968: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F596C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828F5970: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F5974: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F5978: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F597C: 419A0024  beq cr6, 0x828f59a0
	if ctx.cr[6].eq {
	pc = 0x828F59A0; continue 'dispatch;
	}
	// 828F5980: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828F5984: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828F5988: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F598C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828F5990: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828F5994: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F5998: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F599C: 4082FFE8  bne 0x828f5984
	if !ctx.cr[0].eq {
	pc = 0x828F5984; continue 'dispatch;
	}
	// 828F59A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F59A4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F59A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F59AC: 48015B3D  bl 0x8290b4e8
	ctx.lr = 0x828F59B0;
	sub_8290B4E8(ctx, base);
	// 828F59B0: 8061011C  lwz r3, 0x11c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	// 828F59B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F59B8: 419A0008  beq cr6, 0x828f59c0
	if ctx.cr[6].eq {
	pc = 0x828F59C0; continue 'dispatch;
	}
	// 828F59BC: 4B9CAED5  bl 0x822c0890
	ctx.lr = 0x828F59C0;
	sub_822C0890(ctx, base);
	// 828F59C0: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 828F59C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F59C8: 419A0008  beq cr6, 0x828f59d0
	if ctx.cr[6].eq {
	pc = 0x828F59D0; continue 'dispatch;
	}
	// 828F59CC: 4B9CAEC5  bl 0x822c0890
	ctx.lr = 0x828F59D0;
	sub_822C0890(ctx, base);
	// 828F59D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F59D4: C03A004C  lfs f1, 0x4c(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F59D8: 48018A79  bl 0x8290e450
	ctx.lr = 0x828F59DC;
	sub_8290E450(ctx, base);
	// 828F59DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F59E0: 4BEF6781  bl 0x827ec160
	ctx.lr = 0x828F59E4;
	sub_827EC160(ctx, base);
	// 828F59E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F59E8: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 828F59EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F59F0: 4E800421  bctrl
	ctx.lr = 0x828F59F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F59F4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F59F8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828F59FC: C09A0014  lfs f4, 0x14(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 828F5A00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F5A04: C07A0010  lfs f3, 0x10(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828F5A08: C05A000C  lfs f2, 0xc(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828F5A0C: C03B0000  lfs f1, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F5A10: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F5A14: C00AFD2C  lfs f0, -0x2d4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-724 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F5A18: ECAD002A  fadds f5, f13, f0
	ctx.f[5].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 828F5A1C: 4801A88D  bl 0x829102a8
	ctx.lr = 0x828F5A20;
	sub_829102A8(ctx, base);
	// 828F5A20: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828F5A24: 48049545  bl 0x8293ef68
	ctx.lr = 0x828F5A28;
	sub_8293EF68(ctx, base);
	// 828F5A28: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828F5A2C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F5A30: 38A00175  li r5, 0x175
	ctx.r[5].s64 = 373;
	// 828F5A34: 386000A0  li r3, 0xa0
	ctx.r[3].s64 = 160;
	// 828F5A38: 4B9CA9A1  bl 0x822c03d8
	ctx.lr = 0x828F5A3C;
	sub_822C03D8(ctx, base);
	// 828F5A3C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F5A40: 41820024  beq 0x828f5a64
	if ctx.cr[0].eq {
	pc = 0x828F5A64; continue 'dispatch;
	}
	// 828F5A44: 2B110000  cmplwi cr6, r17, 0
	ctx.cr[6].compare_u32(ctx.r[17].u32, 0 as u32, &mut ctx.xer);
	// 828F5A48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F5A4C: 409A0008  bne cr6, 0x828f5a54
	if !ctx.cr[6].eq {
	pc = 0x828F5A54; continue 'dispatch;
	}
	// 828F5A50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F5A54: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 828F5A58: 4804A679  bl 0x829400d0
	ctx.lr = 0x828F5A5C;
	sub_829400D0(ctx, base);
	// 828F5A5C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F5A60: 48000008  b 0x828f5a68
	pc = 0x828F5A68; continue 'dispatch;
	// 828F5A64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F5A68: 387D0370  addi r3, r29, 0x370
	ctx.r[3].s64 = ctx.r[29].s64 + 880;
	// 828F5A6C: 4BF729DD  bl 0x82868448
	ctx.lr = 0x828F5A70;
	sub_82868448(ctx, base);
	// 828F5A70: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F5A74: 4BEF66ED  bl 0x827ec160
	ctx.lr = 0x828F5A78;
	sub_827EC160(ctx, base);
	// 828F5A78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F5A7C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 828F5A80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F5A84: 4E800421  bctrl
	ctx.lr = 0x828F5A88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F5A88: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F5A8C: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 828F5A90: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 828F5A94: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 828F5A98: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F5A9C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828F5AA0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F5AA4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828F5AA8: 4200FFF0  bdnz 0x828f5a98
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828F5A98; continue 'dispatch;
	}
	// 828F5AAC: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828F5AB0: 4825D921  bl 0x82b533d0
	ctx.lr = 0x828F5AB4;
	sub_82B533D0(ctx, base);
	// 828F5AB4: 39600015  li r11, 0x15
	ctx.r[11].s64 = 21;
	// 828F5AB8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F5ABC: C00100A0  lfs f0, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F5AC0: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 828F5AC4: D3E100EC  stfs f31, 0xec(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 828F5AC8: D00100E4  stfs f0, 0xe4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 828F5ACC: 93C100C0  stw r30, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 828F5AD0: 914100E8  stw r10, 0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[10].u32 ) };
	// 828F5AD4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F5AD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5ADC: 388BB334  addi r4, r11, -0x4ccc
	ctx.r[4].s64 = ctx.r[11].s64 + -19660;
	// 828F5AE0: 839D0260  lwz r28, 0x260(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(608 as u32) ) } as u64;
	// 828F5AE4: 484FDF25  bl 0x82df3a08
	ctx.lr = 0x828F5AE8;
	sub_82DF3A08(ctx, base);
	// 828F5AE8: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 828F5AEC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F5AF0: 38E100C0  addi r7, r1, 0xc0
	ctx.r[7].s64 = ctx.r[1].s64 + 192;
	// 828F5AF4: 7E86A378  mr r6, r20
	ctx.r[6].u64 = ctx.r[20].u64;
	// 828F5AF8: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 828F5AFC: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 828F5B00: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 828F5B04: 4801E145  bl 0x82913c48
	ctx.lr = 0x828F5B08;
	sub_82913C48(ctx, base);
	// 828F5B08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5B0C: 484FD91D  bl 0x82df3428
	ctx.lr = 0x828F5B10;
	sub_82DF3428(ctx, base);
	// 828F5B10: 3D60828D  lis r11, -0x7d73
	ctx.r[11].s64 = -2104688640;
	// 828F5B14: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F5B18: 932100A8  stw r25, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[25].u32 ) };
	// 828F5B1C: 396BF2A8  addi r11, r11, -0xd58
	ctx.r[11].s64 = ctx.r[11].s64 + -3416;
	// 828F5B20: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828F5B24: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828F5B28: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828F5B2C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828F5B30: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 828F5B34: 4BFFEE5D  bl 0x828f4990
	ctx.lr = 0x828F5B38;
	sub_828F4990(ctx, base);
	// 828F5B38: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F5B3C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828F5B40: 4801CDD9  bl 0x82912918
	ctx.lr = 0x828F5B44;
	sub_82912918(ctx, base);
	// 828F5B44: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F5B48: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F5B4C: 388BAC10  addi r4, r11, -0x53f0
	ctx.r[4].s64 = ctx.r[11].s64 + -21488;
	// 828F5B50: 4801C661  bl 0x829121b0
	ctx.lr = 0x828F5B54;
	sub_829121B0(ctx, base);
	// 828F5B54: 817D037C  lwz r11, 0x37c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(892 as u32) ) } as u64;
	// 828F5B58: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828F5B5C: 419A0034  beq cr6, 0x828f5b90
	if ctx.cr[6].eq {
	pc = 0x828F5B90; continue 'dispatch;
	}
	// 828F5B60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5B64: 80970AF0  lwz r4, 0xaf0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(2800 as u32) ) } as u64;
	// 828F5B68: 484FDEA1  bl 0x82df3a08
	ctx.lr = 0x828F5B6C;
	sub_82DF3A08(ctx, base);
	// 828F5B6C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F5B70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F5B74: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F5B78: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 828F5B7C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F5B80: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828F5B84: 48568DDD  bl 0x82e5e960
	ctx.lr = 0x828F5B88;
	sub_82E5E960(ctx, base);
	// 828F5B88: 80610104  lwz r3, 0x104(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 828F5B8C: 48000030  b 0x828f5bbc
	pc = 0x828F5BBC; continue 'dispatch;
	// 828F5B90: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828F5B94: 8096B408  lwz r4, -0x4bf8(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(-19448 as u32) ) } as u64;
	// 828F5B98: 484FDE71  bl 0x82df3a08
	ctx.lr = 0x828F5B9C;
	sub_82DF3A08(ctx, base);
	// 828F5B9C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F5BA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F5BA4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F5BA8: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 828F5BAC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F5BB0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828F5BB4: 48568DAD  bl 0x82e5e960
	ctx.lr = 0x828F5BB8;
	sub_82E5E960(ctx, base);
	// 828F5BB8: 80610114  lwz r3, 0x114(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 828F5BBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F5BC0: 419A0008  beq cr6, 0x828f5bc8
	if ctx.cr[6].eq {
	pc = 0x828F5BC8; continue 'dispatch;
	}
	// 828F5BC4: 4B9CACCD  bl 0x822c0890
	ctx.lr = 0x828F5BC8;
	sub_822C0890(ctx, base);
	// 828F5BC8: 382101C0  addi r1, r1, 0x1c0
	ctx.r[1].s64 = ctx.r[1].s64 + 448;
	// 828F5BCC: CBC1FF60  lfd f30, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 828F5BD0: CBE1FF68  lfd f31, -0x98(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 828F5BD4: 488B25B0  b 0x831a8184
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F5BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F5BD8 size=60
    let mut pc: u32 = 0x828F5BD8;
    'dispatch: loop {
        match pc {
            0x828F5BD8 => {
    //   block [0x828F5BD8..0x828F5C14)
	// 828F5BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F5BDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F5BE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F5BE4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F5BE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F5BEC: 4801F9B5  bl 0x829155a0
	ctx.lr = 0x828F5BF0;
	sub_829155A0(ctx, base);
	// 828F5BF0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F5BF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F5BF8: 396B2FFC  addi r11, r11, 0x2ffc
	ctx.r[11].s64 = ctx.r[11].s64 + 12284;
	// 828F5BFC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F5C00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F5C04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F5C08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F5C0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F5C10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F5C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F5C18 size=88
    let mut pc: u32 = 0x828F5C18;
    'dispatch: loop {
        match pc {
            0x828F5C18 => {
    //   block [0x828F5C18..0x828F5C70)
	// 828F5C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F5C1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F5C20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F5C24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F5C28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F5C2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F5C30: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F5C34: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F5C38: 396B2FFC  addi r11, r11, 0x2ffc
	ctx.r[11].s64 = ctx.r[11].s64 + 12284;
	// 828F5C3C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F5C40: 4801F949  bl 0x82915588
	ctx.lr = 0x828F5C44;
	sub_82915588(ctx, base);
	// 828F5C44: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F5C48: 4182000C  beq 0x828f5c54
	if ctx.cr[0].eq {
	pc = 0x828F5C54; continue 'dispatch;
	}
	// 828F5C4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F5C50: 4B9CA619  bl 0x822c0268
	ctx.lr = 0x828F5C54;
	sub_822C0268(ctx, base);
	// 828F5C54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F5C58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F5C5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F5C60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F5C64: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F5C68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F5C6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F5C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F5C70 size=64
    let mut pc: u32 = 0x828F5C70;
    'dispatch: loop {
        match pc {
            0x828F5C70 => {
    //   block [0x828F5C70..0x828F5CB0)
	// 828F5C70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F5C74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F5C78: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F5C7C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828F5C80: 1D44000C  mulli r10, r4, 0xc
	ctx.r[10].s64 = ctx.r[4].s64 * 12;
	// 828F5C84: 396BAC20  addi r11, r11, -0x53e0
	ctx.r[11].s64 = ctx.r[11].s64 + -21472;
	// 828F5C88: 38830004  addi r4, r3, 4
	ctx.r[4].s64 = ctx.r[3].s64 + 4;
	// 828F5C8C: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828F5C90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5C94: 4BF753CD  bl 0x8286b060
	ctx.lr = 0x828F5C98;
	sub_8286B060(ctx, base);
	// 828F5C98: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F5C9C: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F5CA0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F5CA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F5CA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F5CAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F5CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F5CB0 size=488
    let mut pc: u32 = 0x828F5CB0;
    'dispatch: loop {
        match pc {
            0x828F5CB0 => {
    //   block [0x828F5CB0..0x828F5E98)
	// 828F5CB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F5CB4: 488B249D  bl 0x831a8150
	ctx.lr = 0x828F5CB8;
	sub_831A8130(ctx, base);
	// 828F5CB8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F5CBC: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 828F5CC0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F5CC4: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 828F5CC8: 4BFFCE21  bl 0x828f2ae8
	ctx.lr = 0x828F5CCC;
	sub_828F2AE8(ctx, base);
	// 828F5CCC: 834D0000  lwz r26, 0(r13)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F5CD0: 3B200014  li r25, 0x14
	ctx.r[25].s64 = 20;
	// 828F5CD4: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828F5CD8: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 828F5CDC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828F5CE0: 7C79D02E  lwzx r3, r25, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 828F5CE4: 485AAA4D  bl 0x82ea0730
	ctx.lr = 0x828F5CE8;
	sub_82EA0730(ctx, base);
	// 828F5CE8: 3AC00020  li r22, 0x20
	ctx.r[22].s64 = 32;
	// 828F5CEC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828F5CF0: B2C30004  sth r22, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[22].u16 ) };
	// 828F5CF4: C1BB0000  lfs f13, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F5CF8: 3BEBAC20  addi r31, r11, -0x53e0
	ctx.r[31].s64 = ctx.r[11].s64 + -21472;
	// 828F5CFC: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F5D00: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 828F5D04: 486244ED  bl 0x82f1a1f0
	ctx.lr = 0x828F5D08;
	sub_82F1A1F0(ctx, base);
	// 828F5D08: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828F5D0C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828F5D10: 4182000C  beq 0x828f5d1c
	if ctx.cr[0].eq {
	pc = 0x828F5D1C; continue 'dispatch;
	}
	// 828F5D14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F5D18: 4B9F2531  bl 0x822e8248
	ctx.lr = 0x828F5D1C;
	sub_822E8248(ctx, base);
	// 828F5D1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F5D20: 839E0000  lwz r28, 0(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F5D24: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 828F5D28: 80970000  lwz r4, 0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F5D2C: 4851F305  bl 0x82e15030
	ctx.lr = 0x828F5D30;
	sub_82E15030(ctx, base);
	// 828F5D30: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828F5D34: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828F5D38: 815C00C8  lwz r10, 0xc8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(200 as u32) ) } as u64;
	// 828F5D3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F5D40: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828F5D44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F5D48: 80CB6820  lwz r6, 0x6820(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26656 as u32) ) } as u64;
	// 828F5D4C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828F5D50: 4E800421  bctrl
	ctx.lr = 0x828F5D54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F5D54: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F5D58: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828F5D5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F5D60: 419A000C  beq cr6, 0x828f5d6c
	if ctx.cr[6].eq {
	pc = 0x828F5D6C; continue 'dispatch;
	}
	// 828F5D64: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828F5D68: 4B9F2501  bl 0x822e8268
	ctx.lr = 0x828F5D6C;
	sub_822E8268(ctx, base);
	// 828F5D6C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F5D70: 3B180004  addi r24, r24, 4
	ctx.r[24].s64 = ctx.r[24].s64 + 4;
	// 828F5D74: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828F5D78: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828F5D7C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828F5D80: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F5D84: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828F5D88: 4BF75399  bl 0x8286b120
	ctx.lr = 0x828F5D8C;
	sub_8286B120(ctx, base);
	// 828F5D8C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828F5D90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F5D94: 4801311D  bl 0x82908eb0
	ctx.lr = 0x828F5D98;
	sub_82908EB0(ctx, base);
	// 828F5D98: 38802012  li r4, 0x2012
	ctx.r[4].s64 = 8210;
	// 828F5D9C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828F5DA0: 4BB99411  bl 0x8248f1b0
	ctx.lr = 0x828F5DA4;
	sub_8248F1B0(ctx, base);
	// 828F5DA4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828F5DA8: 419A000C  beq cr6, 0x828f5db4
	if ctx.cr[6].eq {
	pc = 0x828F5DB4; continue 'dispatch;
	}
	// 828F5DAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F5DB0: 4B9F24B9  bl 0x822e8268
	ctx.lr = 0x828F5DB4;
	sub_822E8268(ctx, base);
	// 828F5DB4: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828F5DB8: 7C79D02E  lwzx r3, r25, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 828F5DBC: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 828F5DC0: 485AA971  bl 0x82ea0730
	ctx.lr = 0x828F5DC4;
	sub_82EA0730(ctx, base);
	// 828F5DC4: B2C30004  sth r22, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[22].u16 ) };
	// 828F5DC8: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F5DCC: C1BB0000  lfs f13, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F5DD0: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 828F5DD4: 4862441D  bl 0x82f1a1f0
	ctx.lr = 0x828F5DD8;
	sub_82F1A1F0(ctx, base);
	// 828F5DD8: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 828F5DDC: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828F5DE0: 4182000C  beq 0x828f5dec
	if ctx.cr[0].eq {
	pc = 0x828F5DEC; continue 'dispatch;
	}
	// 828F5DE4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F5DE8: 4B9F2461  bl 0x822e8248
	ctx.lr = 0x828F5DEC;
	sub_822E8248(ctx, base);
	// 828F5DEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F5DF0: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F5DF4: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 828F5DF8: 80970000  lwz r4, 0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F5DFC: 4851F235  bl 0x82e15030
	ctx.lr = 0x828F5E00;
	sub_82E15030(ctx, base);
	// 828F5E00: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828F5E04: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828F5E08: 815D00C8  lwz r10, 0xc8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(200 as u32) ) } as u64;
	// 828F5E0C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828F5E10: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 828F5E14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F5E18: 80CB681C  lwz r6, 0x681c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26652 as u32) ) } as u64;
	// 828F5E1C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828F5E20: 4E800421  bctrl
	ctx.lr = 0x828F5E24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F5E24: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F5E28: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F5E2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F5E30: 419A000C  beq cr6, 0x828f5e3c
	if ctx.cr[6].eq {
	pc = 0x828F5E3C; continue 'dispatch;
	}
	// 828F5E34: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828F5E38: 4B9F2431  bl 0x822e8268
	ctx.lr = 0x828F5E3C;
	sub_822E8268(ctx, base);
	// 828F5E3C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F5E40: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828F5E44: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 828F5E48: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 828F5E4C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F5E50: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828F5E54: 4BF752CD  bl 0x8286b120
	ctx.lr = 0x828F5E58;
	sub_8286B120(ctx, base);
	// 828F5E58: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F5E5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F5E60: 48013051  bl 0x82908eb0
	ctx.lr = 0x828F5E64;
	sub_82908EB0(ctx, base);
	// 828F5E64: 38802012  li r4, 0x2012
	ctx.r[4].s64 = 8210;
	// 828F5E68: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828F5E6C: 4BB99345  bl 0x8248f1b0
	ctx.lr = 0x828F5E70;
	sub_8248F1B0(ctx, base);
	// 828F5E70: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828F5E74: 419A000C  beq cr6, 0x828f5e80
	if ctx.cr[6].eq {
	pc = 0x828F5E80; continue 'dispatch;
	}
	// 828F5E78: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F5E7C: 4B9F23ED  bl 0x822e8268
	ctx.lr = 0x828F5E80;
	sub_822E8268(ctx, base);
	// 828F5E80: 80770004  lwz r3, 4(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F5E84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F5E88: 419A0008  beq cr6, 0x828f5e90
	if ctx.cr[6].eq {
	pc = 0x828F5E90; continue 'dispatch;
	}
	// 828F5E8C: 4B9CAA05  bl 0x822c0890
	ctx.lr = 0x828F5E90;
	sub_822C0890(ctx, base);
	// 828F5E90: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828F5E94: 488B230C  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F5E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F5E98 size=60
    let mut pc: u32 = 0x828F5E98;
    'dispatch: loop {
        match pc {
            0x828F5E98 => {
    //   block [0x828F5E98..0x828F5ED4)
	// 828F5E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F5E9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F5EA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F5EA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F5EA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F5EAC: 4802102D  bl 0x82916ed8
	ctx.lr = 0x828F5EB0;
	sub_82916ED8(ctx, base);
	// 828F5EB0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F5EB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F5EB8: 396B3034  addi r11, r11, 0x3034
	ctx.r[11].s64 = ctx.r[11].s64 + 12340;
	// 828F5EBC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F5EC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F5EC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F5EC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F5ECC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F5ED0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F5ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F5ED8 size=88
    let mut pc: u32 = 0x828F5ED8;
    'dispatch: loop {
        match pc {
            0x828F5ED8 => {
    //   block [0x828F5ED8..0x828F5F30)
	// 828F5ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F5EDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F5EE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F5EE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F5EE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F5EEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F5EF0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F5EF4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F5EF8: 396B3034  addi r11, r11, 0x3034
	ctx.r[11].s64 = ctx.r[11].s64 + 12340;
	// 828F5EFC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F5F00: 48020C69  bl 0x82916b68
	ctx.lr = 0x828F5F04;
	sub_82916B68(ctx, base);
	// 828F5F04: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F5F08: 4182000C  beq 0x828f5f14
	if ctx.cr[0].eq {
	pc = 0x828F5F14; continue 'dispatch;
	}
	// 828F5F0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F5F10: 4B9CA359  bl 0x822c0268
	ctx.lr = 0x828F5F14;
	sub_822C0268(ctx, base);
	// 828F5F14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F5F18: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F5F1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F5F20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F5F24: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F5F28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F5F2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F5F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F5F30 size=152
    let mut pc: u32 = 0x828F5F30;
    'dispatch: loop {
        match pc {
            0x828F5F30 => {
    //   block [0x828F5F30..0x828F5FC8)
	// 828F5F30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F5F34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F5F38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F5F3C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F5F40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F5F44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F5F48: 48020E51  bl 0x82916d98
	ctx.lr = 0x828F5F4C;
	sub_82916D98(ctx, base);
	// 828F5F4C: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F5F50: 396000D0  li r11, 0xd0
	ctx.r[11].s64 = 208;
	// 828F5F54: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 828F5F58: 13E958C7  vcmpequd (lvx128) v31, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F5FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828F5FC8 size=40
    let mut pc: u32 = 0x828F5FC8;
    'dispatch: loop {
        match pc {
            0x828F5FC8 => {
    //   block [0x828F5FC8..0x828F5FF0)
	// 828F5FC8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F5FCC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828F5FD0: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 828F5FD4: C00B093C  lfs f0, 0x93c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F5FD8: C1AA9584  lfs f13, -0x6a7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F5FDC: C1896150  lfs f12, 0x6150(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24912 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828F5FE0: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828F5FE4: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828F5FE8: D1830008  stfs f12, 8(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 828F5FEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F5FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828F5FF0 size=16
    let mut pc: u32 = 0x828F5FF0;
    'dispatch: loop {
        match pc {
            0x828F5FF0 => {
    //   block [0x828F5FF0..0x828F6000)
	// 828F5FF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F5FF4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F5FF8: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828F5FFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F6000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F6000 size=140
    let mut pc: u32 = 0x828F6000;
    'dispatch: loop {
        match pc {
            0x828F6000 => {
    //   block [0x828F6000..0x828F608C)
	// 828F6000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F6004: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F6008: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F600C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F6010: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F6014: 48061BE5  bl 0x82957bf8
	ctx.lr = 0x828F6018;
	sub_82957BF8(ctx, base);
	// 828F6018: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828F601C: 4805F77D  bl 0x82955798
	ctx.lr = 0x828F6020;
	sub_82955798(ctx, base);
	// 828F6020: 387F003C  addi r3, r31, 0x3c
	ctx.r[3].s64 = ctx.r[31].s64 + 60;
	// 828F6024: 48048F45  bl 0x8293ef68
	ctx.lr = 0x828F6028;
	sub_8293EF68(ctx, base);
	// 828F6028: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 828F602C: 4804AFAD  bl 0x82940fd8
	ctx.lr = 0x828F6030;
	sub_82940FD8(ctx, base);
	// 828F6030: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 828F6034: 4804CF1D  bl 0x82942f50
	ctx.lr = 0x828F6038;
	sub_82942F50(ctx, base);
	// 828F6038: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F603C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828F6040: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828F6044: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F6048: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F604C: C1AA9590  lfs f13, -0x6a70(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F6050: C1899524  lfs f12, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828F6054: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 828F6058: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 828F605C: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828F6060: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 828F6064: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 828F6068: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 828F606C: D1BF0030  stfs f13, 0x30(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 828F6070: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828F6074: D19F0058  stfs f12, 0x58(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828F6078: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F607C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F6080: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F6084: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F6088: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F6090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F6090 size=388
    let mut pc: u32 = 0x828F6090;
    'dispatch: loop {
        match pc {
            0x828F6090 => {
    //   block [0x828F6090..0x828F6214)
	// 828F6090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F6094: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F6098: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F609C: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 828F60A0: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828F60A4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F60A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F60AC: 387F004C  addi r3, r31, 0x4c
	ctx.r[3].s64 = ctx.r[31].s64 + 76;
	// 828F60B0: 48063E61  bl 0x82959f10
	ctx.lr = 0x828F60B4;
	sub_82959F10(ctx, base);
	// 828F60B4: 387F00C4  addi r3, r31, 0xc4
	ctx.r[3].s64 = ctx.r[31].s64 + 196;
	// 828F60B8: 4804D2A1  bl 0x82943358
	ctx.lr = 0x828F60BC;
	sub_82943358(ctx, base);
	// 828F60BC: 387F00D4  addi r3, r31, 0xd4
	ctx.r[3].s64 = ctx.r[31].s64 + 212;
	// 828F60C0: 4804B371  bl 0x82941430
	ctx.lr = 0x828F60C4;
	sub_82941430(ctx, base);
	// 828F60C4: 387F00F0  addi r3, r31, 0xf0
	ctx.r[3].s64 = ctx.r[31].s64 + 240;
	// 828F60C8: 4804C829  bl 0x829428f0
	ctx.lr = 0x828F60CC;
	sub_829428F0(ctx, base);
	// 828F60CC: 387F0100  addi r3, r31, 0x100
	ctx.r[3].s64 = ctx.r[31].s64 + 256;
	// 828F60D0: 4BFFFF31  bl 0x828f6000
	ctx.lr = 0x828F60D4;
	sub_828F6000(ctx, base);
	// 828F60D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F60D8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828F60DC: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 828F60E0: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 828F60E4: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 828F60E8: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F60EC: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828F60F0: C1699450  lfs f11, -0x6bb0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828F60F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828F60F8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828F60FC: C1886154  lfs f12, 0x6154(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24916 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828F6100: C147A1C4  lfs f10, -0x5e3c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828F6104: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 828F6108: C1069D1C  lfs f8, -0x62e4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-25316 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 828F610C: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 828F6110: 3CC08203  lis r6, -0x7dfd
	ctx.r[6].s64 = -2113732608;
	// 828F6114: C1AA89AC  lfs f13, -0x7654(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F6118: C0EBFD2C  lfs f7, -0x2d4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-724 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 828F611C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828F6120: C0A99C28  lfs f5, -0x63d8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-25560 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 828F6124: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828F6128: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 828F612C: C088E830  lfs f4, -0x17d0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 828F6130: C0679590  lfs f3, -0x6a70(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27248 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828F6134: 3CA08201  lis r5, -0x7dff
	ctx.r[5].s64 = -2113863680;
	// 828F6138: C0467A10  lfs f2, 0x7a10(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(31248 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828F613C: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 828F6140: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 828F6144: C0CAA2EC  lfs f6, -0x5d14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-23828 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 828F6148: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 828F614C: C02B959C  lfs f1, -0x6a64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F6150: C129614C  lfs f9, 0x614c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24908 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 828F6154: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F6158: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 828F615C: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828F6160: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828F6164: D1BF0020  stfs f13, 0x20(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 828F6168: D1BF0028  stfs f13, 0x28(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 828F616C: 995F00A4  stb r10, 0xa4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[10].u8 ) };
	// 828F6170: C3E50A98  lfs f31, 0xa98(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(2712 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828F6174: 993F0094  stb r9, 0x94(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[9].u8 ) };
	// 828F6178: C3C86150  lfs f30, 0x6150(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24912 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828F617C: 995F00B4  stb r10, 0xb4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[10].u8 ) };
	// 828F6180: C1A7C664  lfs f13, -0x399c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-14748 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F6184: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828F6188: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 828F618C: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F6190: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 828F6194: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 828F6198: C0069524  lfs f0, -0x6adc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F619C: D17F0004  stfs f11, 4(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828F61A0: D17F0008  stfs f11, 8(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 828F61A4: D19F0010  stfs f12, 0x10(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 828F61A8: D19F0014  stfs f12, 0x14(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 828F61AC: D15F0018  stfs f10, 0x18(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828F61B0: D15F001C  stfs f10, 0x1c(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 828F61B4: D11F0024  stfs f8, 0x24(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 828F61B8: D0FF002C  stfs f7, 0x2c(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 828F61BC: D0DF0030  stfs f6, 0x30(r31)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 828F61C0: D0BF0034  stfs f5, 0x34(r31)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 828F61C4: D09F0038  stfs f4, 0x38(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 828F61C8: D07F0040  stfs f3, 0x40(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 828F61CC: D05F0048  stfs f2, 0x48(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 828F61D0: D03F00C8  stfs f1, 0xc8(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 828F61D4: D3FF00C4  stfs f31, 0xc4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 828F61D8: D13F00D4  stfs f9, 0xd4(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 828F61DC: D19F00D8  stfs f12, 0xd8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 828F61E0: D3DF00DC  stfs f30, 0xdc(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 828F61E4: D13F00F0  stfs f9, 0xf0(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 828F61E8: D1BF00F4  stfs f13, 0xf4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 828F61EC: D01F00F8  stfs f0, 0xf8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 828F61F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F61F4: D01F00FC  stfs f0, 0xfc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 828F61F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F61FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F6200: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F6204: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828F6208: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F620C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F6210: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F6218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F6218 size=1272
    let mut pc: u32 = 0x828F6218;
    'dispatch: loop {
        match pc {
            0x828F6218 => {
    //   block [0x828F6218..0x828F6710)
	// 828F6218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F621C: 488B1F4D  bl 0x831a8168
	ctx.lr = 0x828F6220;
	sub_831A8130(ctx, base);
	// 828F6220: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 828F6224: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 828F6228: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828F622C: 9421FDD0  stwu r1, -0x230(r1)
	ea = ctx.r[1].u32.wrapping_add(-560 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F6230: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 828F6234: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F6238: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F623C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828F6240: 388B7A1C  addi r4, r11, 0x7a1c
	ctx.r[4].s64 = ctx.r[11].s64 + 31260;
	// 828F6244: 484FD7C5  bl 0x82df3a08
	ctx.lr = 0x828F6248;
	sub_82DF3A08(ctx, base);
	// 828F6248: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F624C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F6250: 388B1A04  addi r4, r11, 0x1a04
	ctx.r[4].s64 = ctx.r[11].s64 + 6660;
	// 828F6254: 484FD7B5  bl 0x82df3a08
	ctx.lr = 0x828F6258;
	sub_82DF3A08(ctx, base);
	// 828F6258: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F625C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F6260: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 828F6264: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F6268: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828F626C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828F6270: 419A0024  beq cr6, 0x828f6294
	if ctx.cr[6].eq {
	pc = 0x828F6294; continue 'dispatch;
	}
	// 828F6274: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828F6278: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828F627C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F6280: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828F6284: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828F6288: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F628C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F6290: 4082FFE8  bne 0x828f6278
	if !ctx.cr[0].eq {
	pc = 0x828F6278; continue 'dispatch;
	}
	// 828F6294: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 828F6298: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828F629C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F62A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F62A4: 4806196D  bl 0x82957c10
	ctx.lr = 0x828F62A8;
	sub_82957C10(ctx, base);
	// 828F62A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F62AC: 484FD17D  bl 0x82df3428
	ctx.lr = 0x828F62B0;
	sub_82DF3428(ctx, base);
	// 828F62B0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828F62B4: 484FD175  bl 0x82df3428
	ctx.lr = 0x828F62B8;
	sub_82DF3428(ctx, base);
	// 828F62B8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F62BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F62C0: 388B340C  addi r4, r11, 0x340c
	ctx.r[4].s64 = ctx.r[11].s64 + 13324;
	// 828F62C4: 484FD745  bl 0x82df3a08
	ctx.lr = 0x828F62C8;
	sub_82DF3A08(ctx, base);
	// 828F62C8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F62CC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828F62D0: 388B33FC  addi r4, r11, 0x33fc
	ctx.r[4].s64 = ctx.r[11].s64 + 13308;
	// 828F62D4: 484FD735  bl 0x82df3a08
	ctx.lr = 0x828F62D8;
	sub_82DF3A08(ctx, base);
	// 828F62D8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828F62DC: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828F62E0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F62E4: 4BCD421D  bl 0x825ca500
	ctx.lr = 0x828F62E8;
	sub_825CA500(ctx, base);
	// 828F62E8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828F62EC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828F62F0: 484FD139  bl 0x82df3428
	ctx.lr = 0x828F62F4;
	sub_82DF3428(ctx, base);
	// 828F62F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F62F8: 484FD131  bl 0x82df3428
	ctx.lr = 0x828F62FC;
	sub_82DF3428(ctx, base);
	// 828F62FC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6300: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6304: 388B1AD0  addi r4, r11, 0x1ad0
	ctx.r[4].s64 = ctx.r[11].s64 + 6864;
	// 828F6308: 484FD701  bl 0x82df3a08
	ctx.lr = 0x828F630C;
	sub_82DF3A08(ctx, base);
	// 828F630C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6310: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6314: 388B1ABC  addi r4, r11, 0x1abc
	ctx.r[4].s64 = ctx.r[11].s64 + 6844;
	// 828F6318: 484FD6F1  bl 0x82df3a08
	ctx.lr = 0x828F631C;
	sub_82DF3A08(ctx, base);
	// 828F631C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828F6320: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828F6324: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828F6328: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 828F632C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F6330: C3EB9528  lfs f31, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828F6334: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828F6338: C3CA89AC  lfs f30, -0x7654(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828F633C: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828F6340: C3A9964C  lfs f29, -0x69b4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828F6344: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828F6348: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828F634C: 4BCACF5D  bl 0x825a32a8
	ctx.lr = 0x828F6350;
	sub_825A32A8(ctx, base);
	// 828F6350: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F6354: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F6358: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F635C: 4BCAB415  bl 0x825a1770
	ctx.lr = 0x828F6360;
	sub_825A1770(ctx, base);
	// 828F6360: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 828F6364: 484FD0C5  bl 0x82df3428
	ctx.lr = 0x828F6368;
	sub_82DF3428(ctx, base);
	// 828F6368: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828F636C: 4B9D294D  bl 0x822c8cb8
	ctx.lr = 0x828F6370;
	sub_822C8CB8(ctx, base);
	// 828F6370: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6374: 484FD0B5  bl 0x82df3428
	ctx.lr = 0x828F6378;
	sub_82DF3428(ctx, base);
	// 828F6378: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F637C: 484FD0AD  bl 0x82df3428
	ctx.lr = 0x828F6380;
	sub_82DF3428(ctx, base);
	// 828F6380: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6384: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6388: 388B1AA0  addi r4, r11, 0x1aa0
	ctx.r[4].s64 = ctx.r[11].s64 + 6816;
	// 828F638C: 484FD67D  bl 0x82df3a08
	ctx.lr = 0x828F6390;
	sub_82DF3A08(ctx, base);
	// 828F6390: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6394: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6398: 388B1A88  addi r4, r11, 0x1a88
	ctx.r[4].s64 = ctx.r[11].s64 + 6792;
	// 828F639C: 484FD66D  bl 0x82df3a08
	ctx.lr = 0x828F63A0;
	sub_82DF3A08(ctx, base);
	// 828F63A0: 38BF0014  addi r5, r31, 0x14
	ctx.r[5].s64 = ctx.r[31].s64 + 20;
	// 828F63A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F63A8: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828F63AC: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828F63B0: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828F63B4: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828F63B8: 4BCACEF1  bl 0x825a32a8
	ctx.lr = 0x828F63BC;
	sub_825A32A8(ctx, base);
	// 828F63BC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F63C0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F63C4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F63C8: 4BCAB3A9  bl 0x825a1770
	ctx.lr = 0x828F63CC;
	sub_825A1770(ctx, base);
	// 828F63CC: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 828F63D0: 484FD059  bl 0x82df3428
	ctx.lr = 0x828F63D4;
	sub_82DF3428(ctx, base);
	// 828F63D4: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 828F63D8: 4B9D28E1  bl 0x822c8cb8
	ctx.lr = 0x828F63DC;
	sub_822C8CB8(ctx, base);
	// 828F63DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F63E0: 484FD049  bl 0x82df3428
	ctx.lr = 0x828F63E4;
	sub_82DF3428(ctx, base);
	// 828F63E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F63E8: 484FD041  bl 0x82df3428
	ctx.lr = 0x828F63EC;
	sub_82DF3428(ctx, base);
	// 828F63EC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F63F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F63F4: 388B1A6C  addi r4, r11, 0x1a6c
	ctx.r[4].s64 = ctx.r[11].s64 + 6764;
	// 828F63F8: 484FD611  bl 0x82df3a08
	ctx.lr = 0x828F63FC;
	sub_82DF3A08(ctx, base);
	// 828F63FC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6400: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6404: 388B1A58  addi r4, r11, 0x1a58
	ctx.r[4].s64 = ctx.r[11].s64 + 6744;
	// 828F6408: 484FD601  bl 0x82df3a08
	ctx.lr = 0x828F640C;
	sub_82DF3A08(ctx, base);
	// 828F640C: 38BF0018  addi r5, r31, 0x18
	ctx.r[5].s64 = ctx.r[31].s64 + 24;
	// 828F6410: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F6414: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828F6418: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 828F641C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828F6420: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828F6424: 4BCACE85  bl 0x825a32a8
	ctx.lr = 0x828F6428;
	sub_825A32A8(ctx, base);
	// 828F6428: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F642C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F6430: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F6434: 4BCAB33D  bl 0x825a1770
	ctx.lr = 0x828F6438;
	sub_825A1770(ctx, base);
	// 828F6438: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 828F643C: 484FCFED  bl 0x82df3428
	ctx.lr = 0x828F6440;
	sub_82DF3428(ctx, base);
	// 828F6440: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 828F6444: 4B9D2875  bl 0x822c8cb8
	ctx.lr = 0x828F6448;
	sub_822C8CB8(ctx, base);
	// 828F6448: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F644C: 484FCFDD  bl 0x82df3428
	ctx.lr = 0x828F6450;
	sub_82DF3428(ctx, base);
	// 828F6450: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6454: 484FCFD5  bl 0x82df3428
	ctx.lr = 0x828F6458;
	sub_82DF3428(ctx, base);
	// 828F6458: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F645C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6460: 388B1A3C  addi r4, r11, 0x1a3c
	ctx.r[4].s64 = ctx.r[11].s64 + 6716;
	// 828F6464: 484FD5A5  bl 0x82df3a08
	ctx.lr = 0x828F6468;
	sub_82DF3A08(ctx, base);
	// 828F6468: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F646C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6470: 388B1A24  addi r4, r11, 0x1a24
	ctx.r[4].s64 = ctx.r[11].s64 + 6692;
	// 828F6474: 484FD595  bl 0x82df3a08
	ctx.lr = 0x828F6478;
	sub_82DF3A08(ctx, base);
	// 828F6478: 38BF001C  addi r5, r31, 0x1c
	ctx.r[5].s64 = ctx.r[31].s64 + 28;
	// 828F647C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F6480: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828F6484: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828F6488: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828F648C: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828F6490: 4BCACE19  bl 0x825a32a8
	ctx.lr = 0x828F6494;
	sub_825A32A8(ctx, base);
	// 828F6494: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F6498: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F649C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F64A0: 4BCAB2D1  bl 0x825a1770
	ctx.lr = 0x828F64A4;
	sub_825A1770(ctx, base);
	// 828F64A4: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 828F64A8: 484FCF81  bl 0x82df3428
	ctx.lr = 0x828F64AC;
	sub_82DF3428(ctx, base);
	// 828F64AC: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828F64B0: 4B9D2809  bl 0x822c8cb8
	ctx.lr = 0x828F64B4;
	sub_822C8CB8(ctx, base);
	// 828F64B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F64B8: 484FCF71  bl 0x82df3428
	ctx.lr = 0x828F64BC;
	sub_82DF3428(ctx, base);
	// 828F64BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F64C0: 484FCF69  bl 0x82df3428
	ctx.lr = 0x828F64C4;
	sub_82DF3428(ctx, base);
	// 828F64C4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F64C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F64CC: 388B33E0  addi r4, r11, 0x33e0
	ctx.r[4].s64 = ctx.r[11].s64 + 13280;
	// 828F64D0: 484FD539  bl 0x82df3a08
	ctx.lr = 0x828F64D4;
	sub_82DF3A08(ctx, base);
	// 828F64D4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F64D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F64DC: 388B33C8  addi r4, r11, 0x33c8
	ctx.r[4].s64 = ctx.r[11].s64 + 13256;
	// 828F64E0: 484FD529  bl 0x82df3a08
	ctx.lr = 0x828F64E4;
	sub_82DF3A08(ctx, base);
	// 828F64E4: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 828F64E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F64EC: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828F64F0: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 828F64F4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828F64F8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828F64FC: 4BCACDAD  bl 0x825a32a8
	ctx.lr = 0x828F6500;
	sub_825A32A8(ctx, base);
	// 828F6500: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F6504: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F6508: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F650C: 4BCAB265  bl 0x825a1770
	ctx.lr = 0x828F6510;
	sub_825A1770(ctx, base);
	// 828F6510: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 828F6514: 484FCF15  bl 0x82df3428
	ctx.lr = 0x828F6518;
	sub_82DF3428(ctx, base);
	// 828F6518: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 828F651C: 4B9D279D  bl 0x822c8cb8
	ctx.lr = 0x828F6520;
	sub_822C8CB8(ctx, base);
	// 828F6520: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6524: 484FCF05  bl 0x82df3428
	ctx.lr = 0x828F6528;
	sub_82DF3428(ctx, base);
	// 828F6528: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F652C: 484FCEFD  bl 0x82df3428
	ctx.lr = 0x828F6530;
	sub_82DF3428(ctx, base);
	// 828F6530: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F6534: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6538: 388B33AC  addi r4, r11, 0x33ac
	ctx.r[4].s64 = ctx.r[11].s64 + 13228;
	// 828F653C: 484FD4CD  bl 0x82df3a08
	ctx.lr = 0x828F6540;
	sub_82DF3A08(ctx, base);
	// 828F6540: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F6544: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6548: 388B3394  addi r4, r11, 0x3394
	ctx.r[4].s64 = ctx.r[11].s64 + 13204;
	// 828F654C: 484FD4BD  bl 0x82df3a08
	ctx.lr = 0x828F6550;
	sub_82DF3A08(ctx, base);
	// 828F6550: 38BF0024  addi r5, r31, 0x24
	ctx.r[5].s64 = ctx.r[31].s64 + 36;
	// 828F6554: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F6558: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828F655C: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 828F6560: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828F6564: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828F6568: 4BCACD41  bl 0x825a32a8
	ctx.lr = 0x828F656C;
	sub_825A32A8(ctx, base);
	// 828F656C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F6570: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F6574: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F6578: 4BCAB1F9  bl 0x825a1770
	ctx.lr = 0x828F657C;
	sub_825A1770(ctx, base);
	// 828F657C: 386101E8  addi r3, r1, 0x1e8
	ctx.r[3].s64 = ctx.r[1].s64 + 488;
	// 828F6580: 484FCEA9  bl 0x82df3428
	ctx.lr = 0x828F6584;
	sub_82DF3428(ctx, base);
	// 828F6584: 386101C8  addi r3, r1, 0x1c8
	ctx.r[3].s64 = ctx.r[1].s64 + 456;
	// 828F6588: 4B9D2731  bl 0x822c8cb8
	ctx.lr = 0x828F658C;
	sub_822C8CB8(ctx, base);
	// 828F658C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6590: 484FCE99  bl 0x82df3428
	ctx.lr = 0x828F6594;
	sub_82DF3428(ctx, base);
	// 828F6594: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6598: 484FCE91  bl 0x82df3428
	ctx.lr = 0x828F659C;
	sub_82DF3428(ctx, base);
	// 828F659C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F65A0: 4BCD3731  bl 0x825c9cd0
	ctx.lr = 0x828F65A4;
	sub_825C9CD0(ctx, base);
	// 828F65A4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F65A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F65AC: 388B3378  addi r4, r11, 0x3378
	ctx.r[4].s64 = ctx.r[11].s64 + 13176;
	// 828F65B0: 484FD459  bl 0x82df3a08
	ctx.lr = 0x828F65B4;
	sub_82DF3A08(ctx, base);
	// 828F65B4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F65B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F65BC: 388B3368  addi r4, r11, 0x3368
	ctx.r[4].s64 = ctx.r[11].s64 + 13160;
	// 828F65C0: 484FD449  bl 0x82df3a08
	ctx.lr = 0x828F65C4;
	sub_82DF3A08(ctx, base);
	// 828F65C4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F65C8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F65CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F65D0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 828F65D4: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 828F65D8: 419A0024  beq cr6, 0x828f65fc
	if ctx.cr[6].eq {
	pc = 0x828F65FC; continue 'dispatch;
	}
	// 828F65DC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828F65E0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828F65E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F65E8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828F65EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828F65F0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F65F4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F65F8: 4082FFE8  bne 0x828f65e0
	if !ctx.cr[0].eq {
	pc = 0x828F65E0; continue 'dispatch;
	}
	// 828F65FC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828F6600: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828F6604: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828F6608: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828F660C: 4805FD95  bl 0x829563a0
	ctx.lr = 0x828F6610;
	sub_829563A0(ctx, base);
	// 828F6610: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6614: 484FCE15  bl 0x82df3428
	ctx.lr = 0x828F6618;
	sub_82DF3428(ctx, base);
	// 828F6618: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F661C: 484FCE0D  bl 0x82df3428
	ctx.lr = 0x828F6620;
	sub_82DF3428(ctx, base);
	// 828F6620: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F6624: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F6628: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F662C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828F6630: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828F6634: 419A0024  beq cr6, 0x828f6658
	if ctx.cr[6].eq {
	pc = 0x828F6658; continue 'dispatch;
	}
	// 828F6638: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828F663C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828F6640: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F6644: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828F6648: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828F664C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F6650: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F6654: 4082FFE8  bne 0x828f663c
	if !ctx.cr[0].eq {
	pc = 0x828F663C; continue 'dispatch;
	}
	// 828F6658: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F665C: 387F003C  addi r3, r31, 0x3c
	ctx.r[3].s64 = ctx.r[31].s64 + 60;
	// 828F6660: 48049549  bl 0x8293fba8
	ctx.lr = 0x828F6664;
	sub_8293FBA8(ctx, base);
	// 828F6664: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F6668: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F666C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F6670: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828F6674: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828F6678: 419A0024  beq cr6, 0x828f669c
	if ctx.cr[6].eq {
	pc = 0x828F669C; continue 'dispatch;
	}
	// 828F667C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828F6680: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828F6684: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F6688: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828F668C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828F6690: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F6694: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F6698: 4082FFE8  bne 0x828f6680
	if !ctx.cr[0].eq {
	pc = 0x828F6680; continue 'dispatch;
	}
	// 828F669C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F66A0: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 828F66A4: 4804AD05  bl 0x829413a8
	ctx.lr = 0x828F66A8;
	sub_829413A8(ctx, base);
	// 828F66A8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F66AC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F66B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F66B4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828F66B8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828F66BC: 419A0024  beq cr6, 0x828f66e0
	if ctx.cr[6].eq {
	pc = 0x828F66E0; continue 'dispatch;
	}
	// 828F66C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828F66C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828F66C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F66CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828F66D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828F66D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F66D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F66DC: 4082FFE8  bne 0x828f66c4
	if !ctx.cr[0].eq {
	pc = 0x828F66C4; continue 'dispatch;
	}
	// 828F66E0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F66E4: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 828F66E8: 4804CBE9  bl 0x829432d0
	ctx.lr = 0x828F66EC;
	sub_829432D0(ctx, base);
	// 828F66EC: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F66F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F66F4: 419A0008  beq cr6, 0x828f66fc
	if ctx.cr[6].eq {
	pc = 0x828F66FC; continue 'dispatch;
	}
	// 828F66F8: 4B9CA199  bl 0x822c0890
	ctx.lr = 0x828F66FC;
	sub_822C0890(ctx, base);
	// 828F66FC: 38210230  addi r1, r1, 0x230
	ctx.r[1].s64 = ctx.r[1].s64 + 560;
	// 828F6700: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 828F6704: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828F6708: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828F670C: 488B1AAC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F6710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F6710 size=2600
    let mut pc: u32 = 0x828F6710;
    'dispatch: loop {
        match pc {
            0x828F6710 => {
    //   block [0x828F6710..0x828F7138)
	// 828F6710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F6714: 488B1A59  bl 0x831a816c
	ctx.lr = 0x828F6718;
	sub_831A8130(ctx, base);
	// 828F6718: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 828F671C: 488B2351  bl 0x831a8a6c
	ctx.lr = 0x828F6720;
	sub_831A8A40(ctx, base);
	// 828F6720: 9421FA70  stwu r1, -0x590(r1)
	ea = ctx.r[1].u32.wrapping_add(-1424 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F6724: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6728: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F672C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F6730: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F6734: 388B1F3C  addi r4, r11, 0x1f3c
	ctx.r[4].s64 = ctx.r[11].s64 + 7996;
	// 828F6738: 484FD2D1  bl 0x82df3a08
	ctx.lr = 0x828F673C;
	sub_82DF3A08(ctx, base);
	// 828F673C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6740: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828F6744: 388B1F2C  addi r4, r11, 0x1f2c
	ctx.r[4].s64 = ctx.r[11].s64 + 7980;
	// 828F6748: 484FD2C1  bl 0x82df3a08
	ctx.lr = 0x828F674C;
	sub_82DF3A08(ctx, base);
	// 828F674C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828F6750: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 828F6754: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F6758: 4BCD3DA9  bl 0x825ca500
	ctx.lr = 0x828F675C;
	sub_825CA500(ctx, base);
	// 828F675C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F6760: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828F6764: 484FCCC5  bl 0x82df3428
	ctx.lr = 0x828F6768;
	sub_82DF3428(ctx, base);
	// 828F6768: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F676C: 484FCCBD  bl 0x82df3428
	ctx.lr = 0x828F6770;
	sub_82DF3428(ctx, base);
	// 828F6770: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6774: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6778: 388B1F18  addi r4, r11, 0x1f18
	ctx.r[4].s64 = ctx.r[11].s64 + 7960;
	// 828F677C: 484FD28D  bl 0x82df3a08
	ctx.lr = 0x828F6780;
	sub_82DF3A08(ctx, base);
	// 828F6780: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6784: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6788: 388B1F0C  addi r4, r11, 0x1f0c
	ctx.r[4].s64 = ctx.r[11].s64 + 7948;
	// 828F678C: 484FD27D  bl 0x82df3a08
	ctx.lr = 0x828F6790;
	sub_82DF3A08(ctx, base);
	// 828F6790: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828F6794: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828F6798: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F679C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F67A0: 386103B0  addi r3, r1, 0x3b0
	ctx.r[3].s64 = ctx.r[1].s64 + 944;
	// 828F67A4: C3EB9528  lfs f31, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828F67A8: C36A89AC  lfs f27, -0x7654(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 828F67AC: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828F67B0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F67B4: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 828F67B8: 4BCACAF1  bl 0x825a32a8
	ctx.lr = 0x828F67BC;
	sub_825A32A8(ctx, base);
	// 828F67BC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F67C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F67C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F67C8: 4BCAAFA9  bl 0x825a1770
	ctx.lr = 0x828F67CC;
	sub_825A1770(ctx, base);
	// 828F67CC: 386103E8  addi r3, r1, 0x3e8
	ctx.r[3].s64 = ctx.r[1].s64 + 1000;
	// 828F67D0: 484FCC59  bl 0x82df3428
	ctx.lr = 0x828F67D4;
	sub_82DF3428(ctx, base);
	// 828F67D4: 386103C8  addi r3, r1, 0x3c8
	ctx.r[3].s64 = ctx.r[1].s64 + 968;
	// 828F67D8: 4B9D24E1  bl 0x822c8cb8
	ctx.lr = 0x828F67DC;
	sub_822C8CB8(ctx, base);
	// 828F67DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F67E0: 484FCC49  bl 0x82df3428
	ctx.lr = 0x828F67E4;
	sub_82DF3428(ctx, base);
	// 828F67E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F67E8: 484FCC41  bl 0x82df3428
	ctx.lr = 0x828F67EC;
	sub_82DF3428(ctx, base);
	// 828F67EC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F67F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F67F4: 388B1C34  addi r4, r11, 0x1c34
	ctx.r[4].s64 = ctx.r[11].s64 + 7220;
	// 828F67F8: 484FD211  bl 0x82df3a08
	ctx.lr = 0x828F67FC;
	sub_82DF3A08(ctx, base);
	// 828F67FC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6800: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6804: 388B1C24  addi r4, r11, 0x1c24
	ctx.r[4].s64 = ctx.r[11].s64 + 7204;
	// 828F6808: 484FD201  bl 0x82df3a08
	ctx.lr = 0x828F680C;
	sub_82DF3A08(ctx, base);
	// 828F680C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F6810: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F6814: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828F6818: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 828F681C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F6820: 386104B0  addi r3, r1, 0x4b0
	ctx.r[3].s64 = ctx.r[1].s64 + 1200;
	// 828F6824: C34B08A8  lfs f26, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 828F6828: C3CA08A4  lfs f30, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828F682C: FC40D090  fmr f2, f26
	ctx.f[2].f64 = ctx.f[26].f64;
	// 828F6830: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828F6834: 4BCACA75  bl 0x825a32a8
	ctx.lr = 0x828F6838;
	sub_825A32A8(ctx, base);
	// 828F6838: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F683C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F6840: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F6844: 4BCAAF2D  bl 0x825a1770
	ctx.lr = 0x828F6848;
	sub_825A1770(ctx, base);
	// 828F6848: 386104E8  addi r3, r1, 0x4e8
	ctx.r[3].s64 = ctx.r[1].s64 + 1256;
	// 828F684C: 484FCBDD  bl 0x82df3428
	ctx.lr = 0x828F6850;
	sub_82DF3428(ctx, base);
	// 828F6850: 386104C8  addi r3, r1, 0x4c8
	ctx.r[3].s64 = ctx.r[1].s64 + 1224;
	// 828F6854: 4B9D2465  bl 0x822c8cb8
	ctx.lr = 0x828F6858;
	sub_822C8CB8(ctx, base);
	// 828F6858: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F685C: 484FCBCD  bl 0x82df3428
	ctx.lr = 0x828F6860;
	sub_82DF3428(ctx, base);
	// 828F6860: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6864: 484FCBC5  bl 0x82df3428
	ctx.lr = 0x828F6868;
	sub_82DF3428(ctx, base);
	// 828F6868: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F686C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6870: 388B1C0C  addi r4, r11, 0x1c0c
	ctx.r[4].s64 = ctx.r[11].s64 + 7180;
	// 828F6874: 484FD195  bl 0x82df3a08
	ctx.lr = 0x828F6878;
	sub_82DF3A08(ctx, base);
	// 828F6878: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F687C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6880: 388B1BFC  addi r4, r11, 0x1bfc
	ctx.r[4].s64 = ctx.r[11].s64 + 7164;
	// 828F6884: 484FD185  bl 0x82df3a08
	ctx.lr = 0x828F6888;
	sub_82DF3A08(ctx, base);
	// 828F6888: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 828F688C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F6890: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828F6894: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 828F6898: FC40D090  fmr f2, f26
	ctx.f[2].f64 = ctx.f[26].f64;
	// 828F689C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828F68A0: 4BCACA09  bl 0x825a32a8
	ctx.lr = 0x828F68A4;
	sub_825A32A8(ctx, base);
	// 828F68A4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F68A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F68AC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F68B0: 4BCAAEC1  bl 0x825a1770
	ctx.lr = 0x828F68B4;
	sub_825A1770(ctx, base);
	// 828F68B4: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 828F68B8: 484FCB71  bl 0x82df3428
	ctx.lr = 0x828F68BC;
	sub_82DF3428(ctx, base);
	// 828F68BC: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 828F68C0: 4B9D23F9  bl 0x822c8cb8
	ctx.lr = 0x828F68C4;
	sub_822C8CB8(ctx, base);
	// 828F68C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F68C8: 484FCB61  bl 0x82df3428
	ctx.lr = 0x828F68CC;
	sub_82DF3428(ctx, base);
	// 828F68CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F68D0: 484FCB59  bl 0x82df3428
	ctx.lr = 0x828F68D4;
	sub_82DF3428(ctx, base);
	// 828F68D4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F68D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F68DC: 388B1F00  addi r4, r11, 0x1f00
	ctx.r[4].s64 = ctx.r[11].s64 + 7936;
	// 828F68E0: 484FD129  bl 0x82df3a08
	ctx.lr = 0x828F68E4;
	sub_82DF3A08(ctx, base);
	// 828F68E4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F68E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F68EC: 388B1EF4  addi r4, r11, 0x1ef4
	ctx.r[4].s64 = ctx.r[11].s64 + 7924;
	// 828F68F0: 484FD119  bl 0x82df3a08
	ctx.lr = 0x828F68F4;
	sub_82DF3A08(ctx, base);
	// 828F68F4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828F68F8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828F68FC: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828F6900: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 828F6904: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F6908: 38610330  addi r3, r1, 0x330
	ctx.r[3].s64 = ctx.r[1].s64 + 816;
	// 828F690C: C38B6218  lfs f28, 0x6218(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 828F6910: C3AA964C  lfs f29, -0x69b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828F6914: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 828F6918: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828F691C: 4BCAC98D  bl 0x825a32a8
	ctx.lr = 0x828F6920;
	sub_825A32A8(ctx, base);
	// 828F6920: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F6924: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F6928: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F692C: 4BCAAE45  bl 0x825a1770
	ctx.lr = 0x828F6930;
	sub_825A1770(ctx, base);
	// 828F6930: 38610368  addi r3, r1, 0x368
	ctx.r[3].s64 = ctx.r[1].s64 + 872;
	// 828F6934: 484FCAF5  bl 0x82df3428
	ctx.lr = 0x828F6938;
	sub_82DF3428(ctx, base);
	// 828F6938: 38610348  addi r3, r1, 0x348
	ctx.r[3].s64 = ctx.r[1].s64 + 840;
	// 828F693C: 4B9D237D  bl 0x822c8cb8
	ctx.lr = 0x828F6940;
	sub_822C8CB8(ctx, base);
	// 828F6940: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6944: 484FCAE5  bl 0x82df3428
	ctx.lr = 0x828F6948;
	sub_82DF3428(ctx, base);
	// 828F6948: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F694C: 484FCADD  bl 0x82df3428
	ctx.lr = 0x828F6950;
	sub_82DF3428(ctx, base);
	// 828F6950: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6954: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6958: 388B1EE4  addi r4, r11, 0x1ee4
	ctx.r[4].s64 = ctx.r[11].s64 + 7908;
	// 828F695C: 484FD0AD  bl 0x82df3a08
	ctx.lr = 0x828F6960;
	sub_82DF3A08(ctx, base);
	// 828F6960: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6964: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6968: 388B1ED8  addi r4, r11, 0x1ed8
	ctx.r[4].s64 = ctx.r[11].s64 + 7896;
	// 828F696C: 484FD09D  bl 0x82df3a08
	ctx.lr = 0x828F6970;
	sub_82DF3A08(ctx, base);
	// 828F6970: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828F6974: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 828F6978: FC60D090  fmr f3, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[26].f64;
	// 828F697C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F6980: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828F6984: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 828F6988: C32BD200  lfs f25, -0x2e00(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11776 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 828F698C: FC40C890  fmr f2, f25
	ctx.f[2].f64 = ctx.f[25].f64;
	// 828F6990: 4BCAC919  bl 0x825a32a8
	ctx.lr = 0x828F6994;
	sub_825A32A8(ctx, base);
	// 828F6994: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F6998: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F699C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F69A0: 4BCAADD1  bl 0x825a1770
	ctx.lr = 0x828F69A4;
	sub_825A1770(ctx, base);
	// 828F69A4: 386101E8  addi r3, r1, 0x1e8
	ctx.r[3].s64 = ctx.r[1].s64 + 488;
	// 828F69A8: 484FCA81  bl 0x82df3428
	ctx.lr = 0x828F69AC;
	sub_82DF3428(ctx, base);
	// 828F69AC: 386101C8  addi r3, r1, 0x1c8
	ctx.r[3].s64 = ctx.r[1].s64 + 456;
	// 828F69B0: 4B9D2309  bl 0x822c8cb8
	ctx.lr = 0x828F69B4;
	sub_822C8CB8(ctx, base);
	// 828F69B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F69B8: 484FCA71  bl 0x82df3428
	ctx.lr = 0x828F69BC;
	sub_82DF3428(ctx, base);
	// 828F69BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F69C0: 484FCA69  bl 0x82df3428
	ctx.lr = 0x828F69C4;
	sub_82DF3428(ctx, base);
	// 828F69C4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F69C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F69CC: 388B1EC8  addi r4, r11, 0x1ec8
	ctx.r[4].s64 = ctx.r[11].s64 + 7880;
	// 828F69D0: 484FD039  bl 0x82df3a08
	ctx.lr = 0x828F69D4;
	sub_82DF3A08(ctx, base);
	// 828F69D4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F69D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F69DC: 388B1EBC  addi r4, r11, 0x1ebc
	ctx.r[4].s64 = ctx.r[11].s64 + 7868;
	// 828F69E0: 484FD029  bl 0x82df3a08
	ctx.lr = 0x828F69E4;
	sub_82DF3A08(ctx, base);
	// 828F69E4: 38BF0014  addi r5, r31, 0x14
	ctx.r[5].s64 = ctx.r[31].s64 + 20;
	// 828F69E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F69EC: FC60D090  fmr f3, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[26].f64;
	// 828F69F0: 38610430  addi r3, r1, 0x430
	ctx.r[3].s64 = ctx.r[1].s64 + 1072;
	// 828F69F4: FC40C890  fmr f2, f25
	ctx.f[2].f64 = ctx.f[25].f64;
	// 828F69F8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828F69FC: 4BCAC8AD  bl 0x825a32a8
	ctx.lr = 0x828F6A00;
	sub_825A32A8(ctx, base);
	// 828F6A00: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F6A04: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F6A08: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F6A0C: 4BCAAD65  bl 0x825a1770
	ctx.lr = 0x828F6A10;
	sub_825A1770(ctx, base);
	// 828F6A10: 38610468  addi r3, r1, 0x468
	ctx.r[3].s64 = ctx.r[1].s64 + 1128;
	// 828F6A14: 484FCA15  bl 0x82df3428
	ctx.lr = 0x828F6A18;
	sub_82DF3428(ctx, base);
	// 828F6A18: 38610448  addi r3, r1, 0x448
	ctx.r[3].s64 = ctx.r[1].s64 + 1096;
	// 828F6A1C: 4B9D229D  bl 0x822c8cb8
	ctx.lr = 0x828F6A20;
	sub_822C8CB8(ctx, base);
	// 828F6A20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6A24: 484FCA05  bl 0x82df3428
	ctx.lr = 0x828F6A28;
	sub_82DF3428(ctx, base);
	// 828F6A28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6A2C: 484FC9FD  bl 0x82df3428
	ctx.lr = 0x828F6A30;
	sub_82DF3428(ctx, base);
	// 828F6A30: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6A34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6A38: 388B1EA8  addi r4, r11, 0x1ea8
	ctx.r[4].s64 = ctx.r[11].s64 + 7848;
	// 828F6A3C: 484FCFCD  bl 0x82df3a08
	ctx.lr = 0x828F6A40;
	sub_82DF3A08(ctx, base);
	// 828F6A40: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6A44: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6A48: 388B1E98  addi r4, r11, 0x1e98
	ctx.r[4].s64 = ctx.r[11].s64 + 7832;
	// 828F6A4C: 484FCFBD  bl 0x82df3a08
	ctx.lr = 0x828F6A50;
	sub_82DF3A08(ctx, base);
	// 828F6A50: 38BF0018  addi r5, r31, 0x18
	ctx.r[5].s64 = ctx.r[31].s64 + 24;
	// 828F6A54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F6A58: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828F6A5C: 38610230  addi r3, r1, 0x230
	ctx.r[3].s64 = ctx.r[1].s64 + 560;
	// 828F6A60: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 828F6A64: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828F6A68: 4BCAC841  bl 0x825a32a8
	ctx.lr = 0x828F6A6C;
	sub_825A32A8(ctx, base);
	// 828F6A6C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F6A70: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F6A74: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F6A78: 4BCAACF9  bl 0x825a1770
	ctx.lr = 0x828F6A7C;
	sub_825A1770(ctx, base);
	// 828F6A7C: 38610268  addi r3, r1, 0x268
	ctx.r[3].s64 = ctx.r[1].s64 + 616;
	// 828F6A80: 484FC9A9  bl 0x82df3428
	ctx.lr = 0x828F6A84;
	sub_82DF3428(ctx, base);
	// 828F6A84: 38610248  addi r3, r1, 0x248
	ctx.r[3].s64 = ctx.r[1].s64 + 584;
	// 828F6A88: 4B9D2231  bl 0x822c8cb8
	ctx.lr = 0x828F6A8C;
	sub_822C8CB8(ctx, base);
	// 828F6A8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6A90: 484FC999  bl 0x82df3428
	ctx.lr = 0x828F6A94;
	sub_82DF3428(ctx, base);
	// 828F6A94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6A98: 484FC991  bl 0x82df3428
	ctx.lr = 0x828F6A9C;
	sub_82DF3428(ctx, base);
	// 828F6A9C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6AA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6AA4: 388B1E80  addi r4, r11, 0x1e80
	ctx.r[4].s64 = ctx.r[11].s64 + 7808;
	// 828F6AA8: 484FCF61  bl 0x82df3a08
	ctx.lr = 0x828F6AAC;
	sub_82DF3A08(ctx, base);
	// 828F6AAC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6AB0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6AB4: 388B1E74  addi r4, r11, 0x1e74
	ctx.r[4].s64 = ctx.r[11].s64 + 7796;
	// 828F6AB8: 484FCF51  bl 0x82df3a08
	ctx.lr = 0x828F6ABC;
	sub_82DF3A08(ctx, base);
	// 828F6ABC: 38BF001C  addi r5, r31, 0x1c
	ctx.r[5].s64 = ctx.r[31].s64 + 28;
	// 828F6AC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F6AC4: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828F6AC8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828F6ACC: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 828F6AD0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828F6AD4: 4BCAC7D5  bl 0x825a32a8
	ctx.lr = 0x828F6AD8;
	sub_825A32A8(ctx, base);
	// 828F6AD8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F6ADC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F6AE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F6AE4: 4BCAAC8D  bl 0x825a1770
	ctx.lr = 0x828F6AE8;
	sub_825A1770(ctx, base);
	// 828F6AE8: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 828F6AEC: 484FC93D  bl 0x82df3428
	ctx.lr = 0x828F6AF0;
	sub_82DF3428(ctx, base);
	// 828F6AF0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828F6AF4: 4B9D21C5  bl 0x822c8cb8
	ctx.lr = 0x828F6AF8;
	sub_822C8CB8(ctx, base);
	// 828F6AF8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6AFC: 484FC92D  bl 0x82df3428
	ctx.lr = 0x828F6B00;
	sub_82DF3428(ctx, base);
	// 828F6B00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6B04: 484FC925  bl 0x82df3428
	ctx.lr = 0x828F6B08;
	sub_82DF3428(ctx, base);
	// 828F6B08: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6B0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6B10: 388B1E4C  addi r4, r11, 0x1e4c
	ctx.r[4].s64 = ctx.r[11].s64 + 7756;
	// 828F6B14: 484FCEF5  bl 0x82df3a08
	ctx.lr = 0x828F6B18;
	sub_82DF3A08(ctx, base);
	// 828F6B18: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6B1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6B20: 388B1E40  addi r4, r11, 0x1e40
	ctx.r[4].s64 = ctx.r[11].s64 + 7744;
	// 828F6B24: 484FCEE5  bl 0x82df3a08
	ctx.lr = 0x828F6B28;
	sub_82DF3A08(ctx, base);
	// 828F6B28: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828F6B2C: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 828F6B30: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 828F6B34: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F6B38: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828F6B3C: 386102B0  addi r3, r1, 0x2b0
	ctx.r[3].s64 = ctx.r[1].s64 + 688;
	// 828F6B40: C32B029C  lfs f25, 0x29c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(668 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 828F6B44: FC40C890  fmr f2, f25
	ctx.f[2].f64 = ctx.f[25].f64;
	// 828F6B48: 4BCAC761  bl 0x825a32a8
	ctx.lr = 0x828F6B4C;
	sub_825A32A8(ctx, base);
	// 828F6B4C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F6B50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F6B54: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F6B58: 4BCAAC19  bl 0x825a1770
	ctx.lr = 0x828F6B5C;
	sub_825A1770(ctx, base);
	// 828F6B5C: 386102E8  addi r3, r1, 0x2e8
	ctx.r[3].s64 = ctx.r[1].s64 + 744;
	// 828F6B60: 484FC8C9  bl 0x82df3428
	ctx.lr = 0x828F6B64;
	sub_82DF3428(ctx, base);
	// 828F6B64: 386102C8  addi r3, r1, 0x2c8
	ctx.r[3].s64 = ctx.r[1].s64 + 712;
	// 828F6B68: 4B9D2151  bl 0x822c8cb8
	ctx.lr = 0x828F6B6C;
	sub_822C8CB8(ctx, base);
	// 828F6B6C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6B70: 484FC8B9  bl 0x82df3428
	ctx.lr = 0x828F6B74;
	sub_82DF3428(ctx, base);
	// 828F6B74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6B78: 484FC8B1  bl 0x82df3428
	ctx.lr = 0x828F6B7C;
	sub_82DF3428(ctx, base);
	// 828F6B7C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6B80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6B84: 388B1E30  addi r4, r11, 0x1e30
	ctx.r[4].s64 = ctx.r[11].s64 + 7728;
	// 828F6B88: 484FCE81  bl 0x82df3a08
	ctx.lr = 0x828F6B8C;
	sub_82DF3A08(ctx, base);
	// 828F6B8C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6B90: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6B94: 388B1E24  addi r4, r11, 0x1e24
	ctx.r[4].s64 = ctx.r[11].s64 + 7716;
	// 828F6B98: 484FCE71  bl 0x82df3a08
	ctx.lr = 0x828F6B9C;
	sub_82DF3A08(ctx, base);
	// 828F6B9C: 38BF0024  addi r5, r31, 0x24
	ctx.r[5].s64 = ctx.r[31].s64 + 36;
	// 828F6BA0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F6BA4: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 828F6BA8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828F6BAC: FC40C890  fmr f2, f25
	ctx.f[2].f64 = ctx.f[25].f64;
	// 828F6BB0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828F6BB4: 4BCAC6F5  bl 0x825a32a8
	ctx.lr = 0x828F6BB8;
	sub_825A32A8(ctx, base);
	// 828F6BB8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F6BBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F6BC0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F6BC4: 4BCAABAD  bl 0x825a1770
	ctx.lr = 0x828F6BC8;
	sub_825A1770(ctx, base);
	// 828F6BC8: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 828F6BCC: 484FC85D  bl 0x82df3428
	ctx.lr = 0x828F6BD0;
	sub_82DF3428(ctx, base);
	// 828F6BD0: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828F6BD4: 4B9D20E5  bl 0x822c8cb8
	ctx.lr = 0x828F6BD8;
	sub_822C8CB8(ctx, base);
	// 828F6BD8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6BDC: 484FC84D  bl 0x82df3428
	ctx.lr = 0x828F6BE0;
	sub_82DF3428(ctx, base);
	// 828F6BE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6BE4: 484FC845  bl 0x82df3428
	ctx.lr = 0x828F6BE8;
	sub_82DF3428(ctx, base);
	// 828F6BE8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6BEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6BF0: 388B1DC4  addi r4, r11, 0x1dc4
	ctx.r[4].s64 = ctx.r[11].s64 + 7620;
	// 828F6BF4: 484FCE15  bl 0x82df3a08
	ctx.lr = 0x828F6BF8;
	sub_82DF3A08(ctx, base);
	// 828F6BF8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6BFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6C00: 388B1DB0  addi r4, r11, 0x1db0
	ctx.r[4].s64 = ctx.r[11].s64 + 7600;
	// 828F6C04: 484FCE05  bl 0x82df3a08
	ctx.lr = 0x828F6C08;
	sub_82DF3A08(ctx, base);
	// 828F6C08: 38BF0028  addi r5, r31, 0x28
	ctx.r[5].s64 = ctx.r[31].s64 + 40;
	// 828F6C0C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F6C10: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828F6C14: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828F6C18: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 828F6C1C: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828F6C20: 4BCAC689  bl 0x825a32a8
	ctx.lr = 0x828F6C24;
	sub_825A32A8(ctx, base);
	// 828F6C24: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F6C28: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F6C2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F6C30: 4BCAAB41  bl 0x825a1770
	ctx.lr = 0x828F6C34;
	sub_825A1770(ctx, base);
	// 828F6C34: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 828F6C38: 484FC7F1  bl 0x82df3428
	ctx.lr = 0x828F6C3C;
	sub_82DF3428(ctx, base);
	// 828F6C3C: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 828F6C40: 4B9D2079  bl 0x822c8cb8
	ctx.lr = 0x828F6C44;
	sub_822C8CB8(ctx, base);
	// 828F6C44: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6C48: 484FC7E1  bl 0x82df3428
	ctx.lr = 0x828F6C4C;
	sub_82DF3428(ctx, base);
	// 828F6C4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6C50: 484FC7D9  bl 0x82df3428
	ctx.lr = 0x828F6C54;
	sub_82DF3428(ctx, base);
	// 828F6C54: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6C58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6C5C: 388B1D9C  addi r4, r11, 0x1d9c
	ctx.r[4].s64 = ctx.r[11].s64 + 7580;
	// 828F6C60: 484FCDA9  bl 0x82df3a08
	ctx.lr = 0x828F6C64;
	sub_82DF3A08(ctx, base);
	// 828F6C64: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6C68: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6C6C: 388B1D8C  addi r4, r11, 0x1d8c
	ctx.r[4].s64 = ctx.r[11].s64 + 7564;
	// 828F6C70: 484FCD99  bl 0x82df3a08
	ctx.lr = 0x828F6C74;
	sub_82DF3A08(ctx, base);
	// 828F6C74: 38BF002C  addi r5, r31, 0x2c
	ctx.r[5].s64 = ctx.r[31].s64 + 44;
	// 828F6C78: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F6C7C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828F6C80: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 828F6C84: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 828F6C88: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828F6C8C: 4BCAC61D  bl 0x825a32a8
	ctx.lr = 0x828F6C90;
	sub_825A32A8(ctx, base);
	// 828F6C90: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F6C94: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F6C98: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F6C9C: 4BCAAAD5  bl 0x825a1770
	ctx.lr = 0x828F6CA0;
	sub_825A1770(ctx, base);
	// 828F6CA0: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 828F6CA4: 484FC785  bl 0x82df3428
	ctx.lr = 0x828F6CA8;
	sub_82DF3428(ctx, base);
	// 828F6CA8: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 828F6CAC: 4B9D200D  bl 0x822c8cb8
	ctx.lr = 0x828F6CB0;
	sub_822C8CB8(ctx, base);
	// 828F6CB0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6CB4: 484FC775  bl 0x82df3428
	ctx.lr = 0x828F6CB8;
	sub_82DF3428(ctx, base);
	// 828F6CB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6CBC: 484FC76D  bl 0x82df3428
	ctx.lr = 0x828F6CC0;
	sub_82DF3428(ctx, base);
	// 828F6CC0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6CC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6CC8: 388B1D78  addi r4, r11, 0x1d78
	ctx.r[4].s64 = ctx.r[11].s64 + 7544;
	// 828F6CCC: 484FCD3D  bl 0x82df3a08
	ctx.lr = 0x828F6CD0;
	sub_82DF3A08(ctx, base);
	// 828F6CD0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6CD4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6CD8: 388B1D64  addi r4, r11, 0x1d64
	ctx.r[4].s64 = ctx.r[11].s64 + 7524;
	// 828F6CDC: 484FCD2D  bl 0x82df3a08
	ctx.lr = 0x828F6CE0;
	sub_82DF3A08(ctx, base);
	// 828F6CE0: 38BF0030  addi r5, r31, 0x30
	ctx.r[5].s64 = ctx.r[31].s64 + 48;
	// 828F6CE4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F6CE8: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828F6CEC: 386101F0  addi r3, r1, 0x1f0
	ctx.r[3].s64 = ctx.r[1].s64 + 496;
	// 828F6CF0: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 828F6CF4: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828F6CF8: 4BCAC5B1  bl 0x825a32a8
	ctx.lr = 0x828F6CFC;
	sub_825A32A8(ctx, base);
	// 828F6CFC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F6D00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F6D04: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F6D08: 4BCAAA69  bl 0x825a1770
	ctx.lr = 0x828F6D0C;
	sub_825A1770(ctx, base);
	// 828F6D0C: 38610228  addi r3, r1, 0x228
	ctx.r[3].s64 = ctx.r[1].s64 + 552;
	// 828F6D10: 484FC719  bl 0x82df3428
	ctx.lr = 0x828F6D14;
	sub_82DF3428(ctx, base);
	// 828F6D14: 38610208  addi r3, r1, 0x208
	ctx.r[3].s64 = ctx.r[1].s64 + 520;
	// 828F6D18: 4B9D1FA1  bl 0x822c8cb8
	ctx.lr = 0x828F6D1C;
	sub_822C8CB8(ctx, base);
	// 828F6D1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6D20: 484FC709  bl 0x82df3428
	ctx.lr = 0x828F6D24;
	sub_82DF3428(ctx, base);
	// 828F6D24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6D28: 484FC701  bl 0x82df3428
	ctx.lr = 0x828F6D2C;
	sub_82DF3428(ctx, base);
	// 828F6D2C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6D30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6D34: 388B1D48  addi r4, r11, 0x1d48
	ctx.r[4].s64 = ctx.r[11].s64 + 7496;
	// 828F6D38: 484FCCD1  bl 0x82df3a08
	ctx.lr = 0x828F6D3C;
	sub_82DF3A08(ctx, base);
	// 828F6D3C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6D40: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6D44: 388B1D34  addi r4, r11, 0x1d34
	ctx.r[4].s64 = ctx.r[11].s64 + 7476;
	// 828F6D48: 484FCCC1  bl 0x82df3a08
	ctx.lr = 0x828F6D4C;
	sub_82DF3A08(ctx, base);
	// 828F6D4C: 38BF0034  addi r5, r31, 0x34
	ctx.r[5].s64 = ctx.r[31].s64 + 52;
	// 828F6D50: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F6D54: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828F6D58: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 828F6D5C: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 828F6D60: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828F6D64: 4BCAC545  bl 0x825a32a8
	ctx.lr = 0x828F6D68;
	sub_825A32A8(ctx, base);
	// 828F6D68: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F6D6C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F6D70: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F6D74: 4BCAA9FD  bl 0x825a1770
	ctx.lr = 0x828F6D78;
	sub_825A1770(ctx, base);
	// 828F6D78: 386102A8  addi r3, r1, 0x2a8
	ctx.r[3].s64 = ctx.r[1].s64 + 680;
	// 828F6D7C: 484FC6AD  bl 0x82df3428
	ctx.lr = 0x828F6D80;
	sub_82DF3428(ctx, base);
	// 828F6D80: 38610288  addi r3, r1, 0x288
	ctx.r[3].s64 = ctx.r[1].s64 + 648;
	// 828F6D84: 4B9D1F35  bl 0x822c8cb8
	ctx.lr = 0x828F6D88;
	sub_822C8CB8(ctx, base);
	// 828F6D88: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6D8C: 484FC69D  bl 0x82df3428
	ctx.lr = 0x828F6D90;
	sub_82DF3428(ctx, base);
	// 828F6D90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6D94: 484FC695  bl 0x82df3428
	ctx.lr = 0x828F6D98;
	sub_82DF3428(ctx, base);
	// 828F6D98: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6D9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6DA0: 388B1D14  addi r4, r11, 0x1d14
	ctx.r[4].s64 = ctx.r[11].s64 + 7444;
	// 828F6DA4: 484FCC65  bl 0x82df3a08
	ctx.lr = 0x828F6DA8;
	sub_82DF3A08(ctx, base);
	// 828F6DA8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6DAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6DB0: 388B1D04  addi r4, r11, 0x1d04
	ctx.r[4].s64 = ctx.r[11].s64 + 7428;
	// 828F6DB4: 484FCC55  bl 0x82df3a08
	ctx.lr = 0x828F6DB8;
	sub_82DF3A08(ctx, base);
	// 828F6DB8: 38BF0038  addi r5, r31, 0x38
	ctx.r[5].s64 = ctx.r[31].s64 + 56;
	// 828F6DBC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F6DC0: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828F6DC4: 386102F0  addi r3, r1, 0x2f0
	ctx.r[3].s64 = ctx.r[1].s64 + 752;
	// 828F6DC8: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 828F6DCC: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828F6DD0: 4BCAC4D9  bl 0x825a32a8
	ctx.lr = 0x828F6DD4;
	sub_825A32A8(ctx, base);
	// 828F6DD4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F6DD8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F6DDC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F6DE0: 4BCAA991  bl 0x825a1770
	ctx.lr = 0x828F6DE4;
	sub_825A1770(ctx, base);
	// 828F6DE4: 38610328  addi r3, r1, 0x328
	ctx.r[3].s64 = ctx.r[1].s64 + 808;
	// 828F6DE8: 484FC641  bl 0x82df3428
	ctx.lr = 0x828F6DEC;
	sub_82DF3428(ctx, base);
	// 828F6DEC: 38610308  addi r3, r1, 0x308
	ctx.r[3].s64 = ctx.r[1].s64 + 776;
	// 828F6DF0: 4B9D1EC9  bl 0x822c8cb8
	ctx.lr = 0x828F6DF4;
	sub_822C8CB8(ctx, base);
	// 828F6DF4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6DF8: 484FC631  bl 0x82df3428
	ctx.lr = 0x828F6DFC;
	sub_82DF3428(ctx, base);
	// 828F6DFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6E00: 484FC629  bl 0x82df3428
	ctx.lr = 0x828F6E04;
	sub_82DF3428(ctx, base);
	// 828F6E04: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6E08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6E0C: 388B1CF8  addi r4, r11, 0x1cf8
	ctx.r[4].s64 = ctx.r[11].s64 + 7416;
	// 828F6E10: 484FCBF9  bl 0x82df3a08
	ctx.lr = 0x828F6E14;
	sub_82DF3A08(ctx, base);
	// 828F6E14: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6E18: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6E1C: 388B1CF0  addi r4, r11, 0x1cf0
	ctx.r[4].s64 = ctx.r[11].s64 + 7408;
	// 828F6E20: 484FCBE9  bl 0x82df3a08
	ctx.lr = 0x828F6E24;
	sub_82DF3A08(ctx, base);
	// 828F6E24: 38BF003C  addi r5, r31, 0x3c
	ctx.r[5].s64 = ctx.r[31].s64 + 60;
	// 828F6E28: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F6E2C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828F6E30: 38610370  addi r3, r1, 0x370
	ctx.r[3].s64 = ctx.r[1].s64 + 880;
	// 828F6E34: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828F6E38: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 828F6E3C: 4BCAC46D  bl 0x825a32a8
	ctx.lr = 0x828F6E40;
	sub_825A32A8(ctx, base);
	// 828F6E40: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F6E44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F6E48: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F6E4C: 4BCAA925  bl 0x825a1770
	ctx.lr = 0x828F6E50;
	sub_825A1770(ctx, base);
	// 828F6E50: 386103A8  addi r3, r1, 0x3a8
	ctx.r[3].s64 = ctx.r[1].s64 + 936;
	// 828F6E54: 484FC5D5  bl 0x82df3428
	ctx.lr = 0x828F6E58;
	sub_82DF3428(ctx, base);
	// 828F6E58: 38610388  addi r3, r1, 0x388
	ctx.r[3].s64 = ctx.r[1].s64 + 904;
	// 828F6E5C: 4B9D1E5D  bl 0x822c8cb8
	ctx.lr = 0x828F6E60;
	sub_822C8CB8(ctx, base);
	// 828F6E60: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6E64: 484FC5C5  bl 0x82df3428
	ctx.lr = 0x828F6E68;
	sub_82DF3428(ctx, base);
	// 828F6E68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6E6C: 484FC5BD  bl 0x82df3428
	ctx.lr = 0x828F6E70;
	sub_82DF3428(ctx, base);
	// 828F6E70: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6E74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6E78: 388B1CD4  addi r4, r11, 0x1cd4
	ctx.r[4].s64 = ctx.r[11].s64 + 7380;
	// 828F6E7C: 484FCB8D  bl 0x82df3a08
	ctx.lr = 0x828F6E80;
	sub_82DF3A08(ctx, base);
	// 828F6E80: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6E84: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6E88: 388B1CC0  addi r4, r11, 0x1cc0
	ctx.r[4].s64 = ctx.r[11].s64 + 7360;
	// 828F6E8C: 484FCB7D  bl 0x82df3a08
	ctx.lr = 0x828F6E90;
	sub_82DF3A08(ctx, base);
	// 828F6E90: 38BF0040  addi r5, r31, 0x40
	ctx.r[5].s64 = ctx.r[31].s64 + 64;
	// 828F6E94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F6E98: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828F6E9C: 386103F0  addi r3, r1, 0x3f0
	ctx.r[3].s64 = ctx.r[1].s64 + 1008;
	// 828F6EA0: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 828F6EA4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828F6EA8: 4BCAC401  bl 0x825a32a8
	ctx.lr = 0x828F6EAC;
	sub_825A32A8(ctx, base);
	// 828F6EAC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F6EB0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F6EB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F6EB8: 4BCAA8B9  bl 0x825a1770
	ctx.lr = 0x828F6EBC;
	sub_825A1770(ctx, base);
	// 828F6EBC: 38610428  addi r3, r1, 0x428
	ctx.r[3].s64 = ctx.r[1].s64 + 1064;
	// 828F6EC0: 484FC569  bl 0x82df3428
	ctx.lr = 0x828F6EC4;
	sub_82DF3428(ctx, base);
	// 828F6EC4: 38610408  addi r3, r1, 0x408
	ctx.r[3].s64 = ctx.r[1].s64 + 1032;
	// 828F6EC8: 4B9D1DF1  bl 0x822c8cb8
	ctx.lr = 0x828F6ECC;
	sub_822C8CB8(ctx, base);
	// 828F6ECC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6ED0: 484FC559  bl 0x82df3428
	ctx.lr = 0x828F6ED4;
	sub_82DF3428(ctx, base);
	// 828F6ED4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6ED8: 484FC551  bl 0x82df3428
	ctx.lr = 0x828F6EDC;
	sub_82DF3428(ctx, base);
	// 828F6EDC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6EE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6EE4: 388B1CA4  addi r4, r11, 0x1ca4
	ctx.r[4].s64 = ctx.r[11].s64 + 7332;
	// 828F6EE8: 484FCB21  bl 0x82df3a08
	ctx.lr = 0x828F6EEC;
	sub_82DF3A08(ctx, base);
	// 828F6EEC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6EF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6EF4: 388B1C88  addi r4, r11, 0x1c88
	ctx.r[4].s64 = ctx.r[11].s64 + 7304;
	// 828F6EF8: 484FCB11  bl 0x82df3a08
	ctx.lr = 0x828F6EFC;
	sub_82DF3A08(ctx, base);
	// 828F6EFC: 38BF0044  addi r5, r31, 0x44
	ctx.r[5].s64 = ctx.r[31].s64 + 68;
	// 828F6F00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F6F04: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828F6F08: 38610470  addi r3, r1, 0x470
	ctx.r[3].s64 = ctx.r[1].s64 + 1136;
	// 828F6F0C: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828F6F10: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 828F6F14: 4BCAC395  bl 0x825a32a8
	ctx.lr = 0x828F6F18;
	sub_825A32A8(ctx, base);
	// 828F6F18: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F6F1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F6F20: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F6F24: 4BCAA84D  bl 0x825a1770
	ctx.lr = 0x828F6F28;
	sub_825A1770(ctx, base);
	// 828F6F28: 386104A8  addi r3, r1, 0x4a8
	ctx.r[3].s64 = ctx.r[1].s64 + 1192;
	// 828F6F2C: 484FC4FD  bl 0x82df3428
	ctx.lr = 0x828F6F30;
	sub_82DF3428(ctx, base);
	// 828F6F30: 38610488  addi r3, r1, 0x488
	ctx.r[3].s64 = ctx.r[1].s64 + 1160;
	// 828F6F34: 4B9D1D85  bl 0x822c8cb8
	ctx.lr = 0x828F6F38;
	sub_822C8CB8(ctx, base);
	// 828F6F38: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6F3C: 484FC4ED  bl 0x82df3428
	ctx.lr = 0x828F6F40;
	sub_82DF3428(ctx, base);
	// 828F6F40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6F44: 484FC4E5  bl 0x82df3428
	ctx.lr = 0x828F6F48;
	sub_82DF3428(ctx, base);
	// 828F6F48: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6F4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6F50: 388B1C78  addi r4, r11, 0x1c78
	ctx.r[4].s64 = ctx.r[11].s64 + 7288;
	// 828F6F54: 484FCAB5  bl 0x82df3a08
	ctx.lr = 0x828F6F58;
	sub_82DF3A08(ctx, base);
	// 828F6F58: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F6F5C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6F60: 388B1C64  addi r4, r11, 0x1c64
	ctx.r[4].s64 = ctx.r[11].s64 + 7268;
	// 828F6F64: 484FCAA5  bl 0x82df3a08
	ctx.lr = 0x828F6F68;
	sub_82DF3A08(ctx, base);
	// 828F6F68: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828F6F6C: 38BF0048  addi r5, r31, 0x48
	ctx.r[5].s64 = ctx.r[31].s64 + 72;
	// 828F6F70: FC60D090  fmr f3, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[26].f64;
	// 828F6F74: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F6F78: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828F6F7C: 386104F0  addi r3, r1, 0x4f0
	ctx.r[3].s64 = ctx.r[1].s64 + 1264;
	// 828F6F80: C04BDDF0  lfs f2, -0x2210(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8720 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828F6F84: 4BCAC325  bl 0x825a32a8
	ctx.lr = 0x828F6F88;
	sub_825A32A8(ctx, base);
	// 828F6F88: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F6F8C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F6F90: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F6F94: 4BCAA7DD  bl 0x825a1770
	ctx.lr = 0x828F6F98;
	sub_825A1770(ctx, base);
	// 828F6F98: 38610528  addi r3, r1, 0x528
	ctx.r[3].s64 = ctx.r[1].s64 + 1320;
	// 828F6F9C: 484FC48D  bl 0x82df3428
	ctx.lr = 0x828F6FA0;
	sub_82DF3428(ctx, base);
	// 828F6FA0: 38610508  addi r3, r1, 0x508
	ctx.r[3].s64 = ctx.r[1].s64 + 1288;
	// 828F6FA4: 4B9D1D15  bl 0x822c8cb8
	ctx.lr = 0x828F6FA8;
	sub_822C8CB8(ctx, base);
	// 828F6FA8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F6FAC: 484FC47D  bl 0x82df3428
	ctx.lr = 0x828F6FB0;
	sub_82DF3428(ctx, base);
	// 828F6FB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F6FB4: 484FC475  bl 0x82df3428
	ctx.lr = 0x828F6FB8;
	sub_82DF3428(ctx, base);
	// 828F6FB8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F6FBC: 4BCD2D15  bl 0x825c9cd0
	ctx.lr = 0x828F6FC0;
	sub_825C9CD0(ctx, base);
	// 828F6FC0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F6FC4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F6FC8: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 828F6FCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F6FD0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828F6FD4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828F6FD8: 419A0024  beq cr6, 0x828f6ffc
	if ctx.cr[6].eq {
	pc = 0x828F6FFC; continue 'dispatch;
	}
	// 828F6FDC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828F6FE0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828F6FE4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F6FE8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828F6FEC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828F6FF0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F6FF4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F6FF8: 4082FFE8  bne 0x828f6fe0
	if !ctx.cr[0].eq {
	pc = 0x828F6FE0; continue 'dispatch;
	}
	// 828F6FFC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F7000: 387F004C  addi r3, r31, 0x4c
	ctx.r[3].s64 = ctx.r[31].s64 + 76;
	// 828F7004: 48063B15  bl 0x8295ab18
	ctx.lr = 0x828F7008;
	sub_8295AB18(ctx, base);
	// 828F7008: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F700C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F7010: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F7014: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828F7018: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828F701C: 419A0024  beq cr6, 0x828f7040
	if ctx.cr[6].eq {
	pc = 0x828F7040; continue 'dispatch;
	}
	// 828F7020: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828F7024: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828F7028: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F702C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828F7030: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828F7034: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F7038: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F703C: 4082FFE8  bne 0x828f7024
	if !ctx.cr[0].eq {
	pc = 0x828F7024; continue 'dispatch;
	}
	// 828F7040: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F7044: 387F00C4  addi r3, r31, 0xc4
	ctx.r[3].s64 = ctx.r[31].s64 + 196;
	// 828F7048: 4804CA49  bl 0x82943a90
	ctx.lr = 0x828F704C;
	sub_82943A90(ctx, base);
	// 828F704C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F7050: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F7054: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F7058: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828F705C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828F7060: 419A0024  beq cr6, 0x828f7084
	if ctx.cr[6].eq {
	pc = 0x828F7084; continue 'dispatch;
	}
	// 828F7064: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828F7068: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828F706C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F7070: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828F7074: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828F7078: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F707C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F7080: 4082FFE8  bne 0x828f7068
	if !ctx.cr[0].eq {
	pc = 0x828F7068; continue 'dispatch;
	}
	// 828F7084: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F7088: 387F00D4  addi r3, r31, 0xd4
	ctx.r[3].s64 = ctx.r[31].s64 + 212;
	// 828F708C: 4804ADF5  bl 0x82941e80
	ctx.lr = 0x828F7090;
	sub_82941E80(ctx, base);
	// 828F7090: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F7094: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F7098: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F709C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828F70A0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828F70A4: 419A0024  beq cr6, 0x828f70c8
	if ctx.cr[6].eq {
	pc = 0x828F70C8; continue 'dispatch;
	}
	// 828F70A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828F70AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828F70B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F70B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828F70B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828F70BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F70C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F70C4: 4082FFE8  bne 0x828f70ac
	if !ctx.cr[0].eq {
	pc = 0x828F70AC; continue 'dispatch;
	}
	// 828F70C8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F70CC: 387F00F0  addi r3, r31, 0xf0
	ctx.r[3].s64 = ctx.r[31].s64 + 240;
	// 828F70D0: 4804BB51  bl 0x82942c20
	ctx.lr = 0x828F70D4;
	sub_82942C20(ctx, base);
	// 828F70D4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F70D8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F70DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F70E0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828F70E4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828F70E8: 419A0024  beq cr6, 0x828f710c
	if ctx.cr[6].eq {
	pc = 0x828F710C; continue 'dispatch;
	}
	// 828F70EC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828F70F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828F70F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F70F8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828F70FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828F7100: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F7104: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F7108: 4082FFE8  bne 0x828f70f0
	if !ctx.cr[0].eq {
	pc = 0x828F70F0; continue 'dispatch;
	}
	// 828F710C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F7110: 387F0100  addi r3, r31, 0x100
	ctx.r[3].s64 = ctx.r[31].s64 + 256;
	// 828F7114: 4BFFF105  bl 0x828f6218
	ctx.lr = 0x828F7118;
	sub_828F6218(ctx, base);
	// 828F7118: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F711C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F7120: 419A0008  beq cr6, 0x828f7128
	if ctx.cr[6].eq {
	pc = 0x828F7128; continue 'dispatch;
	}
	// 828F7124: 4B9C976D  bl 0x822c0890
	ctx.lr = 0x828F7128;
	sub_822C0890(ctx, base);
	// 828F7128: 38210590  addi r1, r1, 0x590
	ctx.r[1].s64 = ctx.r[1].s64 + 1424;
	// 828F712C: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 828F7130: 488B1989  bl 0x831a8ab8
	ctx.lr = 0x828F7134;
	sub_831A8A8C(ctx, base);
	// 828F7134: 488B1088  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F7138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F7138 size=436
    let mut pc: u32 = 0x828F7138;
    'dispatch: loop {
        match pc {
            0x828F7138 => {
    //   block [0x828F7138..0x828F72EC)
	// 828F7138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F713C: 488B1031  bl 0x831a816c
	ctx.lr = 0x828F7140;
	sub_831A8130(ctx, base);
	// 828F7140: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 828F7144: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828F7148: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F714C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F7150: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828F7154: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 828F7158: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F715C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F7160: 4BCD33A1  bl 0x825ca500
	ctx.lr = 0x828F7164;
	sub_825CA500(ctx, base);
	// 828F7164: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828F7168: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F716C: 388BF620  addi r4, r11, -0x9e0
	ctx.r[4].s64 = ctx.r[11].s64 + -2528;
	// 828F7170: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F7174: 484FC895  bl 0x82df3a08
	ctx.lr = 0x828F7178;
	sub_82DF3A08(ctx, base);
	// 828F7178: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828F717C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7180: 388BDBBC  addi r4, r11, -0x2444
	ctx.r[4].s64 = ctx.r[11].s64 + -9284;
	// 828F7184: 484FC885  bl 0x82df3a08
	ctx.lr = 0x828F7188;
	sub_82DF3A08(ctx, base);
	// 828F7188: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828F718C: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 828F7190: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F7194: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828F7198: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F719C: C3EB9528  lfs f31, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828F71A0: C3CA6218  lfs f30, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828F71A4: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828F71A8: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828F71AC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F71B0: 4BCAC0F9  bl 0x825a32a8
	ctx.lr = 0x828F71B4;
	sub_825A32A8(ctx, base);
	// 828F71B4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F71B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F71BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F71C0: 4BCAA5B1  bl 0x825a1770
	ctx.lr = 0x828F71C4;
	sub_825A1770(ctx, base);
	// 828F71C4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 828F71C8: 484FC261  bl 0x82df3428
	ctx.lr = 0x828F71CC;
	sub_82DF3428(ctx, base);
	// 828F71CC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828F71D0: 4B9D1AE9  bl 0x822c8cb8
	ctx.lr = 0x828F71D4;
	sub_822C8CB8(ctx, base);
	// 828F71D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F71D8: 484FC251  bl 0x82df3428
	ctx.lr = 0x828F71DC;
	sub_82DF3428(ctx, base);
	// 828F71DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F71E0: 484FC249  bl 0x82df3428
	ctx.lr = 0x828F71E4;
	sub_82DF3428(ctx, base);
	// 828F71E4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F71E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F71EC: 388B343C  addi r4, r11, 0x343c
	ctx.r[4].s64 = ctx.r[11].s64 + 13372;
	// 828F71F0: 484FC819  bl 0x82df3a08
	ctx.lr = 0x828F71F4;
	sub_82DF3A08(ctx, base);
	// 828F71F4: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 828F71F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F71FC: 388B6098  addi r4, r11, 0x6098
	ctx.r[4].s64 = ctx.r[11].s64 + 24728;
	// 828F7200: 484FC809  bl 0x82df3a08
	ctx.lr = 0x828F7204;
	sub_82DF3A08(ctx, base);
	// 828F7204: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 828F7208: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F720C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828F7210: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828F7214: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F7218: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828F721C: 4BCAC08D  bl 0x825a32a8
	ctx.lr = 0x828F7220;
	sub_825A32A8(ctx, base);
	// 828F7220: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F7224: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F7228: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828F722C: 4BCAA545  bl 0x825a1770
	ctx.lr = 0x828F7230;
	sub_825A1770(ctx, base);
	// 828F7230: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 828F7234: 484FC1F5  bl 0x82df3428
	ctx.lr = 0x828F7238;
	sub_82DF3428(ctx, base);
	// 828F7238: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 828F723C: 4B9D1A7D  bl 0x822c8cb8
	ctx.lr = 0x828F7240;
	sub_822C8CB8(ctx, base);
	// 828F7240: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F7244: 484FC1E5  bl 0x82df3428
	ctx.lr = 0x828F7248;
	sub_82DF3428(ctx, base);
	// 828F7248: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F724C: 484FC1DD  bl 0x82df3428
	ctx.lr = 0x828F7250;
	sub_82DF3428(ctx, base);
	// 828F7250: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F7254: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7258: 388B3430  addi r4, r11, 0x3430
	ctx.r[4].s64 = ctx.r[11].s64 + 13360;
	// 828F725C: 484FC7AD  bl 0x82df3a08
	ctx.lr = 0x828F7260;
	sub_82DF3A08(ctx, base);
	// 828F7260: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F7264: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F7268: 388B3424  addi r4, r11, 0x3424
	ctx.r[4].s64 = ctx.r[11].s64 + 13348;
	// 828F726C: 484FC79D  bl 0x82df3a08
	ctx.lr = 0x828F7270;
	sub_82DF3A08(ctx, base);
	// 828F7270: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828F7274: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F7278: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828F727C: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 828F7280: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F7284: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 828F7288: C04B89AC  lfs f2, -0x7654(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828F728C: C02A08A4  lfs f1, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F7290: 4BCAC019  bl 0x825a32a8
	ctx.lr = 0x828F7294;
	sub_825A32A8(ctx, base);
	// 828F7294: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F7298: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828F729C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F72A0: 4BCAA4D1  bl 0x825a1770
	ctx.lr = 0x828F72A4;
	sub_825A1770(ctx, base);
	// 828F72A4: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 828F72A8: 484FC181  bl 0x82df3428
	ctx.lr = 0x828F72AC;
	sub_82DF3428(ctx, base);
	// 828F72AC: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 828F72B0: 4B9D1A09  bl 0x822c8cb8
	ctx.lr = 0x828F72B4;
	sub_822C8CB8(ctx, base);
	// 828F72B4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F72B8: 484FC171  bl 0x82df3428
	ctx.lr = 0x828F72BC;
	sub_82DF3428(ctx, base);
	// 828F72BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F72C0: 484FC169  bl 0x82df3428
	ctx.lr = 0x828F72C4;
	sub_82DF3428(ctx, base);
	// 828F72C4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F72C8: 4BCD2A09  bl 0x825c9cd0
	ctx.lr = 0x828F72CC;
	sub_825C9CD0(ctx, base);
	// 828F72CC: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F72D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F72D4: 419A0008  beq cr6, 0x828f72dc
	if ctx.cr[6].eq {
	pc = 0x828F72DC; continue 'dispatch;
	}
	// 828F72D8: 4B9C95B9  bl 0x822c0890
	ctx.lr = 0x828F72DC;
	sub_822C0890(ctx, base);
	// 828F72DC: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 828F72E0: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828F72E4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828F72E8: 488B0ED4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F72F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F72F0 size=72
    let mut pc: u32 = 0x828F72F0;
    'dispatch: loop {
        match pc {
            0x828F72F0 => {
    //   block [0x828F72F0..0x828F7338)
	// 828F72F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F72F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F72F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F72FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F7300: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F7304: 48565625  bl 0x82e5c928
	ctx.lr = 0x828F7308;
	sub_82E5C928(ctx, base);
	// 828F7308: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F730C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828F7310: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7314: 394A3450  addi r10, r10, 0x3450
	ctx.r[10].s64 = ctx.r[10].s64 + 13392;
	// 828F7318: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F731C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828F7320: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828F7324: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F7328: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F732C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F7330: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F7334: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F7338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F7338 size=60
    let mut pc: u32 = 0x828F7338;
    'dispatch: loop {
        match pc {
            0x828F7338 => {
    //   block [0x828F7338..0x828F7374)
	// 828F7338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F733C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F7340: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F7344: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F7348: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F734C: 4BFFFFA5  bl 0x828f72f0
	ctx.lr = 0x828F7350;
	sub_828F72F0(ctx, base);
	// 828F7350: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F7354: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7358: 396B3478  addi r11, r11, 0x3478
	ctx.r[11].s64 = ctx.r[11].s64 + 13432;
	// 828F735C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F7360: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F7364: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F7368: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F736C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F7370: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F7378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F7378 size=60
    let mut pc: u32 = 0x828F7378;
    'dispatch: loop {
        match pc {
            0x828F7378 => {
    //   block [0x828F7378..0x828F73B4)
	// 828F7378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F737C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F7380: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F7384: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F7388: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F738C: 4BFFFF65  bl 0x828f72f0
	ctx.lr = 0x828F7390;
	sub_828F72F0(ctx, base);
	// 828F7390: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F7394: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7398: 396B34A4  addi r11, r11, 0x34a4
	ctx.r[11].s64 = ctx.r[11].s64 + 13476;
	// 828F739C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F73A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F73A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F73A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F73AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F73B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F73B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F73B8 size=200
    let mut pc: u32 = 0x828F73B8;
    'dispatch: loop {
        match pc {
            0x828F73B8 => {
    //   block [0x828F73B8..0x828F7480)
	// 828F73B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F73BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F73C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F73C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F73C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F73CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F73D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F73D4: 4885D22D  bl 0x83154600
	ctx.lr = 0x828F73D8;
	sub_83154600(ctx, base);
	// 828F73D8: 4BFC1911  bl 0x828b8ce8
	ctx.lr = 0x828F73DC;
	sub_828B8CE8(ctx, base);
	// 828F73DC: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828F73E0: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 828F73E4: 409A003C  bne cr6, 0x828f7420
	if !ctx.cr[6].eq {
	pc = 0x828F7420; continue 'dispatch;
	}
	// 828F73E8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F73EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F73F0: 808B0B08  lwz r4, 0xb08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2824 as u32) ) } as u64;
	// 828F73F4: 484FC615  bl 0x82df3a08
	ctx.lr = 0x828F73F8;
	sub_82DF3A08(ctx, base);
	// 828F73F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F73FC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F7400: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F7404: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F7408: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F740C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828F7410: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F7414: 4856767D  bl 0x82e5ea90
	ctx.lr = 0x828F7418;
	sub_82E5EA90(ctx, base);
	// 828F7418: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828F741C: 48000040  b 0x828f745c
	pc = 0x828F745C; continue 'dispatch;
	// 828F7420: 2F0B000B  cmpwi cr6, r11, 0xb
	ctx.cr[6].compare_i32(ctx.r[11].s32, 11, &mut ctx.xer);
	// 828F7424: 409A0044  bne cr6, 0x828f7468
	if !ctx.cr[6].eq {
	pc = 0x828F7468; continue 'dispatch;
	}
	// 828F7428: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F742C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7430: 808B0B10  lwz r4, 0xb10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2832 as u32) ) } as u64;
	// 828F7434: 484FC5D5  bl 0x82df3a08
	ctx.lr = 0x828F7438;
	sub_82DF3A08(ctx, base);
	// 828F7438: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F743C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F7440: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F7444: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F7448: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F744C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828F7450: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F7454: 4856763D  bl 0x82e5ea90
	ctx.lr = 0x828F7458;
	sub_82E5EA90(ctx, base);
	// 828F7458: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F745C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F7460: 419A0008  beq cr6, 0x828f7468
	if ctx.cr[6].eq {
	pc = 0x828F7468; continue 'dispatch;
	}
	// 828F7464: 4B9C942D  bl 0x822c0890
	ctx.lr = 0x828F7468;
	sub_822C0890(ctx, base);
	// 828F7468: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F746C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F7470: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F7474: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F7478: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F747C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F7480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F7480 size=136
    let mut pc: u32 = 0x828F7480;
    'dispatch: loop {
        match pc {
            0x828F7480 => {
    //   block [0x828F7480..0x828F7508)
	// 828F7480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F7484: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F7488: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F748C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F7490: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F7494: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F7498: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F749C: 4885D165  bl 0x83154600
	ctx.lr = 0x828F74A0;
	sub_83154600(ctx, base);
	// 828F74A0: 4BFC1849  bl 0x828b8ce8
	ctx.lr = 0x828F74A4;
	sub_828B8CE8(ctx, base);
	// 828F74A4: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828F74A8: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 828F74AC: 409A0044  bne cr6, 0x828f74f0
	if !ctx.cr[6].eq {
	pc = 0x828F74F0; continue 'dispatch;
	}
	// 828F74B0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F74B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F74B8: 808B0B08  lwz r4, 0xb08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2824 as u32) ) } as u64;
	// 828F74BC: 484FC54D  bl 0x82df3a08
	ctx.lr = 0x828F74C0;
	sub_82DF3A08(ctx, base);
	// 828F74C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F74C4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F74C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F74CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F74D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F74D4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828F74D8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F74DC: 485675B5  bl 0x82e5ea90
	ctx.lr = 0x828F74E0;
	sub_82E5EA90(ctx, base);
	// 828F74E0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828F74E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F74E8: 419A0008  beq cr6, 0x828f74f0
	if ctx.cr[6].eq {
	pc = 0x828F74F0; continue 'dispatch;
	}
	// 828F74EC: 4B9C93A5  bl 0x822c0890
	ctx.lr = 0x828F74F0;
	sub_822C0890(ctx, base);
	// 828F74F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F74F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F74F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F74FC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F7500: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F7504: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F7508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F7508 size=96
    let mut pc: u32 = 0x828F7508;
    'dispatch: loop {
        match pc {
            0x828F7508 => {
    //   block [0x828F7508..0x828F7568)
	// 828F7508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F750C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F7510: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F7514: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F7518: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F751C: 4BFFFDD5  bl 0x828f72f0
	ctx.lr = 0x828F7520;
	sub_828F72F0(ctx, base);
	// 828F7520: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F7524: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828F7528: 396B3510  addi r11, r11, 0x3510
	ctx.r[11].s64 = ctx.r[11].s64 + 13584;
	// 828F752C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7530: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F7534: 808A0B88  lwz r4, 0xb88(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2952 as u32) ) } as u64;
	// 828F7538: 484FC4D1  bl 0x82df3a08
	ctx.lr = 0x828F753C;
	sub_82DF3A08(ctx, base);
	// 828F753C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7540: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F7544: 485621A5  bl 0x82e596e8
	ctx.lr = 0x828F7548;
	sub_82E596E8(ctx, base);
	// 828F7548: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F754C: 484FBEDD  bl 0x82df3428
	ctx.lr = 0x828F7550;
	sub_82DF3428(ctx, base);
	// 828F7550: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7554: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F7558: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F755C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F7560: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F7564: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F7568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F7568 size=332
    let mut pc: u32 = 0x828F7568;
    'dispatch: loop {
        match pc {
            0x828F7568 => {
    //   block [0x828F7568..0x828F76B4)
	// 828F7568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F756C: 488B0BFD  bl 0x831a8168
	ctx.lr = 0x828F7570;
	sub_831A8130(ctx, base);
	// 828F7570: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828F7574: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F7578: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F757C: 4885D085  bl 0x83154600
	ctx.lr = 0x828F7580;
	sub_83154600(ctx, base);
	// 828F7580: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828F7584: 4BFC1765  bl 0x828b8ce8
	ctx.lr = 0x828F7588;
	sub_828B8CE8(ctx, base);
	// 828F7588: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F758C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F7590: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7594: 808BB3B0  lwz r4, -0x4c50(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19536 as u32) ) } as u64;
	// 828F7598: 484FC471  bl 0x82df3a08
	ctx.lr = 0x828F759C;
	sub_82DF3A08(ctx, base);
	// 828F759C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F75A0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F75A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F75A8: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F75AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F75B0: 4E800421  bctrl
	ctx.lr = 0x828F75B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F75B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F75B8: 484FBE71  bl 0x82df3428
	ctx.lr = 0x828F75BC;
	sub_82DF3428(ctx, base);
	// 828F75BC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F75C0: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828F75C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F75C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F75CC: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828F75D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F75D4: 4E800421  bctrl
	ctx.lr = 0x828F75D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F75D8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F75DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F75E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F75E4: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828F75E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F75EC: 4E800421  bctrl
	ctx.lr = 0x828F75F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F75F0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F75F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F75F8: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828F75FC: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F7600: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F7604: 4E800421  bctrl
	ctx.lr = 0x828F7608;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F7608: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F760C: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 828F7610: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F7614: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F7618: 4E800421  bctrl
	ctx.lr = 0x828F761C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F761C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F7620: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F7624: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F7628: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F762C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F7630: 4E800421  bctrl
	ctx.lr = 0x828F7634;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F7634: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F7638: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F763C: 917D0064  stw r11, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828F7640: 997D0068  stb r11, 0x68(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(104 as u32), ctx.r[11].u8 ) };
	// 828F7644: 4BFC16A5  bl 0x828b8ce8
	ctx.lr = 0x828F7648;
	sub_828B8CE8(ctx, base);
	// 828F7648: 4BFFB4A1  bl 0x828f2ae8
	ctx.lr = 0x828F764C;
	sub_828F2AE8(ctx, base);
	// 828F764C: 3BE30100  addi r31, r3, 0x100
	ctx.r[31].s64 = ctx.r[3].s64 + 256;
	// 828F7650: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F7654: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F7658: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828F765C: C1BF0034  lfs f13, 0x34(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F7660: C19F0038  lfs f12, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828F7664: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F7668: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828F766C: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828F7670: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828F7674: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828F7678: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F767C: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828F7680: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F7684: 4E800421  bctrl
	ctx.lr = 0x828F7688;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F7688: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F768C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F7690: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828F7694: C3FF0028  lfs f31, 0x28(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828F7698: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F769C: 4E800421  bctrl
	ctx.lr = 0x828F76A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F76A0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F76A4: 4BEF2CC5  bl 0x827ea368
	ctx.lr = 0x828F76A8;
	sub_827EA368(ctx, base);
	// 828F76A8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828F76AC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828F76B0: 488B0B08  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F76B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F76B8 size=636
    let mut pc: u32 = 0x828F76B8;
    'dispatch: loop {
        match pc {
            0x828F76B8 => {
    //   block [0x828F76B8..0x828F7934)
	// 828F76B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F76BC: 488B0AAD  bl 0x831a8168
	ctx.lr = 0x828F76C0;
	sub_831A8130(ctx, base);
	// 828F76C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F76C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F76C8: 4885CF39  bl 0x83154600
	ctx.lr = 0x828F76CC;
	sub_83154600(ctx, base);
	// 828F76CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F76D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F76D4: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828F76D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F76DC: 4E800421  bctrl
	ctx.lr = 0x828F76E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F76E0: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F76E4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F76E8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828F76EC: 41980164  blt cr6, 0x828f7850
	if ctx.cr[6].lt {
	pc = 0x828F7850; continue 'dispatch;
	}
	// 828F76F0: 419A0100  beq cr6, 0x828f77f0
	if ctx.cr[6].eq {
	pc = 0x828F77F0; continue 'dispatch;
	}
	// 828F76F4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 828F76F8: 41980044  blt cr6, 0x828f773c
	if ctx.cr[6].lt {
	pc = 0x828F773C; continue 'dispatch;
	}
	// 828F76FC: 409A0230  bne cr6, 0x828f792c
	if !ctx.cr[6].eq {
	pc = 0x828F792C; continue 'dispatch;
	}
	// 828F7700: 4BEF2C11  bl 0x827ea310
	ctx.lr = 0x828F7704;
	sub_827EA310(ctx, base);
	// 828F7704: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F7708: 41820224  beq 0x828f792c
	if ctx.cr[0].eq {
	pc = 0x828F792C; continue 'dispatch;
	}
	// 828F770C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F7710: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7714: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828F7718: 484FC2F1  bl 0x82df3a08
	ctx.lr = 0x828F771C;
	sub_82DF3A08(ctx, base);
	// 828F771C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F7720: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 828F7724: 4885CEDD  bl 0x83154600
	ctx.lr = 0x828F7728;
	sub_83154600(ctx, base);
	// 828F7728: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F772C: 4BEF8015  bl 0x827ef740
	ctx.lr = 0x828F7730;
	sub_827EF740(ctx, base);
	// 828F7730: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7734: 484FBCF5  bl 0x82df3428
	ctx.lr = 0x828F7738;
	sub_82DF3428(ctx, base);
	// 828F7738: 480001F4  b 0x828f792c
	pc = 0x828F792C; continue 'dispatch;
	// 828F773C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F7740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7744: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 828F7748: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F774C: 4E800421  bctrl
	ctx.lr = 0x828F7750;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F7750: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F7754: 418201D8  beq 0x828f792c
	if ctx.cr[0].eq {
	pc = 0x828F792C; continue 'dispatch;
	}
	// 828F7758: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F775C: 4BFC158D  bl 0x828b8ce8
	ctx.lr = 0x828F7760;
	sub_828B8CE8(ctx, base);
	// 828F7760: 4BFFB389  bl 0x828f2ae8
	ctx.lr = 0x828F7764;
	sub_828F2AE8(ctx, base);
	// 828F7764: 897E0068  lbz r11, 0x68(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 828F7768: 3B830100  addi r28, r3, 0x100
	ctx.r[28].s64 = ctx.r[3].s64 + 256;
	// 828F776C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F7770: 4182003C  beq 0x828f77ac
	if ctx.cr[0].eq {
	pc = 0x828F77AC; continue 'dispatch;
	}
	// 828F7774: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F7778: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F777C: 808BB3B8  lwz r4, -0x4c48(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19528 as u32) ) } as u64;
	// 828F7780: 484FC289  bl 0x82df3a08
	ctx.lr = 0x828F7784;
	sub_82DF3A08(ctx, base);
	// 828F7784: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F7788: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828F778C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7790: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F7794: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F7798: 4E800421  bctrl
	ctx.lr = 0x828F779C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F779C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F77A0: 484FBC89  bl 0x82df3428
	ctx.lr = 0x828F77A4;
	sub_82DF3428(ctx, base);
	// 828F77A4: C03C0020  lfs f1, 0x20(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F77A8: 48000038  b 0x828f77e0
	pc = 0x828F77E0; continue 'dispatch;
	// 828F77AC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F77B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F77B4: 808BB3C0  lwz r4, -0x4c40(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19520 as u32) ) } as u64;
	// 828F77B8: 484FC251  bl 0x82df3a08
	ctx.lr = 0x828F77BC;
	sub_82DF3A08(ctx, base);
	// 828F77BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F77C0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828F77C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F77C8: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F77CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F77D0: 4E800421  bctrl
	ctx.lr = 0x828F77D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F77D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F77D8: 484FBC51  bl 0x82df3428
	ctx.lr = 0x828F77DC;
	sub_82DF3428(ctx, base);
	// 828F77DC: C03C0024  lfs f1, 0x24(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F77E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F77E4: 4BEF2B85  bl 0x827ea368
	ctx.lr = 0x828F77E8;
	sub_827EA368(ctx, base);
	// 828F77E8: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 828F77EC: 4800013C  b 0x828f7928
	pc = 0x828F7928; continue 'dispatch;
	// 828F77F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F77F4: 4BEF2B1D  bl 0x827ea310
	ctx.lr = 0x828F77F8;
	sub_827EA310(ctx, base);
	// 828F77F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F77FC: 41820130  beq 0x828f792c
	if ctx.cr[0].eq {
	pc = 0x828F792C; continue 'dispatch;
	}
	// 828F7800: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7804: 4BFC14E5  bl 0x828b8ce8
	ctx.lr = 0x828F7808;
	sub_828B8CE8(ctx, base);
	// 828F7808: 4BFFB2E1  bl 0x828f2ae8
	ctx.lr = 0x828F780C;
	sub_828F2AE8(ctx, base);
	// 828F780C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F7810: 3B830100  addi r28, r3, 0x100
	ctx.r[28].s64 = ctx.r[3].s64 + 256;
	// 828F7814: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828F7818: 808BB3BC  lwz r4, -0x4c44(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19524 as u32) ) } as u64;
	// 828F781C: 484FC1ED  bl 0x82df3a08
	ctx.lr = 0x828F7820;
	sub_82DF3A08(ctx, base);
	// 828F7820: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F7824: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 828F7828: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F782C: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F7830: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F7834: 4E800421  bctrl
	ctx.lr = 0x828F7838;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F7838: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828F783C: 484FBBED  bl 0x82df3428
	ctx.lr = 0x828F7840;
	sub_82DF3428(ctx, base);
	// 828F7840: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F7844: C03C0020  lfs f1, 0x20(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F7848: 4BEF2B21  bl 0x827ea368
	ctx.lr = 0x828F784C;
	sub_827EA368(ctx, base);
	// 828F784C: 480000C0  b 0x828f790c
	pc = 0x828F790C; continue 'dispatch;
	// 828F7850: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F7854: 4BEF2ABD  bl 0x827ea310
	ctx.lr = 0x828F7858;
	sub_827EA310(ctx, base);
	// 828F7858: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F785C: 418200D0  beq 0x828f792c
	if ctx.cr[0].eq {
	pc = 0x828F792C; continue 'dispatch;
	}
	// 828F7860: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7864: 4BFC1485  bl 0x828b8ce8
	ctx.lr = 0x828F7868;
	sub_828B8CE8(ctx, base);
	// 828F7868: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F786C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F7870: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 828F7874: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F7878: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828F787C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F7880: 4E800421  bctrl
	ctx.lr = 0x828F7884;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F7884: 897E0068  lbz r11, 0x68(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 828F7888: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F788C: 41820050  beq 0x828f78dc
	if ctx.cr[0].eq {
	pc = 0x828F78DC; continue 'dispatch;
	}
	// 828F7890: 4BFFB259  bl 0x828f2ae8
	ctx.lr = 0x828F7894;
	sub_828F2AE8(ctx, base);
	// 828F7894: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F7898: 3B830100  addi r28, r3, 0x100
	ctx.r[28].s64 = ctx.r[3].s64 + 256;
	// 828F789C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F78A0: 808BB3B4  lwz r4, -0x4c4c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19532 as u32) ) } as u64;
	// 828F78A4: 484FC165  bl 0x82df3a08
	ctx.lr = 0x828F78A8;
	sub_82DF3A08(ctx, base);
	// 828F78A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F78AC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828F78B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F78B4: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F78B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F78BC: 4E800421  bctrl
	ctx.lr = 0x828F78C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F78C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F78C4: 484FBB65  bl 0x82df3428
	ctx.lr = 0x828F78C8;
	sub_82DF3428(ctx, base);
	// 828F78C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F78CC: C03C0020  lfs f1, 0x20(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F78D0: 4BEF2A99  bl 0x827ea368
	ctx.lr = 0x828F78D4;
	sub_827EA368(ctx, base);
	// 828F78D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F78D8: 48000050  b 0x828f7928
	pc = 0x828F7928; continue 'dispatch;
	// 828F78DC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F78E0: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828F78E4: 808BB3BC  lwz r4, -0x4c44(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19524 as u32) ) } as u64;
	// 828F78E8: 484FC121  bl 0x82df3a08
	ctx.lr = 0x828F78EC;
	sub_82DF3A08(ctx, base);
	// 828F78EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F78F0: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 828F78F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F78F8: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F78FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F7900: 4E800421  bctrl
	ctx.lr = 0x828F7904;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F7904: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828F7908: 484FBB21  bl 0x82df3428
	ctx.lr = 0x828F790C;
	sub_82DF3428(ctx, base);
	// 828F790C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F7910: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7914: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F7918: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F791C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F7920: 4E800421  bctrl
	ctx.lr = 0x828F7924;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F7924: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 828F7928: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828F792C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828F7930: 488B0888  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F7938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F7938 size=120
    let mut pc: u32 = 0x828F7938;
    'dispatch: loop {
        match pc {
            0x828F7938 => {
    //   block [0x828F7938..0x828F79B0)
	// 828F7938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F793C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F7940: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F7944: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F7948: 4885CCB9  bl 0x83154600
	ctx.lr = 0x828F794C;
	sub_83154600(ctx, base);
	// 828F794C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F7950: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F7954: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F7958: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F795C: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F7960: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F7964: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828F7968: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828F796C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828F7970: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828F7974: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F7978: 816B005C  lwz r11, 0x5c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 828F797C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F7980: 4E800421  bctrl
	ctx.lr = 0x828F7984;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F7984: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F7988: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F798C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7990: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F7994: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F7998: 4E800421  bctrl
	ctx.lr = 0x828F799C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F799C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F79A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F79A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F79A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F79AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F79B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F79B0 size=124
    let mut pc: u32 = 0x828F79B0;
    'dispatch: loop {
        match pc {
            0x828F79B0 => {
    //   block [0x828F79B0..0x828F7A2C)
	// 828F79B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F79B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F79B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F79BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F79C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F79C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F79C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F79CC: 4885CC35  bl 0x83154600
	ctx.lr = 0x828F79D0;
	sub_83154600(ctx, base);
	// 828F79D0: 4BFC1319  bl 0x828b8ce8
	ctx.lr = 0x828F79D4;
	sub_828B8CE8(ctx, base);
	// 828F79D4: 4BF6EDF5  bl 0x828667c8
	ctx.lr = 0x828F79D8;
	sub_828667C8(ctx, base);
	// 828F79D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F79DC: 41820034  beq 0x828f7a10
	if ctx.cr[0].eq {
	pc = 0x828F7A10; continue 'dispatch;
	}
	// 828F79E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F79E4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828F79E8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828F79EC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F79F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F79F4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828F79F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F79FC: 4E800421  bctrl
	ctx.lr = 0x828F7A00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F7A00: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F7A04: 4182000C  beq 0x828f7a10
	if ctx.cr[0].eq {
	pc = 0x828F7A10; continue 'dispatch;
	}
	// 828F7A08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F7A0C: 997F0068  stb r11, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u8 ) };
	// 828F7A10: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828F7A14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F7A18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F7A1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F7A20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F7A24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F7A28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F7A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F7A30 size=96
    let mut pc: u32 = 0x828F7A30;
    'dispatch: loop {
        match pc {
            0x828F7A30 => {
    //   block [0x828F7A30..0x828F7A90)
	// 828F7A30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F7A34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F7A38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F7A3C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F7A40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F7A44: 4BFFF8AD  bl 0x828f72f0
	ctx.lr = 0x828F7A48;
	sub_828F72F0(ctx, base);
	// 828F7A48: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F7A4C: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828F7A50: 396B3538  addi r11, r11, 0x3538
	ctx.r[11].s64 = ctx.r[11].s64 + 13624;
	// 828F7A54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7A58: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F7A5C: 808A0B34  lwz r4, 0xb34(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2868 as u32) ) } as u64;
	// 828F7A60: 484FBFA9  bl 0x82df3a08
	ctx.lr = 0x828F7A64;
	sub_82DF3A08(ctx, base);
	// 828F7A64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7A68: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F7A6C: 48561C7D  bl 0x82e596e8
	ctx.lr = 0x828F7A70;
	sub_82E596E8(ctx, base);
	// 828F7A70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7A74: 484FB9B5  bl 0x82df3428
	ctx.lr = 0x828F7A78;
	sub_82DF3428(ctx, base);
	// 828F7A78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7A7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F7A80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F7A84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F7A88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F7A8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F7A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F7A90 size=264
    let mut pc: u32 = 0x828F7A90;
    'dispatch: loop {
        match pc {
            0x828F7A90 => {
    //   block [0x828F7A90..0x828F7B98)
	// 828F7A90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F7A94: 488B06D5  bl 0x831a8168
	ctx.lr = 0x828F7A98;
	sub_831A8130(ctx, base);
	// 828F7A98: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F7A9C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828F7AA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F7AA4: 4885CB5D  bl 0x83154600
	ctx.lr = 0x828F7AA8;
	sub_83154600(ctx, base);
	// 828F7AA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F7AAC: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828F7AB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F7AB4: 4E800421  bctrl
	ctx.lr = 0x828F7AB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F7AB8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F7ABC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F7AC0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F7AC4: 808BB3C4  lwz r4, -0x4c3c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19516 as u32) ) } as u64;
	// 828F7AC8: 484FBF41  bl 0x82df3a08
	ctx.lr = 0x828F7ACC;
	sub_82DF3A08(ctx, base);
	// 828F7ACC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F7AD0: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 828F7AD4: 3BA10054  addi r29, r1, 0x54
	ctx.r[29].s64 = ctx.r[1].s64 + 84;
	// 828F7AD8: 4BEF27D1  bl 0x827ea2a8
	ctx.lr = 0x828F7ADC;
	sub_827EA2A8(ctx, base);
	// 828F7ADC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F7AE0: 484FB829  bl 0x82df3308
	ctx.lr = 0x828F7AE4;
	sub_82DF3308(ctx, base);
	// 828F7AE4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F7AE8: 40820038  bne 0x828f7b20
	if !ctx.cr[0].eq {
	pc = 0x828F7B20; continue 'dispatch;
	}
	// 828F7AEC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F7AF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7AF4: 808BB3C8  lwz r4, -0x4c38(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19512 as u32) ) } as u64;
	// 828F7AF8: 484FBF11  bl 0x82df3a08
	ctx.lr = 0x828F7AFC;
	sub_82DF3A08(ctx, base);
	// 828F7AFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F7B00: 3BE00003  li r31, 3
	ctx.r[31].s64 = 3;
	// 828F7B04: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828F7B08: 4BEF27A1  bl 0x827ea2a8
	ctx.lr = 0x828F7B0C;
	sub_827EA2A8(ctx, base);
	// 828F7B0C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F7B10: 484FB7F9  bl 0x82df3308
	ctx.lr = 0x828F7B14;
	sub_82DF3308(ctx, base);
	// 828F7B14: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F7B18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F7B1C: 41820008  beq 0x828f7b24
	if ctx.cr[0].eq {
	pc = 0x828F7B24; continue 'dispatch;
	}
	// 828F7B20: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F7B24: 57EA07BD  rlwinm. r10, r31, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828F7B28: 557D063E  clrlwi r29, r11, 0x18
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828F7B2C: 41820010  beq 0x828f7b3c
	if ctx.cr[0].eq {
	pc = 0x828F7B3C; continue 'dispatch;
	}
	// 828F7B30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7B34: 57FF07FA  rlwinm r31, r31, 0, 0x1f, 0x1d
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 828F7B38: 484FB8F1  bl 0x82df3428
	ctx.lr = 0x828F7B3C;
	sub_82DF3428(ctx, base);
	// 828F7B3C: 57EB07FF  clrlwi. r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F7B40: 4182000C  beq 0x828f7b4c
	if ctx.cr[0].eq {
	pc = 0x828F7B4C; continue 'dispatch;
	}
	// 828F7B44: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F7B48: 484FB8E1  bl 0x82df3428
	ctx.lr = 0x828F7B4C;
	sub_82DF3428(ctx, base);
	// 828F7B4C: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F7B50: 41820040  beq 0x828f7b90
	if ctx.cr[0].eq {
	pc = 0x828F7B90; continue 'dispatch;
	}
	// 828F7B54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F7B58: 4BEF27B9  bl 0x827ea310
	ctx.lr = 0x828F7B5C;
	sub_827EA310(ctx, base);
	// 828F7B5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F7B60: 41820030  beq 0x828f7b90
	if ctx.cr[0].eq {
	pc = 0x828F7B90; continue 'dispatch;
	}
	// 828F7B64: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F7B68: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F7B6C: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828F7B70: 484FBE99  bl 0x82df3a08
	ctx.lr = 0x828F7B74;
	sub_82DF3A08(ctx, base);
	// 828F7B74: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F7B78: 3BE10054  addi r31, r1, 0x54
	ctx.r[31].s64 = ctx.r[1].s64 + 84;
	// 828F7B7C: 4885CA85  bl 0x83154600
	ctx.lr = 0x828F7B80;
	sub_83154600(ctx, base);
	// 828F7B80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F7B84: 4BEF7BBD  bl 0x827ef740
	ctx.lr = 0x828F7B88;
	sub_827EF740(ctx, base);
	// 828F7B88: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F7B8C: 484FB89D  bl 0x82df3428
	ctx.lr = 0x828F7B90;
	sub_82DF3428(ctx, base);
	// 828F7B90: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F7B94: 488B0624  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F7B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F7B98 size=104
    let mut pc: u32 = 0x828F7B98;
    'dispatch: loop {
        match pc {
            0x828F7B98 => {
    //   block [0x828F7B98..0x828F7C00)
	// 828F7B98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F7B9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F7BA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F7BA4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F7BA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F7BAC: 4BFFF745  bl 0x828f72f0
	ctx.lr = 0x828F7BB0;
	sub_828F72F0(ctx, base);
	// 828F7BB0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F7BB4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828F7BB8: 396B3560  addi r11, r11, 0x3560
	ctx.r[11].s64 = ctx.r[11].s64 + 13664;
	// 828F7BBC: 915F0064  stw r10, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828F7BC0: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828F7BC4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F7BC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7BCC: 808A0B28  lwz r4, 0xb28(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2856 as u32) ) } as u64;
	// 828F7BD0: 484FBE39  bl 0x82df3a08
	ctx.lr = 0x828F7BD4;
	sub_82DF3A08(ctx, base);
	// 828F7BD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7BD8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F7BDC: 48561B0D  bl 0x82e596e8
	ctx.lr = 0x828F7BE0;
	sub_82E596E8(ctx, base);
	// 828F7BE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7BE4: 484FB845  bl 0x82df3428
	ctx.lr = 0x828F7BE8;
	sub_82DF3428(ctx, base);
	// 828F7BE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7BEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F7BF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F7BF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F7BF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F7BFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F7C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F7C00 size=252
    let mut pc: u32 = 0x828F7C00;
    'dispatch: loop {
        match pc {
            0x828F7C00 => {
    //   block [0x828F7C00..0x828F7CFC)
	// 828F7C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F7C04: 488B0561  bl 0x831a8164
	ctx.lr = 0x828F7C08;
	sub_831A8130(ctx, base);
	// 828F7C08: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F7C0C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828F7C10: 4885C9F1  bl 0x83154600
	ctx.lr = 0x828F7C14;
	sub_83154600(ctx, base);
	// 828F7C14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F7C18: 4BFC10D1  bl 0x828b8ce8
	ctx.lr = 0x828F7C1C;
	sub_828B8CE8(ctx, base);
	// 828F7C1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F7C20: 4BFFAEC9  bl 0x828f2ae8
	ctx.lr = 0x828F7C24;
	sub_828F2AE8(ctx, base);
	// 828F7C24: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F7C28: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828F7C2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7C30: 808B0BD8  lwz r4, 0xbd8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3032 as u32) ) } as u64;
	// 828F7C34: 484FBDD5  bl 0x82df3a08
	ctx.lr = 0x828F7C38;
	sub_82DF3A08(ctx, base);
	// 828F7C38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7C3C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F7C40: 4BEF7B31  bl 0x827ef770
	ctx.lr = 0x828F7C44;
	sub_827EF770(ctx, base);
	// 828F7C44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7C48: 484FB7E1  bl 0x82df3428
	ctx.lr = 0x828F7C4C;
	sub_82DF3428(ctx, base);
	// 828F7C4C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F7C50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7C54: 808BB3CC  lwz r4, -0x4c34(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19508 as u32) ) } as u64;
	// 828F7C58: 484FBDB1  bl 0x82df3a08
	ctx.lr = 0x828F7C5C;
	sub_82DF3A08(ctx, base);
	// 828F7C5C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F7C60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7C64: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F7C68: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F7C6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F7C70: 4E800421  bctrl
	ctx.lr = 0x828F7C74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F7C74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7C78: 484FB7B1  bl 0x82df3428
	ctx.lr = 0x828F7C7C;
	sub_82DF3428(ctx, base);
	// 828F7C7C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F7C80: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 828F7C84: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F7C88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F7C8C: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828F7C90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F7C94: 4E800421  bctrl
	ctx.lr = 0x828F7C98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F7C98: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F7C9C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F7CA0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F7CA4: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828F7CA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F7CAC: 4E800421  bctrl
	ctx.lr = 0x828F7CB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F7CB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F7CB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7CB8: 917C0064  stw r11, 0x64(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828F7CBC: C01B003C  lfs f0, 0x3c(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F7CC0: D01C0060  stfs f0, 0x60(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828F7CC4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F7CC8: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F7CCC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F7CD0: 4E800421  bctrl
	ctx.lr = 0x828F7CD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F7CD4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F7CD8: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F7CDC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828F7CE0: 41990014  bgt cr6, 0x828f7cf4
	if ctx.cr[6].gt {
	pc = 0x828F7CF4; continue 'dispatch;
	}
	// 828F7CE4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828F7CE8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828F7CEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7CF0: 4801F331  bl 0x82917020
	ctx.lr = 0x828F7CF4;
	sub_82917020(ctx, base);
	// 828F7CF4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828F7CF8: 488B04BC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F7D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F7D00 size=196
    let mut pc: u32 = 0x828F7D00;
    'dispatch: loop {
        match pc {
            0x828F7D00 => {
    //   block [0x828F7D00..0x828F7DC4)
	// 828F7D00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F7D04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F7D08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F7D0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F7D10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F7D14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F7D18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F7D1C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F7D20: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F7D24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F7D28: 4B9C8C11  bl 0x822c0938
	ctx.lr = 0x828F7D2C;
	sub_822C0938(ctx, base);
	// 828F7D2C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F7D30: 41820028  beq 0x828f7d58
	if ctx.cr[0].eq {
	pc = 0x828F7D58; continue 'dispatch;
	}
	// 828F7D34: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F7D38: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F7D3C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F7D40: 392B34D4  addi r9, r11, 0x34d4
	ctx.r[9].s64 = ctx.r[11].s64 + 13524;
	// 828F7D44: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F7D48: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F7D4C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F7D50: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F7D54: 48000008  b 0x828f7d5c
	pc = 0x828F7D5C; continue 'dispatch;
	// 828F7D58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F7D5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F7D60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F7D64: 409A0044  bne cr6, 0x828f7da8
	if !ctx.cr[6].eq {
	pc = 0x828F7DA8; continue 'dispatch;
	}
	// 828F7D68: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F7D6C: 419A001C  beq cr6, 0x828f7d88
	if ctx.cr[6].eq {
	pc = 0x828F7D88; continue 'dispatch;
	}
	// 828F7D70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F7D74: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F7D78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7D7C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F7D80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F7D84: 4E800421  bctrl
	ctx.lr = 0x828F7D88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F7D88: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F7D8C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F7D90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7D94: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F7D98: 816BB528  lwz r11, -0x4ad8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19160 as u32) ) } as u64;
	// 828F7D9C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F7DA0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F7DA4: 4B9C825D  bl 0x822c0000
	ctx.lr = 0x828F7DA8;
	sub_822C0000(ctx, base);
	// 828F7DA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F7DAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F7DB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F7DB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F7DB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F7DBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F7DC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F7DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F7DC8 size=196
    let mut pc: u32 = 0x828F7DC8;
    'dispatch: loop {
        match pc {
            0x828F7DC8 => {
    //   block [0x828F7DC8..0x828F7E8C)
	// 828F7DC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F7DCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F7DD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F7DD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F7DD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F7DDC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F7DE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F7DE4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F7DE8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F7DEC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F7DF0: 4B9C8B49  bl 0x822c0938
	ctx.lr = 0x828F7DF4;
	sub_822C0938(ctx, base);
	// 828F7DF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F7DF8: 41820028  beq 0x828f7e20
	if ctx.cr[0].eq {
	pc = 0x828F7E20; continue 'dispatch;
	}
	// 828F7DFC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F7E00: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F7E04: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F7E08: 392B34E8  addi r9, r11, 0x34e8
	ctx.r[9].s64 = ctx.r[11].s64 + 13544;
	// 828F7E0C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F7E10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F7E14: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F7E18: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F7E1C: 48000008  b 0x828f7e24
	pc = 0x828F7E24; continue 'dispatch;
	// 828F7E20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F7E24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F7E28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F7E2C: 409A0044  bne cr6, 0x828f7e70
	if !ctx.cr[6].eq {
	pc = 0x828F7E70; continue 'dispatch;
	}
	// 828F7E30: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F7E34: 419A001C  beq cr6, 0x828f7e50
	if ctx.cr[6].eq {
	pc = 0x828F7E50; continue 'dispatch;
	}
	// 828F7E38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F7E3C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F7E40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7E44: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F7E48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F7E4C: 4E800421  bctrl
	ctx.lr = 0x828F7E50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F7E50: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F7E54: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F7E58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7E5C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F7E60: 816BB528  lwz r11, -0x4ad8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19160 as u32) ) } as u64;
	// 828F7E64: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F7E68: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F7E6C: 4B9C8195  bl 0x822c0000
	ctx.lr = 0x828F7E70;
	sub_822C0000(ctx, base);
	// 828F7E70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F7E74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F7E78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F7E7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F7E80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F7E84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F7E88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F7E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F7E90 size=196
    let mut pc: u32 = 0x828F7E90;
    'dispatch: loop {
        match pc {
            0x828F7E90 => {
    //   block [0x828F7E90..0x828F7F54)
	// 828F7E90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F7E94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F7E98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F7E9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F7EA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F7EA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F7EA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F7EAC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F7EB0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F7EB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F7EB8: 4B9C8A81  bl 0x822c0938
	ctx.lr = 0x828F7EBC;
	sub_822C0938(ctx, base);
	// 828F7EBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F7EC0: 41820028  beq 0x828f7ee8
	if ctx.cr[0].eq {
	pc = 0x828F7EE8; continue 'dispatch;
	}
	// 828F7EC4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F7EC8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F7ECC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F7ED0: 392B34FC  addi r9, r11, 0x34fc
	ctx.r[9].s64 = ctx.r[11].s64 + 13564;
	// 828F7ED4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F7ED8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F7EDC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F7EE0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F7EE4: 48000008  b 0x828f7eec
	pc = 0x828F7EEC; continue 'dispatch;
	// 828F7EE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F7EEC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F7EF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F7EF4: 409A0044  bne cr6, 0x828f7f38
	if !ctx.cr[6].eq {
	pc = 0x828F7F38; continue 'dispatch;
	}
	// 828F7EF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F7EFC: 419A001C  beq cr6, 0x828f7f18
	if ctx.cr[6].eq {
	pc = 0x828F7F18; continue 'dispatch;
	}
	// 828F7F00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F7F04: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F7F08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7F0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F7F10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F7F14: 4E800421  bctrl
	ctx.lr = 0x828F7F18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F7F18: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F7F1C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F7F20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7F24: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F7F28: 816BB528  lwz r11, -0x4ad8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19160 as u32) ) } as u64;
	// 828F7F2C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F7F30: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F7F34: 4B9C80CD  bl 0x822c0000
	ctx.lr = 0x828F7F38;
	sub_822C0000(ctx, base);
	// 828F7F38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F7F3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F7F40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F7F44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F7F48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F7F4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F7F50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F7F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F7F58 size=96
    let mut pc: u32 = 0x828F7F58;
    'dispatch: loop {
        match pc {
            0x828F7F58 => {
    //   block [0x828F7F58..0x828F7FB8)
	// 828F7F58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F7F5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F7F60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F7F64: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F7F68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F7F6C: 4BFFF385  bl 0x828f72f0
	ctx.lr = 0x828F7F70;
	sub_828F72F0(ctx, base);
	// 828F7F70: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F7F74: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828F7F78: 396B35B0  addi r11, r11, 0x35b0
	ctx.r[11].s64 = ctx.r[11].s64 + 13744;
	// 828F7F7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7F80: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F7F84: 808A0B08  lwz r4, 0xb08(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2824 as u32) ) } as u64;
	// 828F7F88: 484FBA81  bl 0x82df3a08
	ctx.lr = 0x828F7F8C;
	sub_82DF3A08(ctx, base);
	// 828F7F8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7F90: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F7F94: 48561755  bl 0x82e596e8
	ctx.lr = 0x828F7F98;
	sub_82E596E8(ctx, base);
	// 828F7F98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F7F9C: 484FB48D  bl 0x82df3428
	ctx.lr = 0x828F7FA0;
	sub_82DF3428(ctx, base);
	// 828F7FA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F7FA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F7FA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F7FAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F7FB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F7FB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F7FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F7FB8 size=160
    let mut pc: u32 = 0x828F7FB8;
    'dispatch: loop {
        match pc {
            0x828F7FB8 => {
    //   block [0x828F7FB8..0x828F8058)
	// 828F7FB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F7FBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F7FC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F7FC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F7FC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F7FCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F7FD0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828F7FD4: 897F006C  lbz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 828F7FD8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F7FDC: 41820018  beq 0x828f7ff4
	if ctx.cr[0].eq {
	pc = 0x828F7FF4; continue 'dispatch;
	}
	// 828F7FE0: 48561781  bl 0x82e59760
	ctx.lr = 0x828F7FE4;
	sub_82E59760(ctx, base);
	// 828F7FE4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828F7FE8: C00B9524  lfs f0, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F7FEC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828F7FF0: 40990050  ble cr6, 0x828f8040
	if !ctx.cr[6].gt {
	pc = 0x828F8040; continue 'dispatch;
	}
	// 828F7FF4: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828F7FF8: 2F0B000B  cmpwi cr6, r11, 0xb
	ctx.cr[6].compare_i32(ctx.r[11].s32, 11, &mut ctx.xer);
	// 828F7FFC: 409A0044  bne cr6, 0x828f8040
	if !ctx.cr[6].eq {
	pc = 0x828F8040; continue 'dispatch;
	}
	// 828F8000: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F8004: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F8008: 808B0B10  lwz r4, 0xb10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2832 as u32) ) } as u64;
	// 828F800C: 484FB9FD  bl 0x82df3a08
	ctx.lr = 0x828F8010;
	sub_82DF3A08(ctx, base);
	// 828F8010: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F8014: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828F8018: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F801C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F8020: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F8024: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828F8028: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F802C: 48566A65  bl 0x82e5ea90
	ctx.lr = 0x828F8030;
	sub_82E5EA90(ctx, base);
	// 828F8030: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828F8034: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F8038: 419A0008  beq cr6, 0x828f8040
	if ctx.cr[6].eq {
	pc = 0x828F8040; continue 'dispatch;
	}
	// 828F803C: 4B9C8855  bl 0x822c0890
	ctx.lr = 0x828F8040;
	sub_822C0890(ctx, base);
	// 828F8040: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828F8044: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F8048: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F804C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F8050: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F8054: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F8058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F8058 size=104
    let mut pc: u32 = 0x828F8058;
    'dispatch: loop {
        match pc {
            0x828F8058 => {
    //   block [0x828F8058..0x828F80C0)
	// 828F8058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F805C: 488B0111  bl 0x831a816c
	ctx.lr = 0x828F8060;
	sub_831A8130(ctx, base);
	// 828F8060: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F8064: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828F8068: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F806C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F8070: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F8074: 41820034  beq 0x828f80a8
	if ctx.cr[0].eq {
	pc = 0x828F80A8; continue 'dispatch;
	}
	// 828F8078: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F807C: 488B190D  bl 0x831a9988
	ctx.lr = 0x828F8080;
	sub_831A9988(ctx, base);
	// 828F8080: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 828F8084: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F8088: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 828F808C: 488B006D  bl 0x831a80f8
	ctx.lr = 0x828F8090;
	sub_831A80F8(ctx, base);
	// 828F8090: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F8094: 41820014  beq 0x828f80a8
	if ctx.cr[0].eq {
	pc = 0x828F80A8; continue 'dispatch;
	}
	// 828F8098: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F809C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F80A0: 4BFFF911  bl 0x828f79b0
	ctx.lr = 0x828F80A4;
	sub_828F79B0(ctx, base);
	// 828F80A4: 48000014  b 0x828f80b8
	pc = 0x828F80B8; continue 'dispatch;
	// 828F80A8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828F80AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F80B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F80B4: 488863D5  bl 0x8317e488
	ctx.lr = 0x828F80B8;
	sub_8317E488(ctx, base);
	// 828F80B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F80BC: 488B0100  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F80C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F80C0 size=196
    let mut pc: u32 = 0x828F80C0;
    'dispatch: loop {
        match pc {
            0x828F80C0 => {
    //   block [0x828F80C0..0x828F8184)
	// 828F80C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F80C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F80C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F80CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F80D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F80D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F80D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F80DC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F80E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F80E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F80E8: 4B9C8851  bl 0x822c0938
	ctx.lr = 0x828F80EC;
	sub_822C0938(ctx, base);
	// 828F80EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F80F0: 41820028  beq 0x828f8118
	if ctx.cr[0].eq {
	pc = 0x828F8118; continue 'dispatch;
	}
	// 828F80F4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F80F8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F80FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F8100: 392B3588  addi r9, r11, 0x3588
	ctx.r[9].s64 = ctx.r[11].s64 + 13704;
	// 828F8104: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F8108: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F810C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F8110: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F8114: 48000008  b 0x828f811c
	pc = 0x828F811C; continue 'dispatch;
	// 828F8118: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F811C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F8120: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F8124: 409A0044  bne cr6, 0x828f8168
	if !ctx.cr[6].eq {
	pc = 0x828F8168; continue 'dispatch;
	}
	// 828F8128: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F812C: 419A001C  beq cr6, 0x828f8148
	if ctx.cr[6].eq {
	pc = 0x828F8148; continue 'dispatch;
	}
	// 828F8130: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F8134: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F8138: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F813C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F8140: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F8144: 4E800421  bctrl
	ctx.lr = 0x828F8148;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F8148: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F814C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F8150: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F8154: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F8158: 816BB528  lwz r11, -0x4ad8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19160 as u32) ) } as u64;
	// 828F815C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F8160: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F8164: 4B9C7E9D  bl 0x822c0000
	ctx.lr = 0x828F8168;
	sub_822C0000(ctx, base);
	// 828F8168: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F816C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F8170: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F8174: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F8178: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F817C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F8180: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F8188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F8188 size=196
    let mut pc: u32 = 0x828F8188;
    'dispatch: loop {
        match pc {
            0x828F8188 => {
    //   block [0x828F8188..0x828F824C)
	// 828F8188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F818C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F8190: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F8194: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F8198: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F819C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F81A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F81A4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F81A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F81AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F81B0: 4B9C8789  bl 0x822c0938
	ctx.lr = 0x828F81B4;
	sub_822C0938(ctx, base);
	// 828F81B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F81B8: 41820028  beq 0x828f81e0
	if ctx.cr[0].eq {
	pc = 0x828F81E0; continue 'dispatch;
	}
	// 828F81BC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F81C0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F81C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F81C8: 392B359C  addi r9, r11, 0x359c
	ctx.r[9].s64 = ctx.r[11].s64 + 13724;
	// 828F81CC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F81D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F81D4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F81D8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F81DC: 48000008  b 0x828f81e4
	pc = 0x828F81E4; continue 'dispatch;
	// 828F81E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F81E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F81E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F81EC: 409A0044  bne cr6, 0x828f8230
	if !ctx.cr[6].eq {
	pc = 0x828F8230; continue 'dispatch;
	}
	// 828F81F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F81F4: 419A001C  beq cr6, 0x828f8210
	if ctx.cr[6].eq {
	pc = 0x828F8210; continue 'dispatch;
	}
	// 828F81F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F81FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F8200: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F8204: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F8208: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F820C: 4E800421  bctrl
	ctx.lr = 0x828F8210;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F8210: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F8214: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F8218: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F821C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F8220: 816BB528  lwz r11, -0x4ad8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19160 as u32) ) } as u64;
	// 828F8224: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F8228: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F822C: 4B9C7DD5  bl 0x822c0000
	ctx.lr = 0x828F8230;
	sub_822C0000(ctx, base);
	// 828F8230: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F8234: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F8238: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F823C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F8240: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F8244: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F8248: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F8250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F8250 size=108
    let mut pc: u32 = 0x828F8250;
    'dispatch: loop {
        match pc {
            0x828F8250 => {
    //   block [0x828F8250..0x828F82BC)
	// 828F8250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F8254: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F8258: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F825C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F8260: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F8264: 4BFFF08D  bl 0x828f72f0
	ctx.lr = 0x828F8268;
	sub_828F72F0(ctx, base);
	// 828F8268: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828F826C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F8270: 394A35D8  addi r10, r10, 0x35d8
	ctx.r[10].s64 = ctx.r[10].s64 + 13784;
	// 828F8274: 3D20832D  lis r9, -0x7cd3
	ctx.r[9].s64 = -2094202880;
	// 828F8278: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828F827C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F8280: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828F8284: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828F8288: 80890B30  lwz r4, 0xb30(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2864 as u32) ) } as u64;
	// 828F828C: 484FB77D  bl 0x82df3a08
	ctx.lr = 0x828F8290;
	sub_82DF3A08(ctx, base);
	// 828F8290: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F8294: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F8298: 48561451  bl 0x82e596e8
	ctx.lr = 0x828F829C;
	sub_82E596E8(ctx, base);
	// 828F829C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F82A0: 484FB189  bl 0x82df3428
	ctx.lr = 0x828F82A4;
	sub_82DF3428(ctx, base);
	// 828F82A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F82A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F82AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F82B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F82B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F82B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F82C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F82C0 size=676
    let mut pc: u32 = 0x828F82C0;
    'dispatch: loop {
        match pc {
            0x828F82C0 => {
    //   block [0x828F82C0..0x828F8564)
	// 828F82C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F82C4: 488AFEA1  bl 0x831a8164
	ctx.lr = 0x828F82C8;
	sub_831A8130(ctx, base);
	// 828F82C8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828F82CC: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F82D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F82D4: 4885C32D  bl 0x83154600
	ctx.lr = 0x828F82D8;
	sub_83154600(ctx, base);
	// 828F82D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F82DC: 4BFC0A0D  bl 0x828b8ce8
	ctx.lr = 0x828F82E0;
	sub_828B8CE8(ctx, base);
	// 828F82E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F82E4: 4BFFA805  bl 0x828f2ae8
	ctx.lr = 0x828F82E8;
	sub_828F2AE8(ctx, base);
	// 828F82E8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828F82EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F82F0: 4BFFB0A1  bl 0x828f3390
	ctx.lr = 0x828F82F4;
	sub_828F3390(ctx, base);
	// 828F82F4: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 828F82F8: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828F82FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F8300: 48011289  bl 0x82909588
	ctx.lr = 0x828F8304;
	sub_82909588(ctx, base);
	// 828F8304: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 828F8308: 48048149  bl 0x82940450
	ctx.lr = 0x828F830C;
	sub_82940450(ctx, base);
	// 828F830C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F8310: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F8314: 4804A3BD  bl 0x829426d0
	ctx.lr = 0x828F8318;
	sub_829426D0(ctx, base);
	// 828F8318: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828F831C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F8320: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828F8324: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F8328: 4E800421  bctrl
	ctx.lr = 0x828F832C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F832C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F8330: 41820098  beq 0x828f83c8
	if ctx.cr[0].eq {
	pc = 0x828F83C8; continue 'dispatch;
	}
	// 828F8334: C01C0030  lfs f0, 0x30(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F8338: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F833C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 828F8340: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828F8344: 40980038  bge cr6, 0x828f837c
	if !ctx.cr[6].lt {
	pc = 0x828F837C; continue 'dispatch;
	}
	// 828F8348: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F834C: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828F8350: 484FB6B9  bl 0x82df3a08
	ctx.lr = 0x828F8354;
	sub_82DF3A08(ctx, base);
	// 828F8354: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F8358: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F835C: 4BEF73E5  bl 0x827ef740
	ctx.lr = 0x828F8360;
	sub_827EF740(ctx, base);
	// 828F8360: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F8364: 484FB0C5  bl 0x82df3428
	ctx.lr = 0x828F8368;
	sub_82DF3428(ctx, base);
	// 828F8368: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828F836C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F8370: 419A01E8  beq cr6, 0x828f8558
	if ctx.cr[6].eq {
	pc = 0x828F8558; continue 'dispatch;
	}
	// 828F8374: 4B9C851D  bl 0x822c0890
	ctx.lr = 0x828F8378;
	sub_822C0890(ctx, base);
	// 828F8378: 480001E0  b 0x828f8558
	pc = 0x828F8558; continue 'dispatch;
	// 828F837C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F8380: 808B0B10  lwz r4, 0xb10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2832 as u32) ) } as u64;
	// 828F8384: 484FB685  bl 0x82df3a08
	ctx.lr = 0x828F8388;
	sub_82DF3A08(ctx, base);
	// 828F8388: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F838C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F8390: 4870FD99  bl 0x83008128
	ctx.lr = 0x828F8394;
	sub_83008128(ctx, base);
	// 828F8394: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F8398: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F839C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F83A0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828F83A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F83A8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828F83AC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F83B0: 485665B1  bl 0x82e5e960
	ctx.lr = 0x828F83B4;
	sub_82E5E960(ctx, base);
	// 828F83B4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F83B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F83BC: 419AFFAC  beq cr6, 0x828f8368
	if ctx.cr[6].eq {
	pc = 0x828F8368; continue 'dispatch;
	}
	// 828F83C0: 4B9C84D1  bl 0x822c0890
	ctx.lr = 0x828F83C4;
	sub_822C0890(ctx, base);
	// 828F83C4: 4BFFFFA4  b 0x828f8368
	pc = 0x828F8368; continue 'dispatch;
	// 828F83C8: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828F83CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F83D0: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828F83D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F83D8: 4E800421  bctrl
	ctx.lr = 0x828F83DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F83DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F83E0: 40820048  bne 0x828f8428
	if !ctx.cr[0].eq {
	pc = 0x828F8428; continue 'dispatch;
	}
	// 828F83E4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F83E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F83EC: 808B0B10  lwz r4, 0xb10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2832 as u32) ) } as u64;
	// 828F83F0: 484FB619  bl 0x82df3a08
	ctx.lr = 0x828F83F4;
	sub_82DF3A08(ctx, base);
	// 828F83F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F83F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F83FC: 4870FD2D  bl 0x83008128
	ctx.lr = 0x828F8400;
	sub_83008128(ctx, base);
	// 828F8400: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F8404: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F8408: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828F840C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828F8410: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F8414: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828F8418: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F841C: 48566545  bl 0x82e5e960
	ctx.lr = 0x828F8420;
	sub_82E5E960(ctx, base);
	// 828F8420: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828F8424: 4BFFFF94  b 0x828f83b8
	pc = 0x828F83B8; continue 'dispatch;
	// 828F8428: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828F842C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F8430: 419A0008  beq cr6, 0x828f8438
	if ctx.cr[6].eq {
	pc = 0x828F8438; continue 'dispatch;
	}
	// 828F8434: 4B9C845D  bl 0x822c0890
	ctx.lr = 0x828F8438;
	sub_822C0890(ctx, base);
	// 828F8438: C01C0158  lfs f0, 0x158(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F843C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 828F8440: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828F8444: 4098002C  bge cr6, 0x828f8470
	if !ctx.cr[6].lt {
	pc = 0x828F8470; continue 'dispatch;
	}
	// 828F8448: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F844C: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828F8450: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F8454: 484FB5B5  bl 0x82df3a08
	ctx.lr = 0x828F8458;
	sub_82DF3A08(ctx, base);
	// 828F8458: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F845C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F8460: 4BEF72E1  bl 0x827ef740
	ctx.lr = 0x828F8464;
	sub_827EF740(ctx, base);
	// 828F8464: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F8468: 484FAFC1  bl 0x82df3428
	ctx.lr = 0x828F846C;
	sub_82DF3428(ctx, base);
	// 828F846C: 480000EC  b 0x828f8558
	pc = 0x828F8558; continue 'dispatch;
	// 828F8470: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F8474: 485612ED  bl 0x82e59760
	ctx.lr = 0x828F8478;
	sub_82E59760(ctx, base);
	// 828F8478: 3F608209  lis r27, -0x7df7
	ctx.r[27].s64 = -2113339392;
	// 828F847C: C01B34CC  lfs f0, 0x34cc(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(13516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F8480: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828F8484: 40990020  ble cr6, 0x828f84a4
	if !ctx.cr[6].gt {
	pc = 0x828F84A4; continue 'dispatch;
	}
	// 828F8488: C01C0034  lfs f0, 0x34(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F848C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 828F8490: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 828F8494: 40990010  ble cr6, 0x828f84a4
	if !ctx.cr[6].gt {
	pc = 0x828F84A4; continue 'dispatch;
	}
	// 828F8498: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F849C: 808B0B10  lwz r4, 0xb10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2832 as u32) ) } as u64;
	// 828F84A0: 4BFFFFB0  b 0x828f8450
	pc = 0x828F8450; continue 'dispatch;
	// 828F84A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F84A8: 480110D9  bl 0x82909580
	ctx.lr = 0x828F84AC;
	sub_82909580(ctx, base);
	// 828F84AC: 4802396D  bl 0x8291be18
	ctx.lr = 0x828F84B0;
	sub_8291BE18(ctx, base);
	// 828F84B0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F84B4: 41820014  beq 0x828f84c8
	if ctx.cr[0].eq {
	pc = 0x828F84C8; continue 'dispatch;
	}
	// 828F84B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F84BC: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F84C0: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828F84C4: 4800003C  b 0x828f8500
	pc = 0x828F8500; continue 'dispatch;
	// 828F84C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F84CC: 485612AD  bl 0x82e59778
	ctx.lr = 0x828F84D0;
	sub_82E59778(ctx, base);
	// 828F84D0: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F84D4: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 828F84D8: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828F84DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F84E0: 48561281  bl 0x82e59760
	ctx.lr = 0x828F84E4;
	sub_82E59760(ctx, base);
	// 828F84E4: C01B34CC  lfs f0, 0x34cc(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(13516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F84E8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828F84EC: 40990014  ble cr6, 0x828f8500
	if !ctx.cr[6].gt {
	pc = 0x828F8500; continue 'dispatch;
	}
	// 828F84F0: C01F0060  lfs f0, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F84F4: C1BC0038  lfs f13, 0x38(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F84F8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828F84FC: 4199FF9C  bgt cr6, 0x828f8498
	if ctx.cr[6].gt {
	pc = 0x828F8498; continue 'dispatch;
	}
	// 828F8500: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F8504: 48011085  bl 0x82909588
	ctx.lr = 0x828F8508;
	sub_82909588(ctx, base);
	// 828F8508: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F850C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F8510: 48561269  bl 0x82e59778
	ctx.lr = 0x828F8514;
	sub_82E59778(ctx, base);
	// 828F8514: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F8518: 48047E01  bl 0x82940318
	ctx.lr = 0x828F851C;
	sub_82940318(ctx, base);
	// 828F851C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828F8520: C1BC0048  lfs f13, 0x48(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F8524: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828F8528: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828F852C: C00BCEE4  lfs f0, -0x311c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F8530: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 828F8534: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F8538: 48047CD1  bl 0x82940208
	ctx.lr = 0x828F853C;
	sub_82940208(ctx, base);
	// 828F853C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F8540: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 828F8544: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F8548: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F854C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828F8550: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F8554: 4E800421  bctrl
	ctx.lr = 0x828F8558;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F8558: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828F855C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828F8560: 488AFC54  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F8568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F8568 size=176
    let mut pc: u32 = 0x828F8568;
    'dispatch: loop {
        match pc {
            0x828F8568 => {
    //   block [0x828F8568..0x828F8618)
	// 828F8568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F856C: 488AFBFD  bl 0x831a8168
	ctx.lr = 0x828F8570;
	sub_831A8130(ctx, base);
	// 828F8570: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828F8574: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F8578: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F857C: 4885C085  bl 0x83154600
	ctx.lr = 0x828F8580;
	sub_83154600(ctx, base);
	// 828F8580: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828F8584: 4BFC0765  bl 0x828b8ce8
	ctx.lr = 0x828F8588;
	sub_828B8CE8(ctx, base);
	// 828F8588: 3BC30010  addi r30, r3, 0x10
	ctx.r[30].s64 = ctx.r[3].s64 + 16;
	// 828F858C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F8590: 48010FF9  bl 0x82909588
	ctx.lr = 0x828F8594;
	sub_82909588(ctx, base);
	// 828F8594: 48047F15  bl 0x829404a8
	ctx.lr = 0x828F8598;
	sub_829404A8(ctx, base);
	// 828F8598: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828F859C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F85A0: 83BC0000  lwz r29, 0(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F85A4: 4BEF72AD  bl 0x827ef850
	ctx.lr = 0x828F85A8;
	sub_827EF850(ctx, base);
	// 828F85A8: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828F85AC: 815D0034  lwz r10, 0x34(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 828F85B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828F85B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F85B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F85BC: C02B029C  lfs f1, 0x29c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(668 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F85C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828F85C4: 4E800421  bctrl
	ctx.lr = 0x828F85C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F85C8: 4BFFA521  bl 0x828f2ae8
	ctx.lr = 0x828F85CC;
	sub_828F2AE8(ctx, base);
	// 828F85CC: C3E3000C  lfs f31, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828F85D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F85D4: 48010FAD  bl 0x82909580
	ctx.lr = 0x828F85D8;
	sub_82909580(ctx, base);
	// 828F85D8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F85DC: 48023275  bl 0x8291b850
	ctx.lr = 0x828F85E0;
	sub_8291B850(ctx, base);
	// 828F85E0: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F85E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F85E8: 419A0008  beq cr6, 0x828f85f0
	if ctx.cr[6].eq {
	pc = 0x828F85F0; continue 'dispatch;
	}
	// 828F85EC: 4824E0DD  bl 0x82b466c8
	ctx.lr = 0x828F85F0;
	sub_82B466C8(ctx, base);
	// 828F85F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F85F4: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828F85F8: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 828F85FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F8600: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828F8604: 419A0008  beq cr6, 0x828f860c
	if ctx.cr[6].eq {
	pc = 0x828F860C; continue 'dispatch;
	}
	// 828F8608: 4B9C8289  bl 0x822c0890
	ctx.lr = 0x828F860C;
	sub_822C0890(ctx, base);
	// 828F860C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828F8610: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828F8614: 488AFBA4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F8618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F8618 size=112
    let mut pc: u32 = 0x828F8618;
    'dispatch: loop {
        match pc {
            0x828F8618 => {
    //   block [0x828F8618..0x828F8688)
	// 828F8618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F861C: 488AFB51  bl 0x831a816c
	ctx.lr = 0x828F8620;
	sub_831A8130(ctx, base);
	// 828F8620: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F8624: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F8628: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F862C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F8630: 388B3600  addi r4, r11, 0x3600
	ctx.r[4].s64 = ctx.r[11].s64 + 13824;
	// 828F8634: 38A001CE  li r5, 0x1ce
	ctx.r[5].s64 = 462;
	// 828F8638: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 828F863C: 484F9DAD  bl 0x82df23e8
	ctx.lr = 0x828F8640;
	sub_82DF23E8(ctx, base);
	// 828F8640: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F8644: 41820010  beq 0x828f8654
	if ctx.cr[0].eq {
	pc = 0x828F8654; continue 'dispatch;
	}
	// 828F8648: 4BFFEEC1  bl 0x828f7508
	ctx.lr = 0x828F864C;
	sub_828F7508(ctx, base);
	// 828F864C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F8650: 48000008  b 0x828f8658
	pc = 0x828F8658; continue 'dispatch;
	// 828F8654: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F8658: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F865C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828F8660: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F8664: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F8668: 4BFFF699  bl 0x828f7d00
	ctx.lr = 0x828F866C;
	sub_828F7D00(ctx, base);
	// 828F866C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F8670: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F8674: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F8678: 4B9C7989  bl 0x822c0000
	ctx.lr = 0x828F867C;
	sub_822C0000(ctx, base);
	// 828F867C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F8680: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F8684: 488AFB38  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F8688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828F8688 size=292
    let mut pc: u32 = 0x828F8688;
    'dispatch: loop {
        match pc {
            0x828F8688 => {
    //   block [0x828F8688..0x828F87AC)
	// 828F8688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F868C: 488AFAE1  bl 0x831a816c
	ctx.lr = 0x828F8690;
	sub_831A8130(ctx, base);
	// 828F8690: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F87B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F87B0 size=112
    let mut pc: u32 = 0x828F87B0;
    'dispatch: loop {
        match pc {
            0x828F87B0 => {
    //   block [0x828F87B0..0x828F8820)
	// 828F87B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F87B4: 488AF9B9  bl 0x831a816c
	ctx.lr = 0x828F87B8;
	sub_831A8130(ctx, base);
	// 828F87B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F87BC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F87C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F87C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F87C8: 388B3600  addi r4, r11, 0x3600
	ctx.r[4].s64 = ctx.r[11].s64 + 13824;
	// 828F87CC: 38A00210  li r5, 0x210
	ctx.r[5].s64 = 528;
	// 828F87D0: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828F87D4: 484F9C15  bl 0x82df23e8
	ctx.lr = 0x828F87D8;
	sub_82DF23E8(ctx, base);
	// 828F87D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F87DC: 41820010  beq 0x828f87ec
	if ctx.cr[0].eq {
	pc = 0x828F87EC; continue 'dispatch;
	}
	// 828F87E0: 4BFFF251  bl 0x828f7a30
	ctx.lr = 0x828F87E4;
	sub_828F7A30(ctx, base);
	// 828F87E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F87E8: 48000008  b 0x828f87f0
	pc = 0x828F87F0; continue 'dispatch;
	// 828F87EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F87F0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F87F4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828F87F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F87FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F8800: 4BFFF5C9  bl 0x828f7dc8
	ctx.lr = 0x828F8804;
	sub_828F7DC8(ctx, base);
	// 828F8804: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F8808: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F880C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F8810: 4B9C77F1  bl 0x822c0000
	ctx.lr = 0x828F8814;
	sub_822C0000(ctx, base);
	// 828F8814: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F8818: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F881C: 488AF9A0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F8820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F8820 size=112
    let mut pc: u32 = 0x828F8820;
    'dispatch: loop {
        match pc {
            0x828F8820 => {
    //   block [0x828F8820..0x828F8890)
	// 828F8820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F8824: 488AF949  bl 0x831a816c
	ctx.lr = 0x828F8828;
	sub_831A8130(ctx, base);
	// 828F8828: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F882C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F8830: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F8834: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F8838: 388B3600  addi r4, r11, 0x3600
	ctx.r[4].s64 = ctx.r[11].s64 + 13824;
	// 828F883C: 38A00276  li r5, 0x276
	ctx.r[5].s64 = 630;
	// 828F8840: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 828F8844: 484F9BA5  bl 0x82df23e8
	ctx.lr = 0x828F8848;
	sub_82DF23E8(ctx, base);
	// 828F8848: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F884C: 41820010  beq 0x828f885c
	if ctx.cr[0].eq {
	pc = 0x828F885C; continue 'dispatch;
	}
	// 828F8850: 4BFFF349  bl 0x828f7b98
	ctx.lr = 0x828F8854;
	sub_828F7B98(ctx, base);
	// 828F8854: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F8858: 48000008  b 0x828f8860
	pc = 0x828F8860; continue 'dispatch;
	// 828F885C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F8860: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F8864: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828F8868: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F886C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F8870: 4BFFF621  bl 0x828f7e90
	ctx.lr = 0x828F8874;
	sub_828F7E90(ctx, base);
	// 828F8874: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F8878: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F887C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F8880: 4B9C7781  bl 0x822c0000
	ctx.lr = 0x828F8884;
	sub_822C0000(ctx, base);
	// 828F8884: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F8888: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F888C: 488AF930  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F8890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F8890 size=292
    let mut pc: u32 = 0x828F8890;
    'dispatch: loop {
        match pc {
            0x828F8890 => {
    //   block [0x828F8890..0x828F89B4)
	// 828F8890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F8894: 488AF8D9  bl 0x831a816c
	ctx.lr = 0x828F8898;
	sub_831A8130(ctx, base);
	// 828F8898: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F889C: 4885BD65  bl 0x83154600
	ctx.lr = 0x828F88A0;
	sub_83154600(ctx, base);
	// 828F88A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F88A4: 4BFC0445  bl 0x828b8ce8
	ctx.lr = 0x828F88A8;
	sub_828B8CE8(ctx, base);
	// 828F88A8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F88AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F88B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F88B4: 808BB3F8  lwz r4, -0x4c08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19464 as u32) ) } as u64;
	// 828F88B8: 484FB151  bl 0x82df3a08
	ctx.lr = 0x828F88BC;
	sub_82DF3A08(ctx, base);
	// 828F88BC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F88C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F88C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F88C8: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F88CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F88D0: 4E800421  bctrl
	ctx.lr = 0x828F88D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F88D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F88D8: 484FAB51  bl 0x82df3428
	ctx.lr = 0x828F88DC;
	sub_82DF3428(ctx, base);
	// 828F88DC: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828F88E0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F88E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F88E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F88EC: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828F88F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F88F4: 4E800421  bctrl
	ctx.lr = 0x828F88F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F88F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F88FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F8900: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F8904: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828F8908: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F890C: 4E800421  bctrl
	ctx.lr = 0x828F8910;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F8910: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F8914: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F8918: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828F891C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F8920: 48016459  bl 0x8290ed78
	ctx.lr = 0x828F8924;
	sub_8290ED78(ctx, base);
	// 828F8924: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F8928: 48010BC1  bl 0x829094e8
	ctx.lr = 0x828F892C;
	sub_829094E8(ctx, base);
	// 828F892C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F8930: 4BFFA1B9  bl 0x828f2ae8
	ctx.lr = 0x828F8934;
	sub_828F2AE8(ctx, base);
	// 828F8934: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 828F8938: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F893C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828F8940: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F8944: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F8948: 4BAA1BB1  bl 0x8239a4f8
	ctx.lr = 0x828F894C;
	sub_8239A4F8(ctx, base);
	// 828F894C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F8950: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828F8954: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F8958: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F895C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828F8960: 419A0024  beq cr6, 0x828f8984
	if ctx.cr[6].eq {
	pc = 0x828F8984; continue 'dispatch;
	}
	// 828F8964: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828F8968: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828F896C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F8970: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828F8974: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828F8978: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F897C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F8980: 4082FFE8  bne 0x828f8968
	if !ctx.cr[0].eq {
	pc = 0x828F8968; continue 'dispatch;
	}
	// 828F8984: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828F8988: C05E002C  lfs f2, 0x2c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828F898C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F8990: C03E0028  lfs f1, 0x28(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F8994: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F8998: 48026219  bl 0x8291ebb0
	ctx.lr = 0x828F899C;
	sub_8291EBB0(ctx, base);
	// 828F899C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F89A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F89A4: 419A0008  beq cr6, 0x828f89ac
	if ctx.cr[6].eq {
	pc = 0x828F89AC; continue 'dispatch;
	}
	// 828F89A8: 4B9C7EE9  bl 0x822c0890
	ctx.lr = 0x828F89AC;
	sub_822C0890(ctx, base);
	// 828F89AC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828F89B0: 488AF80C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F89B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F89B8 size=112
    let mut pc: u32 = 0x828F89B8;
    'dispatch: loop {
        match pc {
            0x828F89B8 => {
    //   block [0x828F89B8..0x828F8A28)
	// 828F89B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F89BC: 488AF7B1  bl 0x831a816c
	ctx.lr = 0x828F89C0;
	sub_831A8130(ctx, base);
	// 828F89C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F89C4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F89C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F89CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F89D0: 388B3600  addi r4, r11, 0x3600
	ctx.r[4].s64 = ctx.r[11].s64 + 13824;
	// 828F89D4: 38A00079  li r5, 0x79
	ctx.r[5].s64 = 121;
	// 828F89D8: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828F89DC: 484F9A0D  bl 0x82df23e8
	ctx.lr = 0x828F89E0;
	sub_82DF23E8(ctx, base);
	// 828F89E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F89E4: 41820010  beq 0x828f89f4
	if ctx.cr[0].eq {
	pc = 0x828F89F4; continue 'dispatch;
	}
	// 828F89E8: 4BFFF571  bl 0x828f7f58
	ctx.lr = 0x828F89EC;
	sub_828F7F58(ctx, base);
	// 828F89EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F89F0: 48000008  b 0x828f89f8
	pc = 0x828F89F8; continue 'dispatch;
	// 828F89F4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F89F8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F89FC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828F8A00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F8A04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F8A08: 4BFFF6B9  bl 0x828f80c0
	ctx.lr = 0x828F8A0C;
	sub_828F80C0(ctx, base);
	// 828F8A0C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F8A10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F8A14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F8A18: 4B9C75E9  bl 0x822c0000
	ctx.lr = 0x828F8A1C;
	sub_822C0000(ctx, base);
	// 828F8A1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F8A20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F8A24: 488AF798  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F8A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F8A28 size=432
    let mut pc: u32 = 0x828F8A28;
    'dispatch: loop {
        match pc {
            0x828F8A28 => {
    //   block [0x828F8A28..0x828F8BD8)
	// 828F8A28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F8A2C: 488AF739  bl 0x831a8164
	ctx.lr = 0x828F8A30;
	sub_831A8130(ctx, base);
	// 828F8A30: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828F8A34: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F8A38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F8A3C: 4885BBC5  bl 0x83154600
	ctx.lr = 0x828F8A40;
	sub_83154600(ctx, base);
	// 828F8A40: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F8A44: 4BFC02A5  bl 0x828b8ce8
	ctx.lr = 0x828F8A48;
	sub_828B8CE8(ctx, base);
	// 828F8A48: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F8A4C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F8A50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F8A54: 808BB3F4  lwz r4, -0x4c0c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19468 as u32) ) } as u64;
	// 828F8A58: 484FAFB1  bl 0x82df3a08
	ctx.lr = 0x828F8A5C;
	sub_82DF3A08(ctx, base);
	// 828F8A5C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F8A60: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F8A64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F8A68: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F8A6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F8A70: 4E800421  bctrl
	ctx.lr = 0x828F8A74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F8A74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F8A78: 484FA9B1  bl 0x82df3428
	ctx.lr = 0x828F8A7C;
	sub_82DF3428(ctx, base);
	// 828F8A7C: 3BBD0010  addi r29, r29, 0x10
	ctx.r[29].s64 = ctx.r[29].s64 + 16;
	// 828F8A80: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 828F8A84: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F8A88: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F8A8C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F8A90: 816B018C  lwz r11, 0x18c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(396 as u32) ) } as u64;
	// 828F8A94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F8A98: 4E800421  bctrl
	ctx.lr = 0x828F8A9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F8A9C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F8AA0: 395F0064  addi r10, r31, 0x64
	ctx.r[10].s64 = ctx.r[31].s64 + 100;
	// 828F8AA4: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 828F8AA8: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 828F8AAC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F8AB0: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828F8AB4: 4B9CB9AD  bl 0x822c4460
	ctx.lr = 0x828F8AB8;
	sub_822C4460(ctx, base);
	// 828F8AB8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F8ABC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F8AC0: 419A0008  beq cr6, 0x828f8ac8
	if ctx.cr[6].eq {
	pc = 0x828F8AC8; continue 'dispatch;
	}
	// 828F8AC4: 4B9C7DCD  bl 0x822c0890
	ctx.lr = 0x828F8AC8;
	sub_822C0890(ctx, base);
	// 828F8AC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F8ACC: 48010ABD  bl 0x82909588
	ctx.lr = 0x828F8AD0;
	sub_82909588(ctx, base);
	// 828F8AD0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828F8AD4: 480479D5  bl 0x829404a8
	ctx.lr = 0x828F8AD8;
	sub_829404A8(ctx, base);
	// 828F8AD8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F8ADC: 4804950D  bl 0x82941fe8
	ctx.lr = 0x828F8AE0;
	sub_82941FE8(ctx, base);
	// 828F8AE0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F8AE4: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828F8AE8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F8AEC: 388A3600  addi r4, r10, 0x3600
	ctx.r[4].s64 = ctx.r[10].s64 + 13824;
	// 828F8AF0: 38A000A3  li r5, 0xa3
	ctx.r[5].s64 = 163;
	// 828F8AF4: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F8AF8: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828F8AFC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828F8B00: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828F8B04: 4B9C78D5  bl 0x822c03d8
	ctx.lr = 0x828F8B08;
	sub_822C03D8(ctx, base);
	// 828F8B08: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F8B0C: 41820018  beq 0x828f8b24
	if ctx.cr[0].eq {
	pc = 0x828F8B24; continue 'dispatch;
	}
	// 828F8B10: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828F8B14: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828F8B18: 480494F1  bl 0x82942008
	ctx.lr = 0x828F8B1C;
	sub_82942008(ctx, base);
	// 828F8B1C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828F8B20: 48000008  b 0x828f8b28
	pc = 0x828F8B28; continue 'dispatch;
	// 828F8B24: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828F8B28: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828F8B2C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828F8B30: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F8B34: 4BF752FD  bl 0x8286de30
	ctx.lr = 0x828F8B38;
	sub_8286DE30(ctx, base);
	// 828F8B38: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828F8B3C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828F8B40: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F8B44: 4B9C74BD  bl 0x822c0000
	ctx.lr = 0x828F8B48;
	sub_822C0000(ctx, base);
	// 828F8B48: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828F8B4C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828F8B50: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828F8B54: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828F8B58: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828F8B5C: 419A0024  beq cr6, 0x828f8b80
	if ctx.cr[6].eq {
	pc = 0x828F8B80; continue 'dispatch;
	}
	// 828F8B60: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828F8B64: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828F8B68: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F8B6C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828F8B70: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828F8B74: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828F8B78: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828F8B7C: 4082FFE8  bne 0x828f8b64
	if !ctx.cr[0].eq {
	pc = 0x828F8B64; continue 'dispatch;
	}
	// 828F8B80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F8B84: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828F8B88: 48047929  bl 0x829404b0
	ctx.lr = 0x828F8B8C;
	sub_829404B0(ctx, base);
	// 828F8B8C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828F8B90: 419A000C  beq cr6, 0x828f8b9c
	if ctx.cr[6].eq {
	pc = 0x828F8B9C; continue 'dispatch;
	}
	// 828F8B94: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828F8B98: 4B9C7CF9  bl 0x822c0890
	ctx.lr = 0x828F8B9C;
	sub_822C0890(ctx, base);
	// 828F8B9C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F8BA0: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F8BA4: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828F8BA8: 4BFF9F41  bl 0x828f2ae8
	ctx.lr = 0x828F8BAC;
	sub_828F2AE8(ctx, base);
	// 828F8BAC: C3E30034  lfs f31, 0x34(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828F8BB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F8BB4: 480109CD  bl 0x82909580
	ctx.lr = 0x828F8BB8;
	sub_82909580(ctx, base);
	// 828F8BB8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828F8BBC: 48022C95  bl 0x8291b850
	ctx.lr = 0x828F8BC0;
	sub_8291B850(ctx, base);
	// 828F8BC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F8BC4: 4801DF3D  bl 0x82916b00
	ctx.lr = 0x828F8BC8;
	sub_82916B00(ctx, base);
	// 828F8BC8: 987F006C  stb r3, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[3].u8 ) };
	// 828F8BCC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828F8BD0: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828F8BD4: 488AF5E0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F8BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F8BD8 size=112
    let mut pc: u32 = 0x828F8BD8;
    'dispatch: loop {
        match pc {
            0x828F8BD8 => {
    //   block [0x828F8BD8..0x828F8C48)
	// 828F8BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F8BDC: 488AF591  bl 0x831a816c
	ctx.lr = 0x828F8BE0;
	sub_831A8130(ctx, base);
	// 828F8BE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F8BE4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F8BE8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F8BEC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F8BF0: 388B3600  addi r4, r11, 0x3600
	ctx.r[4].s64 = ctx.r[11].s64 + 13824;
	// 828F8BF4: 38A00128  li r5, 0x128
	ctx.r[5].s64 = 296;
	// 828F8BF8: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 828F8BFC: 484F97ED  bl 0x82df23e8
	ctx.lr = 0x828F8C00;
	sub_82DF23E8(ctx, base);
	// 828F8C00: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F8C04: 41820010  beq 0x828f8c14
	if ctx.cr[0].eq {
	pc = 0x828F8C14; continue 'dispatch;
	}
	// 828F8C08: 4BFFF649  bl 0x828f8250
	ctx.lr = 0x828F8C0C;
	sub_828F8250(ctx, base);
	// 828F8C0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F8C10: 48000008  b 0x828f8c18
	pc = 0x828F8C18; continue 'dispatch;
	// 828F8C14: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F8C18: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F8C1C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828F8C20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F8C24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F8C28: 4BFFF561  bl 0x828f8188
	ctx.lr = 0x828F8C2C;
	sub_828F8188(ctx, base);
	// 828F8C2C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F8C30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F8C34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F8C38: 4B9C73C9  bl 0x822c0000
	ctx.lr = 0x828F8C3C;
	sub_822C0000(ctx, base);
	// 828F8C3C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F8C40: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F8C44: 488AF578  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F8C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F8C48 size=212
    let mut pc: u32 = 0x828F8C48;
    'dispatch: loop {
        match pc {
            0x828F8C48 => {
    //   block [0x828F8C48..0x828F8D1C)
	// 828F8C48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F8C4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F8C50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F8C54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F8C58: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828F8C5C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F8C60: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F8C64: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828F8C68: 4885B999  bl 0x83154600
	ctx.lr = 0x828F8C6C;
	sub_83154600(ctx, base);
	// 828F8C6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F8C70: 4BFC0079  bl 0x828b8ce8
	ctx.lr = 0x828F8C74;
	sub_828B8CE8(ctx, base);
	// 828F8C74: 4BFF9E85  bl 0x828f2af8
	ctx.lr = 0x828F8C78;
	sub_828F2AF8(ctx, base);
	// 828F8C78: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F8C7C: C1BE006C  lfs f13, 0x6c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F8C80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F8C84: EDA06FFC  fnmsubs f13, f0, f31, f13
	ctx.f[13].f64 = -(((ctx.f[0].f64 * ctx.f[31].f64 - ctx.f[13].f64) as f32) as f64);
	// 828F8C88: D1BE006C  stfs f13, 0x6c(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828F8C8C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F8C90: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828F8C94: 41990008  bgt cr6, 0x828f8c9c
	if ctx.cr[6].gt {
	pc = 0x828F8C9C; continue 'dispatch;
	}
	// 828F8C98: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 828F8C9C: D1BE006C  stfs f13, 0x6c(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828F8CA0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828F8CA4: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828F8CA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F8CAC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828F8CB0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828F8CB4: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 828F8CB8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F8CBC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828F8CC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F8CC4: 4E800421  bctrl
	ctx.lr = 0x828F8CC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F8CC8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828F8CCC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828F8CD0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828F8CD4: 48583075  bl 0x82e7bd48
	ctx.lr = 0x828F8CD8;
	sub_82E7BD48(ctx, base);
	// 828F8CD8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F8CDC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 828F8CE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F8CE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F8CE8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F8D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F8D20 size=104
    let mut pc: u32 = 0x828F8D20;
    'dispatch: loop {
        match pc {
            0x828F8D20 => {
    //   block [0x828F8D20..0x828F8D88)
	// 828F8D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F8D24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F8D28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F8D2C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F8D30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F8D34: 4BFFE5BD  bl 0x828f72f0
	ctx.lr = 0x828F8D38;
	sub_828F72F0(ctx, base);
	// 828F8D38: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F8D3C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F8D40: 396B369C  addi r11, r11, 0x369c
	ctx.r[11].s64 = ctx.r[11].s64 + 13980;
	// 828F8D44: 915F0064  stw r10, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 828F8D48: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828F8D4C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F8D50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F8D54: 808AB408  lwz r4, -0x4bf8(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19448 as u32) ) } as u64;
	// 828F8D58: 484FACB1  bl 0x82df3a08
	ctx.lr = 0x828F8D5C;
	sub_82DF3A08(ctx, base);
	// 828F8D5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F8D60: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F8D64: 48560985  bl 0x82e596e8
	ctx.lr = 0x828F8D68;
	sub_82E596E8(ctx, base);
	// 828F8D68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F8D6C: 484FA6BD  bl 0x82df3428
	ctx.lr = 0x828F8D70;
	sub_82DF3428(ctx, base);
	// 828F8D70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F8D74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F8D78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F8D7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F8D80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F8D84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F8D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F8D88 size=364
    let mut pc: u32 = 0x828F8D88;
    'dispatch: loop {
        match pc {
            0x828F8D88 => {
    //   block [0x828F8D88..0x828F8EF4)
	// 828F8D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F8D8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F8D90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F8D94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F8D98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F8D9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F8DA0: 4885B861  bl 0x83154600
	ctx.lr = 0x828F8DA4;
	sub_83154600(ctx, base);
	// 828F8DA4: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828F8DA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F8DAC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828F8DB0: 419800D4  blt cr6, 0x828f8e84
	if ctx.cr[6].lt {
	pc = 0x828F8E84; continue 'dispatch;
	}
	// 828F8DB4: 419A0050  beq cr6, 0x828f8e04
	if ctx.cr[6].eq {
	pc = 0x828F8E04; continue 'dispatch;
	}
	// 828F8DB8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 828F8DBC: 40980120  bge cr6, 0x828f8edc
	if !ctx.cr[6].lt {
	pc = 0x828F8EDC; continue 'dispatch;
	}
	// 828F8DC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F8DC4: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828F8DC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F8DCC: 4E800421  bctrl
	ctx.lr = 0x828F8DD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F8DD0: 4BEF1541  bl 0x827ea310
	ctx.lr = 0x828F8DD4;
	sub_827EA310(ctx, base);
	// 828F8DD4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F8DD8: 41820104  beq 0x828f8edc
	if ctx.cr[0].eq {
	pc = 0x828F8EDC; continue 'dispatch;
	}
	// 828F8DDC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F8DE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F8DE4: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828F8DE8: 484FAC21  bl 0x82df3a08
	ctx.lr = 0x828F8DEC;
	sub_82DF3A08(ctx, base);
	// 828F8DEC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F8DF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F8DF4: 4BEF694D  bl 0x827ef740
	ctx.lr = 0x828F8DF8;
	sub_827EF740(ctx, base);
	// 828F8DF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F8DFC: 484FA62D  bl 0x82df3428
	ctx.lr = 0x828F8E00;
	sub_82DF3428(ctx, base);
	// 828F8E00: 480000DC  b 0x828f8edc
	pc = 0x828F8EDC; continue 'dispatch;
	// 828F8E04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F8E08: 48560971  bl 0x82e59778
	ctx.lr = 0x828F8E0C;
	sub_82E59778(ctx, base);
	// 828F8E0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F8E10: 4BFFFE39  bl 0x828f8c48
	ctx.lr = 0x828F8E14;
	sub_828F8C48(ctx, base);
	// 828F8E14: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F8E18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F8E1C: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 828F8E20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F8E24: 4E800421  bctrl
	ctx.lr = 0x828F8E28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F8E28: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F8E2C: 418200B0  beq 0x828f8edc
	if ctx.cr[0].eq {
	pc = 0x828F8EDC; continue 'dispatch;
	}
	// 828F8E30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F8E34: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 828F8E38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F8E3C: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 828F8E40: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 828F8E44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F8E48: 4E800421  bctrl
	ctx.lr = 0x828F8E4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F8E4C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F8E50: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F8E54: 808BB3AC  lwz r4, -0x4c54(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19540 as u32) ) } as u64;
	// 828F8E58: 484FABB1  bl 0x82df3a08
	ctx.lr = 0x828F8E5C;
	sub_82DF3A08(ctx, base);
	// 828F8E5C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F8E60: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828F8E64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F8E68: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F8E6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F8E70: 4E800421  bctrl
	ctx.lr = 0x828F8E74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F8E74: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828F8E78: 484FA5B1  bl 0x82df3428
	ctx.lr = 0x828F8E7C;
	sub_82DF3428(ctx, base);
	// 828F8E7C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 828F8E80: 48000058  b 0x828f8ed8
	pc = 0x828F8ED8; continue 'dispatch;
	// 828F8E84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F8E88: 485608F1  bl 0x82e59778
	ctx.lr = 0x828F8E8C;
	sub_82E59778(ctx, base);
	// 828F8E8C: C01E0068  lfs f0, 0x68(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F8E90: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 828F8E94: D01E0068  stfs f0, 0x68(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828F8E98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F8E9C: 485608DD  bl 0x82e59778
	ctx.lr = 0x828F8EA0;
	sub_82E59778(ctx, base);
	// 828F8EA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F8EA4: 4BFFFDA5  bl 0x828f8c48
	ctx.lr = 0x828F8EA8;
	sub_828F8C48(ctx, base);
	// 828F8EA8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F8EAC: C1BE0068  lfs f13, 0x68(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F8EB0: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F8EB4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828F8EB8: 40980024  bge cr6, 0x828f8edc
	if !ctx.cr[6].lt {
	pc = 0x828F8EDC; continue 'dispatch;
	}
	// 828F8EBC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F8EC0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F8EC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F8EC8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 828F8ECC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F8ED0: 4E800421  bctrl
	ctx.lr = 0x828F8ED4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F8ED4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828F8ED8: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828F8EDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F8EE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F8EE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F8EE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F8EEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F8EF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F8EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F8EF8 size=196
    let mut pc: u32 = 0x828F8EF8;
    'dispatch: loop {
        match pc {
            0x828F8EF8 => {
    //   block [0x828F8EF8..0x828F8FBC)
	// 828F8EF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F8EFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F8F00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828F8F04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F8F08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F8F0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F8F10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F8F14: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828F8F18: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828F8F1C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F8F20: 4B9C7A19  bl 0x822c0938
	ctx.lr = 0x828F8F24;
	sub_822C0938(ctx, base);
	// 828F8F24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F8F28: 41820028  beq 0x828f8f50
	if ctx.cr[0].eq {
	pc = 0x828F8F50; continue 'dispatch;
	}
	// 828F8F2C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F8F30: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828F8F34: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828F8F38: 392B3688  addi r9, r11, 0x3688
	ctx.r[9].s64 = ctx.r[11].s64 + 13960;
	// 828F8F3C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828F8F40: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828F8F44: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828F8F48: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828F8F4C: 48000008  b 0x828f8f54
	pc = 0x828F8F54; continue 'dispatch;
	// 828F8F50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828F8F54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F8F58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828F8F5C: 409A0044  bne cr6, 0x828f8fa0
	if !ctx.cr[6].eq {
	pc = 0x828F8FA0; continue 'dispatch;
	}
	// 828F8F60: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828F8F64: 419A001C  beq cr6, 0x828f8f80
	if ctx.cr[6].eq {
	pc = 0x828F8F80; continue 'dispatch;
	}
	// 828F8F68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F8F6C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F8F70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F8F74: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828F8F78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F8F7C: 4E800421  bctrl
	ctx.lr = 0x828F8F80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F8F80: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F8F84: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828F8F88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F8F8C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828F8F90: 816BB810  lwz r11, -0x47f0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18416 as u32) ) } as u64;
	// 828F8F94: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828F8F98: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828F8F9C: 4B9C7065  bl 0x822c0000
	ctx.lr = 0x828F8FA0;
	sub_822C0000(ctx, base);
	// 828F8FA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F8FA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F8FA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F8FAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F8FB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828F8FB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F8FB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F8FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F8FC0 size=412
    let mut pc: u32 = 0x828F8FC0;
    'dispatch: loop {
        match pc {
            0x828F8FC0 => {
    //   block [0x828F8FC0..0x828F915C)
	// 828F8FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F8FC4: 488AF1A5  bl 0x831a8168
	ctx.lr = 0x828F8FC8;
	sub_831A8130(ctx, base);
	// 828F8FC8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F8FCC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828F8FD0: 4885B631  bl 0x83154600
	ctx.lr = 0x828F8FD4;
	sub_83154600(ctx, base);
	// 828F8FD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F8FD8: 4BFBFD11  bl 0x828b8ce8
	ctx.lr = 0x828F8FDC;
	sub_828B8CE8(ctx, base);
	// 828F8FDC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F8FE0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F8FE4: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 828F8FE8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828F8FEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F8FF0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F8FF4: 48015D85  bl 0x8290ed78
	ctx.lr = 0x828F8FF8;
	sub_8290ED78(ctx, base);
	// 828F8FF8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828F8FFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F9000: 808BB3A8  lwz r4, -0x4c58(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19544 as u32) ) } as u64;
	// 828F9004: 484FAA05  bl 0x82df3a08
	ctx.lr = 0x828F9008;
	sub_82DF3A08(ctx, base);
	// 828F9008: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F900C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F9010: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9014: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F9018: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F901C: 4E800421  bctrl
	ctx.lr = 0x828F9020;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F9020: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F9024: 484FA405  bl 0x82df3428
	ctx.lr = 0x828F9028;
	sub_82DF3428(ctx, base);
	// 828F9028: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F902C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F9030: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F9034: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828F9038: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F903C: 4E800421  bctrl
	ctx.lr = 0x828F9040;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F9040: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F9044: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F9048: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F904C: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828F9050: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F9054: 4E800421  bctrl
	ctx.lr = 0x828F9058;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F9058: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F905C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828F9060: 38AB36C0  addi r5, r11, 0x36c0
	ctx.r[5].s64 = ctx.r[11].s64 + 14016;
	// 828F9064: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828F9068: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F906C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828F9070: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F9074: 4E800421  bctrl
	ctx.lr = 0x828F9078;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F9078: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828F907C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828F9080: 419A0008  beq cr6, 0x828f9088
	if ctx.cr[6].eq {
	pc = 0x828F9088; continue 'dispatch;
	}
	// 828F9084: 4B9C780D  bl 0x822c0890
	ctx.lr = 0x828F9088;
	sub_822C0890(ctx, base);
	// 828F9088: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F908C: 4BFF9A6D  bl 0x828f2af8
	ctx.lr = 0x828F9090;
	sub_828F2AF8(ctx, base);
	// 828F9090: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828F9094: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F9098: 396BD3D0  addi r11, r11, -0x2c30
	ctx.r[11].s64 = ctx.r[11].s64 + -11312;
	// 828F909C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 828F90A0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828F90A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F90A8: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F90AC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828F90B0: D01C006C  stfs f0, 0x6c(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(108 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F9160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F9160 size=112
    let mut pc: u32 = 0x828F9160;
    'dispatch: loop {
        match pc {
            0x828F9160 => {
    //   block [0x828F9160..0x828F91D0)
	// 828F9160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F9164: 488AF009  bl 0x831a816c
	ctx.lr = 0x828F9168;
	sub_831A8130(ctx, base);
	// 828F9168: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F916C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F9170: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F9174: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828F9178: 388B36D0  addi r4, r11, 0x36d0
	ctx.r[4].s64 = ctx.r[11].s64 + 14032;
	// 828F917C: 38A0009A  li r5, 0x9a
	ctx.r[5].s64 = 154;
	// 828F9180: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 828F9184: 484F9265  bl 0x82df23e8
	ctx.lr = 0x828F9188;
	sub_82DF23E8(ctx, base);
	// 828F9188: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828F918C: 41820010  beq 0x828f919c
	if ctx.cr[0].eq {
	pc = 0x828F919C; continue 'dispatch;
	}
	// 828F9190: 4BFFFB91  bl 0x828f8d20
	ctx.lr = 0x828F9194;
	sub_828F8D20(ctx, base);
	// 828F9194: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F9198: 48000008  b 0x828f91a0
	pc = 0x828F91A0; continue 'dispatch;
	// 828F919C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828F91A0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828F91A4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828F91A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F91AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F91B0: 4BFFFD49  bl 0x828f8ef8
	ctx.lr = 0x828F91B4;
	sub_828F8EF8(ctx, base);
	// 828F91B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828F91B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828F91BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828F91C0: 4B9C6E41  bl 0x822c0000
	ctx.lr = 0x828F91C4;
	sub_822C0000(ctx, base);
	// 828F91C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828F91C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F91CC: 488AEFF0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F91D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F91D0 size=96
    let mut pc: u32 = 0x828F91D0;
    'dispatch: loop {
        match pc {
            0x828F91D0 => {
    //   block [0x828F91D0..0x828F9230)
	// 828F91D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F91D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F91D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828F91DC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F91E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F91E4: 4BFFE10D  bl 0x828f72f0
	ctx.lr = 0x828F91E8;
	sub_828F72F0(ctx, base);
	// 828F91E8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828F91EC: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828F91F0: 396B3758  addi r11, r11, 0x3758
	ctx.r[11].s64 = ctx.r[11].s64 + 14168;
	// 828F91F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F91F8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828F91FC: 808AB404  lwz r4, -0x4bfc(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19452 as u32) ) } as u64;
	// 828F9200: 484FA809  bl 0x82df3a08
	ctx.lr = 0x828F9204;
	sub_82DF3A08(ctx, base);
	// 828F9204: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9208: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F920C: 485604DD  bl 0x82e596e8
	ctx.lr = 0x828F9210;
	sub_82E596E8(ctx, base);
	// 828F9210: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F9214: 484FA215  bl 0x82df3428
	ctx.lr = 0x828F9218;
	sub_82DF3428(ctx, base);
	// 828F9218: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F921C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828F9220: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F9224: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F9228: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828F922C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F9230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828F9230 size=280
    let mut pc: u32 = 0x828F9230;
    'dispatch: loop {
        match pc {
            0x828F9230 => {
    //   block [0x828F9230..0x828F9348)
	// 828F9230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F9234: 488AEF31  bl 0x831a8164
	ctx.lr = 0x828F9238;
	sub_831A8130(ctx, base);
	// 828F9238: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F923C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828F9240: 4885B3C1  bl 0x83154600
	ctx.lr = 0x828F9244;
	sub_83154600(ctx, base);
	// 828F9244: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828F9248: 4BFBFAA1  bl 0x828b8ce8
	ctx.lr = 0x828F924C;
	sub_828B8CE8(ctx, base);
	// 828F924C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F9250: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828F9254: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9258: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828F925C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F9260: 4E800421  bctrl
	ctx.lr = 0x828F9264;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F9264: 3FA0832D  lis r29, -0x7cd3
	ctx.r[29].s64 = -2094202880;
	// 828F9268: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828F926C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F9270: 809DF3F8  lwz r4, -0xc08(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-3080 as u32) ) } as u64;
	// 828F9274: 484FA795  bl 0x82df3a08
	ctx.lr = 0x828F9278;
	sub_82DF3A08(ctx, base);
	// 828F9278: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828F927C: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 828F9280: 4BEF1029  bl 0x827ea2a8
	ctx.lr = 0x828F9284;
	sub_827EA2A8(ctx, base);
	// 828F9284: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828F9288: 484FA019  bl 0x82df32a0
	ctx.lr = 0x828F928C;
	sub_82DF32A0(ctx, base);
	// 828F928C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828F9290: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F9294: 484FA195  bl 0x82df3428
	ctx.lr = 0x828F9298;
	sub_82DF3428(ctx, base);
	// 828F9298: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828F929C: 41820030  beq 0x828f92cc
	if ctx.cr[0].eq {
	pc = 0x828F92CC; continue 'dispatch;
	}
	// 828F92A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F92A4: 809DF3F8  lwz r4, -0xc08(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-3080 as u32) ) } as u64;
	// 828F92A8: 484FA761  bl 0x82df3a08
	ctx.lr = 0x828F92AC;
	sub_82DF3A08(ctx, base);
	// 828F92AC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828F92B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828F92B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F92B8: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828F92BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F92C0: 4E800421  bctrl
	ctx.lr = 0x828F92C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F92C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828F92C8: 484FA161  bl 0x82df3428
	ctx.lr = 0x828F92CC;
	sub_82DF3428(ctx, base);
	// 828F92CC: 4BFF981D  bl 0x828f2ae8
	ctx.lr = 0x828F92D0;
	sub_828F2AE8(ctx, base);
	// 828F92D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828F92D4: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F92D8: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 828F92DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828F92E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F92E4: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828F92E8: 816A0080  lwz r11, 0x80(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 828F92EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F92F0: 4E800421  bctrl
	ctx.lr = 0x828F92F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F92F4: C01D001C  lfs f0, 0x1c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828F92F8: C1BD0018  lfs f13, 0x18(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828F92FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9300: EC01683A  fmadds f0, f1, f0, f13
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 828F9304: D01C0060  stfs f0, 0x60(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828F9308: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F930C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F9310: 816B00D0  lwz r11, 0xd0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 828F9314: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F9318: 4E800421  bctrl
	ctx.lr = 0x828F931C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F931C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828F9320: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F9324: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F9328: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 828F932C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828F9330: 4E800421  bctrl
	ctx.lr = 0x828F9334;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828F9334: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828F9338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828F933C: 4801740D  bl 0x82910748
	ctx.lr = 0x828F9340;
	sub_82910748(ctx, base);
	// 828F9340: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828F9344: 488AEE70  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828F9348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828F9348 size=48
    let mut pc: u32 = 0x828F9348;
    'dispatch: loop {
        match pc {
            0x828F9348 => {
    //   block [0x828F9348..0x828F9378)
	// 828F9348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828F934C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828F9350: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828F9354: 4885B2AD  bl 0x83154600
	ctx.lr = 0x828F9358;
	sub_83154600(ctx, base);
	// 828F9358: 4BFBF991  bl 0x828b8ce8
	ctx.lr = 0x828F935C;
	sub_828B8CE8(ctx, base);
	// 828F935C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828F9360: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 828F9364: 480173E5  bl 0x82910748
	ctx.lr = 0x828F9368;
	sub_82910748(ctx, base);
	// 828F9368: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828F936C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828F9370: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828F9374: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


